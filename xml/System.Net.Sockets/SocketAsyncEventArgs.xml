<Type Name="SocketAsyncEventArgs" FullName="System.Net.Sockets.SocketAsyncEventArgs">
  <Metadata><Meta Name="ms.openlocfilehash" Value="075dbc86ad8b74a8942cad9c1f2bae407a47d22d" /><Meta Name="ms.sourcegitcommit" Value="11d168140aa8fade0768c2a9dde3e3bcacfdfb7d" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-CN" /><Meta Name="ms.lasthandoff" Value="05/27/2020" /><Meta Name="ms.locfileid" Value="83894369" /></Metadata><TypeSignature Language="C#" Value="public class SocketAsyncEventArgs : EventArgs, IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit SocketAsyncEventArgs extends System.EventArgs implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Net.Sockets.SocketAsyncEventArgs" />
  <TypeSignature Language="VB.NET" Value="Public Class SocketAsyncEventArgs&#xA;Inherits EventArgs&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class SocketAsyncEventArgs : EventArgs, IDisposable" />
  <TypeSignature Language="F#" Value="type SocketAsyncEventArgs = class&#xA;    inherit EventArgs&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Net.Sockets</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
    <AssemblyVersion>4.2.2.0</AssemblyVersion>
    <AssemblyVersion>5.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Net</AssemblyName>
  </AssemblyInfo>
  <TypeForwardingChain>
    <TypeForwarding From="netstandard" FromVersion="2.1.0.0" To="System.Net.Sockets" ToVersion="5.0.0.0" FrameworkAlternate="net-5.0" />
    <TypeForwarding From="System.Net" FromVersion="4.0.0.0" To="System" ToVersion="4.0.0.0" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
  </TypeForwardingChain>
  <Base>
    <BaseTypeName>System.EventArgs</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary><span data-ttu-id="b2e37-101">表示异步套接字操作。</span><span class="sxs-lookup"><span data-stu-id="b2e37-101">Represents an asynchronous socket operation.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b2e37-102"><xref:System.Net.Sockets.SocketAsyncEventArgs> 类是对 <xref:System.Net.Sockets.Socket?displayProperty=nameWithType> 类的一组增强功能的一部分，这些增强功能提供了一种可供专用高性能套接字应用程序使用的替代异步模式。</span><span class="sxs-lookup"><span data-stu-id="b2e37-102">The <xref:System.Net.Sockets.SocketAsyncEventArgs> class is part of a set of enhancements to the <xref:System.Net.Sockets.Socket?displayProperty=nameWithType> class that provide an alternative asynchronous pattern that can be used by specialized high-performance socket applications.</span></span> <span data-ttu-id="b2e37-103">此类专为需要高性能的网络服务器应用程序而设计。</span><span class="sxs-lookup"><span data-stu-id="b2e37-103">This class was specifically designed for network server applications that require high performance.</span></span> <span data-ttu-id="b2e37-104">应用程序可以独占方式使用增强的异步模式，也可以仅在目标热点范围内使用（例如，在接收大量数据时）。</span><span class="sxs-lookup"><span data-stu-id="b2e37-104">An application can use the enhanced asynchronous pattern exclusively or only in targeted hot areas (for example, when receiving large amounts of data).</span></span>  
  
 <span data-ttu-id="b2e37-105">这些增强功能的主要功能是避免在大容量异步套接字 I/O 期间重复分配和同步对象。</span><span class="sxs-lookup"><span data-stu-id="b2e37-105">The main feature of these enhancements is the avoidance of the repeated allocation and synchronization of objects during high-volume asynchronous socket I/O.</span></span> <span data-ttu-id="b2e37-106">当前由 <xref:System.Net.Sockets.Socket?displayProperty=nameWithType> 类实现的开始/结束设计模式需要为每个异步套接字操作分配 <xref:System.IAsyncResult?displayProperty=nameWithType> 对象。</span><span class="sxs-lookup"><span data-stu-id="b2e37-106">The Begin/End design pattern currently implemented by the <xref:System.Net.Sockets.Socket?displayProperty=nameWithType> class requires a <xref:System.IAsyncResult?displayProperty=nameWithType> object be allocated for each asynchronous socket operation.</span></span>  
  
 <span data-ttu-id="b2e37-107">在新的 <xref:System.Net.Sockets.Socket?displayProperty=nameWithType> 类增强功能中，异步套接字操作由应用程序分配和维护的可重用 <xref:System.Net.Sockets.SocketAsyncEventArgs> 对象进行描述。</span><span class="sxs-lookup"><span data-stu-id="b2e37-107">In the new <xref:System.Net.Sockets.Socket?displayProperty=nameWithType> class enhancements, asynchronous socket operations are described by reusable <xref:System.Net.Sockets.SocketAsyncEventArgs> objects allocated and maintained by the application.</span></span> <span data-ttu-id="b2e37-108">高性能套接字应用程序非常清楚必须维持的重叠套接字操作的数量。</span><span class="sxs-lookup"><span data-stu-id="b2e37-108">High-performance socket applications know best the amount of overlapped socket operations that must be sustained.</span></span> <span data-ttu-id="b2e37-109">该应用程序可创建所需的 <xref:System.Net.Sockets.SocketAsyncEventArgs> 对象数量。</span><span class="sxs-lookup"><span data-stu-id="b2e37-109">The application can create as many of the <xref:System.Net.Sockets.SocketAsyncEventArgs> objects that it needs.</span></span> <span data-ttu-id="b2e37-110">例如，如果服务器应用程序在任何时间都需要15个套接字接受操作来支持传入的客户端连接速率，则它可以为该目的分配15个可重复使用的 <xref:System.Net.Sockets.SocketAsyncEventArgs> 对象。</span><span class="sxs-lookup"><span data-stu-id="b2e37-110">For example, if a server application needs to have 15 socket accept operations outstanding at all times to support incoming client connection rates, it can allocate 15 reusable <xref:System.Net.Sockets.SocketAsyncEventArgs> objects for that purpose.</span></span>  
  
 <span data-ttu-id="b2e37-111">使用此类执行异步套接字操作的模式包括以下步骤：</span><span class="sxs-lookup"><span data-stu-id="b2e37-111">The pattern for performing an asynchronous socket operation with this class consists of the following steps:</span></span>  
  
1.  <span data-ttu-id="b2e37-112">分配一个新的 <xref:System.Net.Sockets.SocketAsyncEventArgs> 上下文对象，或从应用程序池中获取一个空闲对象。</span><span class="sxs-lookup"><span data-stu-id="b2e37-112">Allocate a new <xref:System.Net.Sockets.SocketAsyncEventArgs> context object, or get a free one from an application pool.</span></span>  
  
2.  <span data-ttu-id="b2e37-113">将上下文对象的属性设置为要执行的操作（例如完成回调方法、数据缓冲区、缓冲区中的偏移量和要传输的最大数据量）。</span><span class="sxs-lookup"><span data-stu-id="b2e37-113">Set properties on the context object to the operation about to be performed (the completion callback method, the data buffer, the offset into the buffer, and the maximum amount of data to transfer, for example).</span></span>  
  
3.  <span data-ttu-id="b2e37-114">调用适当的套接字方法 (xxxAsync) 以启动异步操作。</span><span class="sxs-lookup"><span data-stu-id="b2e37-114">Call the appropriate socket method (xxxAsync) to initiate the asynchronous operation.</span></span>  
  
4.  <span data-ttu-id="b2e37-115">如果异步套接字方法（xxxAsync）在回调中返回 true，则查询上下文属性的完成状态。</span><span class="sxs-lookup"><span data-stu-id="b2e37-115">If the asynchronous socket method (xxxAsync) returns true, in the callback, query the context properties for completion status.</span></span>  
  
5.  <span data-ttu-id="b2e37-116">如果异步套接字方法（xxxAsync）返回 false，则操作同步完成。</span><span class="sxs-lookup"><span data-stu-id="b2e37-116">If the asynchronous socket method (xxxAsync) returns false, the operation completed synchronously.</span></span> <span data-ttu-id="b2e37-117">可查询上下文属性获取操作结果。</span><span class="sxs-lookup"><span data-stu-id="b2e37-117">The context properties may be queried for the operation result.</span></span>  
  
6.  <span data-ttu-id="b2e37-118">重新使用上下文进行另一项操作，将其放回池中，或放弃它。</span><span class="sxs-lookup"><span data-stu-id="b2e37-118">Reuse the context for another operation, put it back in the pool, or discard it.</span></span>  
  
 <span data-ttu-id="b2e37-119">新的异步套接字操作上下文对象的生存期由应用程序代码和异步 i/o 引用的引用确定。</span><span class="sxs-lookup"><span data-stu-id="b2e37-119">The lifetime of the new asynchronous socket operation context object is determined by references by the application code and asynchronous I/O references.</span></span> <span data-ttu-id="b2e37-120">作为参数提交给异步套接字操作方法之一后，应用程序不必保留对异步套接字操作上下文对象的引用。</span><span class="sxs-lookup"><span data-stu-id="b2e37-120">It is not necessary for the application to retain a reference to an asynchronous socket operation context object after it is submitted as a parameter to one of the asynchronous socket operation methods.</span></span> <span data-ttu-id="b2e37-121">完成回调返回之前，应用程序会继续引用它。</span><span class="sxs-lookup"><span data-stu-id="b2e37-121">It will remain referenced until the completion callback returns.</span></span> <span data-ttu-id="b2e37-122">但是，应用程序保留对上下文的引用是有利的，以便以后可以重复使用它进行异步套接字操作。</span><span class="sxs-lookup"><span data-stu-id="b2e37-122">However it is advantageous for the application to retain the reference to the context so that it can be reused for a future asynchronous socket operation.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b2e37-123">下面的代码示例实现使用 <xref:System.Net.Sockets.SocketAsyncEventArgs> 类的套接字服务器的连接逻辑。</span><span class="sxs-lookup"><span data-stu-id="b2e37-123">The following code example implements the connection logic for the socket server that uses the <xref:System.Net.Sockets.SocketAsyncEventArgs> class.</span></span> <span data-ttu-id="b2e37-124">接受连接后，从客户端读取的所有数据都将发送回客户端。</span><span class="sxs-lookup"><span data-stu-id="b2e37-124">After accepting a connection, all data read from the client is sent back to the client.</span></span> <span data-ttu-id="b2e37-125">读取和回显到客户端模式将继续，直到客户端断开连接。</span><span class="sxs-lookup"><span data-stu-id="b2e37-125">The read and echo back to the client pattern is continued until the client disconnects.</span></span> <span data-ttu-id="b2e37-126">此示例使用的 BufferManager 类显示在 <xref:System.Net.Sockets.SocketAsyncEventArgs.SetBuffer%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%29> 方法的代码示例中。</span><span class="sxs-lookup"><span data-stu-id="b2e37-126">The BufferManager class that is used by this example is displayed in the code example for the <xref:System.Net.Sockets.SocketAsyncEventArgs.SetBuffer%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%29> method.</span></span> <span data-ttu-id="b2e37-127">在此示例中使用的 SocketAsyncEventArgsPool 类显示在 <xref:System.Net.Sockets.SocketAsyncEventArgs.%23ctor%2A> 构造函数的代码示例中。</span><span class="sxs-lookup"><span data-stu-id="b2e37-127">The SocketAsyncEventArgsPool class that is used in this example is displayed in the code example for the <xref:System.Net.Sockets.SocketAsyncEventArgs.%23ctor%2A> constructor.</span></span>  
  
 [!code-csharp[NCLAsyncSocketServer#3](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLAsyncSocketServer/CS/AsyncSocketServer.cs#3)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.IAsyncResult" />
    <altmember cref="T:System.Net.Sockets.Socket" />
    <altmember cref="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
    <altmember cref="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
    <altmember cref="M:System.Net.Sockets.Socket.DisconnectAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
    <altmember cref="M:System.Net.Sockets.Socket.ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
    <altmember cref="M:System.Net.Sockets.Socket.ReceiveFromAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
    <altmember cref="M:System.Net.Sockets.Socket.ReceiveMessageFromAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
    <altmember cref="M:System.Net.Sockets.Socket.SendAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
    <altmember cref="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
    <altmember cref="M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
    <related type="Article" href="/dotnet/framework/network-programming/"><span data-ttu-id="b2e37-128">.NET Framework 中的网络编程</span><span class="sxs-lookup"><span data-stu-id="b2e37-128">Network Programming in the .NET Framework</span></span></related>
    <related type="Article" href="/dotnet/framework/network-programming/network-tracing"><span data-ttu-id="b2e37-129">.NET Framework 中的网络跟踪</span><span class="sxs-lookup"><span data-stu-id="b2e37-129">Network Tracing in the .NET Framework</span></span></related>
    <related type="Article" href="/dotnet/framework/network-programming/socket-performance-enhancements-in-version-3-5"><span data-ttu-id="b2e37-130">版本 3.5 中的套接字性能增强</span><span class="sxs-lookup"><span data-stu-id="b2e37-130">Socket Performance Enhancements in Version 3.5</span></span></related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SocketAsyncEventArgs ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.SocketAsyncEventArgs.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SocketAsyncEventArgs();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="b2e37-131">创建一个空的 <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> 实例。</span><span class="sxs-lookup"><span data-stu-id="b2e37-131">Creates an empty <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> instance.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b2e37-132">调用此构造函数后，所有属性都将具有其默认值：</span><span class="sxs-lookup"><span data-stu-id="b2e37-132">After calling this constructor all properties will have their default values:</span></span>  
  
-   <span data-ttu-id="b2e37-133">对象引用将为 null</span><span class="sxs-lookup"><span data-stu-id="b2e37-133">Object references will be null</span></span>  
  
-   <span data-ttu-id="b2e37-134">返回整数的属性将返回零。</span><span class="sxs-lookup"><span data-stu-id="b2e37-134">Properties that return an integer will return zero.</span></span>  
  
-   <span data-ttu-id="b2e37-135"><xref:System.Net.Sockets.SocketAsyncEventArgs.LastOperation%2A> 属性将等于 <xref:System.Net.Sockets.SocketAsyncOperation.None>。</span><span class="sxs-lookup"><span data-stu-id="b2e37-135">The <xref:System.Net.Sockets.SocketAsyncEventArgs.LastOperation%2A> property will be equal to <xref:System.Net.Sockets.SocketAsyncOperation.None>.</span></span>  
  
-   <span data-ttu-id="b2e37-136"><xref:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsFlags%2A> 属性将等于 <xref:System.Net.Sockets.TransmitFileOptions.UseDefaultWorkerThread?displayProperty=nameWithType>，这将不会使用指定的标志。</span><span class="sxs-lookup"><span data-stu-id="b2e37-136">The <xref:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsFlags%2A> property will be equal to <xref:System.Net.Sockets.TransmitFileOptions.UseDefaultWorkerThread?displayProperty=nameWithType>, which specifies no flags will be used.</span></span>  
  
-   <span data-ttu-id="b2e37-137"><xref:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags%2A> 属性将等于 <xref:System.Net.Sockets.SocketAsyncOperation.None>。</span><span class="sxs-lookup"><span data-stu-id="b2e37-137">The <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags%2A> property will be equal to <xref:System.Net.Sockets.SocketAsyncOperation.None>.</span></span>  
  
 <span data-ttu-id="b2e37-138">调用方必须先设置相应的属性，然后才能将对象传递到适当的异步套接字（xxxAsync）方法。</span><span class="sxs-lookup"><span data-stu-id="b2e37-138">The caller must set the appropriate properties prior to passing the object to the appropriate asynchronous socket (xxxAsync) method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b2e37-139">下面的代码示例表示一个可重用 <xref:System.Net.Sockets.SocketAsyncEventArgs> 对象的集合。</span><span class="sxs-lookup"><span data-stu-id="b2e37-139">The following code example represents a collection of reusable <xref:System.Net.Sockets.SocketAsyncEventArgs> objects.</span></span>  
  
 [!code-csharp[NCLAsyncSocketServer#2](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLAsyncSocketServer/CS/AsyncSocketServer.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="b2e37-140">该平台不受支持。</span><span class="sxs-lookup"><span data-stu-id="b2e37-140">The platform is not supported.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SocketAsyncEventArgs (bool unsafeSuppressExecutionContextFlow);" FrameworkAlternate="net-5.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool unsafeSuppressExecutionContextFlow) cil managed" FrameworkAlternate="net-5.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.SocketAsyncEventArgs.#ctor(System.Boolean)" FrameworkAlternate="net-5.0" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (unsafeSuppressExecutionContextFlow As Boolean)" FrameworkAlternate="net-5.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SocketAsyncEventArgs(bool unsafeSuppressExecutionContextFlow);" FrameworkAlternate="net-5.0" />
      <MemberSignature Language="F#" Value="new System.Net.Sockets.SocketAsyncEventArgs : bool -&gt; System.Net.Sockets.SocketAsyncEventArgs" Usage="new System.Net.Sockets.SocketAsyncEventArgs unsafeSuppressExecutionContextFlow" FrameworkAlternate="net-5.0" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="unsafeSuppressExecutionContextFlow" Type="System.Boolean" Index="0" FrameworkAlternate="net-5.0" />
      </Parameters>
      <Docs>
        <param name="unsafeSuppressExecutionContextFlow">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AcceptSocket">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.Socket AcceptSocket { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.Sockets.Socket AcceptSocket" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.SocketAsyncEventArgs.AcceptSocket" />
      <MemberSignature Language="VB.NET" Value="Public Property AcceptSocket As Socket" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Sockets::Socket ^ AcceptSocket { System::Net::Sockets::Socket ^ get(); void set(System::Net::Sockets::Socket ^ value); };" />
      <MemberSignature Language="F#" Value="member this.AcceptSocket : System.Net.Sockets.Socket with get, set" Usage="System.Net.Sockets.SocketAsyncEventArgs.AcceptSocket" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.Socket</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="b2e37-141">获取或设置要使用的套接字或创建用于接受与异步套接字方法的连接的套接字。</span><span class="sxs-lookup"><span data-stu-id="b2e37-141">Gets or sets the socket to use or the socket created for accepting a connection with an asynchronous socket method.</span></span></summary>
        <value><span data-ttu-id="b2e37-142">要使用的 <see cref="T:System.Net.Sockets.Socket" /> 或者创建用于接受与异步套接字方法的连接的套接字。</span><span class="sxs-lookup"><span data-stu-id="b2e37-142">The <see cref="T:System.Net.Sockets.Socket" /> to use or the socket created for accepting a connection with an asynchronous socket method.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b2e37-143">此属性可用于提供已创建的、将用于异步套接字接受操作的 <xref:System.Net.Sockets.Socket>。</span><span class="sxs-lookup"><span data-stu-id="b2e37-143">This property can be used to provide an already created <xref:System.Net.Sockets.Socket> that will be used for an asynchronous socket accept operation.</span></span> <span data-ttu-id="b2e37-144">在接受操作完成后，它是表示接受的连接的套接字。</span><span class="sxs-lookup"><span data-stu-id="b2e37-144">Upon completion of the accept operation, it is the socket representing the accepted connection.</span></span> <span data-ttu-id="b2e37-145">如果在调用 <xref:System.Net.Sockets.Socket.AcceptAsync%2A?displayProperty=nameWithType> 方法之前未提供（设置为 null），则将自动创建新的套接字，并使用此属性在完成回调中访问。</span><span class="sxs-lookup"><span data-stu-id="b2e37-145">If not supplied (set to null) before calling the <xref:System.Net.Sockets.Socket.AcceptAsync%2A?displayProperty=nameWithType> method, a new socket will be created automatically and be accessible in the completion callback with this property.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="Buffer">
      <MemberSignature Language="C#" Value="public byte[] Buffer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance unsigned int8[] Buffer" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Buffer As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::Byte&gt; ^ Buffer { cli::array &lt;System::Byte&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Buffer : byte[]" Usage="System.Net.Sockets.SocketAsyncEventArgs.Buffer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="b2e37-146">获取要用于异步套接字方法的数据缓冲区。</span><span class="sxs-lookup"><span data-stu-id="b2e37-146">Gets the data buffer to use with an asynchronous socket method.</span></span></summary>
        <value><span data-ttu-id="b2e37-147">一个 <see cref="T:System.Byte" /> 数组，表示要用于异步套接字方法的数据缓冲区。</span><span class="sxs-lookup"><span data-stu-id="b2e37-147">A <see cref="T:System.Byte" /> array that represents the data buffer to use with an asynchronous socket method.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b2e37-148">此属性获取当前与 <xref:System.Net.Sockets.SocketAsyncEventArgs> 实例关联的数据缓冲区。</span><span class="sxs-lookup"><span data-stu-id="b2e37-148">This property gets the data buffer currently associated with the <xref:System.Net.Sockets.SocketAsyncEventArgs> instance.</span></span> <span data-ttu-id="b2e37-149">若要设置缓冲区，必须使用 <xref:System.Net.Sockets.SocketAsyncEventArgs.SetBuffer%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="b2e37-149">To set the buffer, the <xref:System.Net.Sockets.SocketAsyncEventArgs.SetBuffer%2A> method must be used.</span></span>  
  
 <span data-ttu-id="b2e37-150">此属性与 <xref:System.Net.Sockets.Socket.AcceptAsync%2A?displayProperty=nameWithType>、<xref:System.Net.Sockets.Socket.ConnectAsync%2A?displayProperty=nameWithType>、<xref:System.Net.Sockets.Socket.ReceiveAsync%2A?displayProperty=nameWithType>、<xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A?displayProperty=nameWithType>、<xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A?displayProperty=nameWithType>、<xref:System.Net.Sockets.Socket.SendAsync%2A?displayProperty=nameWithType>和 <xref:System.Net.Sockets.Socket.SendToAsync%2A?displayProperty=nameWithType> 方法一起使用。</span><span class="sxs-lookup"><span data-stu-id="b2e37-150">This property is used with the <xref:System.Net.Sockets.Socket.AcceptAsync%2A?displayProperty=nameWithType>, <xref:System.Net.Sockets.Socket.ConnectAsync%2A?displayProperty=nameWithType>, <xref:System.Net.Sockets.Socket.ReceiveAsync%2A?displayProperty=nameWithType>, <xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A?displayProperty=nameWithType>, <xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A?displayProperty=nameWithType>, <xref:System.Net.Sockets.Socket.SendAsync%2A?displayProperty=nameWithType>, and <xref:System.Net.Sockets.Socket.SendToAsync%2A?displayProperty=nameWithType> methods.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
        <altmember cref="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFromAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveMessageFromAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
        <altmember cref="Overload:System.Net.Sockets.SocketAsyncEventArgs.SetBuffer" />
      </Docs>
    </Member>
    <Member MemberName="BufferList">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; BufferList { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; BufferList" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" />
      <MemberSignature Language="VB.NET" Value="Public Property BufferList As IList(Of ArraySegment(Of Byte))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ BufferList { System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ get(); void set(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ value); };" />
      <MemberSignature Language="F#" Value="member this.BufferList : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; with get, set" Usage="System.Net.Sockets.SocketAsyncEventArgs.BufferList" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="b2e37-151">获取或设置一个要用于异步套接字方法的数据缓冲区数组。</span><span class="sxs-lookup"><span data-stu-id="b2e37-151">Gets or sets an array of data buffers to use with an asynchronous socket method.</span></span></summary>
        <value><span data-ttu-id="b2e37-152">一个 <see cref="T:System.Collections.IList" />，表示要用于异步套接字方法的数据缓冲区数组。</span><span class="sxs-lookup"><span data-stu-id="b2e37-152">An <see cref="T:System.Collections.IList" /> that represents an array of data buffers to use with an asynchronous socket method.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b2e37-153">此属性与 <xref:System.Net.Sockets.Socket.ReceiveAsync%2A?displayProperty=nameWithType> 和 <xref:System.Net.Sockets.Socket.SendAsync%2A?displayProperty=nameWithType> 方法一起使用。</span><span class="sxs-lookup"><span data-stu-id="b2e37-153">This property is used with the <xref:System.Net.Sockets.Socket.ReceiveAsync%2A?displayProperty=nameWithType> and <xref:System.Net.Sockets.Socket.SendAsync%2A?displayProperty=nameWithType> methods.</span></span>  
  
 <span data-ttu-id="b2e37-154">此属性用于提供要发送的多个数据缓冲区，或者提供多个缓冲区，以便在其中存储可以发送或接收数据的异步套接字操作的接收数据。</span><span class="sxs-lookup"><span data-stu-id="b2e37-154">This property is used to provide multiple buffers of data to be sent or to provide multiple buffers in which to store received data for an asynchronous socket operation that can send or receive data.</span></span> <span data-ttu-id="b2e37-155"><xref:System.Net.Sockets.Socket.ReceiveAsync%2A?displayProperty=nameWithType> 和 <xref:System.Net.Sockets.Socket.SendAsync%2A?displayProperty=nameWithType> 方法支持使用 <xref:System.Net.Sockets.SocketAsyncEventArgs.BufferList%2A> 属性的多个缓冲区。</span><span class="sxs-lookup"><span data-stu-id="b2e37-155">Multiple buffers using the <xref:System.Net.Sockets.SocketAsyncEventArgs.BufferList%2A> property are supported by the <xref:System.Net.Sockets.Socket.ReceiveAsync%2A?displayProperty=nameWithType> and <xref:System.Net.Sockets.Socket.SendAsync%2A?displayProperty=nameWithType> methods.</span></span>  
  
 <span data-ttu-id="b2e37-156">如果 <xref:System.Net.Sockets.SocketAsyncEventArgs.BufferList%2A> 属性设置为非 null 值，则 <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A> 属性必须为 null，并且 <xref:System.Net.Sockets.Socket.ReceiveAsync%2A?displayProperty=nameWithType> 和 <xref:System.Net.Sockets.Socket.SendAsync%2A?displayProperty=nameWithType> 方法将忽略该属性。</span><span class="sxs-lookup"><span data-stu-id="b2e37-156">If the <xref:System.Net.Sockets.SocketAsyncEventArgs.BufferList%2A> property is set to a non-null value, the <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A> property must be null and is ignored by the <xref:System.Net.Sockets.Socket.ReceiveAsync%2A?displayProperty=nameWithType> and <xref:System.Net.Sockets.Socket.SendAsync%2A?displayProperty=nameWithType> methods.</span></span>  
  
 <span data-ttu-id="b2e37-157">如果 <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A> 设置为非 null 值，而尝试将 <xref:System.Net.Sockets.SocketAsyncEventArgs.BufferList%2A> 属性设置为非 null 值，则会引发异常。</span><span class="sxs-lookup"><span data-stu-id="b2e37-157">If the <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A> was set to a non-null value and an attempt is made to set the <xref:System.Net.Sockets.SocketAsyncEventArgs.BufferList%2A> property to a non-null value, an exception is thrown.</span></span>  
  
 <span data-ttu-id="b2e37-158">如果 <xref:System.Net.Sockets.SocketAsyncEventArgs.BufferList%2A> 属性设置为非 null 值，则 <xref:System.Net.Sockets.Socket.ConnectAsync%2A?displayProperty=nameWithType> 和 <xref:System.Net.Sockets.Socket.AcceptAsync%2A?displayProperty=nameWithType> 方法将引发 <xref:System.ArgumentException>。</span><span class="sxs-lookup"><span data-stu-id="b2e37-158">If the <xref:System.Net.Sockets.SocketAsyncEventArgs.BufferList%2A> property is set to a non-null value, the <xref:System.Net.Sockets.Socket.ConnectAsync%2A?displayProperty=nameWithType> and <xref:System.Net.Sockets.Socket.AcceptAsync%2A?displayProperty=nameWithType> methods will throw an <xref:System.ArgumentException>.</span></span>  
  
 <span data-ttu-id="b2e37-159"><xref:System.Net.Sockets.SocketAsyncEventArgs.BufferList%2A> 参数将被 <xref:System.Net.Sockets.Socket.DisconnectAsync%2A?displayProperty=nameWithType> 和 <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A?displayProperty=nameWithType> 方法忽略。</span><span class="sxs-lookup"><span data-stu-id="b2e37-159">The <xref:System.Net.Sockets.SocketAsyncEventArgs.BufferList%2A> parameter is ignored by the <xref:System.Net.Sockets.Socket.DisconnectAsync%2A?displayProperty=nameWithType> and <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A?displayProperty=nameWithType> methods.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="b2e37-160">存在不明确的缓冲区，这些缓冲区是在 set 操作上指定的。</span><span class="sxs-lookup"><span data-stu-id="b2e37-160">There are ambiguous buffers specified on a set operation.</span></span> <span data-ttu-id="b2e37-161">如果 <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" /> 属性已设置为非空值并且尝试将 <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /> 属性设置为非空值，将引发此异常。</span><span class="sxs-lookup"><span data-stu-id="b2e37-161">This exception occurs if the <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" /> property has been set to a non-null value and an attempt was made to set the <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /> property to a non-null value.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />
      </Docs>
    </Member>
    <Member MemberName="BytesTransferred">
      <MemberSignature Language="C#" Value="public int BytesTransferred { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 BytesTransferred" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.SocketAsyncEventArgs.BytesTransferred" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property BytesTransferred As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int BytesTransferred { int get(); };" />
      <MemberSignature Language="F#" Value="member this.BytesTransferred : int" Usage="System.Net.Sockets.SocketAsyncEventArgs.BytesTransferred" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="b2e37-162">获取在套接字操作中传输的字节数。</span><span class="sxs-lookup"><span data-stu-id="b2e37-162">Gets the number of bytes transferred in the socket operation.</span></span></summary>
        <value><span data-ttu-id="b2e37-163">一个 <see cref="T:System.Int32" />，包含在套接字操作中传输的字节数。</span><span class="sxs-lookup"><span data-stu-id="b2e37-163">An <see cref="T:System.Int32" /> that contains the number of bytes transferred in the socket operation.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b2e37-164">此属性提供可接收或发送数据的异步套接字操作中传输的字节数。</span><span class="sxs-lookup"><span data-stu-id="b2e37-164">This property provides the number of bytes transferred in an asynchronous socket operation that can receive or send data.</span></span> <span data-ttu-id="b2e37-165">如果从读取操作返回零，则远程端已关闭连接。</span><span class="sxs-lookup"><span data-stu-id="b2e37-165">If zero is returned from a read operation, the remote end has closed the connection.</span></span>  
  
 <span data-ttu-id="b2e37-166">此属性由除 <xref:System.Net.Sockets.Socket.DisconnectAsync%2A?displayProperty=nameWithType> 方法之外的所有异步套接字操作设置。</span><span class="sxs-lookup"><span data-stu-id="b2e37-166">This property is set by all asynchronous socket operations except the <xref:System.Net.Sockets.Socket.DisconnectAsync%2A?displayProperty=nameWithType> method.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
        <altmember cref="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFromAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveMessageFromAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="Completed">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Net.Sockets.SocketAsyncEventArgs&gt; Completed;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Net.Sockets.SocketAsyncEventArgs&gt; Completed" />
      <MemberSignature Language="DocId" Value="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Completed As EventHandler(Of SocketAsyncEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Net::Sockets::SocketAsyncEventArgs ^&gt; ^ Completed;" />
      <MemberSignature Language="F#" Value="member this.Completed : EventHandler&lt;System.Net.Sockets.SocketAsyncEventArgs&gt; " Usage="member this.Completed : System.EventHandler&lt;System.Net.Sockets.SocketAsyncEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Net.Sockets.SocketAsyncEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="b2e37-167">用于完成异步操作的事件。</span><span class="sxs-lookup"><span data-stu-id="b2e37-167">The event used to complete an asynchronous operation.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b2e37-168"><xref:System.Net.Sockets.SocketAsyncEventArgs.Completed> 事件为客户端应用程序提供了一种完成异步套接字操作的方法。</span><span class="sxs-lookup"><span data-stu-id="b2e37-168">The <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed> event provides a way for client applications to complete an asynchronous socket operation.</span></span> <span data-ttu-id="b2e37-169">当异步套接字操作启动时，事件处理程序应附加到 <xref:System.Net.Sockets.SocketAsyncEventArgs> 实例中的事件，否则应用程序将无法确定操作完成的时间。</span><span class="sxs-lookup"><span data-stu-id="b2e37-169">An event handler should be attached to the event within a <xref:System.Net.Sockets.SocketAsyncEventArgs> instance when an asynchronous socket operation is initiated, otherwise the application will not be able to determine when the operation completes.</span></span>  
  
 <span data-ttu-id="b2e37-170"><xref:System.Net.Sockets.SocketAsyncEventArgs.Completed> 事件引用的完成回调委托包含处理客户端的异步套接字操作的程序逻辑。</span><span class="sxs-lookup"><span data-stu-id="b2e37-170">The completion callback delegates referenced by the <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed> event contains program logic to finish processing the asynchronous socket operation for the client.</span></span>  
  
 <span data-ttu-id="b2e37-171">当事件收到信号时，应用程序将使用 <xref:System.Net.Sockets.SocketAsyncEventArgs> 的对象参数获取已完成的异步套接字操作的状态。</span><span class="sxs-lookup"><span data-stu-id="b2e37-171">When the event is signaled, the application uses the <xref:System.Net.Sockets.SocketAsyncEventArgs> object parameter to obtain the status of the completed asynchronous socket operation.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ConnectByNameError">
      <MemberSignature Language="C#" Value="public Exception ConnectByNameError { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Exception ConnectByNameError" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.SocketAsyncEventArgs.ConnectByNameError" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ConnectByNameError As Exception" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Exception ^ ConnectByNameError { Exception ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ConnectByNameError : Exception" Usage="System.Net.Sockets.SocketAsyncEventArgs.ConnectByNameError" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Exception</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="b2e37-172">当使用 <see cref="T:System.Net.DnsEndPoint" /> 时，在出现连接故障的情况下获取异常。</span><span class="sxs-lookup"><span data-stu-id="b2e37-172">Gets the exception in the case of a connection failure when a <see cref="T:System.Net.DnsEndPoint" /> was used.</span></span></summary>
        <value><span data-ttu-id="b2e37-173">一个 <see cref="T:System.Exception" />，指示在为 <see cref="T:System.Net.DnsEndPoint" /> 属性指定 <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> 时发生连接错误的原因。</span><span class="sxs-lookup"><span data-stu-id="b2e37-173">An <see cref="T:System.Exception" /> that indicates the cause of the connection error when a <see cref="T:System.Net.DnsEndPoint" /> was specified for the <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> property.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b2e37-174">如果在连接失败的情况下为 <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A> 属性指定了 <xref:System.Net.DnsEndPoint>，<xref:System.Net.Sockets.SocketAsyncEventArgs.ConnectByNameError%2A> 属性将包含指示套接字错误的详细原因的异常。</span><span class="sxs-lookup"><span data-stu-id="b2e37-174">In the case of a connection failure when a <xref:System.Net.DnsEndPoint> was specified for the <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A> property, the <xref:System.Net.Sockets.SocketAsyncEventArgs.ConnectByNameError%2A> property will contain the exception that indicates the detailed cause of the socket error.</span></span>  
  
 <span data-ttu-id="b2e37-175">如果为 <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A> 属性指定了 <xref:System.Net.IPEndPoint>，并且连接失败，<xref:System.Net.Sockets.SocketAsyncEventArgs.ConnectByNameError%2A> 属性将为 `null` 引用。</span><span class="sxs-lookup"><span data-stu-id="b2e37-175">When an <xref:System.Net.IPEndPoint> was specified for the <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A> property and a connection failure occurs, the <xref:System.Net.Sockets.SocketAsyncEventArgs.ConnectByNameError%2A> property will be a `null` reference.</span></span>  
  
 <span data-ttu-id="b2e37-176">在连接失败的情况下，始终设置 <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A> 属性。</span><span class="sxs-lookup"><span data-stu-id="b2e37-176">The <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A> property is always set in the case of a connection failure.</span></span> <span data-ttu-id="b2e37-177"><xref:System.Net.Sockets.SocketAsyncEventArgs.ConnectByNameError%2A> 属性包含有关在连接到 <xref:System.Net.DnsEndPoint>失败的情况的详细信息。</span><span class="sxs-lookup"><span data-stu-id="b2e37-177">The <xref:System.Net.Sockets.SocketAsyncEventArgs.ConnectByNameError%2A> property contains more information about the failure if it was a failure connecting to a <xref:System.Net.DnsEndPoint>.</span></span> <span data-ttu-id="b2e37-178">如果应用程序只对连接操作成功与否感兴趣，则应用程序只需要检查 <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A> 属性。</span><span class="sxs-lookup"><span data-stu-id="b2e37-178">If an application is only interested in whether the connect operation succeeded or failed, then the application only needs to check the <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A> property.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Net.Sockets.Socket.ConnectAsync" />
      </Docs>
    </Member>
    <Member MemberName="ConnectSocket">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.Socket ConnectSocket { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.Sockets.Socket ConnectSocket" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.SocketAsyncEventArgs.ConnectSocket" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ConnectSocket As Socket" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Sockets::Socket ^ ConnectSocket { System::Net::Sockets::Socket ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ConnectSocket : System.Net.Sockets.Socket" Usage="System.Net.Sockets.SocketAsyncEventArgs.ConnectSocket" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.Socket</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="b2e37-179">成功完成 <see cref="T:System.Net.Sockets.Socket" /> 方法后创建和连接的 <see cref="Overload:System.Net.Sockets.Socket.ConnectAsync" /> 对象。</span><span class="sxs-lookup"><span data-stu-id="b2e37-179">The created and connected <see cref="T:System.Net.Sockets.Socket" /> object after successful completion of the <see cref="Overload:System.Net.Sockets.Socket.ConnectAsync" /> method.</span></span></summary>
        <value><span data-ttu-id="b2e37-180">连接的 <see cref="T:System.Net.Sockets.Socket" /> 对象。</span><span class="sxs-lookup"><span data-stu-id="b2e37-180">The connected <see cref="T:System.Net.Sockets.Socket" /> object.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b2e37-181">成功完成 <xref:System.Net.Sockets.Socket.ConnectAsync%2A> 方法后，此属性包含新创建并连接 <xref:System.Net.Sockets.Socket> 对象。</span><span class="sxs-lookup"><span data-stu-id="b2e37-181">After successful completion of the <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method, this property contains the newly created and connected <xref:System.Net.Sockets.Socket> object.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Net.Sockets.Socket.ConnectAsync" />
      </Docs>
    </Member>
    <Member MemberName="Count">
      <MemberSignature Language="C#" Value="public int Count { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Count" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.SocketAsyncEventArgs.Count" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Count As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Count { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Count : int" Usage="System.Net.Sockets.SocketAsyncEventArgs.Count" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="b2e37-182">获取可在异步操作中发送或接收的最大数据量（以字节为单位）。</span><span class="sxs-lookup"><span data-stu-id="b2e37-182">Gets the maximum amount of data, in bytes, to send or receive in an asynchronous operation.</span></span></summary>
        <value><span data-ttu-id="b2e37-183">一个 <see cref="T:System.Int32" />，包含可发送或接收的最大数据量（以字节为单位）。</span><span class="sxs-lookup"><span data-stu-id="b2e37-183">An <see cref="T:System.Int32" /> that contains the maximum amount of data, in bytes, to send or receive.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b2e37-184">此属性通过调用 <xref:System.Net.Sockets.SocketAsyncEventArgs.SetBuffer%2A> 方法来设置。</span><span class="sxs-lookup"><span data-stu-id="b2e37-184">This property is set by calling the <xref:System.Net.Sockets.SocketAsyncEventArgs.SetBuffer%2A> method.</span></span>  
  
 <span data-ttu-id="b2e37-185">此属性与 <xref:System.Net.Sockets.Socket.AcceptAsync%2A?displayProperty=nameWithType>、<xref:System.Net.Sockets.Socket.ConnectAsync%2A?displayProperty=nameWithType>、<xref:System.Net.Sockets.Socket.ReceiveAsync%2A?displayProperty=nameWithType>、<xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A?displayProperty=nameWithType>、<xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A?displayProperty=nameWithType>、<xref:System.Net.Sockets.Socket.SendAsync%2A?displayProperty=nameWithType>和 <xref:System.Net.Sockets.Socket.SendToAsync%2A?displayProperty=nameWithType> 方法一起使用。</span><span class="sxs-lookup"><span data-stu-id="b2e37-185">This property is used with the <xref:System.Net.Sockets.Socket.AcceptAsync%2A?displayProperty=nameWithType>, <xref:System.Net.Sockets.Socket.ConnectAsync%2A?displayProperty=nameWithType>, <xref:System.Net.Sockets.Socket.ReceiveAsync%2A?displayProperty=nameWithType>, <xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A?displayProperty=nameWithType>, <xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A?displayProperty=nameWithType>, <xref:System.Net.Sockets.Socket.SendAsync%2A?displayProperty=nameWithType>, and <xref:System.Net.Sockets.Socket.SendToAsync%2A?displayProperty=nameWithType> methods.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
        <altmember cref="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFromAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveMessageFromAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
        <altmember cref="Overload:System.Net.Sockets.SocketAsyncEventArgs.SetBuffer" />
      </Docs>
    </Member>
    <Member MemberName="DisconnectReuseSocket">
      <MemberSignature Language="C#" Value="public bool DisconnectReuseSocket { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DisconnectReuseSocket" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.SocketAsyncEventArgs.DisconnectReuseSocket" />
      <MemberSignature Language="VB.NET" Value="Public Property DisconnectReuseSocket As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool DisconnectReuseSocket { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.DisconnectReuseSocket : bool with get, set" Usage="System.Net.Sockets.SocketAsyncEventArgs.DisconnectReuseSocket" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="b2e37-186">获取或设置一个值，该值指定套接字能否在断开操作之后重用。</span><span class="sxs-lookup"><span data-stu-id="b2e37-186">Gets or sets a value that specifies if socket can be reused after a disconnect operation.</span></span></summary>
        <value><span data-ttu-id="b2e37-187">一个 <see cref="T:System.Boolean" />，指定套接字能否在断开操作之后重用。</span><span class="sxs-lookup"><span data-stu-id="b2e37-187">A <see cref="T:System.Boolean" /> that specifies if socket can be reused after a disconnect operation.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b2e37-188">此属性用于更改 <xref:System.Net.Sockets.Socket.DisconnectAsync%2A?displayProperty=nameWithType> 方法的行为。</span><span class="sxs-lookup"><span data-stu-id="b2e37-188">This property is used to alter the behavior of <xref:System.Net.Sockets.Socket.DisconnectAsync%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="b2e37-189">如果为 true，则在后续套接字接受或连接操作完成后，可以重用由 <xref:System.Net.Sockets.Socket.DisconnectAsync%2A?displayProperty=nameWithType> 方法断开连接的套接字。</span><span class="sxs-lookup"><span data-stu-id="b2e37-189">If true, a socket disconnected by the <xref:System.Net.Sockets.Socket.DisconnectAsync%2A?displayProperty=nameWithType> method can be reused after disconnect completion in subsequent socket accept or connect operations.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Net.Sockets.Socket.DisconnectAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.SocketAsyncEventArgs.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="socketAsyncEventArgs.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="b2e37-190">释放由 <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> 实例使用的非托管资源，并可选择释放托管资源。</span><span class="sxs-lookup"><span data-stu-id="b2e37-190">Releases the unmanaged resources used by the <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> instance and optionally disposes of the managed resources.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b2e37-191">此方法由 public `Dispose()` 方法和 <xref:System.Object.Finalize%2A> 方法调用。</span><span class="sxs-lookup"><span data-stu-id="b2e37-191">This method is called by the public `Dispose()` method and the <xref:System.Object.Finalize%2A> method.</span></span> <span data-ttu-id="b2e37-192">`Dispose()` 调用受保护的 `Dispose(Boolean)` 方法，并将 `disposing` 参数设置为 `true`。</span><span class="sxs-lookup"><span data-stu-id="b2e37-192">`Dispose()` invokes the protected `Dispose(Boolean)` method with the `disposing` parameter set to `true`.</span></span> <span data-ttu-id="b2e37-193"><xref:System.Object.Finalize%2A> 调用 `disposing` 设置为 `false`的 `Dispose`。</span><span class="sxs-lookup"><span data-stu-id="b2e37-193"><xref:System.Object.Finalize%2A> invokes `Dispose` with `disposing` set to `false`.</span></span>  
  
 <span data-ttu-id="b2e37-194">当 `disposing` 参数为 `true` 时，此方法释放该 <xref:System.Net.Sockets.SocketAsyncEventArgs> 引用的、由任何托管对象持有的全部资源。</span><span class="sxs-lookup"><span data-stu-id="b2e37-194">When the `disposing` parameter is `true`, this method releases all resources held by any managed objects that this <xref:System.Net.Sockets.SocketAsyncEventArgs> references.</span></span> <span data-ttu-id="b2e37-195">此方法将调用每个被引用对象的 `Dispose()` 方法。</span><span class="sxs-lookup"><span data-stu-id="b2e37-195">This method invokes the `Dispose()` method of each referenced object.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="b2e37-196">当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。</span><span class="sxs-lookup"><span data-stu-id="b2e37-196">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="b2e37-197">有关详细信息，请参阅[.NET Framework 中的网络跟踪](/dotnet/framework/network-programming/network-tracing)。</span><span class="sxs-lookup"><span data-stu-id="b2e37-197">For more information, see [Network Tracing in the .NET Framework](/dotnet/framework/network-programming/network-tracing).</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para><span data-ttu-id="b2e37-198">
            <see langword="Dispose" /> 可以由其他对象多次调用。</span><span class="sxs-lookup"><span data-stu-id="b2e37-198">
            <see langword="Dispose" /> can be called multiple times by other objects.</span></span> <span data-ttu-id="b2e37-199">重写 <see langword="Dispose(Boolean)" /> 时，请注意不要引用在以前调用 <see langword="Dispose" /> 时已释放的对象。</span><span class="sxs-lookup"><span data-stu-id="b2e37-199">When overriding <see langword="Dispose(Boolean)" />, be careful not to reference objects that have been previously disposed of in an earlier call to <see langword="Dispose" />.</span></span> <span data-ttu-id="b2e37-200">有关如何实现 <see langword="Dispose(Boolean)" />的详细信息，请参阅[实现 Dispose 方法](/dotnet/standard/garbage-collection/implementing-dispose)。</span><span class="sxs-lookup"><span data-stu-id="b2e37-200">For more information about how to implement <see langword="Dispose(Boolean)" />, see [Implementing a Dispose Method](/dotnet/standard/garbage-collection/implementing-dispose).</span></span>  
  
<span data-ttu-id="b2e37-201">有关 <see langword="Dispose" /> 和 <see cref="M:System.Object.Finalize" />的详细信息，请参阅[清理非托管资源](/dotnet/standard/garbage-collection/unmanaged)和[重写 Finalize 方法](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/ddae83kx(v=vs.100))。</span><span class="sxs-lookup"><span data-stu-id="b2e37-201">For more information about <see langword="Dispose" /> and <see cref="M:System.Object.Finalize" />, see [Cleaning Up Unmanaged Resources](/dotnet/standard/garbage-collection/unmanaged) and [Overriding the Finalize Method](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/ddae83kx(v=vs.100)).</span></span></para></block>
        <altmember cref="M:System.Object.Finalize" />
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~SocketAsyncEventArgs ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.SocketAsyncEventArgs.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!SocketAsyncEventArgs ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="socketAsyncEventArgs.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="b2e37-202">释放 <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> 类使用的资源。</span><span class="sxs-lookup"><span data-stu-id="b2e37-202">Frees resources used by the <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> class.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b2e37-203"><xref:System.Net.Sockets.SocketAsyncEventArgs> 类终结器将关闭与 <xref:System.Net.Sockets.SocketAsyncEventArgs>关联的 <xref:System.Net.Sockets.SocketAsyncEventArgs> 和可用资源。</span><span class="sxs-lookup"><span data-stu-id="b2e37-203">The <xref:System.Net.Sockets.SocketAsyncEventArgs> class finalizer closes the <xref:System.Net.Sockets.SocketAsyncEventArgs> and free resources associated with the <xref:System.Net.Sockets.SocketAsyncEventArgs>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LastOperation">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.SocketAsyncOperation LastOperation { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Net.Sockets.SocketAsyncOperation LastOperation" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.SocketAsyncEventArgs.LastOperation" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LastOperation As SocketAsyncOperation" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Sockets::SocketAsyncOperation LastOperation { System::Net::Sockets::SocketAsyncOperation get(); };" />
      <MemberSignature Language="F#" Value="member this.LastOperation : System.Net.Sockets.SocketAsyncOperation" Usage="System.Net.Sockets.SocketAsyncEventArgs.LastOperation" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.SocketAsyncOperation</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="b2e37-204">获取最近使用此上下文对象执行的套接字操作类型。</span><span class="sxs-lookup"><span data-stu-id="b2e37-204">Gets the type of socket operation most recently performed with this context object.</span></span></summary>
        <value><span data-ttu-id="b2e37-205">一个 <see cref="T:System.Net.Sockets.SocketAsyncOperation" /> 实例，指示最近使用此上下文对象执行的套接字操作类型。</span><span class="sxs-lookup"><span data-stu-id="b2e37-205">A <see cref="T:System.Net.Sockets.SocketAsyncOperation" /> instance that indicates the type of socket operation most recently performed with this context object.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b2e37-206">此属性描述最近使用此 <xref:System.Net.Sockets.SocketAsyncEventArgs> 对象完成的异步套接字操作。</span><span class="sxs-lookup"><span data-stu-id="b2e37-206">This property describes the asynchronous socket operation that was most recently completed using this <xref:System.Net.Sockets.SocketAsyncEventArgs> object.</span></span> <span data-ttu-id="b2e37-207">此属性的值将 <xref:System.Net.Sockets.SocketAsyncOperation.None?displayProperty=nameWithType>，直到 <xref:System.Net.Sockets.SocketAsyncEventArgs> 实例用于开始异步套接字操作。</span><span class="sxs-lookup"><span data-stu-id="b2e37-207">The value of this property will be <xref:System.Net.Sockets.SocketAsyncOperation.None?displayProperty=nameWithType> until the <xref:System.Net.Sockets.SocketAsyncEventArgs> instance is used to begin an asynchronous socket operation.</span></span> <span data-ttu-id="b2e37-208">然后，将属性设置为采用 <xref:System.Net.Sockets.SocketAsyncEventArgs> 作为参数的方法中所执行的操作的类型。</span><span class="sxs-lookup"><span data-stu-id="b2e37-208">The property will then be set to the type of operation being performed in the methods that take the <xref:System.Net.Sockets.SocketAsyncEventArgs> as a parameter.</span></span> <span data-ttu-id="b2e37-209">此属性更便于使用单个完成回调委托实现多种类型的异步套接字操作。</span><span class="sxs-lookup"><span data-stu-id="b2e37-209">This property more easily facilitates using a single completion callback delegate for multiple kinds of asynchronous socket operations.</span></span>  
  
 <span data-ttu-id="b2e37-210">此属性在 <xref:System.Net.Sockets.SocketAsyncEventArgs> 实例中保持有效，直到 <xref:System.Net.Sockets.SocketAsyncEventArgs> 实例用于另一个异步套接字（xxxAsync）操作。</span><span class="sxs-lookup"><span data-stu-id="b2e37-210">This property remains valid in a <xref:System.Net.Sockets.SocketAsyncEventArgs> instance until the <xref:System.Net.Sockets.SocketAsyncEventArgs> instance is used for another asynchronous socket (xxxAsync) operation.</span></span>  
  
 <span data-ttu-id="b2e37-211">此属性由所有异步套接字（xxxAsync）方法设置。</span><span class="sxs-lookup"><span data-stu-id="b2e37-211">This property is set by all asynchronous socket (xxxAsync) methods.</span></span>  
  
 <span data-ttu-id="b2e37-212">在 <xref:System.Net.Sockets.Socket?displayProperty=nameWithType> 类上调用异步套接字方法（xxxAsync）将设置此属性值。</span><span class="sxs-lookup"><span data-stu-id="b2e37-212">Calling an asynchronous socket method (xxxAsync) on the <xref:System.Net.Sockets.Socket?displayProperty=nameWithType> class sets this property value.</span></span> <span data-ttu-id="b2e37-213">此属性用于与应用程序实现的 SocketAsyncCallback 完成例程一起使用。</span><span class="sxs-lookup"><span data-stu-id="b2e37-213">This property is intended for use with the SocketAsyncCallback completion routine implemented by the application.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
        <altmember cref="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
        <altmember cref="M:System.Net.Sockets.Socket.DisconnectAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFromAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveMessageFromAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
        <altmember cref="T:System.Net.Sockets.SocketAsyncOperation" />
      </Docs>
    </Member>
    <Member MemberName="MemoryBuffer">
      <MemberSignature Language="C#" Value="public Memory&lt;byte&gt; MemoryBuffer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Memory`1&lt;unsigned int8&gt; MemoryBuffer" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.SocketAsyncEventArgs.MemoryBuffer" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MemoryBuffer As Memory(Of Byte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Memory&lt;System::Byte&gt; MemoryBuffer { Memory&lt;System::Byte&gt; get(); };" />
      <MemberSignature Language="F#" Value="member this.MemoryBuffer : Memory&lt;byte&gt;" Usage="System.Net.Sockets.SocketAsyncEventArgs.MemoryBuffer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Memory&lt;System.Byte&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="b2e37-214">使用异步套接字方法获取要用作缓冲区的内存区域。</span><span class="sxs-lookup"><span data-stu-id="b2e37-214">Gets the region of memory to use as a buffer with an asynchronous socket method.</span></span></summary>
        <value><span data-ttu-id="b2e37-215">表示要用于异步套接字方法的数据缓冲区的内存区域。</span><span class="sxs-lookup"><span data-stu-id="b2e37-215">A region of memory that represents the data buffer to use with an asynchronous socket method.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks

<span data-ttu-id="b2e37-216">此属性获取当前与 <xref:System.Net.Sockets.SocketAsyncEventArgs> 实例关联的数据缓冲区。</span><span class="sxs-lookup"><span data-stu-id="b2e37-216">This property gets the data buffer currently associated with the <xref:System.Net.Sockets.SocketAsyncEventArgs> instance.</span></span> <span data-ttu-id="b2e37-217">若要设置缓冲区，必须使用 <xref:System.Net.Sockets.SocketAsyncEventArgs.SetBuffer%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="b2e37-217">To set the buffer, the <xref:System.Net.Sockets.SocketAsyncEventArgs.SetBuffer%2A> method must be used.</span></span>

<span data-ttu-id="b2e37-218">此属性与 <xref:System.Net.Sockets.Socket.AcceptAsync%2A?displayProperty=nameWithType>、<xref:System.Net.Sockets.Socket.ConnectAsync%2A?displayProperty=nameWithType>、<xref:System.Net.Sockets.Socket.ReceiveAsync%2A?displayProperty=nameWithType>、<xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A?displayProperty=nameWithType>、<xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A?displayProperty=nameWithType>、<xref:System.Net.Sockets.Socket.SendAsync%2A?displayProperty=nameWithType>和 <xref:System.Net.Sockets.Socket.SendToAsync%2A?displayProperty=nameWithType> 方法一起使用。</span><span class="sxs-lookup"><span data-stu-id="b2e37-218">This property is used with the <xref:System.Net.Sockets.Socket.AcceptAsync%2A?displayProperty=nameWithType>, <xref:System.Net.Sockets.Socket.ConnectAsync%2A?displayProperty=nameWithType>, <xref:System.Net.Sockets.Socket.ReceiveAsync%2A?displayProperty=nameWithType>, <xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A?displayProperty=nameWithType>, <xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A?displayProperty=nameWithType>, <xref:System.Net.Sockets.Socket.SendAsync%2A?displayProperty=nameWithType>, and <xref:System.Net.Sockets.Socket.SendToAsync%2A?displayProperty=nameWithType> methods.</span></span>  

 ]]></format>
        </remarks>
        <altmember cref="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
        <altmember cref="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFromAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveMessageFromAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
        <altmember cref="Overload:System.Net.Sockets.SocketAsyncEventArgs.SetBuffer" />
      </Docs>
    </Member>
    <Member MemberName="Offset">
      <MemberSignature Language="C#" Value="public int Offset { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Offset" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.SocketAsyncEventArgs.Offset" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Offset As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Offset { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Offset : int" Usage="System.Net.Sockets.SocketAsyncEventArgs.Offset" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="b2e37-219">获取 <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" /> 属性引用的数据缓冲区的偏移量（以字节为单位）。</span><span class="sxs-lookup"><span data-stu-id="b2e37-219">Gets the offset, in bytes, into the data buffer referenced by the <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" /> property.</span></span></summary>
        <value><span data-ttu-id="b2e37-220">一个 <see cref="T:System.Int32" />，包含 <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" /> 属性引用的数据缓冲区的偏移量（以字节为单位）。</span><span class="sxs-lookup"><span data-stu-id="b2e37-220">An <see cref="T:System.Int32" /> that contains the offset, in bytes, into the data buffer referenced by the <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" /> property.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b2e37-221">此属性描述 <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A> 属性中数据的起始字节偏移量。</span><span class="sxs-lookup"><span data-stu-id="b2e37-221">This property describes the starting byte offset of data in the <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A> property.</span></span> <span data-ttu-id="b2e37-222">此值通过调用 <xref:System.Net.Sockets.SocketAsyncEventArgs.SetBuffer%2A> 方法来设置。</span><span class="sxs-lookup"><span data-stu-id="b2e37-222">This value is set by calling the <xref:System.Net.Sockets.SocketAsyncEventArgs.SetBuffer%2A> method.</span></span>  
  
 <span data-ttu-id="b2e37-223">此属性不适用于 <xref:System.Net.Sockets.SocketAsyncEventArgs.BufferList%2A> 属性。</span><span class="sxs-lookup"><span data-stu-id="b2e37-223">This property does not apply to the <xref:System.Net.Sockets.SocketAsyncEventArgs.BufferList%2A> property.</span></span>  
  
 <span data-ttu-id="b2e37-224">此属性与 <xref:System.Net.Sockets.Socket.AcceptAsync%2A?displayProperty=nameWithType>、<xref:System.Net.Sockets.Socket.ConnectAsync%2A?displayProperty=nameWithType>、<xref:System.Net.Sockets.Socket.ReceiveAsync%2A?displayProperty=nameWithType>、<xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A?displayProperty=nameWithType>、<xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A?displayProperty=nameWithType>、<xref:System.Net.Sockets.Socket.SendAsync%2A?displayProperty=nameWithType>和 <xref:System.Net.Sockets.Socket.SendToAsync%2A?displayProperty=nameWithType> 方法一起使用。</span><span class="sxs-lookup"><span data-stu-id="b2e37-224">This property is used with the <xref:System.Net.Sockets.Socket.AcceptAsync%2A?displayProperty=nameWithType>, <xref:System.Net.Sockets.Socket.ConnectAsync%2A?displayProperty=nameWithType>, <xref:System.Net.Sockets.Socket.ReceiveAsync%2A?displayProperty=nameWithType>, <xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A?displayProperty=nameWithType>, <xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A?displayProperty=nameWithType>, <xref:System.Net.Sockets.Socket.SendAsync%2A?displayProperty=nameWithType>, and <xref:System.Net.Sockets.Socket.SendToAsync%2A?displayProperty=nameWithType> methods.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
        <altmember cref="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFromAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveMessageFromAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />
      </Docs>
    </Member>
    <Member MemberName="OnCompleted">
      <MemberSignature Language="C#" Value="protected virtual void OnCompleted (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnCompleted(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.SocketAsyncEventArgs.OnCompleted(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnCompleted (e As SocketAsyncEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnCompleted(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnCompleted : System.Net.Sockets.SocketAsyncEventArgs -&gt; unit&#xA;override this.OnCompleted : System.Net.Sockets.SocketAsyncEventArgs -&gt; unit" Usage="socketAsyncEventArgs.OnCompleted e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="b2e37-225">终止的事件。</span><span class="sxs-lookup"><span data-stu-id="b2e37-225">The event that is signaled.</span></span></param>
        <summary><span data-ttu-id="b2e37-226">表示异步操作完成时调用的方法。</span><span class="sxs-lookup"><span data-stu-id="b2e37-226">Represents a method that is called when an asynchronous operation completes.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b2e37-227">用户代码无法调用此方法。</span><span class="sxs-lookup"><span data-stu-id="b2e37-227">This method is not callable by user code.</span></span> <span data-ttu-id="b2e37-228">当前操作完成后，<xref:System.Net.Sockets.SocketAsyncEventArgs> 对象的内部，将调用此方法。</span><span class="sxs-lookup"><span data-stu-id="b2e37-228">This method gets called by the internals of the <xref:System.Net.Sockets.SocketAsyncEventArgs> object when the current operation is complete.</span></span> <span data-ttu-id="b2e37-229">此方法用于所有异步套接字（xxxAsync）方法。</span><span class="sxs-lookup"><span data-stu-id="b2e37-229">This method is used with all asynchronous socket (xxxAsync) methods.</span></span>  
  
 <span data-ttu-id="b2e37-230">创建从 <xref:System.Net.Sockets.SocketAsyncEventArgs> 继承的类的应用程序可以重写此方法以挂钩到此完成通知，并清理它为操作分配的任何资源。</span><span class="sxs-lookup"><span data-stu-id="b2e37-230">An application that creates a class inheriting from <xref:System.Net.Sockets.SocketAsyncEventArgs> can override this method to hook into this completion notification and clean up any resources that it allocated for the operation.</span></span> <span data-ttu-id="b2e37-231">默认实现仅引发 <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed> 事件。</span><span class="sxs-lookup"><span data-stu-id="b2e37-231">The default implementation just raises the <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed> event.</span></span>  
  
 <span data-ttu-id="b2e37-232">此方法用于挂钩要用作后续异步套接字操作的完成回调的事件处理程序。</span><span class="sxs-lookup"><span data-stu-id="b2e37-232">This method is used to hook up an event handler to be used as the completion callback for a subsequent asynchronous socket operation.</span></span> <span data-ttu-id="b2e37-233">调用方必须在使用 <xref:System.Net.Sockets.Socket?displayProperty=nameWithType> 类上的异步（xxxAsync）方法之一启动异步套接字操作之前，至少实现从此方法继承的一个回调委托。</span><span class="sxs-lookup"><span data-stu-id="b2e37-233">The caller must implement at least one callback delegate inherited from this method prior to starting an asynchronous socket operation using one of the asynchronous (xxxAsync) methods on the <xref:System.Net.Sockets.Socket?displayProperty=nameWithType> class.</span></span>  
  
 <span data-ttu-id="b2e37-234">调用方的 <xref:System.Net.Sockets.SocketAsyncEventArgs.OnCompleted%2A> 方法为客户端应用程序提供了一种完成异步套接字操作的方法。</span><span class="sxs-lookup"><span data-stu-id="b2e37-234">The caller's <xref:System.Net.Sockets.SocketAsyncEventArgs.OnCompleted%2A> method provides a way for client applications to complete an asynchronous socket operation.</span></span> <span data-ttu-id="b2e37-235">启动异步套接字操作时必须实现回调委托。</span><span class="sxs-lookup"><span data-stu-id="b2e37-235">A callback delegate must be implemented when an asynchronous socket operation is initiated.</span></span> <span data-ttu-id="b2e37-236">从 <xref:System.Net.Sockets.SocketAsyncEventArgs.OnCompleted%2A> 方法继承的完成回调委托必须包含用于完成客户端异步套接字操作处理的程序逻辑。</span><span class="sxs-lookup"><span data-stu-id="b2e37-236">The completion callback delegate(s) inherited from the <xref:System.Net.Sockets.SocketAsyncEventArgs.OnCompleted%2A> method must contain program logic to finish processing the asynchronous socket operation for the client.</span></span>  
  
 <span data-ttu-id="b2e37-237">当异步操作收到信号时，应用程序将使用 <xref:System.Net.Sockets.SocketAsyncEventArgs> 的对象参数获取已完成的异步套接字操作的状态。</span><span class="sxs-lookup"><span data-stu-id="b2e37-237">When an asynchronous operation is signaled, the application uses the <xref:System.Net.Sockets.SocketAsyncEventArgs> object parameter to obtain status of the completed asynchronous socket operation.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
        <altmember cref="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
        <altmember cref="M:System.Net.Sockets.Socket.DisconnectAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFromAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveMessageFromAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveMessageFromPacketInfo">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.IPPacketInformation ReceiveMessageFromPacketInfo { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Net.Sockets.IPPacketInformation ReceiveMessageFromPacketInfo" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.SocketAsyncEventArgs.ReceiveMessageFromPacketInfo" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ReceiveMessageFromPacketInfo As IPPacketInformation" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Sockets::IPPacketInformation ReceiveMessageFromPacketInfo { System::Net::Sockets::IPPacketInformation get(); };" />
      <MemberSignature Language="F#" Value="member this.ReceiveMessageFromPacketInfo : System.Net.Sockets.IPPacketInformation" Usage="System.Net.Sockets.SocketAsyncEventArgs.ReceiveMessageFromPacketInfo" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.IPPacketInformation</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="b2e37-238">获取接收的数据包的 IP 地址和接口。</span><span class="sxs-lookup"><span data-stu-id="b2e37-238">Gets the IP address and interface of a received packet.</span></span></summary>
        <value><span data-ttu-id="b2e37-239">一个 <see cref="T:System.Net.Sockets.IPPacketInformation" /> 实例，该实例包含接收的数据包的目标 IP 地址和接口。</span><span class="sxs-lookup"><span data-stu-id="b2e37-239">An <see cref="T:System.Net.Sockets.IPPacketInformation" /> instance that contains the destination IP address and interface of a received packet.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b2e37-240">此属性提供有关使用 <xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A?displayProperty=nameWithType> 方法接收的数据包的信息。</span><span class="sxs-lookup"><span data-stu-id="b2e37-240">This property provides information about a packet received using the <xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="b2e37-241">此属性与 <xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A?displayProperty=nameWithType> 方法一起使用。</span><span class="sxs-lookup"><span data-stu-id="b2e37-241">This property is used with the <xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A?displayProperty=nameWithType> method.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.IPAddress" />
        <altmember cref="T:System.Net.Sockets.IPPacketInformation" />
        <altmember cref="P:System.Net.Sockets.IPPacketInformation.Address" />
        <altmember cref="P:System.Net.Sockets.IPPacketInformation.Interface" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFromAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="RemoteEndPoint">
      <MemberSignature Language="C#" Value="public System.Net.EndPoint RemoteEndPoint { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.EndPoint RemoteEndPoint" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" />
      <MemberSignature Language="VB.NET" Value="Public Property RemoteEndPoint As EndPoint" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::EndPoint ^ RemoteEndPoint { System::Net::EndPoint ^ get(); void set(System::Net::EndPoint ^ value); };" />
      <MemberSignature Language="F#" Value="member this.RemoteEndPoint : System.Net.EndPoint with get, set" Usage="System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.EndPoint</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="b2e37-242">获取或设置异步操作的远程 IP 终结点。</span><span class="sxs-lookup"><span data-stu-id="b2e37-242">Gets or sets the remote IP endpoint for an asynchronous operation.</span></span></summary>
        <value><span data-ttu-id="b2e37-243">一个 <see cref="T:System.Net.EndPoint" />，表示异步操作的远程 IP 终结点。</span><span class="sxs-lookup"><span data-stu-id="b2e37-243">An <see cref="T:System.Net.EndPoint" /> that represents the remote IP endpoint for an asynchronous operation.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b2e37-244">此属性指定远程终结点。</span><span class="sxs-lookup"><span data-stu-id="b2e37-244">This property specifies the remote endpoint.</span></span> <span data-ttu-id="b2e37-245">此属性可使用 <xref:System.Net.Sockets.Socket.ConnectAsync%2A?displayProperty=nameWithType> 方法指定要连接的远程终结点。</span><span class="sxs-lookup"><span data-stu-id="b2e37-245">This property can specify the remote endpoint to which to connect using the <xref:System.Net.Sockets.Socket.ConnectAsync%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="b2e37-246">此属性可使用 <xref:System.Net.Sockets.Socket.SendToAsync%2A?displayProperty=nameWithType> 方法指定要向其发送数据的远程终结点。</span><span class="sxs-lookup"><span data-stu-id="b2e37-246">This property can specify the remote endpoint to which to send data using <xref:System.Net.Sockets.Socket.SendToAsync%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="b2e37-247">此属性可以指定使用 <xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A?displayProperty=nameWithType> 或 <xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A?displayProperty=nameWithType> 方法从中接收数据的远程终结点。</span><span class="sxs-lookup"><span data-stu-id="b2e37-247">This property can specify the remote endpoint from which data was received using the <xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A?displayProperty=nameWithType> or <xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A?displayProperty=nameWithType> methods.</span></span>  
  
 <span data-ttu-id="b2e37-248">此属性指定的远程终结点可以包括 IPv4 或 IPv6 地址。</span><span class="sxs-lookup"><span data-stu-id="b2e37-248">This remote endpoint specified by this property can include an IPv4 or IPv6 address.</span></span>  
  
 <span data-ttu-id="b2e37-249">此属性与 <xref:System.Net.Sockets.Socket.ConnectAsync%2A?displayProperty=nameWithType>、<xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A?displayProperty=nameWithType>、<xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A?displayProperty=nameWithType>或 <xref:System.Net.Sockets.Socket.SendToAsync%2A?displayProperty=nameWithType> 方法一起使用。</span><span class="sxs-lookup"><span data-stu-id="b2e37-249">This property is used with the <xref:System.Net.Sockets.Socket.ConnectAsync%2A?displayProperty=nameWithType>, <xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A?displayProperty=nameWithType>, <xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A?displayProperty=nameWithType>, or <xref:System.Net.Sockets.Socket.SendToAsync%2A?displayProperty=nameWithType> methods.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.EndPoint" />
        <altmember cref="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFromAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveMessageFromAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="SendPacketsElements">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.SendPacketsElement[] SendPacketsElements { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.Sockets.SendPacketsElement[] SendPacketsElements" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsElements" />
      <MemberSignature Language="VB.NET" Value="Public Property SendPacketsElements As SendPacketsElement()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::Net::Sockets::SendPacketsElement ^&gt; ^ SendPacketsElements { cli::array &lt;System::Net::Sockets::SendPacketsElement ^&gt; ^ get(); void set(cli::array &lt;System::Net::Sockets::SendPacketsElement ^&gt; ^ value); };" />
      <MemberSignature Language="F#" Value="member this.SendPacketsElements : System.Net.Sockets.SendPacketsElement[] with get, set" Usage="System.Net.Sockets.SocketAsyncEventArgs.SendPacketsElements" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.SendPacketsElement[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="b2e37-250">获取或设置要为 <see cref="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)" /> 方法使用的异步操作发送的缓冲区数组。</span><span class="sxs-lookup"><span data-stu-id="b2e37-250">Gets or sets an array of buffers to be sent for an asynchronous operation used by the <see cref="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)" /> method.</span></span></summary>
        <value><span data-ttu-id="b2e37-251">表示要发送的缓冲区数组的 <see cref="T:System.Net.Sockets.SendPacketsElement" /> 对象数组。</span><span class="sxs-lookup"><span data-stu-id="b2e37-251">An array of <see cref="T:System.Net.Sockets.SendPacketsElement" /> objects that represent an array of buffers to be sent.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b2e37-252">缓冲区数组可以表示内存中的一个文件或一组内存数据缓冲区。</span><span class="sxs-lookup"><span data-stu-id="b2e37-252">The array of buffers can represent a file or files in memory or a set of memory data buffers.</span></span> <span data-ttu-id="b2e37-253">此属性与 <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A?displayProperty=nameWithType> 方法一起使用。</span><span class="sxs-lookup"><span data-stu-id="b2e37-253">This property is used with the <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A?displayProperty=nameWithType> method.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.Sockets.SendPacketsElement" />
        <altmember cref="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="SendPacketsFlags">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.TransmitFileOptions SendPacketsFlags { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Net.Sockets.TransmitFileOptions SendPacketsFlags" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsFlags" />
      <MemberSignature Language="VB.NET" Value="Public Property SendPacketsFlags As TransmitFileOptions" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Sockets::TransmitFileOptions SendPacketsFlags { System::Net::Sockets::TransmitFileOptions get(); void set(System::Net::Sockets::TransmitFileOptions value); };" />
      <MemberSignature Language="F#" Value="member this.SendPacketsFlags : System.Net.Sockets.TransmitFileOptions with get, set" Usage="System.Net.Sockets.SocketAsyncEventArgs.SendPacketsFlags" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.TransmitFileOptions</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="b2e37-254">为 <see cref="T:System.Net.Sockets.TransmitFileOptions" /> 方法使用的异步操作获取或设置 <see cref="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)" /> 值的按位组合。</span><span class="sxs-lookup"><span data-stu-id="b2e37-254">Gets or sets a bitwise combination of <see cref="T:System.Net.Sockets.TransmitFileOptions" /> values for an asynchronous operation used by the <see cref="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)" /> method.</span></span></summary>
        <value><span data-ttu-id="b2e37-255">一个 <see cref="T:System.Net.Sockets.TransmitFileOptions" />，包含用于异步操作的值的按位组合。</span><span class="sxs-lookup"><span data-stu-id="b2e37-255">A <see cref="T:System.Net.Sockets.TransmitFileOptions" /> that contains a bitwise combination of values that are used with an asynchronous operation.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b2e37-256">此属性指定 <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A?displayProperty=nameWithType> 方法使用的 <xref:System.Net.Sockets.TransmitFileOptions>。</span><span class="sxs-lookup"><span data-stu-id="b2e37-256">This property specifies the <xref:System.Net.Sockets.TransmitFileOptions> that are used by the <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A?displayProperty=nameWithType> method.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
        <altmember cref="T:System.Net.Sockets.TransmitFileOptions" />
      </Docs>
    </Member>
    <Member MemberName="SendPacketsSendSize">
      <MemberSignature Language="C#" Value="public int SendPacketsSendSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 SendPacketsSendSize" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsSendSize" />
      <MemberSignature Language="VB.NET" Value="Public Property SendPacketsSendSize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int SendPacketsSendSize { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.SendPacketsSendSize : int with get, set" Usage="System.Net.Sockets.SocketAsyncEventArgs.SendPacketsSendSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO("unused property")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="b2e37-257">获取或设置发送操作中使用的数据块的大小（以字节为单位）。</span><span class="sxs-lookup"><span data-stu-id="b2e37-257">Gets or sets the size, in bytes, of the data block used in the send operation.</span></span></summary>
        <value><span data-ttu-id="b2e37-258">一个 <see cref="T:System.Int32" />，包含在发送操作中使用的数据块的大小（以字节为单位）。</span><span class="sxs-lookup"><span data-stu-id="b2e37-258">An <see cref="T:System.Int32" /> that contains the size, in bytes, of the data block used in the send operation.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b2e37-259">将此属性设置为零，使套接字层选择默认发送大小。</span><span class="sxs-lookup"><span data-stu-id="b2e37-259">Set this property to zero to let the sockets layer select a default send size.</span></span> <span data-ttu-id="b2e37-260">如果将此属性设置为0xFFFFFFFF，则调用方可以通过使用 <xref:System.Net.Sockets.SendPacketsElement.EndOfPacket%2A?displayProperty=nameWithType> 属性，控制每个发送请求的大小和内容。</span><span class="sxs-lookup"><span data-stu-id="b2e37-260">Setting this property to 0xFFFFFFFF enables the caller to control the size and content of each send request, achieved by using the <xref:System.Net.Sockets.SendPacketsElement.EndOfPacket%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="b2e37-261">此功能适用于对各个发送请求的大小施加限制的消息协议。</span><span class="sxs-lookup"><span data-stu-id="b2e37-261">This capability is useful for message protocols that place limitations on the size of individual send requests.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Net.Sockets.SendPacketsElement.EndOfPacket" />
        <altmember cref="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="SetBuffer">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="b2e37-262">初始化要用于异步套接字方法的数据缓冲区。</span><span class="sxs-lookup"><span data-stu-id="b2e37-262">Initializes the data buffer to use with an asynchronous socket method.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b2e37-263">此方法将 <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A> 属性设置为 null，并将 <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A> 和 <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A> 属性设置为零。</span><span class="sxs-lookup"><span data-stu-id="b2e37-263">This method sets the <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A> property to null and the <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A> and <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A> properties to zero.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Offset" />
      </Docs>
    </MemberGroup>
    <Member MemberName="SetBuffer">
      <MemberSignature Language="C#" Value="public void SetBuffer (Memory&lt;byte&gt; buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetBuffer(valuetype System.Memory`1&lt;unsigned int8&gt; buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.SocketAsyncEventArgs.SetBuffer(System.Memory{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetBuffer (buffer As Memory(Of Byte))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetBuffer(Memory&lt;System::Byte&gt; buffer);" />
      <MemberSignature Language="F#" Value="member this.SetBuffer : Memory&lt;byte&gt; -&gt; unit" Usage="socketAsyncEventArgs.SetBuffer buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Memory&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="b2e37-264">通过异步套接字方法用作缓冲区的内存区域。</span><span class="sxs-lookup"><span data-stu-id="b2e37-264">The region of memory to use as a buffer with an asynchronous socket method.</span></span></param>
        <summary><span data-ttu-id="b2e37-265">使用异步套接字方法设置要用作缓冲区的内存区域。</span><span class="sxs-lookup"><span data-stu-id="b2e37-265">Sets the region of memory to use as a buffer with an asynchronous socket method.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
## Remarks

<span data-ttu-id="b2e37-266">此方法将 <xref:System.Net.Sockets.SocketAsyncEventArgs.MemoryBuffer%2A> 属性设置为 `buffer` 参数，将 <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A> 属性设置为 `buffer` 长度，将 <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A> 属性设置为零。</span><span class="sxs-lookup"><span data-stu-id="b2e37-266">This method sets the <xref:System.Net.Sockets.SocketAsyncEventArgs.MemoryBuffer%2A> property to the `buffer` parameter, the <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A> property to the `buffer` length, and the <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A> property to zero.</span></span>

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetBuffer">
      <MemberSignature Language="C#" Value="public void SetBuffer (int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetBuffer(int32 offset, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.SocketAsyncEventArgs.SetBuffer(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetBuffer (offset As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetBuffer(int offset, int count);" />
      <MemberSignature Language="F#" Value="member this.SetBuffer : int * int -&gt; unit" Usage="socketAsyncEventArgs.SetBuffer (offset, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="offset"><span data-ttu-id="b2e37-267">数据缓冲区中操作开始位置处的偏移量，以字节为单位。</span><span class="sxs-lookup"><span data-stu-id="b2e37-267">The offset, in bytes, in the data buffer where the operation starts.</span></span></param>
        <param name="count"><span data-ttu-id="b2e37-268">可在缓冲区中发送或接收的最大数据量（以字节为单位）。</span><span class="sxs-lookup"><span data-stu-id="b2e37-268">The maximum amount of data, in bytes, to send or receive in the buffer.</span></span></param>
        <summary><span data-ttu-id="b2e37-269">设置要用于异步套接字方法的数据缓冲区。</span><span class="sxs-lookup"><span data-stu-id="b2e37-269">Sets the data buffer to use with an asynchronous socket method.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b2e37-270">`offset` 和 `count` 参数不能为负数。</span><span class="sxs-lookup"><span data-stu-id="b2e37-270">The `offset` and `count` parameters can't be negative numbers.</span></span> <span data-ttu-id="b2e37-271">`offset` 和 `count` 参数的组合必须在 <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A> 属性中的缓冲区数组的边界内。</span><span class="sxs-lookup"><span data-stu-id="b2e37-271">The combination of the `offset` and `count` parameters must be in bounds of the buffer array in the <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A> property.</span></span>  
  
 <span data-ttu-id="b2e37-272">此方法将 <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A> 属性设置为 `count` 参数，并将 <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A> 属性设置为 `offset` 参数。</span><span class="sxs-lookup"><span data-stu-id="b2e37-272">This method sets the <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A> property to the `count` parameter and the <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A> property to the `offset` parameter.</span></span> <span data-ttu-id="b2e37-273">如果 <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A> 属性为 null，则此方法将忽略 `offset` 并 `count` 参数，并将 <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A> 和 <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A> 属性设置为0。</span><span class="sxs-lookup"><span data-stu-id="b2e37-273">If the <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A> property is null, this method ignores the `offset` and `count` parameters and sets the <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A> and <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A> properties to 0.</span></span>  
  
 <span data-ttu-id="b2e37-274">此方法不更改 <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A> 属性。</span><span class="sxs-lookup"><span data-stu-id="b2e37-274">This method does not change the <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A> property.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="b2e37-275">参数超出范围。</span><span class="sxs-lookup"><span data-stu-id="b2e37-275">An argument was out of range.</span></span> <span data-ttu-id="b2e37-276">如果 <paramref name="offset" /> 参数小于零或大于 <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" /> 属性中的数组长度，将发生此异常。</span><span class="sxs-lookup"><span data-stu-id="b2e37-276">This exception occurs if the <paramref name="offset" /> parameter is less than zero or greater than the length of the array in the <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" /> property.</span></span> <span data-ttu-id="b2e37-277">如果 <paramref name="count" /> 参数小于零或大于 <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" /> 属性中的数组长度减去 <paramref name="offset" /> 参数的值，也会发生此异常。</span><span class="sxs-lookup"><span data-stu-id="b2e37-277">This exception also occurs if the <paramref name="count" /> parameter is less than zero or greater than the length of the array in the <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" /> property minus the <paramref name="offset" /> parameter.</span></span></exception>
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Offset" />
      </Docs>
    </Member>
    <Member MemberName="SetBuffer">
      <MemberSignature Language="C#" Value="public void SetBuffer (byte[] buffer, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetBuffer(unsigned int8[] buffer, int32 offset, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.SocketAsyncEventArgs.SetBuffer(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetBuffer (buffer As Byte(), offset As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetBuffer(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count);" />
      <MemberSignature Language="F#" Value="member this.SetBuffer : byte[] * int * int -&gt; unit" Usage="socketAsyncEventArgs.SetBuffer (buffer, offset, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="b2e37-278">要用于异步套接字方法的数据缓冲区。</span><span class="sxs-lookup"><span data-stu-id="b2e37-278">The data buffer to use with an asynchronous socket method.</span></span></param>
        <param name="offset"><span data-ttu-id="b2e37-279">数据缓冲区中操作开始位置处的偏移量，以字节为单位。</span><span class="sxs-lookup"><span data-stu-id="b2e37-279">The offset, in bytes, in the data buffer where the operation starts.</span></span></param>
        <param name="count"><span data-ttu-id="b2e37-280">可在缓冲区中发送或接收的最大数据量（以字节为单位）。</span><span class="sxs-lookup"><span data-stu-id="b2e37-280">The maximum amount of data, in bytes, to send or receive in the buffer.</span></span></param>
        <summary><span data-ttu-id="b2e37-281">设置要用于异步套接字方法的数据缓冲区。</span><span class="sxs-lookup"><span data-stu-id="b2e37-281">Sets the data buffer to use with an asynchronous socket method.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b2e37-282">`offset` 和 `count` 参数不能为负数。</span><span class="sxs-lookup"><span data-stu-id="b2e37-282">The `offset` and `count` parameters can't be negative numbers.</span></span> <span data-ttu-id="b2e37-283">`offset` 和 `count` 参数的组合必须在 `buffer` 参数中的数据数组边界内。</span><span class="sxs-lookup"><span data-stu-id="b2e37-283">The combination of the `offset` and `count` parameters must be in bounds of the data array in the `buffer` parameter.</span></span>  
  
 <span data-ttu-id="b2e37-284">此方法将 <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A> 属性设置为 `buffer` 参数，将 <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A> 属性设置为 `count` 参数，将 <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A> 属性设置为 `offset` 参数。</span><span class="sxs-lookup"><span data-stu-id="b2e37-284">This method sets the <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A> property to the `buffer` parameter, the <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A> property to the `count` parameter, and the <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A> property to the `offset` parameter.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b2e37-285">下面的代码示例创建一个大缓冲区，该缓冲区可被分割并分配到 <xref:System.Net.Sockets.SocketAsyncEventArgs> 对象，以便与每个套接字 i/o 操作一起使用。</span><span class="sxs-lookup"><span data-stu-id="b2e37-285">The following code example creates a single large buffer which can be divided up and assigned to <xref:System.Net.Sockets.SocketAsyncEventArgs> objects for use with each socket I/O operation.</span></span> <span data-ttu-id="b2e37-286">这使得可以轻松地重复使用缓冲区，并防止分段堆内存。</span><span class="sxs-lookup"><span data-stu-id="b2e37-286">This enables buffers to be easily reused and guards against fragmenting heap memory.</span></span>  
  
 [!code-csharp[NCLAsyncSocketServer#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLAsyncSocketServer/CS/AsyncSocketServer.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="b2e37-287">指定的缓冲区不明确。</span><span class="sxs-lookup"><span data-stu-id="b2e37-287">There are ambiguous buffers specified.</span></span> <span data-ttu-id="b2e37-288">如果 <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" /> 属性不为 null，<see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /> 属性也不为 null，将发生此异常。</span><span class="sxs-lookup"><span data-stu-id="b2e37-288">This exception occurs if the <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" /> property is also not null and the <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /> property is also not null.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="b2e37-289">参数超出范围。</span><span class="sxs-lookup"><span data-stu-id="b2e37-289">An argument was out of range.</span></span> <span data-ttu-id="b2e37-290">如果 <paramref name="offset" /> 参数小于零或大于 <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" /> 属性中的数组长度，将发生此异常。</span><span class="sxs-lookup"><span data-stu-id="b2e37-290">This exception occurs if the <paramref name="offset" /> parameter is less than zero or greater than the length of the array in the <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" /> property.</span></span> <span data-ttu-id="b2e37-291">如果 <paramref name="count" /> 参数小于零或大于 <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" /> 属性中的数组长度减去 <paramref name="offset" /> 参数的值，也会发生此异常。</span><span class="sxs-lookup"><span data-stu-id="b2e37-291">This exception also occurs if the <paramref name="count" /> parameter is less than zero or greater than the length of the array in the <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" /> property minus the <paramref name="offset" /> parameter.</span></span></exception>
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Offset" />
      </Docs>
    </Member>
    <Member MemberName="SocketClientAccessPolicyProtocol">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.SocketClientAccessPolicyProtocol SocketClientAccessPolicyProtocol { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Net.Sockets.SocketClientAccessPolicyProtocol SocketClientAccessPolicyProtocol" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.SocketAsyncEventArgs.SocketClientAccessPolicyProtocol" />
      <MemberSignature Language="VB.NET" Value="Public Property SocketClientAccessPolicyProtocol As SocketClientAccessPolicyProtocol" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Sockets::SocketClientAccessPolicyProtocol SocketClientAccessPolicyProtocol { System::Net::Sockets::SocketClientAccessPolicyProtocol get(); void set(System::Net::Sockets::SocketClientAccessPolicyProtocol value); };" />
      <MemberSignature Language="F#" Value="member this.SocketClientAccessPolicyProtocol : System.Net.Sockets.SocketClientAccessPolicyProtocol with get, set" Usage="System.Net.Sockets.SocketAsyncEventArgs.SocketClientAccessPolicyProtocol" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("This API supports the .NET Framework infrastructure and is not intended to be used directly from your code.", true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.SocketClientAccessPolicyProtocol</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="b2e37-292">获取或设置要用于下载套接字客户端访问策略文件的协议。</span><span class="sxs-lookup"><span data-stu-id="b2e37-292">Gets or sets the protocol to use to download the socket client access policy file.</span></span></summary>
        <value><span data-ttu-id="b2e37-293">要用于下载套接字客户端访问策略文件的协议。</span><span class="sxs-lookup"><span data-stu-id="b2e37-293">The protocol to use to download the socket client access policy file.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b2e37-294"><xref:System.Net.Sockets.SocketClientAccessPolicyProtocol> 指定下载客户端访问策略文件的方法。</span><span class="sxs-lookup"><span data-stu-id="b2e37-294">The <xref:System.Net.Sockets.SocketClientAccessPolicyProtocol> specifies the method to download a client access policy file.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SocketError">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.SocketError SocketError { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Net.Sockets.SocketError SocketError" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.SocketAsyncEventArgs.SocketError" />
      <MemberSignature Language="VB.NET" Value="Public Property SocketError As SocketError" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Sockets::SocketError SocketError { System::Net::Sockets::SocketError get(); void set(System::Net::Sockets::SocketError value); };" />
      <MemberSignature Language="F#" Value="member this.SocketError : System.Net.Sockets.SocketError with get, set" Usage="System.Net.Sockets.SocketAsyncEventArgs.SocketError" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.SocketError</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="b2e37-295">获取或设置异步套接字操作的结果。</span><span class="sxs-lookup"><span data-stu-id="b2e37-295">Gets or sets the result of the asynchronous socket operation.</span></span></summary>
        <value><span data-ttu-id="b2e37-296">一个 <see cref="T:System.Net.Sockets.SocketError" />，表示异步套接字操作的结果。</span><span class="sxs-lookup"><span data-stu-id="b2e37-296">A <see cref="T:System.Net.Sockets.SocketError" /> that represents the result of the asynchronous socket operation.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b2e37-297">此属性提供异步套接字操作的完成状态。</span><span class="sxs-lookup"><span data-stu-id="b2e37-297">This property provides the completion status of an asynchronous socket operation.</span></span> <span data-ttu-id="b2e37-298">值 <xref:System.Net.Sockets.SocketError.Success?displayProperty=nameWithType> 指示操作的成功完成。</span><span class="sxs-lookup"><span data-stu-id="b2e37-298">A value of <xref:System.Net.Sockets.SocketError.Success?displayProperty=nameWithType> indicates successful completion of an operation.</span></span> <span data-ttu-id="b2e37-299">此属性主要在应用程序的事件处理程序例程中使用。</span><span class="sxs-lookup"><span data-stu-id="b2e37-299">This property is primarily used in an application's event handler routine.</span></span>  
  
 <span data-ttu-id="b2e37-300">此属性用于所有异步套接字（xxxAsync）方法。</span><span class="sxs-lookup"><span data-stu-id="b2e37-300">This property is used with all of the asynchronous socket (xxxAsync) methods.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
        <altmember cref="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
        <altmember cref="M:System.Net.Sockets.Socket.DisconnectAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFromAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveMessageFromAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
        <altmember cref="T:System.Net.Sockets.SocketError" />
      </Docs>
    </Member>
    <Member MemberName="SocketFlags">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.SocketFlags SocketFlags { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Net.Sockets.SocketFlags SocketFlags" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags" />
      <MemberSignature Language="VB.NET" Value="Public Property SocketFlags As SocketFlags" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Sockets::SocketFlags SocketFlags { System::Net::Sockets::SocketFlags get(); void set(System::Net::Sockets::SocketFlags value); };" />
      <MemberSignature Language="F#" Value="member this.SocketFlags : System.Net.Sockets.SocketFlags with get, set" Usage="System.Net.Sockets.SocketAsyncEventArgs.SocketFlags" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.SocketFlags</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="b2e37-301">获取异步套接字操作的结果或设置异步操作的行为。</span><span class="sxs-lookup"><span data-stu-id="b2e37-301">Gets the results of an asynchronous socket operation or sets the behavior of an asynchronous operation.</span></span></summary>
        <value><span data-ttu-id="b2e37-302">一个 <see cref="T:System.Net.Sockets.SocketFlags" />，表示异步套接字操作的结果。</span><span class="sxs-lookup"><span data-stu-id="b2e37-302">A <see cref="T:System.Net.Sockets.SocketFlags" /> that represents the results of an asynchronous socket operation.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b2e37-303">属性指定要用于异步套接字操作的 <xref:System.Net.Sockets.SocketFlags?displayProperty=nameWithType> 的按位组合。</span><span class="sxs-lookup"><span data-stu-id="b2e37-303">The property specifies the bitwise combination of the <xref:System.Net.Sockets.SocketFlags?displayProperty=nameWithType> to be used for an asynchronous socket operation.</span></span>  
  
 <span data-ttu-id="b2e37-304">此属性与 <xref:System.Net.Sockets.Socket.ReceiveAsync%2A?displayProperty=nameWithType>、<xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A?displayProperty=nameWithType>、<xref:System.Net.Sockets.Socket.SendAsync%2A?displayProperty=nameWithType>和 <xref:System.Net.Sockets.Socket.SendToAsync%2A?displayProperty=nameWithType> 方法一起使用。</span><span class="sxs-lookup"><span data-stu-id="b2e37-304">This property is used with the <xref:System.Net.Sockets.Socket.ReceiveAsync%2A?displayProperty=nameWithType>, <xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A?displayProperty=nameWithType>, <xref:System.Net.Sockets.Socket.SendAsync%2A?displayProperty=nameWithType>, and <xref:System.Net.Sockets.Socket.SendToAsync%2A?displayProperty=nameWithType> methods.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFromAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
      </Docs>
    </Member>
    <Member MemberName="UserToken">
      <MemberSignature Language="C#" Value="public object UserToken { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object UserToken" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      <MemberSignature Language="VB.NET" Value="Public Property UserToken As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ UserToken { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.UserToken : obj with get, set" Usage="System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="b2e37-305">获取或设置与此异步套接字操作关联的用户或应用程序对象。</span><span class="sxs-lookup"><span data-stu-id="b2e37-305">Gets or sets a user or application object associated with this asynchronous socket operation.</span></span></summary>
        <value><span data-ttu-id="b2e37-306">一个对象，表示与此异步套接字操作关联的用户或应用程序对象。</span><span class="sxs-lookup"><span data-stu-id="b2e37-306">An object that represents the user or application object associated with this asynchronous socket operation.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b2e37-307">应用程序可以使用此属性将应用程序状态对象与 <xref:System.Net.Sockets.SocketAsyncEventArgs> 对象相关联。</span><span class="sxs-lookup"><span data-stu-id="b2e37-307">This property can be used by an application to associate an application state object with the <xref:System.Net.Sockets.SocketAsyncEventArgs> object.</span></span> <span data-ttu-id="b2e37-308">此属性主要用于向应用程序传递状态和应用程序的事件处理程序（例如异步操作完成方法）。</span><span class="sxs-lookup"><span data-stu-id="b2e37-308">Primarily, this property is a way for an application to pass state to the application's event handler (for example, the asynchronous operation completion method).</span></span>  
  
 <span data-ttu-id="b2e37-309">此属性用于所有异步套接字（xxxAsync）方法。</span><span class="sxs-lookup"><span data-stu-id="b2e37-309">This property is used with all of the asynchronous socket (xxxAsync) methods.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
        <altmember cref="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
        <altmember cref="M:System.Net.Sockets.Socket.DisconnectAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFromAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveMessageFromAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      </Docs>
    </Member>
  </Members>
</Type>
