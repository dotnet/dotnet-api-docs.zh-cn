<Type Name="Socket" FullName="System.Net.Sockets.Socket">
  <Metadata><Meta Name="ms.openlocfilehash" Value="a91dcb82ba6a2e41f15d1dfd0c8e241be2092487" /><Meta Name="ms.sourcegitcommit" Value="c982ad9e10a242d90f1e631b5981570f9e5d9f34" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-CN" /><Meta Name="ms.lasthandoff" Value="09/10/2020" /><Meta Name="ms.locfileid" Value="89835157" /></Metadata><TypeSignature Language="C#" Value="public class Socket : IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit Socket extends System.Object implements class System.IDisposable" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1" />
  <TypeSignature Language="DocId" Value="T:System.Net.Sockets.Socket" />
  <TypeSignature Language="VB.NET" Value="Public Class Socket&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Socket : IDisposable" />
  <TypeSignature Language="F#" Value="type Socket = class&#xA;    interface IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi Socket extends System.Object implements class System.IDisposable" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <AssemblyInfo>
    <AssemblyName>System.Net.Sockets</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
    <AssemblyVersion>4.2.2.0</AssemblyVersion>
    <AssemblyVersion>5.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Net</AssemblyName>
  </AssemblyInfo>
  <TypeForwardingChain>
    <TypeForwarding From="netstandard" FromVersion="2.1.0.0" To="System.Net.Sockets" ToVersion="5.0.0.0" FrameworkAlternate="net-5.0" />
    <TypeForwarding From="System.Net" FromVersion="4.0.0.0" To="System" ToVersion="4.0.0.0" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
  </TypeForwardingChain>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>实现 Berkeley 套接字接口。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket>类提供一组丰富的网络通信方法和属性。 <xref:System.Net.Sockets.Socket>类允许使用枚举中列出的任何通信协议执行同步和异步数据传输 <xref:System.Net.Sockets.ProtocolType> 。  
  
 <xref:System.Net.Sockets.Socket>类遵循异步方法的 .NET Framework 命名模式。 例如，同步 <xref:System.Net.Sockets.Socket.Receive%2A> 方法对应于异步 <xref:System.Net.Sockets.Socket.BeginReceive%2A> 和 <xref:System.Net.Sockets.Socket.EndReceive%2A> 方法。  
  
 如果应用程序在执行过程中只需要一个线程，请使用以下方法，这些方法是为同步操作模式设计的。  
  
-   如果使用面向连接的协议（例如 TCP），则服务器可以使用方法侦听连接 <xref:System.Net.Sockets.Socket.Listen%2A> 。 <xref:System.Net.Sockets.Socket.Accept%2A>方法处理任何传入的连接请求，并返回 <xref:System.Net.Sockets.Socket> 可用于与远程主机通信数据的。 使用此返回 <xref:System.Net.Sockets.Socket> 的调用 <xref:System.Net.Sockets.Socket.Send%2A> 或 <xref:System.Net.Sockets.Socket.Receive%2A> 方法。 <xref:System.Net.Sockets.Socket.Bind%2A> <xref:System.Net.Sockets.Socket.Listen%2A> 如果要指定本地 IP 地址和端口号，请在调用方法之前调用方法。 如果希望基础服务提供商为你分配一个可用端口，请使用端口号零。 如果要连接到侦听主机，请调用 <xref:System.Net.Sockets.Socket.Connect%2A> 方法。 若要传递数据，请调用 <xref:System.Net.Sockets.Socket.Send%2A> 或 <xref:System.Net.Sockets.Socket.Receive%2A> 方法。  
  
-   如果使用的是无连接协议（如 UDP），则无需侦听连接。 调用 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 方法以接受任何传入的数据报。 使用 <xref:System.Net.Sockets.Socket.SendTo%2A> 方法将数据报发送到远程主机。  
  
 若要在执行过程中使用单独的线程来处理通信，请使用以下方法，这些方法是为异步操作模式设计的。  
  
-   如果使用面向连接的协议（如 TCP），请使用 <xref:System.Net.Sockets.Socket> 、 <xref:System.Net.Sockets.Socket.BeginConnect%2A> 和 <xref:System.Net.Sockets.Socket.EndConnect%2A> 方法连接侦听主机。 使用 <xref:System.Net.Sockets.Socket.BeginSend%2A> 和 <xref:System.Net.Sockets.Socket.EndSend%2A> 或 <xref:System.Net.Sockets.Socket.BeginReceive%2A> 和 <xref:System.Net.Sockets.Socket.EndReceive%2A> 方法以异步方式传递数据。 可以使用和处理传入连接请求 <xref:System.Net.Sockets.Socket.BeginAccept%2A> <xref:System.Net.Sockets.Socket.EndAccept%2A> 。  
  
-   如果你使用的是无连接协议（如 UDP），则可以使用 <xref:System.Net.Sockets.Socket.BeginSendTo%2A> 和 <xref:System.Net.Sockets.Socket.EndSendTo%2A> 来发送数据报，并使用和 <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> 来接收数据报。  
  
 如果对套接字执行多个异步操作，则这些操作不一定按启动顺序完成。  
  
 完成发送和接收数据的操作后，请使用 <xref:System.Net.Sockets.Socket.Shutdown%2A> 方法禁用 <xref:System.Net.Sockets.Socket> 。 调用后 <xref:System.Net.Sockets.Socket.Shutdown%2A> ，调用 <xref:System.Net.Sockets.Socket.Close%2A> 方法以释放与关联的所有资源 <xref:System.Net.Sockets.Socket> 。  
  
 <xref:System.Net.Sockets.Socket>通过类，可以 <xref:System.Net.Sockets.Socket> 使用方法来配置 <xref:System.Net.Sockets.Socket.SetSocketOption%2A> 。 使用方法检索这些设置 <xref:System.Net.Sockets.Socket.GetSocketOption%2A> 。  
  
> [!NOTE]
>  如果你正在编写一个相对简单的应用程序，并且不需要最佳性能，请考虑使用 <xref:System.Net.Sockets.TcpClient> 、 <xref:System.Net.Sockets.TcpListener> 和 <xref:System.Net.Sockets.UdpClient> 。 这些类为通信提供更简单、更易于用户使用的界面 <xref:System.Net.Sockets.Socket> 。  
  
   
  
## Examples  
 下面的代码示例演示如何 <xref:System.Net.Sockets.Socket> 使用类将数据发送到 HTTP 服务器并接收响应。 在收到整个页面之前，此示例将会阻止。  
  
 [!code-cpp[System.Net.Sockets.Socket#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket/CPP/socket.cpp#1)]
 [!code-csharp[System.Net.Sockets.Socket#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket/CS/socket.cs#1)]
 [!code-vb[System.Net.Sockets.Socket#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.Sockets.Socket/VB/socket.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>此类的实例是线程安全的。</threadsafe>
    <altmember cref="N:System.Net" />
    <altmember cref="N:System.Net.Cache" />
    <altmember cref="N:System.Net.Security" />
    <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
    <related type="Article" href="/dotnet/framework/network-programming/">.NET Framework 中的网络编程</related>
    <related type="Article" href="/dotnet/framework/network-programming/best-practices-for-system-net-classes">System.Net 类的最佳实践</related>
    <related type="Article" href="/dotnet/framework/network-programming/cache-management-for-network-applications">网络应用程序的缓存管理</related>
    <related type="Article" href="/dotnet/framework/network-programming/internet-protocol-version-6">Internet 协议版本 6</related>
    <related type="Article" href="/dotnet/framework/network-programming/network-programming-samples">网络编程示例</related>
    <related type="Article" href="/dotnet/framework/network-programming/network-tracing">.NET Framework 中的网络跟踪</related>
    <related type="Article" href="/dotnet/framework/network-programming/security-in-network-programming">网络编程中的安全性</related>
    <related type="Article" href="/dotnet/framework/network-programming/socket-performance-enhancements-in-version-3-5">版本 3.5 中的套接字性能增强</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>初始化 <see cref="T:System.Net.Sockets.Socket" /> 类的新实例。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Socket (System.Net.Sockets.SafeSocketHandle handle);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Net.Sockets.SafeSocketHandle handle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.SafeSocketHandle)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (handle As SafeSocketHandle)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Socket(System::Net::Sockets::SafeSocketHandle ^ handle);" />
      <MemberSignature Language="F#" Value="new System.Net.Sockets.Socket : System.Net.Sockets.SafeSocketHandle -&gt; System.Net.Sockets.Socket" Usage="new System.Net.Sockets.Socket handle" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="handle" Type="System.Net.Sockets.SafeSocketHandle" Index="0" FrameworkAlternate="net-5.0" />
      </Parameters>
      <Docs>
        <param name="handle"><see cref="T:System.Net.Sockets.Socket" /> 对象将封装的套接字的套接字句柄。</param>
        <summary>为指定的套接字句柄初始化 <see cref="T:System.Net.Sockets.Socket" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

此方法 <xref:System.Net.Sockets.Socket> 用从提供的中收集的数据填充该实例 <xref:System.Net.Sockets.SafeSocketHandle> 。
不同的操作系统提供了不同级别的支持，可用于查询套接字句柄或文件描述符的属性和配置。 生成的实例上的一些公共 Api <xref:System.Net.Sockets.Socket> 可能因操作系统而异，例如 <xref:System.Net.Sockets.Socket.ProtocolType> 和 <xref:System.Net.Sockets.Socket.Blocking> 。

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="handle" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="handle" /> 无效。</exception>
        <exception cref="T:System.Net.Sockets.SocketException"><paramref name="handle" /> 不是套接字，或者无法访问有关套接字的信息。</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Socket (System.Net.Sockets.SocketInformation socketInformation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Net.Sockets.SocketInformation socketInformation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.SocketInformation)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (socketInformation As SocketInformation)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Socket(System::Net::Sockets::SocketInformation socketInformation);" />
      <MemberSignature Language="F#" Value="new System.Net.Sockets.Socket : System.Net.Sockets.SocketInformation -&gt; System.Net.Sockets.Socket" Usage="new System.Net.Sockets.Socket socketInformation" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="socketInformation" Type="System.Net.Sockets.SocketInformation" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="socketInformation"><see cref="M:System.Net.Sockets.Socket.DuplicateAndClose(System.Int32)" /> 返回的套接字信息。</param>
        <summary>使用 <see cref="T:System.Net.Sockets.Socket" /> 返回的指定的值初始化 <see cref="M:System.Net.Sockets.Socket.DuplicateAndClose(System.Int32)" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果多次调用 <xref:System.Net.Sockets.Socket.%23ctor%2A> 构造函数并将同一字节数组作为每次调用的参数，则将创建 <xref:System.Net.Sockets.Socket> 具有相同基础套接字的多个托管。 强烈建议您不要这样做。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Socket (System.Net.Sockets.SocketType socketType, System.Net.Sockets.ProtocolType protocolType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Net.Sockets.SocketType socketType, valuetype System.Net.Sockets.ProtocolType protocolType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (socketType As SocketType, protocolType As ProtocolType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Socket(System::Net::Sockets::SocketType socketType, System::Net::Sockets::ProtocolType protocolType);" />
      <MemberSignature Language="F#" Value="new System.Net.Sockets.Socket : System.Net.Sockets.SocketType * System.Net.Sockets.ProtocolType -&gt; System.Net.Sockets.Socket" Usage="new System.Net.Sockets.Socket (socketType, protocolType)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="socketType" Type="System.Net.Sockets.SocketType" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="protocolType" Type="System.Net.Sockets.ProtocolType" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="socketType"><see cref="T:System.Net.Sockets.SocketType" /> 值之一。</param>
        <param name="protocolType"><see cref="T:System.Net.Sockets.ProtocolType" /> 值之一。</param>
        <summary>使用指定的地址族、套接字类型和协议初始化 <see cref="T:System.Net.Sockets.Socket" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `socketType`参数指定类的类型 <xref:System.Net.Sockets.Socket> ， `protocolType` 参数指定所使用的协议 <xref:System.Net.Sockets.Socket> 。 这两个参数不是独立的。 通常， <xref:System.Net.Sockets.Socket> 类型在协议中是隐式的。 如果 <xref:System.Net.Sockets.Socket> 类型类型和协议类型的组合导致无效，则 <xref:System.Net.Sockets.Socket> 此构造函数引发 <xref:System.Net.Sockets.SocketException> 。  
  
> [!NOTE]
>  如果此构造函数引发 <xref:System.Net.Sockets.SocketException> ，则使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性来获取特定的错误代码。 获取此代码后，请参阅 [Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2) 文档，以获取有关错误的详细说明。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅 [.NET Framework 中的网络跟踪](/dotnet/framework/network-programming/network-tracing)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><paramref name="socketType" /> 和 <paramref name="protocolType" /> 组合将导致套接字无效。</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Socket (System.Net.Sockets.AddressFamily addressFamily, System.Net.Sockets.SocketType socketType, System.Net.Sockets.ProtocolType protocolType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Net.Sockets.AddressFamily addressFamily, valuetype System.Net.Sockets.SocketType socketType, valuetype System.Net.Sockets.ProtocolType protocolType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.AddressFamily,System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (addressFamily As AddressFamily, socketType As SocketType, protocolType As ProtocolType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Socket(System::Net::Sockets::AddressFamily addressFamily, System::Net::Sockets::SocketType socketType, System::Net::Sockets::ProtocolType protocolType);" />
      <MemberSignature Language="F#" Value="new System.Net.Sockets.Socket : System.Net.Sockets.AddressFamily * System.Net.Sockets.SocketType * System.Net.Sockets.ProtocolType -&gt; System.Net.Sockets.Socket" Usage="new System.Net.Sockets.Socket (addressFamily, socketType, protocolType)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="addressFamily" Type="System.Net.Sockets.AddressFamily" />
        <Parameter Name="socketType" Type="System.Net.Sockets.SocketType" />
        <Parameter Name="protocolType" Type="System.Net.Sockets.ProtocolType" />
      </Parameters>
      <Docs>
        <param name="addressFamily"><see cref="T:System.Net.Sockets.AddressFamily" /> 值之一。</param>
        <param name="socketType"><see cref="T:System.Net.Sockets.SocketType" /> 值之一。</param>
        <param name="protocolType"><see cref="T:System.Net.Sockets.ProtocolType" /> 值之一。</param>
        <summary>使用指定的地址族、套接字类型和协议初始化 <see cref="T:System.Net.Sockets.Socket" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `addressFamily`参数指定类使用的寻址方案 <xref:System.Net.Sockets.Socket> ， `socketType` 参数指定类的类型 <xref:System.Net.Sockets.Socket> ， `protocolType` 参数指定所使用的协议 <xref:System.Net.Sockets.Socket> 。 这三个参数不是独立的。 某些地址族限制可与它们一起使用的协议，而类型通常 <xref:System.Net.Sockets.Socket> 是协议中的隐式。 如果地址族、 <xref:System.Net.Sockets.Socket> 类型和协议类型的组合导致无效 <xref:System.Net.Sockets.Socket> ，则此构造函数会引发 <xref:System.Net.Sockets.SocketException> 。  
  
> [!NOTE]
>  如果此构造函数引发 <xref:System.Net.Sockets.SocketException> ，则使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性来获取特定的错误代码。 获取此代码后，请参阅 [Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2) 文档，以获取有关错误的详细说明。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅 [.NET Framework 中的网络跟踪](/dotnet/framework/network-programming/network-tracing)。  
  
   
  
## Examples  
 下面的代码示例演示如何创建类的实例 <xref:System.Net.Sockets.Socket> 。  
  
 [!code-cpp[Socket_Send_Receive#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Send_Receive/CPP/source.cpp#1)]
 [!code-csharp[Socket_Send_Receive#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Send_Receive/CS/source.cs#1)]
 [!code-vb[Socket_Send_Receive#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Send_Receive/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><paramref name="addressFamily" />、<paramref name="socketType" /> 和 <paramref name="protocolType" /> 的组合会导致无效套接字。</exception>
        <altmember cref="T:System.Net.Sockets.SocketException" />
        <altmember cref="T:System.Net.Sockets.AddressFamily" />
        <altmember cref="T:System.Net.Sockets.ProtocolType" />
        <altmember cref="T:System.Net.Sockets.SocketType" />
      </Docs>
    </Member>
    <Member MemberName="Accept">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.Socket Accept ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.Sockets.Socket Accept() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Accept" />
      <MemberSignature Language="VB.NET" Value="Public Function Accept () As Socket" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::Sockets::Socket ^ Accept();" />
      <MemberSignature Language="F#" Value="member this.Accept : unit -&gt; System.Net.Sockets.Socket" Usage="socket.Accept " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.Socket</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>为新建连接创建新的 <see cref="T:System.Net.Sockets.Socket" />。</summary>
        <returns>新建连接的 <see cref="T:System.Net.Sockets.Socket" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Accept%2A> 从侦听套接字的连接请求队列中同步提取第一个挂起的连接请求，然后创建并返回一个新的 <xref:System.Net.Sockets.Socket> 。 不能使用此返回的 <xref:System.Net.Sockets.Socket> 来接受连接队列中的任何其他连接。 但是，可以调用 <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> 返回的的方法 <xref:System.Net.Sockets.Socket> 来识别远程主机的网络地址和端口号。  
  
 在阻止模式下， <xref:System.Net.Sockets.Socket.Accept%2A> 阻止传入连接尝试排队。 连接被接受后，原始将 <xref:System.Net.Sockets.Socket> 继续排队传入连接请求，直到你将其关闭。  
  
 如果使用非阻塞调用此方法 <xref:System.Net.Sockets.Socket> ，并且没有连接请求排队，则会 <xref:System.Net.Sockets.Socket.Accept%2A> 引发 <xref:System.Net.Sockets.SocketException> 。 如果收到 <xref:System.Net.Sockets.SocketException> ，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。 获取此代码后，请参阅 [Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2) 文档，以获取有关错误的详细说明。  
  
> [!NOTE]
>  在调用 <xref:System.Net.Sockets.Socket.Accept%2A> 方法之前，必须先调用 <xref:System.Net.Sockets.Socket.Listen%2A> 方法来侦听传入连接请求并对其进行排队。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅 [.NET Framework 中的网络跟踪](/dotnet/framework/network-programming/network-tracing)。  
  
   
  
## Examples  
 下面的代码示例接受简单 <xref:System.Net.Sockets.Socket> 连接。  
  
 [!code-cpp[Classic Socket.Accept Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Accept Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Accept Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Accept Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Accept Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Accept Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <exception cref="T:System.InvalidOperationException">正在接受的套接字不会侦听连接。 在调用 <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> 之前必须调用 <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> 和 <see cref="M:System.Net.Sockets.Socket.Accept" />。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />
        <altmember cref="P:System.Net.Sockets.Socket.RemoteEndPoint" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="AcceptAsync">
      <MemberSignature Language="C#" Value="public bool AcceptAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool AcceptAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function AcceptAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool AcceptAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.AcceptAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="socket.AcceptAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="e">要用于此异步套接字操作的 <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> 对象。</param>
        <summary>开始一个异步操作来接受一个传入的连接尝试。</summary>
        <returns>如果 I/O 操作挂起，则为 <see langword="true" />。 操作完成时，将引发 <paramref name="e" /> 参数的 <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> 事件。  
  
 如果 I/O 操作同步完成，则为 <see langword="false" />。 将不会引发 <paramref name="e" /> 参数的 <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> 事件，并且可能在方法调用返回后立即检查作为参数传递的 <paramref name="e" /> 对象以检索操作的结果。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 面向连接的协议可以使用 <xref:System.Net.Sockets.Socket.AcceptAsync%2A> 方法异步处理传入的连接尝试。 异步接受连接使你能够在单独的执行线程中发送和接收数据。 在调用 <xref:System.Net.Sockets.Socket.AcceptAsync%2A> 方法之前，必须调用 <xref:System.Net.Sockets.Socket.Listen%2A> 方法以侦听传入连接请求并对其进行排队。  
  
 若要在完成时收到通知，必须创建实现 EventHandler 委托的回调方法， \<SocketAsyncEventArgs> 并将其挂钩到 <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType> 事件。  
  
 对象上的下列属性和事件 <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> 是必需的：  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
 调用方可以选择指定要用于 <xref:System.Net.Sockets.Socket> 传入连接的现有，方法是指定 <xref:System.Net.Sockets.Socket> 要与属性一起使用的 <xref:System.Net.Sockets.SocketAsyncEventArgs.AcceptSocket%2A?displayProperty=nameWithType> 。  
  
 如果 <xref:System.Net.Sockets.SocketAsyncEventArgs.AcceptSocket%2A?displayProperty=nameWithType> 属性为 null，则使用与 <xref:System.Net.Sockets.Socket> 当前相同的、和来构造新的， <xref:System.Net.Sockets.Socket.AddressFamily%2A> <xref:System.Net.Sockets.Socket.SocketType%2A> <xref:System.Net.Sockets.Socket.ProtocolType%2A> <xref:System.Net.Sockets.Socket> 并将设置为 <xref:System.Net.Sockets.SocketAsyncEventArgs.AcceptSocket%2A?displayProperty=nameWithType> 属性。  
  
 调用方可以 <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> 在调用方法之前将属性设置为所需的任何用户状态对象 <xref:System.Net.Sockets.Socket.AcceptAsync%2A> ，以便可以在回调方法中检索信息。 如果回调需要比单个对象更多的信息，则可以创建一个小类，以将其他所需的状态信息保存为成员。  
  
 （可选）可以在方法成功后，提供缓冲区来接收套接字上的初始数据块 <xref:System.Net.Sockets.Socket.ConnectAsync%2A> 。 在这种情况下， <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> 需要将属性设置为包含要接收数据的缓冲区，并且 <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> 需要将属性设置为要在缓冲区中接收的数据的最大字节数。 可以使用方法设置这些属性 <xref:System.Net.Sockets.SocketAsyncEventArgs.SetBuffer%2A?displayProperty=nameWithType> 。 传入的缓冲区部分将在内部使用，供基础 Winsock AcceptEx 调用使用。 这意味着返回的数据量将始终小于 <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> 提供的实例的属性值 <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> 。 基于套接字的地址族，在内部使用的缓冲区量会有所不同。 所需的最小缓冲区大小为288个字节。 如果指定较大的缓冲区大小，则 <xref:System.Net.Sockets.Socket> 将期望一些额外的数据（而不是 Winsock AcceptEx 调用接收到的地址数据），并将等待，直到收到此额外的数据。 如果发生超时，则会重置连接。 因此，如果特定金额需要额外数据，则应将缓冲区大小设置为最小缓冲区大小加上此量。  
  
 完成回调方法应检查 <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType> 属性，以确定 <xref:System.Net.Sockets.Socket.AcceptAsync%2A> 操作是否成功。  
  
 <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>在某些情况下，如果未接受连接并且使属性设置为，则可能发生此事件 <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType> <xref:System.Net.Sockets.SocketError.ConnectionReset> 。 这种情况可能是由于使用半开放式 SYN 类型扫描的端口扫描引起的， (SYN > SYN-> RST 序列) 。 应准备使用方法的应用程序 <xref:System.Net.Sockets.Socket.AcceptAsync%2A> 来处理这种情况。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">自变量无效。 如果所提供的缓冲区不够大，将会发生此异常。 缓冲区必须至少为 2 * (sizeof(SOCKADDR_STORAGE + 16) 字节。  
  
如果指定了多个缓冲区，即 <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /> 属性不为 null，也会发生此异常。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">参数超出范围。 如果 <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" /> 小于 0，将会发生此异常。</exception>
        <exception cref="T:System.InvalidOperationException">请求了无效操作。 如果接收方 <see cref="T:System.Net.Sockets.Socket" /> 未侦听连接或者绑定了接受的套接字，将发生此异常。  
  
<see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> 和 <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> 方法必须先于 <see cref="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)" /> 方法调用。  
  
如果套接字已连接或使用指定的 <paramref name="e" /> 参数的套接字操作已经在进行中，也会发生此异常。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.NotSupportedException">此方法需要 Windows XP 或更高版本。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.AcceptSocket" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="AddressFamily">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.AddressFamily AddressFamily { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Net.Sockets.AddressFamily AddressFamily" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.AddressFamily" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AddressFamily As AddressFamily" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Sockets::AddressFamily AddressFamily { System::Net::Sockets::AddressFamily get(); };" />
      <MemberSignature Language="F#" Value="member this.AddressFamily : System.Net.Sockets.AddressFamily" Usage="System.Net.Sockets.Socket.AddressFamily" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.AddressFamily</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取 <see cref="T:System.Net.Sockets.Socket" /> 的地址族。</summary>
        <value><see cref="T:System.Net.Sockets.AddressFamily" /> 值之一。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.AddressFamily>指定类的实例可以使用的寻址方案 <xref:System.Net.Sockets.Socket> 。 此属性是只读的，并且在创建时设置 <xref:System.Net.Sockets.Socket> 。  
  
   
  
## Examples  
 下面的代码示例将 <xref:System.Net.Sockets.AddressFamily> 、 <xref:System.Net.Sockets.SocketType> 和显示 <xref:System.Net.Sockets.ProtocolType> 到控制台。  
  
 [!code-cpp[Socket_Socket_Options#3](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#3)]
 [!code-csharp[Socket_Socket_Options#3](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#3)]
 [!code-vb[Socket_Socket_Options#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.Sockets.AddressFamily" />
      </Docs>
    </Member>
    <Member MemberName="Available">
      <MemberSignature Language="C#" Value="public int Available { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Available" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.Available" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Available As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Available { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Available : int" Usage="System.Net.Sockets.Socket.Available" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取已经从网络接收且可供读取的数据量。</summary>
        <value>从网络接收的、可供读取的数据的字节数。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果使用的是非阻塞 <xref:System.Net.Sockets.Socket> 方法，则在 <xref:System.Net.Sockets.Socket.Available%2A> 调用之前确定数据是否排队等待读取 <xref:System.Net.Sockets.Socket.Receive%2A> 。 可用数据是要读取的网络缓冲区中排队的数据总量。 如果网络缓冲区中没有数据排队，则 <xref:System.Net.Sockets.Socket.Available%2A> 返回0。  
  
 如果远程主机关闭或关闭连接，则 <xref:System.Net.Sockets.Socket.Available%2A> 可能会引发 <xref:System.Net.Sockets.SocketException> 。 如果收到 <xref:System.Net.Sockets.SocketException> ，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。 获取此代码后，请参阅 [Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2) 文档，以获取有关错误的详细说明。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅 [.NET Framework 中的网络跟踪](/dotnet/framework/network-programming/network-tracing)。  
  
   
  
## Examples  
 下面的代码示例将调用 IOControl 和 FIONREAD 以及可用属性的结果进行比较。  
  
 [!code-cpp[NCLSocketIoControl#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketIoControl/CPP/iocontrolserver.cpp#1)]
 [!code-csharp[NCLSocketIoControl#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketIoControl/CS/iocontrolserver.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="T:System.IO.Stream" />
        <altmember cref="F:System.Net.Sockets.SocketType.Dgram" />
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginAccept">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>开始一个异步操作来接受一个传入的连接尝试。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginAccept">
      <MemberSignature Language="C#" Value="public IAsyncResult? BeginAccept (AsyncCallback callback, object state);" FrameworkAlternate="net-5.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginAccept(class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginAccept (callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginAccept(AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginAccept : AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginAccept (callback, state)" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginAccept (AsyncCallback callback, object state);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.AsyncCallback" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="state" Type="System.Object" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="callback"><see cref="T:System.AsyncCallback" /> 委托。</param>
        <param name="state">包含此请求的状态信息的对象。</param>
        <summary>开始一个异步操作来接受一个传入的连接尝试。</summary>
        <returns>一个 <see cref="T:System.IAsyncResult" />，它引用异步 <see cref="T:System.Net.Sockets.Socket" /> 创建。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 面向连接的协议可以使用 <xref:System.Net.Sockets.Socket.BeginAccept%2A> 方法异步处理传入的连接尝试。 异步接受连接使你能够在单独的执行线程中发送和接收数据。 在调用 <xref:System.Net.Sockets.Socket.BeginAccept%2A> 方法之前，必须调用 <xref:System.Net.Sockets.Socket.Listen%2A> 方法以侦听传入连接请求并对其进行排队。  
  
 您必须创建一个实现委托的回调方法 <xref:System.AsyncCallback> ，并将其名称传递给 <xref:System.Net.Sockets.Socket.BeginAccept%2A> 方法。 为此，必须至少 <xref:System.Net.Sockets.Socket> 通过参数将侦听对象传递给 <xref:System.Net.Sockets.Socket.BeginAccept%2A> `state` 。 如果回调需要更多的信息，可以创建一个小类来保存 <xref:System.Net.Sockets.Socket> 和其他所需的信息。 通过参数将此类的一个实例传递给 <xref:System.Net.Sockets.Socket.BeginAccept%2A> 方法 `state` 。  
  
 回调方法应调用 <xref:System.Net.Sockets.Socket.EndAccept%2A> 方法。 当应用程序调用时 <xref:System.Net.Sockets.Socket.BeginAccept%2A> ，系统通常使用单独的线程来执行指定的回调方法，并在 <xref:System.Net.Sockets.Socket.EndAccept%2A> 检索到挂起的连接之前将其阻止。 <xref:System.Net.Sockets.Socket.EndAccept%2A> 将返回一个新 <xref:System.Net.Sockets.Socket> 的对象，该对象可用于发送和接收与远程主机的数据。 不能使用此返回的 <xref:System.Net.Sockets.Socket> 来接受连接队列中的任何其他连接。 如果希望在调用方法后原始线程会被阻止 <xref:System.Net.Sockets.Socket.BeginAccept%2A> ，请使用 <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType> 。 <xref:System.Threading.ManualResetEvent>当你希望原始线程继续执行时，请在回调方法中调用的 Set 方法。  
  
 系统还可以使用调用线程调用回调方法。 在这种情况下， <xref:System.IAsyncResult.CompletedSynchronously%2A> 返回的上的属性 <xref:System.IAsyncResult> 将设置为指示该 <xref:System.Net.Sockets.Socket.BeginAccept%2A> 方法已同步完成。  
  
 有关编写回调方法的其他信息，请参阅将 [委托作为回调方法进行封送处理](/dotnet/framework/interop/marshaling-a-delegate-as-a-callback-method)。  
  
 若要取消挂起的方法调用 <xref:System.Net.Sockets.Socket.BeginAccept%2A> ，请关闭 <xref:System.Net.Sockets.Socket> 。 如果在 <xref:System.Net.Sockets.Socket.Close%2A> 异步操作过程中调用方法，则会调用向方法提供的回调 <xref:System.Net.Sockets.Socket.BeginAccept%2A> 。  对方法的后续调用 <xref:System.Net.Sockets.Socket.EndAccept%2A> 将引发 <xref:System.ObjectDisposedException> ，以指示该操作已取消。  
  
> [!NOTE]
>  你可以使用 <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> 返回的的属性 <xref:System.Net.Sockets.Socket> 来标识远程主机的网络地址和端口号。  
  
> [!NOTE]
>  如果收到 <xref:System.Net.Sockets.SocketException> ，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。 获取此代码后，请参阅 [Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2) 文档，以获取有关错误的详细说明。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅 [.NET Framework 中的网络跟踪](/dotnet/framework/network-programming/network-tracing)。  
  
> [!NOTE]
>  将为异步方法缓存 (安全上下文、模拟用户和调用上下文) 的执行上下文 <xref:System.Net.Sockets.Socket> 。 第一次使用特定的上下文 (特定的异步 <xref:System.Net.Sockets.Socket> 方法、特定的 <xref:System.Net.Sockets.Socket> 实例和特定的回调) 后，该上下文的后续使用将会提高性能。  
  
   
  
## Examples  
 下面的代码示例尝试异步接收传入连接。  
  
 [!code-cpp[Socket_Async_Send_Receive#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#2)]
 [!code-csharp[Socket_Async_Send_Receive#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#2)]
 [!code-vb[Socket_Async_Send_Receive#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 对象已关闭。</exception>
        <exception cref="T:System.NotSupportedException">此方法需要 Windows NT。</exception>
        <exception cref="T:System.InvalidOperationException">正在接受的套接字不会侦听连接。 在调用 <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> 之前必须调用 <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> 和 <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />。  
  
- 或 - 
已接受的套接字是绑定的。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="receiveSize" /> 小于 0。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
        <altmember cref="T:System.Net.Sockets.Socket" />
        <altmember cref="P:System.Net.Sockets.Socket.RemoteEndPoint" />
        <related type="Article" href="/dotnet/framework/network-programming/asynchronous-client-socket-example">异步客户端套接字示例</related>
        <related type="Article" href="/dotnet/framework/network-programming/asynchronous-server-socket-example">异步服务器套接字示例</related>
      </Docs>
    </Member>
    <Member MemberName="BeginAccept">
      <MemberSignature Language="C#" Value="public IAsyncResult? BeginAccept (int receiveSize, AsyncCallback callback, object state);" FrameworkAlternate="net-5.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginAccept(int32 receiveSize, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginAccept (receiveSize As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginAccept(int receiveSize, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginAccept : int * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginAccept (receiveSize, callback, state)" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginAccept (int receiveSize, AsyncCallback callback, object state);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="receiveSize" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="state" Type="System.Object" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="receiveSize">要从发送方读取的字节数。</param>
        <param name="callback"><see cref="T:System.AsyncCallback" /> 委托。</param>
        <param name="state">包含此请求的状态信息的对象。</param>
        <summary>开始异步操作以接受传入的连接尝试并接收客户端应用程序发送的第一个数据块。</summary>
        <returns>一个 <see cref="T:System.IAsyncResult" />，它引用异步 <see cref="T:System.Net.Sockets.Socket" /> 创建。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 面向连接的协议可以使用 <xref:System.Net.Sockets.Socket.BeginAccept%2A> 方法异步处理传入的连接尝试。 通过异步接受连接，可以在单独的执行线程中发送和接收数据。 此重载允许您在参数中指定要在初始传输中接受的字节数 `receiveSize` 。  
  
 在调用 <xref:System.Net.Sockets.Socket.BeginAccept%2A> 方法之前，必须调用 <xref:System.Net.Sockets.Socket.Listen%2A> 方法以侦听传入连接请求并对其进行排队。  
  
 您必须创建一个实现委托的回调方法 <xref:System.AsyncCallback> ，并将其名称传递给 <xref:System.Net.Sockets.Socket.BeginAccept%2A> 方法。 为此，必须至少 <xref:System.Net.Sockets.Socket> 通过参数将侦听对象传递给 <xref:System.Net.Sockets.Socket.BeginAccept%2A> `state` 。 如果回调需要更多的信息，可以创建一个小类来保存 <xref:System.Net.Sockets.Socket> 和其他所需的信息。 通过参数将此类的一个实例传递给 <xref:System.Net.Sockets.Socket.BeginAccept%2A> 方法 `state` 。  
  
 回调方法应调用 <xref:System.Net.Sockets.Socket.EndAccept%2A> 方法。 当应用程序调用时 <xref:System.Net.Sockets.Socket.BeginAccept%2A> ，系统通常使用单独的线程来执行指定的回调方法，并在 <xref:System.Net.Sockets.Socket.EndAccept%2A> 检索到挂起的连接之前将其阻止。  
  
 <xref:System.Net.Sockets.Socket.EndAccept%2A> 返回一个新 <xref:System.Net.Sockets.Socket> 的，它可用于发送和接收与远程主机的数据。 不能使用此返回的 <xref:System.Net.Sockets.Socket> 来接受连接队列中的任何其他连接。 如果希望在调用方法后原始线程会被阻止 <xref:System.Net.Sockets.Socket.BeginAccept%2A> ，请使用 <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType> 。 <xref:System.Threading.ManualResetEvent>当你希望原始线程继续执行时，请在回调方法中调用的 Set 方法。  
  
 系统还可以使用调用线程调用回调方法。 在这种情况下， <xref:System.IAsyncResult.CompletedSynchronously%2A> 返回的上的属性 <xref:System.IAsyncResult> 将设置为指示该 <xref:System.Net.Sockets.Socket.BeginAccept%2A> 方法已同步完成。  
  
 有关编写回调方法的其他信息，请参阅将 [委托作为回调方法进行封送处理](/dotnet/framework/interop/marshaling-a-delegate-as-a-callback-method)。  
  
 若要取消挂起的方法调用 <xref:System.Net.Sockets.Socket.BeginAccept%2A> ，请关闭 <xref:System.Net.Sockets.Socket> 。  如果在 <xref:System.Net.Sockets.Socket.Close%2A> 异步操作过程中调用方法，则会调用向方法提供的回调 <xref:System.Net.Sockets.Socket.BeginAccept%2A> 。  对方法的后续调用 <xref:System.Net.Sockets.Socket.EndAccept%2A> 将引发 <xref:System.ObjectDisposedException> ，以指示该操作已取消。  
  
> [!NOTE]
>  可以调用使用 <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> 返回对象的属性 <xref:System.Net.Sockets.Socket> 来标识远程主机的网络地址和端口号。  
  
> [!NOTE]
>  如果收到 <xref:System.Net.Sockets.SocketException> ，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。 获取此代码后，请参阅 [Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2) 文档，以获取有关错误的详细说明。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅 [.NET Framework 中的网络跟踪](/dotnet/framework/network-programming/network-tracing)。  
  
> [!NOTE]
>  将为异步方法缓存 (安全上下文、模拟用户和调用上下文) 的执行上下文 <xref:System.Net.Sockets.Socket> 。 第一次使用特定的上下文 (特定的异步 <xref:System.Net.Sockets.Socket> 方法、特定的 <xref:System.Net.Sockets.Socket> 实例和特定的回调) 后，该上下文的后续使用将会提高性能。  
  
   
  
## Examples  
 下面的代码示例打开套接字并接受异步连接。 在此示例中，套接字接受前10个字节的数据。 回调委托将接收的字节数和数据显示在控制台上。 <xref:System.Net.Sockets.Socket.BeginReceive%2A>有关如何接收剩余数据的说明，请参阅。  
  
 [!code-cpp[NCLSocketEnhancements#6](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#6)]
 [!code-csharp[NCLSocketEnhancements#6](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 对象已关闭。</exception>
        <exception cref="T:System.NotSupportedException">此方法需要 Windows NT。</exception>
        <exception cref="T:System.InvalidOperationException">正在接受的套接字不会侦听连接。 在调用 <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> 之前必须调用 <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> 和 <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />。  
  
- 或 - 
已接受的套接字是绑定的。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="receiveSize" /> 小于 0。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
        <altmember cref="T:System.Net.Sockets.Socket" />
        <altmember cref="P:System.Net.Sockets.Socket.RemoteEndPoint" />
        <related type="Article" href="/dotnet/framework/network-programming/asynchronous-client-socket-example">异步客户端套接字示例</related>
        <related type="Article" href="/dotnet/framework/network-programming/asynchronous-server-socket-example">异步服务器套接字示例</related>
      </Docs>
    </Member>
    <Member MemberName="BeginAccept">
      <MemberSignature Language="C#" Value="public IAsyncResult? BeginAccept (System.Net.Sockets.Socket acceptSocket, int receiveSize, AsyncCallback callback, object state);" FrameworkAlternate="net-5.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginAccept(class System.Net.Sockets.Socket acceptSocket, int32 receiveSize, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginAccept (acceptSocket As Socket, receiveSize As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginAccept(System::Net::Sockets::Socket ^ acceptSocket, int receiveSize, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginAccept : System.Net.Sockets.Socket * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginAccept (acceptSocket, receiveSize, callback, state)" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginAccept (System.Net.Sockets.Socket acceptSocket, int receiveSize, AsyncCallback callback, object state);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="acceptSocket" Type="System.Net.Sockets.Socket" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="receiveSize" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="state" Type="System.Object" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="acceptSocket">接受的 <see cref="T:System.Net.Sockets.Socket" /> 对象。 此值可为 <see langword="null" />。</param>
        <param name="receiveSize">要接收的最大字节数。</param>
        <param name="callback"><see cref="T:System.AsyncCallback" /> 委托。</param>
        <param name="state">包含此请求的状态信息的对象。</param>
        <summary>开始异步操作以接受从指定套接字传入的连接尝试并接收客户端应用程序发送的第一个数据块。</summary>
        <returns>一个 <see cref="T:System.IAsyncResult" /> 对象，它引用异步 <see cref="T:System.Net.Sockets.Socket" /> 对象创建。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 面向连接的协议可以使用 <xref:System.Net.Sockets.Socket.BeginAccept%2A> 方法异步处理传入的连接尝试。 异步接受连接使你能够在单独的执行线程中发送和接收数据。 此重载允许您在参数中指定已接受的套接字 `acceptSocket` 。 如果此参数为 `null` ，则已接受的套接字由 <xref:System.Net.Sockets.Socket.BeginAccept%2A> 方法创建。 可以在参数中指定初始传输时要接受的字节数 `receiveSize` 。  
  
 在调用 <xref:System.Net.Sockets.Socket.BeginAccept%2A> 方法之前，必须调用 <xref:System.Net.Sockets.Socket.Listen%2A> 方法以侦听传入连接请求并对其进行排队。  
  
 您必须创建一个实现委托的回调方法 <xref:System.AsyncCallback> ，并将其名称传递给 <xref:System.Net.Sockets.Socket.BeginAccept%2A> 方法。 为此，必须至少 <xref:System.Net.Sockets.Socket> 通过参数将侦听对象传递给 <xref:System.Net.Sockets.Socket.BeginAccept%2A> `state` 。 如果回调需要更多的信息，可以创建一个小类来保存 <xref:System.Net.Sockets.Socket> 和其他所需的信息。 通过参数将此类的一个实例传递给 <xref:System.Net.Sockets.Socket.BeginAccept%2A> 方法 `state` 。  
  
 回调方法应调用 <xref:System.Net.Sockets.Socket.EndAccept%2A> 方法。 当应用程序调用时 <xref:System.Net.Sockets.Socket.BeginAccept%2A> ，系统通常使用单独的线程来执行指定的回调方法，并在 <xref:System.Net.Sockets.Socket.EndAccept%2A> 检索到挂起的连接之前将其阻止。  
  
 <xref:System.Net.Sockets.Socket.EndAccept%2A> 返回一个新 <xref:System.Net.Sockets.Socket> 的对象，该对象可用于向远程主机发送和接收数据。 不能使用此返回的 <xref:System.Net.Sockets.Socket> 来接受连接队列中的任何其他连接。 如果希望在调用方法后原始线程会被阻止 <xref:System.Net.Sockets.Socket.BeginAccept%2A> ，请使用 <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType> 。 <xref:System.Threading.ManualResetEvent>当你希望原始线程继续执行时，请在回调方法中调用的 Set 方法。  
  
 系统还可以使用调用线程调用回调方法。 在这种情况下， <xref:System.IAsyncResult.CompletedSynchronously%2A> 返回的上的属性 <xref:System.IAsyncResult> 将设置为指示该 <xref:System.Net.Sockets.Socket.BeginAccept%2A> 方法已同步完成。  
  
 有关编写回调方法的其他信息，请参阅将 [委托作为回调方法进行封送处理](/dotnet/framework/interop/marshaling-a-delegate-as-a-callback-method)。  
  
 若要取消挂起的方法调用 <xref:System.Net.Sockets.Socket.BeginAccept%2A> ，请关闭 <xref:System.Net.Sockets.Socket> 。 如果在 <xref:System.Net.Sockets.Socket.Close%2A> 异步操作过程中调用方法，则会调用向方法提供的回调 <xref:System.Net.Sockets.Socket.BeginAccept%2A> 。  对方法的后续调用 <xref:System.Net.Sockets.Socket.EndAccept%2A> 将引发 <xref:System.ObjectDisposedException> ，以指示该操作已取消。  
  
> [!NOTE]
>  您可以使用 <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> 返回对象的属性 <xref:System.Net.Sockets.Socket> 来标识远程主机的网络地址和端口号。  
  
> [!NOTE]
>  如果收到 <xref:System.Net.Sockets.SocketException> ，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。 获取此代码后，请参阅 [Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2) 文档，以获取有关错误的详细说明。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅 [.NET Framework 中的网络跟踪](/dotnet/framework/network-programming/network-tracing)。  
  
> [!NOTE]
>  将为异步方法缓存 (安全上下文、模拟用户和调用上下文) 的执行上下文 <xref:System.Net.Sockets.Socket> 。 第一次使用特定的上下文 (特定的异步 <xref:System.Net.Sockets.Socket> 方法、特定的 <xref:System.Net.Sockets.Socket> 实例和特定的回调) 后，该上下文的后续使用将会提高性能。  
  
   
  
## Examples  
 下面的代码示例打开套接字并接受异步连接。 在此示例中，套接字接受初始10个字节的数据， `acceptSocket` 参数为 `null` ，这会强制 <xref:System.Net.Sockets.Socket.BeginAccept%2A> 方法创建已接受的套接字。 回调委托将接收的字节数和数据显示在控制台上。 <xref:System.Net.Sockets.Socket.BeginReceive%2A>有关如何接收剩余数据的说明，请参阅。  
  
 [!code-cpp[NCLSocketEnhancements#7](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#7)]
 [!code-csharp[NCLSocketEnhancements#7](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 对象已关闭。</exception>
        <exception cref="T:System.NotSupportedException">此方法需要 Windows NT。</exception>
        <exception cref="T:System.InvalidOperationException">正在接受的套接字不会侦听连接。 在调用 <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> 之前必须调用 <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> 和 <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />。  
  
- 或 - 
已接受的套接字是绑定的。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="receiveSize" /> 小于 0。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
        <altmember cref="T:System.Net.Sockets.Socket" />
        <altmember cref="P:System.Net.Sockets.Socket.RemoteEndPoint" />
        <related type="Article" href="/dotnet/framework/network-programming/asynchronous-client-socket-example">异步客户端套接字示例</related>
        <related type="Article" href="/dotnet/framework/network-programming/asynchronous-server-socket-example">异步服务器套接字示例</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginConnect">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>开始一个对远程主机连接的异步请求。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginConnect">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (System.Net.EndPoint remoteEP, AsyncCallback? callback, object? state);" FrameworkAlternate="net-5.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(class System.Net.EndPoint remoteEP, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (remoteEP As EndPoint, callback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(System::Net::EndPoint ^ remoteEP, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.BeginConnect : System.Net.EndPoint * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginConnect (remoteEP, callback, state)" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (System.Net.EndPoint remoteEP, AsyncCallback callback, object state);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (System.Net.EndPoint end_point, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(class System.Net.EndPoint end_point, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (end_point As EndPoint, callback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(System::Net::EndPoint ^ end_point, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.BeginConnect : System.Net.EndPoint * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginConnect (end_point, callback, state)" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="end_point" Type="System.Net.EndPoint" Index="0" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="state" Type="System.Object" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="remoteEP">表示远程主机的 <see cref="T:System.Net.EndPoint" />。</param>
        <param name="end_point"><see cref="T:System.Net.EndPoint" />，它表示远程主机。</param>
        <param name="callback"><see cref="T:System.AsyncCallback" /> 委托。</param>
        <param name="state">包含此请求的状态信息的对象。</param>
        <summary>开始一个对远程主机连接的异步请求。</summary>
        <returns>引用异步连接的 <see cref="T:System.IAsyncResult" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果使用面向连接的协议，则该方法将 <xref:System.Net.Sockets.Socket.BeginConnect%2A> 启动与参数的连接的异步请求 `remoteEP` 。 如果使用的是无连接协议，则会 <xref:System.Net.Sockets.Socket.BeginConnect%2A> 建立默认远程主机。 使用异步方式连接或设置默认远程主机使你能够在单独的执行线程中发送和接收数据。  
  
 你可以创建一个实现委托的回调方法 <xref:System.AsyncCallback> ，并将其名称传递给 <xref:System.Net.Sockets.Socket.BeginConnect%2A> 方法。 在极少数情况下，必须 <xref:System.Net.Sockets.Socket> <xref:System.Net.Sockets.Socket.BeginConnect%2A> 通过参数将传递给 `state` 。 如果回调需要更多的信息，可以创建一个小类来保存 <xref:System.Net.Sockets.Socket> 和其他所需的信息。 通过参数将此类的一个实例传递给 <xref:System.Net.Sockets.Socket.BeginConnect%2A> 方法 `state` 。  
  
 回调方法应调用 <xref:System.Net.Sockets.Socket.EndConnect%2A> 方法。 当应用程序调用时 <xref:System.Net.Sockets.Socket.BeginConnect%2A> ，系统将使用一个单独的线程来执行指定的回调方法，并在 <xref:System.Net.Sockets.Socket.EndConnect%2A> <xref:System.Net.Sockets.Socket> 连接成功或引发异常前阻止。 如果希望在调用方法后原始线程会被阻止 <xref:System.Net.Sockets.Socket.BeginConnect%2A> ，请使用 <xref:System.Threading.WaitHandle.WaitOne%2A> 。 <xref:System.Threading.ManualResetEvent>当你希望原始线程继续执行时，请在回调方法中调用的 Set 方法。 有关编写回调方法的其他信息，请参阅将 [委托作为回调方法进行封送处理](/dotnet/framework/interop/marshaling-a-delegate-as-a-callback-method)。  
  
 如果使用的是无连接协议（如 UDP），则在 <xref:System.Net.Sockets.Socket.BeginConnect%2A> 发送和接收数据之前无需调用。 您可以使用 <xref:System.Net.Sockets.Socket.BeginSendTo%2A> 和 <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> 来与远程主机通信。 如果调用 <xref:System.Net.Sockets.Socket.BeginConnect%2A> 了，则从指定的默认值以外的地址到达的任何数据报都将被丢弃。 如果要将默认远程主机设置为广播地址，则必须先调用 <xref:System.Net.Sockets.Socket.SetSocketOption%2A> 并将广播设置为 `true` 。 如果无法这样做， <xref:System.Net.Sockets.Socket.BeginConnect%2A> 则将引发 <xref:System.Net.Sockets.SocketException> 。  
  
 如果使用面向连接的协议，且 <xref:System.Net.Sockets.Socket.Bind%2A> 在调用之前未调用 <xref:System.Net.Sockets.Socket.BeginConnect%2A> ，则基础服务提供程序将分配最适当的本地网络地址和端口号。 如果使用的是无连接协议，则在调用或方法之前，服务提供程序将不会分配本地网络地址和端口号 <xref:System.Net.Sockets.Socket.BeginSend%2A> <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 。 如果要更改默认远程主机，请 <xref:System.Net.Sockets.Socket.BeginConnect%2A> 与所需的终结点再次调用方法。  
  
 若要取消挂起的方法调用 <xref:System.Net.Sockets.Socket.BeginConnect%2A> ，请关闭 <xref:System.Net.Sockets.Socket> 。 如果在 <xref:System.Net.Sockets.Socket.Close%2A> 异步操作过程中调用方法，则会调用向方法提供的回调 <xref:System.Net.Sockets.Socket.BeginConnect%2A> 。  对方法的后续调用 <xref:System.Net.Sockets.Socket.EndConnect%2A> 将引发 <xref:System.ObjectDisposedException> ，以指示该操作已取消。  
  
> [!NOTE]
>  如果收到 <xref:System.Net.Sockets.SocketException> ，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。 获取此代码后，请参阅 [Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2) 文档，以获取有关错误的详细说明。  
  
> [!NOTE]
>  如果此套接字以前已断开连接，则 <xref:System.Net.Sockets.Socket.BeginConnect%2A> 必须在操作完成之前，将不会退出的线程上调用。 这是底层提供程序的限制。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅 [.NET Framework 中的网络跟踪](/dotnet/framework/network-programming/network-tracing)。  
  
> [!NOTE]
>  将为异步方法缓存 (安全上下文、模拟用户和调用上下文) 的执行上下文 <xref:System.Net.Sockets.Socket> 。 第一次使用特定的上下文 (特定的异步 <xref:System.Net.Sockets.Socket> 方法、特定的 <xref:System.Net.Sockets.Socket> 实例和特定的回调) 后，该上下文的后续使用将会提高性能。  
  
   
  
## Examples  
 下面的代码示例启动异步连接尝试。  
  
 [!code-cpp[Socket_Async_Send_Receive#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#1)]
 [!code-csharp[Socket_Async_Send_Receive#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#1)]
 [!code-vb[Socket_Async_Send_Receive#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="remoteEP" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <exception cref="T:System.Security.SecurityException">调用堆栈中的较高调用方无权执行所请求的操作。</exception>
        <exception cref="T:System.InvalidOperationException">已通过调用 <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> 将 <see cref="T:System.Net.Sockets.Socket" /> 置于侦听状态，或异步操作已在进行中。</exception>
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
        <related type="Article" href="/dotnet/framework/interop/marshaling-a-delegate-as-a-callback-method">将委托作为回调方法进行封送</related>
        <related type="Article" href="/dotnet/framework/network-programming/asynchronous-client-socket-example">异步客户端套接字示例</related>
        <related type="Article" href="/dotnet/framework/network-programming/asynchronous-server-socket-example">异步服务器套接字示例</related>
      </Docs>
    </Member>
    <Member MemberName="BeginConnect">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (System.Net.IPAddress address, int port, AsyncCallback? requestCallback, object? state);" FrameworkAlternate="net-5.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(class System.Net.IPAddress address, int32 port, class System.AsyncCallback requestCallback, object state) cil managed" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress,System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (address As IPAddress, port As Integer, requestCallback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(System::Net::IPAddress ^ address, int port, AsyncCallback ^ requestCallback, System::Object ^ state);" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.BeginConnect : System.Net.IPAddress * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginConnect (address, port, requestCallback, state)" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (System.Net.IPAddress address, int port, AsyncCallback requestCallback, object state);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (System.Net.IPAddress address, int port, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(class System.Net.IPAddress address, int32 port, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (address As IPAddress, port As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(System::Net::IPAddress ^ address, int port, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.BeginConnect : System.Net.IPAddress * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginConnect (address, port, callback, state)" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Net.IPAddress" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="port" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="requestCallback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="address">远程主机的 <see cref="T:System.Net.IPAddress" />。</param>
        <param name="port">远程主机的端口号。</param>
        <param name="requestCallback">一个 <see cref="T:System.AsyncCallback" /> 委托，它引用连接操作完成时要调用的方法。</param>
        <param name="callback">一个 <see cref="T:System.AsyncCallback" /> 委托，它引用连接操作完成时要调用的方法。</param>
        <param name="state">一个用户定义对象，其中包含连接操作的相关信息。 当操作完成时，此对象会被传递给 <paramref name="requestCallback" /> 委托。</param>
        <summary>开始一个对远程主机连接的异步请求。 主机由 <see cref="T:System.Net.IPAddress" /> 和端口号指定。</summary>
        <returns>引用异步连接的 <see cref="T:System.IAsyncResult" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.BeginConnect%2A>必须通过调用方法完成异步操作 <xref:System.Net.Sockets.Socket.EndConnect%2A> 。 通常，方法由 `requestCallback` 委托调用。  
  
 在操作完成之前，此方法不会被阻止。 若要在操作完成之前一直阻止，请使用 <xref:System.Net.Sockets.Socket.Connect%2A> 方法重载之一，或 <xref:System.Net.Sockets.Socket.EndConnect%2A> 。  
  
 若要取消挂起的方法调用 <xref:System.Net.Sockets.Socket.BeginConnect%2A> ，请关闭 <xref:System.Net.Sockets.Socket> 。 如果在 <xref:System.Net.Sockets.Socket.Close%2A> 异步操作过程中调用方法，则会调用向方法提供的回调 <xref:System.Net.Sockets.Socket.BeginConnect%2A> 。  对方法的后续调用 <xref:System.Net.Sockets.Socket.EndConnect%2A> 将引发 <xref:System.ObjectDisposedException> ，以指示该操作已取消。  
  
 有关使用异步编程模型的详细信息，请参阅 [以异步方式调用同步方法](/dotnet/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously)  
  
> [!NOTE]
>  如果收到 <xref:System.Net.Sockets.SocketException> ，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。 获取此代码后，请参阅 [Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2) 文档，以获取有关错误的详细说明。  
  
> [!NOTE]
>  如果此套接字以前已断开连接，则 <xref:System.Net.Sockets.Socket.BeginConnect%2A> 必须在操作完成之前，将不会退出的线程上调用。 这是底层提供程序的限制。 使用的也 <xref:System.Net.EndPoint> 必须不同。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅 [.NET Framework 中的网络跟踪](/dotnet/framework/network-programming/network-tracing)。  
  
> [!NOTE]
>  将为异步方法缓存 (安全上下文、模拟用户和调用上下文) 的执行上下文 <xref:System.Net.Sockets.Socket> 。 第一次使用特定的上下文 (特定的异步 <xref:System.Net.Sockets.Socket> 方法、特定的 <xref:System.Net.Sockets.Socket> 实例和特定的回调) 后，该上下文的后续使用将会提高性能。  
  
   
  
## Examples  
 下面的代码示例启动异步连接尝试。  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#1)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#1)]  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#7](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#7)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#7](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="address" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <exception cref="T:System.NotSupportedException"><see cref="T:System.Net.Sockets.Socket" /> 不在套接字族中。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">端口号无效。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="address" /> 的长度为零。</exception>
        <exception cref="T:System.InvalidOperationException">已通过调用 <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> 将 <see cref="T:System.Net.Sockets.Socket" /> 置于侦听状态，或异步操作已在进行中。</exception>
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
        <related type="Article" href="/dotnet/framework/interop/marshaling-a-delegate-as-a-callback-method">将委托作为回调方法进行封送</related>
        <related type="Article" href="/dotnet/framework/network-programming/asynchronous-client-socket-example">异步客户端套接字示例</related>
        <related type="Article" href="/dotnet/framework/network-programming/asynchronous-server-socket-example">异步服务器套接字示例</related>
      </Docs>
    </Member>
    <Member MemberName="BeginConnect">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (System.Net.IPAddress[] addresses, int port, AsyncCallback? requestCallback, object? state);" FrameworkAlternate="net-5.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(class System.Net.IPAddress[] addresses, int32 port, class System.AsyncCallback requestCallback, object state) cil managed" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress[],System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (addresses As IPAddress(), port As Integer, requestCallback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(cli::array &lt;System::Net::IPAddress ^&gt; ^ addresses, int port, AsyncCallback ^ requestCallback, System::Object ^ state);" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.BeginConnect : System.Net.IPAddress[] * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginConnect (addresses, port, requestCallback, state)" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (System.Net.IPAddress[] addresses, int port, AsyncCallback requestCallback, object state);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (System.Net.IPAddress[] addresses, int port, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(class System.Net.IPAddress[] addresses, int32 port, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (addresses As IPAddress(), port As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(cli::array &lt;System::Net::IPAddress ^&gt; ^ addresses, int port, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.BeginConnect : System.Net.IPAddress[] * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginConnect (addresses, port, callback, state)" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="addresses" Type="System.Net.IPAddress[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="port" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="requestCallback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="addresses">至少一个用于指定远程主机的 <see cref="T:System.Net.IPAddress" />。</param>
        <param name="port">远程主机的端口号。</param>
        <param name="requestCallback">一个 <see cref="T:System.AsyncCallback" /> 委托，它引用连接操作完成时要调用的方法。</param>
        <param name="callback">一个 <see cref="T:System.AsyncCallback" /> 委托，它引用连接操作完成时要调用的方法。</param>
        <param name="state">一个用户定义对象，其中包含连接操作的相关信息。 当操作完成时，此对象会被传递给 <paramref name="requestCallback" /> 委托。</param>
        <summary>开始一个对远程主机连接的异步请求。 主机由 <see cref="T:System.Net.IPAddress" /> 数组和端口号指定。</summary>
        <returns>引用异步连接的 <see cref="T:System.IAsyncResult" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.BeginConnect%2A>必须通过调用方法完成异步操作 <xref:System.Net.Sockets.Socket.EndConnect%2A> 。 通常，方法由 `requestCallback` 委托调用。  
  
 在操作完成之前，此方法不会被阻止。 若要在操作完成之前一直阻止，请使用 <xref:System.Net.Sockets.Socket.Connect%2A> 方法重载之一。  
  
 若要取消挂起的方法调用 <xref:System.Net.Sockets.Socket.BeginConnect%2A> ，请关闭 <xref:System.Net.Sockets.Socket> 。 如果在 <xref:System.Net.Sockets.Socket.Close%2A> 异步操作过程中调用方法，则会调用向方法提供的回调 <xref:System.Net.Sockets.Socket.BeginConnect%2A> 。  对方法的后续调用 <xref:System.Net.Sockets.Socket.EndConnect%2A> 将引发 <xref:System.ObjectDisposedException> ，以指示该操作已取消。  
  
 有关使用异步编程模型的详细信息，请参阅 [以异步方式调用同步方法](/dotnet/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously)。  
  
> [!NOTE]
>  如果收到 <xref:System.Net.Sockets.SocketException> ，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。 获取此代码后，请参阅 [Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2) 文档，以获取有关错误的详细说明。  
  
> [!NOTE]
>  如果此套接字以前已断开连接，则 <xref:System.Net.Sockets.Socket.BeginConnect%2A> 必须在操作完成之前，将不会退出的线程上调用。 这是底层提供程序的限制。 使用的也 <xref:System.Net.EndPoint> 必须不同。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅 [.NET Framework 中的网络跟踪](/dotnet/framework/network-programming/network-tracing)。  
  
> [!NOTE]
>  将为异步方法缓存 (安全上下文、模拟用户和调用上下文) 的执行上下文 <xref:System.Net.Sockets.Socket> 。 第一次使用特定的上下文 (特定的异步 <xref:System.Net.Sockets.Socket> 方法、特定的 <xref:System.Net.Sockets.Socket> 实例和特定的回调) 后，该上下文的后续使用将会提高性能。  
  
   
  
## Examples  
 下面的代码示例启动异步连接尝试。  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#1)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#1)]  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#2](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#2)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#2](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="addresses" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <exception cref="T:System.NotSupportedException">此方法对使用 <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> 或 <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> 的套接字有效。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">端口号无效。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="address" /> 的长度为零。</exception>
        <exception cref="T:System.InvalidOperationException">已通过调用 <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> 将 <see cref="T:System.Net.Sockets.Socket" /> 置于侦听状态，或异步操作已在进行中。</exception>
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
        <related type="Article" href="/dotnet/framework/interop/marshaling-a-delegate-as-a-callback-method">将委托作为回调方法进行封送</related>
        <related type="Article" href="/dotnet/framework/network-programming/asynchronous-client-socket-example">异步客户端套接字示例</related>
        <related type="Article" href="/dotnet/framework/network-programming/asynchronous-server-socket-example">异步服务器套接字示例</related>
      </Docs>
    </Member>
    <Member MemberName="BeginConnect">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (string host, int port, AsyncCallback? requestCallback, object? state);" FrameworkAlternate="net-5.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(string host, int32 port, class System.AsyncCallback requestCallback, object state) cil managed" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginConnect(System.String,System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (host As String, port As Integer, requestCallback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(System::String ^ host, int port, AsyncCallback ^ requestCallback, System::Object ^ state);" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.BeginConnect : string * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginConnect (host, port, requestCallback, state)" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (string host, int port, AsyncCallback requestCallback, object state);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (string host, int port, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(string host, int32 port, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (host As String, port As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(System::String ^ host, int port, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.BeginConnect : string * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginConnect (host, port, callback, state)" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="host" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="port" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="requestCallback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="host">远程主机的名称。</param>
        <param name="port">远程主机的端口号。</param>
        <param name="requestCallback">一个 <see cref="T:System.AsyncCallback" /> 委托，它引用连接操作完成时要调用的方法。</param>
        <param name="callback">一个 <see cref="T:System.AsyncCallback" /> 委托，它引用连接操作完成时要调用的方法。</param>
        <param name="state">一个用户定义对象，其中包含连接操作的相关信息。 当操作完成时，此对象会被传递给 <paramref name="requestCallback" /> 委托。</param>
        <summary>开始一个对远程主机连接的异步请求。 主机由主机名和端口号指定。</summary>
        <returns>引用异步连接的 <see cref="T:System.IAsyncResult" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.BeginConnect%2A>必须通过调用方法完成异步操作 <xref:System.Net.Sockets.Socket.EndConnect%2A> 。 通常，方法由 `requestCallback` 委托调用。  
  
 在操作完成之前，此方法不会被阻止。 若要在操作完成之前一直阻止，请使用 <xref:System.Net.Sockets.Socket.Connect%2A> 方法重载之一。  
  
 若要取消挂起的方法调用  <xref:System.Net.Sockets.Socket.BeginConnect%2A> ，请关闭 <xref:System.Net.Sockets.Socket> 。 如果在 <xref:System.Net.Sockets.Socket.Close%2A> 异步操作过程中调用方法，则会调用向方法提供的回调 <xref:System.Net.Sockets.Socket.BeginConnect%2A> 。  对方法的后续调用 <xref:System.Net.Sockets.Socket.EndConnect%2A> 将引发 <xref:System.ObjectDisposedException> ，以指示该操作已取消。  
  
 有关使用异步编程模型的详细信息，请参阅 [以异步方式调用同步方法](/dotnet/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously)  
  
> [!NOTE]
>  如果收到 <xref:System.Net.Sockets.SocketException> ，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。 获取此代码后，请参阅 [Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2) 文档，以获取有关错误的详细说明。  
  
> [!NOTE]
>  如果此套接字以前已断开连接，则 <xref:System.Net.Sockets.Socket.BeginConnect%2A> 必须在操作完成之前，将不会退出的线程上调用。 这是底层提供程序的限制。 使用的也 <xref:System.Net.EndPoint> 必须不同。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅 [.NET Framework 中的网络跟踪](/dotnet/framework/network-programming/network-tracing)。  
  
> [!NOTE]
>  将为异步方法缓存 (安全上下文、模拟用户和调用上下文) 的执行上下文 <xref:System.Net.Sockets.Socket> 。 第一次使用特定的上下文 (特定的异步 <xref:System.Net.Sockets.Socket> 方法、特定的 <xref:System.Net.Sockets.Socket> 实例和特定的回调) 后，该上下文的后续使用将会提高性能。  
  
   
  
## Examples  
 下面的代码示例启动异步连接尝试。  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#1)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#1)]  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#3](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#3)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#3](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="host" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <exception cref="T:System.NotSupportedException">此方法对 <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> 或 <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> 系列中的套接字有效。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">端口号无效。</exception>
        <exception cref="T:System.InvalidOperationException">已通过调用 <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> 将 <see cref="T:System.Net.Sockets.Socket" /> 置于侦听状态，或异步操作已在进行中。</exception>
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
        <related type="Article" href="/dotnet/framework/interop/marshaling-a-delegate-as-a-callback-method">将委托作为回调方法进行封送</related>
        <related type="Article" href="/dotnet/framework/network-programming/asynchronous-client-socket-example">异步客户端套接字示例</related>
        <related type="Article" href="/dotnet/framework/network-programming/asynchronous-server-socket-example">异步服务器套接字示例</related>
      </Docs>
    </Member>
    <Member MemberName="BeginDisconnect">
      <MemberSignature Language="C#" Value="public IAsyncResult? BeginDisconnect (bool reuseSocket, AsyncCallback callback, object state);" FrameworkAlternate="net-5.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginDisconnect(bool reuseSocket, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginDisconnect(System.Boolean,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginDisconnect (reuseSocket As Boolean, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginDisconnect(bool reuseSocket, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginDisconnect : bool * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginDisconnect (reuseSocket, callback, state)" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginDisconnect (bool reuseSocket, AsyncCallback callback, object state);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reuseSocket" Type="System.Boolean" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="state" Type="System.Object" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="reuseSocket">如果关闭该连接后可以重用此套接字，则为 <see langword="true" />；否则为 <see langword="false" />。</param>
        <param name="callback"><see cref="T:System.AsyncCallback" /> 委托。</param>
        <param name="state">一个对象，它包含此请求的状态信息。</param>
        <summary>开始异步请求从远程终结点断开连接。</summary>
        <returns>一个 <see cref="T:System.IAsyncResult" /> 对象，它引用异步操作。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果使用面向连接的协议，则可以调用 <xref:System.Net.Sockets.Socket.BeginDisconnect%2A> 方法从远程终结点请求断开连接。 如果 `reuseSocket` 为 `true` ，则可以重复使用套接字。  
  
 <xref:System.Net.Sockets.Socket.BeginDisconnect%2A>方法使用单独的线程来调用指定的回调方法。 <xref:System.Net.Sockets.Socket.EndDisconnect%2A>方法会一直阻止，直到挂起的断开连接完成。 有关编写回调方法的其他信息，请参阅将 [委托作为回调方法进行封送处理](/dotnet/framework/interop/marshaling-a-delegate-as-a-callback-method)。  
  
> [!NOTE]
>  如果收到 <xref:System.Net.Sockets.SocketException> 异常，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。 获取此代码后，请参阅 [Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2) 文档，以获取有关错误的详细说明。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅 [.NET Framework 中的网络跟踪](/dotnet/framework/network-programming/network-tracing)。  
  
   
  
## Examples  
 下面的代码示例为异步通信创建套接字，并将一些数据发送到远程主机。 发送数据时， <xref:System.Net.Sockets.Socket.Shutdown%2A> 将调用以停止发送和接收活动。 然后 <xref:System.Net.Sockets.Socket.BeginDisconnect%2A> 调用以开始断开连接请求。 请求完成后，将 <xref:System.Net.Sockets.Socket.Connected%2A> 查询属性以测试套接字是否已断开连接。  
  
 [!code-cpp[Nclsocketenhancements#11](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#11)]
 [!code-csharp[Nclsocketenhancements#11](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 对象已关闭。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginReceive">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>开始从连接的 <see cref="T:System.Net.Sockets.Socket" /> 中异步接收数据。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult? BeginReceive (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt;? buffers, System.Net.Sockets.SocketFlags socketFlags, AsyncCallback callback, object state);" FrameworkAlternate="net-5.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginReceive (buffers As IList(Of ArraySegment(Of Byte)), socketFlags As SocketFlags, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginReceive : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.Net.Sockets.SocketFlags * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginReceive (buffers, socketFlags, callback, state)" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags, AsyncCallback callback, object state);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="state" Type="System.Object" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="buffers"><see cref="T:System.Byte" /> 类型的数组，它是存储接收到的数据的位置。</param>
        <param name="socketFlags"><see cref="T:System.Net.Sockets.SocketFlags" /> 值的按位组合。</param>
        <param name="callback">一个 <see cref="T:System.AsyncCallback" /> 委托，它引用操作完成时要调用的方法。</param>
        <param name="state">一个用户定义的对象，其中包含接收操作的相关信息。 当操作完成时，此对象会被传递给 <see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /> 委托。</param>
        <summary>开始从连接的 <see cref="T:System.Net.Sockets.Socket" /> 中异步接收数据。</summary>
        <returns>引用异步读的 <see cref="T:System.IAsyncResult" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.BeginReceive%2A>必须通过调用方法完成异步操作 <xref:System.Net.Sockets.Socket.EndReceive%2A> 。 通常，方法由 `callback` 委托调用。  
  
 在操作完成之前，此方法不会被阻止。 若要在操作完成之前一直阻止，请使用 <xref:System.Net.Sockets.Socket.Receive%2A> 方法重载之一。  
  
 若要取消挂起的 <xref:System.Net.Sockets.Socket.BeginReceive%2A> ，请调用 <xref:System.Net.Sockets.Socket.Close%2A> 方法。  
  
 有关使用异步编程模型的详细信息，请参阅 [以异步方式调用同步方法](/dotnet/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously)。  
  
> [!NOTE]
>  如果收到 <xref:System.Net.Sockets.SocketException> ，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。 获取此代码后，请参阅 [Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2) 文档，以获取有关错误的详细说明。  
  
> [!NOTE]
>  给定线程启动的所有 i/o 都将在该线程退出时取消。 如果线程在操作完成之前退出，则挂起的异步操作可能会失败。  
  
> [!NOTE]
>  `state` 是用户定义的类的实例化。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅 [.NET Framework 中的网络跟踪](/dotnet/framework/network-programming/network-tracing)。  
  
> [!NOTE]
>  将为异步方法缓存 (安全上下文、模拟用户和调用上下文) 的执行上下文 <xref:System.Net.Sockets.Socket> 。 第一次使用特定的上下文 (特定的异步 <xref:System.Net.Sockets.Socket> 方法、特定的 <xref:System.Net.Sockets.Socket> 实例和特定的回调) 后，该上下文的后续使用将会提高性能。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
        <related type="Article" href="/dotnet/framework/interop/marshaling-a-delegate-as-a-callback-method">将委托作为回调方法进行封送</related>
        <related type="Article" href="/dotnet/framework/network-programming/asynchronous-client-socket-example">异步客户端套接字示例</related>
        <related type="Article" href="/dotnet/framework/network-programming/asynchronous-server-socket-example">异步服务器套接字示例</related>
      </Docs>
    </Member>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt;? buffers, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode, AsyncCallback callback, object state);" FrameworkAlternate="net-5.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginReceive (buffers As IList(Of ArraySegment(Of Byte)), socketFlags As SocketFlags, ByRef errorCode As SocketError, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginReceive : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.Net.Sockets.SocketFlags * SocketError * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginReceive (buffers, socketFlags, errorCode, callback, state)" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode, AsyncCallback callback, object state);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="state" Type="System.Object" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="buffers"><see cref="T:System.Byte" /> 类型的数组，它是存储接收到的数据的位置。</param>
        <param name="socketFlags"><see cref="T:System.Net.Sockets.SocketFlags" /> 值的按位组合。</param>
        <param name="errorCode">一个 <see cref="T:System.Net.Sockets.SocketError" /> 对象，它存储套接字错误。</param>
        <param name="callback">一个 <see cref="T:System.AsyncCallback" /> 委托，它引用操作完成时要调用的方法。</param>
        <param name="state">一个用户定义的对象，其中包含接收操作的相关信息。 当操作完成时，此对象会被传递给 <see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /> 委托。</param>
        <summary>开始从连接的 <see cref="T:System.Net.Sockets.Socket" /> 中异步接收数据。</summary>
        <returns>引用异步读的 <see cref="T:System.IAsyncResult" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.BeginReceive%2A>必须通过调用方法完成异步操作 <xref:System.Net.Sockets.Socket.EndReceive%2A> 。 通常，方法由 `callback` 委托调用。  
  
 在操作完成之前，此方法不会被阻止。 若要在操作完成之前一直阻止，请使用 <xref:System.Net.Sockets.Socket.Receive%2A> 方法重载之一。  
  
 若要取消挂起的 <xref:System.Net.Sockets.Socket.BeginReceive%2A> ，请调用 <xref:System.Net.Sockets.Socket.Close%2A> 方法。  
  
 有关使用异步编程模型的详细信息，请参阅 [以异步方式调用同步方法](/dotnet/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously)。  
  
> [!NOTE]
>  如果收到 <xref:System.Net.Sockets.SocketException> ，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。 获取此代码后，请参阅 [Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2) 文档，以获取有关错误的详细说明。  
  
> [!NOTE]
>  给定线程启动的所有 i/o 都将在该线程退出时取消。 如果线程在操作完成之前退出，则挂起的异步操作可能会失败。  
  
> [!NOTE]
>  `state` 是用户定义的类的实例化。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅 [.NET Framework 中的网络跟踪](/dotnet/framework/network-programming/network-tracing)。  
  
> [!NOTE]
>  将为异步方法缓存 (安全上下文、模拟用户和调用上下文) 的执行上下文 <xref:System.Net.Sockets.Socket> 。 第一次使用特定的上下文 (特定的异步 <xref:System.Net.Sockets.Socket> 方法、特定的 <xref:System.Net.Sockets.Socket> 实例和特定的回调) 后，该上下文的后续使用将会提高性能。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
        <related type="Article" href="/dotnet/framework/interop/marshaling-a-delegate-as-a-callback-method">将委托作为回调方法进行封送</related>
        <related type="Article" href="/dotnet/framework/network-programming/asynchronous-client-socket-example">异步客户端套接字示例</related>
        <related type="Article" href="/dotnet/framework/network-programming/asynchronous-server-socket-example">异步服务器套接字示例</related>
      </Docs>
    </Member>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, AsyncCallback? callback, object? state);" FrameworkAlternate="net-5.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginReceive (buffer As Byte(), offset As Integer, size As Integer, socketFlags As SocketFlags, callback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.BeginReceive : byte[] * int * int * System.Net.Sockets.SocketFlags * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginReceive (buffer, offset, size, socketFlags, callback, state)" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, AsyncCallback callback, object state);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socket_flags, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socket_flags, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginReceive (buffer As Byte(), offset As Integer, size As Integer, socket_flags As SocketFlags, callback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socket_flags, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.BeginReceive : byte[] * int * int * System.Net.Sockets.SocketFlags * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginReceive (buffer, offset, size, socket_flags, callback, state)" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="socket_flags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="state" Type="System.Object" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="buffer"><see cref="T:System.Byte" /> 类型的数组，它是存储接收到的数据的位置。</param>
        <param name="offset"><paramref name="buffer" /> 参数中存储所接收数据的位置，该位置从零开始计数。</param>
        <param name="size">要接收的字节数。</param>
        <param name="socketFlags"><see cref="T:System.Net.Sockets.SocketFlags" /> 值的按位组合。</param>
        <param name="socket_flags"><see cref="T:System.Net.Sockets.SocketFlags" /> 值的按位组合。</param>
        <param name="callback">一个 <see cref="T:System.AsyncCallback" /> 委托，它引用操作完成时要调用的方法。</param>
        <param name="state">一个用户定义的对象，其中包含接收操作的相关信息。 当操作完成时，此对象会被传递给 <see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /> 委托。</param>
        <summary>开始从连接的 <see cref="T:System.Net.Sockets.Socket" /> 中异步接收数据。</summary>
        <returns>引用异步读的 <see cref="T:System.IAsyncResult" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.BeginReceive%2A>必须通过调用方法完成异步操作 <xref:System.Net.Sockets.Socket.EndReceive%2A> 。 通常，方法由 `callback` 委托调用。  
  
 在操作完成之前，此方法不会被阻止。 若要在操作完成之前一直阻止，请使用 <xref:System.Net.Sockets.Socket.Receive%2A> 方法重载之一。  
  
 若要取消挂起的 <xref:System.Net.Sockets.Socket.BeginReceive%2A> ，请调用 <xref:System.Net.Sockets.Socket.Close%2A> 方法。  
  
 有关使用异步编程模型的详细信息，请参阅 [以异步方式调用同步方法](/dotnet/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously)。  
  
> [!NOTE]
>  如果收到 <xref:System.Net.Sockets.SocketException> ，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。 获取此代码后，请参阅 [Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2) 文档，以获取有关错误的详细说明。  
  
> [!NOTE]
>  给定线程启动的所有 i/o 都将在该线程退出时取消。 如果线程在操作完成之前退出，则挂起的异步操作可能会失败。  
  
> [!NOTE]
>  `state` 是用户定义的类的实例化。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅 [.NET Framework 中的网络跟踪](/dotnet/framework/network-programming/network-tracing)。  
  
> [!NOTE]
>  将为异步方法缓存 (安全上下文、模拟用户和调用上下文) 的执行上下文 <xref:System.Net.Sockets.Socket> 。 第一次使用特定的上下文 (特定的异步 <xref:System.Net.Sockets.Socket> 方法、特定的 <xref:System.Net.Sockets.Socket> 实例和特定的回调) 后，该上下文的后续使用将会提高性能。  
  
   
  
## Examples  
 下面的代码示例开始从连接的异步接收数据 <xref:System.Net.Sockets.Socket> 。  
  
 [!code-cpp[Socket_Async_Send_Receive#11](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#11)]
 [!code-csharp[Socket_Async_Send_Receive#11](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#11)]
 [!code-vb[Socket_Async_Send_Receive#11](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#11)]  
  
 [!code-cpp[Socket_Async_Send_Receive#7](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#7)]
 [!code-csharp[Socket_Async_Send_Receive#7](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#7)]
 [!code-vb[Socket_Async_Send_Receive#7](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#7)]  
  
 [!code-cpp[Socket_Async_Send_Receive#8](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#8)]
 [!code-csharp[Socket_Async_Send_Receive#8](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#8)]
 [!code-vb[Socket_Async_Send_Receive#8](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" /> 小于 0。  
  
- 或 - 
 <paramref name="offset" /> 大于 <paramref name="buffer" /> 的长度。  
  
- 或 - 
 <paramref name="size" /> 小于 0。  
  
- 或 - 
 <paramref name="size" /> 大于 <paramref name="buffer" /> 的长度减去 <paramref name="offset" /> 参数的值。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
        <related type="Article" href="/dotnet/framework/interop/marshaling-a-delegate-as-a-callback-method">将委托作为回调方法进行封送</related>
        <related type="Article" href="/dotnet/framework/network-programming/asynchronous-client-socket-example">异步客户端套接字示例</related>
        <related type="Article" href="/dotnet/framework/network-programming/asynchronous-server-socket-example">异步服务器套接字示例</related>
      </Docs>
    </Member>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (byte[]? buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode, AsyncCallback callback, object state);" FrameworkAlternate="net-5.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginReceive (buffer As Byte(), offset As Integer, size As Integer, socketFlags As SocketFlags, ByRef errorCode As SocketError, callback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.BeginReceive : byte[] * int * int * System.Net.Sockets.SocketFlags * SocketError * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginReceive (buffer, offset, size, socketFlags, errorCode, callback, state)" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode, AsyncCallback callback, object state);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags flags, out System.Net.Sockets.SocketError error, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags flags, [out] valuetype System.Net.Sockets.SocketError&amp; error, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginReceive (buffer As Byte(), offset As Integer, size As Integer, flags As SocketFlags, ByRef error As SocketError, callback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags flags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % error, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.BeginReceive : byte[] * int * int * System.Net.Sockets.SocketFlags * SocketError * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginReceive (buffer, offset, size, flags, error, callback, state)" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="flags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" Index="4" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="error" Type="System.Net.Sockets.SocketError" RefType="out" Index="4" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="state" Type="System.Object" Index="6" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="buffer"><see cref="T:System.Byte" /> 类型的数组，它是存储接收到的数据的位置。</param>
        <param name="offset"><paramref name="buffer" /> 中存储所接收数据的位置。</param>
        <param name="size">要接收的字节数。</param>
        <param name="socketFlags"><see cref="T:System.Net.Sockets.SocketFlags" /> 值的按位组合。</param>
        <param name="flags"><see cref="T:System.Net.Sockets.SocketFlags" /> 值的按位组合。</param>
        <param name="errorCode">一个 <see cref="T:System.Net.Sockets.SocketError" /> 对象，它存储套接字错误。</param>
        <param name="error">一个 <see cref="T:System.Net.Sockets.SocketError" /> 对象，它存储套接字错误。</param>
        <param name="callback">一个 <see cref="T:System.AsyncCallback" /> 委托，它引用操作完成时要调用的方法。</param>
        <param name="state">一个用户定义的对象，其中包含接收操作的相关信息。 当操作完成时，此对象会被传递给 <see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /> 委托。</param>
        <summary>开始从连接的 <see cref="T:System.Net.Sockets.Socket" /> 中异步接收数据。</summary>
        <returns>引用异步读的 <see cref="T:System.IAsyncResult" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.BeginReceive%2A>必须通过调用方法完成异步操作 <xref:System.Net.Sockets.Socket.EndReceive%2A> 。 通常，方法由 `callback` 委托调用。  
  
 在操作完成之前，此方法不会被阻止。 若要在操作完成之前一直阻止，请使用 <xref:System.Net.Sockets.Socket.Receive%2A> 方法重载之一。  
  
 若要取消挂起的 <xref:System.Net.Sockets.Socket.BeginReceive%2A> ，请调用 <xref:System.Net.Sockets.Socket.Close%2A> 方法。  
  
 有关使用异步编程模型的详细信息，请参阅 [以异步方式调用同步方法](/dotnet/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously)。  
  
> [!NOTE]
>  如果收到 <xref:System.Net.Sockets.SocketException> ，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。 获取此代码后，请参阅 [Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2) 文档，以获取有关错误的详细说明。  
  
> [!NOTE]
>  给定线程启动的所有 i/o 都将在该线程退出时取消。 如果线程在操作完成之前退出，则挂起的异步操作可能会失败。  
  
> [!NOTE]
>  `state` 是用户定义的类的实例化。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅 [.NET Framework 中的网络跟踪](/dotnet/framework/network-programming/network-tracing)。  
  
> [!NOTE]
>  将为异步方法缓存 (安全上下文、模拟用户和调用上下文) 的执行上下文 <xref:System.Net.Sockets.Socket> 。 第一次使用特定的上下文 (特定的异步 <xref:System.Net.Sockets.Socket> 方法、特定的 <xref:System.Net.Sockets.Socket> 实例和特定的回调) 后，该上下文的后续使用将会提高性能。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" /> 小于 0。  
  
- 或 - 
 <paramref name="offset" /> 大于 <paramref name="buffer" /> 的长度。  
  
- 或 - 
 <paramref name="size" /> 小于 0。  
  
- 或 - 
 <paramref name="size" /> 大于 <paramref name="buffer" /> 的长度减去 <paramref name="offset" /> 参数的值。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
        <related type="Article" href="/dotnet/framework/interop/marshaling-a-delegate-as-a-callback-method">将委托作为回调方法进行封送</related>
        <related type="Article" href="/dotnet/framework/network-programming/asynchronous-client-socket-example">异步客户端套接字示例</related>
        <related type="Article" href="/dotnet/framework/network-programming/asynchronous-server-socket-example">异步服务器套接字示例</related>
      </Docs>
    </Member>
    <Member MemberName="BeginReceiveFrom">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceiveFrom (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint remoteEP, AsyncCallback? callback, object? state);" FrameworkAlternate="net-5.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceiveFrom(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint&amp; remoteEP, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginReceiveFrom (buffer As Byte(), offset As Integer, size As Integer, socketFlags As SocketFlags, ByRef remoteEP As EndPoint, callback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceiveFrom(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ % remoteEP, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.BeginReceiveFrom : byte[] * int * int * System.Net.Sockets.SocketFlags * EndPoint * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginReceiveFrom (buffer, offset, size, socketFlags, remoteEP, callback, state)" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceiveFrom (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint remoteEP, AsyncCallback callback, object state);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceiveFrom (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socket_flags, ref System.Net.EndPoint remote_end, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceiveFrom(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socket_flags, class System.Net.EndPoint&amp; remote_end, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginReceiveFrom (buffer As Byte(), offset As Integer, size As Integer, socket_flags As SocketFlags, ByRef remote_end As EndPoint, callback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceiveFrom(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socket_flags, System::Net::EndPoint ^ % remote_end, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.BeginReceiveFrom : byte[] * int * int * System.Net.Sockets.SocketFlags * EndPoint * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginReceiveFrom (buffer, offset, size, socket_flags, remote_end, callback, state)" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="socket_flags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" RefType="ref" Index="4" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="remote_end" Type="System.Net.EndPoint" RefType="ref" Index="4" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="state" Type="System.Object" Index="6" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="buffer"><see cref="T:System.Byte" /> 类型的数组，它是存储接收到的数据的位置。</param>
        <param name="offset"><paramref name="buffer" /> 参数中存储数据的位置，该位置从零开始计数。</param>
        <param name="size">要接收的字节数。</param>
        <param name="socketFlags"><see cref="T:System.Net.Sockets.SocketFlags" /> 值的按位组合。</param>
        <param name="socket_flags"><see cref="T:System.Net.Sockets.SocketFlags" /> 值的按位组合。</param>
        <param name="remoteEP">一个 <see cref="T:System.Net.EndPoint" />，它表示数据的来源。</param>
        <param name="remote_end">一个 <see cref="T:System.Net.EndPoint" />，它表示数据的来源。</param>
        <param name="callback"><see cref="T:System.AsyncCallback" /> 委托。</param>
        <param name="state">包含此请求的状态信息的对象。</param>
        <summary>开始从指定网络设备中异步接收数据。</summary>
        <returns>引用异步读的 <see cref="T:System.IAsyncResult" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>方法从远程主机异步读取无连接的数据报。 调用 <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> 方法使你能够在单独的执行线程中接收数据。  
  
 你可以创建一个实现委托的回调方法 <xref:System.AsyncCallback> ，并将其名称传递给 <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> 方法。 为此，你的 `state` 参数至少必须包含用于通信的已连接或默认值 <xref:System.Net.Sockets.Socket> 。 如果回调需要更多的信息，可以创建一个小类来保存 <xref:System.Net.Sockets.Socket> 和其他所需的信息。 通过参数将此类的一个实例传递给 <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> 方法 `state` 。  
  
 回调方法应调用 <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> 方法。 当应用程序调用时 <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> ，系统将使用一个单独的线程来执行指定的回调方法，并且它将在 <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> <xref:System.Net.Sockets.Socket> 读取数据或引发异常之前阻塞。 如果希望在调用方法后原始线程会被阻止 <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> ，请使用 <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType> 。 如果希望原始线程继续执行，请在回调方法中的 T:System.Threading.ManualResetEvent 上调用 Set 方法。 有关编写回调方法的其他信息，请参阅将 [委托作为回调方法进行封送处理](/dotnet/framework/interop/marshaling-a-delegate-as-a-callback-method)。  
  
> [!NOTE]
>  在调用之前 <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> ，必须使用方法将显式绑定 <xref:System.Net.Sockets.Socket> 到本地终结点 <xref:System.Net.Sockets.Socket.Bind%2A> ，否则 <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> 将引发 <xref:System.Net.Sockets.SocketException> 。  
  
 此方法将数据读入 `buffer` 参数，并捕获从其发送数据的远程主机终结点。 有关如何检索此终结点的信息，请参阅 <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> 。 如果打算从未知主机或多台主机异步接收无连接的数据报，此方法非常有用。 在这些情况下， <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> 将读取接收到本地网络缓冲区中的第一个排队数据报。 如果接收的数据报大于大小 `buffer` ，则该 <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> 方法将尽可能多地填充 `buffer` 消息，并引发 <xref:System.Net.Sockets.SocketException> 。 如果使用的是不可靠的协议，则过量的数据将丢失。 如果你使用的是可靠协议，则该服务提供程序将保留多余的数据，并且你可以通过 <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> 使用足够大的缓冲区调用方法来检索这些数据。  
  
 为了保证始终返回远程主机终结点，应用程序应使用方法将显式绑定 <xref:System.Net.Sockets.Socket> 到本地终结点， <xref:System.Net.Sockets.Socket.Bind%2A> 然后调用方法，并将 <xref:System.Net.Sockets.Socket.SetSocketOption%2A> `optionLevel` 参数设置为或适当地将参数设置为 <xref:System.Net.Sockets.SocketOptionLevel.IP> <xref:System.Net.Sockets.SocketOptionLevel.IPv6> `optionName` ，并将参数设置为，并将参数设置为 <xref:System.Net.Sockets.SocketOptionName.PacketInformation> ，以在 `optionValue` 调用方法之前启用此选项 <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> 。 否则，如果发送方在接收方调用方法之前发送了大量的数据报，则不会返回远程主机终结点 <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> 。  
  
 尽管适用 <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> 于无连接协议，但你也可以使用面向连接的协议。 如果选择这样做，则必须先通过调用方法建立远程主机连接， <xref:System.Net.Sockets.Socket.Connect%2A>  /  <xref:System.Net.Sockets.Socket.BeginConnect%2A> 或通过调用或方法接受传入的连接请求 <xref:System.Net.Sockets.Socket.Accept%2A> <xref:System.Net.Sockets.Socket.BeginAccept%2A> 。 如果在 <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> 建立或接受连接之前调用方法，将会收到 <xref:System.Net.Sockets.SocketException> 。 还可以在调用方法之前，为无连接协议建立默认远程主机 <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> 。 在这两种情况下， <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> 方法将忽略 `remoteEP` 参数，并仅从已连接或默认的远程主机接收数据。  
  
 使用面向连接的套接字时， <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> 将读取与参数指定的字节数最多的可用数据 `size` 。  
  
 若要取消挂起的 <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> ，请调用 <xref:System.Net.Sockets.Socket.Close%2A> 方法。  
  
> [!NOTE]
>  如果收到 <xref:System.Net.Sockets.SocketException> ，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。 获取此代码后，请参阅 [Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2) 文档，以获取有关错误的详细说明。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅 [.NET Framework 中的网络跟踪](/dotnet/framework/network-programming/network-tracing)。  
  
> [!NOTE]
>  将为异步方法缓存 (安全上下文、模拟用户和调用上下文) 的执行上下文 <xref:System.Net.Sockets.Socket> 。 第一次使用特定的上下文 (特定的异步 <xref:System.Net.Sockets.Socket> 方法、特定的 <xref:System.Net.Sockets.Socket> 实例和特定的回调) 后，该上下文的后续使用将会提高性能。  
  
   
  
## Examples  
 下面的代码示例从远程主机异步接收无连接的数据报。  
  
 [!code-cpp[Socket_Async_Send_Receive#41](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#41)]
 [!code-csharp[Socket_Async_Send_Receive#41](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#41)]
 [!code-vb[Socket_Async_Send_Receive#41](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#41)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> 为 <see langword="null" />。  
  
- 或 - 
 <paramref name="remoteEP" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" /> 小于 0。  
  
- 或 - 
 <paramref name="offset" /> 大于 <paramref name="buffer" /> 的长度。  
  
- 或 - 
 <paramref name="size" /> 小于 0。  
  
- 或 - 
 <paramref name="size" /> 大于 <paramref name="buffer" /> 的长度减去 <paramref name="offset" /> 参数的值。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <exception cref="T:System.Security.SecurityException">调用堆栈中的较高调用方无权执行所请求的操作。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Accept" />
        <related type="Article" href="/dotnet/framework/interop/marshaling-a-delegate-as-a-callback-method">将委托作为回调方法进行封送</related>
      </Docs>
    </Member>
    <Member MemberName="BeginReceiveMessageFrom">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceiveMessageFrom (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint remoteEP, AsyncCallback? callback, object? state);" FrameworkAlternate="net-5.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceiveMessageFrom(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint&amp; remoteEP, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginReceiveMessageFrom (buffer As Byte(), offset As Integer, size As Integer, socketFlags As SocketFlags, ByRef remoteEP As EndPoint, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceiveMessageFrom(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ % remoteEP, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginReceiveMessageFrom : byte[] * int * int * System.Net.Sockets.SocketFlags * EndPoint * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginReceiveMessageFrom (buffer, offset, size, socketFlags, remoteEP, callback, state)" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceiveMessageFrom (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint remoteEP, AsyncCallback callback, object state);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.MonoTODO]</AttributeName>
          <AttributeName Language="F#">[&lt;System.MonoTODO&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" RefType="ref" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="state" Type="System.Object" Index="6" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="buffer"><see cref="T:System.Byte" /> 类型的数组，它是存储接收到的数据的位置。</param>
        <param name="offset"><paramref name="buffer" /> 参数中存储数据的位置，该位置从零开始计数。</param>
        <param name="size">要接收的字节数。</param>
        <param name="socketFlags"><see cref="T:System.Net.Sockets.SocketFlags" /> 值的按位组合。</param>
        <param name="remoteEP">一个 <see cref="T:System.Net.EndPoint" />，它表示数据的来源。</param>
        <param name="callback"><see cref="T:System.AsyncCallback" /> 委托。</param>
        <param name="state">包含此请求的状态信息的对象。</param>
        <summary>开始使用指定的 <see cref="T:System.Net.Sockets.SocketFlags" /> 将指定字节数的数据异步接收到数据缓冲区的指定位置，然后存储终结点和数据包信息。</summary>
        <returns>引用异步读的 <see cref="T:System.IAsyncResult" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 必须通过调用方法完成异步接收操作 <xref:System.Net.Sockets.Socket.EndReceiveMessageFrom%2A> 。 通常，方法由 `asyncCallback` 委托调用。  
  
 在操作完成之前，此方法不会被阻止。 若要在操作完成之前一直阻止，请使用 <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> 方法。  
  
 若要取消挂起的 <xref:System.Net.Sockets.Socket.BeginReceiveMessageFrom%2A> ，请调用 <xref:System.Net.Sockets.Socket.Close%2A> 方法。  
  
 有关使用异步编程模型的详细信息，请参阅 [以异步方式调用同步方法](/dotnet/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously)  
  
 此方法将数据读入 `buffer` 参数，并捕获从其发送数据的远程主机终结点以及有关已接收数据包的信息。 有关如何检索此终结点的信息，请参阅 <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> 。 如果打算从未知主机或多台主机异步接收无连接的数据报，此方法非常有用。  
  
> [!NOTE]
>  如果收到 <xref:System.Net.Sockets.SocketException> ，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。 获取此代码后，请参阅 [Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2) 文档，以获取有关错误的详细说明。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅 [.NET Framework 中的网络跟踪](/dotnet/framework/network-programming/network-tracing)。  
  
> [!NOTE]
>  将为异步方法缓存 (安全上下文、模拟用户和调用上下文) 的执行上下文 <xref:System.Net.Sockets.Socket> 。 第一次使用特定的上下文 (特定的异步 <xref:System.Net.Sockets.Socket> 方法、特定的 <xref:System.Net.Sockets.Socket> 实例和特定的回调) 后，该上下文的后续使用将会提高性能。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> 为 <see langword="null" />。  
  
- 或 - 
 <paramref name="remoteEP" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" /> 小于 0。  
  
- 或 - 
 <paramref name="offset" /> 大于 <paramref name="buffer" /> 的长度。  
  
- 或 - 
 <paramref name="size" /> 小于 0。  
  
- 或 - 
 <paramref name="size" /> 大于 <paramref name="buffer" /> 的长度减去 <paramref name="offset" /> 参数的值。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginSend">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>将数据异步发送到连接的 <see cref="T:System.Net.Sockets.Socket" />。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginSend">
      <MemberSignature Language="C#" Value="public IAsyncResult? BeginSend (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt;? buffers, System.Net.Sockets.SocketFlags socketFlags, AsyncCallback callback, object state);" FrameworkAlternate="net-5.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSend(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginSend (buffers As IList(Of ArraySegment(Of Byte)), socketFlags As SocketFlags, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSend(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginSend : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.Net.Sockets.SocketFlags * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginSend (buffers, socketFlags, callback, state)" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSend (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags, AsyncCallback callback, object state);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="state" Type="System.Object" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="buffers"><see cref="T:System.Byte" /> 类型的数组，它包含要发送的数据。</param>
        <param name="socketFlags"><see cref="T:System.Net.Sockets.SocketFlags" /> 值的按位组合。</param>
        <param name="callback"><see cref="T:System.AsyncCallback" /> 委托。</param>
        <param name="state">包含此请求的状态信息的对象。</param>
        <summary>将数据异步发送到连接的 <see cref="T:System.Net.Sockets.Socket" />。</summary>
        <returns>引用异步发送的 <see cref="T:System.IAsyncResult" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.BeginSend%2A>方法对 <xref:System.Net.Sockets.Socket.Connect%2A> 、、 <xref:System.Net.Sockets.Socket.BeginConnect%2A> <xref:System.Net.Sockets.Socket.Accept%2A> 或 <xref:System.Net.Sockets.Socket.BeginAccept%2A> 方法中建立的远程主机启动异步发送操作。 <xref:System.Net.Sockets.Socket.BeginSend%2A> 如果你不首先调用、、或，将引发异常 <xref:System.Net.Sockets.Socket.Accept%2A> <xref:System.Net.Sockets.Socket.BeginAccept%2A> <xref:System.Net.Sockets.Socket.Connect%2A> <xref:System.Net.Sockets.Socket.BeginConnect%2A> 。 通过调用 <xref:System.Net.Sockets.Socket.BeginSend%2A> 方法，可以在单独的执行线程中发送数据。  
  
 你可以创建一个实现委托的回调方法 <xref:System.AsyncCallback> ，并将其名称传递给 <xref:System.Net.Sockets.Socket.BeginSend%2A> 方法。 为此，你的 `state` 参数至少必须包含用于通信的已连接或默认值 <xref:System.Net.Sockets.Socket> 。 如果回调需要更多的信息，可以创建一个小型类或结构来保存 <xref:System.Net.Sockets.Socket> 和其他所需的信息。 通过参数将此类的一个实例传递给 <xref:System.Net.Sockets.Socket.BeginSend%2A> 方法 `state` 。  
  
 回调方法应调用 <xref:System.Net.Sockets.Socket.EndSend%2A> 方法。 当应用程序调用时 <xref:System.Net.Sockets.Socket.BeginSend%2A> ，系统将使用一个单独的线程来执行指定的回调方法，并在 <xref:System.Net.Sockets.Socket.EndSend%2A> <xref:System.Net.Sockets.Socket> 发送请求的字节数或引发异常之前阻止。 如果希望在调用方法后原始线程会被阻止 <xref:System.Net.Sockets.Socket.BeginSend%2A> ，请使用 <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType> 方法。 如果希望原始线程继续执行，请在回调方法中的 T:System.Threading.ManualResetEvent 上调用 Set 方法。 有关编写回调方法的其他信息，请参阅将 [委托作为回调方法进行封送处理](/dotnet/framework/interop/marshaling-a-delegate-as-a-callback-method)。  
  
 尽管适用于面向连接的协议，但 <xref:System.Net.Sockets.Socket.BeginSend%2A> 也适用于无连接协议，前提是你首先调用 <xref:System.Net.Sockets.Socket.Connect%2A> 或 <xref:System.Net.Sockets.Socket.BeginConnect%2A> 方法来建立默认远程主机。 如果你使用的是无连接协议并且打算将数据发送到多个不同的主机，则应使用 <xref:System.Net.Sockets.Socket.BeginSendTo%2A> 。 <xref:System.Net.Sockets.Socket.BeginSendTo%2A>即使已使用建立默认远程主机，也可以使用 <xref:System.Net.Sockets.Socket.Connect%2A> 。 还可以在调用之前更改默认远程主机， <xref:System.Net.Sockets.Socket.BeginSend%2A> 方法是调用 <xref:System.Net.Sockets.Socket.Connect%2A> 或 <xref:System.Net.Sockets.Socket.BeginConnect%2A> 。 对于无连接协议，还必须确保缓冲区的大小不超过基础服务提供程序的最大数据包大小。 如果是这样，则不会发送数据报并 <xref:System.Net.Sockets.Socket.BeginSend%2A> 将引发 <xref:System.Net.Sockets.SocketException> 。  
  
 如果指定 <xref:System.Net.Sockets.SocketFlags.DontRoute> 标志作为 `socketflags` 参数，则不会路由要发送的数据。  
  
> [!NOTE]
>  如果收到 <xref:System.Net.Sockets.SocketException> ，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。 获取此代码后，请参阅 [Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2) 文档，以获取有关错误的详细说明。  
  
> [!NOTE]
>  给定线程启动的所有 i/o 都将在该线程退出时取消。 如果线程在操作完成之前退出，则挂起的异步操作可能会失败。  
  
> [!NOTE]
>  `state` 是用户定义的类的实例化。  
  
> [!NOTE]
>  成功完成发送并不表示数据已成功传递。 如果传输系统中没有可用于保存要传输的数据的缓冲区空间，则发送将会阻止，除非已将套接字置于非阻止模式。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅 [.NET Framework 中的网络跟踪](/dotnet/framework/network-programming/network-tracing)。  
  
> [!NOTE]
>  将为异步方法缓存 (安全上下文、模拟用户和调用上下文) 的执行上下文 <xref:System.Net.Sockets.Socket> 。 第一次使用特定的上下文 (特定的异步 <xref:System.Net.Sockets.Socket> 方法、特定的 <xref:System.Net.Sockets.Socket> 实例和特定的回调) 后，该上下文的后续使用将会提高性能。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffers" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="buffers" /> 为空。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。 请参见下面的备注部分。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" />
        <related type="Article" href="/dotnet/framework/interop/marshaling-a-delegate-as-a-callback-method">将委托作为回调方法进行封送</related>
        <related type="Article" href="/dotnet/framework/network-programming/asynchronous-client-socket-example">异步客户端套接字示例</related>
        <related type="Article" href="/dotnet/framework/network-programming/asynchronous-server-socket-example">异步服务器套接字示例</related>
      </Docs>
    </Member>
    <Member MemberName="BeginSend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSend (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt;? buffers, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode, AsyncCallback callback, object state);" FrameworkAlternate="net-5.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSend(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginSend (buffers As IList(Of ArraySegment(Of Byte)), socketFlags As SocketFlags, ByRef errorCode As SocketError, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSend(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginSend : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.Net.Sockets.SocketFlags * SocketError * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginSend (buffers, socketFlags, errorCode, callback, state)" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSend (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode, AsyncCallback callback, object state);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="state" Type="System.Object" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="buffers"><see cref="T:System.Byte" /> 类型的数组，它包含要发送的数据。</param>
        <param name="socketFlags"><see cref="T:System.Net.Sockets.SocketFlags" /> 值的按位组合。</param>
        <param name="errorCode">一个 <see cref="T:System.Net.Sockets.SocketError" /> 对象，它存储套接字错误。</param>
        <param name="callback"><see cref="T:System.AsyncCallback" /> 委托。</param>
        <param name="state">包含此请求的状态信息的对象。</param>
        <summary>将数据异步发送到连接的 <see cref="T:System.Net.Sockets.Socket" />。</summary>
        <returns>引用异步发送的 <see cref="T:System.IAsyncResult" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.BeginSend%2A>方法对 <xref:System.Net.Sockets.Socket.Connect%2A> 、、 <xref:System.Net.Sockets.Socket.BeginConnect%2A> <xref:System.Net.Sockets.Socket.Accept%2A> 或 <xref:System.Net.Sockets.Socket.BeginAccept%2A> 方法中建立的远程主机启动异步发送操作。 <xref:System.Net.Sockets.Socket.BeginSend%2A> 如果你不首先调用、、或，将引发异常 <xref:System.Net.Sockets.Socket.Accept%2A> <xref:System.Net.Sockets.Socket.BeginAccept%2A> <xref:System.Net.Sockets.Socket.Connect%2A> <xref:System.Net.Sockets.Socket.BeginConnect%2A> 。 通过调用 <xref:System.Net.Sockets.Socket.BeginSend%2A> 方法，可以在单独的执行线程中发送数据。  
  
 你可以创建一个实现委托的回调方法 <xref:System.AsyncCallback> ，并将其名称传递给 <xref:System.Net.Sockets.Socket.BeginSend%2A> 方法。 为此，你的 `state` 参数至少必须包含用于通信的已连接或默认值 <xref:System.Net.Sockets.Socket> 。 如果回调需要更多的信息，可以创建一个小型类或结构来保存 <xref:System.Net.Sockets.Socket> 和其他所需的信息。 通过参数将此类的一个实例传递给 <xref:System.Net.Sockets.Socket.BeginSend%2A> 方法 `state` 。  
  
 回调方法应调用 <xref:System.Net.Sockets.Socket.EndSend%2A> 方法。 当应用程序调用时 <xref:System.Net.Sockets.Socket.BeginSend%2A> ，系统将使用一个单独的线程来执行指定的回调方法，并在 <xref:System.Net.Sockets.Socket.EndSend%2A> <xref:System.Net.Sockets.Socket> 发送请求的字节数或引发异常之前阻止。 如果希望在调用方法后原始线程会被阻止 <xref:System.Net.Sockets.Socket.BeginSend%2A> ，请使用 <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType> 方法。 <xref:System.Threading.ManualResetEvent>当你希望原始线程继续执行时，请在回调方法中调用的 Set 方法。 有关编写回调方法的其他信息，请参阅将 [委托作为回调方法进行封送处理](/dotnet/framework/interop/marshaling-a-delegate-as-a-callback-method)。  
  
 尽管适用于面向连接的协议，但 <xref:System.Net.Sockets.Socket.BeginSend%2A> 也适用于无连接协议，前提是你首先调用 <xref:System.Net.Sockets.Socket.Connect%2A> 或 <xref:System.Net.Sockets.Socket.BeginConnect%2A> 方法来建立默认远程主机。 如果你使用的是无连接协议并且打算将数据发送到多个不同的主机，则应使用 <xref:System.Net.Sockets.Socket.BeginSendTo%2A> 。 <xref:System.Net.Sockets.Socket.BeginSendTo%2A>即使已使用建立默认远程主机，也可以使用 <xref:System.Net.Sockets.Socket.Connect%2A> 。 还可以在调用之前更改默认远程主机， <xref:System.Net.Sockets.Socket.BeginSend%2A> 方法是调用 <xref:System.Net.Sockets.Socket.Connect%2A> 或 <xref:System.Net.Sockets.Socket.BeginConnect%2A> 。 对于无连接协议，还必须确保缓冲区的大小不超过基础服务提供程序的最大数据包大小。 如果是这样，则不会发送数据报并 <xref:System.Net.Sockets.Socket.BeginSend%2A> 将引发 <xref:System.Net.Sockets.SocketException> 。  
  
 如果指定 <xref:System.Net.Sockets.SocketFlags.DontRoute> 标志作为 `socketflags` 参数，则不会路由要发送的数据。  
  
> [!NOTE]
>  如果收到 <xref:System.Net.Sockets.SocketException> ，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。 获取此代码后，请参阅 [Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2) 文档，以获取有关错误的详细说明。  
  
> [!NOTE]
>  给定线程启动的所有 i/o 都将在该线程退出时取消。 如果线程在操作完成之前退出，则挂起的异步操作可能会失败。  
  
> [!NOTE]
>  `state` 是用户定义的类的实例化。  
  
> [!NOTE]
>  成功完成发送并不表示数据已成功传递。 如果传输系统中没有可用于保存要传输的数据的缓冲区空间，则发送将会阻止，除非已将套接字置于非阻止模式。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅 [.NET Framework 中的网络跟踪](/dotnet/framework/network-programming/network-tracing)。  
  
> [!NOTE]
>  将为异步方法缓存 (安全上下文、模拟用户和调用上下文) 的执行上下文 <xref:System.Net.Sockets.Socket> 。 第一次使用特定的上下文 (特定的异步 <xref:System.Net.Sockets.Socket> 方法、特定的 <xref:System.Net.Sockets.Socket> 实例和特定的回调) 后，该上下文的后续使用将会提高性能。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffers" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="buffers" /> 为空。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。 请参见下面的备注部分。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" />
        <related type="Article" href="/dotnet/framework/interop/marshaling-a-delegate-as-a-callback-method">将委托作为回调方法进行封送</related>
        <related type="Article" href="/dotnet/framework/network-programming/asynchronous-client-socket-example">异步客户端套接字示例</related>
        <related type="Article" href="/dotnet/framework/network-programming/asynchronous-server-socket-example">异步服务器套接字示例</related>
      </Docs>
    </Member>
    <Member MemberName="BeginSend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSend (byte[]? buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode, AsyncCallback callback, object state);" FrameworkAlternate="net-5.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSend(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginSend (buffer As Byte(), offset As Integer, size As Integer, socketFlags As SocketFlags, ByRef errorCode As SocketError, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSend(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginSend : byte[] * int * int * System.Net.Sockets.SocketFlags * SocketError * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginSend (buffer, offset, size, socketFlags, errorCode, callback, state)" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSend (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode, AsyncCallback callback, object state);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="state" Type="System.Object" Index="6" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="buffer"><see cref="T:System.Byte" /> 类型的数组，它包含要发送的数据。</param>
        <param name="offset"><paramref name="buffer" /> 参数中开始发送数据的位置，该位置从零开始计数。</param>
        <param name="size">要发送的字节数。</param>
        <param name="socketFlags"><see cref="T:System.Net.Sockets.SocketFlags" /> 值的按位组合。</param>
        <param name="errorCode">一个 <see cref="T:System.Net.Sockets.SocketError" /> 对象，它存储套接字错误。</param>
        <param name="callback"><see cref="T:System.AsyncCallback" /> 委托。</param>
        <param name="state">包含此请求的状态信息的对象。</param>
        <summary>将数据异步发送到连接的 <see cref="T:System.Net.Sockets.Socket" />。</summary>
        <returns>引用异步发送的 <see cref="T:System.IAsyncResult" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.BeginSend%2A>方法对 <xref:System.Net.Sockets.Socket.Connect%2A> 、、 <xref:System.Net.Sockets.Socket.BeginConnect%2A> <xref:System.Net.Sockets.Socket.Accept%2A> 或 <xref:System.Net.Sockets.Socket.BeginAccept%2A> 方法中建立的远程主机启动异步发送操作。 <xref:System.Net.Sockets.Socket.BeginSend%2A> 如果你不首先调用、、或，将引发异常 <xref:System.Net.Sockets.Socket.Accept%2A> <xref:System.Net.Sockets.Socket.BeginAccept%2A> <xref:System.Net.Sockets.Socket.Connect%2A> <xref:System.Net.Sockets.Socket.BeginConnect%2A> 。 通过调用 <xref:System.Net.Sockets.Socket.BeginSend%2A> 方法，可以在单独的执行线程中发送数据。  
  
 你可以创建一个实现委托的回调方法 <xref:System.AsyncCallback> ，并将其名称传递给 <xref:System.Net.Sockets.Socket.BeginSend%2A> 方法。 为此，你的 `state` 参数至少必须包含用于通信的已连接或默认值 <xref:System.Net.Sockets.Socket> 。 如果回调需要更多的信息，可以创建一个小型类或结构来保存 <xref:System.Net.Sockets.Socket> 和其他所需的信息。 通过参数将此类的一个实例传递给 <xref:System.Net.Sockets.Socket.BeginSend%2A> 方法 `state` 。  
  
 回调方法应调用 <xref:System.Net.Sockets.Socket.EndSend%2A> 方法。 当应用程序调用时 <xref:System.Net.Sockets.Socket.BeginSend%2A> ，系统将使用一个单独的线程来执行指定的回调方法，并在 <xref:System.Net.Sockets.Socket.EndSend%2A> <xref:System.Net.Sockets.Socket> 发送请求的字节数或引发异常之前阻止。 如果希望在调用方法后原始线程会被阻止 <xref:System.Net.Sockets.Socket.BeginSend%2A> ，请使用 <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType> 方法。 如果希望原始线程继续执行，请在回调方法中的 T:System.Threading.ManualResetEvent 上调用 Set 方法。 有关编写回调方法的其他信息，请参阅将 [委托作为回调方法进行封送处理](/dotnet/framework/interop/marshaling-a-delegate-as-a-callback-method)。  
  
 尽管适用于面向连接的协议，但 <xref:System.Net.Sockets.Socket.BeginSend%2A> 也适用于无连接协议，前提是你首先调用 <xref:System.Net.Sockets.Socket.Connect%2A> 或 <xref:System.Net.Sockets.Socket.BeginConnect%2A> 方法来建立默认远程主机。 如果你使用的是无连接协议并且打算将数据发送到多个不同的主机，则应使用 <xref:System.Net.Sockets.Socket.BeginSendTo%2A> 。 <xref:System.Net.Sockets.Socket.BeginSendTo%2A>即使已使用建立默认远程主机，也可以使用 <xref:System.Net.Sockets.Socket.Connect%2A> 。 还可以在调用之前更改默认远程主机， <xref:System.Net.Sockets.Socket.BeginSend%2A> 方法是调用 <xref:System.Net.Sockets.Socket.Connect%2A> 或 <xref:System.Net.Sockets.Socket.BeginConnect%2A> 。 对于无连接协议，还必须确保缓冲区的大小不超过基础服务提供程序的最大数据包大小。 如果是这样，则不会发送数据报并 <xref:System.Net.Sockets.Socket.BeginSend%2A> 将引发 <xref:System.Net.Sockets.SocketException> 。  
  
 如果指定 <xref:System.Net.Sockets.SocketFlags.DontRoute> 标志作为 `socketflags` 参数，则不会路由要发送的数据。  
  
> [!NOTE]
>  如果收到 <xref:System.Net.Sockets.SocketException> ，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。 获取此代码后，请参阅 [Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2) 文档，以获取有关错误的详细说明。  
  
> [!NOTE]
>  给定线程启动的所有 i/o 都将在该线程退出时取消。 如果线程在操作完成之前退出，则挂起的异步操作可能会失败。  
  
> [!NOTE]
>  `state` 是用户定义的类的实例化。  
  
> [!NOTE]
>  成功完成发送并不表示数据已成功传递。 如果传输系统中没有可用于保存要传输的数据的缓冲区空间，则发送将会阻止，除非已将套接字置于非阻止模式。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅 [.NET Framework 中的网络跟踪](/dotnet/framework/network-programming/network-tracing)。  
  
> [!NOTE]
>  将为异步方法缓存 (安全上下文、模拟用户和调用上下文) 的执行上下文 <xref:System.Net.Sockets.Socket> 。 第一次使用特定的上下文 (特定的异步 <xref:System.Net.Sockets.Socket> 方法、特定的 <xref:System.Net.Sockets.Socket> 实例和特定的回调) 后，该上下文的后续使用将会提高性能。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。 请参见下面的备注部分。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" /> 小于 0。  
  
- 或 - 
 <paramref name="offset" /> 小于 <paramref name="buffer" /> 的长度。  
  
- 或 - 
 <paramref name="size" /> 小于 0。  
  
- 或 - 
 <paramref name="size" /> 大于 <paramref name="buffer" /> 的长度减去 <paramref name="offset" /> 参数的值。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" />
        <related type="Article" href="/dotnet/framework/interop/marshaling-a-delegate-as-a-callback-method">将委托作为回调方法进行封送</related>
        <related type="Article" href="/dotnet/framework/network-programming/asynchronous-client-socket-example">异步客户端套接字示例</related>
        <related type="Article" href="/dotnet/framework/network-programming/asynchronous-server-socket-example">异步服务器套接字示例</related>
      </Docs>
    </Member>
    <Member MemberName="BeginSend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSend (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, AsyncCallback? callback, object? state);" FrameworkAlternate="net-5.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSend(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginSend (buffer As Byte(), offset As Integer, size As Integer, socketFlags As SocketFlags, callback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSend(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.BeginSend : byte[] * int * int * System.Net.Sockets.SocketFlags * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginSend (buffer, offset, size, socketFlags, callback, state)" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSend (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, AsyncCallback callback, object state);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSend (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socket_flags, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSend(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socket_flags, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginSend (buffer As Byte(), offset As Integer, size As Integer, socket_flags As SocketFlags, callback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSend(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socket_flags, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.BeginSend : byte[] * int * int * System.Net.Sockets.SocketFlags * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginSend (buffer, offset, size, socket_flags, callback, state)" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="socket_flags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="state" Type="System.Object" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="buffer"><see cref="T:System.Byte" /> 类型的数组，它包含要发送的数据。</param>
        <param name="offset"><paramref name="buffer" /> 参数中开始发送数据的位置，该位置从零开始计数。</param>
        <param name="size">要发送的字节数。</param>
        <param name="socketFlags"><see cref="T:System.Net.Sockets.SocketFlags" /> 值的按位组合。</param>
        <param name="socket_flags"><see cref="T:System.Net.Sockets.SocketFlags" /> 值的按位组合。</param>
        <param name="callback"><see cref="T:System.AsyncCallback" /> 委托。</param>
        <param name="state">包含此请求的状态信息的对象。</param>
        <summary>将数据异步发送到连接的 <see cref="T:System.Net.Sockets.Socket" />。</summary>
        <returns>引用异步发送的 <see cref="T:System.IAsyncResult" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.BeginSend%2A>方法对 <xref:System.Net.Sockets.Socket.Connect%2A> 、、 <xref:System.Net.Sockets.Socket.BeginConnect%2A> <xref:System.Net.Sockets.Socket.Accept%2A> 或 <xref:System.Net.Sockets.Socket.BeginAccept%2A> 方法中建立的远程主机启动异步发送操作。 <xref:System.Net.Sockets.Socket.BeginSend%2A> 如果你不首先调用、、或，将引发异常 <xref:System.Net.Sockets.Socket.Accept%2A> <xref:System.Net.Sockets.Socket.BeginAccept%2A> <xref:System.Net.Sockets.Socket.Connect%2A> <xref:System.Net.Sockets.Socket.BeginConnect%2A> 。 通过调用 <xref:System.Net.Sockets.Socket.BeginSend%2A> 方法，可以在单独的执行线程中发送数据。  
  
 你可以创建一个实现委托的回调方法 <xref:System.AsyncCallback> ，并将其名称传递给 <xref:System.Net.Sockets.Socket.BeginSend%2A> 方法。 为此，你的 `state` 参数至少必须包含用于通信的已连接或默认值 <xref:System.Net.Sockets.Socket> 。 如果回调需要更多的信息，可以创建一个小型类或结构来保存 <xref:System.Net.Sockets.Socket> 和其他所需的信息。 通过参数将此类的一个实例传递给 <xref:System.Net.Sockets.Socket.BeginSend%2A> 方法 `state` 。  
  
 回调方法应调用 <xref:System.Net.Sockets.Socket.EndSend%2A> 方法。 当应用程序调用时 <xref:System.Net.Sockets.Socket.BeginSend%2A> ，系统将使用一个单独的线程来执行指定的回调方法，并在 <xref:System.Net.Sockets.Socket.EndSend%2A> <xref:System.Net.Sockets.Socket> 发送请求的字节数或引发异常之前阻止。 如果希望在调用方法后原始线程会被阻止 <xref:System.Net.Sockets.Socket.BeginSend%2A> ，请使用 <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType> 方法。 如果希望原始线程继续执行，请在回调方法中的 T:System.Threading.ManualResetEvent 上调用 Set 方法。 有关编写回调方法的其他信息，请参阅将 [委托作为回调方法进行封送处理](/dotnet/framework/interop/marshaling-a-delegate-as-a-callback-method)。  
  
 尽管适用于面向连接的协议，但 <xref:System.Net.Sockets.Socket.BeginSend%2A> 也适用于无连接协议，前提是你首先调用 <xref:System.Net.Sockets.Socket.Connect%2A> 或 <xref:System.Net.Sockets.Socket.BeginConnect%2A> 方法来建立默认远程主机。 如果你使用的是无连接协议并且打算将数据发送到多个不同的主机，则应使用 <xref:System.Net.Sockets.Socket.BeginSendTo%2A> 。 <xref:System.Net.Sockets.Socket.BeginSendTo%2A>即使已使用建立默认远程主机，也可以使用 <xref:System.Net.Sockets.Socket.Connect%2A> 。 还可以在调用之前更改默认远程主机， <xref:System.Net.Sockets.Socket.BeginSend%2A> 方法是调用 <xref:System.Net.Sockets.Socket.Connect%2A> 或 <xref:System.Net.Sockets.Socket.BeginConnect%2A> 。 对于无连接协议，还必须确保缓冲区的大小不超过基础服务提供程序的最大数据包大小。 如果是这样，则不会发送数据报并 <xref:System.Net.Sockets.Socket.BeginSend%2A> 将引发 <xref:System.Net.Sockets.SocketException> 。  
  
 如果指定 <xref:System.Net.Sockets.SocketFlags.DontRoute> 标志作为 `socketflags` 参数，则不会路由要发送的数据。  
  
> [!NOTE]
>  如果收到 <xref:System.Net.Sockets.SocketException> ，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。 获取此代码后，请参阅 [Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2) 文档，以获取有关错误的详细说明。  
  
> [!NOTE]
>  给定线程启动的所有 i/o 都将在该线程退出时取消。 如果线程在操作完成之前退出，则挂起的异步操作可能会失败。  
  
> [!NOTE]
>  `state` 是用户定义的类的实例化。  
  
> [!NOTE]
>  成功完成发送并不表示数据已成功传递。 如果传输系统中没有可用于保存要传输的数据的缓冲区空间，则发送将会阻止，除非已将套接字置于非阻止模式。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅 [.NET Framework 中的网络跟踪](/dotnet/framework/network-programming/network-tracing)。  
  
> [!NOTE]
>  将为异步方法缓存 (安全上下文、模拟用户和调用上下文) 的执行上下文 <xref:System.Net.Sockets.Socket> 。 第一次使用特定的上下文 (特定的异步 <xref:System.Net.Sockets.Socket> 方法、特定的 <xref:System.Net.Sockets.Socket> 实例和特定的回调) 后，该上下文的后续使用将会提高性能。  
  
   
  
## Examples  
 下面的代码示例开始将数据异步发送到远程主机。  
  
 [!code-cpp[Socket_Async_Send_Receive#5](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#5)]
 [!code-csharp[Socket_Async_Send_Receive#5](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#5)]
 [!code-vb[Socket_Async_Send_Receive#5](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。 请参见下面的备注部分。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" /> 小于 0。  
  
- 或 - 
 <paramref name="offset" /> 小于 <paramref name="buffer" /> 的长度。  
  
- 或 - 
 <paramref name="size" /> 小于 0。  
  
- 或 - 
 <paramref name="size" /> 大于 <paramref name="buffer" /> 的长度减去 <paramref name="offset" /> 参数的值。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" />
        <related type="Article" href="/dotnet/framework/interop/marshaling-a-delegate-as-a-callback-method">将委托作为回调方法进行封送</related>
        <related type="Article" href="/dotnet/framework/network-programming/asynchronous-client-socket-example">异步客户端套接字示例</related>
        <related type="Article" href="/dotnet/framework/network-programming/asynchronous-server-socket-example">异步服务器套接字示例</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginSendFile">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>将文件异步发送到连接的 <see cref="T:System.Net.Sockets.Socket" /> 对象。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginSendFile">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSendFile (string fileName, AsyncCallback? callback, object? state);" FrameworkAlternate="net-5.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSendFile(string fileName, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginSendFile (fileName As String, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSendFile(System::String ^ fileName, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginSendFile : string * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginSendFile (fileName, callback, state)" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSendFile (string fileName, AsyncCallback callback, object state);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="state" Type="System.Object" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="fileName">一个字符串，它包含要发送的文件的路径和名称。 此参数可以为 <see langword="null" />。</param>
        <param name="callback"><see cref="T:System.AsyncCallback" /> 委托。</param>
        <param name="state">包含此请求的状态信息的对象。</param>
        <summary>使用 <see cref="T:System.Net.Sockets.Socket" /> 标志，将文件 <paramref name="fileName" /> 发送到连接的 <see cref="F:System.Net.Sockets.TransmitFileOptions.UseDefaultWorkerThread" /> 对象。</summary>
        <returns>一个 <see cref="T:System.IAsyncResult" /> 对象，它表示异步发送。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此重载将文件发送 `fileName` 到连接的套接字。 如果 `fileName` 位于本地目录中，则只能用文件的名称进行标识; 否则，必须指定文件的完整路径和名称。 通配符 ( "... \\支持\myfile.txt ") 和 UNC 共享名称 (" \\ \\ \\ \shared directory \\\myfile.txt ") 。 如果找不到该文件，则 <xref:System.IO.FileNotFoundException> 会引发异常。  
  
 此方法使用 `TransmitFile` 在 Windows socket 2 API 中找到的函数。 有关 `TransmitFile` 函数及其标志的详细信息，请参阅 [Windows 套接字](/windows/desktop/WinSock/) 文档。  
  
 <xref:System.Net.Sockets.Socket.BeginSendFile%2A>方法对 <xref:System.Net.Sockets.Socket.Connect%2A> 、、 <xref:System.Net.Sockets.Socket.BeginConnect%2A> <xref:System.Net.Sockets.Socket.Accept%2A> 或 <xref:System.Net.Sockets.Socket.BeginAccept%2A> 方法中建立的远程主机启动异步发送操作。 <xref:System.Net.Sockets.Socket.BeginSendFile%2A> 如果你不首先调用、、或，则会引发异常 <xref:System.Net.Sockets.Socket.Accept%2A> <xref:System.Net.Sockets.Socket.BeginAccept%2A> <xref:System.Net.Sockets.Socket.Connect%2A> <xref:System.Net.Sockets.Socket.BeginConnect%2A> 。 通过调用 <xref:System.Net.Sockets.Socket.BeginSendFile%2A> 方法，可以在单独的执行线程中发送文件。  
  
 若要完成此操作，可以创建一个由委托参数调用的回调方法 <xref:System.AsyncCallback> 。 为此，此 `state` 参数至少必须包含 <xref:System.Net.Sockets.Socket> 用于通信的对象。 如果回调需要更多信息，你可以创建一个类或结构来保存 <xref:System.Net.Sockets.Socket> 和其他所需的信息。 通过参数将此自定义对象的实例传递给 <xref:System.Net.Sockets.Socket.BeginSendFile%2A> 方法 `state` 。  
  
 回调方法必须调用 <xref:System.Net.Sockets.Socket.EndSendFile%2A> 方法。 当应用程序调用时 <xref:System.Net.Sockets.Socket.BeginSendFile%2A> ，系统将使用一个单独的线程来执行指定的回调方法，并在 <xref:System.Net.Sockets.Socket.EndSendFile%2A> <xref:System.Net.Sockets.Socket> 发送整个文件或引发异常前阻止。 有关编写回调方法的其他信息，请参阅将 [委托作为回调方法进行封送处理](/dotnet/framework/interop/marshaling-a-delegate-as-a-callback-method)。  
  
 尽管适用于面向连接的协议，但 <xref:System.Net.Sockets.Socket.BeginSendFile%2A> 也适用于无连接协议，前提是你首先调用 <xref:System.Net.Sockets.Socket.Connect%2A> 或 <xref:System.Net.Sockets.Socket.BeginConnect%2A> 方法来建立默认远程主机。 在无连接协议的情况下，必须确保文件大小不超过基础服务提供程序的最大数据包大小。 如果是这样，则不发送数据报并 <xref:System.Net.Sockets.Socket.BeginSendFile%2A> 引发 <xref:System.Net.Sockets.SocketException> 异常。  
  
> [!NOTE]
>  如果收到 <xref:System.Net.Sockets.SocketException> 异常，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。 获取此代码后，请参阅 [Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2) 文档，以获取有关错误的详细说明。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅 [.NET Framework 中的网络跟踪](/dotnet/framework/network-programming/network-tracing)。  
  
> [!NOTE]
>  将为异步方法缓存 (安全上下文、模拟用户和调用上下文) 的执行上下文 <xref:System.Net.Sockets.Socket> 。 第一次使用特定的上下文 (特定的异步 <xref:System.Net.Sockets.Socket> 方法、特定的 <xref:System.Net.Sockets.Socket> 实例和特定的回调) 后，该上下文的后续使用将会提高性能。  
  
   
  
## Examples  
 下面的代码示例创建并连接套接字以进行异步通信。 首先，将文件 "text.txt" 异步发送到远程主机。 回调委托调用 <xref:System.Net.Sockets.Socket.EndSendFile%2A> 来完成传输。  
  
 [!code-cpp[NCLSocketEnhancements#9](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#9)]
 [!code-csharp[NCLSocketEnhancements#9](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 对象已关闭。</exception>
        <exception cref="T:System.NotSupportedException">套接字未连接到远程主机。</exception>
        <exception cref="T:System.IO.FileNotFoundException">未找到文件 <paramref name="fileName" />。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。 请参见下面的备注部分。</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginSendFile">
      <MemberSignature Language="C#" Value="public IAsyncResult? BeginSendFile (string fileName, byte[] preBuffer, byte[] postBuffer, System.Net.Sockets.TransmitFileOptions flags, AsyncCallback callback, object state);" FrameworkAlternate="net-5.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSendFile(string fileName, unsigned int8[] preBuffer, unsigned int8[] postBuffer, valuetype System.Net.Sockets.TransmitFileOptions flags, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginSendFile (fileName As String, preBuffer As Byte(), postBuffer As Byte(), flags As TransmitFileOptions, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSendFile(System::String ^ fileName, cli::array &lt;System::Byte&gt; ^ preBuffer, cli::array &lt;System::Byte&gt; ^ postBuffer, System::Net::Sockets::TransmitFileOptions flags, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginSendFile : string * byte[] * byte[] * System.Net.Sockets.TransmitFileOptions * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginSendFile (fileName, preBuffer, postBuffer, flags, callback, state)" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSendFile (string fileName, byte[] preBuffer, byte[] postBuffer, System.Net.Sockets.TransmitFileOptions flags, AsyncCallback callback, object state);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="preBuffer" Type="System.Byte[]" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="postBuffer" Type="System.Byte[]" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="flags" Type="System.Net.Sockets.TransmitFileOptions" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="state" Type="System.Object" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="fileName">一个字符串，它包含要发送的文件的路径和名称。 此参数可以为 <see langword="null" />。</param>
        <param name="preBuffer">一个 <see cref="T:System.Byte" /> 数组，它包含发送文件前要发送的数据。 此参数可以为 <see langword="null" />。</param>
        <param name="postBuffer">一个 <see cref="T:System.Byte" /> 数组，它包含发送文件后要发送的数据。 此参数可以为 <see langword="null" />。</param>
        <param name="flags"><see cref="T:System.Net.Sockets.TransmitFileOptions" /> 值的按位组合。</param>
        <param name="callback">一个 <see cref="T:System.AsyncCallback" /> 委托，将在此操作完成时调用它。 此参数可以为 <see langword="null" />。</param>
        <param name="state">一个用户定义的对象，它包含此请求的状态信息。 此参数可以为 <see langword="null" />。</param>
        <summary>将文件和数据缓冲区异步发送到连接的 <see cref="T:System.Net.Sockets.Socket" /> 对象。</summary>
        <returns>一个 <see cref="T:System.IAsyncResult" /> 对象，它表示异步操作。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此重载要求要发送的文件的名称和值的按位组合 <xref:System.Net.Sockets.TransmitFileOptions> 。 `preBuffer`参数包含要在文件之前的任何数据。 `postBuffer` 包含要跟踪文件的数据。 如果 `fileName` 位于本地目录中，则只能用文件的名称进行标识; 否则，必须指定文件的完整路径和名称。 通配符 ( "... \\支持\myfile.txt ") 和 UNC 共享名称 (" \\ \\ \\ \shared directory \\\myfile.txt ") 。 如果找不到该文件，则 <xref:System.IO.FileNotFoundException> 会引发异常。  
  
 `flags`参数为窗口套接字服务提供程序提供有关文件传输的其他信息。 有关如何使用此参数的详细信息，请参阅 <xref:System.Net.Sockets.TransmitFileOptions> 。  
  
 此方法使用 `TransmitFile` 在 Windows socket 2 API 中找到的函数。 有关 `TransmitFile` 函数及其标志的详细信息，请参阅 [Windows 套接字](/windows/desktop/WinSock/) 文档。  
  
 <xref:System.Net.Sockets.Socket.BeginSendFile%2A>方法对 <xref:System.Net.Sockets.Socket.Connect%2A> 、、 <xref:System.Net.Sockets.Socket.BeginConnect%2A> <xref:System.Net.Sockets.Socket.Accept%2A> 或 <xref:System.Net.Sockets.Socket.BeginAccept%2A> 方法中建立的远程主机启动异步发送操作。 <xref:System.Net.Sockets.Socket.BeginSendFile%2A> 如果你不首先调用、、或，则会引发异常 <xref:System.Net.Sockets.Socket.Accept%2A> <xref:System.Net.Sockets.Socket.BeginAccept%2A> <xref:System.Net.Sockets.Socket.Connect%2A> <xref:System.Net.Sockets.Socket.BeginConnect%2A> 。 通过调用 <xref:System.Net.Sockets.Socket.BeginSendFile%2A> 方法，可以在单独的执行线程中发送文件。  
  
 若要完成此操作，可以创建一个由委托参数调用的回调方法 <xref:System.AsyncCallback> 。 为此，此 `state` 参数至少必须包含 <xref:System.Net.Sockets.Socket> 用于通信的对象。 如果回调需要更多信息，你可以创建一个类或结构来保存 <xref:System.Net.Sockets.Socket> 和其他所需的信息。 通过参数将此自定义对象的实例传递给 <xref:System.Net.Sockets.Socket.BeginSendFile%2A> 方法 `state` 。  
  
 回调方法必须调用 <xref:System.Net.Sockets.Socket.EndSendFile%2A> 方法。 当应用程序调用时 <xref:System.Net.Sockets.Socket.BeginSendFile%2A> ，系统将使用一个单独的线程来执行指定的回调方法，并在 <xref:System.Net.Sockets.Socket.EndSendFile%2A> <xref:System.Net.Sockets.Socket> 发送整个文件或引发异常前阻止。 有关编写回调方法的其他信息，请参阅将 [委托作为回调方法进行封送处理](/dotnet/framework/interop/marshaling-a-delegate-as-a-callback-method)。  
  
 尽管适用于面向连接的协议，但 <xref:System.Net.Sockets.Socket.BeginSendFile%2A> 也适用于无连接协议，前提是你首先调用 <xref:System.Net.Sockets.Socket.Connect%2A> 或 <xref:System.Net.Sockets.Socket.BeginConnect%2A> 方法来建立默认远程主机。 在无连接协议的情况下，你还必须确保文件大小不超过基础服务提供程序的最大数据包大小。 如果是这样，则不发送数据报并 <xref:System.Net.Sockets.Socket.BeginSendFile%2A> 引发 <xref:System.Net.Sockets.SocketException> 异常。  
  
> [!NOTE]
>  如果收到 <xref:System.Net.Sockets.SocketException> 异常，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。 获取此代码后，请参阅 [Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2) 文档，以获取有关错误的详细说明。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅 [.NET Framework 中的网络跟踪](/dotnet/framework/network-programming/network-tracing)。  
  
> [!NOTE]
>  将为异步方法缓存 (安全上下文、模拟用户和调用上下文) 的执行上下文 <xref:System.Net.Sockets.Socket> 。 第一次使用特定的上下文 (特定的异步 <xref:System.Net.Sockets.Socket> 方法、特定的 <xref:System.Net.Sockets.Socket> 实例和特定的回调) 后，该上下文的后续使用将会提高性能。  
  
   
  
## Examples  
 下面的代码示例创建并连接套接字用于异步通信，并开始将文件 "text.txt" 异步发送到远程主机。 在此示例中， `preBuffer` 创建了一个和一个与 `postBuffer` 文件一起发送的数据，并使用了默认 <xref:System.Net.Sockets.TransmitFileOptions> 值。 回调委托调用 <xref:System.Net.Sockets.Socket.EndSendFile%2A> 来完成传输。  
  
 [!code-cpp[NCLSocketEnhancements#10](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#10)]
 [!code-csharp[NCLSocketEnhancements#10](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 对象已关闭。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。 请参见下面的备注部分。</exception>
        <exception cref="T:System.NotSupportedException">操作系统不是 Windows NT 或更高版本。  
  
- 或 -
  
 套接字未连接到远程主机。</exception>
        <exception cref="T:System.IO.FileNotFoundException">未找到文件 <paramref name="fileName" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginSendTo">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSendTo (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, System.Net.EndPoint remoteEP, AsyncCallback? callback, object? state);" FrameworkAlternate="net-5.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSendTo(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint remoteEP, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginSendTo (buffer As Byte(), offset As Integer, size As Integer, socketFlags As SocketFlags, remoteEP As EndPoint, callback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSendTo(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ remoteEP, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.BeginSendTo : byte[] * int * int * System.Net.Sockets.SocketFlags * System.Net.EndPoint * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginSendTo (buffer, offset, size, socketFlags, remoteEP, callback, state)" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSendTo (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, System.Net.EndPoint remoteEP, AsyncCallback callback, object state);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSendTo (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socket_flags, System.Net.EndPoint remote_end, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSendTo(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socket_flags, class System.Net.EndPoint remote_end, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginSendTo (buffer As Byte(), offset As Integer, size As Integer, socket_flags As SocketFlags, remote_end As EndPoint, callback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSendTo(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socket_flags, System::Net::EndPoint ^ remote_end, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.BeginSendTo : byte[] * int * int * System.Net.Sockets.SocketFlags * System.Net.EndPoint * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginSendTo (buffer, offset, size, socket_flags, remote_end, callback, state)" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="socket_flags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" Index="4" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="remote_end" Type="System.Net.EndPoint" Index="4" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="state" Type="System.Object" Index="6" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="buffer"><see cref="T:System.Byte" /> 类型的数组，它包含要发送的数据。</param>
        <param name="offset"><paramref name="buffer" /> 中的从其开始发送数据的、从零开始编排的位置。</param>
        <param name="size">要发送的字节数。</param>
        <param name="socketFlags"><see cref="T:System.Net.Sockets.SocketFlags" /> 值的按位组合。</param>
        <param name="socket_flags"><see cref="T:System.Net.Sockets.SocketFlags" /> 值的按位组合。</param>
        <param name="remoteEP">表示远程设备的 <see cref="T:System.Net.EndPoint" />。</param>
        <param name="remote_end">表示远程设备的 <see cref="T:System.Net.EndPoint" />。</param>
        <param name="callback"><see cref="T:System.AsyncCallback" /> 委托。</param>
        <param name="state">包含此请求的状态信息的对象。</param>
        <summary>以异步方式将数据发送到特定远程主机。</summary>
        <returns>引用异步发送的 <see cref="T:System.IAsyncResult" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.BeginSendTo%2A>方法对参数中指定的远程主机启动异步发送操作 `remoteEP` 。 通过调用 <xref:System.Net.Sockets.Socket.BeginSendTo%2A> 方法，可以在单独的执行线程中发送数据。 尽管适用于无连接协议，但适用于连接 <xref:System.Net.Sockets.Socket.BeginSendTo%2A> 和面向连接的协议。  
  
 你可以创建一个实现委托的回调方法 <xref:System.AsyncCallback> ，并将其名称传递给 <xref:System.Net.Sockets.Socket.BeginSendTo%2A> 方法。 为此，你的 `state` 参数至少必须包含用于通信的已连接或默认值 <xref:System.Net.Sockets.Socket> 。 如果回调需要更多的信息，可以创建一个小类来保存 <xref:System.Net.Sockets.Socket> 和其他所需的信息。 通过参数将此类的一个实例传递给 <xref:System.Net.Sockets.Socket.BeginSendTo%2A> 方法 `state` 。  
  
 回调方法应调用 <xref:System.Net.Sockets.Socket.EndSendTo%2A> 方法。 当应用程序调用时 <xref:System.Net.Sockets.Socket.BeginSendTo%2A> ，系统将使用一个单独的线程来执行指定的回调方法，并在 <xref:System.Net.Sockets.Socket.EndSendTo%2A> <xref:System.Net.Sockets.Socket> 发送请求的字节数或引发异常之前阻止。 如果希望在调用方法后原始线程会被阻止 <xref:System.Net.Sockets.Socket.BeginSendTo%2A> ，请使用 <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType> 方法。 如果希望原始线程继续执行，请在回调方法中的 T:System.Threading.ManualResetEvent 上调用 Set 方法。 有关编写回调方法的其他信息，请参阅将 [委托作为回调方法进行封送处理](/dotnet/framework/interop/marshaling-a-delegate-as-a-callback-method)。  
  
 如果使用面向连接的协议，则必须先调用 <xref:System.Net.Sockets.Socket.Connect%2A> 、 <xref:System.Net.Sockets.Socket.BeginConnect%2A> 、 <xref:System.Net.Sockets.Socket.Accept%2A> 或 <xref:System.Net.Sockets.Socket.BeginAccept%2A> 方法，否则 <xref:System.Net.Sockets.Socket.BeginSendTo%2A> 将引发 <xref:System.Net.Sockets.SocketException> 。 <xref:System.Net.Sockets.Socket.BeginSendTo%2A> 将忽略 `remoteEP` 参数，并将数据发送到 <xref:System.Net.EndPoint> 、、 <xref:System.Net.Sockets.Socket.Connect%2A> <xref:System.Net.Sockets.Socket.BeginConnect%2A> <xref:System.Net.Sockets.Socket.Accept%2A> 或 <xref:System.Net.Sockets.Socket.BeginAccept%2A> 方法中建立的。  
  
 如果使用的是无连接协议，则在调用之前，无需使用或方法建立默认远程主机 <xref:System.Net.Sockets.Socket.Connect%2A> <xref:System.Net.Sockets.Socket.BeginConnect%2A> <xref:System.Net.Sockets.Socket.SendTo%2A> 。 如果要调用方法，只需执行此操作 <xref:System.Net.Sockets.Socket.BeginSend%2A> 。 如果在 <xref:System.Net.Sockets.Socket.Connect%2A> 调用之前调用了或 <xref:System.Net.Sockets.Socket.BeginConnect%2A> 方法 <xref:System.Net.Sockets.Socket.SendTo%2A> ，则该 `remoteEP` 参数将仅为该发送操作重写指定的默认远程主机。 您也不需要调用 <xref:System.Net.Sockets.Socket.Bind%2A> 方法。 在这种情况下，基础服务提供程序将分配最适当的本地网络地址和端口号。 如果希望基础服务提供商选择可用端口，请使用端口号零。 如果需要确定分配的本地网络地址和端口号，可以在 <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> <xref:System.Net.Sockets.Socket.EndSendTo%2A> 方法成功完成后使用属性。  
  
 如果要将数据发送到广播地址，则必须先调用 <xref:System.Net.Sockets.Socket.SetSocketOption%2A> 方法，并将套接字选项设置为 <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType> 。 -还必须确保缓冲区的大小不超过基础服务提供程序的最大数据包大小。 如果是这样，则不会发送数据报并 <xref:System.Net.Sockets.Socket.EndSendTo%2A> 将引发 <xref:System.Net.Sockets.SocketException> 。  
  
 如果指定 <xref:System.Net.Sockets.SocketFlags.DontRoute> 标志作为 `socketflags` 参数，则不会路由要发送的数据。  
  
> [!NOTE]
>  如果收到 <xref:System.Net.Sockets.SocketException> ，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。 获取此代码后，请参阅 [Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2) 文档，以获取有关错误的详细说明。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅 [.NET Framework 中的网络跟踪](/dotnet/framework/network-programming/network-tracing)。  
  
> [!NOTE]
>  将为异步方法缓存 (安全上下文、模拟用户和调用上下文) 的执行上下文 <xref:System.Net.Sockets.Socket> 。 第一次使用特定的上下文 (特定的异步 <xref:System.Net.Sockets.Socket> 方法、特定的 <xref:System.Net.Sockets.Socket> 实例和特定的回调) 后，该上下文的后续使用将会提高性能。  
  
   
  
## Examples  
 下面的代码示例将数据异步发送到指定的远程主机。  
  
 [!code-cpp[Socket_Async_Send_Receive#3](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#3)]
 [!code-csharp[Socket_Async_Send_Receive#3](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#3)]
 [!code-vb[Socket_Async_Send_Receive#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> 为 <see langword="null" />。  
  
- 或 - 
 <paramref name="remoteEP" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" /> 小于 0。  
  
- 或 - 
 <paramref name="offset" /> 大于 <paramref name="buffer" /> 的长度。  
  
- 或 - 
 <paramref name="size" /> 小于 0。  
  
- 或 - 
 <paramref name="size" /> 大于 <paramref name="buffer" /> 的长度减去 <paramref name="offset" /> 参数的值。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <exception cref="T:System.Security.SecurityException">调用堆栈中的较高调用方无权执行所请求的操作。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="P:System.Net.Sockets.Socket.LocalEndPoint" />
        <altmember cref="F:System.Net.Sockets.SocketOptionName.Broadcast" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <related type="Article" href="/dotnet/framework/interop/marshaling-a-delegate-as-a-callback-method">将委托作为回调方法进行封送</related>
      </Docs>
    </Member>
    <Member MemberName="Bind">
      <MemberSignature Language="C#" Value="public void Bind (System.Net.EndPoint localEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Bind(class System.Net.EndPoint localEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Bind (localEP As EndPoint)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Bind(System::Net::EndPoint ^ localEP);" />
      <MemberSignature Language="F#" Value="member this.Bind : System.Net.EndPoint -&gt; unit" Usage="socket.Bind localEP" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localEP" Type="System.Net.EndPoint" />
      </Parameters>
      <Docs>
        <param name="localEP">要与 <see cref="T:System.Net.EndPoint" /> 关联的本地 <see cref="T:System.Net.Sockets.Socket" />。</param>
        <summary>使 <see cref="T:System.Net.Sockets.Socket" /> 与一个本地终结点相关联。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Bind%2A>如果需要使用特定的本地终结点，请使用方法。 必须先调用， <xref:System.Net.Sockets.Socket.Bind%2A> 然后才能调用 <xref:System.Net.Sockets.Socket.Listen%2A> 方法。 <xref:System.Net.Sockets.Socket.Bind%2A> <xref:System.Net.Sockets.Socket.Connect%2A> 除非需要使用特定的本地终结点，否则在使用方法之前无需调用。 可 <xref:System.Net.Sockets.Socket.Bind%2A> 在无连接和面向连接的协议上使用方法。  
  
 在调用之前 <xref:System.Net.Sockets.Socket.Bind%2A> ，必须先创建要 <xref:System.Net.IPEndPoint> 用于与数据通信的本地。 如果你不关心分配了哪个本地地址，则可以 <xref:System.Net.IPEndPoint> 使用 <xref:System.Net.IPAddress.Any?displayProperty=nameWithType> 作为 address 参数创建，基础服务提供程序将分配最合适的网络地址。 如果你有多个网络接口，这可能有助于简化你的应用程序。 如果你不介意使用哪个本地端口，则可以 <xref:System.Net.IPEndPoint> 使用0作为端口号来创建。 在这种情况下，服务提供商将分配介于1024和5000之间的可用端口号。  
  
 如果使用以上方法，则可以通过调用来发现分配了哪些本地网络地址和端口号 <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> 。 如果使用面向连接的协议，则在 <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> 调用或方法之前，将不会返回本地分配的网络地址 <xref:System.Net.Sockets.Socket.Connect%2A> <xref:System.Net.Sockets.Socket.EndConnect%2A> 。 如果使用的是无连接协议，则在完成发送或接收之前，将无法访问此信息。  
  
 如果 UDP 套接字希望接收有关接收到的数据包的接口信息，则 <xref:System.Net.Sockets.Socket.SetSocketOption%2A> 应在 <xref:System.Net.Sockets.SocketOptionName.PacketInformation> 调用方法后，使用套接字选项显式调用此方法 <xref:System.Net.Sockets.Socket.Bind%2A> 。  
  
> [!NOTE]
>  如果打算接收多播数据报，则必须 <xref:System.Net.Sockets.Socket.Bind%2A> 使用多播端口号调用方法。  
  
> [!NOTE]
>  <xref:System.Net.Sockets.Socket.Bind%2A>如果打算使用方法接收无连接的数据报，则必须调用方法 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 。  
  
> [!NOTE]
>  如果在 <xref:System.Net.Sockets.SocketException> 调用方法时接收到 <xref:System.Net.Sockets.Socket.Bind%2A> ，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。 获取此代码后，请参阅 [Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2) 文档，以获取有关错误的详细说明。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅 [.NET Framework 中的网络跟踪](/dotnet/framework/network-programming/network-tracing)。  
  
   
  
## Examples  
 下面的代码示例 <xref:System.Net.Sockets.Socket> 使用指定的本地终结点绑定。  
  
 [!code-cpp[Classic Socket.Bind Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Bind Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Bind Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Bind Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Bind Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Bind Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="localEP" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <exception cref="T:System.Security.SecurityException">调用堆栈中的较高调用方无权执行所请求的操作。</exception>
        <altmember cref="T:System.Net.IPEndPoint" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />
        <altmember cref="T:System.Net.IPAddress" />
        <altmember cref="P:System.Net.Sockets.Socket.LocalEndPoint" />
      </Docs>
    </Member>
    <Member MemberName="Blocking">
      <MemberSignature Language="C#" Value="public bool Blocking { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Blocking" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.Blocking" />
      <MemberSignature Language="VB.NET" Value="Public Property Blocking As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Blocking { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Blocking : bool with get, set" Usage="System.Net.Sockets.Socket.Blocking" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指示 <see cref="T:System.Net.Sockets.Socket" /> 是否处于阻止模式。</summary>
        <value>如果 <see cref="T:System.Net.Sockets.Socket" /> 将阻止，则为 <see langword="true" />；否则为 <see langword="false" />。 默认值为 <see langword="true" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Blocking%2A>属性指示是否处于 <xref:System.Net.Sockets.Socket> 阻止模式。  
  
 如果你处于阻止模式，并且你进行了一个不会立即完成的方法调用，则应用程序将在请求的操作完成前阻止执行。 如果希望继续执行（即使请求的操作未完成），请将属性更改 <xref:System.Net.Sockets.Socket.Blocking%2A> 为 `false` 。 此 <xref:System.Net.Sockets.Socket.Blocking%2A> 属性对异步方法不起作用。 如果要以异步方式发送和接收数据，并想要阻止执行，请使用 <xref:System.Threading.ManualResetEvent> 类。  
  
> [!NOTE]
>  如果收到 <xref:System.Net.Sockets.SocketException> ，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。 获取此代码后，请参阅 [Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2) 文档，以获取有关错误的详细说明。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅 [.NET Framework 中的网络跟踪](/dotnet/framework/network-programming/network-tracing)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
      </Docs>
    </Member>
    <Member MemberName="CancelConnectAsync">
      <MemberSignature Language="C#" Value="public static void CancelConnectAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CancelConnectAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.CancelConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub CancelConnectAsync (e As SocketAsyncEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CancelConnectAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="static member CancelConnectAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; unit" Usage="System.Net.Sockets.Socket.CancelConnectAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> 对象，该对象用于通过调用 <see cref="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)" /> 方法之一，请求与远程主机的连接。</param>
        <summary>取消一个对远程主机连接的异步请求。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.CancelConnectAsync%2A>方法取消对远程主机连接的异步请求。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="e" /> 参数不能为 null，并且 <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> 不能为空。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <exception cref="T:System.Security.SecurityException">调用堆栈中的较高调用方无权执行所请求的操作。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Close">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>关闭 <see cref="T:System.Net.Sockets.Socket" /> 连接并释放所有关联的资源。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberSignature Language="F#" Value="member this.Close : unit -&gt; unit" Usage="socket.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>关闭 <see cref="T:System.Net.Sockets.Socket" /> 连接并释放所有关联的资源。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Close%2A>方法会关闭远程主机连接，并释放与关联的所有托管资源和非托管资源 <xref:System.Net.Sockets.Socket> 。 关闭时， <xref:System.Net.Sockets.Socket.Connected%2A> 属性将设置为 `false` 。  
  
 对于面向连接的协议，建议你在 <xref:System.Net.Sockets.Socket.Shutdown%2A> 调用方法之前调用 <xref:System.Net.Sockets.Socket.Close%2A> 。 这可确保所有数据在连接的套接字关闭之前都已发送和接收。  
  
 如果需要 <xref:System.Net.Sockets.Socket.Close%2A> 先调用而不调用 <xref:System.Net.Sockets.Socket.Shutdown%2A> ，则可以通过将选项设置 <xref:System.Net.Sockets.SocketOptionName.DontLinger> <xref:System.Net.Sockets.Socket> 为 `false` 并指定非零超时间隔来确保将排队等待传出传输的数据发送。 <xref:System.Net.Sockets.Socket.Close%2A> 然后将被阻止，直到发送此数据或指定的超时过期。 如果将设置 <xref:System.Net.Sockets.SocketOptionName.DontLinger> 为 `false` 并指定零超时间隔，则 <xref:System.Net.Sockets.Socket.Close%2A> 会释放连接并自动丢弃传出的排队数据。  
  
> [!NOTE]
>  若要将 <xref:System.Net.Sockets.SocketOptionName.DontLinger> 套接字选项设置为 `false` ，请创建 <xref:System.Net.Sockets.LingerOption> ，将 enabled 属性设置为 `true` ，并将 <xref:System.Net.Sockets.LingerOption.LingerTime%2A> 属性设置为所需的超时时间。 将此 <xref:System.Net.Sockets.LingerOption> 与 <xref:System.Net.Sockets.SocketOptionName.DontLinger> 套接字选项一起使用来调用 <xref:System.Net.Sockets.Socket.SetSocketOption%2A> 方法。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅 [.NET Framework 中的网络跟踪](/dotnet/framework/network-programming/network-tracing)。  
  
   
  
## Examples  
 下面的代码示例关闭 <xref:System.Net.Sockets.Socket> 。  
  
 [!code-cpp[Classic Socket.Close Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Close Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Close Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Close Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Close Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Close Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="F:System.Net.Sockets.SocketOptionName.DontLinger" />
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close (int timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close(int32 timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Close(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close (timeout As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close(int timeout);" />
      <MemberSignature Language="F#" Value="member this.Close : int -&gt; unit" Usage="socket.Close timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="timeout">等待最多 <paramref name="timeout" /> 秒钟后，即可发送任何剩余数据，然后关闭套接字。</param>
        <summary>关闭 <see cref="T:System.Net.Sockets.Socket" /> 连接并释放所有与指定超时关联的资源，以允许要发送的数据排队。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Close%2A>方法会关闭远程主机连接，并释放与关联的所有托管资源和非托管资源 <xref:System.Net.Sockets.Socket> 。 关闭时， <xref:System.Net.Sockets.Socket.Connected%2A> 属性将设置为 `false` 。  
  
 对于面向连接的协议，建议你在 <xref:System.Net.Sockets.Socket.Shutdown%2A> 调用之前调用 <xref:System.Net.Sockets.Socket.Close%2A> 。 这可确保所有数据在连接的套接字关闭之前都已发送和接收。  
  
 如果需要 <xref:System.Net.Sockets.Socket.Close%2A> 先调用而不调用 <xref:System.Net.Sockets.Socket.Shutdown%2A> ，则可以通过将选项设置 <xref:System.Net.Sockets.SocketOptionName.DontLinger> 为 `false` 并指定非零超时间隔来确保将排队等待传出传输的数据发送。 <xref:System.Net.Sockets.Socket.Close%2A> 然后将被阻止，直到发送此数据或指定的超时过期。 如果将设置 <xref:System.Net.Sockets.SocketOptionName.DontLinger> 为 `false` 并指定零超时间隔，则 <xref:System.Net.Sockets.Socket.Close%2A> 会释放连接并自动丢弃传出的排队数据。  
  
> [!NOTE]
>  若要将 <xref:System.Net.Sockets.SocketOptionName.DontLinger> 套接字选项设置为 `false` ，请创建 <xref:System.Net.Sockets.LingerOption> ，将 enabled 属性设置为 `true` ，并将 <xref:System.Net.Sockets.LingerOption.LingerTime%2A> 属性设置为所需的超时期限。 将此 <xref:System.Net.Sockets.LingerOption> 与 <xref:System.Net.Sockets.SocketOptionName.DontLinger> 套接字选项一起使用来调用 <xref:System.Net.Sockets.Socket.SetSocketOption%2A> 方法。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅 [.NET Framework 中的网络跟踪](/dotnet/framework/network-programming/network-tracing)。  
  
   
  
## Examples  
 下面的代码示例演示如何关闭 <xref:System.Net.Sockets.Socket> 。  
  
 [!code-cpp[Classic Socket.Close Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Close Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Close Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Close Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Close Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Close Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="F:System.Net.Sockets.SocketOptionName.DontLinger" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Connect">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>与远程主机建立连接。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Connect">
      <MemberSignature Language="C#" Value="public void Connect (System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Connect(class System.Net.EndPoint remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Connect (remoteEP As EndPoint)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Connect(System::Net::EndPoint ^ remoteEP);" />
      <MemberSignature Language="F#" Value="member this.Connect : System.Net.EndPoint -&gt; unit" Usage="socket.Connect remoteEP" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="remoteEP">表示远程设备的 <see cref="T:System.Net.EndPoint" />。</param>
        <summary>与远程主机建立连接。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果使用面向连接的协议（例如 TCP），则方法会在 <xref:System.Net.Sockets.Socket.Connect%2A> <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> 和指定的远程终结点之间同步建立网络连接。 如果使用的是无连接协议，则会 <xref:System.Net.Sockets.Socket.Connect%2A> 建立默认远程主机。 调用后 <xref:System.Net.Sockets.Socket.Connect%2A> ，可通过方法将数据发送到远程设备 <xref:System.Net.Sockets.Socket.Send%2A> ，或通过方法从远程设备接收数据 <xref:System.Net.Sockets.Socket.Receive%2A> 。  
  
 如果使用的是无连接协议（如 UDP），则在 <xref:System.Net.Sockets.Socket.Connect%2A> 发送和接收数据之前无需调用。 您可以使用 <xref:System.Net.Sockets.Socket.SendTo%2A> 和 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 来与远程主机同步通信。 如果调用 <xref:System.Net.Sockets.Socket.Connect%2A> 了，则从指定的默认值以外的地址到达的任何数据报都将被丢弃。 如果要将默认远程主机设置为广播地址，则必须先调用 <xref:System.Net.Sockets.Socket.SetSocketOption%2A> 方法，并将套接字选项设置为 <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType> ，否则 <xref:System.Net.Sockets.Socket.Connect%2A> 将引发 <xref:System.Net.Sockets.SocketException> 。 如果收到 <xref:System.Net.Sockets.SocketException> ，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。 获取此代码后，请参阅 [Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2) 文档，以获取有关错误的详细说明。  
  
 <xref:System.Net.Sockets.Socket.Connect%2A>方法将会阻止，除非在 <xref:System.Net.Sockets.Socket.Blocking%2A> 调用之前专门将属性设置为 `false` <xref:System.Net.Sockets.Socket.Connect%2A> 。 如果使用面向连接的协议（如 TCP），并禁用阻止，则 <xref:System.Net.Sockets.Socket.Connect%2A> 会引发， <xref:System.Net.Sockets.SocketException> 因为它需要时间来建立连接。 无连接协议不会引发异常，因为它们只是建立默认远程主机。 您可以使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 来获取特定的错误代码。 获取此代码后，请参阅 [Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2) 文档，以获取有关错误的详细说明。 如果错误返回了 WSAEWOULDBLOCK，则远程主机连接已由面向连接的连接 <xref:System.Net.Sockets.Socket> ，但尚未成功完成。 使用 <xref:System.Net.Sockets.Socket.Poll%2A> 方法可确定 <xref:System.Net.Sockets.Socket> 完成连接的时间。  
  
> [!NOTE]
>  如果使用面向连接的协议，且 <xref:System.Net.Sockets.Socket.Bind%2A> 在调用之前未调用 <xref:System.Net.Sockets.Socket.Connect%2A> ，则基础服务提供程序将分配本地网络地址和端口号。 如果使用的是无连接协议，则在完成发送或接收操作之前，服务提供程序将不会分配本地网络地址和端口号。 如果要更改默认远程主机，请 <xref:System.Net.Sockets.Socket.Connect%2A> 再次调用所需的终结点。  
  
> [!NOTE]
>  如果先前已断开套接字连接，则不能使用此方法来还原连接。 使用异步 <xref:System.Net.Sockets.Socket.BeginConnect%2A> 方法之一重新连接。 这是底层提供程序的限制。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅 [.NET Framework 中的网络跟踪](/dotnet/framework/network-programming/network-tracing)。  
  
   
  
## Examples  
 下面的代码示例连接到远程终结点，并验证连接。  
  
 [!code-cpp[Classic Socket.Connect Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Connect Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Connect Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Connect Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Connect Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Connect Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="remoteEP" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <exception cref="T:System.Security.SecurityException">调用堆栈中的较高调用方无权执行所请求的操作。</exception>
        <exception cref="T:System.InvalidOperationException">已通过调用 <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> 将 <see cref="T:System.Net.Sockets.Socket" /> 置于侦听状态。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.LocalEndPoint" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="P:System.Net.Sockets.Socket.Blocking" />
        <altmember cref="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)" />
      </Docs>
    </Member>
    <Member MemberName="Connect">
      <MemberSignature Language="C#" Value="public void Connect (System.Net.IPAddress address, int port);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Connect(class System.Net.IPAddress address, int32 port) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Connect (address As IPAddress, port As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Connect(System::Net::IPAddress ^ address, int port);" />
      <MemberSignature Language="F#" Value="member this.Connect : System.Net.IPAddress * int -&gt; unit" Usage="socket.Connect (address, port)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Net.IPAddress" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="port" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="address">远程主机的 IP 地址。</param>
        <param name="port">远程主机的端口号。</param>
        <summary>与远程主机建立连接。 主机由 IP 地址和端口号指定。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果使用面向连接的协议（例如 TCP），则方法会在 <xref:System.Net.Sockets.Socket.Connect%2A> <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> 和指定的远程终结点之间同步建立网络连接。 如果使用的是无连接协议，则会 <xref:System.Net.Sockets.Socket.Connect%2A> 建立默认远程主机。 调用后， <xref:System.Net.Sockets.Socket.Connect%2A> 可通过方法将数据发送到远程设备 <xref:System.Net.Sockets.Socket.Send%2A> ，或通过方法从远程设备接收数据 <xref:System.Net.Sockets.Socket.Receive%2A> 。  
  
 如果使用的是无连接协议（如 UDP），则在 <xref:System.Net.Sockets.Socket.Connect%2A> 发送和接收数据之前无需调用。 您可以使用 <xref:System.Net.Sockets.Socket.SendTo%2A> 和 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 来与远程主机同步通信。 如果确实要调用 <xref:System.Net.Sockets.Socket.Connect%2A> 从指定的默认值以外的地址到达的任何数据报，将放弃。 如果要将默认远程主机设置为广播地址，则必须先调用 <xref:System.Net.Sockets.Socket.SetSocketOption%2A> 方法，并将套接字选项设置为 <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType> ，否则 <xref:System.Net.Sockets.Socket.Connect%2A> 将引发 <xref:System.Net.Sockets.SocketException> 。 如果收到 <xref:System.Net.Sockets.SocketException> ，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。 获取此代码后，请参阅 [Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2) 文档，以获取有关错误的详细说明。  
  
 <xref:System.Net.Sockets.Socket.Connect%2A> 方法将会阻止，除非在 <xref:System.Net.Sockets.Socket.Blocking%2A> 调用之前专门将属性设置为 `false` <xref:System.Net.Sockets.Socket.Connect%2A> 。 如果使用面向连接的协议（如 TCP），并禁用阻止，则 <xref:System.Net.Sockets.Socket.Connect%2A> 会引发， <xref:System.Net.Sockets.SocketException> 因为它需要时间来建立连接。 无连接协议不会引发异常，因为它们只是建立默认远程主机。 您可以使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 来获取特定的错误代码。 获取此代码后，请参阅 [Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2) 文档，以获取有关错误的详细说明。 如果错误返回了 WSAEWOULDBLOCK，则远程主机连接已由面向连接的连接 <xref:System.Net.Sockets.Socket> ，但尚未成功完成。 使用 <xref:System.Net.Sockets.Socket.Poll%2A> 方法可确定 <xref:System.Net.Sockets.Socket> 完成连接的时间。  
  
> [!NOTE]
>  如果使用面向连接的协议，且 <xref:System.Net.Sockets.Socket.Bind%2A> 在调用之前未调用 <xref:System.Net.Sockets.Socket.Connect%2A> ，则基础服务提供程序将分配本地网络地址和端口号。 如果使用的是无连接协议，则在完成发送或接收操作之前，服务提供程序将不会分配本地网络地址和端口号。 如果要更改默认远程主机，请 <xref:System.Net.Sockets.Socket.Connect%2A> 再次调用所需的终结点。  
  
> [!NOTE]
>  如果先前已断开套接字连接，则不能使用此方法来还原连接。 使用异步 <xref:System.Net.Sockets.Socket.BeginConnect%2A> 方法之一重新连接。 这是底层提供程序的限制。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅 [.NET Framework 中的网络跟踪](/dotnet/framework/network-programming/network-tracing)。  
  
   
  
## Examples  
 下面的代码示例连接到远程终结点，并验证连接。  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#4](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#4)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#4](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="address" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">端口号无效。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <exception cref="T:System.NotSupportedException">此方法对 <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> 或 <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> 系列中的套接字有效。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="address" /> 的长度为零。</exception>
        <exception cref="T:System.InvalidOperationException">已通过调用 <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> 将 <see cref="T:System.Net.Sockets.Socket" /> 置于侦听状态。</exception>
      </Docs>
    </Member>
    <Member MemberName="Connect">
      <MemberSignature Language="C#" Value="public void Connect (System.Net.IPAddress[] addresses, int port);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Connect(class System.Net.IPAddress[] addresses, int32 port) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Connect (addresses As IPAddress(), port As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Connect(cli::array &lt;System::Net::IPAddress ^&gt; ^ addresses, int port);" />
      <MemberSignature Language="F#" Value="member this.Connect : System.Net.IPAddress[] * int -&gt; unit" Usage="socket.Connect (addresses, port)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="addresses" Type="System.Net.IPAddress[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="port" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="addresses">远程主机的 IP 地址。</param>
        <param name="port">远程主机的端口号。</param>
        <summary>与远程主机建立连接。 主机由 IP 地址数组和端口号指定。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法通常在调用后立即使用 <xref:System.Net.Dns.GetHostAddresses%2A> ，后者可为单个主机返回多个 IP 地址。 如果使用面向连接的协议（例如 TCP），则方法会在 <xref:System.Net.Sockets.Socket.Connect%2A> <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> 和指定的远程终结点之间同步建立网络连接。 如果使用的是无连接协议，则会 <xref:System.Net.Sockets.Socket.Connect%2A> 建立默认远程主机。 调用后， <xref:System.Net.Sockets.Socket.Connect%2A> 可通过方法将数据发送到远程设备 <xref:System.Net.Sockets.Socket.Send%2A> ，或通过方法从远程设备接收数据 <xref:System.Net.Sockets.Socket.Receive%2A> 。  
  
 如果使用的是无连接协议（如 UDP），则在 <xref:System.Net.Sockets.Socket.Connect%2A> 发送和接收数据之前无需调用。 您可以使用 <xref:System.Net.Sockets.Socket.SendTo%2A> 和 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 来与远程主机同步通信。 如果确实要调用 <xref:System.Net.Sockets.Socket.Connect%2A> 从指定的默认值以外的地址到达的任何数据报，将放弃。 如果要将默认远程主机设置为广播地址，则必须先调用 <xref:System.Net.Sockets.Socket.SetSocketOption%2A> 方法，并将套接字选项设置为 <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType> ，否则 <xref:System.Net.Sockets.Socket.Connect%2A> 将引发 <xref:System.Net.Sockets.SocketException> 。 如果收到 <xref:System.Net.Sockets.SocketException> ，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。 获取此代码后，请参阅 [Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2) 文档，以获取有关错误的详细说明。  
  
 <xref:System.Net.Sockets.Socket.Connect%2A> 方法将会阻止，除非在 <xref:System.Net.Sockets.Socket.Blocking%2A> 调用之前专门将属性设置为 `false` <xref:System.Net.Sockets.Socket.Connect%2A> 。 如果使用面向连接的协议（如 TCP），并禁用阻止，则 <xref:System.Net.Sockets.Socket.Connect%2A> 会引发， <xref:System.Net.Sockets.SocketException> 因为它需要时间来建立连接。 无连接协议不会引发异常，因为它们只是建立默认远程主机。 您可以使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 来获取特定的错误代码。 获取此代码后，请参阅 [Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2) 文档，以获取有关错误的详细说明。 如果错误返回了 WSAEWOULDBLOCK，则远程主机连接已由面向连接的连接 <xref:System.Net.Sockets.Socket> ，但尚未成功完成。 使用 <xref:System.Net.Sockets.Socket.Poll%2A> 方法可确定 <xref:System.Net.Sockets.Socket> 完成连接的时间。  
  
> [!NOTE]
>  如果使用面向连接的协议，且 <xref:System.Net.Sockets.Socket.Bind%2A> 在调用之前未调用 <xref:System.Net.Sockets.Socket.Connect%2A> ，则基础服务提供程序将分配本地网络地址和端口号。 如果使用的是无连接协议，则在完成发送或接收操作之前，服务提供程序将不会分配本地网络地址和端口号。 如果要更改默认远程主机，请 <xref:System.Net.Sockets.Socket.Connect%2A> 再次调用所需的终结点。  
  
> [!NOTE]
>  如果先前已断开套接字连接，则不能使用此方法来还原连接。 使用异步 <xref:System.Net.Sockets.Socket.BeginConnect%2A> 方法之一重新连接。 这是底层提供程序的限制。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅 [.NET Framework 中的网络跟踪](/dotnet/framework/network-programming/network-tracing)。  
  
   
  
## Examples  
 下面的代码示例连接到远程终结点，并验证连接。  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#5](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#5)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#5](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="addresses" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">端口号无效。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <exception cref="T:System.NotSupportedException">此方法对 <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> 或 <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> 系列中的套接字有效。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="address" /> 的长度为零。</exception>
        <exception cref="T:System.InvalidOperationException">已通过调用 <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> 将 <see cref="T:System.Net.Sockets.Socket" /> 置于侦听状态。</exception>
      </Docs>
    </Member>
    <Member MemberName="Connect">
      <MemberSignature Language="C#" Value="public void Connect (string host, int port);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Connect(string host, int32 port) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Connect(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Connect (host As String, port As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Connect(System::String ^ host, int port);" />
      <MemberSignature Language="F#" Value="member this.Connect : string * int -&gt; unit" Usage="socket.Connect (host, port)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="host" Type="System.String" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="port" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="host">远程主机的名称。</param>
        <param name="port">远程主机的端口号。</param>
        <summary>与远程主机建立连接。 主机由主机名和端口号指定。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果你使用的是面向连接的协议（例如 TCP），则方法会在 <xref:System.Net.Sockets.Socket.Connect%2A> <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> 和指定的远程主机之间同步建立网络连接。 如果使用的是无连接协议，则会 <xref:System.Net.Sockets.Socket.Connect%2A> 建立默认远程主机。 调用后， <xref:System.Net.Sockets.Socket.Connect%2A> 可通过方法将数据发送到远程设备 <xref:System.Net.Sockets.Socket.Send%2A> ，或通过方法从远程设备接收数据 <xref:System.Net.Sockets.Socket.Receive%2A> 。  
  
 如果使用的是无连接协议（如 UDP），则在 <xref:System.Net.Sockets.Socket.Connect%2A> 发送和接收数据之前无需调用。 您可以使用 <xref:System.Net.Sockets.Socket.SendTo%2A> 和 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 来与远程主机同步通信。 如果确实要调用 <xref:System.Net.Sockets.Socket.Connect%2A> 从指定的默认值以外的地址到达的任何数据报，将放弃。 如果要将默认远程主机设置为广播地址，则必须先调用 <xref:System.Net.Sockets.Socket.SetSocketOption%2A> 方法，并将套接字选项设置为 <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType> ，否则 <xref:System.Net.Sockets.Socket.Connect%2A> 将引发 <xref:System.Net.Sockets.SocketException> 。 如果收到 <xref:System.Net.Sockets.SocketException> ，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。 获取此代码后，请参阅 [Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2) 文档，以获取有关错误的详细说明。  
  
 <xref:System.Net.Sockets.Socket.Connect%2A> 方法将会阻止，除非在 <xref:System.Net.Sockets.Socket.Blocking%2A> 调用之前专门将属性设置为 `false` <xref:System.Net.Sockets.Socket.Connect%2A> 。 如果使用面向连接的协议（如 TCP），并禁用阻止，则 <xref:System.Net.Sockets.Socket.Connect%2A> 会引发， <xref:System.Net.Sockets.SocketException> 因为它需要时间来建立连接。 无连接协议不会引发异常，因为它们只是建立默认远程主机。 您可以使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 来获取特定的错误代码。 获取此代码后，请参阅 [Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2) 文档，以获取有关错误的详细说明。 如果错误返回了 WSAEWOULDBLOCK，则远程主机连接已由面向连接的连接 <xref:System.Net.Sockets.Socket> ，但尚未成功完成。 使用 <xref:System.Net.Sockets.Socket.Poll%2A> 方法可确定 <xref:System.Net.Sockets.Socket> 完成连接的时间。  
  
 如果启用了 IPv6，并且 <xref:System.Net.Sockets.Socket.Connect%28System.String%2CSystem.Int32%29> 调用了方法来连接到解析 IPv6 和 ipv4 地址的主机，则在 IPv4 地址之前将首先尝试连接到 ipv6 地址。 如果主机未侦听 IPv6 地址，则这可能会延迟建立连接的时间。  
  
> [!NOTE]
>  如果使用面向连接的协议，且 <xref:System.Net.Sockets.Socket.Bind%2A> 在调用之前未调用 <xref:System.Net.Sockets.Socket.Connect%2A> ，则基础服务提供程序将分配本地网络地址和端口号。 如果使用的是无连接协议，则在完成发送或接收操作之前，服务提供程序将不会分配本地网络地址和端口号。 如果要更改默认远程主机，请 <xref:System.Net.Sockets.Socket.Connect%2A> 再次调用所需的终结点。  
  
> [!NOTE]
>  如果先前已断开套接字连接，则不能使用此方法来还原连接。 使用异步 <xref:System.Net.Sockets.Socket.BeginConnect%2A> 方法之一重新连接。 这是底层提供程序的限制。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅 [.NET Framework 中的网络跟踪](/dotnet/framework/network-programming/network-tracing)。  
  
   
  
## Examples  
 下面的代码示例连接到远程终结点，并验证连接。  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#6](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#6)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#6](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="host" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">端口号无效。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <exception cref="T:System.NotSupportedException">此方法对 <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> 或 <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> 系列中的套接字有效。</exception>
        <exception cref="T:System.InvalidOperationException">已通过调用 <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> 将 <see cref="T:System.Net.Sockets.Socket" /> 置于侦听状态。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ConnectAsync">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>开始一个对远程主机连接的异步请求。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ConnectAsync">
      <MemberSignature Language="C#" Value="public bool ConnectAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ConnectAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function ConnectAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ConnectAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.ConnectAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="socket.ConnectAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="e">要用于此异步套接字操作的 <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> 对象。</param>
        <summary>开始一个对远程主机连接的异步请求。</summary>
        <returns>如果 I/O 操作挂起，则为 <see langword="true" />。 操作完成时，将引发 <paramref name="e" /> 参数的 <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> 事件。  
  
 如果 I/O 操作同步完成，则为 <see langword="false" />。 在这种情况下，将不会引发 <paramref name="e" /> 参数的 <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> 事件，并且可能在方法调用返回后立即检查作为参数传递的 <paramref name="e" /> 对象以检索操作的结果。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果使用面向连接的协议，则该方法将 <xref:System.Net.Sockets.Socket.ConnectAsync%2A> 启动与远程主机的连接的异步请求。 如果使用的是无连接协议，则会 <xref:System.Net.Sockets.Socket.ConnectAsync%2A> 建立默认远程主机。  
  
 若要在完成时收到通知，您必须创建一个实现 EventHandler 委托的回调方法 \<SocketAsyncEventArgs> ，并将回调附加到该 <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType> 事件。  
  
 调用方必须将 <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> 属性设置为 <xref:System.Net.IPEndPoint> 要连接到的远程主机的。  
  
 调用方可以 <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> 在调用方法之前将属性设置为所需的任何用户状态对象 <xref:System.Net.Sockets.Socket.ConnectAsync%2A> ，以便可以在回调方法中检索信息。 如果回调需要比单个对象更多的信息，则可以创建一个小类，以将其他所需的状态信息保存为成员。  
  
 如果使用的是无连接协议（如 UDP），则在 <xref:System.Net.Sockets.Socket.ConnectAsync%2A> 发送和接收数据之前无需调用。 您可以使用 <xref:System.Net.Sockets.Socket.SendToAsync%2A> 和 <xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A> 来与远程主机通信。 如果调用 <xref:System.Net.Sockets.Socket.ConnectAsync%2A> 了，则从指定的默认值以外的地址到达的任何数据报都将被丢弃。 如果要更改默认远程主机，请 <xref:System.Net.Sockets.Socket.ConnectAsync%2A> 与所需的终结点再次调用方法。  
  
 如果要将默认远程主机设置为广播地址，则必须先调用 <xref:System.Net.Sockets.Socket.SetSocketOption%2A> 并将广播设置为 `true` 。 如果未执行此操作，则该 <xref:System.Net.Sockets.Socket.ConnectAsync%2A> 方法将引发 <xref:System.Net.Sockets.SocketException> 。  
  
 对象上的下列属性和事件 <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> 是必需的：  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>  
  
 （可选）可以在方法成功后，提供可在套接字上自动发送的缓冲区 <xref:System.Net.Sockets.Socket.ConnectAsync%2A> 。 在这种情况下， <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> 需要将属性设置为包含要发送的数据的缓冲区，并且 <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> 需要将属性设置为要从缓冲区发送的数据的字节数。 建立连接后，将发送此数据缓冲区。  
  
 如果使用面向连接的协议，且 <xref:System.Net.Sockets.Socket.Bind%2A> 在调用之前未调用 <xref:System.Net.Sockets.Socket.ConnectAsync%2A> ，则基础服务提供程序将分配最适当的本地网络地址和端口号。  
  
 如果使用的是无连接协议，则在调用或方法之前，服务提供程序将不会分配本地网络 IP 地址和端口号 <xref:System.Net.Sockets.Socket.SendAsync%2A> <xref:System.Net.Sockets.Socket.ReceiveAsync%2A> 。  
  
 <xref:System.Net.Sockets.Socket.ConnectAsync%2A> <xref:System.NotSupportedException> 如果和的地址系列不同，则方法将引发 <xref:System.Net.Sockets.Socket> <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> 。  
  
> [!NOTE]
>  如果在 <xref:System.Net.Sockets.SocketException> 调用此方法时接收到，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。 获取此代码后，请参阅 [Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2) 文档，以获取有关错误的详细说明。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">自变量无效。 如果指定了多个缓冲区，即 <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /> 属性不为 null，将会发生此异常。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="e" /> 参数不能为 null，并且 <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> 不能为空。</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Net.Sockets.Socket" /> 正在侦听或已经在使用 <paramref name="e" /> 参数中指定的 <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> 对象执行套接字操作。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.NotSupportedException">此方法需要 Windows XP 或更高版本。 如果本地终结点和 <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> 不是相同的地址族，也会发生此异常。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <exception cref="T:System.Security.SecurityException">调用堆栈中的较高调用方无权执行所请求的操作。</exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="ConnectAsync">
      <MemberSignature Language="C#" Value="public static bool ConnectAsync (System.Net.Sockets.SocketType socketType, System.Net.Sockets.ProtocolType protocolType, System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool ConnectAsync(valuetype System.Net.Sockets.SocketType socketType, valuetype System.Net.Sockets.ProtocolType protocolType, class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ConnectAsync (socketType As SocketType, protocolType As ProtocolType, e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool ConnectAsync(System::Net::Sockets::SocketType socketType, System::Net::Sockets::ProtocolType protocolType, System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="static member ConnectAsync : System.Net.Sockets.SocketType * System.Net.Sockets.ProtocolType * System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="System.Net.Sockets.Socket.ConnectAsync (socketType, protocolType, e)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="socketType" Type="System.Net.Sockets.SocketType" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="protocolType" Type="System.Net.Sockets.ProtocolType" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" Index="2" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="socketType"><see cref="T:System.Net.Sockets.SocketType" /> 值之一。</param>
        <param name="protocolType"><see cref="T:System.Net.Sockets.ProtocolType" /> 值之一。</param>
        <param name="e">要用于此异步套接字操作的 <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> 对象。</param>
        <summary>开始一个对远程主机连接的异步请求。</summary>
        <returns>如果 I/O 操作挂起，则为 <see langword="true" />。 操作完成时，将引发 <paramref name="e" /> 参数的 <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> 事件。  
  
 如果 I/O 操作同步完成，则为 <see langword="false" />。 在这种情况下，将不会引发 <paramref name="e" /> 参数的 <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> 事件，并且可能在方法调用返回后立即检查作为参数传递的 <paramref name="e" /> 对象以检索操作的结果。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果你使用的是面向连接的协议，则 M:System.Net.Sockets.Socket.ConnectAsync (系统 SocketType，系统 .net. ProtocolType，SocketAsyncEventArgs) 方法启动到远程主机的连接的异步请求。 如果使用的是无连接协议，则 <xref:System.Net.Sockets.Socket.ConnectAsync%2A> 建立由和参数指定的默认远程主机 `socketType` `protocolType` 。  
  
 若要在完成时收到通知，您必须创建一个实现 EventHandler 委托的回调方法 \<SocketAsyncEventArgs> ，并将回调附加到该 <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType> 事件。  
  
 调用方必须将 <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> 属性设置为 <xref:System.Net.IPEndPoint> 要连接到的远程主机的。  
  
 调用方可以 <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> 在调用方法之前将属性设置为所需的任何用户状态对象 <xref:System.Net.Sockets.Socket.ConnectAsync%2A> ，以便可以在回调方法中检索信息。 如果回调需要比单个对象更多的信息，则可以创建一个小类，以将其他所需的状态信息保存为成员。  
  
 如果使用的是无连接协议（如 UDP），则在 <xref:System.Net.Sockets.Socket.ConnectAsync%2A> 发送和接收数据之前无需调用。 您可以使用 <xref:System.Net.Sockets.Socket.SendToAsync%2A> 和 <xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A> 来与远程主机通信。 如果调用 <xref:System.Net.Sockets.Socket.ConnectAsync%2A> 了，则从指定的默认值以外的地址到达的任何数据报都将被丢弃。 如果要更改默认远程主机，请 <xref:System.Net.Sockets.Socket.ConnectAsync%2A> 与所需的终结点再次调用方法。  
  
 如果要将默认远程主机设置为广播地址，则必须先调用 <xref:System.Net.Sockets.Socket.SetSocketOption%2A> 并将广播设置为 `true` 。 如果未执行此操作，则该 <xref:System.Net.Sockets.Socket.ConnectAsync%2A> 方法将引发 <xref:System.Net.Sockets.SocketException> 。  
  
 对象上的下列属性和事件 <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> 是必需的：  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>  
  
 （可选）可以在方法成功后，提供可在套接字上自动发送的缓冲区 <xref:System.Net.Sockets.Socket.ConnectAsync%2A> 。 在这种情况下， <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> 需要将属性设置为包含要发送的数据的缓冲区，并且 <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> 需要将属性设置为要从缓冲区发送的数据的字节数。 建立连接后，将发送此数据缓冲区。  
  
 如果使用面向连接的协议，且 <xref:System.Net.Sockets.Socket.Bind%2A> 在调用之前未调用 <xref:System.Net.Sockets.Socket.ConnectAsync%2A> ，则基础服务提供程序将分配最适当的本地网络地址和端口号。  
  
 如果使用的是无连接协议，则在调用或方法之前，服务提供程序将不会分配本地网络 IP 地址和端口号 <xref:System.Net.Sockets.Socket.SendAsync%2A> <xref:System.Net.Sockets.Socket.ReceiveAsync%2A> 。  
  
 <xref:System.Net.Sockets.Socket.ConnectAsync%2A> <xref:System.NotSupportedException> 如果和的地址系列不同，则方法将引发 <xref:System.Net.Sockets.Socket> <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> 。  
  
> [!NOTE]
>  如果在 <xref:System.Net.Sockets.SocketException> 调用此方法时接收到，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。 获取此代码后，请参阅 [Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2) 文档，以获取有关错误的详细说明。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">自变量无效。 如果指定了多个缓冲区，即 <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /> 属性不为 null，将会发生此异常。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="e" /> 参数不能为 null，并且 <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> 不能为空。</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Net.Sockets.Socket" /> 正在侦听或已经在使用 <paramref name="e" /> 参数中指定的 <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> 对象执行套接字操作。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.NotSupportedException">此方法需要 Windows XP 或更高版本。 如果本地终结点和 <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> 不是相同的地址族，也会发生此异常。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <exception cref="T:System.Security.SecurityException">调用堆栈中的较高调用方无权执行所请求的操作。</exception>
      </Docs>
    </Member>
    <Member MemberName="Connected">
      <MemberSignature Language="C#" Value="public bool Connected { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Connected" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.Connected" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Connected As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Connected { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.Connected : bool" Usage="System.Net.Sockets.Socket.Connected" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示 <see cref="T:System.Net.Sockets.Socket" /> 是在上次 <see cref="Overload:System.Net.Sockets.Socket.Send" /> 还是 <see cref="Overload:System.Net.Sockets.Socket.Receive" /> 操作时连接到远程主机。</summary>
        <value>如果 <see cref="T:System.Net.Sockets.Socket" /> 在最近操作时连接到远程资源，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Connected`属性获取从 <xref:System.Net.Sockets.Socket> 最后一个 i/o 操作到的的连接状态。 当它返回时 `false` ， <xref:System.Net.Sockets.Socket> 要么从未连接，要么不再处于连接状态。 `Connected` 不是线程安全的; `true` 当 <xref:System.Net.Sockets.Socket> 从另一个线程断开连接时，它可能会在操作中止后返回。
  
 属性的值反映了从 <xref:System.Net.Sockets.Socket.Connected%2A> 最近操作到的连接状态。 如果需要确定连接的当前状态，请发出非阻止的零字节发送调用。 如果调用成功返回或引发 WAEWOULDBLOCK 错误代码 (10035) ，则套接字仍处于连接状态;否则，将不再连接套接字。  
  
 如果在 <xref:System.Net.Sockets.Socket.Connect%2A> (udp) 套接字的用户数据报协议上调用，则该 <xref:System.Net.Sockets.Socket.Connected%2A> 属性始终返回 `true` ; 但是，此操作不会更改 UDP 的固有无连接性质。  
  
   
  
## Examples  
 下面的代码示例连接到远程终结点，检查 <xref:System.Net.Sockets.Socket.Connected%2A> 属性，并检查连接的当前状态。  
  
 [!code-cpp[Classic Socket.Connect Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Connect Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Connect Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Connect Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Connect Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Connect Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Disconnect">
      <MemberSignature Language="C#" Value="public void Disconnect (bool reuseSocket);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Disconnect(bool reuseSocket) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Disconnect(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Disconnect (reuseSocket As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Disconnect(bool reuseSocket);" />
      <MemberSignature Language="F#" Value="member this.Disconnect : bool -&gt; unit" Usage="socket.Disconnect reuseSocket" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reuseSocket" Type="System.Boolean" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="reuseSocket">如果关闭当前连接后可以重用此套接字，则为 <see langword="true" />；否则为 <see langword="false" />。</param>
        <summary>关闭套接字连接并允许重用套接字。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果使用面向连接的协议，则可以使用此方法关闭套接字。 此方法结束连接，并将 <xref:System.Net.Sockets.Socket.Connected%2A> 属性设置为 `false` 。 但是，如果 `reuseSocket` 为 `true` ，则可以重复使用套接字。  
  
 若要确保在关闭套接字之前发送和接收所有数据，应在 <xref:System.Net.Sockets.Socket.Shutdown%2A> 调用方法之前调用 <xref:System.Net.Sockets.Socket.Disconnect%2A> 。  
  
 如果需要在 <xref:System.Net.Sockets.Socket.Disconnect%2A> 不第一次调用的情况下调用 <xref:System.Net.Sockets.Socket.Shutdown%2A> ，可以将 <xref:System.Net.Sockets.SocketOptionName.DontLinger> <xref:System.Net.Sockets.Socket> 选项设置为 `false` ，并指定非零超时间隔，以确保发送排队等候传出传输的数据。 <xref:System.Net.Sockets.Socket.Disconnect%2A> 然后阻止到发送数据，或直到指定的超时过期。 如果将设置 <xref:System.Net.Sockets.SocketOptionName.DontLinger> 为 `false` 并指定零超时间隔，则 <xref:System.Net.Sockets.Socket.Close%2A> 会释放连接并自动丢弃传出的排队数据。  
  
> [!NOTE]
>  如果收到 <xref:System.Net.Sockets.SocketException> ，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。 获取此代码后，请参阅 [Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2) 文档，以获取有关错误的详细说明。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅 [.NET Framework 中的网络跟踪](/dotnet/framework/network-programming/network-tracing)。  
  
   
  
## Examples  
 下面的代码示例为同步通信创建套接字，并将一些数据发送到远程主机。 然后，它调用 <xref:System.Net.Sockets.Socket.Shutdown%2A> 以停止发送和接收活动，并调用 <xref:System.Net.Sockets.Socket.Disconnect%2A> 以关闭套接字连接。  
  
 [!code-cpp[Nclsocketenhancements#12](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#12)]
 [!code-csharp[Nclsocketenhancements#12](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 对象已关闭。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
      </Docs>
    </Member>
    <Member MemberName="DisconnectAsync">
      <MemberSignature Language="C#" Value="public bool DisconnectAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool DisconnectAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.DisconnectAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function DisconnectAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool DisconnectAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.DisconnectAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="socket.DisconnectAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="e">要用于此异步套接字操作的 <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> 对象。</param>
        <summary>开始异步请求从远程终结点断开连接。</summary>
        <returns>如果 I/O 操作挂起，则为 <see langword="true" />。 操作完成时，将引发 <paramref name="e" /> 参数的 <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> 事件。  
  
 如果 I/O 操作同步完成，则为 <see langword="false" />。 在这种情况下，将不会引发 <paramref name="e" /> 参数的 <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> 事件，并且可能在方法调用返回后立即检查作为参数传递的 <paramref name="e" /> 对象以检索操作的结果。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用面向连接的协议时，调用方法会 <xref:System.Net.Sockets.Socket.DisconnectAsync%2A> 从远程终结点请求断开连接。 如果在 <xref:System.Net.Sockets.SocketAsyncEventArgs.DisconnectReuseSocket%2A?displayProperty=nameWithType> 参数中将设置为 `true` `e` ，则可以重复使用套接字。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="e" /> 参数不能为 NULL。</exception>
        <exception cref="T:System.InvalidOperationException">已经在使用 <paramref name="e" /> 参数中指定的 <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> 对象执行套接字操作。</exception>
        <exception cref="T:System.NotSupportedException">此方法需要 Windows XP 或更高版本。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.DisconnectReuseSocket" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>释放 <see cref="T:System.Net.Sockets.Socket" /> 类的当前实例所使用的所有资源。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="socket.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>释放 <see cref="T:System.Net.Sockets.Socket" /> 类的当前实例所使用的所有资源。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在完成使用 `Dispose` 后，应调用 <xref:System.Net.Sockets.Socket>。 `Dispose` 方法使 <xref:System.Net.Sockets.Socket> 处于不可用状态。 调用后 `Dispose` ，必须释放对的所有引用， <xref:System.Net.Sockets.Socket> 以便垃圾回收器能够回收占用的内存 <xref:System.Net.Sockets.Socket> 。  
  
 有关详细信息，请参阅 [清理非托管资源](/dotnet/standard/garbage-collection/unmanaged) 和 [实现 Dispose 方法](/dotnet/standard/garbage-collection/implementing-dispose)。  
  
> [!NOTE]
>  每次释放对 `Dispose` 的最后一个引用前，均应调用 <xref:System.Net.Sockets.Socket>。 否则，在垃圾回收器调用 <xref:System.Net.Sockets.Socket> 对象的 `Finalize` 方法之前，该对象正在使用的资源不会被释放。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit&#xA;override this.Dispose : bool -&gt; unit" Usage="socket.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">如果释放托管资源和非托管资源，则为 <see langword="true" />；如果仅释放非托管资源，则为 <see langword="false" />。</param>
        <summary>释放由 <see cref="T:System.Net.Sockets.Socket" /> 使用的非托管资源，并可根据需要释放托管资源。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法由公共 `Dispose()` 方法和 <xref:System.Object.Finalize%2A> 方法调用。 `Dispose()` 调用受保护的 `Dispose(Boolean)` 方法，并将 `disposing` 参数设置为 `true` 。 <xref:System.Object.Finalize%2A>`Dispose`在设置为的情况调用 `disposing` `false` 。  
  
 当 `disposing` 参数为 `true` 时，此方法释放该 <xref:System.Net.Sockets.Socket> 引用的、由任何托管对象持有的全部资源。 此方法将调用每个被引用对象的 `Dispose()` 方法。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅 [.NET Framework 中的网络跟踪](/dotnet/framework/network-programming/network-tracing)。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>
            <see langword="Dispose" /> 可以由其他对象多次调用。 重写 <see cref="M:System.Net.Sockets.Socket.Dispose(System.Boolean)" /> 时，请注意不要引用在以前调用 <see langword="Dispose" /> 时已释放的对象。 有关如何实现的详细信息 <see cref="M:System.Net.Sockets.Socket.Dispose(System.Boolean)" /> ，请参阅 [实现 Dispose 方法](/dotnet/standard/garbage-collection/implementing-dispose)。  
  
有关和的详细 <see langword="Dispose" /> 信息 <see cref="M:System.Object.Finalize" /> ，请参阅 [清理非托管资源](/dotnet/standard/garbage-collection/unmanaged) 和 [重写 Finalize 方法](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/ddae83kx(v=vs.100))。</para></block>
      </Docs>
    </Member>
    <Member MemberName="DontFragment">
      <MemberSignature Language="C#" Value="public bool DontFragment { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DontFragment" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.DontFragment" />
      <MemberSignature Language="VB.NET" Value="Public Property DontFragment As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool DontFragment { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.DontFragment : bool with get, set" Usage="System.Net.Sockets.Socket.DontFragment" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置 <see cref="T:System.Boolean" /> 值，该值指定 <see cref="T:System.Net.Sockets.Socket" /> 是否允许将 Internet 协议 (IP) 数据报分段。</summary>
        <value>如果 <see cref="T:System.Net.Sockets.Socket" /> 允许数据报分段，则为 <see langword="true" />；否则为 <see langword="false" />。 默认值为 <see langword="true" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果数据报的大小超过传输媒介 (MTU) 的最大传输单位，则需要进行碎片整理。 发送主机可能会将数据报分段 (所有 Internet 协议版本) 或中间路由器 (Internet 协议版本4仅) 。 如果数据报必须分段，并设置该 <xref:System.Net.Sockets.Socket.DontFragment%2A> 选项，则会丢弃数据报，并将 Internet 控制消息协议 (ICMP) 错误消息发送回数据报的发送方。  
  
  (TCP) 套接字对传输控制协议设置此属性将不起作用。  
  
   
  
## Examples  
 下面的代码示例演示属性的用法 <xref:System.Net.Sockets.Socket.DontFragment%2A> 。  
  
 [!code-cpp[SocketPropertyTester#2](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#2)]
 [!code-csharp[SocketPropertyTester#2](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">只有对于在 <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> 或 <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> 族中的套接字，才可以设置此属性。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
      </Docs>
    </Member>
    <Member MemberName="DualMode">
      <MemberSignature Language="C#" Value="public bool DualMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DualMode" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.DualMode" />
      <MemberSignature Language="VB.NET" Value="Public Property DualMode As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool DualMode { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.DualMode : bool with get, set" Usage="System.Net.Sockets.Socket.DualMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个 <see cref="T:System.Boolean" /> 值，该值指定 <see cref="T:System.Net.Sockets.Socket" /> 是否是用于 IPv4 和 IPv6 的双模式套接字。</summary>
        <value>如果 <see cref="T:System.Net.Sockets.Socket" /> 是双模式套接字，则为 <see langword="true" />；否则为 <see langword="false" />。 默认值为 <see langword="false" />。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DuplicateAndClose">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.SocketInformation DuplicateAndClose (int targetProcessId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Net.Sockets.SocketInformation DuplicateAndClose(int32 targetProcessId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.DuplicateAndClose(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function DuplicateAndClose (targetProcessId As Integer) As SocketInformation" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::Sockets::SocketInformation DuplicateAndClose(int targetProcessId);" />
      <MemberSignature Language="F#" Value="member this.DuplicateAndClose : int -&gt; System.Net.Sockets.SocketInformation" Usage="socket.DuplicateAndClose targetProcessId" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.MonoLimitation("We do not support passing sockets across processes, we merely allow this API to pass the socket across AppDomains")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.MonoLimitation("We do not support passing sockets across processes, we merely allow this API to pass the socket across AppDomains")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.SocketInformation</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="targetProcessId" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="targetProcessId">从中创建重复套接字引用的目标进程的 ID。</param>
        <summary>重复目标进程的套接字引用，并关闭此进程的套接字。</summary>
        <returns>要传递到目标进程的套接字引用。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 目标进程应使用 <xref:System.Net.Sockets.Socket.%23ctor%2A> 来创建重复的套接字实例。  
  
 如果多次调用 <xref:System.Net.Sockets.Socket.%23ctor%2A> 构造函数并将同一字节数组作为每次调用的参数，则将创建 <xref:System.Net.Sockets.Socket> 具有相同基础套接字的多个托管实例。 强烈建议您不要这样做。  
  
 如果创建套接字的进程使用 (<xref:System.Net.Sockets.Socket.BeginReceive%2A> 或 <xref:System.Net.Sockets.Socket.BeginSend%2A>) 的异步方法，则进程必须首先将该 <xref:System.Net.Sockets.Socket.UseOnlyOverlappedIO%2A> 属性设置为 true; 否则，套接字将绑定到创建进程的完成端口，这可能会导致 <xref:System.ArgumentNullException> 目标进程引发。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><paramref name="targetProcessID" /> 不是有效的进程 ID。 
- 或 - 
套接字引用的复制失败。</exception>
      </Docs>
    </Member>
    <Member MemberName="EnableBroadcast">
      <MemberSignature Language="C#" Value="public bool EnableBroadcast { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableBroadcast" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.EnableBroadcast" />
      <MemberSignature Language="VB.NET" Value="Public Property EnableBroadcast As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EnableBroadcast { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnableBroadcast : bool with get, set" Usage="System.Net.Sockets.Socket.EnableBroadcast" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个 <see cref="T:System.Boolean" /> 值，该值指定 <see cref="T:System.Net.Sockets.Socket" /> 是否可以发送或接收广播数据包。</summary>
        <value>如果 <see cref="T:System.Net.Sockets.Socket" /> 允许广播数据包，则为 <see langword="true" />；否则为 <see langword="false" />。 默认值为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 广播限制为特定子网，并且必须使用用户数据报协议 (UDP。 ) 对于 Internet 协议版本4，你可以通过将数据包发送到255.255.255.255 来向本地子网广播;或者，你可以使用定向广播地址（Internet 协议的网络部分） (IP) 地址，并在主机部分中设置所有位。 例如，如果你的 IP 地址是 (192.168.1.40，其中的网络部分为255.255.255.0，网络部分是前三个八位字节，主机部分为最后一个八位字节) ，则定向广播地址为192.168.1.255。  
  
  (TCP) 套接字对传输控制协议设置此属性将不起作用。  
  
   
  
## Examples  
 下面的代码示例演示属性的用法 <xref:System.Net.Sockets.Socket.EnableBroadcast%2A> 。  
  
 [!code-cpp[SocketPropertyTester#2](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#2)]
 [!code-csharp[SocketPropertyTester#2](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">此选项仅对数据报套接字有效。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="EndAccept">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>异步接受传入的连接尝试。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="EndAccept">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.Socket EndAccept (out byte[]? buffer, IAsyncResult asyncResult);" FrameworkAlternate="net-5.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.Sockets.Socket EndAccept([out] unsigned int8[]&amp; buffer, class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndAccept (ByRef buffer As Byte(), asyncResult As IAsyncResult) As Socket" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::Sockets::Socket ^ EndAccept([Runtime::InteropServices::Out] cli::array &lt;System::Byte&gt; ^ % buffer, IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="member this.EndAccept : Byte[] * IAsyncResult -&gt; System.Net.Sockets.Socket" Usage="socket.EndAccept (buffer, asyncResult)" />
      <MemberSignature Language="C#" Value="public System.Net.Sockets.Socket EndAccept (out byte[] buffer, IAsyncResult asyncResult);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.Socket</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" RefType="out" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="buffer">包含所传输字节的类型 <see cref="T:System.Byte" /> 的数组。</param>
        <param name="asyncResult"><see cref="T:System.IAsyncResult" /> 对象，它存储此异步操作的状态信息以及任何用户定义数据。</param>
        <summary>异步接受传入的连接尝试，并创建新的 <see cref="T:System.Net.Sockets.Socket" /> 对象来处理远程主机通信。 此方法返回包含所传输的初始数据的缓冲区。</summary>
        <returns>一个 <see cref="T:System.Net.Sockets.Socket" /> 对象，它处理与远程主机的通信。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndAccept%2A> 完成对的调用 <xref:System.Net.Sockets.Socket.BeginAccept%2A> 。 在调用之前 <xref:System.Net.Sockets.Socket.BeginAccept%2A> ，需要创建由委托调用的回调方法 <xref:System.AsyncCallback> 。 此回调方法在单独的线程中执行，并在该方法返回后由系统调用 <xref:System.Net.Sockets.Socket.BeginAccept%2A> 。  
  
 在回调方法中，调用 <xref:System.IAsyncResult.AsyncState%2A> 参数的方法 `asyncResult` 来获取 <xref:System.Net.Sockets.Socket> 正在进行连接尝试的。 获取后 <xref:System.Net.Sockets.Socket> ，可以调用 <xref:System.Net.Sockets.Socket.EndAccept%2A> 方法以成功完成连接尝试。 `buffer`此重载的参数包含在对的调用中接收的数据， <xref:System.Net.Sockets.Socket.BeginAccept%2A> `bytesTransferred` 参数包含在调用中传输的字节数。  
  
 <xref:System.Net.Sockets.Socket.EndAccept%2A>方法会一直阻止，直到传入连接队列中有挂起的连接。 <xref:System.Net.Sockets.Socket.EndAccept%2A>方法接受传入的连接，并返回一个新 <xref:System.Net.Sockets.Socket> 的，它可用于向远程主机发送数据和从远程主机接收数据。  
  
> [!NOTE]
>  如果收到 <xref:System.Net.Sockets.SocketException> ，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。 获取此代码后，请参阅 [Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2) 文档，以获取有关错误的详细说明。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅 [.NET Framework 中的网络跟踪](/dotnet/framework/network-programming/network-tracing)。  
  
   
  
## Examples  
 下面的代码示例使用 <xref:System.Net.Sockets.Socket.BeginAccept%2A> 创建并连接套接字，并接受前10个字节的数据。 回调委托调用 <xref:System.Net.Sockets.Socket.EndAccept%2A> 以结束异步请求。 传输的字节数和数据在 `buffer` 此方法的和参数中返回 `bytesTransferred` ，并显示在控制台上。  
  
 [!code-cpp[NCLSocketEnhancements#6](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#6)]
 [!code-csharp[NCLSocketEnhancements#6](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">此方法需要 Windows NT。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 对象已关闭。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" /> 为空。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="asyncResult" /> 并不是通过对 <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" /> 的调用创建的。</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" /> 方法以前被调用过。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问 <see cref="T:System.Net.Sockets.Socket" /> 时出错</exception>
      </Docs>
    </Member>
    <Member MemberName="EndAccept">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.Socket EndAccept (IAsyncResult asyncResult);" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.Sockets.Socket EndAccept(class System.IAsyncResult asyncResult) cil managed" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndAccept (asyncResult As IAsyncResult) As Socket" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::Sockets::Socket ^ EndAccept(IAsyncResult ^ asyncResult);" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.EndAccept : IAsyncResult -&gt; System.Net.Sockets.Socket" Usage="socket.EndAccept asyncResult" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public System.Net.Sockets.Socket EndAccept (IAsyncResult result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.Sockets.Socket EndAccept(class System.IAsyncResult result) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function EndAccept (result As IAsyncResult) As Socket" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::Sockets::Socket ^ EndAccept(IAsyncResult ^ result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.EndAccept : IAsyncResult -&gt; System.Net.Sockets.Socket" Usage="socket.EndAccept result" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.Socket</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="result" Type="System.IAsyncResult" Index="0" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult"><see cref="T:System.IAsyncResult" />，它存储此异步操作的状态信息以及任何用户定义数据。</param>
        <param name="result"><see cref="T:System.IAsyncResult" />，它存储此异步操作的状态信息以及任何用户定义数据。</param>
        <summary>异步接受传入的连接尝试，并创建新的 <see cref="T:System.Net.Sockets.Socket" /> 来处理远程主机通信。</summary>
        <returns>一个 <see cref="T:System.Net.Sockets.Socket" />，它处理与远程主机的通信。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndAccept%2A> 完成对的调用 <xref:System.Net.Sockets.Socket.BeginAccept%2A> 。 在调用之前 <xref:System.Net.Sockets.Socket.BeginAccept%2A> ，需要创建一个实现委托的回调方法 <xref:System.AsyncCallback> 。 此回调方法在单独的线程中执行，并在该方法返回后由系统调用 <xref:System.Net.Sockets.Socket.BeginAccept%2A> 。 它必须接受 `asyncResult` 从方法返回的参数 <xref:System.Net.Sockets.Socket.BeginAccept%2A> 。  
  
 在回调方法中，调用 <xref:System.IAsyncResult.AsyncState%2A> 参数的方法 `asyncResult` 来获取 <xref:System.Net.Sockets.Socket> 正在进行连接尝试的。 获取后 <xref:System.Net.Sockets.Socket> ，可以调用 <xref:System.Net.Sockets.Socket.EndAccept%2A> 方法以成功完成连接尝试。  
  
 <xref:System.Net.Sockets.Socket.EndAccept%2A>方法会一直阻止，直到传入连接队列中有挂起的连接。 <xref:System.Net.Sockets.Socket.EndAccept%2A>方法接受传入的连接，并返回一个新 <xref:System.Net.Sockets.Socket> 的，它可用于向远程主机发送数据和从远程主机接收数据。  
  
> [!NOTE]
>  如果收到 <xref:System.Net.Sockets.SocketException> ，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。 获取此代码后，请参阅 [Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2) 文档，以获取有关错误的详细说明。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅 [.NET Framework 中的网络跟踪](/dotnet/framework/network-programming/network-tracing)。  
  
   
  
## Examples  
 下面的代码示例结束异步请求，并创建新的 <xref:System.Net.Sockets.Socket> 以接受传入连接请求。 有关演示与套接字的异步通信的完整示例，请参阅 [套接字代码示例](/dotnet/framework/network-programming/socket-code-examples)。  
  
 [!code-cpp[Socket_Async_Send_Receive#7](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#7)]
 [!code-csharp[Socket_Async_Send_Receive#7](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#7)]
 [!code-vb[Socket_Async_Send_Receive#7](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="asyncResult" /> 并不是通过对 <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" /> 的调用创建的。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。 有关详细信息，请参阅备注部分。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" /> 方法以前被调用过。</exception>
        <exception cref="T:System.NotSupportedException">此方法需要 Windows NT。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="P:System.IAsyncResult.AsyncState" />
      </Docs>
    </Member>
    <Member MemberName="EndAccept">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.Socket EndAccept (out byte[]? buffer, out int bytesTransferred, IAsyncResult asyncResult);" FrameworkAlternate="net-5.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.Sockets.Socket EndAccept([out] unsigned int8[]&amp; buffer, [out] int32&amp; bytesTransferred, class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.Int32@,System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndAccept (ByRef buffer As Byte(), ByRef bytesTransferred As Integer, asyncResult As IAsyncResult) As Socket" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::Sockets::Socket ^ EndAccept([Runtime::InteropServices::Out] cli::array &lt;System::Byte&gt; ^ % buffer, [Runtime::InteropServices::Out] int % bytesTransferred, IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="member this.EndAccept : Byte[] * int * IAsyncResult -&gt; System.Net.Sockets.Socket" Usage="socket.EndAccept (buffer, bytesTransferred, asyncResult)" />
      <MemberSignature Language="C#" Value="public System.Net.Sockets.Socket EndAccept (out byte[] buffer, out int bytesTransferred, IAsyncResult asyncResult);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.Socket</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" RefType="out" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="bytesTransferred" Type="System.Int32" RefType="out" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="buffer">包含所传输字节的类型 <see cref="T:System.Byte" /> 的数组。</param>
        <param name="bytesTransferred">已传输的字节数。</param>
        <param name="asyncResult"><see cref="T:System.IAsyncResult" /> 对象，它存储此异步操作的状态信息以及任何用户定义数据。</param>
        <summary>异步接受传入的连接尝试，并创建新的 <see cref="T:System.Net.Sockets.Socket" /> 对象来处理远程主机通信。 此方法返回一个缓冲区，其中包含初始数据和传输的字节数。</summary>
        <returns>一个 <see cref="T:System.Net.Sockets.Socket" /> 对象，它处理与远程主机的通信。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndAccept%2A> 完成对的调用 <xref:System.Net.Sockets.Socket.BeginAccept%2A> 。 在调用之前 <xref:System.Net.Sockets.Socket.BeginAccept%2A> ，需要创建由委托调用的回调方法 <xref:System.AsyncCallback> 。 此回调方法在单独的线程中执行，并在该方法返回后由系统调用 <xref:System.Net.Sockets.Socket.BeginAccept%2A> 。 它必须接受 `asyncResult` 从方法返回的参数 <xref:System.Net.Sockets.Socket.BeginAccept%2A> 。  
  
 在回调方法中，调用 <xref:System.IAsyncResult.AsyncState%2A> 参数的方法 `asyncResult` 来获取 <xref:System.Net.Sockets.Socket> 正在进行连接尝试的。 获取后 <xref:System.Net.Sockets.Socket> ，可以调用 <xref:System.Net.Sockets.Socket.EndAccept%2A> 方法以成功完成连接尝试。 `buffer`此重载的参数包含在对的调用中接收的数据， <xref:System.Net.Sockets.Socket.BeginAccept%2A> `bytesTransferred` 参数包含在调用中传输的字节数。  
  
 <xref:System.Net.Sockets.Socket.EndAccept%2A>方法会一直阻止，直到传入连接队列中有挂起的连接。 <xref:System.Net.Sockets.Socket.EndAccept%2A>方法接受传入的连接，并返回一个新 <xref:System.Net.Sockets.Socket> 的，它可用于向远程主机发送数据和从远程主机接收数据。  
  
> [!NOTE]
>  如果收到 <xref:System.Net.Sockets.SocketException> ，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。 获取此代码后，请参阅 [Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2) 文档，以获取有关错误的详细说明。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅 [.NET Framework 中的网络跟踪](/dotnet/framework/network-programming/network-tracing)。  
  
   
  
## Examples  
 下面的代码示例使用 <xref:System.Net.Sockets.Socket.BeginAccept%2A> 创建并连接套接字，并接受前10个字节的数据。 回调委托调用 <xref:System.Net.Sockets.Socket.EndAccept%2A> 以结束异步请求。 传输的字节数和数据在 `buffer` 此方法的和参数中返回 `bytesTransferred` ，并显示在控制台上。  
  
 [!code-cpp[NCLSocketEnhancements#6](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#6)]
 [!code-csharp[NCLSocketEnhancements#6](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">此方法需要 Windows NT。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 对象已关闭。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" /> 为空。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="asyncResult" /> 并不是通过对 <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" /> 的调用创建的。</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" /> 方法以前被调用过。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问 <see cref="T:System.Net.Sockets.Socket" /> 时出错。</exception>
      </Docs>
    </Member>
    <Member MemberName="EndConnect">
      <MemberSignature Language="C#" Value="public void EndConnect (IAsyncResult asyncResult);" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EndConnect(class System.IAsyncResult asyncResult) cil managed" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndConnect (asyncResult As IAsyncResult)" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EndConnect(IAsyncResult ^ asyncResult);" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.EndConnect : IAsyncResult -&gt; unit" Usage="socket.EndConnect asyncResult" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public void EndConnect (IAsyncResult result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EndConnect(class System.IAsyncResult result) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndConnect (result As IAsyncResult)" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EndConnect(IAsyncResult ^ result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.EndConnect : IAsyncResult -&gt; unit" Usage="socket.EndConnect result" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="result" Type="System.IAsyncResult" Index="0" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult"><see cref="T:System.IAsyncResult" />，它存储此异步操作的状态信息以及所有用户定义的数据。</param>
        <param name="result"><see cref="T:System.IAsyncResult" />，它存储此异步操作的状态信息以及所有用户定义的数据。</param>
        <summary>结束挂起的异步连接请求。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndConnect%2A> 是一个阻止方法，用于完成方法中启动的异步远程主机连接请求 <xref:System.Net.Sockets.Socket.BeginConnect%2A> 。  
  
 在调用之前 <xref:System.Net.Sockets.Socket.BeginConnect%2A> ，需要创建一个实现委托的回调方法 <xref:System.AsyncCallback> 。 此回调方法在单独的线程中执行，并在返回后由系统调用 <xref:System.Net.Sockets.Socket.BeginConnect%2A> 。 回调方法必须接受 <xref:System.IAsyncResult> 方法返回的 <xref:System.Net.Sockets.Socket.BeginConnect%2A> 作为参数。  
  
 在回调方法中，调用 <xref:System.IAsyncResult.AsyncState%2A> 参数的方法 <xref:System.IAsyncResult> 来获取 <xref:System.Net.Sockets.Socket> 正在进行连接尝试的。 获取后 <xref:System.Net.Sockets.Socket> ，可以调用 <xref:System.Net.Sockets.Socket.EndConnect%2A> 方法以成功完成连接尝试。  
  
> [!NOTE]
>  如果收到 <xref:System.Net.Sockets.SocketException> ，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。 获取此代码后，请参阅 [Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2) 文档，以获取有关错误的详细说明。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅 [.NET Framework 中的网络跟踪](/dotnet/framework/network-programming/network-tracing)。  
  
   
  
## Examples  
 下面的代码示例结束了异步连接尝试。 有关演示与套接字的异步通信的完整示例，请参阅 [套接字代码示例](/dotnet/framework/network-programming/socket-code-examples)。  
  
 [!code-cpp[Socket_Async_Send_Receive#5](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#5)]
 [!code-csharp[Socket_Async_Send_Receive#5](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#5)]
 [!code-vb[Socket_Async_Send_Receive#5](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">对 <see cref="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)" /> 方法的调用未返回 <paramref name="asyncResult" />。</exception>
        <exception cref="T:System.InvalidOperationException">先前曾为异步连接调用过 <see cref="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)" />。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="P:System.IAsyncResult.AsyncState" />
      </Docs>
    </Member>
    <Member MemberName="EndDisconnect">
      <MemberSignature Language="C#" Value="public void EndDisconnect (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EndDisconnect(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndDisconnect(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndDisconnect (asyncResult As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EndDisconnect(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="member this.EndDisconnect : IAsyncResult -&gt; unit" Usage="socket.EndDisconnect asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult"><see cref="T:System.IAsyncResult" /> 对象，它存储此异步操作的状态信息以及所有用户定义数据。</param>
        <summary>结束挂起的异步断开连接请求。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndDisconnect%2A> 完成对的调用 <xref:System.Net.Sockets.Socket.BeginDisconnect%2A> 。 <xref:System.Net.Sockets.Socket.EndDisconnect%2A>直到断开连接完成后，方法才会阻止。 有关异步操作的详细信息，请参阅 MSDN library 中的异步编程概述主题。  
  
> [!NOTE]
>  如果收到 <xref:System.Net.Sockets.SocketException> ，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。 获取此代码后，请参阅 [Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2) 文档，以获取有关错误的详细说明。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅 [.NET Framework 中的网络跟踪](/dotnet/framework/network-programming/network-tracing)。  
  
   
  
## Examples  
 下面的代码示例为异步通信创建套接字，并将一些数据发送到远程主机。 发送数据时， <xref:System.Net.Sockets.Socket.Shutdown%2A> 将调用以停止发送和接收活动。 然后 <xref:System.Net.Sockets.Socket.BeginDisconnect%2A> 调用以开始断开连接请求。 回调委托调用 <xref:System.Net.Sockets.Socket.EndDisconnect%2A> 以结束异步请求。 请求完成后，将 <xref:System.Net.Sockets.Socket.Connected%2A> 查询属性以测试套接字是否已断开连接。  
  
 [!code-cpp[Nclsocketenhancements#11](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#11)]
 [!code-csharp[Nclsocketenhancements#11](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 对象已关闭。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">对 <see cref="M:System.Net.Sockets.Socket.BeginDisconnect(System.Boolean,System.AsyncCallback,System.Object)" /> 方法的调用未返回 <paramref name="asyncResult" />。</exception>
        <exception cref="T:System.InvalidOperationException">先前曾为异步连接调用过 <see cref="M:System.Net.Sockets.Socket.EndDisconnect(System.IAsyncResult)" />。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.Net.WebException">断开连接请求已超时。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="EndReceive">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>结束挂起的异步读取。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="EndReceive">
      <MemberSignature Language="C#" Value="public int EndReceive (IAsyncResult asyncResult);" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndReceive(class System.IAsyncResult asyncResult) cil managed" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReceive (asyncResult As IAsyncResult) As Integer" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndReceive(IAsyncResult ^ asyncResult);" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.EndReceive : IAsyncResult -&gt; int" Usage="socket.EndReceive asyncResult" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public int EndReceive (IAsyncResult result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndReceive(class System.IAsyncResult result) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReceive (result As IAsyncResult) As Integer" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndReceive(IAsyncResult ^ result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.EndReceive : IAsyncResult -&gt; int" Usage="socket.EndReceive result" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="result" Type="System.IAsyncResult" Index="0" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult"><see cref="T:System.IAsyncResult" />，它存储此异步操作的状态信息以及所有用户定义的数据。</param>
        <param name="result"><see cref="T:System.IAsyncResult" />，它存储此异步操作的状态信息以及所有用户定义的数据。</param>
        <summary>结束挂起的异步读取。</summary>
        <returns>收到的字节数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndReceive%2A>方法完成方法中启动的异步读取操作 <xref:System.Net.Sockets.Socket.BeginReceive%2A> 。  
  
 在调用之前 <xref:System.Net.Sockets.Socket.BeginReceive%2A> ，需要创建一个实现委托的回调方法 <xref:System.AsyncCallback> 。 此回调方法在单独的线程中执行，并在返回后由系统调用 <xref:System.Net.Sockets.Socket.BeginReceive%2A> 。 回调方法必须接受 <xref:System.IAsyncResult> 方法返回的 <xref:System.Net.Sockets.Socket.BeginReceive%2A> 作为参数。  
  
 在回调方法中调用 <xref:System.IAsyncResult.AsyncState%2A> 的方法， <xref:System.IAsyncResult> 以获取传递给方法的状态对象 <xref:System.Net.Sockets.Socket.BeginReceive%2A> 。 <xref:System.Net.Sockets.Socket>从此状态对象提取接收。 获取后 <xref:System.Net.Sockets.Socket> ，可以调用 <xref:System.Net.Sockets.Socket.EndReceive%2A> 方法来成功完成读取操作并返回读取的字节数。  
  
 在 <xref:System.Net.Sockets.Socket.EndReceive%2A> 数据可用之前，将阻止该方法。 如果使用的是无连接协议， <xref:System.Net.Sockets.Socket.EndReceive%2A> 将读取传入网络缓冲区中的第一个排队数据报。 如果使用面向连接的协议，则该 <xref:System.Net.Sockets.Socket.EndReceive%2A> 方法将读取尽可能多的数据，最多可达在方法的参数中指定的字节数 `size` <xref:System.Net.Sockets.Socket.BeginReceive%2A> 。 如果远程主机 <xref:System.Net.Sockets.Socket> 使用方法关闭连接 <xref:System.Net.Sockets.Socket.Shutdown%2A> 并且收到所有可用数据，则该 <xref:System.Net.Sockets.Socket.EndReceive%2A> 方法将立即完成并返回零字节。  
  
 若要获取收到的数据，请调用 <xref:System.IAsyncResult.AsyncState%2A> 的方法 <xref:System.IAsyncResult> ，并提取生成的状态对象中包含的缓冲区。  
  
 若要取消挂起的 <xref:System.Net.Sockets.Socket.BeginReceive%2A> ，请调用 <xref:System.Net.Sockets.Socket.Close%2A> 方法。  
  
> [!NOTE]
>  如果收到 <xref:System.Net.Sockets.SocketException> ，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。 获取此代码后，请参阅 [Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2) 文档，以获取有关错误的详细说明。  
  
> [!NOTE]
>  给定线程启动的所有 i/o 都将在该线程退出时取消。 如果线程在操作完成之前退出，则挂起的异步操作可能会失败。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅 [.NET Framework 中的网络跟踪](/dotnet/framework/network-programming/network-tracing)。  
  
   
  
## Examples  
 下面的代码示例结束挂起的异步读取。 有关演示与套接字的异步通信的完整示例，请参阅 [套接字代码示例](/dotnet/framework/network-programming/socket-code-examples)。  
  
 [!code-cpp[Socket_Async_Send_Receive#8](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#8)]
 [!code-csharp[Socket_Async_Send_Receive#8](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#8)]
 [!code-vb[Socket_Async_Send_Receive#8](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">对 <see cref="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" /> 方法的调用未返回 <paramref name="asyncResult" />。</exception>
        <exception cref="T:System.InvalidOperationException">先前曾为异步读取调用过 <see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" />。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="T:System.IAsyncResult" />
        <altmember cref="P:System.IAsyncResult.AsyncState" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
      </Docs>
    </Member>
    <Member MemberName="EndReceive">
      <MemberSignature Language="C#" Value="public int EndReceive (IAsyncResult asyncResult, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndReceive(class System.IAsyncResult asyncResult, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReceive (asyncResult As IAsyncResult, ByRef errorCode As SocketError) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndReceive(IAsyncResult ^ asyncResult, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberSignature Language="F#" Value="member this.EndReceive : IAsyncResult * SocketError -&gt; int" Usage="socket.EndReceive (asyncResult, errorCode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult"><see cref="T:System.IAsyncResult" />，它存储此异步操作的状态信息以及所有用户定义的数据。</param>
        <param name="errorCode">一个 <see cref="T:System.Net.Sockets.SocketError" /> 对象，它存储套接字错误。</param>
        <summary>结束挂起的异步读取。</summary>
        <returns>收到的字节数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndReceive%2A>方法完成方法中启动的异步读取操作 <xref:System.Net.Sockets.Socket.BeginReceive%2A> 。  
  
 在调用之前 <xref:System.Net.Sockets.Socket.BeginReceive%2A> ，需要创建一个实现委托的回调方法 <xref:System.AsyncCallback> 。 此回调方法在单独的线程中执行，并在返回后由系统调用 <xref:System.Net.Sockets.Socket.BeginReceive%2A> 。 回调方法必须接受 <xref:System.IAsyncResult> 方法返回的 <xref:System.Net.Sockets.Socket.BeginReceive%2A> 作为参数。  
  
 在回调方法中调用 <xref:System.IAsyncResult.AsyncState%2A> 的方法， <xref:System.IAsyncResult> 以获取传递给方法的状态对象 <xref:System.Net.Sockets.Socket.BeginReceive%2A> 。 <xref:System.Net.Sockets.Socket>从此状态对象提取接收。 获取后 <xref:System.Net.Sockets.Socket> ，可以调用 <xref:System.Net.Sockets.Socket.EndReceive%2A> 方法来成功完成读取操作并返回读取的字节数。  
  
 在 <xref:System.Net.Sockets.Socket.EndReceive%2A> 数据可用之前，将阻止该方法。 如果使用的是无连接协议， <xref:System.Net.Sockets.Socket.EndReceive%2A> 将读取传入网络缓冲区中的第一个排队数据报。 如果使用面向连接的协议，则该 <xref:System.Net.Sockets.Socket.EndReceive%2A> 方法将读取尽可能多的数据，最多可达在方法的参数中指定的字节数 `size` <xref:System.Net.Sockets.Socket.BeginReceive%2A> 。 如果远程主机 <xref:System.Net.Sockets.Socket> 使用方法关闭连接 <xref:System.Net.Sockets.Socket.Shutdown%2A> 并且收到所有可用数据，则该 <xref:System.Net.Sockets.Socket.EndReceive%2A> 方法将立即完成并返回零字节。  
  
 若要获取收到的数据，请调用 <xref:System.IAsyncResult.AsyncState%2A> 的方法 <xref:System.IAsyncResult> ，并提取生成的状态对象中包含的缓冲区。  
  
> [!NOTE]
>  如果收到 <xref:System.Net.Sockets.SocketException> ，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。 获取此代码后，请参阅 [Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2) 文档，以获取有关错误的详细说明。  
  
> [!NOTE]
>  给定线程启动的所有 i/o 都将在该线程退出时取消。 如果线程在操作完成之前退出，则挂起的异步操作可能会失败。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅 [.NET Framework 中的网络跟踪](/dotnet/framework/network-programming/network-tracing)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">对 <see cref="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" /> 方法的调用未返回 <paramref name="asyncResult" />。</exception>
        <exception cref="T:System.InvalidOperationException">先前曾为异步读取调用过 <see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" />。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="T:System.IAsyncResult" />
        <altmember cref="P:System.IAsyncResult.AsyncState" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
      </Docs>
    </Member>
    <Member MemberName="EndReceiveFrom">
      <MemberSignature Language="C#" Value="public int EndReceiveFrom (IAsyncResult asyncResult, ref System.Net.EndPoint endPoint);" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndReceiveFrom(class System.IAsyncResult asyncResult, class System.Net.EndPoint&amp; endPoint) cil managed" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReceiveFrom (asyncResult As IAsyncResult, ByRef endPoint As EndPoint) As Integer" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndReceiveFrom(IAsyncResult ^ asyncResult, System::Net::EndPoint ^ % endPoint);" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.EndReceiveFrom : IAsyncResult * EndPoint -&gt; int" Usage="socket.EndReceiveFrom (asyncResult, endPoint)" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public int EndReceiveFrom (IAsyncResult result, ref System.Net.EndPoint end_point);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndReceiveFrom(class System.IAsyncResult result, class System.Net.EndPoint&amp; end_point) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReceiveFrom (result As IAsyncResult, ByRef end_point As EndPoint) As Integer" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndReceiveFrom(IAsyncResult ^ result, System::Net::EndPoint ^ % end_point);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.EndReceiveFrom : IAsyncResult * EndPoint -&gt; int" Usage="socket.EndReceiveFrom (result, end_point)" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="result" Type="System.IAsyncResult" Index="0" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="endPoint" Type="System.Net.EndPoint" RefType="ref" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="end_point" Type="System.Net.EndPoint" RefType="ref" Index="1" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult"><see cref="T:System.IAsyncResult" />，它存储此异步操作的状态信息以及所有用户定义的数据。</param>
        <param name="result"><see cref="T:System.IAsyncResult" />，它存储此异步操作的状态信息以及所有用户定义的数据。</param>
        <param name="endPoint">源 <see cref="T:System.Net.EndPoint" />。</param>
        <param name="end_point">源 <see cref="T:System.Net.EndPoint" />。</param>
        <summary>结束挂起的、从特定终结点进行异步读取。</summary>
        <returns>如果成功，则返回已接收的字节数。 如果不成功，则返回 0。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A>方法完成方法中启动的异步读取操作 <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> 。  
  
 在调用之前 <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> ，需要创建一个实现委托的回调方法 <xref:System.AsyncCallback> 。 此回调方法在单独的线程中执行，并在返回后由系统调用 <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> 。 回调方法必须接受 <xref:System.IAsyncResult> 方法返回的 <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> 作为参数。  
  
 在回调方法中调用 <xref:System.IAsyncResult.AsyncState%2A> 的方法， <xref:System.IAsyncResult> 以获取传递给方法的状态对象 <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> 。 <xref:System.Net.Sockets.Socket>从此状态对象提取接收。 获取后 <xref:System.Net.Sockets.Socket> ，可以调用 <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> 方法来成功完成读取操作并返回读取的字节数。  
  
 在 <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> 数据可用之前，将阻止该方法。 如果使用的是无连接协议， <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> 将读取传入网络缓冲区中的第一个排队数据报。 如果使用面向连接的协议，则该 <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> 方法将读取尽可能多的数据，最多可达在方法的参数中指定的字节数 `size` <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> 。 如果远程主机 <xref:System.Net.Sockets.Socket> 使用方法关闭连接 <xref:System.Net.Sockets.Socket.Shutdown%2A> 并且收到所有可用数据，则该 <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> 方法将立即完成并返回零字节。 若要获取接收的数据，请调用 <xref:System.IAsyncResult.AsyncState%2A> 对象的方法 <xref:System.IAsyncResult> ，并提取生成的状态对象中包含的缓冲区。 若要标识源主机，请提取 <xref:System.Net.EndPoint> 并将其转换为 <xref:System.Net.IPEndPoint> 。 使用 <xref:System.Net.IPEndPoint.Address%2A?displayProperty=nameWithType> 方法可获取 IP 地址和 <xref:System.Net.IPEndPoint.Port%2A?displayProperty=nameWithType> 方法以获取端口号。  
  
> [!NOTE]
>  如果收到 <xref:System.Net.Sockets.SocketException> ，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。 获取此代码后，请参阅 [Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2) 文档，以获取有关错误的详细说明。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅 [.NET Framework 中的网络跟踪](/dotnet/framework/network-programming/network-tracing)。  
  
   
  
## Examples  
 下面的代码示例结束了从特定的挂起的异步读取 <xref:System.Net.EndPoint> 。  
  
 [!code-cpp[Socket_Async_Send_Receive#10](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#10)]
 [!code-csharp[Socket_Async_Send_Receive#10](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#10)]
 [!code-vb[Socket_Async_Send_Receive#10](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">对 <see cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" /> 方法的调用未返回 <paramref name="asyncResult" />。</exception>
        <exception cref="T:System.InvalidOperationException">先前曾为异步读取调用过 <see cref="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)" />。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
      </Docs>
    </Member>
    <Member MemberName="EndReceiveMessageFrom">
      <MemberSignature Language="C#" Value="public int EndReceiveMessageFrom (IAsyncResult asyncResult, ref System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint endPoint, out System.Net.Sockets.IPPacketInformation ipPacketInformation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndReceiveMessageFrom(class System.IAsyncResult asyncResult, valuetype System.Net.Sockets.SocketFlags&amp; socketFlags, class System.Net.EndPoint&amp; endPoint, [out] valuetype System.Net.Sockets.IPPacketInformation&amp; ipPacketInformation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndReceiveMessageFrom(System.IAsyncResult,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReceiveMessageFrom (asyncResult As IAsyncResult, ByRef socketFlags As SocketFlags, ByRef endPoint As EndPoint, ByRef ipPacketInformation As IPPacketInformation) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndReceiveMessageFrom(IAsyncResult ^ asyncResult, System::Net::Sockets::SocketFlags % socketFlags, System::Net::EndPoint ^ % endPoint, [Runtime::InteropServices::Out] System::Net::Sockets::IPPacketInformation % ipPacketInformation);" />
      <MemberSignature Language="F#" Value="member this.EndReceiveMessageFrom : IAsyncResult * SocketFlags * EndPoint * IPPacketInformation -&gt; int" Usage="socket.EndReceiveMessageFrom (asyncResult, socketFlags, endPoint, ipPacketInformation)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.MonoTODO]</AttributeName>
          <AttributeName Language="F#">[&lt;System.MonoTODO&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" RefType="ref" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="endPoint" Type="System.Net.EndPoint" RefType="ref" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="ipPacketInformation" Type="System.Net.Sockets.IPPacketInformation" RefType="out" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult"><see cref="T:System.IAsyncResult" />，它存储此异步操作的状态信息以及所有用户定义的数据。</param>
        <param name="socketFlags">所接收数据包的 <see cref="T:System.Net.Sockets.SocketFlags" /> 值的按位组合。</param>
        <param name="endPoint">源 <see cref="T:System.Net.EndPoint" />。</param>
        <param name="ipPacketInformation">所接收数据包的 <see cref="T:System.Net.IPAddress" /> 和接口。</param>
        <summary>结束挂起的、从特定终结点进行异步读取。 此方法还显示有关数据包而不是 <see cref="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)" /> 的更多信息。</summary>
        <returns>如果成功，则返回已接收的字节数。 如果不成功，则返回 0。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果操作尚未完成，则此方法将一直阻止到该操作。  
  
 若要同步执行此操作，请使用 <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> 方法。  
  
 检查 `ipPacketInformation` 是否需要了解使用单播、多播或广播地址发送的数据报。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" /> 为 <see langword="null" />  
  
- 或 - 
 <paramref name="endPoint" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">对 <see cref="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" /> 方法的调用未返回 <paramref name="asyncResult" />。</exception>
        <exception cref="T:System.InvalidOperationException">先前曾为异步读取调用过 <see cref="M:System.Net.Sockets.Socket.EndReceiveMessageFrom(System.IAsyncResult,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)" />。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="EndSend">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>结束挂起的异步发送。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="EndSend">
      <MemberSignature Language="C#" Value="public int EndSend (IAsyncResult asyncResult);" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndSend(class System.IAsyncResult asyncResult) cil managed" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndSend (asyncResult As IAsyncResult) As Integer" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndSend(IAsyncResult ^ asyncResult);" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.EndSend : IAsyncResult -&gt; int" Usage="socket.EndSend asyncResult" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public int EndSend (IAsyncResult result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndSend(class System.IAsyncResult result) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function EndSend (result As IAsyncResult) As Integer" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndSend(IAsyncResult ^ result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.EndSend : IAsyncResult -&gt; int" Usage="socket.EndSend result" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="result" Type="System.IAsyncResult" Index="0" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult"><see cref="T:System.IAsyncResult" />，它存储此异步操作的状态信息。</param>
        <param name="result"><see cref="T:System.IAsyncResult" />，它存储此异步操作的状态信息。</param>
        <summary>结束挂起的异步发送。</summary>
        <returns>如果成功，则将返回向 <see cref="T:System.Net.Sockets.Socket" /> 发送的字节数；否则会返回无效 <see cref="T:System.Net.Sockets.Socket" /> 错误。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndSend%2A> 完成在中启动的异步发送操作 <xref:System.Net.Sockets.Socket.BeginSend%2A> 。  
  
 在调用之前 <xref:System.Net.Sockets.Socket.BeginSend%2A> ，需要创建一个实现委托的回调方法 <xref:System.AsyncCallback> 。 此回调方法在单独的线程中执行，并在返回后由系统调用 <xref:System.Net.Sockets.Socket.BeginSend%2A> 。 回调方法必须接受 <xref:System.IAsyncResult> 方法返回的 <xref:System.Net.Sockets.Socket.BeginSend%2A> 作为参数。  
  
 在回调方法中，调用 <xref:System.IAsyncResult.AsyncState%2A> 参数的方法 <xref:System.IAsyncResult> 以获取发送 <xref:System.Net.Sockets.Socket> 。 获取后 <xref:System.Net.Sockets.Socket> ，可以调用 <xref:System.Net.Sockets.Socket.EndSend%2A> 方法来成功完成发送操作，并返回发送的字节数。  
  
 如果使用的是无连接协议，则 <xref:System.Net.Sockets.Socket.EndSend%2A> 在发送数据报之前将一直阻止。 如果使用面向连接的协议， <xref:System.Net.Sockets.Socket.EndSend%2A> 则会一直阻止，直到发送了某些缓冲区。 如果的返回值 <xref:System.Net.Sockets.Socket.EndSend%2A> 指示未完全发送缓冲区，则再次调用该 <xref:System.Net.Sockets.Socket.BeginSend%2A> 方法，同时修改缓冲区以保存未发送的数据。  
  
 不能保证发送的数据会立即显示在网络上。 为了提高网络效率，基础系统可能会延迟传输，直到收集大量传出数据。 此方法成功完成 <xref:System.Net.Sockets.Socket.BeginSend%2A> 意味着基础系统具有空间来缓冲用于网络发送的数据。  
  
> [!NOTE]
>  如果收到 <xref:System.Net.Sockets.SocketException> ，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。 获取此代码后，请参阅 [Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2) 文档，以获取有关错误的详细说明。  
  
> [!NOTE]
>  给定线程启动的所有 i/o 都将在该线程退出时取消。 如果线程在操作完成之前退出，则挂起的异步操作可能会失败。  
  
> [!NOTE]
>  成功完成发送并不表示数据已成功传递。 如果传输系统中没有可用于保存要传输的数据的缓冲区空间，则发送将会阻止，除非已将套接字置于非阻止模式。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅 [.NET Framework 中的网络跟踪](/dotnet/framework/network-programming/network-tracing)。  
  
   
  
## Examples  
 下面的代码示例结束挂起的异步发送。  
  
 [!code-cpp[Socket_Async_Send_Receive#6](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#6)]
 [!code-csharp[Socket_Async_Send_Receive#6](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#6)]
 [!code-vb[Socket_Async_Send_Receive#6](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">对 <see cref="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" /> 方法的调用未返回 <paramref name="asyncResult" />。</exception>
        <exception cref="T:System.InvalidOperationException">先前为异步发送已调用过 <see cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" />。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="P:System.IAsyncResult.AsyncState" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="F:System.Net.Sockets.SocketOptionName.NoDelay" />
      </Docs>
    </Member>
    <Member MemberName="EndSend">
      <MemberSignature Language="C#" Value="public int EndSend (IAsyncResult asyncResult, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndSend(class System.IAsyncResult asyncResult, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndSend (asyncResult As IAsyncResult, ByRef errorCode As SocketError) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndSend(IAsyncResult ^ asyncResult, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberSignature Language="F#" Value="member this.EndSend : IAsyncResult * SocketError -&gt; int" Usage="socket.EndSend (asyncResult, errorCode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult"><see cref="T:System.IAsyncResult" />，它存储此异步操作的状态信息。</param>
        <param name="errorCode">一个 <see cref="T:System.Net.Sockets.SocketError" /> 对象，它存储套接字错误。</param>
        <summary>结束挂起的异步发送。</summary>
        <returns>如果成功，则将返回向 <see cref="T:System.Net.Sockets.Socket" /> 发送的字节数；否则会返回无效 <see cref="T:System.Net.Sockets.Socket" /> 错误。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndSend%2A> 完成在中启动的异步发送操作 <xref:System.Net.Sockets.Socket.BeginSend%2A> 。  
  
 在调用之前 <xref:System.Net.Sockets.Socket.BeginSend%2A> ，需要创建一个实现委托的回调方法 <xref:System.AsyncCallback> 。 此回调方法在单独的线程中执行，并在返回后由系统调用 <xref:System.Net.Sockets.Socket.BeginSend%2A> 。 回调方法必须接受 <xref:System.IAsyncResult> 方法返回的 <xref:System.Net.Sockets.Socket.BeginSend%2A> 作为参数。  
  
 在回调方法中，调用 <xref:System.IAsyncResult.AsyncState%2A> 参数的方法 <xref:System.IAsyncResult> 以获取发送 <xref:System.Net.Sockets.Socket> 。 获取后 <xref:System.Net.Sockets.Socket> ，可以调用 <xref:System.Net.Sockets.Socket.EndSend%2A> 方法来成功完成发送操作，并返回发送的字节数。  
  
 如果使用的是无连接协议，则 <xref:System.Net.Sockets.Socket.EndSend%2A> 在发送数据报之前将一直阻止。 如果使用面向连接的协议， <xref:System.Net.Sockets.Socket.EndSend%2A> 则会一直阻止，直到发送了某些缓冲区。 如果的返回值 <xref:System.Net.Sockets.Socket.EndSend%2A> 指示未完全发送缓冲区，则再次调用该 <xref:System.Net.Sockets.Socket.BeginSend%2A> 方法，同时修改缓冲区以保存未发送的数据。  
  
 不能保证发送的数据会立即显示在网络上。 为了提高网络效率，基础系统可能会延迟传输，直到收集大量传出数据。 此方法成功完成 <xref:System.Net.Sockets.Socket.BeginSend%2A> 意味着基础系统具有空间来缓冲用于网络发送的数据。  
  
> [!NOTE]
>  如果收到 <xref:System.Net.Sockets.SocketException> ，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。 获取此代码后，请参阅 [Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2) 文档，以获取有关错误的详细说明。  
  
> [!NOTE]
>  给定线程启动的所有 i/o 都将在该线程退出时取消。 如果线程在操作完成之前退出，则挂起的异步操作可能会失败。  
  
> [!NOTE]
>  成功完成发送并不表示数据已成功传递。 如果传输系统中没有可用于保存要传输的数据的缓冲区空间，则发送将会阻止，除非已将套接字置于非阻止模式。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅 [.NET Framework 中的网络跟踪](/dotnet/framework/network-programming/network-tracing)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">对 <see cref="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" /> 方法的调用未返回 <paramref name="asyncResult" />。</exception>
        <exception cref="T:System.InvalidOperationException">先前为异步发送已调用过 <see cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" />。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="P:System.IAsyncResult.AsyncState" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="F:System.Net.Sockets.SocketOptionName.NoDelay" />
      </Docs>
    </Member>
    <Member MemberName="EndSendFile">
      <MemberSignature Language="C#" Value="public void EndSendFile (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EndSendFile(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndSendFile(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndSendFile (asyncResult As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EndSendFile(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="member this.EndSendFile : IAsyncResult -&gt; unit" Usage="socket.EndSendFile asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult"><see cref="T:System.IAsyncResult" /> 对象，它存储此异步操作的状态信息。</param>
        <summary>结束文件的挂起异步发送。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndSendFile%2A> 完成在中启动的异步发送操作 <xref:System.Net.Sockets.Socket.BeginSendFile%2A> 。  
  
 在调用之前 <xref:System.Net.Sockets.Socket.BeginSendFile%2A> ，必须创建实现委托的回调方法 <xref:System.AsyncCallback> 。 此回调方法在单独的线程中执行，并在返回后由系统调用 <xref:System.Net.Sockets.Socket.BeginSendFile%2A> 。 回调方法必须接受 <xref:System.IAsyncResult> 由方法返回的对象 <xref:System.Net.Sockets.Socket.BeginSendFile%2A> 作为参数。  
  
 在回调方法中，调用 <xref:System.IAsyncResult.AsyncState%2A> 参数的方法 <xref:System.IAsyncResult> 以获取发送 <xref:System.Net.Sockets.Socket> 。 获取后 <xref:System.Net.Sockets.Socket> ，可以调用 <xref:System.Net.Sockets.Socket.EndSendFile%2A> 方法来成功完成发送操作。  
  
 如果使用的是无连接协议，则在 <xref:System.Net.Sockets.Socket.EndSendFile%2A> 发送数据报之前阻止。 如果你使用的是面向连接的协议，则会 <xref:System.Net.Sockets.Socket.EndSendFile%2A> 阻止，直到发送整个文件。 不能保证发送的数据会立即显示在网络上。 为了提高网络效率，基础系统可能会延迟传输，直到收集大量传出数据。 此方法成功完成 <xref:System.Net.Sockets.Socket.BeginSendFile%2A> 意味着基础系统具有空间来缓冲用于网络发送的数据。  
  
> [!NOTE]
>  如果收到 <xref:System.Net.Sockets.SocketException> ，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。 获取此代码后，请参阅 [Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2) 文档，以获取有关错误的详细说明。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅 [.NET Framework 中的网络跟踪](/dotnet/framework/network-programming/network-tracing)。  
  
   
  
## Examples  
 下面的代码示例创建并连接套接字用于异步通信，并开始将文件 "text.txt" 异步发送到远程主机。 回调委托调用 <xref:System.Net.Sockets.Socket.EndSendFile%2A> 来完成传输。  
  
 [!code-cpp[NCLSocketEnhancements#9](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#9)]
 [!code-csharp[NCLSocketEnhancements#9](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">此方法需要 Windows NT。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 对象已关闭。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" /> 为空。</exception>
        <exception cref="T:System.ArgumentException">对 <see cref="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)" /> 方法的调用未返回 <paramref name="asyncResult" />。</exception>
        <exception cref="T:System.InvalidOperationException">先前曾为异步 <see cref="M:System.Net.Sockets.Socket.EndSendFile(System.IAsyncResult)" /> 调用过 <see cref="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)" />。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。 请参见下面的备注部分。</exception>
      </Docs>
    </Member>
    <Member MemberName="EndSendTo">
      <MemberSignature Language="C#" Value="public int EndSendTo (IAsyncResult asyncResult);" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndSendTo(class System.IAsyncResult asyncResult) cil managed" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndSendTo (asyncResult As IAsyncResult) As Integer" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndSendTo(IAsyncResult ^ asyncResult);" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.EndSendTo : IAsyncResult -&gt; int" Usage="socket.EndSendTo asyncResult" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public int EndSendTo (IAsyncResult result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndSendTo(class System.IAsyncResult result) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function EndSendTo (result As IAsyncResult) As Integer" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndSendTo(IAsyncResult ^ result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.EndSendTo : IAsyncResult -&gt; int" Usage="socket.EndSendTo result" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="result" Type="System.IAsyncResult" Index="0" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult"><see cref="T:System.IAsyncResult" />，它存储此异步操作的状态信息以及所有用户定义的数据。</param>
        <param name="result"><see cref="T:System.IAsyncResult" />，它存储此异步操作的状态信息以及所有用户定义的数据。</param>
        <summary>结束挂起的、向指定位置进行的异步发送。</summary>
        <returns>如果成功，则返回已发送的字节数；否则会返回无效 <see cref="T:System.Net.Sockets.Socket" /> 错误。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndSendTo%2A> 完成在中启动的异步发送操作 <xref:System.Net.Sockets.Socket.BeginSendTo%2A> 。  
  
 在调用之前 <xref:System.Net.Sockets.Socket.BeginSendTo%2A> ，需要创建一个实现委托的回调方法 <xref:System.AsyncCallback> 。 此回调方法在单独的线程中执行，并在返回后由系统调用 <xref:System.Net.Sockets.Socket.BeginReceive%2A> 。 回调方法必须接受 <xref:System.IAsyncResult> 方法返回的 <xref:System.Net.Sockets.Socket.BeginSendTo%2A> 作为参数。  
  
 在回调方法中，调用 <xref:System.IAsyncResult.AsyncState%2A> 参数的方法 <xref:System.IAsyncResult> 以获取发送 <xref:System.Net.Sockets.Socket> 。 获取后 <xref:System.Net.Sockets.Socket> ，可以调用 <xref:System.Net.Sockets.Socket.EndSendTo%2A> 方法来成功完成发送操作，并返回发送的字节数。  
  
 如果使用的是无连接协议，则 <xref:System.Net.Sockets.Socket.EndSendTo%2A> 在发送数据报之前将一直阻止。 如果使用面向连接的协议， <xref:System.Net.Sockets.Socket.EndSendTo%2A> 则会一直阻止，直到发送请求的字节数。 不能保证发送的数据会立即显示在网络上。 为了提高网络效率，基础系统可能会延迟传输，直到收集大量传出数据。 此方法成功完成 <xref:System.Net.Sockets.Socket.BeginSendTo%2A> 意味着基础系统具有空间来缓冲用于网络发送的数据。  
  
> [!NOTE]
>  如果收到 <xref:System.Net.Sockets.SocketException> ，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。 获取此代码后，请参阅 [Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2) 文档，以获取有关错误的详细说明。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅 [.NET Framework 中的网络跟踪](/dotnet/framework/network-programming/network-tracing)。  
  
   
  
## Examples  
 下面的代码示例结束了到特定位置的异步发送。  
  
 [!code-cpp[Socket_Async_Send_Receive#9](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#9)]
 [!code-csharp[Socket_Async_Send_Receive#9](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#9)]
 [!code-vb[Socket_Async_Send_Receive#9](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">对 <see cref="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)" /> 方法的调用未返回 <paramref name="asyncResult" />。</exception>
        <exception cref="T:System.InvalidOperationException">先前为异步发送已调用过 <see cref="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)" />。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
      </Docs>
    </Member>
    <Member MemberName="ExclusiveAddressUse">
      <MemberSignature Language="C#" Value="public bool ExclusiveAddressUse { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ExclusiveAddressUse" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.ExclusiveAddressUse" />
      <MemberSignature Language="VB.NET" Value="Public Property ExclusiveAddressUse As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ExclusiveAddressUse { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ExclusiveAddressUse : bool with get, set" Usage="System.Net.Sockets.Socket.ExclusiveAddressUse" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置 <see cref="T:System.Boolean" /> 值，该值指定 <see cref="T:System.Net.Sockets.Socket" /> 是否仅允许一个进程绑定到端口。</summary>
        <value>如果 <see cref="T:System.Net.Sockets.Socket" /> 仅允许一个套接字绑定到特定端口，则为 <see langword="true" />；否则为 <see langword="false" />。 <see langword="true" />对于 Windows Server 2003 和 WINDOWS XP Service Pack 2 以及所有其他版本，默认值为 <see langword="false" /> 。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果 <xref:System.Net.Sockets.Socket.ExclusiveAddressUse%2A> 为 `false` ，则多个套接字可以使用 <xref:System.Net.Sockets.Socket.Bind%2A> 方法绑定到特定端口; 但只有一个套接字可对发送到端口的网络流量执行操作。 如果有多个套接字尝试使用 <xref:System.Net.Sockets.Socket.Bind%28System.Net.EndPoint%29> 方法绑定到特定端口，则具有更具体的 IP 地址的套接字将处理发送到该端口的网络流量。  
  
 如果 <xref:System.Net.Sockets.Socket.ExclusiveAddressUse%2A> 为 `true` ，则在第一次使用 <xref:System.Net.Sockets.Socket.Bind%2A> 方法时，尝试绑定到特定端口，而不管 INTERNET 协议 (IP) 地址，都将成功; 在 <xref:System.Net.Sockets.Socket.Bind%2A> 销毁原始绑定套接字之前，该方法的所有后续使用将失败。  
  
 在调用之前必须设置此属性 <xref:System.Net.Sockets.Socket.Bind%2A> ; 否则 <xref:System.InvalidOperationException> 将引发。  
  
   
  
## Examples  
 下面的代码示例演示属性的用法 <xref:System.Net.Sockets.Socket.ExclusiveAddressUse%2A> 。  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <exception cref="T:System.InvalidOperationException">已为此 <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> 调用了 <see cref="T:System.Net.Sockets.Socket" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~Socket ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!Socket ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="socket.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>释放 <see cref="T:System.Net.Sockets.Socket" /> 类使用的资源。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket>类终结器调用 <xref:System.Net.Sockets.Socket.Close%2A> 方法来关闭与 <xref:System.Net.Sockets.Socket> 相关联的和可用资源 <xref:System.Net.Sockets.Socket> 。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="socket.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回 <see cref="T:System.Net.Sockets.Socket" /> 实例的哈希值。</summary>
        <returns>整数哈希值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks  
GetHashCode 方法返回此实例的哈希代码。 此值可用作哈希表中的键。

]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetRawSocketOption">
      <MemberSignature Language="C#" Value="public int GetRawSocketOption (int optionLevel, int optionName, Span&lt;byte&gt; optionValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetRawSocketOption(int32 optionLevel, int32 optionName, valuetype System.Span`1&lt;unsigned int8&gt; optionValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.GetRawSocketOption(System.Int32,System.Int32,System.Span{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Function GetRawSocketOption (optionLevel As Integer, optionName As Integer, optionValue As Span(Of Byte)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetRawSocketOption(int optionLevel, int optionName, Span&lt;System::Byte&gt; optionValue);" />
      <MemberSignature Language="F#" Value="member this.GetRawSocketOption : int * int * Span&lt;byte&gt; -&gt; int" Usage="socket.GetRawSocketOption (optionLevel, optionName, optionValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Int32" Index="0" FrameworkAlternate="net-5.0" />
        <Parameter Name="optionName" Type="System.Int32" Index="1" FrameworkAlternate="net-5.0" />
        <Parameter Name="optionValue" Type="System.Span&lt;System.Byte&gt;" Index="2" FrameworkAlternate="net-5.0" />
      </Parameters>
      <Docs>
        <param name="optionLevel">平台定义的选项级别。</param>
        <param name="optionName">平台定义的选项名称。</param>
        <param name="optionValue">检索到的选项值应存储到的范围。</param>
        <summary>使用平台特定的级别和名称标识符获取套接字选项值。</summary>
        <returns>已成功检索的值已写入 <paramref name="optionValue" /> 的字节数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

通常，在 `GetSocketOption` 获取选项时，应使用方法 <xref:System.Net.Sockets.Socket> 。

<xref:System.Net.Sockets.Socket.GetRawSocketOption(System.Int32,System.Int32,System.Span{System.Byte})> 仅当 <xref:System.Net.Sockets.SocketOptionLevel> 和 <xref:System.Net.Sockets.SocketOptionName> 不公开所需选项时，才应使用方法。

          ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetSocketOption">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>返回 <see cref="T:System.Net.Sockets.Socket" /> 选项的值。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetSocketOption">
      <MemberSignature Language="C#" Value="public object GetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetSocketOption (optionLevel As SocketOptionLevel, optionName As SocketOptionName) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetSocketOption(System::Net::Sockets::SocketOptionLevel optionLevel, System::Net::Sockets::SocketOptionName optionName);" />
      <MemberSignature Language="F#" Value="member this.GetSocketOption : System.Net.Sockets.SocketOptionLevel * System.Net.Sockets.SocketOptionName -&gt; obj" Usage="socket.GetSocketOption (optionLevel, optionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="optionLevel"><see cref="T:System.Net.Sockets.SocketOptionLevel" /> 值之一。</param>
        <param name="optionName"><see cref="T:System.Net.Sockets.SocketOptionName" /> 值之一。</param>
        <summary>返回指定的 <see cref="T:System.Net.Sockets.Socket" /> 选项的值，表示为一个对象。</summary>
        <returns>一个对象，表示选项的值。 当将 <paramref name="optionName" /> 参数设置为 <see cref="F:System.Net.Sockets.SocketOptionName.Linger" /> 时，返回值为 <see cref="T:System.Net.Sockets.LingerOption" /> 类的一个实例。 当将 <paramref name="optionName" /> 设置为 <see cref="F:System.Net.Sockets.SocketOptionName.AddMembership" /> 或 <see cref="F:System.Net.Sockets.SocketOptionName.DropMembership" /> 时，返回值为 <see cref="T:System.Net.Sockets.MulticastOption" /> 类的一个实例。 当 <paramref name="optionName" /> 为其他任何值时，返回值为整数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket> 选项确定当前的行为 <xref:System.Net.Sockets.Socket> 。 使用此重载获取 <xref:System.Net.Sockets.SocketOptionName.Linger> 、 <xref:System.Net.Sockets.SocketOptionName.AddMembership> 和 <xref:System.Net.Sockets.SocketOptionName.DropMembership> <xref:System.Net.Sockets.Socket> 选项。 对于 <xref:System.Net.Sockets.SocketOptionName.Linger> 选项，请使用 <xref:System.Net.Sockets.Socket> 作为 `optionLevel` 参数。 对于 <xref:System.Net.Sockets.SocketOptionName.AddMembership> 和 <xref:System.Net.Sockets.SocketOptionName.DropMembership> ，请使用 <xref:System.Net.Sockets.SocketOptionLevel.IP> 。 如果要设置上面列出的任何选项的值，请使用 <xref:System.Net.Sockets.Socket.SetSocketOption%2A> 方法。  
  
> [!NOTE]
>  如果收到 <xref:System.Net.Sockets.SocketException> ，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。 获取此代码后，请参阅 [Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2) 文档，以获取有关错误的详细说明。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅 [.NET Framework 中的网络跟踪](/dotnet/framework/network-programming/network-tracing)。  
  
   
  
## Examples  
 下面的代码示例检索 <xref:System.Net.Sockets.LingerOption> 和超时 <xref:System.Net.Sockets.Socket.Send%2A> 值，并将其显示在控制台中。  
  
 [!code-cpp[Socket_Socket_Options#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#2)]
 [!code-csharp[Socket_Socket_Options#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#2)]
 [!code-vb[Socket_Socket_Options#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。  
  
- 或 - 
 <paramref name="optionName" /> 设置为不支持的值 <see cref="F:System.Net.Sockets.SocketOptionName.MaxConnections" />。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="T:System.Net.Sockets.SocketOptionName" />
        <altmember cref="T:System.Net.Sockets.SocketOptionLevel" />
      </Docs>
    </Member>
    <Member MemberName="GetSocketOption">
      <MemberSignature Language="C#" Value="public void GetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName, byte[] optionValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void GetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName, unsigned int8[] optionValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub GetSocketOption (optionLevel As SocketOptionLevel, optionName As SocketOptionName, optionValue As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void GetSocketOption(System::Net::Sockets::SocketOptionLevel optionLevel, System::Net::Sockets::SocketOptionName optionName, cli::array &lt;System::Byte&gt; ^ optionValue);" />
      <MemberSignature Language="F#" Value="member this.GetSocketOption : System.Net.Sockets.SocketOptionLevel * System.Net.Sockets.SocketOptionName * byte[] -&gt; unit" Usage="socket.GetSocketOption (optionLevel, optionName, optionValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="optionValue" Type="System.Byte[]" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="optionLevel"><see cref="T:System.Net.Sockets.SocketOptionLevel" /> 值之一。</param>
        <param name="optionName"><see cref="T:System.Net.Sockets.SocketOptionName" /> 值之一。</param>
        <param name="optionValue"><see cref="T:System.Byte" /> 类型的数组，用于接收选项设置。</param>
        <summary>返回指定的 <see cref="T:System.Net.Sockets.Socket" /> 选项设置，表示为字节数组。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket> 选项确定当前的行为 <xref:System.Net.Sockets.Socket> 。 此方法成功完成后，由参数指定的数组 `optionValue` 包含指定选项的值 <xref:System.Net.Sockets.Socket> 。  
  
 当数组的长度小于 `optionValue` 存储指定选项的值所需的字节数时 <xref:System.Net.Sockets.Socket> ， <xref:System.Net.Sockets.Socket.GetSocketOption%2A> 将引发 <xref:System.Net.Sockets.SocketException> 。 如果收到 <xref:System.Net.Sockets.SocketException> ，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。 获取此代码后，请参阅 [Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2) 文档，以获取有关错误的详细说明。 将此重载用于由布尔值或整数表示的任何套接字。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅 [.NET Framework 中的网络跟踪](/dotnet/framework/network-programming/network-tracing)。  
  
   
  
## Examples  
 下面的代码示例检索 <xref:System.Net.Sockets.LingerOption> 和超时 <xref:System.Net.Sockets.Socket.Send%2A> 值，并将其显示在控制台中。  
  
 [!code-cpp[Socket_Socket_Options#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#2)]
 [!code-csharp[Socket_Socket_Options#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#2)]
 [!code-vb[Socket_Socket_Options#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。  
  
- 或 - 
在 .NET Compact Framework 应用程序中，Windows CE 默认缓冲区的空间被设置为 32768 字节。 通过调用 <see cref="Overload:System.Net.Sockets.Socket.SetSocketOption" />，可以更改每个套接字缓冲区的空间。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="T:System.Net.Sockets.SocketOptionName" />
        <altmember cref="T:System.Net.Sockets.SocketOptionLevel" />
      </Docs>
    </Member>
    <Member MemberName="GetSocketOption">
      <MemberSignature Language="C#" Value="public byte[] GetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName, int optionLength);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8[] GetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName, int32 optionLength) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetSocketOption (optionLevel As SocketOptionLevel, optionName As SocketOptionName, optionLength As Integer) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Byte&gt; ^ GetSocketOption(System::Net::Sockets::SocketOptionLevel optionLevel, System::Net::Sockets::SocketOptionName optionName, int optionLength);" />
      <MemberSignature Language="F#" Value="member this.GetSocketOption : System.Net.Sockets.SocketOptionLevel * System.Net.Sockets.SocketOptionName * int -&gt; byte[]" Usage="socket.GetSocketOption (optionLevel, optionName, optionLength)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="optionLength" Type="System.Int32" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="optionLevel"><see cref="T:System.Net.Sockets.SocketOptionLevel" /> 值之一。</param>
        <param name="optionName"><see cref="T:System.Net.Sockets.SocketOptionName" /> 值之一。</param>
        <param name="optionLength">所需返回值的长度（以字节为单位）。</param>
        <summary>返回数组中指定的 <see cref="T:System.Net.Sockets.Socket" /> 选项的值。</summary>
        <returns><see cref="T:System.Byte" /> 类型的数组，它包含套接字选项的值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `optionLength`参数设置返回的字节数组的最大大小。 如果选项值需要较少的字节，则数组只包含很多字节。 如果选项值需要多个字节， <xref:System.Net.Sockets.Socket.GetSocketOption%2A> 则将引发 <xref:System.Net.Sockets.SocketException> 。 将此重载用于由布尔值或整数表示的任何套接字。  
  
> [!NOTE]
>  如果收到 <xref:System.Net.Sockets.SocketException> ，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。 获取此代码后，请参阅 [Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2) 文档，以获取有关错误的详细说明。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅 [.NET Framework 中的网络跟踪](/dotnet/framework/network-programming/network-tracing)。  
  
   
  
## Examples  
 下面的代码示例检索 <xref:System.Net.Sockets.LingerOption> 和超时 <xref:System.Net.Sockets.Socket.Send%2A> 值，并将其显示在控制台中。  
  
 [!code-cpp[Socket_Socket_Options#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#2)]
 [!code-csharp[Socket_Socket_Options#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#2)]
 [!code-vb[Socket_Socket_Options#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。  
  
- 或 - 
在 .NET Compact Framework 应用程序中，Windows CE 默认缓冲区的空间被设置为 32768 字节。 通过调用 <see cref="Overload:System.Net.Sockets.Socket.SetSocketOption" />，可以更改每个套接字缓冲区的空间。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="T:System.Net.Sockets.SocketOptionName" />
        <altmember cref="T:System.Net.Sockets.SocketOptionLevel" />
      </Docs>
    </Member>
    <Member MemberName="Handle">
      <MemberSignature Language="C#" Value="public IntPtr Handle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int Handle" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.Handle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Handle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr Handle { IntPtr get(); };" />
      <MemberSignature Language="F#" Value="member this.Handle : nativeint" Usage="System.Net.Sockets.Socket.Handle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取 <see cref="T:System.Net.Sockets.Socket" /> 的操作系统句柄。</summary>
        <value>一个 <see cref="T:System.IntPtr" />，它表示 <see cref="T:System.Net.Sockets.Socket" /> 的操作系统句柄。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="IOControl">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>为 <see cref="T:System.Net.Sockets.Socket" /> 设置低级别操作模式。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IOControl">
      <MemberSignature Language="C#" Value="public int IOControl (int ioControlCode, byte[] optionInValue, byte[] optionOutValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IOControl(int32 ioControlCode, unsigned int8[] optionInValue, unsigned int8[] optionOutValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.IOControl(System.Int32,System.Byte[],System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Function IOControl (ioControlCode As Integer, optionInValue As Byte(), optionOutValue As Byte()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IOControl(int ioControlCode, cli::array &lt;System::Byte&gt; ^ optionInValue, cli::array &lt;System::Byte&gt; ^ optionOutValue);" />
      <MemberSignature Language="F#" Value="member this.IOControl : int * byte[] * byte[] -&gt; int" Usage="socket.IOControl (ioControlCode, optionInValue, optionOutValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ioControlCode" Type="System.Int32" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="optionInValue" Type="System.Byte[]" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="optionOutValue" Type="System.Byte[]" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="ioControlCode">一个 <see cref="T:System.Int32" /> 值，该值指定要执行的操作的控制代码。</param>
        <param name="optionInValue">一个 <see cref="T:System.Byte" /> 数组，它包含操作需要的输入数据。</param>
        <param name="optionOutValue">一个 <see cref="T:System.Byte" /> 数组，它包含操作返回的输出数据。</param>
        <summary>使用数字控制代码，为 <see cref="T:System.Net.Sockets.Socket" /> 设置低级操作模式。</summary>
        <returns><paramref name="optionOutValue" /> 参数中的字节数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.IOControl%2A>方法为类的当前实例所基于的操作系统提供低级别访问权限 <xref:System.Net.Sockets.Socket> <xref:System.Net.Sockets.Socket> 。 有关详细信息，请参阅 [WSAIoctl](/windows/win32/api/winsock2/nf-winsock2-wsaioctl) 文档。  
  
> [!NOTE]
>  如果收到 <xref:System.Net.Sockets.SocketException> ，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。 获取此代码后，请参阅 [Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2) 文档，以获取有关错误的详细说明。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅 [.NET Framework 中的网络跟踪](/dotnet/framework/network-programming/network-tracing)。  
  
   
  
## Examples  
 下面的代码示例将 FIONREAD 和可用属性的结果进行比较。  
  
 [!code-cpp[NCLSocketIoControl#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketIoControl/CPP/iocontrolserver.cpp#1)]
 [!code-csharp[NCLSocketIoControl#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketIoControl/CS/iocontrolserver.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <exception cref="T:System.InvalidOperationException">尝试不使用 <see cref="P:System.Net.Sockets.Socket.Blocking" /> 属性更改阻止模式。</exception>
        <exception cref="T:System.Security.SecurityException">调用堆栈中的调用方没有所需的权限。</exception>
      </Docs>
    </Member>
    <Member MemberName="IOControl">
      <MemberSignature Language="C#" Value="public int IOControl (System.Net.Sockets.IOControlCode ioControlCode, byte[] optionInValue, byte[] optionOutValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IOControl(valuetype System.Net.Sockets.IOControlCode ioControlCode, unsigned int8[] optionInValue, unsigned int8[] optionOutValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.IOControl(System.Net.Sockets.IOControlCode,System.Byte[],System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Function IOControl (ioControlCode As IOControlCode, optionInValue As Byte(), optionOutValue As Byte()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IOControl(System::Net::Sockets::IOControlCode ioControlCode, cli::array &lt;System::Byte&gt; ^ optionInValue, cli::array &lt;System::Byte&gt; ^ optionOutValue);" />
      <MemberSignature Language="F#" Value="member this.IOControl : System.Net.Sockets.IOControlCode * byte[] * byte[] -&gt; int" Usage="socket.IOControl (ioControlCode, optionInValue, optionOutValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ioControlCode" Type="System.Net.Sockets.IOControlCode" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="optionInValue" Type="System.Byte[]" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="optionOutValue" Type="System.Byte[]" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="ioControlCode">一个 <see cref="T:System.Net.Sockets.IOControlCode" /> 值，它指定要执行的操作的控制代码。</param>
        <param name="optionInValue"><see cref="T:System.Byte" /> 类型的数组，包含操作要求的输入数据。</param>
        <param name="optionOutValue"><see cref="T:System.Byte" /> 类型的数组，包含由操作返回的输出数据。</param>
        <summary>使用 <see cref="T:System.Net.Sockets.Socket" /> 枚举指定控制代码，为 <see cref="T:System.Net.Sockets.IOControlCode" /> 设置低级操作模式。</summary>
        <returns><paramref name="optionOutValue" /> 参数中的字节数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法提供对类的当前实例所基于的操作系统的低级访问 <xref:System.Net.Sockets.Socket> <xref:System.Net.Sockets.Socket> 。 有关详细信息，请参阅 [WSAIoctl](/windows/win32/api/winsock2/nf-winsock2-wsaioctl) 文档。  
  
> [!NOTE]
>  如果收到 <xref:System.Net.Sockets.SocketException> ，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。 获取此代码后，请参阅 [Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2) 文档，以获取有关错误的详细说明。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅 [.NET Framework 中的网络跟踪](/dotnet/framework/network-programming/network-tracing)。  
  
   
  
## Examples  
 下面的代码示例将调用的结果 <xref:System.Net.Sockets.Socket.IOControl%2A> 与 <xref:System.Net.Sockets.IOControlCode.DataToRead> 属性进行比较 <xref:System.Net.Sockets.Socket.Available%2A> 。  
  
 [!code-cpp[NCLSocketIoControl1#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketIoControl1/CPP/iocontrolcode.cpp#1)]
 [!code-csharp[NCLSocketIoControl1#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketIoControl1/CS/iocontrolcode.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <exception cref="T:System.InvalidOperationException">尝试不使用 <see cref="P:System.Net.Sockets.Socket.Blocking" /> 属性更改阻止模式。</exception>
      </Docs>
    </Member>
    <Member MemberName="IsBound">
      <MemberSignature Language="C#" Value="public bool IsBound { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsBound" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.IsBound" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsBound As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsBound { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsBound : bool" Usage="System.Net.Sockets.Socket.IsBound" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示 <see cref="T:System.Net.Sockets.Socket" /> 是否绑定到特定本地端口。</summary>
        <value>如果 <see cref="T:System.Net.Sockets.Socket" /> 绑定到本地端口，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果套接字是通过调用方法显式绑定的，或者通过调用的成员（如、或）隐式绑定，则将套接字绑定到本地端口; 如果使用的是 <xref:System.Net.Sockets.Socket.Bind%2A> <xref:System.Net.Sockets.Socket.Connect%2A> <xref:System.Net.Sockets.Socket.SendTo%2A> <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> (端口（由 ) 操作系统选择），则它将使用一个临时本地端口，而不是使用大于1024的空闲端口 <xref:System.Net.Sockets.Socket.Bind%2A>  
  
   
  
## Examples  
 下面的代码示例演示属性的用法 <xref:System.Net.Sockets.Socket.IsBound%2A> 。  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LingerState">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.LingerOption? LingerState { get; set; }" FrameworkAlternate="net-5.0" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.Sockets.LingerOption LingerState" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.LingerState" />
      <MemberSignature Language="VB.NET" Value="Public Property LingerState As LingerOption" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Sockets::LingerOption ^ LingerState { System::Net::Sockets::LingerOption ^ get(); void set(System::Net::Sockets::LingerOption ^ value); };" />
      <MemberSignature Language="F#" Value="member this.LingerState : System.Net.Sockets.LingerOption with get, set" Usage="System.Net.Sockets.Socket.LingerState" />
      <MemberSignature Language="C#" Value="public System.Net.Sockets.LingerOption LingerState { get; set; }" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.LingerOption</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指定 <see cref="T:System.Net.Sockets.Socket" /> 在尝试发送所有挂起数据时是否延迟关闭套接字。</summary>
        <value>一个 <see cref="T:System.Net.Sockets.LingerOption" />，它指定关闭套接字时如何逗留。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.LingerState%2A>属性更改 <xref:System.Net.Sockets.Socket.Close%2A> 方法的行为方式。 设置此属性时，此属性修改 Winsock 可以重置连接时的条件。 仍然可以基于 IP 协议行为重置连接。  
  
 此属性控制在调用数据时，面向连接的连接保持打开状态的时间长度 <xref:System.Net.Sockets.Socket.Close%2A> 。  
  
 调用方法将数据发送到对等节点时，此数据将被置于传出网络缓冲区中。 此属性可用于确保在该方法断开连接之前，将此数据发送到远程主机 <xref:System.Net.Sockets.TcpClient.Close%2A> 。  
  
 若要启用延迟，请创建 <xref:System.Net.Sockets.LingerOption> 包含所需值的实例，并将 <xref:System.Net.Sockets.Socket.LingerState%2A> 属性设置为此实例。  
  
 下表描述了 <xref:System.Net.Sockets.Socket.Close%2A> 方法对于属性的可能值 <xref:System.Net.Sockets.LingerOption.Enabled%2A> 和 <xref:System.Net.Sockets.LingerOption.LingerTime%2A> 存储在属性中的属性的行为 <xref:System.Net.Sockets.Socket.LingerState%2A> 。  
  
|LingerState 已启用|LingerState.LingerTime|行为|  
|-------------------------|----------------------------|--------------|  
|`false` (禁用) ，默认值|超时不适用， (默认) 。|在默认 IP 协议超时过期之前，尝试发送挂起的数据。|  
|`true` (启用) |非零超时|尝试发送挂起的数据直到指定的超时过期，如果尝试失败，Winsock 将重置连接。|  
|`true` (启用) |零超时。|丢弃所有挂起的数据。 对于面向连接的套接字 (TCP，如) ，Winsock 重置连接。|  
  
 IP 堆栈根据连接的往返时间来计算要使用的默认 IP 协议超时期限。 在大多数情况下，堆栈计算出的超时比应用程序定义的超时更密切。 当未设置属性时，这是套接字的默认行为 <xref:System.Net.Sockets.Socket.LingerState%2A> 。  
  
 当 <xref:System.Net.Sockets.LingerOption.LingerTime%2A> 属性中存储的属性 <xref:System.Net.Sockets.Socket.LingerState%2A> 设置为大于默认 ip 协议超时值时，默认的 ip 协议超时值仍将应用并将替代。  
  
   
  
## Examples  
 下面的代码示例演示属性的用法 <xref:System.Net.Sockets.Socket.LingerState%2A> 。  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
      </Docs>
    </Member>
    <Member MemberName="Listen">
      <MemberSignature Language="C#" Value="public void Listen ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Listen() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Listen" />
      <MemberSignature Language="VB.NET" Value="Public Sub Listen ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Listen();" />
      <MemberSignature Language="F#" Value="member this.Listen : unit -&gt; unit" Usage="socket.Listen " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>将 <see cref="T:System.Net.Sockets.Socket" /> 置于侦听状态。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

自动确定挂起的连接队列的最大长度。

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Listen">
      <MemberSignature Language="C#" Value="public void Listen (int backlog);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Listen(int32 backlog) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Listen(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Listen (backlog As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Listen(int backlog);" />
      <MemberSignature Language="F#" Value="member this.Listen : int -&gt; unit" Usage="socket.Listen backlog" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="backlog" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="backlog">挂起连接队列的最大长度。</param>
        <summary>将 <see cref="T:System.Net.Sockets.Socket" /> 置于侦听状态。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Listen%2A> 导致面向连接的 <xref:System.Net.Sockets.Socket> 侦听传入的连接尝试。 `backlog`参数指定可以排队等待接受的传入连接的数量。 若要确定可以指定的最大连接数，请检索 <xref:System.Net.Sockets.SocketOptionName.MaxConnections> 值。 <xref:System.Net.Sockets.Socket.Listen%2A> 不会阻止。  
  
 如果收到 <xref:System.Net.Sockets.SocketException> ，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A> 属性获取特定的错误代码。 获取此代码后，请参阅 [Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2) 文档，以获取有关错误的详细说明。 使用 <xref:System.Net.Sockets.Socket.Accept%2A> 或 <xref:System.Net.Sockets.Socket.BeginAccept%2A> 接受队列中的连接。  
  
> [!NOTE]
>  必须在 <xref:System.Net.Sockets.Socket.Bind%2A> 调用之前调用方法 <xref:System.Net.Sockets.Socket.Listen%2A> ，否则 <xref:System.Net.Sockets.Socket.Listen%2A> 将引发 <xref:System.Net.Sockets.SocketException> 。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅 [.NET Framework 中的网络跟踪](/dotnet/framework/network-programming/network-tracing)。  
  
> [!NOTE]
>  积压工作（backlog）参数限制为不同的值，具体取决于操作系统。 您可以指定较大的值，但积压工作（backlog）将基于操作系统进行限制。  
  
   
  
## Examples  
 下面的代码示例使用 <xref:System.Net.Sockets.Socket> 侦听传入连接。  
  
 [!code-cpp[Classic Socket.Listen Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Listen Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Listen Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Listen Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Listen Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Listen Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <altmember cref="F:System.Net.Sockets.SocketOptionName.MaxConnections" />
        <altmember cref="M:System.Net.Sockets.Socket.Accept" />
        <altmember cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
      </Docs>
    </Member>
    <Member MemberName="LocalEndPoint">
      <MemberSignature Language="C#" Value="public System.Net.EndPoint LocalEndPoint { get; }" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.EndPoint LocalEndPoint" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.LocalEndPoint" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LocalEndPoint As EndPoint" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::EndPoint ^ LocalEndPoint { System::Net::EndPoint ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.LocalEndPoint : System.Net.EndPoint" Usage="System.Net.Sockets.Socket.LocalEndPoint" />
      <MemberSignature Language="C#" Value="public System.Net.EndPoint? LocalEndPoint { get; }" FrameworkAlternate="net-5.0" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.EndPoint</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取本地终结点。</summary>
        <value><see cref="T:System.Net.EndPoint" /> 当前用以进行通信的 <see cref="T:System.Net.Sockets.Socket" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.LocalEndPoint%2A>属性获取一个 <xref:System.Net.EndPoint> ，其中包含绑定到的本地 IP 地址和端口号 <xref:System.Net.Sockets.Socket> 。 在 <xref:System.Net.EndPoint> <xref:System.Net.IPEndPoint> 检索任何信息之前，必须将此转换为。 然后，可以调用 <xref:System.Net.IPEndPoint.Address%2A?displayProperty=nameWithType> 方法来检索本地 <xref:System.Net.IPAddress> ，并调用 <xref:System.Net.IPEndPoint.Port%2A?displayProperty=nameWithType> 方法来检索本地端口号。  
  
 <xref:System.Net.Sockets.Socket.LocalEndPoint%2A>通常在调用方法后设置属性 <xref:System.Net.Sockets.Socket.Bind%2A> 。 如果允许系统分配套接字的本地 IP 地址和端口号，则将在 <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> 第一次 i/o 操作后设置属性。 对于面向连接的协议，第一个 i/o 操作将是对 <xref:System.Net.Sockets.Socket.Connect%2A> 或方法的调用 <xref:System.Net.Sockets.Socket.Accept%2A> 。 对于无连接协议，第一个 i/o 操作将是任何发送或接收调用。  
  
> [!NOTE]
>  如果收到 <xref:System.Net.Sockets.SocketException> ，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。 获取此代码后，请参阅 [Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2) 文档，以获取有关错误的详细说明。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅 [.NET Framework 中的网络跟踪](/dotnet/framework/network-programming/network-tracing)。  
  
   
  
## Examples  
 下面的代码示例检索并显示本地和远程终结点。  
  
 [!code-cpp[Socket_Socket_Options#4](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#4)]
 [!code-csharp[Socket_Socket_Options#4](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#4)]
 [!code-vb[Socket_Socket_Options#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <altmember cref="T:System.Net.EndPoint" />
        <altmember cref="T:System.Net.IPEndPoint" />
        <altmember cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
      </Docs>
    </Member>
    <Member MemberName="MulticastLoopback">
      <MemberSignature Language="C#" Value="public bool MulticastLoopback { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool MulticastLoopback" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.MulticastLoopback" />
      <MemberSignature Language="VB.NET" Value="Public Property MulticastLoopback As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool MulticastLoopback { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.MulticastLoopback : bool with get, set" Usage="System.Net.Sockets.Socket.MulticastLoopback" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指定传出的多路广播数据包是否传递到发送应用程序。</summary>
        <value>如果 <see cref="T:System.Net.Sockets.Socket" /> 接收传出的多路广播数据包，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 多播是 Internet 上多对多通信的可扩展方法。 进程订阅多路广播地址;然后，由订阅的进程发送的任何数据包都由订阅了多播地址的每个其他进程接收。  
  
  (TCP) 套接字对传输控制协议设置此属性将不起作用。  
  
   
  
## Examples  
 下面的代码示例演示属性的用法 <xref:System.Net.Sockets.Socket.MulticastLoopback%2A> 。  
  
 [!code-cpp[SocketPropertyTester#2](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#2)]
 [!code-csharp[SocketPropertyTester#2](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
      </Docs>
    </Member>
    <Member MemberName="NoDelay">
      <MemberSignature Language="C#" Value="public bool NoDelay { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool NoDelay" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.NoDelay" />
      <MemberSignature Language="VB.NET" Value="Public Property NoDelay As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool NoDelay { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.NoDelay : bool with get, set" Usage="System.Net.Sockets.Socket.NoDelay" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置 <see cref="T:System.Boolean" /> 值，该值指定流 <see cref="T:System.Net.Sockets.Socket" /> 是否正在使用 Nagle 算法。</summary>
        <value>如果 <see cref="T:System.Net.Sockets.Socket" /> 使用 Nagle 算法，则为 <see langword="false" />；否则为 <see langword="true" />。 默认值为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nagle 算法旨在通过使套接字缓冲小数据包，然后在特定情况下将它们合并并发送到一个数据包，从而减少网络流量。 TCP 数据包包含40字节的标头以及要发送的数据。 当使用 TCP 发送小型数据包时，TCP 标头产生的开销可能会成为网络流量的重要部分。 在负载较重的网络上，由于这种开销导致的拥塞会导致丢失数据报和重新传输，以及拥塞导致的传播时间过大。 如果在连接上以前传输的数据保持未确认的情况，则 Nagle 算法将禁止发送新的 TCP 段。  
  
 大多数网络应用程序都应使用 Nagle 算法。  
  
  (UDP) 套接字在用户数据报协议上设置此属性将不起作用。  
  
   
  
## Examples  
 下面的代码示例演示属性的用法 <xref:System.Net.Sockets.Socket.NoDelay%2A> 。  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问 <see cref="T:System.Net.Sockets.Socket" /> 时出错。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
      </Docs>
    </Member>
    <Member MemberName="OSSupportsIPv4">
      <MemberSignature Language="C#" Value="public static bool OSSupportsIPv4 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool OSSupportsIPv4" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.OSSupportsIPv4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property OSSupportsIPv4 As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool OSSupportsIPv4 { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.OSSupportsIPv4 : bool" Usage="System.Net.Sockets.Socket.OSSupportsIPv4" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指示基础操作系统和网络适配器是否支持 Internet 协议第 4 版 (IPv4)。</summary>
        <value>如果操作系统和网络适配器支持 IPv4 协议，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 操作系统可能支持 IPv4 和 IPv6 协议。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Net.Sockets.Socket.OSSupportsIPv6" />
      </Docs>
    </Member>
    <Member MemberName="OSSupportsIPv6">
      <MemberSignature Language="C#" Value="public static bool OSSupportsIPv6 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool OSSupportsIPv6" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.OSSupportsIPv6" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property OSSupportsIPv6 As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool OSSupportsIPv6 { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.OSSupportsIPv6 : bool" Usage="System.Net.Sockets.Socket.OSSupportsIPv6" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指示基础操作系统和网络适配器是否支持 Internet 协议第 6 版 (IPv6)。</summary>
        <value>如果操作系统和网络适配器支持 IPv6 协议，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 操作系统可能支持 IPv4 和 IPv6 协议。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Net.Sockets.Socket.OSSupportsIPv4" />
      </Docs>
    </Member>
    <Member MemberName="OSSupportsUnixDomainSockets">
      <MemberSignature Language="C#" Value="public static bool OSSupportsUnixDomainSockets { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool OSSupportsUnixDomainSockets" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.OSSupportsUnixDomainSockets" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property OSSupportsUnixDomainSockets As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool OSSupportsUnixDomainSockets { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.OSSupportsUnixDomainSockets : bool" Usage="System.Net.Sockets.Socket.OSSupportsUnixDomainSockets" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指示基础操作系统是否支持 Unix 域套接字。</summary>
        <value><see langword="true" /> 如果操作系统支持 Unix 域套接字，则为;否则为 <see langword="false" /> 。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Poll">
      <MemberSignature Language="C#" Value="public bool Poll (int microSeconds, System.Net.Sockets.SelectMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Poll(int32 microSeconds, valuetype System.Net.Sockets.SelectMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)" />
      <MemberSignature Language="VB.NET" Value="Public Function Poll (microSeconds As Integer, mode As SelectMode) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Poll(int microSeconds, System::Net::Sockets::SelectMode mode);" />
      <MemberSignature Language="F#" Value="member this.Poll : int * System.Net.Sockets.SelectMode -&gt; bool" Usage="socket.Poll (microSeconds, mode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="microSeconds" Type="System.Int32" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="mode" Type="System.Net.Sockets.SelectMode" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="microSeconds">等待响应的时间（以微秒为单位）。</param>
        <param name="mode"><see cref="T:System.Net.Sockets.SelectMode" /> 值之一。</param>
        <summary>确定 <see cref="T:System.Net.Sockets.Socket" /> 的状态。</summary>
        <returns>基于 <paramref name="mode" /> 参数中传递的轮询模式值的 <see cref="T:System.Net.Sockets.Socket" /> 的状态。  
  
 <list type="table"><listheader><term> 模式 
 </term><description> 返回值 
 </description></listheader><item><term><see cref="F:System.Net.Sockets.SelectMode.SelectRead" /></term><description>如果已调用 <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> 并且有挂起的连接，则为 <see langword="true" />。 
- 或 - 
 如果有数据可供读取，则为 <see langword="true" />。 
- 或 - 
 如果连接已关闭、重置或终止，则返回 <see langword="true" />； 
否则，返回 <see langword="false" />。  
  
 </description></item><item><term><see cref="F:System.Net.Sockets.SelectMode.SelectWrite" /></term><description>如果正在处理 <see cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" /> 并且连接已成功，则为 <see langword="true" />； 
- 或 - 
 如果可以发送数据，则返回 <see langword="true" />； 
否则，返回 <see langword="false" />。  
  
 </description></item><item><term><see cref="F:System.Net.Sockets.SelectMode.SelectError" /></term><description>如果正在处理不阻止的 <see cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />，并且连接已失败，则为 <see langword="true" />； 
- 或 - 
 如果 <see cref="F:System.Net.Sockets.SocketOptionName.OutOfBandInline" /> 未设置，并且带外数据可用，则为 <see langword="true" />； 
否则，返回 <see langword="false" />。  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Poll%2A>方法将检查的状态 <xref:System.Net.Sockets.Socket> 。 为 <xref:System.Net.Sockets.SelectMode.SelectRead?displayProperty=nameWithType> 参数指定 `selectMode` 以确定 <xref:System.Net.Sockets.Socket> 是否可读。 指定 <xref:System.Net.Sockets.SelectMode.SelectWrite?displayProperty=nameWithType> 以确定 <xref:System.Net.Sockets.Socket> 是否可写。 使用 <xref:System.Net.Sockets.SelectMode.SelectError?displayProperty=nameWithType> 检测错误条件。 <xref:System.Net.Sockets.Socket.Poll%2A> 将阻止执行到指定的时间段（以为单位） `microseconds` 。 如果要 `microSeconds` 无限期等待响应，请将参数设置为负整数。 如果要检查多个套接字的状态，可能更倾向于使用 <xref:System.Net.Sockets.Socket.Select%2A> 方法。  
  
> [!NOTE]
>  如果收到 <xref:System.Net.Sockets.SocketException> ，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。 获取此代码后，请参阅 [Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2) 文档，以获取有关错误的详细说明。  
  
> [!NOTE]
>  此方法无法检测某些类型的连接问题，例如网络电缆损坏或远程主机已关闭意外。 您必须尝试发送或接收数据，以检测这些类型的错误。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅 [.NET Framework 中的网络跟踪](/dotnet/framework/network-programming/network-tracing)。  
  
   
  
## Examples  
 下面的代码示例创建套接字，连接到服务器，并使用 <xref:System.Net.Sockets.Socket.Poll%2A> 检查套接字的状态。  
  
 [!code-cpp[SelectModeExample#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SelectModeExample/CPP/source.cpp#1)]
 [!code-csharp[SelectModeExample#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SelectModeExample/CS/source.cs#1)]
 [!code-vb[SelectModeExample#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/SelectModeExample/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><paramref name="mode" /> 参数不是一个 <see cref="T:System.Net.Sockets.SelectMode" /> 值。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。 请参见下面的备注。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <altmember cref="T:System.Net.Sockets.SelectMode" />
        <altmember cref="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)" />
      </Docs>
    </Member>
    <Member MemberName="ProtocolType">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.ProtocolType ProtocolType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Net.Sockets.ProtocolType ProtocolType" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.ProtocolType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ProtocolType As ProtocolType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Sockets::ProtocolType ProtocolType { System::Net::Sockets::ProtocolType get(); };" />
      <MemberSignature Language="F#" Value="member this.ProtocolType : System.Net.Sockets.ProtocolType" Usage="System.Net.Sockets.Socket.ProtocolType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.ProtocolType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取 <see cref="T:System.Net.Sockets.Socket" /> 的协议类型。</summary>
        <value><see cref="T:System.Net.Sockets.ProtocolType" /> 值之一。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.ProtocolType%2A>属性是在创建时设置的 <xref:System.Net.Sockets.Socket> ，它指定了所使用的协议 <xref:System.Net.Sockets.Socket> 。  
  
   
  
## Examples  
 下面的代码示例将 <xref:System.Net.Sockets.AddressFamily> 、 <xref:System.Net.Sockets.SocketType> 和显示 <xref:System.Net.Sockets.ProtocolType> 到控制台。  
  
 [!code-cpp[Socket_Socket_Options#3](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#3)]
 [!code-csharp[Socket_Socket_Options#3](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#3)]
 [!code-vb[Socket_Socket_Options#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Receive">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>接收来自绑定的 <see cref="T:System.Net.Sockets.Socket" /> 的数据。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (byte[] buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(unsigned int8[] buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (buffer As Byte()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(cli::array &lt;System::Byte&gt; ^ buffer);" />
      <MemberSignature Language="F#" Value="member this.Receive : byte[] -&gt; int" Usage="socket.Receive buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="buffer"><see cref="T:System.Byte" /> 类型的数组，它是存储接收到的数据的位置。</param>
        <summary>从绑定的 <see cref="T:System.Net.Sockets.Socket" /> 套接字接收数据，将数据存入接收缓冲区。</summary>
        <returns>收到的字节数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Receive%2A>方法将数据读入 buffer 参数，并返回成功读取的字节数。 可 <xref:System.Net.Sockets.Socket.Receive%2A> 从面向连接的套接字和无连接套接字调用。  
  
 此重载只要求你提供接收缓冲区。 缓冲区偏移量默认为0，大小默认为 buffer 参数的长度， <xref:System.Net.Sockets.SocketFlags> 值默认为 <xref:System.Net.Sockets.SocketFlags.None> 。  
  
 如果使用面向连接的协议，则必须调用 <xref:System.Net.Sockets.Socket.Connect%2A> 以建立远程主机连接，或在 <xref:System.Net.Sockets.Socket.Accept%2A> 调用之前接受传入连接 <xref:System.Net.Sockets.Socket.Receive%2A> 。 <xref:System.Net.Sockets.Socket.Receive%2A>方法只读取从或方法中建立的远程主机到达的数据 <xref:System.Net.Sockets.Socket.Connect%2A> <xref:System.Net.Sockets.Socket.Accept%2A> 。 如果你使用的是无连接协议，则还可以使用 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 方法。 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 将允许接收来自任何主机的数据。  
  
 如果没有可供读取的数据，则该 <xref:System.Net.Sockets.Socket.Receive%2A> 方法将在数据可用之前被阻止，除非使用设置超时值 <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType> 。 如果超过超时值，则 <xref:System.Net.Sockets.Socket.Receive%2A> 调用将引发 <xref:System.Net.Sockets.SocketException> 。 如果处于非阻止模式，并且在协议堆栈缓冲区中没有可用的数据，则该 <xref:System.Net.Sockets.Socket.Receive%2A> 方法将立即完成并引发 <xref:System.Net.Sockets.SocketException> 。 您可以使用 <xref:System.Net.Sockets.Socket.Available%2A> 属性来确定数据是否可用于读取。 如果 <xref:System.Net.Sockets.Socket.Available%2A> 为非零，则重试接收操作。  
  
 如果使用面向连接的 <xref:System.Net.Sockets.Socket> ，该 <xref:System.Net.Sockets.Socket.Receive%2A> 方法将读取尽可能多的数据，直到达到缓冲区的大小。 如果远程主机 <xref:System.Net.Sockets.Socket> 使用方法关闭连接 <xref:System.Net.Sockets.Socket.Shutdown%2A> 并且收到所有可用数据，则该 <xref:System.Net.Sockets.Socket.Receive%2A> 方法将立即完成并返回零字节。  
  
 如果你使用的是无连接 <xref:System.Net.Sockets.Socket> ， <xref:System.Net.Sockets.Socket.Receive%2A> 将从你在方法中指定的目标地址读取第一个排队的数据报 <xref:System.Net.Sockets.Socket.Connect%2A> 。 如果接收的数据报大于参数的大小，则将 `buffer` `buffer` 使用消息的第一部分进行填充，超过的数据将会丢失，并 <xref:System.Net.Sockets.SocketException> 引发。  
  
> [!NOTE]
>  如果收到 <xref:System.Net.Sockets.SocketException> ，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。 获取此代码后，请参阅 [Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2) 文档，以获取有关错误的详细说明。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅 [.NET Framework 中的网络跟踪](/dotnet/framework/network-programming/network-tracing)。  
  
   
  
## Examples  
 下面的代码示例在连接的上接收数据 <xref:System.Net.Sockets.Socket> 。  
  
 [!code-cpp[Socket_Sync_Send_Receive#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#1)]
 [!code-csharp[Socket_Sync_Send_Receive#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#1)]
 [!code-vb[Socket_Sync_Send_Receive#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <exception cref="T:System.Security.SecurityException">调用堆栈中的调用方没有所需的权限。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt;? buffers);" FrameworkAlternate="net-5.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (buffers As IList(Of ArraySegment(Of Byte))) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers);" />
      <MemberSignature Language="F#" Value="member this.Receive : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; -&gt; int" Usage="socket.Receive buffers" />
      <MemberSignature Language="C#" Value="public int Receive (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="buffers"><see cref="T:System.ArraySegment`1" /> 类型的一个 <see cref="T:System.Byte" /> 列表，包含接收的数据。</param>
        <summary>从绑定的 <see cref="T:System.Net.Sockets.Socket" /> 接收数据，将数据存入接收缓冲区列表中。</summary>
        <returns>收到的字节数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法将数据读取到缓冲区参数，并返回成功读取的字节数。 可从面向连接的套接字和无连接套接字调用。  
  
 此重载要求提供一个或多个接收缓冲区。  
  
 如果使用面向连接的协议，则必须调用 <xref:System.Net.Sockets.Socket.Connect%2A> 以建立远程主机连接，或在 <xref:System.Net.Sockets.Socket.Accept%2A> 调用之前接受传入连接 <xref:System.Net.Sockets.Socket.Receive%2A> 。 <xref:System.Net.Sockets.Socket.Receive%2A>方法只读取从或方法中建立的远程主机连接到达的数据 <xref:System.Net.Sockets.Socket.Connect%2A> <xref:System.Net.Sockets.Socket.Accept%2A> 。 如果你使用的是无连接协议，则还可以使用 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 方法。 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 将允许接收来自任何主机的数据。  
  
 如果没有可供读取的数据，则该 <xref:System.Net.Sockets.Socket.Receive%2A> 方法将在数据可用之前被阻止，除非使用设置超时值 <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType> 。 如果超过超时值，则 <xref:System.Net.Sockets.Socket.Receive%2A> 调用将引发 <xref:System.Net.Sockets.SocketException> 。 如果处于非阻止模式，并且在协议堆栈缓冲区中没有可用的数据，则该 <xref:System.Net.Sockets.Socket.Receive%2A> 方法将立即完成并引发 <xref:System.Net.Sockets.SocketException> 。 您可以使用 <xref:System.Net.Sockets.Socket.Available%2A> 属性来确定数据是否可用于读取。 如果 <xref:System.Net.Sockets.Socket.Available%2A> 为非零，则重试接收操作。  
  
 如果使用面向连接的 <xref:System.Net.Sockets.Socket> ，该 <xref:System.Net.Sockets.Socket.Receive%2A> 方法将读取尽可能多的数据，直到达到缓冲区的大小。 如果远程主机 <xref:System.Net.Sockets.Socket> 使用方法关闭连接 <xref:System.Net.Sockets.Socket.Shutdown%2A> 并且收到所有可用数据，则该 <xref:System.Net.Sockets.Socket.Receive%2A> 方法将立即完成并返回零字节。  
  
 如果你使用的是无连接 <xref:System.Net.Sockets.Socket> ， <xref:System.Net.Sockets.Socket.Receive%2A> 将从你在方法中指定的目标地址读取第一个排队的数据报 <xref:System.Net.Sockets.Socket.Connect%2A> 。 如果接收的数据报大于参数的大小，则将 `buffers` `buffers` 使用消息的第一部分进行填充，超过的数据将会丢失，并 <xref:System.Net.Sockets.SocketException> 引发。  
  
> [!NOTE]
>  如果收到 <xref:System.Net.Sockets.SocketException> ，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。 获取此代码后，请参阅 [Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2) 文档，以获取有关错误的详细说明。  
  
 **注意** 当你在应用程序中启用网络跟踪时，此成员将输出跟踪信息。 有关详细信息，请参阅 [.NET Framework 中的网络跟踪](/dotnet/framework/network-programming/network-tracing)。  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Net.Sockets.Socket.Receive(System.Byte[])" />
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> 参数为 <see langword="null" />。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (Span&lt;byte&gt; buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(valuetype System.Span`1&lt;unsigned int8&gt; buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Span{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (buffer As Span(Of Byte)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(Span&lt;System::Byte&gt; buffer);" />
      <MemberSignature Language="F#" Value="member this.Receive : Span&lt;byte&gt; -&gt; int" Usage="socket.Receive buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Span&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="buffer">一个字节范围，它是所接收的数据的存储位置。</param>
        <summary>从绑定的 <see cref="T:System.Net.Sockets.Socket" /> 套接字接收数据，将数据存入接收缓冲区。</summary>
        <returns>收到的字节数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks

<xref:System.Net.Sockets.Socket.Receive%2A>方法将数据读入 buffer 参数，并返回成功读取的字节数。 可 <xref:System.Net.Sockets.Socket.Receive%2A> 从面向连接的套接字和无连接套接字调用。

此重载只要求你提供接收缓冲区。 缓冲区偏移量默认为0，大小默认为 buffer 参数的长度， <xref:System.Net.Sockets.SocketFlags> 值默认为 <xref:System.Net.Sockets.SocketFlags.None> 。

如果使用面向连接的协议，则必须调用 <xref:System.Net.Sockets.Socket.Connect%2A> 以建立远程主机连接，或在 <xref:System.Net.Sockets.Socket.Accept%2A> 调用之前接受传入连接 <xref:System.Net.Sockets.Socket.Receive%2A> 。 <xref:System.Net.Sockets.Socket.Receive%2A>方法只读取从或方法中建立的远程主机到达的数据 <xref:System.Net.Sockets.Socket.Connect%2A> <xref:System.Net.Sockets.Socket.Accept%2A> 。 如果使用的是无连接协议，则还可以使用 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 方法。 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 将允许接收来自任何主机的数据。

如果没有可供读取的数据，则该 <xref:System.Net.Sockets.Socket.Receive%2A> 方法将在数据可用之前被阻止，除非使用设置超时值 <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType> 。 当超过超时值时， <xref:System.Net.Sockets.Socket.Receive%2A> 调用将引发 <xref:System.Net.Sockets.SocketException> 。 如果处于非阻止模式，并且协议堆栈缓冲区中没有可用数据，则该 <xref:System.Net.Sockets.Socket.Receive%2A> 方法将立即完成并引发 <xref:System.Net.Sockets.SocketException> 。 您可以使用 <xref:System.Net.Sockets.Socket.Available%2A> 属性来确定数据是否可用于读取。 如果 <xref:System.Net.Sockets.Socket.Available%2A> 为非零，则重试接收操作。

如果使用面向连接的 <xref:System.Net.Sockets.Socket> ，该 <xref:System.Net.Sockets.Socket.Receive%2A> 方法将读取尽可能多的数据，直到达到缓冲区的大小。 如果远程主机 <xref:System.Net.Sockets.Socket> 使用方法关闭连接 <xref:System.Net.Sockets.Socket.Shutdown%2A> 并且收到所有可用数据，则该 <xref:System.Net.Sockets.Socket.Receive%2A> 方法将立即完成并返回零字节。

如果你使用的是无连接 <xref:System.Net.Sockets.Socket> ， <xref:System.Net.Sockets.Socket.Receive%2A> 将从你在方法中指定的目标地址读取第一个排队的数据报 <xref:System.Net.Sockets.Socket.Connect%2A> 。 如果接收的数据报大于参数的大小，则会 `buffer` `buffer` 填充消息的第一部分，超过的数据将会丢失，并 <xref:System.Net.Sockets.SocketException> 引发。

> [!NOTE]
> 如果收到 <xref:System.Net.Sockets.SocketException> ，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。 获取此代码后，请参阅 [Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2) 文档，以获取有关错误的详细说明。

当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅 [.NET Framework 中的网络跟踪](/dotnet/framework/network-programming/network-tracing)。
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <exception cref="T:System.Security.SecurityException">调用堆栈中的调用方没有所需的权限。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (byte[] buffer, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(unsigned int8[] buffer, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (buffer As Byte(), socketFlags As SocketFlags) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(cli::array &lt;System::Byte&gt; ^ buffer, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Receive : byte[] * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Receive (buffer, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="buffer"><see cref="T:System.Byte" /> 类型的数组，它是存储接收到的数据的位置。</param>
        <param name="socketFlags"><see cref="T:System.Net.Sockets.SocketFlags" /> 值的按位组合。</param>
        <summary>使用指定的 <see cref="T:System.Net.Sockets.Socket" />，从绑定的 <see cref="T:System.Net.Sockets.SocketFlags" /> 接收数据，将数据存入接收缓冲区。</summary>
        <returns>收到的字节数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Receive%2A>方法将数据读入 buffer 参数，并返回成功读取的字节数。 可 <xref:System.Net.Sockets.Socket.Receive%2A> 从面向连接的套接字和无连接套接字调用。  
  
 此重载只要求你提供接收缓冲区和必要的 <xref:System.Net.Sockets.SocketFlags> 。 缓冲区偏移量默认为0，大小默认为 byte 参数的长度。  
  
 如果使用面向连接的协议，则必须调用 <xref:System.Net.Sockets.Socket.Connect%2A> 以建立远程主机连接，或在 <xref:System.Net.Sockets.Socket.Accept%2A> 调用之前接受传入连接 <xref:System.Net.Sockets.Socket.Receive%2A> 。 <xref:System.Net.Sockets.Socket.Receive%2A>方法只读取从或方法中建立的远程主机到达的数据 <xref:System.Net.Sockets.Socket.Connect%2A> <xref:System.Net.Sockets.Socket.Accept%2A> 。 如果你使用的是无连接协议，则还可以使用 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 方法。 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 将允许接收来自任何主机的数据。  
  
 如果没有可供读取的数据，则该 <xref:System.Net.Sockets.Socket.Receive%2A> 方法将被阻止，直到数据可用。 如果处于非阻止模式，并且协议堆栈缓冲区中没有可用数据，则该 <xref:System.Net.Sockets.Socket.Receive%2A> 方法将立即完成并引发 <xref:System.Net.Sockets.SocketException> 。 您可以使用 <xref:System.Net.Sockets.Socket.Available%2A> 属性来确定数据是否可用于读取。 如果 <xref:System.Net.Sockets.Socket.Available%2A> 为非零，则重试接收操作。  
  
 如果使用面向连接的 <xref:System.Net.Sockets.Socket> ，则该 <xref:System.Net.Sockets.Socket.Receive%2A> 方法将读取尽可能多的数据，直到缓冲区大小可用。 如果远程主机 <xref:System.Net.Sockets.Socket> 使用方法关闭连接 <xref:System.Net.Sockets.Socket.Shutdown%2A> 并且收到所有可用数据，则该 <xref:System.Net.Sockets.Socket.Receive%2A> 方法将立即完成并返回零字节。  
  
 如果你使用的是无连接 <xref:System.Net.Sockets.Socket> ， <xref:System.Net.Sockets.Socket.Receive%2A> 将从你在方法中指定的目标地址读取第一个排队的数据报 <xref:System.Net.Sockets.Socket.Connect%2A> 。 如果接收的数据报大于参数的大小，则将 `buffer` `buffer` 使用消息的第一部分进行填充，超过的数据将会丢失，并 <xref:System.Net.Sockets.SocketException> 引发。  
  
> [!NOTE]
>  如果收到 <xref:System.Net.Sockets.SocketException> ，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。 获取此代码后，请参阅 [Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2) 文档，以获取有关错误的详细说明。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅 [.NET Framework 中的网络跟踪](/dotnet/framework/network-programming/network-tracing)。  
  
   
  
## Examples  
 下面的代码示例指定了一个数据缓冲区， <xref:System.Net.Sockets.SocketFlags> 用于在连接的上接收数据 <xref:System.Net.Sockets.Socket> 。  
  
 [!code-cpp[Socket_Sync_Send_Receive#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#2)]
 [!code-csharp[Socket_Sync_Send_Receive#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#2)]
 [!code-vb[Socket_Sync_Send_Receive#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <exception cref="T:System.Security.SecurityException">调用堆栈中的调用方没有所需的权限。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt;? buffers, System.Net.Sockets.SocketFlags socketFlags);" FrameworkAlternate="net-5.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (buffers As IList(Of ArraySegment(Of Byte)), socketFlags As SocketFlags) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Receive : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Receive (buffers, socketFlags)" />
      <MemberSignature Language="C#" Value="public int Receive (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="buffers"><see cref="T:System.ArraySegment`1" /> 类型的一个 <see cref="T:System.Byte" /> 列表，包含接收的数据。</param>
        <param name="socketFlags"><see cref="T:System.Net.Sockets.SocketFlags" /> 值的按位组合。</param>
        <summary>使用指定的 <see cref="T:System.Net.Sockets.Socket" />，从绑定的 <see cref="T:System.Net.Sockets.SocketFlags" /> 接收数据，将数据存入接收缓冲区列表中。</summary>
        <returns>收到的字节数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法将数据读入 `buffers` 参数，并返回成功读取的字节数。 可从面向连接的套接字和无连接套接字调用。  
  
 此重载要求提供一个或多个接收缓冲区。 <xref:System.Net.Sockets.SocketFlags>值默认为 <xref:System.Net.Sockets.SocketFlags.None> 。  
  
 如果使用面向连接的协议，则必须调用 <xref:System.Net.Sockets.Socket.Connect%2A> 以建立远程主机连接，或在 <xref:System.Net.Sockets.Socket.Accept%2A> 调用之前接受传入连接 <xref:System.Net.Sockets.Socket.Receive%2A> 。 <xref:System.Net.Sockets.Socket.Receive%2A>方法只读取从或方法中建立的远程主机连接到达的数据 <xref:System.Net.Sockets.Socket.Connect%2A> <xref:System.Net.Sockets.Socket.Accept%2A> 。 如果你使用的是无连接协议，则还可以使用 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 方法。 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 将允许接收来自任何主机的数据。  
  
 如果没有可供读取的数据，则该 <xref:System.Net.Sockets.Socket.Receive%2A> 方法将在数据可用之前被阻止，除非使用设置超时值 <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType> 。 如果超出了超时值，则 <xref:System.Net.Sockets.Socket.Receive%2A> 调用将引发 <xref:System.Net.Sockets.SocketException> 。 如果处于非阻止模式，并且在协议堆栈缓冲区中没有可用的数据，则该 <xref:System.Net.Sockets.Socket.Receive%2A> 方法将立即完成并引发 <xref:System.Net.Sockets.SocketException> 。 您可以使用 <xref:System.Net.Sockets.Socket.Available%2A> 属性来确定数据是否可用于读取。 如果 <xref:System.Net.Sockets.Socket.Available%2A> 为非零，则重试接收操作。  
  
 如果使用面向连接的 <xref:System.Net.Sockets.Socket> ，该 <xref:System.Net.Sockets.Socket.Receive%2A> 方法将读取尽可能多的数据，直到达到缓冲区的大小。 如果远程主机 <xref:System.Net.Sockets.Socket> 使用方法关闭连接 <xref:System.Net.Sockets.Socket.Shutdown%2A> 并且收到所有可用数据，则该 <xref:System.Net.Sockets.Socket.Receive%2A> 方法将立即完成并返回零字节。  
  
 如果你使用的是无连接 <xref:System.Net.Sockets.Socket> ， <xref:System.Net.Sockets.Socket.Receive%2A> 将从你在方法中指定的目标地址读取第一个排队的数据报 <xref:System.Net.Sockets.Socket.Connect%2A> 。 如果接收的数据报大于参数的大小，则将 `buffers` `buffers` 使用消息的第一部分进行填充，超过的数据将会丢失，并 <xref:System.Net.Sockets.SocketException> 引发。  
  
> [!NOTE]
>  如果收到 <xref:System.Net.Sockets.SocketException> ，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。 获取此代码后，请参阅 [Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2) 文档，以获取有关错误的详细说明。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅 [.NET Framework 中的网络跟踪](/dotnet/framework/network-programming/network-tracing)。  
  
   
  
## Examples  
 下面的代码示例演示如何在连接的上接收数据 <xref:System.Net.Sockets.Socket> 。  
  
 [!code-cpp[System.Net.Sockets.Socketgenerics#2](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socketgenerics/CPP/sendgeneric.cpp#2)]
 [!code-csharp[System.Net.Sockets.Socketgenerics#2](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socketgenerics/CS/sendgeneric.cs#2)]  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)" />
        <exception cref="T:System.ArgumentNullException"><paramref name="buffers" /> 为 <see langword="null" />。  
  
- 或 - 
 <paramref name="buffers" />.Count 是零。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (Span&lt;byte&gt; buffer, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(valuetype System.Span`1&lt;unsigned int8&gt; buffer, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Span{System.Byte},System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (buffer As Span(Of Byte), socketFlags As SocketFlags) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(Span&lt;System::Byte&gt; buffer, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Receive : Span&lt;byte&gt; * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Receive (buffer, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Span&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="buffer">一个字节范围，它是所接收的数据的存储位置。</param>
        <param name="socketFlags">枚举值的按位组合，它用于指定发送和接收行为。</param>
        <summary>使用指定的 <see cref="T:System.Net.Sockets.Socket" />，从绑定的 <see cref="T:System.Net.Sockets.SocketFlags" /> 接收数据，将数据存入接收缓冲区。</summary>
        <returns>收到的字节数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[
## Remarks

<xref:System.Net.Sockets.Socket.Receive%2A>方法将数据读入 buffer 参数，并返回成功读取的字节数。 可 <xref:System.Net.Sockets.Socket.Receive%2A> 从面向连接的套接字和无连接套接字调用。

此重载只要求你提供接收缓冲区。 缓冲区偏移量默认为0，大小默认为 buffer 参数的长度， <xref:System.Net.Sockets.SocketFlags> 值默认为 <xref:System.Net.Sockets.SocketFlags.None> 。

如果使用面向连接的协议，则必须调用 <xref:System.Net.Sockets.Socket.Connect%2A> 以建立远程主机连接，或在 <xref:System.Net.Sockets.Socket.Accept%2A> 调用之前接受传入连接 <xref:System.Net.Sockets.Socket.Receive%2A> 。 <xref:System.Net.Sockets.Socket.Receive%2A>方法只读取从或方法中建立的远程主机到达的数据 <xref:System.Net.Sockets.Socket.Connect%2A> <xref:System.Net.Sockets.Socket.Accept%2A> 。 如果使用的是无连接协议，则还可以使用 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 方法。 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 将允许接收来自任何主机的数据。

如果没有可供读取的数据，则该 <xref:System.Net.Sockets.Socket.Receive%2A> 方法将在数据可用之前被阻止，除非使用设置超时值 <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType> 。 当超过超时值时， <xref:System.Net.Sockets.Socket.Receive%2A> 调用将引发 <xref:System.Net.Sockets.SocketException> 。 如果处于非阻止模式，并且协议堆栈缓冲区中没有可用数据，则该 <xref:System.Net.Sockets.Socket.Receive%2A> 方法将立即完成并引发 <xref:System.Net.Sockets.SocketException> 。 您可以使用 <xref:System.Net.Sockets.Socket.Available%2A> 属性来确定数据是否可用于读取。 如果 <xref:System.Net.Sockets.Socket.Available%2A> 为非零，则重试接收操作。

如果使用面向连接的 <xref:System.Net.Sockets.Socket> ，该 <xref:System.Net.Sockets.Socket.Receive%2A> 方法将读取尽可能多的数据，直到达到缓冲区的大小。 如果远程主机 <xref:System.Net.Sockets.Socket> 使用方法关闭连接 <xref:System.Net.Sockets.Socket.Shutdown%2A> 并且收到所有可用数据，则该 <xref:System.Net.Sockets.Socket.Receive%2A> 方法将立即完成并返回零字节。

如果你使用的是无连接 <xref:System.Net.Sockets.Socket> ， <xref:System.Net.Sockets.Socket.Receive%2A> 将从你在方法中指定的目标地址读取第一个排队的数据报 <xref:System.Net.Sockets.Socket.Connect%2A> 。 如果接收的数据报大于参数的大小，则会 `buffer` `buffer` 填充消息的第一部分，超过的数据将会丢失，并 <xref:System.Net.Sockets.SocketException> 引发。

> [!NOTE]
> 如果收到 <xref:System.Net.Sockets.SocketException> ，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。 获取此代码后，请参阅 [Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2) 文档，以获取有关错误的详细说明。

当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅 [.NET Framework 中的网络跟踪](/dotnet/framework/network-programming/network-tracing)。

 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <exception cref="T:System.Security.SecurityException">调用堆栈中的调用方没有所需的权限。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (byte[] buffer, int size, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(unsigned int8[] buffer, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (buffer As Byte(), size As Integer, socketFlags As SocketFlags) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(cli::array &lt;System::Byte&gt; ^ buffer, int size, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Receive : byte[] * int * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Receive (buffer, size, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="size" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="buffer"><see cref="T:System.Byte" /> 类型的数组，它是存储接收到的数据的位置。</param>
        <param name="size">要接收的字节数。</param>
        <param name="socketFlags"><see cref="T:System.Net.Sockets.SocketFlags" /> 值的按位组合。</param>
        <summary>使用指定的 <see cref="T:System.Net.Sockets.Socket" />，从绑定的 <see cref="T:System.Net.Sockets.SocketFlags" /> 接收指定字节数的数据，并将数据存入接收缓冲区。</summary>
        <returns>收到的字节数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Receive%2A>方法将数据读入 `buffer` 参数并返回成功读取的字节数。 可 <xref:System.Net.Sockets.Socket.Receive%2A> 从面向连接的套接字和无连接套接字调用。  
  
 此重载只要求你提供接收缓冲区、要接收的字节数和必要的 <xref:System.Net.Sockets.SocketFlags> 。  
  
 如果使用面向连接的协议，则必须调用 <xref:System.Net.Sockets.Socket.Connect%2A> 以建立远程主机连接，或在 <xref:System.Net.Sockets.Socket.Accept%2A> 调用之前接受传入连接 <xref:System.Net.Sockets.Socket.Receive%2A> 。 <xref:System.Net.Sockets.Socket.Receive%2A>方法只读取从或方法中建立的远程主机到达的数据 <xref:System.Net.Sockets.Socket.Connect%2A> <xref:System.Net.Sockets.Socket.Accept%2A> 。 如果你使用的是无连接协议，则还可以使用 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 方法。 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 将允许接收来自任何主机的数据。  
  
 如果没有可供读取的数据，则该 <xref:System.Net.Sockets.Socket.Receive%2A> 方法将在数据可用之前被阻止，除非使用设置超时值 <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType> 。 如果超过超时值，则 <xref:System.Net.Sockets.Socket.Receive%2A> 调用将引发 <xref:System.Net.Sockets.SocketException> 。 如果处于非阻止模式，并且在协议堆栈缓冲区中没有可用的数据，则该 <xref:System.Net.Sockets.Socket.Receive%2A> 方法将立即完成并引发 <xref:System.Net.Sockets.SocketException> 。 您可以使用 <xref:System.Net.Sockets.Socket.Available%2A> 属性来确定数据是否可用于读取。 如果 <xref:System.Net.Sockets.Socket.Available%2A> 为非零，则重试接收操作。  
  
 如果使用面向连接的 <xref:System.Net.Sockets.Socket> ，该 <xref:System.Net.Sockets.Socket.Receive%2A> 方法将读取尽可能多的数据，直到参数指定的字节数 `size` 。 如果远程主机 <xref:System.Net.Sockets.Socket> 使用方法关闭连接 <xref:System.Net.Sockets.Socket.Shutdown%2A> 并且收到所有可用数据，则该 <xref:System.Net.Sockets.Socket.Receive%2A> 方法将立即完成并返回零字节。  
  
 如果你使用的是无连接 <xref:System.Net.Sockets.Socket> ， <xref:System.Net.Sockets.Socket.Receive%2A> 将从你在方法中指定的目标地址读取第一个排队的数据报 <xref:System.Net.Sockets.Socket.Connect%2A> 。 如果接收的数据报大于参数的大小，则将 `buffer` `buffer` 使用消息的第一部分进行填充，超过的数据将会丢失，并 <xref:System.Net.Sockets.SocketException> 引发。  
  
> [!NOTE]
>  如果收到 <xref:System.Net.Sockets.SocketException> ，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。 获取此代码后，请参阅 [Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2) 文档，以获取有关错误的详细说明。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅 [.NET Framework 中的网络跟踪](/dotnet/framework/network-programming/network-tracing)。  
  
   
  
## Examples  
 下面的将接收找到的数据 `buffer` ，并 <xref:System.Net.Sockets.SocketFlags.None> 为指定 <xref:System.Net.Sockets.SocketFlags> 。  
  
 [!code-cpp[Socket_Send_Receive#4](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Send_Receive/CPP/source.cpp#4)]
 [!code-csharp[Socket_Send_Receive#4](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Send_Receive/CS/source.cs#4)]
 [!code-vb[Socket_Send_Receive#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Send_Receive/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="size" /> 超出了 <paramref name="buffer" /> 的大小。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <exception cref="T:System.Security.SecurityException">调用堆栈中的调用方没有所需的权限。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt;? buffers, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode);" FrameworkAlternate="net-5.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (buffers As IList(Of ArraySegment(Of Byte)), socketFlags As SocketFlags, ByRef errorCode As SocketError) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberSignature Language="F#" Value="member this.Receive : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.Net.Sockets.SocketFlags * SocketError -&gt; int" Usage="socket.Receive (buffers, socketFlags, errorCode)" />
      <MemberSignature Language="C#" Value="public int Receive (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="buffers"><see cref="T:System.ArraySegment`1" /> 类型的一个 <see cref="T:System.Byte" /> 列表，包含接收的数据。</param>
        <param name="socketFlags"><see cref="T:System.Net.Sockets.SocketFlags" /> 值的按位组合。</param>
        <param name="errorCode">一个 <see cref="T:System.Net.Sockets.SocketError" /> 对象，它存储套接字错误。</param>
        <summary>使用指定的 <see cref="T:System.Net.Sockets.Socket" />，从绑定的 <see cref="T:System.Net.Sockets.SocketFlags" /> 接收数据，将数据存入接收缓冲区列表中。</summary>
        <returns>收到的字节数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法将数据读入 `buffers` 参数，并返回成功读取的字节数。 可从面向连接的套接字和无连接套接字调用。  
  
 此重载要求提供一个或多个接收缓冲区。 <xref:System.Net.Sockets.SocketFlags>值默认为 <xref:System.Net.Sockets.SocketFlags.None> 。  
  
 如果使用面向连接的协议，则必须调用 <xref:System.Net.Sockets.Socket.Connect%2A> 以建立远程主机连接，或在 <xref:System.Net.Sockets.Socket.Accept%2A> 调用之前接受传入连接 <xref:System.Net.Sockets.Socket.Receive%2A> 。 <xref:System.Net.Sockets.Socket.Receive%2A>方法只读取从或方法中建立的远程主机连接到达的数据 <xref:System.Net.Sockets.Socket.Connect%2A> <xref:System.Net.Sockets.Socket.Accept%2A> 。 如果你使用的是无连接协议，则还可以使用 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 方法。 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 将允许接收来自任何主机的数据。  
  
 如果没有可供读取的数据，则该 <xref:System.Net.Sockets.Socket.Receive%2A> 方法将在数据可用之前被阻止，除非使用设置超时值 <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType> 。 如果超出了超时值，则 <xref:System.Net.Sockets.Socket.Receive%2A> 调用将引发 <xref:System.Net.Sockets.SocketException> 。 如果处于非阻止模式，并且在协议堆栈缓冲区中没有可用的数据，则该 <xref:System.Net.Sockets.Socket.Receive%2A> 方法将立即完成并引发 <xref:System.Net.Sockets.SocketException> 。 您可以使用 <xref:System.Net.Sockets.Socket.Available%2A> 属性来确定数据是否可用于读取。 如果 <xref:System.Net.Sockets.Socket.Available%2A> 为非零，则重试接收操作。  
  
 如果使用面向连接的 <xref:System.Net.Sockets.Socket> ，该 <xref:System.Net.Sockets.Socket.Receive%2A> 方法将读取尽可能多的数据，直到达到缓冲区的大小。 如果远程主机 <xref:System.Net.Sockets.Socket> 使用方法关闭连接 <xref:System.Net.Sockets.Socket.Shutdown%2A> 并且收到所有可用数据，则该 <xref:System.Net.Sockets.Socket.Receive%2A> 方法将立即完成并返回零字节。  
  
 如果你使用的是无连接 <xref:System.Net.Sockets.Socket> ， <xref:System.Net.Sockets.Socket.Receive%2A> 将从你在方法中指定的目标地址读取第一个排队的数据报 <xref:System.Net.Sockets.Socket.Connect%2A> 。 如果接收的数据报大于参数的大小，则将 `buffers` `buffers` 使用消息的第一部分进行填充，超过的数据将会丢失，并 <xref:System.Net.Sockets.SocketException> 引发。  
  
> [!NOTE]
>  如果收到 <xref:System.Net.Sockets.SocketException> ，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。 获取此代码后，请参阅 [Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2) 文档，以获取有关错误的详细说明。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅 [.NET Framework 中的网络跟踪](/dotnet/framework/network-programming/network-tracing)。  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)" />
        <exception cref="T:System.ArgumentNullException"><paramref name="buffers" /> 为 <see langword="null" />。  
  
- 或 - 
 <paramref name="buffers" />.Count 是零。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (Span&lt;byte&gt; buffer, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(valuetype System.Span`1&lt;unsigned int8&gt; buffer, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Span{System.Byte},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (buffer As Span(Of Byte), socketFlags As SocketFlags, ByRef errorCode As SocketError) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(Span&lt;System::Byte&gt; buffer, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberSignature Language="F#" Value="member this.Receive : Span&lt;byte&gt; * System.Net.Sockets.SocketFlags * SocketError -&gt; int" Usage="socket.Receive (buffer, socketFlags, errorCode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Span&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="buffer">一个字节范围，它是所接收的数据的存储位置。</param>
        <param name="socketFlags">枚举值的按位组合，它用于指定发送和接收行为。</param>
        <param name="errorCode">当此方法返回时，将包含定义套接字错误代码的枚举值之一。</param>
        <summary>使用指定的 <see cref="T:System.Net.Sockets.Socket" />，从绑定的 <see cref="T:System.Net.Sockets.SocketFlags" /> 接收数据，将数据存入接收缓冲区。</summary>
        <returns>收到的字节数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
## Remarks

<xref:System.Net.Sockets.Socket.Receive%2A>方法将数据读入 buffer 参数，并返回成功读取的字节数。 可 <xref:System.Net.Sockets.Socket.Receive%2A> 从面向连接的套接字和无连接套接字调用。  

此重载只要求你提供接收缓冲区。 缓冲区偏移量默认为0，大小默认为 buffer 参数的长度， <xref:System.Net.Sockets.SocketFlags> 值默认为 <xref:System.Net.Sockets.SocketFlags.None> 。  

如果使用面向连接的协议，则必须调用 <xref:System.Net.Sockets.Socket.Connect%2A> 以建立远程主机连接，或在 <xref:System.Net.Sockets.Socket.Accept%2A> 调用之前接受传入连接 <xref:System.Net.Sockets.Socket.Receive%2A> 。 <xref:System.Net.Sockets.Socket.Receive%2A>方法只读取从或方法中建立的远程主机到达的数据 <xref:System.Net.Sockets.Socket.Connect%2A> <xref:System.Net.Sockets.Socket.Accept%2A> 。 如果使用的是无连接协议，则还可以使用 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 方法。 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 将允许接收来自任何主机的数据。  

如果没有可供读取的数据，则该 <xref:System.Net.Sockets.Socket.Receive%2A> 方法将在数据可用之前被阻止，除非使用设置超时值 <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType> 。 当超过超时值时， <xref:System.Net.Sockets.Socket.Receive%2A> 调用将引发 <xref:System.Net.Sockets.SocketException> 。 如果处于非阻止模式，并且协议堆栈缓冲区中没有可用数据，则该 <xref:System.Net.Sockets.Socket.Receive%2A> 方法将立即完成并引发 <xref:System.Net.Sockets.SocketException> 。 您可以使用 <xref:System.Net.Sockets.Socket.Available%2A> 属性来确定数据是否可用于读取。 如果 <xref:System.Net.Sockets.Socket.Available%2A> 为非零，则重试接收操作。  

如果使用面向连接的 <xref:System.Net.Sockets.Socket> ，该 <xref:System.Net.Sockets.Socket.Receive%2A> 方法将读取尽可能多的数据，直到达到缓冲区的大小。 如果远程主机 <xref:System.Net.Sockets.Socket> 使用方法关闭连接 <xref:System.Net.Sockets.Socket.Shutdown%2A> 并且收到所有可用数据，则该 <xref:System.Net.Sockets.Socket.Receive%2A> 方法将立即完成并返回零字节。  

如果你使用的是无连接 <xref:System.Net.Sockets.Socket> ， <xref:System.Net.Sockets.Socket.Receive%2A> 将从你在方法中指定的目标地址读取第一个排队的数据报 <xref:System.Net.Sockets.Socket.Connect%2A> 。 如果接收的数据报大于参数的大小，则将 `buffer` `buffer` 使用消息的第一部分进行填充，超过的数据将会丢失，并 <xref:System.Net.Sockets.SocketException> 引发。  

> [!NOTE]
>  如果收到 <xref:System.Net.Sockets.SocketException> ，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。 获取此代码后，请参阅 [Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2) 文档，以获取有关错误的详细说明。  

> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅 [.NET Framework 中的网络跟踪](/dotnet/framework/network-programming/network-tracing)。  

 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <exception cref="T:System.Security.SecurityException">调用堆栈中的调用方没有所需的权限。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (buffer As Byte(), offset As Integer, size As Integer, socketFlags As SocketFlags) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Receive : byte[] * int * int * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Receive (buffer, offset, size, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="buffer">类型 <see cref="T:System.Byte" /> 的数组，它是所接受的数据的存储位置。</param>
        <param name="offset"><paramref name="buffer" /> 中存储所接收数据的位置。</param>
        <param name="size">要接收的字节数。</param>
        <param name="socketFlags"><see cref="T:System.Net.Sockets.SocketFlags" /> 值的按位组合。</param>
        <summary>使用指定的 <see cref="T:System.Net.Sockets.Socket" />，从绑定的 <see cref="T:System.Net.Sockets.SocketFlags" /> 接收指定的字节数，存入接收缓冲区的指定偏移量位置。</summary>
        <returns>收到的字节数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Receive%2A>方法将数据读入 buffer 参数，并返回成功读取的字节数。 可 <xref:System.Net.Sockets.Socket.Receive%2A> 从面向连接的套接字和无连接套接字调用。  
  
 如果使用面向连接的协议，则必须调用 <xref:System.Net.Sockets.Socket.Connect%2A> 以建立远程主机连接，或在 <xref:System.Net.Sockets.Socket.Accept%2A> 调用之前接受传入连接 <xref:System.Net.Sockets.Socket.Receive%2A> 。 <xref:System.Net.Sockets.Socket.Receive%2A>方法只读取从或方法中建立的远程主机到达的数据 <xref:System.Net.Sockets.Socket.Connect%2A> <xref:System.Net.Sockets.Socket.Accept%2A> 。 如果你使用的是无连接协议，则还可以使用 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 方法。 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 将允许接收来自任何主机的数据。  
  
 如果没有可供读取的数据，则该 <xref:System.Net.Sockets.Socket.Receive%2A> 方法将在数据可用之前被阻止，除非使用设置超时值 <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType> 。 如果超过超时值，则 <xref:System.Net.Sockets.Socket.Receive%2A> 调用将引发 <xref:System.Net.Sockets.SocketException> 。 如果处于非阻止模式，并且在协议堆栈缓冲区中没有可用的数据，则该 <xref:System.Net.Sockets.Socket.Receive%2A> 方法将立即完成并引发 <xref:System.Net.Sockets.SocketException> 。 尝试访问套接字时出错。 请参阅下面的备注。 您可以使用 <xref:System.Net.Sockets.Socket.Available%2A> 属性来确定数据是否可用于读取。 如果 <xref:System.Net.Sockets.Socket.Available%2A> 为非零，则重试接收操作。  
  
 如果使用面向连接的 <xref:System.Net.Sockets.Socket> ，该 <xref:System.Net.Sockets.Socket.Receive%2A> 方法将读取尽可能多的数据，最多可达 size 参数指定的字节数。 如果远程主机 <xref:System.Net.Sockets.Socket> 使用方法关闭连接 <xref:System.Net.Sockets.Socket.Shutdown%2A> 并且收到所有可用数据，则该 <xref:System.Net.Sockets.Socket.Receive%2A> 方法将立即完成并返回零字节。  
  
 如果你使用的是无连接 <xref:System.Net.Sockets.Socket> ， <xref:System.Net.Sockets.Socket.Receive%2A> 将从你在方法中指定的目标地址读取第一个排队的数据报 <xref:System.Net.Sockets.Socket.Connect%2A> 。 如果接收的数据报大于参数的大小，则将 `buffer` `buffer` 使用消息的第一部分进行填充，超过的数据将会丢失，并 <xref:System.Net.Sockets.SocketException> 引发。  
  
> [!NOTE]
>  如果收到 <xref:System.Net.Sockets.SocketException> ，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。 获取此代码后，请参阅 [Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2) 文档，以获取有关错误的详细说明。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅 [.NET Framework 中的网络跟踪](/dotnet/framework/network-programming/network-tracing)。  
  
   
  
## Examples  
 下面的代码示例指定了一个数据缓冲区、偏移量、大小和套接字标志，然后在连接的上接收数据 <xref:System.Net.Sockets.Socket> 。  
  
 [!code-cpp[Socket_Sync_Send_Receive#4](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#4)]
 [!code-csharp[Socket_Sync_Send_Receive#4](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#4)]
 [!code-vb[Socket_Sync_Send_Receive#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" /> 小于 0。  
  
- 或 - 
 <paramref name="offset" /> 大于 <paramref name="buffer" /> 的长度。  
  
- 或 - 
 <paramref name="size" /> 小于 0。  
  
- 或 - 
 <paramref name="size" /> 大于 <paramref name="buffer" /> 的长度减去 <paramref name="offset" /> 参数的值。</exception>
        <exception cref="T:System.Net.Sockets.SocketException"><paramref name="socketFlags" /> 不是有效的值组合。  
  
- 或 - 
未设置 <see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /> 属性。  
  
- 或 - 
访问 <see cref="T:System.Net.Sockets.Socket" /> 时出现操作系统错误。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <exception cref="T:System.Security.SecurityException">调用堆栈中的调用方没有所需的权限。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (buffer As Byte(), offset As Integer, size As Integer, socketFlags As SocketFlags, ByRef errorCode As SocketError) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberSignature Language="F#" Value="member this.Receive : byte[] * int * int * System.Net.Sockets.SocketFlags * SocketError -&gt; int" Usage="socket.Receive (buffer, offset, size, socketFlags, errorCode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" Index="4" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="buffer"><see cref="T:System.Byte" /> 类型的数组，它是存储接收到的数据的位置。</param>
        <param name="offset"><paramref name="buffer" /> 参数中的位置，用于存储所接收的数据。</param>
        <param name="size">要接收的字节数。</param>
        <param name="socketFlags"><see cref="T:System.Net.Sockets.SocketFlags" /> 值的按位组合。</param>
        <param name="errorCode">一个 <see cref="T:System.Net.Sockets.SocketError" /> 对象，它存储套接字错误。</param>
        <summary>使用指定的 <see cref="T:System.Net.Sockets.Socket" />，从绑定的 <see cref="T:System.Net.Sockets.SocketFlags" /> 接收数据，将数据存入接收缓冲区。</summary>
        <returns>收到的字节数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Receive%2A>方法将数据读入 buffer 参数，并返回成功读取的字节数。 可 <xref:System.Net.Sockets.Socket.Receive%2A> 从面向连接的套接字和无连接套接字调用。  
  
 如果使用面向连接的协议，则必须调用 <xref:System.Net.Sockets.Socket.Connect%2A> 以建立远程主机连接，或在 <xref:System.Net.Sockets.Socket.Accept%2A> 调用之前接受传入连接 <xref:System.Net.Sockets.Socket.Receive%2A> 。 <xref:System.Net.Sockets.Socket.Receive%2A>方法只读取从或方法中建立的远程主机到达的数据 <xref:System.Net.Sockets.Socket.Connect%2A> <xref:System.Net.Sockets.Socket.Accept%2A> 。 如果你使用的是无连接协议，则还可以使用 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 方法。 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 将允许接收来自任何主机的数据。  
  
 如果没有可供读取的数据，则该 <xref:System.Net.Sockets.Socket.Receive%2A> 方法将在数据可用之前被阻止，除非使用设置超时值 <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType> 。 如果超过超时值，则 <xref:System.Net.Sockets.Socket.Receive%2A> 调用将引发 <xref:System.Net.Sockets.SocketException> 。 如果处于非阻止模式，并且在协议堆栈缓冲区中没有可用的数据，则该 <xref:System.Net.Sockets.Socket.Receive%2A> 方法将立即完成并引发 <xref:System.Net.Sockets.SocketException> 。 尝试访问套接字时出错。 请参阅下面的备注。 您可以使用 <xref:System.Net.Sockets.Socket.Available%2A> 属性来确定数据是否可用于读取。 如果 <xref:System.Net.Sockets.Socket.Available%2A> 为非零，则重试接收操作。  
  
 如果使用面向连接的 <xref:System.Net.Sockets.Socket> ，该 <xref:System.Net.Sockets.Socket.Receive%2A> 方法将读取尽可能多的数据，最多可达 size 参数指定的字节数。 如果远程主机 <xref:System.Net.Sockets.Socket> 使用方法关闭连接 <xref:System.Net.Sockets.Socket.Shutdown%2A> 并且收到所有可用数据，则该 <xref:System.Net.Sockets.Socket.Receive%2A> 方法将立即完成并返回零字节。  
  
 如果你使用的是无连接 <xref:System.Net.Sockets.Socket> ， <xref:System.Net.Sockets.Socket.Receive%2A> 将从你在方法中指定的目标地址读取第一个排队的数据报 <xref:System.Net.Sockets.Socket.Connect%2A> 。 如果接收的数据报大于参数的大小，则将 `buffer` `buffer` 使用消息的第一部分进行填充，超过的数据将会丢失，并 <xref:System.Net.Sockets.SocketException> 引发。  
  
> [!NOTE]
>  如果收到 <xref:System.Net.Sockets.SocketException> ，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。 获取此代码后，请参阅 [Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2) 文档，以获取有关错误的详细说明。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅 [.NET Framework 中的网络跟踪](/dotnet/framework/network-programming/network-tracing)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" /> 小于 0。  
  
- 或 - 
 <paramref name="offset" /> 大于 <paramref name="buffer" /> 的长度。  
  
- 或 - 
 <paramref name="size" /> 小于 0。  
  
- 或 - 
 <paramref name="size" /> 大于 <paramref name="buffer" /> 的长度减去 <paramref name="offset" /> 参数的值。</exception>
        <exception cref="T:System.Net.Sockets.SocketException"><paramref name="socketFlags" /> 不是有效的值组合。  
  
- 或 - 
未设置 <see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /> 属性。  
  
- 或 - 
访问 <see cref="T:System.Net.Sockets.Socket" /> 时出现操作系统错误。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <exception cref="T:System.Security.SecurityException">调用堆栈中的调用方没有所需的权限。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveAsync">
      <MemberSignature Language="C#" Value="public bool ReceiveAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ReceiveAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ReceiveAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.ReceiveAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="socket.ReceiveAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="e">要用于此异步套接字操作的 <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> 对象。</param>
        <summary>开始一个异步请求以便从连接的 <see cref="T:System.Net.Sockets.Socket" /> 对象中接收数据。</summary>
        <returns>如果 I/O 操作挂起，则为 <see langword="true" />。 操作完成时，将引发 <paramref name="e" /> 参数的 <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> 事件。  
  
 如果 I/O 操作同步完成，则为 <see langword="false" />。 在这种情况下，将不会引发 <paramref name="e" /> 参数的 <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> 事件，并且可能在方法调用返回后立即检查作为参数传递的 <paramref name="e" /> 对象以检索操作的结果。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.ReceiveAsync%2A>方法用于连接的套接字或绑定的无连接套接字，并用于读取传入的数据。 套接字的本地地址必须是已知的。  
  
 对于绑定的无连接套接字，此函数限制接受接收的消息的地址。 函数只从连接中指定的远程地址返回消息。 来自其他地址的消息将悄悄地丢弃。  
  
 <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags%2A?displayProperty=nameWithType>参数上的属性为 `e` 窗口套接字服务提供程序提供有关读取请求的其他信息。 有关如何使用此参数的详细信息，请参阅 <xref:System.Net.Sockets.SocketFlags?displayProperty=nameWithType> 。  
  
 <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType>若要成功调用此方法，必须具有对象上的下列属性和事件：  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> 或 <xref:System.Net.Sockets.SocketAsyncEventArgs.BufferList%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> 如果 <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> 设置  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType> 如果 <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> 设置  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
 调用方可以 <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> 在调用方法之前将属性设置为所需的任何用户状态对象 <xref:System.Net.Sockets.Socket.ReceiveAsync%2A> ，以便可以在回调方法中检索信息。 如果回调需要比单个对象更多的信息，则可以创建一个小类，以将其他所需的状态信息保存为成员。  
  
 对于字节流样式的套接字，传入的数据将被放入缓冲区中，直到缓冲区填充完毕、连接关闭或内部缓冲的数据被耗尽。  
  
 对于面向消息的套接字，传入消息会放入缓冲区中，直到与参数相关联的缓冲区的总大小 `e` 。 如果消息大于缓冲区，则缓冲区将用消息的第一部分进行填充。  
  
 对于面向连接的套接字，该 <xref:System.Net.Sockets.Socket.ReceiveAsync%2A> 方法可以通过两种方式中的一种来指示虚拟线路的正常终止方式，这种方式取决于套接字是字节流还是面向消息。 对于字节流，已读取的零字节表示正常关闭，不会再读取更多的字节。 对于面向消息的套接字，通常允许使用零字节消息， <xref:System.Net.Sockets.SocketException> <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType> 将设置为本机 Winsock WSAEDISCON 错误代码 (10101) ，以指示正常关闭。 在任何情况下，将 <xref:System.Net.Sockets.SocketException> <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType> 设置为本机 Winsock WSAECONNRESET 错误代码 (10054) 指示发生了异常关闭。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">参数无效。 <paramref name="e" /> 参数的 <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" /> 或 <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /> 属性必须引用有效的缓冲区。 可以设置这两个属性中的某一个，但不能同时设置这两个属性。</exception>
        <exception cref="T:System.InvalidOperationException">已经在使用 <paramref name="e" /> 参数中指定的 <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> 对象执行套接字操作。</exception>
        <exception cref="T:System.NotSupportedException">此方法需要 Windows XP 或更高版本。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Offset" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveBufferSize">
      <MemberSignature Language="C#" Value="public int ReceiveBufferSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ReceiveBufferSize" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.ReceiveBufferSize" />
      <MemberSignature Language="VB.NET" Value="Public Property ReceiveBufferSize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ReceiveBufferSize { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.ReceiveBufferSize : int with get, set" Usage="System.Net.Sockets.Socket.ReceiveBufferSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，它指定 <see cref="T:System.Net.Sockets.Socket" /> 接收缓冲区的大小。</summary>
        <value><see cref="T:System.Int32" />，它包含接收缓冲区的大小（以字节为单位）。 默认值为 8192。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 较大的缓冲区大小可能会减少 (没有数据部分) TCP 数据包的空确认的数目，但也可能会延迟连接问题的识别。 如果正在传输大文件，或者使用的是高带宽、高延迟连接 (如卫星宽带提供程序），请考虑增加缓冲区大小。 )   
  
   
  
## Examples  
 下面的代码示例演示属性的用法 <xref:System.Net.Sockets.Socket.ReceiveBufferSize%2A> 。  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">为设置操作指定的值小于 0。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReceiveFrom">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>接收数据报并存储源终结点。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReceiveFrom">
      <MemberSignature Language="C#" Value="public int ReceiveFrom (byte[] buffer, ref System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ReceiveFrom(unsigned int8[] buffer, class System.Net.EndPoint&amp; remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.EndPoint@)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveFrom (buffer As Byte(), ByRef remoteEP As EndPoint) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ReceiveFrom(cli::array &lt;System::Byte&gt; ^ buffer, System::Net::EndPoint ^ % remoteEP);" />
      <MemberSignature Language="F#" Value="member this.ReceiveFrom : byte[] * EndPoint -&gt; int" Usage="socket.ReceiveFrom (buffer, remoteEP)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" RefType="ref" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="buffer">类型 <see cref="T:System.Byte" /> 的数组，它是所接受的数据的存储位置。</param>
        <param name="remoteEP">通过引用传递的 <see cref="T:System.Net.EndPoint" />，表示远程服务器。</param>
        <summary>将数据报接收到数据缓冲区并存储终结点。</summary>
        <returns>收到的字节数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>方法将数据读入 `buffer` 参数，返回成功读取的字节数，并捕获从中发送数据的远程主机终结点。 如果打算从未知主机或多台主机接收无连接的数据报，此方法非常有用。  
  
 此重载仅要求你提供接收 `buffer` ，以及 <xref:System.Net.EndPoint> 表示远程主机的。 缓冲区偏移量默认为0。 大小默认为参数的长度 `buffer` ， `socketFlags` 值默认为 <xref:System.Net.Sockets.SocketFlags.None> 。  
  
> [!NOTE]
>  在调用之前 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> ，必须使用方法将显式绑定 <xref:System.Net.Sockets.Socket> 到本地终结点 <xref:System.Net.Sockets.Socket.Bind%2A> 。 否则， <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 将引发 <xref:System.Net.Sockets.SocketException> 。  
  
 对于无连接协议， <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 将读取接收到本地网络缓冲区中的第一个排队数据报。 如果接收的数据报大于大小 `buffer` ，则该 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 方法将尽可能多地填充 `buffer` 消息，并引发 <xref:System.Net.Sockets.SocketException> 。 如果使用的是不可靠的协议，则过量的数据将丢失。 如果你使用的是可靠协议，则该服务提供程序将保留多余的数据，并且你可以通过 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 使用足够大的缓冲区调用方法来检索这些数据。  
  
 如果没有可供读取的数据，则该 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 方法将被阻止，直到数据可用。 如果处于非阻止模式，并且在协议堆栈缓冲区中没有可用的数据，则该 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 方法将立即完成并引发 <xref:System.Net.Sockets.SocketException> 。 您可以使用 <xref:System.Net.Sockets.Socket.Available%2A> 属性来确定数据是否可用于读取。 如果 <xref:System.Net.Sockets.Socket.Available%2A> 为非零，则重试接收操作。  
  
 尽管适用 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 于无连接协议，但你也可以使用面向连接的协议。 如果选择这样做，则必须先通过调用方法建立远程主机连接， <xref:System.Net.Sockets.Socket.Connect%2A> 或通过调用方法接受传入的远程主机连接 <xref:System.Net.Sockets.Socket.Accept%2A> 。 如果在调用方法之前未建立或接受连接 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> ，则将获得 <xref:System.Net.Sockets.SocketException> 。 还可以在调用方法之前，为无连接协议建立默认远程主机 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 。 在这两种情况下， <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 方法将忽略 `remoteEP` 参数，并仅从已连接或默认的远程主机接收数据。  
  
 使用面向连接的套接字时， <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 将读取尽可能多的数据，最大可达大小 `buffer` 。 如果远程主机 <xref:System.Net.Sockets.Socket> 使用方法关闭连接 <xref:System.Net.Sockets.Socket.Shutdown%2A> 并且收到所有可用数据，则该 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 方法将立即完成并返回零字节。  
  
> [!NOTE]
>  如果收到 <xref:System.Net.Sockets.SocketException> ，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。 获取此代码后，请参阅 [Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2) 文档，以获取有关错误的详细说明。  
  
> [!NOTE]
>  <xref:System.Net.Sockets.AddressFamily> <xref:System.Net.EndPoint> 中使用的 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 需要与中使用的匹配 <xref:System.Net.Sockets.AddressFamily> <xref:System.Net.EndPoint> <xref:System.Net.Sockets.Socket.SendTo%2A> 。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅 [.NET Framework 中的网络跟踪](/dotnet/framework/network-programming/network-tracing)。  
  
   
  
## Examples  
 下面的代码示例从远程主机接收无连接的数据报。  
  
 [!code-cpp[Socket_Sync_Send_Receive#9](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#9)]
 [!code-csharp[Socket_Sync_Send_Receive#9](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#9)]
 [!code-vb[Socket_Sync_Send_Receive#9](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> 为 <see langword="null" />。  
  
- 或 - 
 <paramref name="remoteEP" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <exception cref="T:System.Security.SecurityException">调用堆栈中的调用方没有所需的权限。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveFrom">
      <MemberSignature Language="C#" Value="public int ReceiveFrom (byte[] buffer, System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ReceiveFrom(unsigned int8[] buffer, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint&amp; remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveFrom (buffer As Byte(), socketFlags As SocketFlags, ByRef remoteEP As EndPoint) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ReceiveFrom(cli::array &lt;System::Byte&gt; ^ buffer, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ % remoteEP);" />
      <MemberSignature Language="F#" Value="member this.ReceiveFrom : byte[] * System.Net.Sockets.SocketFlags * EndPoint -&gt; int" Usage="socket.ReceiveFrom (buffer, socketFlags, remoteEP)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" RefType="ref" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="buffer"><see cref="T:System.Byte" /> 类型的数组，它是存储接收到的数据的位置。</param>
        <param name="socketFlags"><see cref="T:System.Net.Sockets.SocketFlags" /> 值的按位组合。</param>
        <param name="remoteEP">通过引用传递的 <see cref="T:System.Net.EndPoint" />，表示远程服务器。</param>
        <summary>使用指定的 <see cref="T:System.Net.Sockets.SocketFlags" /> 将数据报接收到数据缓冲区并存储终结点。</summary>
        <returns>收到的字节数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>方法将数据读入 `buffer` 参数，返回成功读取的字节数，并捕获从中发送数据的远程主机终结点。 如果打算从未知主机或多台主机接收无连接的数据报，此方法非常有用。  
  
 此重载只要求你提供接收缓冲区、必需的 <xref:System.Net.Sockets.SocketFlags> 和 <xref:System.Net.EndPoint> 表示远程主机的。 偏移量默认为0，大小默认为 buffer 参数的长度。  
  
> [!NOTE]
>  在调用之前 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> ，必须使用方法将显式绑定 <xref:System.Net.Sockets.Socket> 到本地终结点 <xref:System.Net.Sockets.Socket.Bind%2A> 。 否则， <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 将引发 <xref:System.Net.Sockets.SocketException> 。  
  
 对于无连接协议， <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 将读取接收到本地网络缓冲区中的第一个排队数据报。 如果接收的数据报大于大小 `buffer` ，则该 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 方法将尽可能多地填充 `buffer` 消息，并引发 <xref:System.Net.Sockets.SocketException> 。 如果使用的是不可靠的协议，则过量的数据将丢失。 如果你使用的是可靠协议，则该服务提供程序将保留多余的数据，并且你可以通过 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 使用足够大的缓冲区调用方法来检索这些数据。  
  
 如果没有可供读取的数据，则该 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 方法将被阻止，直到数据可用。 如果处于非阻止模式，并且在协议堆栈缓冲区中没有可用的数据，则该 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 方法将立即完成并引发 <xref:System.Net.Sockets.SocketException> 。 您可以使用 <xref:System.Net.Sockets.Socket.Available%2A> 属性来确定数据是否可用于读取。 如果 <xref:System.Net.Sockets.Socket.Available%2A> 为非零，则重试接收操作。  
  
 尽管适用 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 于无连接协议，但你也可以使用面向连接的协议。 如果选择这样做，则必须先通过调用方法建立远程主机连接， <xref:System.Net.Sockets.Socket.Connect%2A> 或通过调用方法接受传入的远程主机连接 <xref:System.Net.Sockets.Socket.Accept%2A> 。 如果在调用方法之前未建立或接受连接 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> ，则将获得 <xref:System.Net.Sockets.SocketException> 。 还可以在调用方法之前，为无连接协议建立默认远程主机 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 。 在这两种情况下， <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 方法将忽略 `remoteEP` 参数，并仅从已连接或默认的远程主机接收数据。  
  
 使用面向连接的套接字时， <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 将读取尽可能多的数据，最大可达大小 `buffer` 。 如果远程主机 <xref:System.Net.Sockets.Socket> 使用方法关闭连接 <xref:System.Net.Sockets.Socket.Shutdown%2A> 并且收到所有可用数据，则该 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 方法将立即完成并返回零字节。  
  
> [!NOTE]
>  如果收到 <xref:System.Net.Sockets.SocketException> ，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。 获取此代码后，请参阅 [Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2) 文档，以获取有关错误的详细说明。  
  
> [!NOTE]
>  <xref:System.Net.Sockets.AddressFamily> <xref:System.Net.EndPoint> 中使用的 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 需要与中使用的匹配 <xref:System.Net.Sockets.AddressFamily> <xref:System.Net.EndPoint> <xref:System.Net.Sockets.Socket.SendTo%2A> 。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅 [.NET Framework 中的网络跟踪](/dotnet/framework/network-programming/network-tracing)。  
  
   
  
## Examples  
 下面的代码示例从远程主机接收无连接的数据报。 <xref:System.Net.Sockets.SocketFlags> 传递给 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 方法。  
  
 [!code-cpp[Socket_Sync_Send_Receive#10](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#10)]
 [!code-csharp[Socket_Sync_Send_Receive#10](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#10)]
 [!code-vb[Socket_Sync_Send_Receive#10](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> 为 <see langword="null" />。  
  
- 或 - 
 <paramref name="remoteEP" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <exception cref="T:System.Security.SecurityException">调用堆栈中的调用方没有所需的权限。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveFrom">
      <MemberSignature Language="C#" Value="public int ReceiveFrom (byte[] buffer, int size, System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ReceiveFrom(unsigned int8[] buffer, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint&amp; remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveFrom (buffer As Byte(), size As Integer, socketFlags As SocketFlags, ByRef remoteEP As EndPoint) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ReceiveFrom(cli::array &lt;System::Byte&gt; ^ buffer, int size, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ % remoteEP);" />
      <MemberSignature Language="F#" Value="member this.ReceiveFrom : byte[] * int * System.Net.Sockets.SocketFlags * EndPoint -&gt; int" Usage="socket.ReceiveFrom (buffer, size, socketFlags, remoteEP)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="size" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" RefType="ref" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="buffer">类型 <see cref="T:System.Byte" /> 的数组，它是所接受的数据的存储位置。</param>
        <param name="size">要接收的字节数。</param>
        <param name="socketFlags"><see cref="T:System.Net.Sockets.SocketFlags" /> 值的按位组合。</param>
        <param name="remoteEP">通过引用传递的 <see cref="T:System.Net.EndPoint" />，表示远程服务器。</param>
        <summary>使用指定的 <see cref="T:System.Net.Sockets.SocketFlags" /> 将指定的字节数接收到数据缓冲区并存储终结点。</summary>
        <returns>收到的字节数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>方法将数据读入 `buffer` 参数，返回成功读取的字节数，并捕获从中发送数据的远程主机终结点。 如果打算从未知主机或多台主机接收无连接的数据报，此方法非常有用。  
  
 此重载只要求你提供接收缓冲区、要接收的字节数、必需的 <xref:System.Net.Sockets.SocketFlags> 以及 <xref:System.Net.EndPoint> 表示远程主机的。 缓冲区偏移量默认为0。  
  
 对于无连接协议， <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 将读取接收到本地网络缓冲区中的第一个排队数据报。 如果接收的数据报大于大小 `buffer` ，则该 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 方法将尽可能多地填充 `buffer` 消息，并引发 <xref:System.Net.Sockets.SocketException> 。 如果使用的是不可靠的协议，则过量的数据将丢失。 如果你使用的是可靠协议，则该服务提供程序将保留多余的数据，并且你可以通过 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 使用足够大的缓冲区调用方法来检索这些数据。  
  
 如果没有可供读取的数据，则该 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 方法将被阻止，直到数据可用。 如果处于非阻止模式，并且在协议堆栈缓冲区中没有可用的数据，则该 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 方法将立即完成并引发 <xref:System.Net.Sockets.SocketException> 。 您可以使用 <xref:System.Net.Sockets.Socket.Available%2A> 属性来确定数据是否可用于读取。 如果 <xref:System.Net.Sockets.Socket.Available%2A> 为非零，则重试接收操作。  
  
 尽管适用 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 于无连接协议，但你也可以使用面向连接的协议。 如果选择这样做，则必须先通过调用方法建立远程主机连接， <xref:System.Net.Sockets.Socket.Connect%2A> 或通过调用方法接受传入的远程主机连接 <xref:System.Net.Sockets.Socket.Accept%2A> 。 如果在调用方法之前未建立或接受连接 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> ，则将获得 <xref:System.Net.Sockets.SocketException> 。 还可以在调用方法之前，为无连接协议建立默认远程主机 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 。 在这两种情况下， <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 方法将忽略 `remoteEP` 参数，并仅从已连接或默认的远程主机接收数据。  
  
 使用面向连接的套接字时， <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 将读取与参数指定的字节数最多的可用数据 `size` 。 如果远程主机 <xref:System.Net.Sockets.Socket> 使用方法关闭连接 <xref:System.Net.Sockets.Socket.Shutdown%2A> 并且收到所有可用数据，则该 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 方法将立即完成并返回零字节。  
  
> [!NOTE]
>  在调用之前 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> ，必须使用方法将显式绑定 <xref:System.Net.Sockets.Socket> 到本地终结点 <xref:System.Net.Sockets.Socket.Bind%2A> 。 否则， <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 将引发 <xref:System.Net.Sockets.SocketException> 。 如果收到 <xref:System.Net.Sockets.SocketException> ，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。 获取此代码后，请参阅 [Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2) 文档，以获取有关错误的详细说明。  
  
> [!NOTE]
>  <xref:System.Net.Sockets.AddressFamily> <xref:System.Net.EndPoint> 中使用的 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 需要与中使用的匹配 <xref:System.Net.Sockets.AddressFamily> <xref:System.Net.EndPoint> <xref:System.Net.Sockets.Socket.SendTo%2A> 。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅 [.NET Framework 中的网络跟踪](/dotnet/framework/network-programming/network-tracing)。  
  
   
  
## Examples  
 下面的代码示例从远程主机接收无连接的数据报。 缓冲区大小和 <xref:System.Net.Sockets.SocketFlags> 被传递给 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 方法。  
  
 [!code-cpp[Socket_Sync_Send_Receive#11](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#11)]
 [!code-csharp[Socket_Sync_Send_Receive#11](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#11)]
 [!code-vb[Socket_Sync_Send_Receive#11](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> 为 <see langword="null" />。  
  
- 或 - 
 <paramref name="remoteEP" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="size" /> 小于 0。  
  
- 或 - 
 <paramref name="size" /> 大于 <paramref name="buffer" />的长度。</exception>
        <exception cref="T:System.Net.Sockets.SocketException"><paramref name="socketFlags" /> 不是有效的值组合。  
  
- 或 - 
未设置 <see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /> 属性。  
  
- 或 - 
访问 <see cref="T:System.Net.Sockets.Socket" /> 时出现操作系统错误。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <exception cref="T:System.Security.SecurityException">调用堆栈中的调用方没有所需的权限。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveFrom">
      <MemberSignature Language="C#" Value="public int ReceiveFrom (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ReceiveFrom(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint&amp; remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveFrom (buffer As Byte(), offset As Integer, size As Integer, socketFlags As SocketFlags, ByRef remoteEP As EndPoint) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ReceiveFrom(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ % remoteEP);" />
      <MemberSignature Language="F#" Value="member this.ReceiveFrom : byte[] * int * int * System.Net.Sockets.SocketFlags * EndPoint -&gt; int" Usage="socket.ReceiveFrom (buffer, offset, size, socketFlags, remoteEP)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" RefType="ref" Index="4" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="buffer">类型 <see cref="T:System.Byte" /> 的数组，它是所接受的数据的存储位置。</param>
        <param name="offset"><paramref name="buffer" /> 参数中的位置，用于存储所接收的数据。</param>
        <param name="size">要接收的字节数。</param>
        <param name="socketFlags"><see cref="T:System.Net.Sockets.SocketFlags" /> 值的按位组合。</param>
        <param name="remoteEP">通过引用传递的 <see cref="T:System.Net.EndPoint" />，表示远程服务器。</param>
        <summary>使用指定的 <see cref="T:System.Net.Sockets.SocketFlags" /> 将指定的数据字节数接收到数据缓冲区的指定位置，并存储终结点。</summary>
        <returns>收到的字节数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>方法将数据读入 `buffer` 参数，返回成功读取的字节数，并捕获从中发送数据的远程主机终结点。 如果打算从未知主机或多台主机接收无连接的数据报，此方法非常有用。  
  
 对于无连接协议， <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 将读取接收到本地网络缓冲区中的第一个排队数据报。 如果接收的数据报大于大小 `buffer` ，则该 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 方法将尽可能多地填充 `buffer` 消息，并引发 <xref:System.Net.Sockets.SocketException> 。 如果使用的是不可靠的协议，则过量的数据将丢失。 如果你使用的是可靠协议，则该服务提供程序将保留多余的数据，并且你可以通过 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 使用足够大的缓冲区调用方法来检索这些数据。  
  
 如果没有可供读取的数据，则该 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 方法将被阻止，直到数据可用。 如果处于非阻止模式，并且在协议堆栈缓冲区中没有可用的数据，则该 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 方法将立即完成并引发 <xref:System.Net.Sockets.SocketException> 。 您可以使用 <xref:System.Net.Sockets.Socket.Available%2A> 属性来确定数据是否可用于读取。 如果 <xref:System.Net.Sockets.Socket.Available%2A> 为非零，则重试接收操作。  
  
 尽管适用 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 于无连接协议，但你也可以使用面向连接的协议。 如果选择这样做，则必须先通过调用方法建立远程主机连接， <xref:System.Net.Sockets.Socket.Connect%2A> 或通过调用方法接受传入的远程主机连接 <xref:System.Net.Sockets.Socket.Accept%2A> 。 如果在调用方法之前未建立或接受连接 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> ，则将获得 <xref:System.Net.Sockets.SocketException> 。 还可以在调用方法之前，为无连接协议建立默认远程主机 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 。 在这两种情况下， <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 方法将忽略 `remoteEP` 参数，并仅从已连接或默认的远程主机接收数据。  
  
 使用面向连接的套接字时， <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 将读取与参数指定的字节量最多的可用数据 `size` 。 如果远程主机 <xref:System.Net.Sockets.Socket> 使用方法关闭连接 <xref:System.Net.Sockets.Socket.Shutdown%2A> 并且收到所有可用数据，则该 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 方法将立即完成并返回零字节。  
  
> [!NOTE]
>  在调用之前 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> ，必须使用方法将显式绑定 <xref:System.Net.Sockets.Socket> 到本地终结点 <xref:System.Net.Sockets.Socket.Bind%2A> 。 否则， <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 将引发 <xref:System.Net.Sockets.SocketException> 。 如果收到 <xref:System.Net.Sockets.SocketException> ，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。 获取此代码后，请参阅 [Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2) 文档，以获取有关错误的详细说明。  
  
> [!NOTE]
>  <xref:System.Net.Sockets.AddressFamily> <xref:System.Net.EndPoint> 中使用的 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 需要与中使用的匹配 <xref:System.Net.Sockets.AddressFamily> <xref:System.Net.EndPoint> <xref:System.Net.Sockets.Socket.SendTo%2A> 。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅 [.NET Framework 中的网络跟踪](/dotnet/framework/network-programming/network-tracing)。  
  
   
  
## Examples  
 下面的代码示例从远程主机接收无连接的数据报。 偏移量、缓冲区大小和 <xref:System.Net.Sockets.SocketFlags> 被传递给 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 方法。  
  
 [!code-cpp[Socket_Sync_Send_Receive#12](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#12)]
 [!code-csharp[Socket_Sync_Send_Receive#12](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#12)]
 [!code-vb[Socket_Sync_Send_Receive#12](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> 为 <see langword="null" />。  
  
- 或 - 
 <paramref name="remoteEP" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" /> 小于 0。  
  
- 或 - 
 <paramref name="offset" /> 大于 <paramref name="buffer" /> 的长度。  
  
- 或 - 
 <paramref name="size" /> 小于 0。  
  
- 或 - 
 <paramref name="size" /> 大于 <paramref name="buffer" /> 的长度减去偏移量参数的值。</exception>
        <exception cref="T:System.Net.Sockets.SocketException"><paramref name="socketFlags" /> 不是有效的值组合。  
  
- 或 - 
未设置 <see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /> 属性。  
  
- 或 - 
尝试访问套接字时出错。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveFromAsync">
      <MemberSignature Language="C#" Value="public bool ReceiveFromAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ReceiveFromAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveFromAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveFromAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ReceiveFromAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.ReceiveFromAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="socket.ReceiveFromAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="e">要用于此异步套接字操作的 <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> 对象。</param>
        <summary>开始从指定网络设备中异步接收数据。</summary>
        <returns>如果 I/O 操作挂起，则为 <see langword="true" />。 操作完成时，将引发 <paramref name="e" /> 参数的 <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> 事件。  
  
 如果 I/O 操作同步完成，则为 <see langword="false" />。 在这种情况下，将不会引发 <paramref name="e" /> 参数的 <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> 事件，并且可能在方法调用返回后立即检查作为参数传递的 <paramref name="e" /> 对象以检索操作的结果。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A>方法主要用于接收无连接套接字上的数据。 套接字的本地地址必须是已知的。  
  
 调用方必须将 <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> 属性设置为从中 <xref:System.Net.IPEndPoint> 接收数据的远程主机的。  
  
 <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags%2A?displayProperty=nameWithType>参数上的属性为 `e` 窗口套接字服务提供程序提供有关读取请求的其他信息。 有关如何使用此参数的详细信息，请参阅 <xref:System.Net.Sockets.SocketFlags?displayProperty=nameWithType> 。  
  
 <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType>若要成功调用此方法，必须具有对象上的下列属性和事件：  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
 调用方可以 <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> 在调用方法之前将属性设置为所需的任何用户状态对象 <xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A> ，以便可以在回调方法中检索信息。 如果回调需要比单个对象更多的信息，则可以创建一个小类，以将其他所需的状态信息保存为成员。  
  
 对于面向消息的套接字，传入消息会放入缓冲区中，直到缓冲区的总大小。 <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType>和 <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType> 属性确定数据放置在缓冲区中的位置以及数据量。  
  
 对于字节流样式的套接字，传入的数据将被放入缓冲区中，直到缓冲区填充完毕、连接关闭或内部缓冲的数据被耗尽。 <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType>和 <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType> 属性确定数据放置在缓冲区中的位置以及数据量。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> 不能为 null。</exception>
        <exception cref="T:System.InvalidOperationException">已经在使用 <paramref name="e" /> 参数中指定的 <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> 对象执行套接字操作。</exception>
        <exception cref="T:System.NotSupportedException">此方法需要 Windows XP 或更高版本。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Offset" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveMessageFrom">
      <MemberSignature Language="C#" Value="public int ReceiveMessageFrom (byte[] buffer, int offset, int size, ref System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint remoteEP, out System.Net.Sockets.IPPacketInformation ipPacketInformation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ReceiveMessageFrom(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags&amp; socketFlags, class System.Net.EndPoint&amp; remoteEP, [out] valuetype System.Net.Sockets.IPPacketInformation&amp; ipPacketInformation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveMessageFrom (buffer As Byte(), offset As Integer, size As Integer, ByRef socketFlags As SocketFlags, ByRef remoteEP As EndPoint, ByRef ipPacketInformation As IPPacketInformation) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ReceiveMessageFrom(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags % socketFlags, System::Net::EndPoint ^ % remoteEP, [Runtime::InteropServices::Out] System::Net::Sockets::IPPacketInformation % ipPacketInformation);" />
      <MemberSignature Language="F#" Value="member this.ReceiveMessageFrom : byte[] * int * int * SocketFlags * EndPoint * IPPacketInformation -&gt; int" Usage="socket.ReceiveMessageFrom (buffer, offset, size, socketFlags, remoteEP, ipPacketInformation)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.MonoTODO("Not implemented")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.MonoTODO("Not implemented")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" RefType="ref" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" RefType="ref" Index="4" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="ipPacketInformation" Type="System.Net.Sockets.IPPacketInformation" RefType="out" Index="5" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="buffer">类型 <see cref="T:System.Byte" /> 的数组，它是所接受的数据的存储位置。</param>
        <param name="offset"><paramref name="buffer" /> 参数中的位置，用于存储所接收的数据。</param>
        <param name="size">要接收的字节数。</param>
        <param name="socketFlags"><see cref="T:System.Net.Sockets.SocketFlags" /> 值的按位组合。</param>
        <param name="remoteEP">通过引用传递的 <see cref="T:System.Net.EndPoint" />，表示远程服务器。</param>
        <param name="ipPacketInformation">保存地址和接口信息的 <see cref="T:System.Net.Sockets.IPPacketInformation" />。</param>
        <summary>使用指定的 <see cref="T:System.Net.Sockets.SocketFlags" /> 将指定字节数的数据接收到指定的数据缓冲区位置，并存储终结点和数据包信息。</summary>
        <returns>收到的字节数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A>方法将数据读取到 `buffer` 参数中，返回成功读取的字节数，并捕获从其发送数据的远程主机终结点以及有关已接收数据包的信息。  
  
 <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A>方法主要用于接收无连接套接字上的消息数据。 套接字的本地地址必须是已知的。 此方法只能用于数据报和原始套接字。 在 <xref:System.Net.Sockets.SocketType.Dgram> <xref:System.Net.Sockets.SocketType.Raw> 调用此方法之前，必须用设置为或的套接字类型初始化套接字。 当使用构造套接字时，可以执行此操作 <xref:System.Net.Sockets.Socket.%23ctor%2A> 。  
  
 对于面向消息的套接字，会将传入消息放入 `buffer` 参数中指定的总大小 `size` 。 `offset`参数确定数据中放置的位置 `buffer` 。 放置在中的实际数据量 `buffer` 由 <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> 方法返回。  
  
 <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A>方法自动方法将 <xref:System.Net.Sockets.SocketOptionName.PacketInformation> 套接字选项设置为 `true` 第一次调用给定的 <xref:System.Net.Sockets.Socket> 。 但是，只有在 <xref:System.Net.Sockets.IPPacketInformation> 设置了套接字选项后，返回的对象才会对到达本地计算机的数据包有效。 如果套接字是在绑定到本地终结点时通过方法显式 (<xref:System.Net.Sockets.Socket.Bind%2A> 或由) 的其中一个 <xref:System.Net.Sockets.Socket.Connect%2A> 、、或方法隐式发送的， <xref:System.Net.Sockets.Socket.ConnectAsync%2A> <xref:System.Net.Sockets.Socket.SendTo%2A> <xref:System.Net.Sockets.Socket.SendToAsync%2A> 并且第一次调用方法，则对 <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> 方法的调用将 <xref:System.Net.Sockets.IPPacketInformation> 为这些数据包返回无效对象。  
  
 若要确保所有 <xref:System.Net.Sockets.IPPacketInformation> 对象均有效，应用程序应在 <xref:System.Net.Sockets.SocketOptionName.PacketInformation> 使用方法将套接字选项 `true` 绑定到本地终结点之前将其设置为 <xref:System.Net.Sockets.Socket.SetSocketOption%28System.Net.Sockets.SocketOptionLevel%2CSystem.Net.Sockets.SocketOptionName%2CSystem.Boolean%29> 。  
  
 如果某个应用程序 `ipPacketInformation` 需要知道是否使用单播、多播或广播地址发送了数据报，则该应用程序可以检查该参数。  
  
> [!NOTE]
>  <xref:System.Net.Sockets.AddressFamily> <xref:System.Net.EndPoint> 中使用的 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 需要与中使用的匹配 <xref:System.Net.Sockets.AddressFamily> <xref:System.Net.EndPoint> <xref:System.Net.Sockets.Socket.SendTo%2A> 。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅 [.NET Framework 中的网络跟踪](/dotnet/framework/network-programming/network-tracing)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> 为 <see langword="null" />。  
  
- 或 - 
 <paramref name="remoteEP" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" /> 小于 0。  
  
- 或 - 
 <paramref name="offset" /> 大于 <paramref name="buffer" /> 的长度。  
  
- 或 - 
 <paramref name="size" /> 小于 0。  
  
- 或 - 
 <paramref name="size" /> 大于 <paramref name="buffer" /> 的长度减去偏移量参数的值。</exception>
        <exception cref="T:System.Net.Sockets.SocketException"><paramref name="socketFlags" /> 不是有效的值组合。  
  
- 或 - 
未设置 <see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /> 属性。  
  
- 或 - 
.NET Framework 运行在 AMD 64 位处理器上。  
  
- 或 - 
尝试访问套接字时出错。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveMessageFromAsync">
      <MemberSignature Language="C#" Value="public bool ReceiveMessageFromAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ReceiveMessageFromAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveMessageFromAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveMessageFromAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ReceiveMessageFromAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.ReceiveMessageFromAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="socket.ReceiveMessageFromAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.MonoTODO("Not implemented")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.MonoTODO("Not implemented")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="e">要用于此异步套接字操作的 <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> 对象。</param>
        <summary>开始使用指定的 <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags" /> 将指定字节数的数据异步接收到数据缓冲区的指定位置，并存储终结点和数据包信息。</summary>
        <returns>如果 I/O 操作挂起，则为 <see langword="true" />。 操作完成时，将引发 <paramref name="e" /> 参数的 <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> 事件。  
  
 如果 I/O 操作同步完成，则为 <see langword="false" />。 在这种情况下，将不会引发 <paramref name="e" /> 参数的 <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> 事件，并且可能在方法调用返回后立即检查作为参数传递的 <paramref name="e" /> 对象以检索操作的结果。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A>方法主要用于接收无连接套接字上的消息数据。 套接字的本地地址必须是已知的。 此方法只能用于数据报和原始套接字。 在 <xref:System.Net.Sockets.SocketType.Dgram> <xref:System.Net.Sockets.SocketType.Raw> 调用此方法之前，必须用设置为或的套接字类型初始化套接字。 当使用构造套接字时，可以执行此操作 <xref:System.Net.Sockets.Socket.%23ctor%2A> 。  
  
 调用方必须将 <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> 属性设置为从中 <xref:System.Net.IPEndPoint> 接收数据的远程主机的。  
  
 <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType>若要成功调用此方法，必须具有对象上的下列属性和事件：  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
 调用方可以 <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> 在调用方法之前将属性设置为所需的任何用户状态对象 <xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A> ，以便可以在回调方法中检索信息。 如果回调需要比单个对象更多的信息，则可以创建一个小类，以将其他所需的状态信息保存为成员。  
  
 对于面向消息的套接字，传入消息会放入缓冲区中，直到缓冲区的总大小。 <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType>和 <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType> 属性确定数据放置在缓冲区中的位置以及数据量。  
  
 <xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A>方法会在 <xref:System.Net.Sockets.SocketOptionName.PacketInformation> `true` 第一次为给定指定时将套接字选项自动设置为 <xref:System.Net.Sockets.Socket> 。 但是，在 <xref:System.Net.Sockets.IPPacketInformation> 设置套接字选项后，对象将仅对到达本地计算机的数据包有效。 如果套接字是在将套接字绑定到本地终结点时通过方法显式 (的 <xref:System.Net.Sockets.Socket.Bind%2A> ，或由 <xref:System.Net.Sockets.Socket.Connect%2A>) 和第一次调用方法隐式传递的，则对 <xref:System.Net.Sockets.Socket.ConnectAsync%2A> 方法的 <xref:System.Net.Sockets.Socket.SendTo%2A> <xref:System.Net.Sockets.Socket.SendToAsync%2A> <xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A> 调用 <xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A> 将导致 <xref:System.Net.Sockets.IPPacketInformation> 这些包的对象无效。  
  
 若要确保所有 <xref:System.Net.Sockets.IPPacketInformation> 对象均有效，应用程序应在 <xref:System.Net.Sockets.SocketOptionName.PacketInformation> 使用方法将套接字选项 `true` 绑定到本地终结点之前将其设置为 <xref:System.Net.Sockets.Socket.SetSocketOption%28System.Net.Sockets.SocketOptionLevel%2CSystem.Net.Sockets.SocketOptionName%2CSystem.Boolean%29> 。  
  
 如果应用程序 <xref:System.Net.Sockets.IPPacketInformation> 需要知道是否使用单播、多播或广播地址发送了数据报，则该应用程序可以检查产生的对象。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> 不能为 null。</exception>
        <exception cref="T:System.NotSupportedException">此方法需要 Windows XP 或更高版本。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Offset" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveTimeout">
      <MemberSignature Language="C#" Value="public int ReceiveTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ReceiveTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.ReceiveTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Property ReceiveTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ReceiveTimeout { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.ReceiveTimeout : int with get, set" Usage="System.Net.Sockets.Socket.ReceiveTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指定之后同步 <see cref="Overload:System.Net.Sockets.Socket.Receive" /> 调用将超时的时间长度。</summary>
        <value>超时值（以毫秒为单位）。 默认值为 0，指示超时期限无限大。 指定 -1 还会指示超时期限无限大。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此选项仅适用于同步 <xref:System.Net.Sockets.Socket.Receive%2A> 调用。 如果超过超时期限，该 <xref:System.Net.Sockets.Socket.Receive%2A> 方法将引发 <xref:System.Net.Sockets.SocketException> 。  
  
   
  
## Examples  
 下面的代码示例演示属性的用法 <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A> 。  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">为设置操作指定的值小于 1。</exception>
      </Docs>
    </Member>
    <Member MemberName="RemoteEndPoint">
      <MemberSignature Language="C#" Value="public System.Net.EndPoint RemoteEndPoint { get; }" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.EndPoint RemoteEndPoint" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.RemoteEndPoint" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RemoteEndPoint As EndPoint" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::EndPoint ^ RemoteEndPoint { System::Net::EndPoint ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.RemoteEndPoint : System.Net.EndPoint" Usage="System.Net.Sockets.Socket.RemoteEndPoint" />
      <MemberSignature Language="C#" Value="public System.Net.EndPoint? RemoteEndPoint { get; }" FrameworkAlternate="net-5.0" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.EndPoint</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取远程终结点。</summary>
        <value>当前和 <see cref="T:System.Net.EndPoint" /> 通信的 <see cref="T:System.Net.Sockets.Socket" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果使用面向连接的协议，则 <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> 属性将获取 <xref:System.Net.EndPoint> ，其中包含连接到的远程 IP 地址和端口号 <xref:System.Net.Sockets.Socket> 。 如果使用的是无连接协议，则 <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> 包含将与之通信的默认远程 IP 地址和端口号 <xref:System.Net.Sockets.Socket> 。 在 <xref:System.Net.EndPoint> <xref:System.Net.IPEndPoint> 检索任何信息之前，必须将此转换为。 然后，可以调用 <xref:System.Net.IPEndPoint.Address%2A?displayProperty=nameWithType> 方法来检索远程 <xref:System.Net.IPAddress> 端口号，并调用 <xref:System.Net.IPEndPoint.Port%2A?displayProperty=nameWithType> 方法来检索远程端口号。  
  
 在 <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> 调用或之后设置 <xref:System.Net.Sockets.Socket.Accept%2A> <xref:System.Net.Sockets.Socket.Connect%2A> 。 如果你之前尝试访问此属性， <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> 将引发 <xref:System.Net.Sockets.SocketException> 。 如果收到 <xref:System.Net.Sockets.SocketException> ，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。 获取此代码后，请参阅 [Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2) 文档，以获取有关错误的详细说明。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅 [.NET Framework 中的网络跟踪](/dotnet/framework/network-programming/network-tracing)。  
  
   
  
## Examples  
 下面的代码示例检索并显示本地和远程终结点。  
  
 [!code-cpp[Socket_Socket_Options#4](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#4)]
 [!code-csharp[Socket_Socket_Options#4](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#4)]
 [!code-vb[Socket_Socket_Options#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <altmember cref="T:System.Net.EndPoint" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Accept" />
      </Docs>
    </Member>
    <Member MemberName="SafeHandle">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.SafeSocketHandle SafeHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.Sockets.SafeSocketHandle SafeHandle" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.SafeHandle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SafeHandle As SafeSocketHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Sockets::SafeSocketHandle ^ SafeHandle { System::Net::Sockets::SafeSocketHandle ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SafeHandle : System.Net.Sockets.SafeSocketHandle" Usage="System.Net.Sockets.Socket.SafeHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.SafeSocketHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个 <see cref="T:System.Net.Sockets.SafeSocketHandle" />，它表示当前 <see cref="T:System.Net.Sockets.Socket" /> 对象封装的套接字句柄。</summary>
        <value>以安全方式公开当前对象封装的套接字的套接字句柄 <see cref="T:System.Net.Sockets.Socket" /> 。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  

> [!IMPORTANT]
> 使用 <xref:System.Net.Sockets.SafeSocketHandle> 直接对套接字进行操作可能会导致未记录状态。 

         ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Select">
      <MemberSignature Language="C#" Value="public static void Select (System.Collections.IList checkRead, System.Collections.IList checkWrite, System.Collections.IList checkError, int microSeconds);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Select(class System.Collections.IList checkRead, class System.Collections.IList checkWrite, class System.Collections.IList checkError, int32 microSeconds) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Select(System.Collections.IList,System.Collections.IList,System.Collections.IList,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Select (checkRead As IList, checkWrite As IList, checkError As IList, microSeconds As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Select(System::Collections::IList ^ checkRead, System::Collections::IList ^ checkWrite, System::Collections::IList ^ checkError, int microSeconds);" />
      <MemberSignature Language="F#" Value="static member Select : System.Collections.IList * System.Collections.IList * System.Collections.IList * int -&gt; unit" Usage="System.Net.Sockets.Socket.Select (checkRead, checkWrite, checkError, microSeconds)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="checkRead" Type="System.Collections.IList" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="checkWrite" Type="System.Collections.IList" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="checkError" Type="System.Collections.IList" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="microSeconds" Type="System.Int32" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="checkRead">用于检查可读性的 <see cref="T:System.Net.Sockets.Socket" /> 实例的 <see cref="T:System.Collections.IList" />。</param>
        <param name="checkWrite">用于检查可写性的 <see cref="T:System.Net.Sockets.Socket" /> 实例的 <see cref="T:System.Collections.IList" />。</param>
        <param name="checkError">用于检查错误的 <see cref="T:System.Net.Sockets.Socket" /> 实例的 <see cref="T:System.Collections.IList" />。</param>
        <param name="microSeconds">超时值（以微秒为单位）。 值 -1 指示无限超时。</param>
        <summary>确定一个或多个套接字的状态。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Select%2A> 是一个静态方法，用于确定一个或多个实例的状态 <xref:System.Net.Sockets.Socket> 。 必须将一个或多个套接字置于中， <xref:System.Collections.IList> 然后才能使用 <xref:System.Net.Sockets.Socket.Select%2A> 方法。 通过调用作为参数来检查是否有可读性 <xref:System.Net.Sockets.Socket.Select%2A> <xref:System.Collections.IList> `checkRead` 。 若要查看可写性的套接字，请使用 `checkWrite` 参数。 对于检测错误条件，请使用 `checkError` 。 调用后 <xref:System.Net.Sockets.Socket.Select%2A> ， <xref:System.Collections.IList> 将只填充满足条件的那些套接字。  
  
 如果你处于侦听状态，则可读性意味着对的调用 <xref:System.Net.Sockets.Socket.Accept%2A> 将成功，而不会受到阻止。 如果已接受连接，则可读性意味着数据可用于读取。 在这些情况下，所有接收操作都将成功，但不会被阻止。 可读性还可指示遥控器是否 <xref:System.Net.Sockets.Socket> 关闭了连接; 在这种情况下，对的调用 <xref:System.Net.Sockets.Socket.Receive%2A> 将立即返回，并返回零个字节。  
  
 <xref:System.Net.Sockets.Socket.Select%2A> 当、和列表中的套接字 `checkRead` `checkWrite` `checkError`) 满足指定的条件，或者 `microSeconds` 超出了参数（以第一个为准）时， (将返回。 设置 `microSeconds` 为-1 表示无限期超时。  
  
 如果对进行非阻止调用 <xref:System.Net.Sockets.Socket.Connect%2A> ，则可写性表示已成功连接。 如果已建立连接，可写性意味着所有发送操作都将成功，且不会阻止。  
  
 如果已进行非阻塞调用 <xref:System.Net.Sockets.Socket.Connect%2A> ，则 `checkerror` 参数将标识未成功连接的套接字。  
  
> [!NOTE]
>  <xref:System.Net.Sockets.Socket.Poll%2A>如果只想确定单个的状态，请使用方法 <xref:System.Net.Sockets.Socket> 。  
  
> [!NOTE]
>  此方法无法检测某些类型的连接问题，例如网络电缆损坏或远程主机已关闭意外。 您必须尝试发送或接收数据，以检测这些类型的错误。  
  
> [!NOTE]
>  如果收到 <xref:System.Net.Sockets.SocketException> ，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。 获取此代码后，请参阅 [Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2) 文档，以获取有关错误的详细说明。  
  
   
  
## Examples  
 下面的代码示例使用 <xref:System.Net.Sockets.Socket.Select%2A> 来确定哪些侦听套接字具有连接请求。  
  
 [!code-cpp[Socket_Select#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Select/CPP/source.cpp#1)]
 [!code-csharp[Socket_Select#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Select/CS/source.cs#1)]
 [!code-vb[Socket_Select#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Select/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="checkRead" /> 参数为 <see langword="null" /> 或为空。  
  
－和－ 
<paramref name="checkWrite" /> 参数为 <see langword="null" /> 或为空 
－和－ 
<paramref name="checkError" /> 参数为 <see langword="null" /> 或为空。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.ObjectDisposedException">.NET 5.0 及更高版本：释放一个或多个套接字。</exception>
        <altmember cref="T:System.Collections.IList" />
        <altmember cref="M:System.Net.Sockets.Socket.Accept" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Send">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>将数据发送到连接的 <see cref="T:System.Net.Sockets.Socket" />。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (byte[] buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(unsigned int8[] buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Send (buffer As Byte()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(cli::array &lt;System::Byte&gt; ^ buffer);" />
      <MemberSignature Language="F#" Value="member this.Send : byte[] -&gt; int" Usage="socket.Send buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="buffer">类型 <see cref="T:System.Byte" /> 的数组，其中包含要发送的数据。</param>
        <summary>将数据发送到连接的 <see cref="T:System.Net.Sockets.Socket" />。</summary>
        <returns>发送到 <see cref="T:System.Net.Sockets.Socket" /> 的字节数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Send%2A> 将数据同步发送到或方法中指定的远程主机 <xref:System.Net.Sockets.Socket.Connect%2A> <xref:System.Net.Sockets.Socket.Accept%2A> ，并返回成功发送的字节数。 <xref:System.Net.Sockets.Socket.Send%2A> 可用于面向连接的协议和无连接的协议。  
  
 此重载需要包含要发送的数据的缓冲区。 <xref:System.Net.Sockets.SocketFlags>默认值为0，缓冲区偏移量默认为0，要发送的字节数默认为缓冲区的大小。  
  
 如果使用的是无连接协议，则必须在 <xref:System.Net.Sockets.Socket.Connect%2A> 调用此方法之前调用，否则 <xref:System.Net.Sockets.Socket.Send%2A> 将引发 <xref:System.Net.Sockets.SocketException> 。 如果使用面向连接的协议，则必须使用 <xref:System.Net.Sockets.Socket.Connect%2A> 建立远程主机连接，或使用 <xref:System.Net.Sockets.Socket.Accept%2A> 来接受传入连接。  
  
 如果使用的是无连接协议并计划将数据发送到多个不同的主机，则应使用 <xref:System.Net.Sockets.Socket.SendTo%2A> 方法。 如果不使用 <xref:System.Net.Sockets.Socket.SendTo%2A> 方法，则必须 <xref:System.Net.Sockets.Socket.Connect%2A> 在每次调用前调用 <xref:System.Net.Sockets.Socket.Send%2A> 。 <xref:System.Net.Sockets.Socket.SendTo%2A>即使已使用建立默认远程主机，也可以使用 <xref:System.Net.Sockets.Socket.Connect%2A> 。 你还可以通过调用来更改默认远程主机，然后再调用 <xref:System.Net.Sockets.Socket.Send%2A> <xref:System.Net.Sockets.Socket.Connect%2A> 。  
  
 如果使用面向连接的协议， <xref:System.Net.Sockets.Socket.Send%2A> 则会一直阻止，直到发送了缓冲区中的所有字节，除非使用设置了超时 <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType> 。 如果超过超时值，则 <xref:System.Net.Sockets.Socket.Send%2A> 调用将引发 <xref:System.Net.Sockets.SocketException> 。 在非阻止模式下， <xref:System.Net.Sockets.Socket.Send%2A> 即使发送的字节数小于缓冲区中的字节数，也可能成功完成。 应用程序负责跟踪发送的字节数，并在应用程序发送缓冲区中的字节之前重试该操作。 还不能保证发送的数据会立即显示在网络上。 为了提高网络效率，基础系统可能会延迟传输，直到收集大量传出数据。 此方法成功完成 <xref:System.Net.Sockets.Socket.Send%2A> 意味着基础系统具有空间来缓冲用于网络发送的数据。  
  
> [!NOTE]
>  如果收到 <xref:System.Net.Sockets.SocketException> ，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。 获取此代码后，请参阅 [Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2) 文档，以获取有关错误的详细说明。  
  
> [!NOTE]
>  成功完成发送并不表示数据已成功传递。 如果传输系统中没有可用于保存要传输的数据的缓冲区空间，则发送将会阻止，除非已将套接字置于非阻止模式。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅 [.NET Framework 中的网络跟踪](/dotnet/framework/network-programming/network-tracing)。  
  
   
  
## Examples  
 下面的代码示例演示如何在连接的上发送数据 <xref:System.Net.Sockets.Socket> 。  
  
 [!code-cpp[Socket_Sync_Send_Receive#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#1)]
 [!code-csharp[Socket_Sync_Send_Receive#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#1)]
 [!code-vb[Socket_Sync_Send_Receive#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt;? buffers);" FrameworkAlternate="net-5.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})" />
      <MemberSignature Language="VB.NET" Value="Public Function Send (buffers As IList(Of ArraySegment(Of Byte))) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers);" />
      <MemberSignature Language="F#" Value="member this.Send : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; -&gt; int" Usage="socket.Send buffers" />
      <MemberSignature Language="C#" Value="public int Send (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="buffers"><see cref="T:System.ArraySegment`1" /> 类型的 <see cref="T:System.Byte" /> 的列表，它包含要发送的数据。</param>
        <summary>将列表中的一组缓冲区发送到连接的 <see cref="T:System.Net.Sockets.Socket" />。</summary>
        <returns>发送到 <see cref="T:System.Net.Sockets.Socket" /> 的字节数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Send%2A> 可用于面向连接的协议和无连接的协议。  
  
 此重载至少需要一个包含要发送的数据的缓冲区。  
  
 如果使用的是无连接协议，则必须在 <xref:System.Net.Sockets.Socket.Connect%2A> 调用此方法之前调用，否则 <xref:System.Net.Sockets.Socket.Send%2A> 将引发 <xref:System.Net.Sockets.SocketException> 。 如果使用面向连接的协议，则必须使用 <xref:System.Net.Sockets.Socket.Connect%2A> 建立远程主机连接，或使用 <xref:System.Net.Sockets.Socket.Accept%2A> 来接受传入连接。  
  
 如果使用的是无连接协议并计划将数据发送到多个不同的主机，则应使用 <xref:System.Net.Sockets.Socket.SendTo%2A> 方法。 如果不使用 <xref:System.Net.Sockets.Socket.SendTo%2A> 方法，则必须 <xref:System.Net.Sockets.Socket.Connect%2A> 在每次调用前调用 <xref:System.Net.Sockets.Socket.Send%2A> 。 <xref:System.Net.Sockets.Socket.SendTo%2A>即使已使用建立默认远程主机，也可以使用 <xref:System.Net.Sockets.Socket.Connect%2A> 。 你还可以通过调用来更改默认远程主机，然后再调用 <xref:System.Net.Sockets.Socket.Send%2A> <xref:System.Net.Sockets.Socket.Connect%2A> 。  
  
 如果使用面向连接的协议， <xref:System.Net.Sockets.Socket.Send%2A> 则会一直阻止，直到发送了缓冲区中的所有字节，除非使用设置了超时 <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType> 。 如果超过超时值，则 <xref:System.Net.Sockets.Socket.Send%2A> 调用将引发 <xref:System.Net.Sockets.SocketException> 。 在非阻止模式下， <xref:System.Net.Sockets.Socket.Send%2A> 即使发送的字节数小于缓冲区中的字节数，也可能成功完成。 应用程序负责跟踪发送的字节数，并在应用程序发送缓冲区中的字节之前重试该操作。 还不能保证发送的数据会立即显示在网络上。 为了提高网络效率，基础系统可能会延迟传输，直到收集大量传出数据。 此方法成功完成 <xref:System.Net.Sockets.Socket.Send%2A> 意味着基础系统具有空间来缓冲用于网络发送的数据。  
  
> [!NOTE]
>  如果收到 <xref:System.Net.Sockets.SocketException> ，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。 获取此代码后，请参阅 [Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2) 文档，以获取有关错误的详细说明。  
  
> [!NOTE]
>  成功完成发送并不表示数据已成功传递。 如果传输系统中没有可用于保存要传输的数据的缓冲区空间，则发送将会阻止，除非已将套接字置于非阻止模式。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅 [.NET Framework 中的网络跟踪](/dotnet/framework/network-programming/network-tracing)。  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Net.Sockets.Socket.Send(System.Byte[])" />
        <exception cref="T:System.ArgumentNullException"><paramref name="buffers" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="buffers" /> 为空。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。 请参见下面的备注部分。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (ReadOnlySpan&lt;byte&gt; buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.ReadOnlySpan{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Function Send (buffer As ReadOnlySpan(Of Byte)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(ReadOnlySpan&lt;System::Byte&gt; buffer);" />
      <MemberSignature Language="F#" Value="member this.Send : ReadOnlySpan&lt;byte&gt; -&gt; int" Usage="socket.Send buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="buffer">一个字符范围，其中包含要发送的数据。</param>
        <summary>将数据发送到连接的 <see cref="T:System.Net.Sockets.Socket" />。</summary>
        <returns>发送到 <see cref="T:System.Net.Sockets.Socket" /> 的字节数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks

<xref:System.Net.Sockets.Socket.Send%2A> 将数据同步发送到或方法中指定的远程主机 <xref:System.Net.Sockets.Socket.Connect%2A> <xref:System.Net.Sockets.Socket.Accept%2A> ，并返回成功发送的字节数。 <xref:System.Net.Sockets.Socket.Send%2A> 可用于面向连接的协议和无连接的协议。

此重载需要包含要发送的数据的缓冲区。 <xref:System.Net.Sockets.SocketFlags>默认值为0，缓冲区偏移量默认为0，要发送的字节数默认为缓冲区的大小。

如果使用的是无连接协议，则必须在 <xref:System.Net.Sockets.Socket.Connect%2A> 调用此方法之前调用，否则 <xref:System.Net.Sockets.Socket.Send%2A> 将引发 <xref:System.Net.Sockets.SocketException> 。 如果使用面向连接的协议，则必须使用 <xref:System.Net.Sockets.Socket.Connect%2A> 建立远程主机连接，或使用 <xref:System.Net.Sockets.Socket.Accept%2A> 来接受传入连接。

如果使用的是无连接协议并计划将数据发送到多个不同的主机，则应使用 <xref:System.Net.Sockets.Socket.SendTo%2A> 方法。 如果不使用 <xref:System.Net.Sockets.Socket.SendTo%2A> 方法，则必须在 <xref:System.Net.Sockets.Socket.Connect%2A> 每次调用前调用 <xref:System.Net.Sockets.Socket.Send%2A> 。 <xref:System.Net.Sockets.Socket.SendTo%2A>即使已使用建立默认远程主机，也可以使用 <xref:System.Net.Sockets.Socket.Connect%2A> 。 你还可以通过调用来更改默认远程主机，然后再调用 <xref:System.Net.Sockets.Socket.Send%2A> <xref:System.Net.Sockets.Socket.Connect%2A> 。

如果使用面向连接的协议， <xref:System.Net.Sockets.Socket.Send%2A> 则会一直阻止到发送缓冲区中的所有字节，除非使用设置了超时 <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType> 。 如果超过超时值，则 <xref:System.Net.Sockets.Socket.Send%2A> 调用将引发 <xref:System.Net.Sockets.SocketException> 。 在非阻止模式下， <xref:System.Net.Sockets.Socket.Send%2A> 即使发送的字节数小于缓冲区中的字节数，也可能成功完成。 应用程序负责跟踪发送的字节数，并在应用程序发送缓冲区中的字节之前重试该操作。 还不能保证发送的数据会立即显示在网络上。 为了提高网络效率，基础系统可能会延迟传输，直到收集大量传出数据。 此方法成功完成 <xref:System.Net.Sockets.Socket.Send%2A> 意味着基础系统具有空间来缓冲用于网络发送的数据。

> [!NOTE]
>如果收到 <xref:System.Net.Sockets.SocketException> ，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。 获取此代码后，请参阅 [Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2) 文档，以获取有关错误的详细说明。

当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅 [.NET Framework 中的网络跟踪](/dotnet/framework/network-programming/network-tracing)。

> [!IMPORTANT]
>成功完成发送并不表示数据已成功传递。 如果传输系统中没有可用于保存要传输的数据的缓冲区空间，则发送将会阻止，除非已将套接字置于非阻止模式。
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (byte[] buffer, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(unsigned int8[] buffer, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Function Send (buffer As Byte(), socketFlags As SocketFlags) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(cli::array &lt;System::Byte&gt; ^ buffer, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Send : byte[] * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Send (buffer, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="buffer">类型 <see cref="T:System.Byte" /> 的数组，其中包含要发送的数据。</param>
        <param name="socketFlags"><see cref="T:System.Net.Sockets.SocketFlags" /> 值的按位组合。</param>
        <summary>使用指定的 <see cref="T:System.Net.Sockets.Socket" /> 将数据发送到连接的 <see cref="T:System.Net.Sockets.SocketFlags" />。</summary>
        <returns>发送到 <see cref="T:System.Net.Sockets.Socket" /> 的字节数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Send%2A> 将数据同步发送到或方法中建立的远程主机 <xref:System.Net.Sockets.Socket.Connect%2A> <xref:System.Net.Sockets.Socket.Accept%2A> ，并返回成功发送的字节数。 <xref:System.Net.Sockets.Socket.Send%2A>方法可用于面向连接的协议和无连接的协议。  
  
 此重载需要包含要发送的数据的缓冲区和的按位组合 <xref:System.Net.Sockets.SocketFlags> 。 缓冲区偏移量默认为0，要发送的字节数默认为缓冲区的大小。 如果 <xref:System.Net.Sockets.SocketFlags.DontRoute> 将标志指定为 `socketflags` 参数值，则将不路由要发送的数据。  
  
 如果使用的是无连接协议，则必须在 <xref:System.Net.Sockets.Socket.Connect%2A> 调用此方法之前调用，否则 <xref:System.Net.Sockets.Socket.Send%2A> 将引发 <xref:System.Net.Sockets.SocketException> 。 如果使用面向连接的协议，则必须使用 <xref:System.Net.Sockets.Socket.Connect%2A> 建立远程主机连接，或使用 <xref:System.Net.Sockets.Socket.Accept%2A> 来接受传入连接。  
  
 如果使用的是无连接协议并计划将数据发送到多个不同的主机，则应使用 <xref:System.Net.Sockets.Socket.SendTo%2A> 方法。 如果不使用 <xref:System.Net.Sockets.Socket.SendTo%2A> 方法，则必须在 <xref:System.Net.Sockets.Socket.Connect%2A> 每次调用之前调用方法 <xref:System.Net.Sockets.Socket.Send%2A> 。 <xref:System.Net.Sockets.Socket.SendTo%2A>即使已使用建立默认远程主机，也可以使用 <xref:System.Net.Sockets.Socket.Connect%2A> 。 你还可以通过调用来更改默认远程主机，然后再调用 <xref:System.Net.Sockets.Socket.Send%2A> <xref:System.Net.Sockets.Socket.Connect%2A> 。  
  
 如果使用面向连接的协议， <xref:System.Net.Sockets.Socket.Send%2A> 则会一直阻止，直到发送了缓冲区中的所有字节，除非使用设置了超时 <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType> 。 如果超过超时值，则 <xref:System.Net.Sockets.Socket.Send%2A> 调用将引发 <xref:System.Net.Sockets.SocketException> 。 在非阻止模式下， <xref:System.Net.Sockets.Socket.Send%2A> 即使发送的字节数小于缓冲区中的字节数，也可能成功完成。 应用程序负责跟踪发送的字节数，并重试操作，直到应用程序发送请求的字节数。 还不能保证发送的数据会立即显示在网络上。 为了提高网络效率，基础系统可能会延迟传输，直到收集大量传出数据。 此方法成功完成 <xref:System.Net.Sockets.Socket.Send%2A> 意味着基础系统具有空间来缓冲用于网络发送的数据。  
  
> [!NOTE]
>  必须确保缓冲区的大小不超过基础服务提供程序的最大数据包大小。 如果是这样，则不会发送数据报并 <xref:System.Net.Sockets.Socket.Send%2A> 将引发 <xref:System.Net.Sockets.SocketException> 。 如果收到 <xref:System.Net.Sockets.SocketException> ，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。 获取此代码后，请参阅 [Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2) 文档，以获取有关错误的详细说明。  
  
> [!NOTE]
>  成功完成发送并不表示数据已成功传递。 如果传输系统中没有可用于保存要传输的数据的缓冲区空间，则发送将会阻止，除非已将套接字置于非阻止模式。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅 [.NET Framework 中的网络跟踪](/dotnet/framework/network-programming/network-tracing)。  
  
   
  
## Examples  
 下面的代码示例演示如何在连接的上发送数据 <xref:System.Net.Sockets.Socket> 。  
  
 [!code-cpp[Socket_Sync_Send_Receive#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#2)]
 [!code-csharp[Socket_Sync_Send_Receive#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#2)]
 [!code-vb[Socket_Sync_Send_Receive#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt;? buffers, System.Net.Sockets.SocketFlags socketFlags);" FrameworkAlternate="net-5.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Function Send (buffers As IList(Of ArraySegment(Of Byte)), socketFlags As SocketFlags) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Send : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Send (buffers, socketFlags)" />
      <MemberSignature Language="C#" Value="public int Send (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="buffers"><see cref="T:System.ArraySegment`1" /> 类型的 <see cref="T:System.Byte" /> 的列表，它包含要发送的数据。</param>
        <param name="socketFlags"><see cref="T:System.Net.Sockets.SocketFlags" /> 值的按位组合。</param>
        <summary>使用指定的 <see cref="T:System.Net.Sockets.Socket" />，将列表中的一组缓冲区发送到连接的 <see cref="T:System.Net.Sockets.SocketFlags" />。</summary>
        <returns>发送到 <see cref="T:System.Net.Sockets.Socket" /> 的字节数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此重载至少需要一个包含要发送的数据的缓冲区。 <xref:System.Net.Sockets.SocketFlags>值默认为0。 如果指定 <xref:System.Net.Sockets.SocketFlags.DontRoute> 标志作为 `socketFlags` 参数，则不会路由要发送的数据。  
  
 如果使用的是无连接协议，则必须在 <xref:System.Net.Sockets.Socket.Connect%2A> 调用此方法之前调用，否则 <xref:System.Net.Sockets.Socket.Send%2A> 将引发 <xref:System.Net.Sockets.SocketException> 。 如果使用面向连接的协议，则必须使用 <xref:System.Net.Sockets.Socket.Connect%2A> 建立远程主机连接，或使用 <xref:System.Net.Sockets.Socket.Accept%2A> 来接受传入连接。  
  
 如果使用的是无连接协议并计划将数据发送到多个不同的主机，则应使用 <xref:System.Net.Sockets.Socket.SendTo%2A> 方法。 如果不使用 <xref:System.Net.Sockets.Socket.SendTo%2A> 方法，则必须 <xref:System.Net.Sockets.Socket.Connect%2A> 在每次调用前调用 <xref:System.Net.Sockets.Socket.Send%2A> 。 <xref:System.Net.Sockets.Socket.SendTo%2A>即使已使用建立默认远程主机，也可以使用 <xref:System.Net.Sockets.Socket.Connect%2A> 。 你还可以通过调用来更改默认远程主机，然后再调用 <xref:System.Net.Sockets.Socket.Send%2A> <xref:System.Net.Sockets.Socket.Connect%2A> 。  
  
 如果使用面向连接的协议， <xref:System.Net.Sockets.Socket.Send%2A> 则会一直阻止，直到发送了缓冲区中的所有字节，除非使用设置了超时 <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType> 。 如果超过超时值，则 <xref:System.Net.Sockets.Socket.Send%2A> 调用将引发 <xref:System.Net.Sockets.SocketException> 。 在非阻止模式下， <xref:System.Net.Sockets.Socket.Send%2A> 即使发送的字节数小于缓冲区中的字节数，也可能成功完成。 应用程序负责跟踪发送的字节数，并在应用程序发送缓冲区中的字节之前重试该操作。 还不能保证发送的数据会立即显示在网络上。 为了提高网络效率，基础系统可能会延迟传输，直到收集大量传出数据。 此方法成功完成 <xref:System.Net.Sockets.Socket.Send%2A> 意味着基础系统具有空间来缓冲用于网络发送的数据。  
  
> [!NOTE]
>  如果收到 <xref:System.Net.Sockets.SocketException> ，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。 获取此代码后，请参阅 [Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2) 文档，以获取有关错误的详细说明。  
  
> [!NOTE]
>  成功完成发送并不表示数据已成功传递。 如果传输系统中没有可用于保存要传输的数据的缓冲区空间，则发送将会阻止，除非已将套接字置于非阻止模式。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅 [.NET Framework 中的网络跟踪](/dotnet/framework/network-programming/network-tracing)。  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <exception cref="T:System.ArgumentNullException"><paramref name="buffers" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="buffers" /> 为空。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (ReadOnlySpan&lt;byte&gt; buffer, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; buffer, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.ReadOnlySpan{System.Byte},System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Function Send (buffer As ReadOnlySpan(Of Byte), socketFlags As SocketFlags) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(ReadOnlySpan&lt;System::Byte&gt; buffer, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Send : ReadOnlySpan&lt;byte&gt; * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Send (buffer, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="buffer">一个字符范围，其中包含要发送的数据。</param>
        <param name="socketFlags">枚举值的按位组合，它用于指定发送和接收行为。</param>
        <summary>使用指定的 <see cref="T:System.Net.Sockets.Socket" /> 将数据发送到连接的 <see cref="T:System.Net.Sockets.SocketFlags" />。</summary>
        <returns>发送到 <see cref="T:System.Net.Sockets.Socket" /> 的字节数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  

  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (byte[] buffer, int size, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(unsigned int8[] buffer, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Function Send (buffer As Byte(), size As Integer, socketFlags As SocketFlags) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(cli::array &lt;System::Byte&gt; ^ buffer, int size, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Send : byte[] * int * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Send (buffer, size, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="size" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="buffer">类型 <see cref="T:System.Byte" /> 的数组，其中包含要发送的数据。</param>
        <param name="size">要发送的字节数。</param>
        <param name="socketFlags"><see cref="T:System.Net.Sockets.SocketFlags" /> 值的按位组合。</param>
        <summary>使用指定的 <see cref="T:System.Net.Sockets.Socket" />，将指定字节数的数据发送到已连接的 <see cref="T:System.Net.Sockets.SocketFlags" />。</summary>
        <returns>发送到 <see cref="T:System.Net.Sockets.Socket" /> 的字节数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
## Remarks

<xref:System.Net.Sockets.Socket.Send%2A> 将数据同步发送到或方法中建立的远程主机 <xref:System.Net.Sockets.Socket.Connect%2A> <xref:System.Net.Sockets.Socket.Accept%2A> ，并返回成功发送的字节数。 <xref:System.Net.Sockets.Socket.Send%2A> 可用于面向连接的协议和无连接的协议。

此重载需要包含要发送的数据的缓冲区、要发送的字节数以及任意的按位组合 <xref:System.Net.Sockets.SocketFlags> 。 如果指定 <xref:System.Net.Sockets.SocketFlags.DontRoute> 标志作为 `socketflags` 参数，则不会路由要发送的数据。

如果使用的是无连接协议，则必须在 <xref:System.Net.Sockets.Socket.Connect%2A> 调用此方法之前调用，否则 <xref:System.Net.Sockets.Socket.Send%2A> 将引发 <xref:System.Net.Sockets.SocketException> 。 如果使用面向连接的协议，则必须使用 <xref:System.Net.Sockets.Socket.Connect%2A> 建立远程主机连接，或使用 <xref:System.Net.Sockets.Socket.Accept%2A> 来接受传入连接。

如果使用的是无连接协议并计划将数据发送到多个不同的主机，则应使用 <xref:System.Net.Sockets.Socket.SendTo%2A> 方法。 如果 don'tuse <xref:System.Net.Sockets.Socket.SendTo%2A> 方法，则必须在 <xref:System.Net.Sockets.Socket.Connect%2A> 每次调用方法之前调用方法 <xref:System.Net.Sockets.Socket.Send%2A> 。 <xref:System.Net.Sockets.Socket.SendTo%2A>即使已使用建立默认远程主机，也可以使用 <xref:System.Net.Sockets.Socket.Connect%2A> 。 你还可以通过调用来更改默认远程主机，然后再调用 <xref:System.Net.Sockets.Socket.Send%2A> <xref:System.Net.Sockets.Socket.Connect%2A> 。

使用面向连接的协议时， <xref:System.Net.Sockets.Socket.Send%2A> 将一直阻止到发送请求的字节数，除非使用设置了超时值 <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType> 。 如果超过超时值，则 <xref:System.Net.Sockets.Socket.Send%2A> 调用将引发 <xref:System.Net.Sockets.SocketException> 。 在非阻止模式下， <xref:System.Net.Sockets.Socket.Send%2A> 即使发送的字节数少于你请求的字节数，也可能成功完成。 应用程序负责跟踪发送的字节数，并重试操作，直到应用程序发送请求的字节数。 还不能保证发送的数据会立即显示在网络上。 为了提高网络效率，基础系统可能会延迟传输，直到收集大量传出数据。 此方法成功完成 <xref:System.Net.Sockets.Socket.Send%2A> 意味着基础系统具有空间来缓冲用于网络发送的数据。

> [!NOTE]
> 必须确保大小不超过基础服务提供程序的最大数据包大小。 如果是这样，则不会发送数据报并 <xref:System.Net.Sockets.Socket.Send%2A> 将引发 <xref:System.Net.Sockets.SocketException> 。 如果收到 <xref:System.Net.Sockets.SocketException> ，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。 获取此代码后，请参阅 [Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2) 文档，以获取有关错误的详细说明。

当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅 [.NET Framework 中的网络跟踪](/dotnet/framework/network-programming/network-tracing)。

> [!IMPORTANT]
>成功完成发送并不表示数据已成功传递。 如果传输系统中没有可用于保存要传输的数据的缓冲区空间，则发送将会阻止，除非已将套接字置于非阻止模式。

## Examples

下面的代码示例发送缓冲区中找到的数据，并 <xref:System.Net.Sockets.SocketFlags.None> 为指定 <xref:System.Net.Sockets.SocketFlags> 。

[!code-cpp[Socket_Sync_Send_Receive#3](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#3)]
[!code-csharp[Socket_Sync_Send_Receive#3](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#3)]
[!code-vb[Socket_Sync_Send_Receive#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#3)]
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="size" /> 小于 0 或超过缓冲区的大小。</exception>
        <exception cref="T:System.Net.Sockets.SocketException"><paramref name="socketFlags" /> 不是有效的值组合。  
  
- 或 - 
访问套接字时发生操作系统错误。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt;? buffers, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode);" FrameworkAlternate="net-5.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Send (buffers As IList(Of ArraySegment(Of Byte)), socketFlags As SocketFlags, ByRef errorCode As SocketError) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberSignature Language="F#" Value="member this.Send : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.Net.Sockets.SocketFlags * SocketError -&gt; int" Usage="socket.Send (buffers, socketFlags, errorCode)" />
      <MemberSignature Language="C#" Value="public int Send (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="buffers"><see cref="T:System.ArraySegment`1" /> 类型的 <see cref="T:System.Byte" /> 的列表，它包含要发送的数据。</param>
        <param name="socketFlags"><see cref="T:System.Net.Sockets.SocketFlags" /> 值的按位组合。</param>
        <param name="errorCode">一个 <see cref="T:System.Net.Sockets.SocketError" /> 对象，它存储套接字错误。</param>
        <summary>使用指定的 <see cref="T:System.Net.Sockets.Socket" />，将列表中的一组缓冲区发送到连接的 <see cref="T:System.Net.Sockets.SocketFlags" />。</summary>
        <returns>发送到 <see cref="T:System.Net.Sockets.Socket" /> 的字节数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此重载至少需要一个包含要发送的数据的缓冲区。 <xref:System.Net.Sockets.SocketFlags>值默认为0。 如果指定 <xref:System.Net.Sockets.SocketFlags.DontRoute> 标志作为 `socketFlags` 参数，则不会路由要发送的数据。  
  
 如果使用的是无连接协议，则必须在 <xref:System.Net.Sockets.Socket.Connect%2A> 调用此方法之前调用，否则 <xref:System.Net.Sockets.Socket.Send%2A> 将引发 <xref:System.Net.Sockets.SocketException> 。 如果使用面向连接的协议，则必须使用 <xref:System.Net.Sockets.Socket.Connect%2A> 建立远程主机连接，或使用 <xref:System.Net.Sockets.Socket.Accept%2A> 来接受传入连接。  
  
 如果使用的是无连接协议并计划将数据发送到多个不同的主机，则应使用 <xref:System.Net.Sockets.Socket.SendTo%2A> 方法。 如果不使用 <xref:System.Net.Sockets.Socket.SendTo%2A> 方法，则必须 <xref:System.Net.Sockets.Socket.Connect%2A> 在每次调用前调用 <xref:System.Net.Sockets.Socket.Send%2A> 。 <xref:System.Net.Sockets.Socket.SendTo%2A>即使已使用建立默认远程主机，也可以使用 <xref:System.Net.Sockets.Socket.Connect%2A> 。 你还可以通过调用来更改默认远程主机，然后再调用 <xref:System.Net.Sockets.Socket.Send%2A> <xref:System.Net.Sockets.Socket.Connect%2A> 。  
  
 如果使用面向连接的协议， <xref:System.Net.Sockets.Socket.Send%2A> 则会一直阻止，直到发送了缓冲区中的所有字节，除非使用设置了超时 <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType> 。 如果超过超时值，则 <xref:System.Net.Sockets.Socket.Send%2A> 调用将引发 <xref:System.Net.Sockets.SocketException> 。 在非阻止模式下， <xref:System.Net.Sockets.Socket.Send%2A> 即使发送的字节数小于缓冲区中的字节数，也可能成功完成。 应用程序负责跟踪发送的字节数，并在应用程序发送缓冲区中的字节之前重试该操作。 还不能保证发送的数据会立即显示在网络上。 为了提高网络效率，基础系统可能会延迟传输，直到收集大量传出数据。 此方法成功完成 <xref:System.Net.Sockets.Socket.Send%2A> 意味着基础系统具有空间来缓冲用于网络发送的数据。  
  
> [!NOTE]
>  如果收到 <xref:System.Net.Sockets.SocketException> ，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。 获取此代码后，请参阅 [Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2) 文档，以获取有关错误的详细说明。  
  
> [!NOTE]
>  成功完成发送并不表示数据已成功传递。 如果传输系统中没有可用于保存要传输的数据的缓冲区空间，则发送将会阻止，除非已将套接字置于非阻止模式。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅 [.NET Framework 中的网络跟踪](/dotnet/framework/network-programming/network-tracing)。  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <exception cref="T:System.ArgumentNullException"><paramref name="buffers" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="buffers" /> 为空。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (ReadOnlySpan&lt;byte&gt; buffer, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; buffer, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.ReadOnlySpan{System.Byte},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Send (buffer As ReadOnlySpan(Of Byte), socketFlags As SocketFlags, ByRef errorCode As SocketError) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(ReadOnlySpan&lt;System::Byte&gt; buffer, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberSignature Language="F#" Value="member this.Send : ReadOnlySpan&lt;byte&gt; * System.Net.Sockets.SocketFlags * SocketError -&gt; int" Usage="socket.Send (buffer, socketFlags, errorCode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="buffer">一个字符范围，其中包含要发送的数据。</param>
        <param name="socketFlags">枚举值的按位组合，它用于指定发送和接收行为。</param>
        <param name="errorCode">当此方法返回时，将包含定义套接字错误代码的枚举值之一。</param>
        <summary>使用指定的 <see cref="T:System.Net.Sockets.Socket" /> 将数据发送到连接的 <see cref="T:System.Net.Sockets.SocketFlags" />。</summary>
        <returns>发送到 <see cref="T:System.Net.Sockets.Socket" /> 的字节数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
## Remarks

<xref:System.Net.Sockets.Socket.Send%2A> 将数据同步发送到或方法中指定的远程主机 <xref:System.Net.Sockets.Socket.Connect%2A> <xref:System.Net.Sockets.Socket.Accept%2A> ，并返回成功发送的字节数。 <xref:System.Net.Sockets.Socket.Send%2A> 可用于面向连接的协议和无连接的协议。

此重载需要包含要发送的数据的缓冲区。 <xref:System.Net.Sockets.SocketFlags>默认值为0，缓冲区偏移量默认为0，要发送的字节数默认为缓冲区的大小。

如果使用的是无连接协议，则必须在 <xref:System.Net.Sockets.Socket.Connect%2A> 调用此方法之前调用，否则 <xref:System.Net.Sockets.Socket.Send%2A> 将引发 <xref:System.Net.Sockets.SocketException> 。 如果使用面向连接的协议，则必须使用 <xref:System.Net.Sockets.Socket.Connect%2A> 建立远程主机连接，或使用 <xref:System.Net.Sockets.Socket.Accept%2A> 来接受传入连接。

如果使用的是无连接协议并计划将数据发送到多个不同的主机，则应使用 <xref:System.Net.Sockets.Socket.SendTo%2A> 方法。 如果不使用 <xref:System.Net.Sockets.Socket.SendTo%2A> 方法，则必须在 <xref:System.Net.Sockets.Socket.Connect%2A> 每次调用前调用 <xref:System.Net.Sockets.Socket.Send%2A> 。 <xref:System.Net.Sockets.Socket.SendTo%2A>即使已使用建立默认远程主机，也可以使用 <xref:System.Net.Sockets.Socket.Connect%2A> 。 你还可以通过调用来更改默认远程主机，然后再调用 <xref:System.Net.Sockets.Socket.Send%2A> <xref:System.Net.Sockets.Socket.Connect%2A> 。

如果使用面向连接的协议， <xref:System.Net.Sockets.Socket.Send%2A> 则会一直阻止到发送缓冲区中的所有字节，除非使用设置了超时 <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType> 。 如果超过超时值，则 <xref:System.Net.Sockets.Socket.Send%2A> 调用将引发 <xref:System.Net.Sockets.SocketException> 。 在非阻止模式下， <xref:System.Net.Sockets.Socket.Send%2A> 即使发送的字节数小于缓冲区中的字节数，也可能成功完成。 应用程序负责跟踪发送的字节数，并在应用程序发送缓冲区中的字节之前重试该操作。 还不能保证发送的数据会立即显示在网络上。 为了提高网络效率，基础系统可能会延迟传输，直到收集大量传出数据。 此方法成功完成 <xref:System.Net.Sockets.Socket.Send%2A> 意味着基础系统具有空间来缓冲用于网络发送的数据。

> [!NOTE]
>如果收到 <xref:System.Net.Sockets.SocketException> ，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。 获取此代码后，请参阅 [Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2) 文档，以获取有关错误的详细说明。

当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅 [.NET Framework 中的网络跟踪](/dotnet/framework/network-programming/network-tracing)。

> [!IMPORTANT]
>成功完成发送并不表示数据已成功传递。 如果传输系统中没有可用于保存要传输的数据的缓冲区空间，则发送将会阻止，除非已将套接字置于非阻止模式。

 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Function Send (buffer As Byte(), offset As Integer, size As Integer, socketFlags As SocketFlags) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Send : byte[] * int * int * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Send (buffer, offset, size, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="buffer">类型 <see cref="T:System.Byte" /> 的数组，其中包含要发送的数据。</param>
        <param name="offset">开始发送数据的缓冲区中的位置。</param>
        <param name="size">要发送的字节数。</param>
        <param name="socketFlags"><see cref="T:System.Net.Sockets.SocketFlags" /> 值的按位组合。</param>
        <summary>从指定偏移量开始，使用指定 <see cref="T:System.Net.Sockets.SocketFlags" />，将指定的数据字节数发送到已连接的 <see cref="T:System.Net.Sockets.Socket" />。</summary>
        <returns>发送到 <see cref="T:System.Net.Sockets.Socket" /> 的字节数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Send%2A> 将数据同步发送到或方法中指定的远程主机 <xref:System.Net.Sockets.Socket.Connect%2A> <xref:System.Net.Sockets.Socket.Accept%2A> ，并返回成功发送的字节数。 <xref:System.Net.Sockets.Socket.Send%2A> 可用于面向连接的协议和无连接的协议。  
  
 在此重载中，如果指定 <xref:System.Net.Sockets.SocketFlags.DontRoute> 标志作为 `socketflags` 参数，则将不路由要发送的数据。  
  
 如果使用的是无连接协议，则必须在 <xref:System.Net.Sockets.Socket.Connect%2A> 调用此方法之前调用，否则 <xref:System.Net.Sockets.Socket.Send%2A> 将引发 <xref:System.Net.Sockets.SocketException> 。 如果使用面向连接的协议，则必须使用 <xref:System.Net.Sockets.Socket.Connect%2A> 建立远程主机连接，或使用 <xref:System.Net.Sockets.Socket.Accept%2A> 来接受传入连接。  
  
 如果你使用的是无连接协议并且打算将数据发送到多个不同的主机，则应使用 <xref:System.Net.Sockets.Socket.SendTo%2A> 。 如果不使用 <xref:System.Net.Sockets.Socket.SendTo%2A> ，则必须 <xref:System.Net.Sockets.Socket.Connect%2A> 在每次调用前调用 <xref:System.Net.Sockets.Socket.Send%2A> 。 <xref:System.Net.Sockets.Socket.SendTo%2A>即使已使用建立默认远程主机，也可以使用 <xref:System.Net.Sockets.Socket.Connect%2A> 。 你还可以通过调用来更改默认远程主机，然后再调用 <xref:System.Net.Sockets.Socket.Send%2A> <xref:System.Net.Sockets.Socket.Connect%2A> 。  
  
 您还必须确保大小不超过基础服务提供程序的最大数据包大小。 如果是这样，则不会发送数据报并 <xref:System.Net.Sockets.Socket.Send%2A> 将引发 <xref:System.Net.Sockets.SocketException> 。  
  
 如果使用面向连接的协议， <xref:System.Net.Sockets.Socket.Send%2A> 则会一直阻止到发送请求的字节数，除非使用设置了超时 <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType> 。 如果超过超时值，则 <xref:System.Net.Sockets.Socket.Send%2A> 调用将引发 <xref:System.Net.Sockets.SocketException> 。 在非阻止模式下， <xref:System.Net.Sockets.Socket.Send%2A> 即使发送的字节数少于你请求的字节数，也可能成功完成。 应用程序负责跟踪发送的字节数，并重试操作，直到应用程序发送请求的字节数。 还不能保证发送的数据会立即显示在网络上。 为了提高网络效率，基础系统可能会延迟传输，直到收集大量传出数据。 此方法成功完成 <xref:System.Net.Sockets.Socket.Send%2A> 意味着基础系统具有空间来缓冲用于网络发送的数据。  
  
> [!NOTE]
>  如果收到 <xref:System.Net.Sockets.SocketException> ，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。 获取此代码后，请参阅 [Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2) 文档，以获取有关错误的详细说明。  
  
> [!NOTE]
>  成功完成发送并不表示数据已成功传递。 如果传输系统中没有可用于保存要传输的数据的缓冲区空间，则发送将会阻止，除非已将套接字置于非阻止模式。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅 [.NET Framework 中的网络跟踪](/dotnet/framework/network-programming/network-tracing)。  
  
   
  
## Examples  
 下面的代码示例指定了数据缓冲区、偏移量、大小，以及 <xref:System.Net.Sockets.SocketFlags> 用于将数据发送到连接的 <xref:System.Net.Sockets.Socket> 。  
  
 [!code-cpp[Socket_Sync_Send_Receive#4](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#4)]
 [!code-csharp[Socket_Sync_Send_Receive#4](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#4)]
 [!code-vb[Socket_Sync_Send_Receive#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" /> 小于 0。  
  
- 或 - 
 <paramref name="offset" /> 大于 <paramref name="buffer" /> 的长度。  
  
- 或 - 
 <paramref name="size" /> 小于 0。  
  
- 或 - 
 <paramref name="size" /> 大于 <paramref name="buffer" /> 的长度减去 <paramref name="offset" /> 参数的值。</exception>
        <exception cref="T:System.Net.Sockets.SocketException"><paramref name="socketFlags" /> 不是有效的值组合。  
  
- 或 - 
访问 <see cref="T:System.Net.Sockets.Socket" /> 时出现操作系统错误。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Send (buffer As Byte(), offset As Integer, size As Integer, socketFlags As SocketFlags, ByRef errorCode As SocketError) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberSignature Language="F#" Value="member this.Send : byte[] * int * int * System.Net.Sockets.SocketFlags * SocketError -&gt; int" Usage="socket.Send (buffer, offset, size, socketFlags, errorCode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" Index="4" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="buffer">类型 <see cref="T:System.Byte" /> 的数组，其中包含要发送的数据。</param>
        <param name="offset">开始发送数据的缓冲区中的位置。</param>
        <param name="size">要发送的字节数。</param>
        <param name="socketFlags"><see cref="T:System.Net.Sockets.SocketFlags" /> 值的按位组合。</param>
        <param name="errorCode">一个 <see cref="T:System.Net.Sockets.SocketError" /> 对象，它存储套接字错误。</param>
        <summary>从指定的偏移量开始使用指定的 <see cref="T:System.Net.Sockets.Socket" /> 将指定字节数的数据发送到连接的 <see cref="T:System.Net.Sockets.SocketFlags" />。</summary>
        <returns>发送到 <see cref="T:System.Net.Sockets.Socket" /> 的字节数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Send%2A> 将数据同步发送到或方法中指定的远程主机 <xref:System.Net.Sockets.Socket.Connect%2A> <xref:System.Net.Sockets.Socket.Accept%2A> ，并返回成功发送的字节数。 <xref:System.Net.Sockets.Socket.Send%2A> 可用于面向连接的协议和无连接的协议。  
  
 在此重载中，如果指定 <xref:System.Net.Sockets.SocketFlags.DontRoute> 标志作为 `socketflags` 参数，则将不路由要发送的数据。  
  
 如果使用的是无连接协议，则必须在 <xref:System.Net.Sockets.Socket.Connect%2A> 调用此方法之前调用，否则 <xref:System.Net.Sockets.Socket.Send%2A> 将引发 <xref:System.Net.Sockets.SocketException> 。 如果使用面向连接的协议，则必须使用 <xref:System.Net.Sockets.Socket.Connect%2A> 建立远程主机连接，或使用 <xref:System.Net.Sockets.Socket.Accept%2A> 来接受传入连接。  
  
 如果你使用的是无连接协议并且打算将数据发送到多个不同的主机，则应使用 <xref:System.Net.Sockets.Socket.SendTo%2A> 。 如果不使用 <xref:System.Net.Sockets.Socket.SendTo%2A> ，则必须 <xref:System.Net.Sockets.Socket.Connect%2A> 在每次调用前调用 <xref:System.Net.Sockets.Socket.Send%2A> 。 <xref:System.Net.Sockets.Socket.SendTo%2A>即使已使用建立默认远程主机，也可以使用 <xref:System.Net.Sockets.Socket.Connect%2A> 。 你还可以通过调用来更改默认远程主机，然后再调用 <xref:System.Net.Sockets.Socket.Send%2A> <xref:System.Net.Sockets.Socket.Connect%2A> 。  
  
 您还必须确保大小不超过基础服务提供程序的最大数据包大小。 如果是这样，则不会发送数据报并 <xref:System.Net.Sockets.Socket.Send%2A> 将引发 <xref:System.Net.Sockets.SocketException> 。  
  
 如果使用面向连接的协议， <xref:System.Net.Sockets.Socket.Send%2A> 则会一直阻止到发送请求的字节数，除非使用设置了超时 <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType> 。 如果超过超时值，则 <xref:System.Net.Sockets.Socket.Send%2A> 调用将引发 <xref:System.Net.Sockets.SocketException> 。 在非阻止模式下， <xref:System.Net.Sockets.Socket.Send%2A> 即使发送的字节数少于你请求的字节数，也可能成功完成。 应用程序负责跟踪发送的字节数，并重试操作，直到应用程序发送请求的字节数。 还不能保证发送的数据会立即显示在网络上。 为了提高网络效率，基础系统可能会延迟传输，直到收集大量传出数据。 此方法成功完成 <xref:System.Net.Sockets.Socket.Send%2A> 意味着基础系统具有空间来缓冲用于网络发送的数据。  
  
> [!NOTE]
>  如果收到 <xref:System.Net.Sockets.SocketException> ，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。 获取此代码后，请参阅 [Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2) 文档，以获取有关错误的详细说明。  
  
> [!NOTE]
>  成功完成发送并不表示数据已成功传递。 如果传输系统中没有可用于保存要传输的数据的缓冲区空间，则发送将会阻止，除非已将套接字置于非阻止模式。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅 [.NET Framework 中的网络跟踪](/dotnet/framework/network-programming/network-tracing)。  
  
   
  
## Examples  
 下面的代码示例指定了数据缓冲区、偏移量、大小，以及 <xref:System.Net.Sockets.SocketFlags> 用于将数据发送到连接的 <xref:System.Net.Sockets.Socket> 。  
  
 [!code-cpp[Socket_Sync_Send_Receive#4](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#4)]
 [!code-csharp[Socket_Sync_Send_Receive#4](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#4)]
 [!code-vb[Socket_Sync_Send_Receive#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" /> 小于 0。  
  
- 或 - 
 <paramref name="offset" /> 大于 <paramref name="buffer" /> 的长度。  
  
- 或 - 
 <paramref name="size" /> 小于 0。  
  
- 或 - 
 <paramref name="size" /> 大于 <paramref name="buffer" /> 的长度减去 <paramref name="offset" /> 参数的值。</exception>
        <exception cref="T:System.Net.Sockets.SocketException"><paramref name="socketFlags" /> 不是有效的值组合。  
  
- 或 - 
访问 <see cref="T:System.Net.Sockets.Socket" /> 时出现操作系统错误。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="SendAsync">
      <MemberSignature Language="C#" Value="public bool SendAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool SendAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function SendAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool SendAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.SendAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="socket.SendAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="e">要用于此异步套接字操作的 <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> 对象。</param>
        <summary>将数据异步发送到连接的 <see cref="T:System.Net.Sockets.Socket" /> 对象。</summary>
        <returns>如果 I/O 操作挂起，则为 <see langword="true" />。 操作完成时，将引发 <paramref name="e" /> 参数的 <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> 事件。  
  
 如果 I/O 操作同步完成，则为 <see langword="false" />。 在这种情况下，将不会引发 <paramref name="e" /> 参数的 <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> 事件，并且可能在方法调用返回后立即检查作为参数传递的 <paramref name="e" /> 对象以检索操作的结果。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.SendAsync%2A>方法用于从面向连接的套接字上的一个或多个缓冲区写入传出数据。 但是，也可以在连接操作上已指定远程主机的无连接套接字上使用此方法。  
  
 <xref:System.Net.Sockets.Socket.SendAsync%2A>方法对、、、、 <xref:System.Net.Sockets.Socket.Accept%2A> <xref:System.Net.Sockets.Socket.AcceptAsync%2A> <xref:System.Net.Sockets.Socket.BeginAccept%2A> <xref:System.Net.Sockets.Socket.BeginConnect%2A> <xref:System.Net.Sockets.Socket.Connect%2A> 或 <xref:System.Net.Sockets.Socket.ConnectAsync%2A> 方法中建立的远程主机启动异步发送操作。  
  
 <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType>若要成功调用此方法，必须具有对象上的下列属性和事件：  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> 或 <xref:System.Net.Sockets.SocketAsyncEventArgs.BufferList%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> 如果 <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> 设置  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType> 如果 <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> 设置  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
 调用方可以 <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> 在调用方法之前将属性设置为所需的任何用户状态对象 <xref:System.Net.Sockets.Socket.SendAsync%2A> ，以便可以在回调方法中检索信息。 如果回调需要比单个对象更多的信息，则可以创建一个小类，以将其他所需的状态信息保存为成员。  
  
 <xref:System.Net.Sockets.Socket.SendAsync%2A>如果你不首先调用、、、或，则此方法将引发异常 <xref:System.Net.Sockets.Socket.Accept%2A> <xref:System.Net.Sockets.Socket.AcceptAsync%2A> <xref:System.Net.Sockets.Socket.BeginAccept%2A> <xref:System.Net.Sockets.Socket.BeginConnect%2A> <xref:System.Net.Sockets.Socket.Connect%2A> <xref:System.Net.Sockets.Socket.ConnectAsync%2A> 。  
  
 通过调用 <xref:System.Net.Sockets.Socket.SendAsync%2A> 方法，可以在单独的执行线程中发送数据。  
  
 对于面向消息的套接字，不要超过底层 Windows 套接字服务提供程序的最大消息大小。 如果数据太长，无法通过基础服务提供程序以原子方式传递，则不会传输任何数据，并且该 <xref:System.Net.Sockets.Socket.SendAsync%2A> 方法将引发，并将 <xref:System.Net.Sockets.SocketException> <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType> 设置为本机 Winsock WSAEMSGSIZE 错误代码 (10040) 。  
  
 请注意，成功完成 <xref:System.Net.Sockets.Socket.SendAsync%2A> 方法并不表示数据已成功传递。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="e" /> 参数的 <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" /> 或 <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /> 属性必须引用有效的缓冲区。 可以设置这两个属性中的某一个，但不能同时设置这两个属性。</exception>
        <exception cref="T:System.InvalidOperationException">已经在使用 <paramref name="e" /> 参数中指定的 <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> 对象执行套接字操作。</exception>
        <exception cref="T:System.NotSupportedException">此方法需要 Windows XP 或更高版本。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <exception cref="T:System.Net.Sockets.SocketException"><see cref="T:System.Net.Sockets.Socket" /> 尚未连接或者尚未通过 <see cref="M:System.Net.Sockets.Socket.Accept" />、<see cref="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)" /> 或 <see cref="Overload:System.Net.Sockets.Socket.BeginAccept" /> 方法获得。</exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Offset" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="SendBufferSize">
      <MemberSignature Language="C#" Value="public int SendBufferSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 SendBufferSize" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.SendBufferSize" />
      <MemberSignature Language="VB.NET" Value="Public Property SendBufferSize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int SendBufferSize { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.SendBufferSize : int with get, set" Usage="System.Net.Sockets.Socket.SendBufferSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指定 <see cref="T:System.Net.Sockets.Socket" /> 发送缓冲区的大小。</summary>
        <value><see cref="T:System.Int32" />，它包含发送缓冲区的大小（以字节为单位）。 默认值为 8192。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 缓冲区大小越大，可能会延迟连接的识别问题。 如果正在传输大文件，或者使用的是高带宽、高延迟连接 (如卫星宽带提供程序），请考虑增加缓冲区大小。 )   
  
   
  
## Examples  
 下面的代码示例演示属性的用法 <xref:System.Net.Sockets.Socket.SendBufferSize%2A> 。  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">为设置操作指定的值小于 0。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="SendFile">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>将文件和可选数据异步发送到连接的 <see cref="T:System.Net.Sockets.Socket" />。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SendFile">
      <MemberSignature Language="C#" Value="public void SendFile (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SendFile(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendFile(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SendFile (fileName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SendFile(System::String ^ fileName);" />
      <MemberSignature Language="F#" Value="member this.SendFile : string -&gt; unit" Usage="socket.SendFile fileName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="fileName">一个 <see cref="T:System.String" />，它包含要发送的文件的路径和名称。 此参数可以为 <see langword="null" />。</param>
        <summary>使用 <see cref="T:System.Net.Sockets.Socket" /> 传输标志，将文件 <paramref name="fileName" /> 发送到连接的 <see cref="F:System.Net.Sockets.TransmitFileOptions.UseDefaultWorkerThread" /> 对象。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此重载将文件发送 `fileName` 到连接的套接字。 `flags`参数默认为 <xref:System.Net.Sockets.TransmitFileOptions.UseDefaultWorkerThread> (0) ， `preBuffer` 且和 `postBuffer` 参数默认为 `null` 。 如果 `fileName` 位于本地目录中，则只能用文件的名称进行标识; 否则，必须指定文件的完整路径和名称。 通配符 ( "... \\支持\myfile.txt ") 和 UNC 共享名称 (" \\ \\ \\ \shared directory \\\myfile.txt ") 。 如果找不到该文件，则 <xref:System.IO.FileNotFoundException> 会引发异常。  
  
 此方法使用 `TransmitFile` 在 Windows socket 2 API 中找到的函数。 有关 `TransmitFile` 函数及其标志的详细信息，请参阅 [Windows 套接字](/windows/desktop/WinSock/) 文档。  
  
 <xref:System.Net.Sockets.Socket.SendFile%2A> 同步地将文件发送到或方法中指定的远程主机 <xref:System.Net.Sockets.Socket.Connect%2A> <xref:System.Net.Sockets.Socket.Accept%2A> 。 <xref:System.Net.Sockets.Socket.SendFile%2A> 可用于面向连接的协议和无连接协议。  
  
 如果使用的是无连接协议，则必须在 <xref:System.Net.Sockets.Socket.Connect%2A> 调用此方法之前调用，否则会 <xref:System.Net.Sockets.Socket.SendFile%2A> 引发 <xref:System.Net.Sockets.SocketException> 异常。 如果使用面向连接的协议，则必须使用 <xref:System.Net.Sockets.Socket.Connect%2A> 建立远程主机连接或使用 <xref:System.Net.Sockets.Socket.Accept%2A> 接受传入连接。  
  
 如果使用面向连接的协议，则 <xref:System.Net.Sockets.Socket.SendFile%2A> 在发送文件之前将阻止。 在非阻止模式下， <xref:System.Net.Sockets.Socket.SendFile%2A> 可能会在发送整个文件之前成功完成。 不能保证发送的数据会立即显示在网络上。 为了提高网络效率，基础系统可能会延迟传输，直到收集大量传出数据。 此方法成功完成 <xref:System.Net.Sockets.Socket.SendFile%2A> 意味着基础系统具有空间来缓冲用于网络发送的数据。  
  
> [!NOTE]
>  如果收到 <xref:System.Net.Sockets.SocketException> ，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。 获取此代码后，请参阅 [Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2) 文档，以获取有关错误的详细说明。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅 [.NET Framework 中的网络跟踪](/dotnet/framework/network-programming/network-tracing)。  
  
   
  
## Examples  
 下面的代码示例创建并连接套接字，然后将文件发送到远程主机。 文件 "test.txt" 位于本地计算机的根目录中。  
  
 [!code-cpp[NCLSocketEnhancements#3](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#3)]
 [!code-csharp[NCLSocketEnhancements#3](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">套接字未连接到远程主机。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 对象已关闭。</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Net.Sockets.Socket" /> 对象未处于阻止模式，无法接受此同步调用。</exception>
        <exception cref="T:System.IO.FileNotFoundException">未找到文件 <paramref name="fileName" />。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
      </Docs>
    </Member>
    <Member MemberName="SendFile">
      <MemberSignature Language="C#" Value="public void SendFile (string fileName, byte[] preBuffer, byte[] postBuffer, System.Net.Sockets.TransmitFileOptions flags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SendFile(string fileName, unsigned int8[] preBuffer, unsigned int8[] postBuffer, valuetype System.Net.Sockets.TransmitFileOptions flags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SendFile (fileName As String, preBuffer As Byte(), postBuffer As Byte(), flags As TransmitFileOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SendFile(System::String ^ fileName, cli::array &lt;System::Byte&gt; ^ preBuffer, cli::array &lt;System::Byte&gt; ^ postBuffer, System::Net::Sockets::TransmitFileOptions flags);" />
      <MemberSignature Language="F#" Value="member this.SendFile : string * byte[] * byte[] * System.Net.Sockets.TransmitFileOptions -&gt; unit" Usage="socket.SendFile (fileName, preBuffer, postBuffer, flags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="preBuffer" Type="System.Byte[]" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="postBuffer" Type="System.Byte[]" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="flags" Type="System.Net.Sockets.TransmitFileOptions" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="fileName">一个 <see cref="T:System.String" />，它包含要发送的文件的路径和名称。 此参数可以为 <see langword="null" />。</param>
        <param name="preBuffer">一个 <see cref="T:System.Byte" /> 数组，它包含发送文件前要发送的数据。 此参数可以为 <see langword="null" />。</param>
        <param name="postBuffer">一个 <see cref="T:System.Byte" /> 数组，它包含发送文件后要发送的数据。 此参数可以为 <see langword="null" />。</param>
        <param name="flags">一个或多个 <see cref="T:System.Net.Sockets.TransmitFileOptions" /> 值。</param>
        <summary>通过指定的 <see cref="T:System.Net.Sockets.TransmitFileOptions" /> 值，将文件 <paramref name="fileName" /> 和数据缓冲区发送到连接的 <see cref="T:System.Net.Sockets.Socket" /> 对象。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此重载要求要发送的文件的名称和值的按位组合 <xref:System.Net.Sockets.TransmitFileOptions> 。 `preBuffer`参数包含要在文件之前的任何数据。 `postBuffer` 包含要跟踪文件的数据。 如果 `fileName` 在当前工作目录中，则可以只使用文件的名称标识它; 否则，必须指定文件的完整路径和名称。 通配符 ( "... \\支持\myfile.txt ") 和 UNC 共享名称 (" \\ \\ \\ \shared directory \\\myfile.txt ") 。  
  
 `flags`参数为窗口套接字服务提供程序提供有关文件传输的其他信息。 有关如何使用此参数的详细信息，请参阅 <xref:System.Net.Sockets.TransmitFileOptions> 。  
  
 此方法使用 `TransmitFile` 在 Windows socket 2 API 中找到的函数。 有关 `TransmitFile` 函数及其标志的详细信息，请参阅 [Windows 套接字](/windows/desktop/WinSock/) 文档。  
  
 <xref:System.Net.Sockets.Socket.SendFile%2A> 同步地将文件发送到或方法中指定的远程主机 <xref:System.Net.Sockets.Socket.Connect%2A> <xref:System.Net.Sockets.Socket.Accept%2A> 。 <xref:System.Net.Sockets.Socket.SendFile%2A> 可用于面向连接的协议和无连接协议。  
  
 如果使用的是无连接协议，则在 <xref:System.Net.Sockets.Socket.Connect%2A> 调用此方法之前必须调用，否则将 <xref:System.Net.Sockets.Socket.SendFile%2A> 引发 <xref:System.Net.Sockets.SocketException> 。 如果使用面向连接的协议，则必须使用 <xref:System.Net.Sockets.Socket.Connect%2A> 建立远程主机连接，或使用 <xref:System.Net.Sockets.Socket.Accept%2A> 来接受传入连接。  
  
 如果你使用的是面向连接的协议，则会 <xref:System.Net.Sockets.Socket.SendFile%2A> 阻止，直到发送整个文件。 在非阻止模式下， <xref:System.Net.Sockets.Socket.SendFile%2A> 可能会在发送整个文件之前成功完成。 不能保证发送的数据会立即显示在网络上。 为了提高网络效率，基础系统可能会延迟传输，直到收集大量传出数据。 此方法成功完成 <xref:System.Net.Sockets.Socket.SendFile%2A> 意味着基础系统具有空间来缓冲用于网络发送的数据。  
  
> [!NOTE]
>  如果收到 <xref:System.Net.Sockets.SocketException> ，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。 获取此代码后，请参阅 [Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2) 文档，以获取有关错误的详细说明。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅 [.NET Framework 中的网络跟踪](/dotnet/framework/network-programming/network-tracing)。  
  
   
  
## Examples  
 下面的代码示例创建并连接套接字。 文件 "test.txt" 位于本地计算机的根目录中。 在此示例中，我们将创建 prebuffer 和以增大 postbuffer 数据，并使用该文件将其发送到远程主机。 使用默认值 <xref:System.Net.Sockets.TransmitFileOptions> 。  
  
 [!code-cpp[NCLSocketEnhancements#4](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#4)]
 [!code-csharp[NCLSocketEnhancements#4](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">操作系统不是 Windows NT 或更高版本。  
  
- 或 -
  
 套接字未连接到远程主机。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 对象已关闭。</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Net.Sockets.Socket" /> 对象未处于阻止模式，无法接受此同步调用。</exception>
        <exception cref="T:System.IO.FileNotFoundException">未找到文件 <paramref name="fileName" />。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
      </Docs>
    </Member>
    <Member MemberName="SendPacketsAsync">
      <MemberSignature Language="C#" Value="public bool SendPacketsAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool SendPacketsAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function SendPacketsAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool SendPacketsAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.SendPacketsAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="socket.SendPacketsAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.MonoTODO("Not implemented")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.MonoTODO("Not implemented")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="e">要用于此异步套接字操作的 <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> 对象。</param>
        <summary>将文件集合或者内存中的数据缓冲区以异步方法发送给连接的 <see cref="T:System.Net.Sockets.Socket" /> 对象。</summary>
        <returns>如果 I/O 操作挂起，则为 <see langword="true" />。 操作完成时，将引发 <paramref name="e" /> 参数的 <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> 事件。  
  
 如果 I/O 操作同步完成，则为 <see langword="false" />。 在这种情况下，将不会引发 <paramref name="e" /> 参数的 <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> 事件，并且可能在方法调用返回后立即检查作为参数传递的 <paramref name="e" /> 对象以检索操作的结果。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A>方法用于将文件集合或内存中的数据缓冲区发送到远程主机。 <xref:System.Net.Sockets.Socket>必须已连接到远程主机。  
  
 如果 <xref:System.Net.Sockets.SendPacketsElement?displayProperty=nameWithType> 引用工作目录中的文件，则可以只使用文件的名称标识该文件; 否则，必须指定文件的完整路径和名称。 支持通配符和 UNC 共享名。 如果找不到该文件， <xref:System.IO.FileNotFoundException> 则将引发。  
  
 若要在完成时收到通知，您必须创建一个实现 EventHandler 委托的回调方法 \<SocketAsyncEventArgs> ，并将回调附加到该 <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType> 事件。  
  
 <xref:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsFlags%2A?displayProperty=nameWithType>参数上的属性为 `e` 窗口套接字服务提供程序提供有关文件传输的其他信息。 有关如何使用此参数的详细信息，请参阅 <xref:System.Net.Sockets.TransmitFileOptions> 。  
  
 <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType>若要成功调用此方法，必须具有对象上的下列属性和事件：  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsElements%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
 调用方可以 <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> 在调用方法之前将属性设置为所需的任何用户状态对象 <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> ，以便可以在回调方法中检索信息。 如果回调需要比单个对象更多的信息，则可以创建一个小类，以将其他所需的状态信息保存为成员。  
  
 此方法使用在 Windows Socket 2 API 中找到的 TransmitPackets 函数。 有关 TransmitPackets 函数及其标志的详细信息，请参阅 [Windows 套接字](/windows/desktop/WinSock/) 文档。  
  
 尽管适用于面向连接的协议，但该 <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> 方法还适用于无连接协议，前提是你首先调用 <xref:System.Net.Sockets.Socket.BeginConnect%2A> 、 <xref:System.Net.Sockets.Socket.Connect%2A> 或 <xref:System.Net.Sockets.Socket.ConnectAsync%2A> 方法来建立默认远程主机。 在无连接协议的情况下，你还必须确保文件大小不超过基础服务提供程序的最大数据包大小。 如果是这样，则不发送数据报并 <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> 引发 <xref:System.Net.Sockets.SocketException> 异常。  
  
 <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A>方法根据使用它的操作系统进行了优化。 在 Windows server 版本上， <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> 方法经过优化，可实现高性能。  
  
 在 Windows 客户端版本上， <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> 方法针对最小内存和资源利用率进行了优化。  
  
 在 <xref:System.Net.Sockets.TransmitFileOptions.UseKernelApc?displayProperty=nameWithType> 参数的属性中使用标志 <xref:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsFlags%2A?displayProperty=nameWithType> `e` 可以提供显著的性能优势。 如果启动方法调用的线程正在 <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> 用于繁重的计算，则可能会阻止 apc 启动。 请注意，内核模式和用户模式 Apc 之间存在差异。 当线程处于等待状态时，内核 Apc 启动。 当线程处于可报警等待状态时，用户模式 Apc 启动  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException">未找到在 <see cref="P:System.Net.Sockets.SendPacketsElement.FilePath" /> 属性中指定的文件。</exception>
        <exception cref="T:System.InvalidOperationException">已经在使用 <paramref name="e" /> 参数中指定的 <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> 对象执行套接字操作。</exception>
        <exception cref="T:System.NotSupportedException">此方法需要 Windows XP 或更高版本。 如果 <see cref="T:System.Net.Sockets.Socket" /> 未连接到远程主机，也会发生此异常。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">使用的是无连接 <see cref="T:System.Net.Sockets.Socket" />，并且所发送的文件超过了基础传输的最大数据包大小。</exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsElements" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsFlags" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="SendTimeout">
      <MemberSignature Language="C#" Value="public int SendTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 SendTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.SendTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Property SendTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int SendTimeout { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.SendTimeout : int with get, set" Usage="System.Net.Sockets.Socket.SendTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指定之后同步 <see cref="Overload:System.Net.Sockets.Socket.Send" /> 调用将超时的时间长度。</summary>
        <value>超时值（以毫秒为单位）。 如果将该属性设置为 1 到 499 之间的值，该值将被更改为 500。 默认值为 0，指示超时期限无限大。 指定 -1 还会指示超时期限无限大。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此选项仅适用于同步 <xref:System.Net.Sockets.Socket.Send%2A> 调用。 如果超过超时期限，该 <xref:System.Net.Sockets.Socket.Send%2A> 方法将引发 <xref:System.Net.Sockets.SocketException> 。  
  
   
  
## Examples  
 下面的代码示例演示属性的用法 <xref:System.Net.Sockets.Socket.SendTimeout%2A> 。  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">为设置操作指定的值小于 1。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="SendTo">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>将数据发送到特定终结点。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SendTo">
      <MemberSignature Language="C#" Value="public int SendTo (byte[] buffer, System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 SendTo(unsigned int8[] buffer, class System.Net.EndPoint remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.EndPoint)" />
      <MemberSignature Language="VB.NET" Value="Public Function SendTo (buffer As Byte(), remoteEP As EndPoint) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int SendTo(cli::array &lt;System::Byte&gt; ^ buffer, System::Net::EndPoint ^ remoteEP);" />
      <MemberSignature Language="F#" Value="member this.SendTo : byte[] * System.Net.EndPoint -&gt; int" Usage="socket.SendTo (buffer, remoteEP)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="buffer">类型 <see cref="T:System.Byte" /> 的数组，其中包含要发送的数据。</param>
        <param name="remoteEP"><see cref="T:System.Net.EndPoint" />，它表示数据的目标位置。</param>
        <summary>将数据发送到指定的终结点。</summary>
        <returns>已发送的字节数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在此重载中，缓冲区偏移量默认为0，发送的字节数默认为参数的大小 `buffer` ， <xref:System.Net.Sockets.SocketFlags> 值默认为0。  
  
 如果使用的是无连接协议，则在调用之前，不需要使用方法建立默认远程主机 <xref:System.Net.Sockets.Socket.Connect%2A> <xref:System.Net.Sockets.Socket.SendTo%2A> 。 如果要调用方法，只需执行此操作 <xref:System.Net.Sockets.Socket.Send%2A> 。 如果在 <xref:System.Net.Sockets.Socket.Connect%2A> 调用之前调用方法 <xref:System.Net.Sockets.Socket.SendTo%2A> ，则该 `remoteEP` 参数将仅为该发送操作重写指定的默认远程主机。 你还不需要调用 <xref:System.Net.Sockets.Socket.Bind%2A> 方法，因为基础服务提供程序将分配最适当的本地网络地址和端口号。 如果需要确定分配的本地网络地址和端口号，可以在 <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> <xref:System.Net.Sockets.Socket.SendTo%2A> 方法成功完成后使用属性。  
  
 尽管适用于无连接协议，但 <xref:System.Net.Sockets.Socket.SendTo%2A> 也适用于面向连接的协议。 如果使用面向连接的协议，则必须先通过调用方法建立远程主机连接， <xref:System.Net.Sockets.Socket.Connect%2A> 或使用方法接受传入的连接请求 <xref:System.Net.Sockets.Socket.Accept%2A> 。 如果未建立或接受远程主机连接， <xref:System.Net.Sockets.Socket.SendTo%2A> 将引发 <xref:System.Net.Sockets.SocketException> 。 还可以在调用方法之前，为无连接协议建立默认远程主机 <xref:System.Net.Sockets.Socket.SendTo%2A> 。 在这两种情况下， <xref:System.Net.Sockets.Socket.SendTo%2A> 将忽略 `remoteEP` 参数，且仅向已连接或默认的远程主机发送数据。  
  
 在发送缓冲区中的所有字节之前，阻止套接字将会阻止。 由于非阻止 <xref:System.Net.Sockets.Socket> 会立即完成，因此它可能不会发送中的所有字节 `buffer` 。 应用程序负责跟踪发送的字节数，并重试操作，直到应用程序发送中的所有字节 `buffer` 。 还不能保证发送的数据会立即显示在网络上。 为了提高网络效率，基础系统可能会延迟传输，直到收集大量传出数据。 此方法成功完成 <xref:System.Net.Sockets.Socket.SendTo%2A> 意味着基础系统具有空间来缓冲用于网络发送的数据。  
  
 如果在阻止模式下使用无连接协议， <xref:System.Net.Sockets.Socket.SendTo%2A> 则会一直阻止，直到发送数据报。 如果要将数据发送到广播地址，则必须先调用 <xref:System.Net.Sockets.Socket.SetSocketOption%2A> 方法，并将套接字选项设置为 <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType> 。 还必须确保发送的字节数不超过基础服务提供程序的最大数据包大小。 如果是这样，则不会发送数据报并 <xref:System.Net.Sockets.Socket.SendTo%2A> 将引发 <xref:System.Net.Sockets.SocketException> 。  
  
> [!NOTE]
>  如果收到 <xref:System.Net.Sockets.SocketException> ，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。 获取此代码后，请参阅 [Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2) 文档，以获取有关错误的详细说明。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅 [.NET Framework 中的网络跟踪](/dotnet/framework/network-programming/network-tracing)。  
  
   
  
## Examples  
 下面的代码示例将无连接数据报发送到指定的远程主机。  
  
 [!code-cpp[Socket_Sync_Send_Receive#5](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#5)]
 [!code-csharp[Socket_Sync_Send_Receive#5](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#5)]
 [!code-vb[Socket_Sync_Send_Receive#5](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> 为 <see langword="null" />。  
  
- 或 - 
 <paramref name="remoteEP" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="P:System.Net.Sockets.Socket.LocalEndPoint" />
      </Docs>
    </Member>
    <Member MemberName="SendTo">
      <MemberSignature Language="C#" Value="public int SendTo (byte[] buffer, System.Net.Sockets.SocketFlags socketFlags, System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 SendTo(unsigned int8[] buffer, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
      <MemberSignature Language="VB.NET" Value="Public Function SendTo (buffer As Byte(), socketFlags As SocketFlags, remoteEP As EndPoint) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int SendTo(cli::array &lt;System::Byte&gt; ^ buffer, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ remoteEP);" />
      <MemberSignature Language="F#" Value="member this.SendTo : byte[] * System.Net.Sockets.SocketFlags * System.Net.EndPoint -&gt; int" Usage="socket.SendTo (buffer, socketFlags, remoteEP)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="buffer">类型 <see cref="T:System.Byte" /> 的数组，其中包含要发送的数据。</param>
        <param name="socketFlags"><see cref="T:System.Net.Sockets.SocketFlags" /> 值的按位组合。</param>
        <param name="remoteEP"><see cref="T:System.Net.EndPoint" />，它表示数据的目标位置。</param>
        <summary>使用指定的 <see cref="T:System.Net.Sockets.SocketFlags" />，将数据发送到特定的终结点。</summary>
        <returns>已发送的字节数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在此重载中，缓冲区偏移量默认为0，要发送的字节数默认为的大小 `buffer` 。 如果指定 <xref:System.Net.Sockets.SocketFlags.DontRoute> 标志作为 `socketflags` 参数，则不会路由要发送的数据。  
  
 如果使用的是无连接协议，则在调用之前，不需要使用方法建立默认远程主机 <xref:System.Net.Sockets.Socket.Connect%2A> <xref:System.Net.Sockets.Socket.SendTo%2A> 。 如果要调用方法，只需执行此操作 <xref:System.Net.Sockets.Socket.Send%2A> 。 如果在 <xref:System.Net.Sockets.Socket.Connect%2A> 调用之前调用方法 <xref:System.Net.Sockets.Socket.SendTo%2A> ，则该 `remoteEP` 参数将仅为该发送操作重写指定的默认远程主机。 你还不需要调用 <xref:System.Net.Sockets.Socket.Bind%2A> 方法，因为基础服务提供程序将分配最适当的本地网络地址和端口号。 如果需要确定分配的本地网络地址和端口号，可以在 <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> <xref:System.Net.Sockets.Socket.SendTo%2A> 方法成功完成后使用属性。  
  
 尽管适用于无连接协议，但 <xref:System.Net.Sockets.Socket.SendTo%2A> 也适用于面向连接的协议。 如果使用面向连接的协议，则必须先通过调用方法建立远程主机连接， <xref:System.Net.Sockets.Socket.Connect%2A> 或使用方法接受传入的连接请求 <xref:System.Net.Sockets.Socket.Accept%2A> 。 如果未建立或接受远程主机连接， <xref:System.Net.Sockets.Socket.SendTo%2A> 将引发 <xref:System.Net.Sockets.SocketException> 。 还可以在调用方法之前，为无连接协议建立默认远程主机 <xref:System.Net.Sockets.Socket.SendTo%2A> 。 在这两种情况下， <xref:System.Net.Sockets.Socket.SendTo%2A> 将忽略 `remoteEP` 参数，且仅向已连接或默认的远程主机发送数据。  
  
 阻止套接字将会阻塞，直到发送了中的所有字节 `buffer` 。 由于非阻止 <xref:System.Net.Sockets.Socket> 会立即完成，因此它可能不会发送中的所有字节 `buffer` 。 应用程序负责跟踪发送的字节数，并重试操作，直到应用程序发送中的所有字节 `buffer` 。 还不能保证发送的数据会立即显示在网络上。 为了提高网络效率，基础系统可能会延迟传输，直到收集了大量的传出数据。 此方法成功完成 <xref:System.Net.Sockets.Socket.SendTo%2A> 意味着基础系统具有空间来缓冲用于网络发送的数据。  
  
 如果在阻止模式下使用无连接协议， <xref:System.Net.Sockets.Socket.SendTo%2A> 则会一直阻止，直到发送数据报。 如果要将数据发送到广播地址，则必须先调用 <xref:System.Net.Sockets.Socket.SetSocketOption%2A> 方法，并将套接字选项设置为 <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType> 。 还必须确保发送的字节数不超过基础服务提供程序的最大数据包大小。 如果是这样，则不会发送数据报并 <xref:System.Net.Sockets.Socket.SendTo%2A> 将引发 <xref:System.Net.Sockets.SocketException> 。  
  
> [!NOTE]
>  如果收到 <xref:System.Net.Sockets.SocketException> ，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。 获取此代码后，请参阅 [Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2) 文档，以获取有关错误的详细说明。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅 [.NET Framework 中的网络跟踪](/dotnet/framework/network-programming/network-tracing)。  
  
   
  
## Examples  
 下面的代码示例将无连接数据报发送到指定的远程主机。 <xref:System.Net.Sockets.SocketFlags> 传递给 <xref:System.Net.Sockets.Socket.SendTo%2A> 方法。  
  
 [!code-cpp[Socket_Sync_Send_Receive#6](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#6)]
 [!code-csharp[Socket_Sync_Send_Receive#6](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#6)]
 [!code-vb[Socket_Sync_Send_Receive#6](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> 为 <see langword="null" />。  
  
- 或 - 
 <paramref name="remoteEP" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="P:System.Net.Sockets.Socket.LocalEndPoint" />
      </Docs>
    </Member>
    <Member MemberName="SendTo">
      <MemberSignature Language="C#" Value="public int SendTo (byte[] buffer, int size, System.Net.Sockets.SocketFlags socketFlags, System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 SendTo(unsigned int8[] buffer, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
      <MemberSignature Language="VB.NET" Value="Public Function SendTo (buffer As Byte(), size As Integer, socketFlags As SocketFlags, remoteEP As EndPoint) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int SendTo(cli::array &lt;System::Byte&gt; ^ buffer, int size, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ remoteEP);" />
      <MemberSignature Language="F#" Value="member this.SendTo : byte[] * int * System.Net.Sockets.SocketFlags * System.Net.EndPoint -&gt; int" Usage="socket.SendTo (buffer, size, socketFlags, remoteEP)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="size" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="buffer">类型 <see cref="T:System.Byte" /> 的数组，其中包含要发送的数据。</param>
        <param name="size">要发送的字节数。</param>
        <param name="socketFlags"><see cref="T:System.Net.Sockets.SocketFlags" /> 值的按位组合。</param>
        <param name="remoteEP"><see cref="T:System.Net.EndPoint" />，它表示数据的目标位置。</param>
        <summary>使用指定的 <see cref="T:System.Net.Sockets.SocketFlags" />，将指定字节数的数据发送到指定的终结点。</summary>
        <returns>已发送的字节数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在此重载中，缓冲区偏移量默认为0。 如果指定 <xref:System.Net.Sockets.SocketFlags.DontRoute> 标志作为 `socketflags` 参数，则不会路由要发送的数据。  
  
 如果使用的是无连接协议，则在调用之前，不需要使用方法建立默认远程主机 <xref:System.Net.Sockets.Socket.Connect%2A> <xref:System.Net.Sockets.Socket.SendTo%2A> 。 如果要调用方法，只需执行此操作 <xref:System.Net.Sockets.Socket.Send%2A> 。 如果在 <xref:System.Net.Sockets.Socket.Connect%2A> 调用之前调用方法 <xref:System.Net.Sockets.Socket.SendTo%2A> ，则该 `remoteEP` 参数将仅为该发送操作重写指定的默认远程主机。 你还不需要调用 <xref:System.Net.Sockets.Socket.Bind%2A> 方法，因为基础服务提供程序将分配最适当的本地网络地址和端口号。 如果需要确定分配的本地网络地址和端口号，可以在 <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> <xref:System.Net.Sockets.Socket.SendTo%2A> 方法成功完成后使用属性。  
  
 尽管适用于无连接协议，但 <xref:System.Net.Sockets.Socket.SendTo%2A> 也适用于面向连接的协议。 如果使用面向连接的协议，则必须先通过调用方法建立远程主机连接， <xref:System.Net.Sockets.Socket.Connect%2A> 或使用方法接受传入的连接请求 <xref:System.Net.Sockets.Socket.Accept%2A> 。 如果未建立或接受远程主机连接， <xref:System.Net.Sockets.Socket.SendTo%2A> 将引发 <xref:System.Net.Sockets.SocketException> 。 还可以在调用方法之前，为无连接协议建立默认远程主机 <xref:System.Net.Sockets.Socket.SendTo%2A> 。 在这两种情况下， <xref:System.Net.Sockets.Socket.SendTo%2A> 将忽略 `remoteEP` 参数，且仅向已连接或默认的远程主机发送数据。  
  
 阻止套接字将会阻止，直到发送请求的字节数。 由于非阻止 <xref:System.Net.Sockets.Socket> 会立即完成，因此它可能不会在单个操作中发送所有请求的字节。 应用程序负责跟踪发送的字节数，并重试操作，直到应用程序发送请求的字节数。 还不能保证发送的数据会立即显示在网络上。 为了提高网络效率，基础系统可能会延迟传输，直到收集了大量的传出数据。 此方法成功完成 <xref:System.Net.Sockets.Socket.SendTo%2A> 意味着基础系统具有空间来缓冲用于网络发送的数据。  
  
 如果在阻止模式下使用无连接协议， <xref:System.Net.Sockets.Socket.SendTo%2A> 则会一直阻止，直到发送数据报。 如果要将数据发送到广播地址，则必须先调用 <xref:System.Net.Sockets.Socket.SetSocketOption%2A> 方法，并将套接字选项设置为 <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType> 。 还必须确保发送的字节数不超过基础服务提供程序的最大数据包大小。 如果是这样，则不会发送数据报并 <xref:System.Net.Sockets.Socket.SendTo%2A> 将引发 <xref:System.Net.Sockets.SocketException> 。  
  
> [!NOTE]
>  如果收到 <xref:System.Net.Sockets.SocketException> ，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。 获取此代码后，请参阅 [Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2) 文档，以获取有关错误的详细说明。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅 [.NET Framework 中的网络跟踪](/dotnet/framework/network-programming/network-tracing)。  
  
   
  
## Examples  
 下面的代码示例将无连接数据报发送到指定的远程主机。 大小和 <xref:System.Net.Sockets.SocketFlags> 被传递给 <xref:System.Net.Sockets.Socket.SendTo%2A> 方法。  
  
 [!code-cpp[Socket_Sync_Send_Receive#7](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#7)]
 [!code-csharp[Socket_Sync_Send_Receive#7](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#7)]
 [!code-vb[Socket_Sync_Send_Receive#7](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> 为 <see langword="null" />。  
  
- 或 - 
 <paramref name="remoteEP" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">指定的 <paramref name="size" /> 超出 <paramref name="buffer" /> 的大小。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="P:System.Net.Sockets.Socket.LocalEndPoint" />
      </Docs>
    </Member>
    <Member MemberName="SendTo">
      <MemberSignature Language="C#" Value="public int SendTo (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 SendTo(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
      <MemberSignature Language="VB.NET" Value="Public Function SendTo (buffer As Byte(), offset As Integer, size As Integer, socketFlags As SocketFlags, remoteEP As EndPoint) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int SendTo(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ remoteEP);" />
      <MemberSignature Language="F#" Value="member this.SendTo : byte[] * int * int * System.Net.Sockets.SocketFlags * System.Net.EndPoint -&gt; int" Usage="socket.SendTo (buffer, offset, size, socketFlags, remoteEP)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" Index="4" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="buffer">类型 <see cref="T:System.Byte" /> 的数组，其中包含要发送的数据。</param>
        <param name="offset">开始发送数据的缓冲区中的位置。</param>
        <param name="size">要发送的字节数。</param>
        <param name="socketFlags"><see cref="T:System.Net.Sockets.SocketFlags" /> 值的按位组合。</param>
        <param name="remoteEP"><see cref="T:System.Net.EndPoint" />，它表示数据的目标位置。</param>
        <summary>使用指定的 <see cref="T:System.Net.Sockets.SocketFlags" />，将指定字节数的数据发送到指定终结点（从缓冲区中的指定位置开始）。</summary>
        <returns>已发送的字节数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在此重载中，如果指定 <xref:System.Net.Sockets.SocketFlags.DontRoute> 标志作为 `socketflags` 参数，则将不路由要发送的数据。  
  
 如果使用的是无连接协议，则在调用之前，不需要使用方法建立默认远程主机 <xref:System.Net.Sockets.Socket.Connect%2A> <xref:System.Net.Sockets.Socket.SendTo%2A> 。 如果要调用方法，只需执行此操作 <xref:System.Net.Sockets.Socket.Send%2A> 。 如果在 <xref:System.Net.Sockets.Socket.Connect%2A> 调用之前调用方法 <xref:System.Net.Sockets.Socket.SendTo%2A> ，则该 `remoteEP` 参数将仅为该发送操作重写指定的默认远程主机。 你还不需要调用 <xref:System.Net.Sockets.Socket.Bind%2A> 方法，因为基础服务提供程序将分配最适当的本地网络地址和端口号。 如果需要确定分配的本地网络地址和端口号，可以在 <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> <xref:System.Net.Sockets.Socket.SendTo%2A> 方法成功完成后使用属性。  
  
 尽管适用于无连接协议，但 <xref:System.Net.Sockets.Socket.SendTo%2A> 也适用于面向连接的协议。 如果使用面向连接的协议，则必须先通过调用方法建立远程主机连接， <xref:System.Net.Sockets.Socket.Connect%2A> 或使用方法接受传入的连接请求 <xref:System.Net.Sockets.Socket.Accept%2A> 。 如果未建立或接受远程主机连接， <xref:System.Net.Sockets.Socket.SendTo%2A> 将引发 <xref:System.Net.Sockets.SocketException> 。 还可以在调用方法之前，为无连接协议建立默认远程主机 <xref:System.Net.Sockets.Socket.SendTo%2A> 。 在这两种情况下， <xref:System.Net.Sockets.Socket.SendTo%2A> 将忽略 `remoteEP` 参数，且仅向已连接或默认的远程主机发送数据。  
  
 阻止套接字将会阻止，直到发送请求的字节数。 由于非阻止 <xref:System.Net.Sockets.Socket> 会立即完成，因此它可能不会发送单个操作中请求的所有字节。 应用程序负责跟踪发送的字节数，并重试操作，直到应用程序发送请求的字节数。 还不能保证发送的数据会立即显示在网络上。 为了提高网络效率，基础系统可能会延迟传输，直到收集了大量的传出数据。 此方法成功完成 <xref:System.Net.Sockets.Socket.SendTo%2A> 意味着基础系统具有空间来缓冲用于网络发送的数据。  
  
 如果在阻止模式下使用无连接协议， <xref:System.Net.Sockets.Socket.SendTo%2A> 则会一直阻止，直到发送数据报。 如果要将数据发送到广播地址，则必须先调用 <xref:System.Net.Sockets.Socket.SetSocketOption%2A> 方法，并将套接字选项设置为 <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType> 。 您还必须确保大小不超过基础服务提供程序的最大数据包大小。 如果是这样，则不会发送数据报并 <xref:System.Net.Sockets.Socket.SendTo%2A> 将引发 <xref:System.Net.Sockets.SocketException> 。  
  
> [!NOTE]
>  如果收到 <xref:System.Net.Sockets.SocketException> ，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。 获取此代码后，请参阅 [Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2) 文档，以获取有关错误的详细说明。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅 [.NET Framework 中的网络跟踪](/dotnet/framework/network-programming/network-tracing)。  
  
   
  
## Examples  
 下面的代码示例将无连接数据报发送到指定的远程主机。 偏移量、大小和 <xref:System.Net.Sockets.SocketFlags> 被传递给 <xref:System.Net.Sockets.Socket.SendTo%2A> 方法。  
  
 [!code-cpp[Socket_Sync_Send_Receive#8](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#8)]
 [!code-csharp[Socket_Sync_Send_Receive#8](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#8)]
 [!code-vb[Socket_Sync_Send_Receive#8](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> 为 <see langword="null" />。  
  
- 或 - 
 <paramref name="remoteEP" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" /> 小于 0。  
  
- 或 - 
 <paramref name="offset" /> 大于 <paramref name="buffer" /> 的长度。  
  
- 或 - 
 <paramref name="size" /> 小于 0。  
  
- 或 - 
 <paramref name="size" /> 大于 <paramref name="buffer" /> 的长度减去 <paramref name="offset" /> 参数的值。</exception>
        <exception cref="T:System.Net.Sockets.SocketException"><paramref name="socketFlags" /> 不是有效的值组合。  
  
- 或 - 
访问 <see cref="T:System.Net.Sockets.Socket" /> 时出现操作系统错误。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <exception cref="T:System.Security.SecurityException">调用堆栈中的调用方没有所需的权限。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="P:System.Net.Sockets.Socket.LocalEndPoint" />
      </Docs>
    </Member>
    <Member MemberName="SendToAsync">
      <MemberSignature Language="C#" Value="public bool SendToAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool SendToAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function SendToAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool SendToAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.SendToAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="socket.SendToAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="e">要用于此异步套接字操作的 <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> 对象。</param>
        <summary>以异步方式将数据发送到特定远程主机。</summary>
        <returns>如果 I/O 操作挂起，则为 <see langword="true" />。 操作完成时，将引发 <paramref name="e" /> 参数的 <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> 事件。  
  
 如果 I/O 操作同步完成，则为 <see langword="false" />。 在这种情况下，将不会引发 <paramref name="e" /> 参数的 <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> 事件，并且可能在方法调用返回后立即检查作为参数传递的 <paramref name="e" /> 对象以检索操作的结果。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.SendToAsync%2A>方法对参数的属性中指定的远程主机启动异步发送操作 <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> `e` 。 通过调用 <xref:System.Net.Sockets.Socket.SendToAsync%2A> 方法，可以在单独的执行线程中发送数据。 尽管此方法用于无连接协议，但 <xref:System.Net.Sockets.Socket.SendToAsync%2A> 适用于无连接和面向连接的协议。  
  
 若要在完成时收到通知，您必须创建一个实现 EventHandler 委托的回调方法 \<SocketAsyncEventArgs> ，并将回调附加到该 <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType> 事件。  
  
 <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType>若要成功调用此方法，必须具有对象上的下列属性和事件：  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
 调用方可以 <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> 在调用方法之前将属性设置为所需的任何用户状态对象 <xref:System.Net.Sockets.Socket.SendToAsync%2A> ，以便可以在回调方法中检索信息。 如果回调需要比单个对象更多的信息，则可以创建一个小类，以将其他所需的状态信息保存为成员。  
  
 如果使用面向连接的协议，则必须先调用、、、、 <xref:System.Net.Sockets.Socket.Accept%2A> <xref:System.Net.Sockets.Socket.AcceptAsync%2A> <xref:System.Net.Sockets.Socket.BeginAccept%2A> <xref:System.Net.Sockets.Socket.BeginConnect%2A> <xref:System.Net.Sockets.Socket.Connect%2A> 或 <xref:System.Net.Sockets.Socket.ConnectAsync%2A> 方法。 否则 <xref:System.Net.Sockets.Socket.SendToAsync%2A> 将引发 <xref:System.Net.Sockets.SocketException> 。 使用面向连接的协议时， <xref:System.Net.Sockets.Socket.SendToAsync%2A> 方法将忽略 <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> 属性，并将数据发送到在、、、 <xref:System.Net.EndPoint?displayProperty=nameWithType> <xref:System.Net.Sockets.Socket.Accept%2A> <xref:System.Net.Sockets.Socket.AcceptAsync%2A> <xref:System.Net.Sockets.Socket.BeginAccept%2A> <xref:System.Net.Sockets.Socket.BeginConnect%2A> 、 <xref:System.Net.Sockets.Socket.Connect%2A> 或 <xref:System.Net.Sockets.Socket.ConnectAsync%2A> 方法中建立的。  
  
 如果使用的是无连接协议，则不需要在 <xref:System.Net.Sockets.Socket.BeginConnect%2A> <xref:System.Net.Sockets.Socket.Connect%2A> 调用前使用、或方法建立默认远程主机 <xref:System.Net.Sockets.Socket.ConnectAsync%2A> <xref:System.Net.Sockets.Socket.SendToAsync%2A> 。 仅当要调用或方法时，才需要执行此 <xref:System.Net.Sockets.Socket.BeginSend%2A> 操作 <xref:System.Net.Sockets.Socket.SendAsync%2A> 。 如果在 <xref:System.Net.Sockets.Socket.BeginConnect%2A> 调用之前调用了、 <xref:System.Net.Sockets.Socket.Connect%2A> 或 <xref:System.Net.Sockets.Socket.ConnectAsync%2A> 方法 <xref:System.Net.Sockets.Socket.SendToAsync%2A> ，则该 <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> 属性将替代仅用于该发送操作的指定的默认远程主机。 您也不需要调用 <xref:System.Net.Sockets.Socket.Bind%2A> 方法。 在这种情况下，基础服务提供程序将分配最适当的本地网络 IP 地址和端口号。 如果希望基础服务提供商选择可用端口，请使用端口号零。 如果需要确定分配的本地网络 IP 地址和端口号，可以在 <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> 事件终止后使用属性， <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType> 并调用关联的委托。  
  
 如果要将数据发送到广播地址，则必须先调用 <xref:System.Net.Sockets.Socket.SetSocketOption%2A> 方法，并将 socket 选项设置为 <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType> true。 还必须确保缓冲区的大小不超过基础服务提供程序的最大数据包大小。 如果是这样，则不会发送数据报并 <xref:System.Net.Sockets.Socket.SendToAsync%2A> 将引发 <xref:System.Net.Sockets.SocketException> 。  
  
 如果在属性中指定 DontRoute 标志 <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags%2A?displayProperty=nameWithType> ，则将不路由要发送的数据。  
  
 对于面向消息的套接字，必须注意不要超出基础传输的最大消息大小。 如果缓冲区的大小超过了基础服务提供程序的最大数据包大小，则不会发送数据报并 <xref:System.Net.Sockets.Socket.SendToAsync%2A> 将引发 <xref:System.Net.Sockets.SocketException> 。 成功完成 <xref:System.Net.Sockets.Socket.SendToAsync%2A> 方法并不表示数据已成功传递。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> 不能为 null。</exception>
        <exception cref="T:System.InvalidOperationException">已经在使用 <paramref name="e" /> 参数中指定的 <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> 对象执行套接字操作。</exception>
        <exception cref="T:System.NotSupportedException">此方法需要 Windows XP 或更高版本。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">指定的协议是面向连接的，但 <see cref="T:System.Net.Sockets.Socket" /> 尚未连接。</exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Offset" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="SetIPProtectionLevel">
      <MemberSignature Language="C#" Value="public void SetIPProtectionLevel (System.Net.Sockets.IPProtectionLevel level);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetIPProtectionLevel(valuetype System.Net.Sockets.IPProtectionLevel level) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SetIPProtectionLevel(System.Net.Sockets.IPProtectionLevel)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetIPProtectionLevel (level As IPProtectionLevel)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetIPProtectionLevel(System::Net::Sockets::IPProtectionLevel level);" />
      <MemberSignature Language="F#" Value="member this.SetIPProtectionLevel : System.Net.Sockets.IPProtectionLevel -&gt; unit" Usage="socket.SetIPProtectionLevel level" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="level" Type="System.Net.Sockets.IPProtectionLevel" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="level">要为此套接字设置的 IP 保护级别。</param>
        <summary>设置套接字的 IP 保护级别。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.SetIPProtectionLevel%2A>使用方法，可以限制 IPv6 或 IP 套接字侦听指定的作用域，如具有相同链接本地或站点本地前缀的地址。 此套接字选项使应用程序可以对 IPv6 或 IP 套接字设置访问限制。 通过应用此类限制，可让在专用局域网上运行的应用程序能够通过简单的方式很好地增强自身的安全性，以便防范外部攻击。 如果将参数设置为，还可以使用此套接字选项来删除访问限制 `level` <xref:System.Net.Sockets.IPProtectionLevel.Unrestricted> 。 此套接字选项可以扩大或缩小侦听套接字的范围，从而使得公共用户和私人用户可以在适当情况下对站点进行无限制的访问，或者可以根据需要对同一站点进行有限制的访问。  
  
 此套接字选项具有 <xref:System.Net.Sockets.IPProtectionLevel> 枚举中指定的已定义保护级别。  
  
 <xref:System.Net.Sockets.Socket.SetIPProtectionLevel%2A>方法用于启用或禁用实例的网络地址遍历 (NAT) <xref:System.Net.Sockets.Socket> 。 可以使用 Teredo、6to4 或 ISATAP 隧道来提供 NAT 遍历。  
  
 当 `level` 参数设置为或时 <xref:System.Net.Sockets.IPProtectionLevel.EdgeRestricted> <xref:System.Net.Sockets.IPProtectionLevel.Restricted> ，这会显式禁用实例的 NAT 遍历 <xref:System.Net.Sockets.Socket> 。  
  
 当 `level` 参数设置为时 <xref:System.Net.Sockets.IPProtectionLevel.EdgeRestricted> ，这可能会允许 NAT 遍历系统上的 <xref:System.Net.Sockets.Socket> 防火墙规则。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="level" /> 参数不能为 <see cref="F:System.Net.Sockets.IPProtectionLevel.Unspecified" />。 IP 保护级别不能设置为未指定。</exception>
        <exception cref="T:System.NotSupportedException">套接字的 <see cref="T:System.Net.Sockets.AddressFamily" /> 必须为 <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> 或 <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" />。</exception>
        <altmember cref="P:System.Net.IPAddress.IsIPv6Teredo" />
        <altmember cref="T:System.Net.Sockets.IPProtectionLevel" />
        <altmember cref="F:System.Net.Sockets.SocketOptionName.IPProtectionLevel" />
        <altmember cref="M:System.Net.Sockets.TcpListener.AllowNatTraversal(System.Boolean)" />
        <altmember cref="M:System.Net.Sockets.UdpClient.AllowNatTraversal(System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="SetRawSocketOption">
      <MemberSignature Language="C#" Value="public void SetRawSocketOption (int optionLevel, int optionName, ReadOnlySpan&lt;byte&gt; optionValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetRawSocketOption(int32 optionLevel, int32 optionName, valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; optionValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SetRawSocketOption(System.Int32,System.Int32,System.ReadOnlySpan{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetRawSocketOption (optionLevel As Integer, optionName As Integer, optionValue As ReadOnlySpan(Of Byte))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetRawSocketOption(int optionLevel, int optionName, ReadOnlySpan&lt;System::Byte&gt; optionValue);" />
      <MemberSignature Language="F#" Value="member this.SetRawSocketOption : int * int * ReadOnlySpan&lt;byte&gt; -&gt; unit" Usage="socket.SetRawSocketOption (optionLevel, optionName, optionValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Int32" Index="0" FrameworkAlternate="net-5.0" />
        <Parameter Name="optionName" Type="System.Int32" Index="1" FrameworkAlternate="net-5.0" />
        <Parameter Name="optionValue" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="2" FrameworkAlternate="net-5.0" />
      </Parameters>
      <Docs>
        <param name="optionLevel">平台定义的选项级别。</param>
        <param name="optionName">平台定义的选项名称。</param>
        <param name="optionValue">选项应设置的值。</param>
        <summary>使用平台特定的级别和名称标识符设置套接字选项值。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

通常，在 `SetSocketOption` 设置选项时，应使用方法 <xref:System.Net.Sockets.Socket> 。

<xref:System.Net.Sockets.Socket.SetRawSocketOption(System.Int32,System.Int32,System.ReadOnlySpan{System.Byte})>仅当 <xref:System.Net.Sockets.SocketOptionLevel> 和 <xref:System.Net.Sockets.SocketOptionName> 不公开所需选项时才应使用方法。

          ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="SetSocketOption">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>设置 <see cref="T:System.Net.Sockets.Socket" /> 选项。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetSocketOption">
      <MemberSignature Language="C#" Value="public void SetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName, bool optionValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName, bool optionValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetSocketOption (optionLevel As SocketOptionLevel, optionName As SocketOptionName, optionValue As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetSocketOption(System::Net::Sockets::SocketOptionLevel optionLevel, System::Net::Sockets::SocketOptionName optionName, bool optionValue);" />
      <MemberSignature Language="F#" Value="member this.SetSocketOption : System.Net.Sockets.SocketOptionLevel * System.Net.Sockets.SocketOptionName * bool -&gt; unit" Usage="socket.SetSocketOption (optionLevel, optionName, optionValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="optionValue" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="optionLevel"><see cref="T:System.Net.Sockets.SocketOptionLevel" /> 值之一。</param>
        <param name="optionName"><see cref="T:System.Net.Sockets.SocketOptionName" /> 值之一。</param>
        <param name="optionValue">选项的值，表示为 <see cref="T:System.Boolean" />。</param>
        <summary>将指定的 <see cref="T:System.Net.Sockets.Socket" /> 选项设置为指定的 <see cref="T:System.Boolean" /> 值。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket> 选项确定当前的行为 <xref:System.Net.Sockets.Socket> 。 设置 `optionValue` 为 `true` 以启用选项，或设置为以 `false` 禁用选项。  
  
 <xref:System.Net.Sockets.Socket> 按协议支持级别对选项进行分组。  
  
 下面列出了 <xref:System.Net.Sockets.Socket> 可使用此重载设置的各种选项。 这些选项按适当的值进行分组 <xref:System.Net.Sockets.SocketOptionLevel> 。 如果要设置这些选项中的任何一个，请确保为参数使用适当的 <xref:System.Net.Sockets.SocketOptionLevel> 值 `optionLevel` 。 您选择设置的选项必须在参数中指定 `optionName` 。 如果要获取所列出的任何选项的当前值，请使用 <xref:System.Net.Sockets.Socket.GetSocketOption%2A> 方法。  
  
 <xref:System.Net.Sockets.SocketOptionLevel.Socket?displayProperty=nameWithType> 可使用此重载设置的选项。  
  
-   <xref:System.Net.Sockets.SocketOptionName.AcceptConnection>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Broadcast>  
  
-   <xref:System.Net.Sockets.SocketOptionName.DontLinger>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Debug>  
  
-   <xref:System.Net.Sockets.SocketOptionName.KeepAlive>  
  
-   <xref:System.Net.Sockets.SocketOptionName.OutOfBandInline>  
  
-   <xref:System.Net.Sockets.SocketOptionName.ReuseAddress>  
  
 <xref:System.Net.Sockets.SocketOptionLevel.IP?displayProperty=nameWithType> 可使用此重载设置的选项。  
  
-   <xref:System.Net.Sockets.SocketOptionName.HeaderIncluded>  
  
-   <xref:System.Net.Sockets.SocketOptionName.MulticastLoopback>  
  
-   <xref:System.Net.Sockets.SocketOptionName.UseLoopback>  
  
 <xref:System.Net.Sockets.SocketOptionLevel.Tcp?displayProperty=nameWithType> 可使用此重载设置的选项。  
  
-   <xref:System.Net.Sockets.SocketOptionName.BsdUrgent>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Expedited>  
  
-   <xref:System.Net.Sockets.SocketOptionName.NoDelay>  
  
 <xref:System.Net.Sockets.SocketOptionLevel.Udp?displayProperty=nameWithType> 可使用此重载设置的选项。  
  
-   <xref:System.Net.Sockets.SocketOptionName.NoChecksum>  
  
 有关这些选项的详细信息，请参阅 <xref:System.Net.Sockets.SocketOptionName> 枚举。  
  
> [!NOTE]
>  如果收到 <xref:System.Net.Sockets.SocketException> 异常，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。 获取此代码后，请参阅 [Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2) 文档，以获取有关错误的详细说明。  
  
   
  
## Examples  
 下面的代码示例打开套接字，并启用 `DontLinger` 和 `OutOfBandInline` 套接字选项。  
  
 [!code-cpp[NCLSocketEnhancements#5](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#5)]
 [!code-csharp[NCLSocketEnhancements#5](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 对象已关闭。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
      </Docs>
    </Member>
    <Member MemberName="SetSocketOption">
      <MemberSignature Language="C#" Value="public void SetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName, byte[] optionValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName, unsigned int8[] optionValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetSocketOption (optionLevel As SocketOptionLevel, optionName As SocketOptionName, optionValue As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetSocketOption(System::Net::Sockets::SocketOptionLevel optionLevel, System::Net::Sockets::SocketOptionName optionName, cli::array &lt;System::Byte&gt; ^ optionValue);" />
      <MemberSignature Language="F#" Value="member this.SetSocketOption : System.Net.Sockets.SocketOptionLevel * System.Net.Sockets.SocketOptionName * byte[] -&gt; unit" Usage="socket.SetSocketOption (optionLevel, optionName, optionValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="optionValue" Type="System.Byte[]" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="optionLevel"><see cref="T:System.Net.Sockets.SocketOptionLevel" /> 值之一。</param>
        <param name="optionName"><see cref="T:System.Net.Sockets.SocketOptionName" /> 值之一。</param>
        <param name="optionValue"><see cref="T:System.Byte" /> 类型的数组，表示选项值。</param>
        <summary>将指定的 <see cref="T:System.Net.Sockets.Socket" /> 选项设置为指定的值，表示为字节数组。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket> 选项确定当前的行为 <xref:System.Net.Sockets.Socket> 。 使用此重载可以设置那些 <xref:System.Net.Sockets.Socket> 需要字节数组作为选项值的选项。  
  
> [!NOTE]
>  如果收到 <xref:System.Net.Sockets.SocketException> ，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。 获取此代码后，请参阅 [Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2) 文档，以获取有关错误的详细说明。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅 [.NET Framework 中的网络跟踪](/dotnet/framework/network-programming/network-tracing)。  
  
   
  
## Examples  
 下面的代码示例设置 <xref:System.Net.Sockets.LingerOption> 和超时 <xref:System.Net.Sockets.Socket.Send%2A> 值。  
  
 [!code-cpp[Socket_Socket_Options#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#1)]
 [!code-csharp[Socket_Socket_Options#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#1)]
 [!code-vb[Socket_Socket_Options#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <altmember cref="T:System.Net.Sockets.SocketOptionName" />
        <altmember cref="T:System.Net.Sockets.SocketOptionLevel" />
        <altmember cref="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)" />
      </Docs>
    </Member>
    <Member MemberName="SetSocketOption">
      <MemberSignature Language="C#" Value="public void SetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName, int optionValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName, int32 optionValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetSocketOption (optionLevel As SocketOptionLevel, optionName As SocketOptionName, optionValue As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetSocketOption(System::Net::Sockets::SocketOptionLevel optionLevel, System::Net::Sockets::SocketOptionName optionName, int optionValue);" />
      <MemberSignature Language="F#" Value="member this.SetSocketOption : System.Net.Sockets.SocketOptionLevel * System.Net.Sockets.SocketOptionName * int -&gt; unit" Usage="socket.SetSocketOption (optionLevel, optionName, optionValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="optionValue" Type="System.Int32" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="optionLevel"><see cref="T:System.Net.Sockets.SocketOptionLevel" /> 值之一。</param>
        <param name="optionName"><see cref="T:System.Net.Sockets.SocketOptionName" /> 值之一。</param>
        <param name="optionValue">该选项的值。</param>
        <summary>将指定的 <see cref="T:System.Net.Sockets.Socket" /> 选项设置为指定的整数值。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket> 选项确定当前的行为 <xref:System.Net.Sockets.Socket> 。 对于数据类型为的选项 <xref:System.Boolean> ，请指定一个非零值以启用该选项，并指定零值以禁用该选项。 对于整数数据类型的选项，请指定相应的值。 <xref:System.Net.Sockets.Socket> 按协议支持级别对选项进行分组。  
  
 下面列出了 <xref:System.Net.Sockets.Socket> 可使用此重载设置的各种选项。 这些选项按适当的方式进行分组 <xref:System.Net.Sockets.SocketOptionLevel> 。 如果要设置这些选项中的任何一个，请确保对参数使用合适的 <xref:System.Net.Sockets.SocketOptionLevel> `optionLevel` 。 您选择设置的选项必须在参数中指定 `optionName` 。 如果要获取所列出的任何选项的当前值，请使用 <xref:System.Net.Sockets.Socket.GetSocketOption%2A> 方法。  
  
 <xref:System.Net.Sockets.SocketOptionLevel.Socket?displayProperty=nameWithType> 可使用此重载设置的选项。  
  
-   <xref:System.Net.Sockets.SocketOptionName.Broadcast>  
  
-   <xref:System.Net.Sockets.SocketOptionName.DontLinger>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Debug>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Error>  
  
-   <xref:System.Net.Sockets.SocketOptionName.KeepAlive>  
  
-   <xref:System.Net.Sockets.SocketOptionName.OutOfBandInline>  
  
-   <xref:System.Net.Sockets.SocketOptionName.ReceiveBuffer>  
  
-   <xref:System.Net.Sockets.SocketOptionName.ReceiveTimeout>  
  
-   <xref:System.Net.Sockets.SocketOptionName.ReuseAddress>  
  
-   <xref:System.Net.Sockets.SocketOptionName.SendBuffer>  
  
-   <xref:System.Net.Sockets.SocketOptionName.SendTimeout>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Type>  
  
 <xref:System.Net.Sockets.SocketOptionLevel.IP?displayProperty=nameWithType> 可使用此重载设置的选项。  
  
-   <xref:System.Net.Sockets.SocketOptionName.HeaderIncluded>  
  
-   <xref:System.Net.Sockets.SocketOptionName.IPOptions>  
  
-   <xref:System.Net.Sockets.SocketOptionName.IpTimeToLive>  
  
-   <xref:System.Net.Sockets.SocketOptionName.MulticastInterface>  
  
-   <xref:System.Net.Sockets.SocketOptionName.MulticastLoopback>  
  
-   <xref:System.Net.Sockets.SocketOptionName.MulticastTimeToLive>  
  
-   <xref:System.Net.Sockets.SocketOptionName.TypeOfService>  
  
-   <xref:System.Net.Sockets.SocketOptionName.UseLoopback>  
  
 <xref:System.Net.Sockets.SocketOptionLevel.Tcp?displayProperty=nameWithType> 可使用此重载设置的选项。  
  
-   <xref:System.Net.Sockets.SocketOptionName.BsdUrgent>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Expedited>  
  
-   <xref:System.Net.Sockets.SocketOptionName.NoDelay>  
  
 <xref:System.Net.Sockets.SocketOptionLevel.Udp?displayProperty=nameWithType> 可使用此重载设置的选项。  
  
-   <xref:System.Net.Sockets.SocketOptionName.ChecksumCoverage>  
  
-   <xref:System.Net.Sockets.SocketOptionName.NoChecksum>  
  
 <xref:System.Net.Sockets.SocketOptionLevel.IPv6?displayProperty=nameWithType> 可使用此重载设置的选项。  
  
-   <xref:System.Net.Sockets.SocketOptionName.HopLimit>  
  
 有关这些选项的详细信息，请参阅 <xref:System.Net.Sockets.SocketOptionName> 枚举。  
  
> [!NOTE]
>  如果收到 <xref:System.Net.Sockets.SocketException> ，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。 获取此代码后，请参阅 [Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2) 文档，以获取有关错误的详细说明。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅 [.NET Framework 中的网络跟踪](/dotnet/framework/network-programming/network-tracing)。  
  
   
  
## Examples  
 下面的代码示例设置 <xref:System.Net.Sockets.LingerOption> 和超时 <xref:System.Net.Sockets.Socket.Send%2A> 值。  
  
 [!code-cpp[Socket_Socket_Options#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#1)]
 [!code-csharp[Socket_Socket_Options#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#1)]
 [!code-vb[Socket_Socket_Options#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <altmember cref="T:System.Net.Sockets.SocketOptionName" />
        <altmember cref="T:System.Net.Sockets.SocketOptionLevel" />
        <altmember cref="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)" />
      </Docs>
    </Member>
    <Member MemberName="SetSocketOption">
      <MemberSignature Language="C#" Value="public void SetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName, object optionValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName, object optionValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetSocketOption (optionLevel As SocketOptionLevel, optionName As SocketOptionName, optionValue As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetSocketOption(System::Net::Sockets::SocketOptionLevel optionLevel, System::Net::Sockets::SocketOptionName optionName, System::Object ^ optionValue);" />
      <MemberSignature Language="F#" Value="member this.SetSocketOption : System.Net.Sockets.SocketOptionLevel * System.Net.Sockets.SocketOptionName * obj -&gt; unit" Usage="socket.SetSocketOption (optionLevel, optionName, optionValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="optionValue" Type="System.Object" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="optionLevel"><see cref="T:System.Net.Sockets.SocketOptionLevel" /> 值之一。</param>
        <param name="optionName"><see cref="T:System.Net.Sockets.SocketOptionName" /> 值之一。</param>
        <param name="optionValue">一个 <see cref="T:System.Net.Sockets.LingerOption" /> 或 <see cref="T:System.Net.Sockets.MulticastOption" />，它包含该选项的值。</param>
        <summary>将指定的 <see cref="T:System.Net.Sockets.Socket" /> 选项设置为指定值，表示为对象。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket> 选项确定当前的行为 <xref:System.Net.Sockets.Socket> 。 使用此重载设置 <xref:System.Net.Sockets.SocketOptionName.Linger> 、 <xref:System.Net.Sockets.SocketOptionName.AddMembership> 和 <xref:System.Net.Sockets.SocketOptionName.DropMembership> <xref:System.Net.Sockets.Socket> 选项。 对于 <xref:System.Net.Sockets.SocketOptionName.Linger> 选项，请使用 <xref:System.Net.Sockets.Socket> 作为 `optionLevel` 参数。 对于 <xref:System.Net.Sockets.SocketOptionName.AddMembership> 和 <xref:System.Net.Sockets.SocketOptionName.DropMembership> ，请使用 <xref:System.Net.Sockets.SocketOptionLevel.IP> 。 如果要获取上面列出的任何选项的当前值，请使用 <xref:System.Net.Sockets.Socket.GetSocketOption%2A> 方法。  
  
> [!NOTE]
>  如果收到 <xref:System.Net.Sockets.SocketException> ，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。 获取此代码后，请参阅 [Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2) 文档，以获取有关错误的详细说明。  
  
   
  
## Examples  
 下面的代码示例设置 <xref:System.Net.Sockets.LingerOption> 和超时 <xref:System.Net.Sockets.Socket.Send%2A> 值。  
  
 [!code-cpp[Socket_Socket_Options#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#1)]
 [!code-csharp[Socket_Socket_Options#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#1)]
 [!code-vb[Socket_Socket_Options#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="optionValue" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <altmember cref="T:System.Net.Sockets.SocketOptionName" />
        <altmember cref="T:System.Net.Sockets.SocketOptionLevel" />
        <altmember cref="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)" />
      </Docs>
    </Member>
    <Member MemberName="Shutdown">
      <MemberSignature Language="C#" Value="public void Shutdown (System.Net.Sockets.SocketShutdown how);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Shutdown(valuetype System.Net.Sockets.SocketShutdown how) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Shutdown (how As SocketShutdown)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Shutdown(System::Net::Sockets::SocketShutdown how);" />
      <MemberSignature Language="F#" Value="member this.Shutdown : System.Net.Sockets.SocketShutdown -&gt; unit" Usage="socket.Shutdown how" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="how" Type="System.Net.Sockets.SocketShutdown" />
      </Parameters>
      <Docs>
        <param name="how"><see cref="T:System.Net.Sockets.SocketShutdown" /> 值之一，它指定不再允许执行的操作。</param>
        <summary>禁用某 <see cref="T:System.Net.Sockets.Socket" /> 上的发送和接收。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用面向连接的时 <xref:System.Net.Sockets.Socket> ，请始终在 <xref:System.Net.Sockets.Socket.Shutdown%2A> 关闭之前调用方法 <xref:System.Net.Sockets.Socket> 。 这可确保所有数据在连接的套接字关闭之前都已发送和接收。  
  
 调用 <xref:System.Net.Sockets.Socket.Close%2A> 方法以释放与关联的所有托管资源和非托管资源 <xref:System.Net.Sockets.Socket> 。 不要尝试 <xref:System.Net.Sockets.Socket> 在关闭后使用。  
  
 下表显示 <xref:System.Net.Sockets.SocketShutdown> 了对参数有效的枚举值 `how` 。  
  
|“值”|描述|  
|-----------|-----------------|  
|发送|禁止在此上发送 <xref:System.Net.Sockets.Socket> 。|  
|接收|禁止在此上接收 <xref:System.Net.Sockets.Socket> 。|  
|两者|在此上禁用发送和接收 <xref:System.Net.Sockets.Socket> 。|  
  
 设置 `how` 为 <xref:System.Net.Sockets.SocketShutdown.Send> 指定不允许对的后续调用 <xref:System.Net.Sockets.Socket.Send%2A> 。 如果使用的是无连接的 <xref:System.Net.Sockets.Socket> ，则指定 <xref:System.Net.Sockets.SocketShutdown.Send> 将不起作用。  
  
 设置 `how` 为 <xref:System.Net.Sockets.SocketShutdown.Receive> 指定不允许对的后续调用 <xref:System.Net.Sockets.Socket.Receive%2A> 。 这在较低的协议层上不起作用。 如果使用面向连接的协议，则在调用以下任一条件后，将终止连接 <xref:System.Net.Sockets.Socket.Shutdown%2A> ：  
  
-   数据位于传入网络缓冲区中等待接收。  
  
-   已到达更多数据。  
  
 如果使用的是无连接协议，则接受并排队数据报。 但是，如果没有可用于附加传入数据报的缓冲区空间，则将丢弃这些数据，并且不会将错误返回给发件人。 <xref:System.Net.Sockets.Socket.Shutdown%2A>不建议在无连接上使用 <xref:System.Net.Sockets.Socket> 。  
  
 `how` <xref:System.Net.Sockets.SocketShutdown.Both> 按如上所述禁用发送和接收的设置。  
  
> [!NOTE]
>  如果在 <xref:System.Net.Sockets.SocketException> 调用方法时接收到 <xref:System.Net.Sockets.Socket.Shutdown%2A> ，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。 获取此代码后，请参阅 [Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2) 文档，以获取有关错误的详细说明。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅 [.NET Framework 中的网络跟踪](/dotnet/framework/network-programming/network-tracing)。  
  
   
  
## Examples  
 下面的代码示例使用 <xref:System.Net.Sockets.Socket.Shutdown%2A> 来禁用 <xref:System.Net.Sockets.Socket> 。  
  
 [!code-cpp[Classic Socket.Close Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Close Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Close Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Close Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Close Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Close Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
        <altmember cref="T:System.Net.Sockets.SocketShutdown" />
      </Docs>
    </Member>
    <Member MemberName="SocketType">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.SocketType SocketType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Net.Sockets.SocketType SocketType" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.SocketType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SocketType As SocketType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Sockets::SocketType SocketType { System::Net::Sockets::SocketType get(); };" />
      <MemberSignature Language="F#" Value="member this.SocketType : System.Net.Sockets.SocketType" Usage="System.Net.Sockets.Socket.SocketType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.SocketType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取 <see cref="T:System.Net.Sockets.Socket" /> 的类型。</summary>
        <value><see cref="T:System.Net.Sockets.SocketType" /> 值之一。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.SocketType%2A> 是只读的，并且在创建时设置 <xref:System.Net.Sockets.Socket> 。  
  
   
  
## Examples  
 下面的代码示例将 <xref:System.Net.Sockets.AddressFamily> 、 <xref:System.Net.Sockets.SocketType> 和显示 <xref:System.Net.Sockets.ProtocolType> 到控制台。  
  
 [!code-cpp[Socket_Socket_Options#3](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#3)]
 [!code-csharp[Socket_Socket_Options#3](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#3)]
 [!code-vb[Socket_Socket_Options#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.Sockets.SocketType" />
      </Docs>
    </Member>
    <Member MemberName="SupportsIPv4">
      <MemberSignature Language="C#" Value="public static bool SupportsIPv4 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool SupportsIPv4" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.SupportsIPv4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SupportsIPv4 As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool SupportsIPv4 { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.SupportsIPv4 : bool" Usage="System.Net.Sockets.Socket.SupportsIPv4" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0">
          <AttributeName Language="C#">[System.Obsolete("SupportsIPv4 is obsoleted for this type, please use OSSupportsIPv4 instead. http://go.microsoft.com/fwlink/?linkid=14202")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Obsolete("SupportsIPv4 is obsoleted for this type, please use OSSupportsIPv4 instead. http://go.microsoft.com/fwlink/?linkid=14202")&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netcore-3.1;netstandard-2.1">
          <AttributeName Language="C#">[System.Obsolete("SupportsIPv4 is obsoleted for this type, please use OSSupportsIPv4 instead. https://go.microsoft.com/fwlink/?linkid=14202")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Obsolete("SupportsIPv4 is obsoleted for this type, please use OSSupportsIPv4 instead. https://go.microsoft.com/fwlink/?linkid=14202")&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Obsolete("Use OSSupportsIPv4 instead")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Obsolete("Use OSSupportsIPv4 instead")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示在当前主机上 IPv4 支持是否可用并且已启用。</summary>
        <value>如果当前主机支持 IPv4 协议，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 操作系统可能支持 IPv4 和 IPv6 协议。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Net.Sockets.Socket.SupportsIPv6" />
      </Docs>
    </Member>
    <Member MemberName="SupportsIPv6">
      <MemberSignature Language="C#" Value="public static bool SupportsIPv6 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool SupportsIPv6" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.SupportsIPv6" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SupportsIPv6 As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool SupportsIPv6 { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.SupportsIPv6 : bool" Usage="System.Net.Sockets.Socket.SupportsIPv6" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0">
          <AttributeName Language="C#">[System.Obsolete("SupportsIPv6 is obsoleted for this type, please use OSSupportsIPv6 instead. http://go.microsoft.com/fwlink/?linkid=14202")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Obsolete("SupportsIPv6 is obsoleted for this type, please use OSSupportsIPv6 instead. http://go.microsoft.com/fwlink/?linkid=14202")&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netcore-3.1;netstandard-2.1">
          <AttributeName Language="C#">[System.Obsolete("SupportsIPv6 is obsoleted for this type, please use OSSupportsIPv6 instead. https://go.microsoft.com/fwlink/?linkid=14202")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Obsolete("SupportsIPv6 is obsoleted for this type, please use OSSupportsIPv6 instead. https://go.microsoft.com/fwlink/?linkid=14202")&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Obsolete("Use OSSupportsIPv6 instead")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Obsolete("Use OSSupportsIPv6 instead")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示 Framework 对某些已过时的 <see cref="T:System.Net.Dns" /> 成员是否支持 IPv6。</summary>
        <value>如果 Framework 对某些已过时的 <see cref="T:System.Net.Dns" /> 方法支持 IPv6，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 操作系统可能支持 IPv4 和 IPv6 协议。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Net.Sockets.Socket.OSSupportsIPv6" />
        <altmember cref="P:System.Net.Sockets.Socket.SupportsIPv4" />
      </Docs>
    </Member>
    <Member MemberName="System.IDisposable.Dispose">
      <MemberSignature Language="C#" Value="void IDisposable.Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.IDisposable.Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.System#IDisposable#Dispose" />
      <MemberSignature Language="VB.NET" Value="Sub Dispose () Implements IDisposable.Dispose" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.IDisposable.Dispose() = IDisposable::Dispose;" />
      <MemberSignature Language="F#" Value="abstract member System.IDisposable.Dispose : unit -&gt; unit&#xA;override this.System.IDisposable.Dispose : unit -&gt; unit" Usage="socket.System.IDisposable.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>释放由 <see cref="T:System.Net.Sockets.Socket" /> 使用的所有资源。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks  
使用完后，调用 <xref:System.Net.Sockets.Socket> IDisposable。 IDisposable 方法会使 <xref:System.Net.Sockets.Socket> 处于不可用状态。 调用 IDisposable 之后，必须释放对的所有引用， <xref:System.Net.Sockets.Socket> 这样垃圾回收器才能收回占用的内存 <xref:System.Net.Sockets.Socket> 。 有关详细信息，请参阅 [清理非托管资源](/dotnet/standard/garbage-collection/unmanaged) 和 [实现 Dispose 方法](/dotnet/standard/garbage-collection/implementing-dispose)。

> [!NOTE] 
> 在释放对的最后一个引用之前，请始终调用 IDisposable <xref:System.Net.Sockets.Socket> 。 否则，在垃圾回收器调用 <xref:System.Net.Sockets.Socket> 对象的 `Finalize` 方法之前，该对象正在使用的资源不会被释放。

]]></format>
        </remarks>
        <forInternalUseOnly />
      </Docs>
    </Member>
    <Member MemberName="Ttl">
      <MemberSignature Language="C#" Value="public short Ttl { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int16 Ttl" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.Ttl" />
      <MemberSignature Language="VB.NET" Value="Public Property Ttl As Short" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property short Ttl { short get(); void set(short value); };" />
      <MemberSignature Language="F#" Value="member this.Ttl : int16 with get, set" Usage="System.Net.Sockets.Socket.Ttl" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，指定 <see cref="T:System.Net.Sockets.Socket" /> 发送的 Internet 协议 (IP) 数据包的生存时间 (TTL) 值。</summary>
        <value>TTL 值。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 TTL 值表示在路由器丢弃数据包和 Internet 控制消息协议 (ICMP) "超过 TTL" 错误消息返回给发件人之前，数据包可以遍历的路由器的最大数目。  
  
 TTL 值可以设置为0到255之间的值。 如果未设置此属性，则套接字的默认 TTL 值为32。  
  
 如果已使用套接字建立成功的连接，则 TCP/IP 堆栈将忽略 () TCP/IP 堆栈设置此属性。  
  
 如果收到 <xref:System.Net.Sockets.SocketException> ，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。 获取此代码后，请参阅 [Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2) 文档，以获取有关错误的详细说明。  
  
   
  
## Examples  
 下面的代码示例演示属性的用法 <xref:System.Net.Sockets.Socket.Ttl%2A> 。  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">TTL 值不能设置为负数。</exception>
        <exception cref="T:System.NotSupportedException">只有对于在 <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> 或 <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> 族中的套接字，才可以设置此属性。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。 在尝试将 TTL 设置为大于 255 的值时，也将返回此错误。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
      </Docs>
    </Member>
    <Member MemberName="UseOnlyOverlappedIO">
      <MemberSignature Language="C#" Value="public bool UseOnlyOverlappedIO { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseOnlyOverlappedIO" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.UseOnlyOverlappedIO" />
      <MemberSignature Language="VB.NET" Value="Public Property UseOnlyOverlappedIO As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UseOnlyOverlappedIO { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UseOnlyOverlappedIO : bool with get, set" Usage="System.Net.Sockets.Socket.UseOnlyOverlappedIO" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.MonoTODO("This doesn't do anything on Mono yet")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.MonoTODO("This doesn't do anything on Mono yet")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指定套接字是否应仅使用重叠 I/O 模式。</summary>
        <value>如果 <see cref="T:System.Net.Sockets.Socket" /> 仅使用重叠 I/O，则为 <see langword="true" />；否则为 <see langword="false" />。 默认值为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `true`如果要调用，请将此属性设置为 <xref:System.Net.Sockets.Socket> <xref:System.Net.Sockets.Socket.DuplicateAndClose%2A> 。 否则，框架可能会为套接字分配完成端口，这将禁止使用 <xref:System.Net.Sockets.Socket.DuplicateAndClose%2A> 。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">套接字已绑定到完成端口。</exception>
      </Docs>
    </Member>
  </Members>
</Type>
