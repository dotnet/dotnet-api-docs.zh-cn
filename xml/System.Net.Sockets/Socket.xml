<Type Name="Socket" FullName="System.Net.Sockets.Socket">
  <Metadata><Meta Name="ms.openlocfilehash" Value="57a635fcfcf4dc73477d5eaedc9dd42615b464e0" /><Meta Name="ms.sourcegitcommit" Value="11d168140aa8fade0768c2a9dde3e3bcacfdfb7d" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-CN" /><Meta Name="ms.lasthandoff" Value="05/27/2020" /><Meta Name="ms.locfileid" Value="83894387" /></Metadata><TypeSignature Language="C#" Value="public class Socket : IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit Socket extends System.Object implements class System.IDisposable" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1" />
  <TypeSignature Language="DocId" Value="T:System.Net.Sockets.Socket" />
  <TypeSignature Language="VB.NET" Value="Public Class Socket&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Socket : IDisposable" />
  <TypeSignature Language="F#" Value="type Socket = class&#xA;    interface IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi Socket extends System.Object implements class System.IDisposable" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <AssemblyInfo>
    <AssemblyName>System.Net.Sockets</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
    <AssemblyVersion>4.2.2.0</AssemblyVersion>
    <AssemblyVersion>5.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Net</AssemblyName>
  </AssemblyInfo>
  <TypeForwardingChain>
    <TypeForwarding From="netstandard" FromVersion="2.1.0.0" To="System.Net.Sockets" ToVersion="5.0.0.0" FrameworkAlternate="net-5.0" />
    <TypeForwarding From="System.Net" FromVersion="4.0.0.0" To="System" ToVersion="4.0.0.0" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
  </TypeForwardingChain>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>实现 Berkeley 套接字接口。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket> 类提供一组丰富的用于网络通信的方法和属性。 <xref:System.Net.Sockets.Socket> 类允许使用 <xref:System.Net.Sockets.ProtocolType> 枚举中列出的任何通信协议执行同步和异步数据传输。  
  
 <xref:System.Net.Sockets.Socket> 类遵循异步方法 .NET Framework 命名模式。 例如，同步 <xref:System.Net.Sockets.Socket.Receive%2A> 方法与异步 <xref:System.Net.Sockets.Socket.BeginReceive%2A> 和 <xref:System.Net.Sockets.Socket.EndReceive%2A> 方法相对应。  
  
 如果应用程序在执行过程中只需要一个线程，请使用以下方法，这些方法是为同步操作模式设计的。  
  
-   如果使用面向连接的协议（例如 TCP），则服务器可以使用 <xref:System.Net.Sockets.Socket.Listen%2A> 方法侦听连接。 <xref:System.Net.Sockets.Socket.Accept%2A> 方法处理任何传入连接请求，并返回可用于与远程主机通信的 <xref:System.Net.Sockets.Socket>。 使用返回 <xref:System.Net.Sockets.Socket> 调用 <xref:System.Net.Sockets.Socket.Send%2A> 或 <xref:System.Net.Sockets.Socket.Receive%2A> 方法。 如果要指定本地 IP 地址和端口号，请在调用 <xref:System.Net.Sockets.Socket.Listen%2A> 方法之前调用 <xref:System.Net.Sockets.Socket.Bind%2A> 方法。 如果希望基础服务提供商为你分配一个可用端口，请使用端口号零。 如果要连接到侦听主机，请调用 <xref:System.Net.Sockets.Socket.Connect%2A> 方法。 若要传递数据，请调用 <xref:System.Net.Sockets.Socket.Send%2A> 或 <xref:System.Net.Sockets.Socket.Receive%2A> 方法。  
  
-   如果使用的是无连接协议（如 UDP），则无需侦听连接。 调用 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 方法以接受任何传入的数据报。 使用 <xref:System.Net.Sockets.Socket.SendTo%2A> 方法将数据报发送到远程主机。  
  
 若要在执行过程中使用单独的线程来处理通信，请使用以下方法，这些方法是为异步操作模式设计的。  
  
-   如果使用面向连接的协议（如 TCP），请使用 <xref:System.Net.Sockets.Socket>、<xref:System.Net.Sockets.Socket.BeginConnect%2A>和 <xref:System.Net.Sockets.Socket.EndConnect%2A> 方法连接到侦听主机。 使用 <xref:System.Net.Sockets.Socket.BeginSend%2A> 和 <xref:System.Net.Sockets.Socket.EndSend%2A> 或 <xref:System.Net.Sockets.Socket.BeginReceive%2A> 和 <xref:System.Net.Sockets.Socket.EndReceive%2A> 方法以异步方式传递数据。 可以使用 <xref:System.Net.Sockets.Socket.BeginAccept%2A> 和 <xref:System.Net.Sockets.Socket.EndAccept%2A>处理传入连接请求。  
  
-   如果使用的是无连接协议（如 UDP），则可以使用 <xref:System.Net.Sockets.Socket.BeginSendTo%2A> 和 <xref:System.Net.Sockets.Socket.EndSendTo%2A> 发送数据报，并 <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> 和 <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> 接收数据报。  
  
 如果对套接字执行多个异步操作，则这些操作不一定按启动顺序完成。  
  
 完成发送和接收数据的操作后，请使用 <xref:System.Net.Sockets.Socket.Shutdown%2A> 方法禁用 <xref:System.Net.Sockets.Socket>。 调用 <xref:System.Net.Sockets.Socket.Shutdown%2A>后，调用 <xref:System.Net.Sockets.Socket.Close%2A> 方法以释放与 <xref:System.Net.Sockets.Socket>关联的所有资源。  
  
 <xref:System.Net.Sockets.Socket> 类允许使用 <xref:System.Net.Sockets.Socket.SetSocketOption%2A> 方法配置 <xref:System.Net.Sockets.Socket>。 使用 <xref:System.Net.Sockets.Socket.GetSocketOption%2A> 方法检索这些设置。  
  
> [!NOTE]
>  如果你正在编写一个相对简单的应用程序，并且不需要最佳性能，请考虑使用 <xref:System.Net.Sockets.TcpClient>、<xref:System.Net.Sockets.TcpListener>和 <xref:System.Net.Sockets.UdpClient>。 这些类提供了更简单、更易于使用的界面来 <xref:System.Net.Sockets.Socket> 通信。  
  
   
  
## Examples  
 下面的代码示例演示如何使用 <xref:System.Net.Sockets.Socket> 类将数据发送到 HTTP 服务器并接收响应。 在收到整个页面之前，此示例将会阻止。  
  
 [!code-cpp[System.Net.Sockets.Socket#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket/CPP/socket.cpp#1)]
 [!code-csharp[System.Net.Sockets.Socket#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket/CS/socket.cs#1)]
 [!code-vb[System.Net.Sockets.Socket#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.Sockets.Socket/VB/socket.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>此类的实例是线程安全的。</threadsafe>
    <altmember cref="N:System.Net" />
    <altmember cref="N:System.Net.Cache" />
    <altmember cref="N:System.Net.Security" />
    <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
    <related type="Article" href="/dotnet/framework/network-programming/">.NET Framework 中的网络编程</related>
    <related type="Article" href="/dotnet/framework/network-programming/best-practices-for-system-net-classes">System.Net 类的最佳实践</related>
    <related type="Article" href="/dotnet/framework/network-programming/cache-management-for-network-applications">网络应用程序的缓存管理</related>
    <related type="Article" href="/dotnet/framework/network-programming/internet-protocol-version-6">Internet 协议版本 6</related>
    <related type="Article" href="/dotnet/framework/network-programming/network-programming-samples">网络编程示例</related>
    <related type="Article" href="/dotnet/framework/network-programming/network-tracing">.NET Framework 中的网络跟踪</related>
    <related type="Article" href="/dotnet/framework/network-programming/security-in-network-programming">网络编程中的安全性</related>
    <related type="Article" href="/dotnet/framework/network-programming/socket-performance-enhancements-in-version-3-5">版本 3.5 中的套接字性能增强</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>初始化 <see cref="T:System.Net.Sockets.Socket" /> 类的新实例。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Socket (System.Net.Sockets.SafeSocketHandle handle);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Net.Sockets.SafeSocketHandle handle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.SafeSocketHandle)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (handle As SafeSocketHandle)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Socket(System::Net::Sockets::SafeSocketHandle ^ handle);" />
      <MemberSignature Language="F#" Value="new System.Net.Sockets.Socket : System.Net.Sockets.SafeSocketHandle -&gt; System.Net.Sockets.Socket" Usage="new System.Net.Sockets.Socket handle" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="handle" Type="System.Net.Sockets.SafeSocketHandle" Index="0" FrameworkAlternate="net-5.0" />
      </Parameters>
      <Docs>
        <param name="handle">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Socket (System.Net.Sockets.SocketInformation socketInformation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Net.Sockets.SocketInformation socketInformation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.SocketInformation)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (socketInformation As SocketInformation)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Socket(System::Net::Sockets::SocketInformation socketInformation);" />
      <MemberSignature Language="F#" Value="new System.Net.Sockets.Socket : System.Net.Sockets.SocketInformation -&gt; System.Net.Sockets.Socket" Usage="new System.Net.Sockets.Socket socketInformation" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="socketInformation" Type="System.Net.Sockets.SocketInformation" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="socketInformation"><see cref="M:System.Net.Sockets.Socket.DuplicateAndClose(System.Int32)" /> 返回的套接字信息。</param>
        <summary>使用 <see cref="T:System.Net.Sockets.Socket" /> 返回的指定的值初始化 <see cref="M:System.Net.Sockets.Socket.DuplicateAndClose(System.Int32)" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果多次调用 <xref:System.Net.Sockets.Socket.%23ctor%2A> 构造函数并将同一字节数组作为每次调用的参数，则将创建多个具有相同基础套接字的托管 <xref:System.Net.Sockets.Socket>。 强烈建议您不要这样做。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Socket (System.Net.Sockets.SocketType socketType, System.Net.Sockets.ProtocolType protocolType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Net.Sockets.SocketType socketType, valuetype System.Net.Sockets.ProtocolType protocolType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (socketType As SocketType, protocolType As ProtocolType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Socket(System::Net::Sockets::SocketType socketType, System::Net::Sockets::ProtocolType protocolType);" />
      <MemberSignature Language="F#" Value="new System.Net.Sockets.Socket : System.Net.Sockets.SocketType * System.Net.Sockets.ProtocolType -&gt; System.Net.Sockets.Socket" Usage="new System.Net.Sockets.Socket (socketType, protocolType)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="socketType" Type="System.Net.Sockets.SocketType" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="protocolType" Type="System.Net.Sockets.ProtocolType" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="socketType"><see cref="T:System.Net.Sockets.SocketType" /> 值之一。</param>
        <param name="protocolType"><see cref="T:System.Net.Sockets.ProtocolType" /> 值之一。</param>
        <summary>使用指定的地址族、套接字类型和协议初始化 <see cref="T:System.Net.Sockets.Socket" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `socketType` 参数指定 <xref:System.Net.Sockets.Socket> 类的类型，`protocolType` 参数指定 <xref:System.Net.Sockets.Socket>所使用的协议。 这两个参数不是独立的。 通常，<xref:System.Net.Sockets.Socket> 类型在协议中是隐式的。 如果 <xref:System.Net.Sockets.Socket> 类型和协议类型的组合导致无效 <xref:System.Net.Sockets.Socket>，则此构造函数将引发一个 <xref:System.Net.Sockets.SocketException>。  
  
> [!NOTE]
>  如果此构造函数引发 <xref:System.Net.Sockets.SocketException>，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。 获取此代码后，请参阅[Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2)文档，以获取有关错误的详细说明。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[.NET Framework 中的网络跟踪](/dotnet/framework/network-programming/network-tracing)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><paramref name="socketType" /> 和 <paramref name="protocolType" /> 组合将导致套接字无效。</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Socket (System.Net.Sockets.AddressFamily addressFamily, System.Net.Sockets.SocketType socketType, System.Net.Sockets.ProtocolType protocolType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Net.Sockets.AddressFamily addressFamily, valuetype System.Net.Sockets.SocketType socketType, valuetype System.Net.Sockets.ProtocolType protocolType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.AddressFamily,System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (addressFamily As AddressFamily, socketType As SocketType, protocolType As ProtocolType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Socket(System::Net::Sockets::AddressFamily addressFamily, System::Net::Sockets::SocketType socketType, System::Net::Sockets::ProtocolType protocolType);" />
      <MemberSignature Language="F#" Value="new System.Net.Sockets.Socket : System.Net.Sockets.AddressFamily * System.Net.Sockets.SocketType * System.Net.Sockets.ProtocolType -&gt; System.Net.Sockets.Socket" Usage="new System.Net.Sockets.Socket (addressFamily, socketType, protocolType)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="addressFamily" Type="System.Net.Sockets.AddressFamily" />
        <Parameter Name="socketType" Type="System.Net.Sockets.SocketType" />
        <Parameter Name="protocolType" Type="System.Net.Sockets.ProtocolType" />
      </Parameters>
      <Docs>
        <param name="addressFamily"><see cref="T:System.Net.Sockets.AddressFamily" /> 值之一。</param>
        <param name="socketType"><see cref="T:System.Net.Sockets.SocketType" /> 值之一。</param>
        <param name="protocolType"><see cref="T:System.Net.Sockets.ProtocolType" /> 值之一。</param>
        <summary>使用指定的地址族、套接字类型和协议初始化 <see cref="T:System.Net.Sockets.Socket" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `addressFamily` 参数指定 <xref:System.Net.Sockets.Socket> 类使用的寻址方案，`socketType` 参数指定 <xref:System.Net.Sockets.Socket> 类的类型，而 `protocolType` 参数指定 <xref:System.Net.Sockets.Socket>使用的协议。 这三个参数不是独立的。 某些地址族限制了可与它们一起使用的协议，并且 <xref:System.Net.Sockets.Socket> 类型在协议中是隐式的。 如果地址族、<xref:System.Net.Sockets.Socket> 类型和协议类型的组合导致无效 <xref:System.Net.Sockets.Socket>，则此构造函数将引发一个 <xref:System.Net.Sockets.SocketException>。  
  
> [!NOTE]
>  如果此构造函数引发 <xref:System.Net.Sockets.SocketException>，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。 获取此代码后，请参阅[Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2)文档，以获取有关错误的详细说明。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[.NET Framework 中的网络跟踪](/dotnet/framework/network-programming/network-tracing)。  
  
   
  
## Examples  
 下面的代码示例演示如何创建 <xref:System.Net.Sockets.Socket> 类的实例。  
  
 [!code-cpp[Socket_Send_Receive#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Send_Receive/CPP/source.cpp#1)]
 [!code-csharp[Socket_Send_Receive#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Send_Receive/CS/source.cs#1)]
 [!code-vb[Socket_Send_Receive#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Send_Receive/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><paramref name="addressFamily" />、<paramref name="socketType" /> 和 <paramref name="protocolType" /> 的组合会导致无效套接字。</exception>
        <altmember cref="T:System.Net.Sockets.SocketException" />
        <altmember cref="T:System.Net.Sockets.AddressFamily" />
        <altmember cref="T:System.Net.Sockets.ProtocolType" />
        <altmember cref="T:System.Net.Sockets.SocketType" />
      </Docs>
    </Member>
    <Member MemberName="Accept">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.Socket Accept ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.Sockets.Socket Accept() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Accept" />
      <MemberSignature Language="VB.NET" Value="Public Function Accept () As Socket" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::Sockets::Socket ^ Accept();" />
      <MemberSignature Language="F#" Value="member this.Accept : unit -&gt; System.Net.Sockets.Socket" Usage="socket.Accept " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.Socket</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>为新建连接创建新的 <see cref="T:System.Net.Sockets.Socket" />。</summary>
        <returns>新建连接的 <see cref="T:System.Net.Sockets.Socket" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Accept%2A> 从侦听套接字的连接请求队列中同步提取第一个挂起的连接请求，然后创建并返回新的 <xref:System.Net.Sockets.Socket>。 不能使用返回的 <xref:System.Net.Sockets.Socket> 接受来自连接队列的任何其他连接。 但是，你可以调用返回的 <xref:System.Net.Sockets.Socket> 的 <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> 方法来识别远程主机的网络地址和端口号。  
  
 在阻止模式下，<xref:System.Net.Sockets.Socket.Accept%2A> 会被阻止，直到传入连接尝试排入队列。 连接被接受后，原始 <xref:System.Net.Sockets.Socket> 将继续排队传入连接请求，直到你将其关闭。  
  
 如果使用非阻塞 <xref:System.Net.Sockets.Socket>调用此方法，并且没有任何连接请求排队，则 <xref:System.Net.Sockets.Socket.Accept%2A> 会引发 <xref:System.Net.Sockets.SocketException>。 如果收到 <xref:System.Net.Sockets.SocketException>，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。 获取此代码后，请参阅[Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2)文档，以获取有关错误的详细说明。  
  
> [!NOTE]
>  在调用 <xref:System.Net.Sockets.Socket.Accept%2A> 方法之前，必须先调用 <xref:System.Net.Sockets.Socket.Listen%2A> 方法来侦听传入连接请求并对其进行排队。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[.NET Framework 中的网络跟踪](/dotnet/framework/network-programming/network-tracing)。  
  
   
  
## Examples  
 下面的代码示例接受简单的 <xref:System.Net.Sockets.Socket> 连接。  
  
 [!code-cpp[Classic Socket.Accept Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Accept Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Accept Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Accept Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Accept Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Accept Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <exception cref="T:System.InvalidOperationException">正在接受的套接字不会侦听连接。 在调用 <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> 之前必须调用 <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> 和 <see cref="M:System.Net.Sockets.Socket.Accept" />。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />
        <altmember cref="P:System.Net.Sockets.Socket.RemoteEndPoint" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="AcceptAsync">
      <MemberSignature Language="C#" Value="public bool AcceptAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool AcceptAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function AcceptAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool AcceptAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.AcceptAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="socket.AcceptAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="e">要用于此异步套接字操作的 <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> 对象。</param>
        <summary>开始一个异步操作来接受一个传入的连接尝试。</summary>
        <returns>如果 I/O 操作挂起，则为 <see langword="true" />。 操作完成时，将引发 <paramref name="e" /> 参数的 <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> 事件。  
  
 如果 I/O 操作同步完成，则为 <see langword="false" />。 将不会引发 <paramref name="e" /> 参数的 <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> 事件，并且可能在方法调用返回后立即检查作为参数传递的 <paramref name="e" /> 对象以检索操作的结果。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 面向连接的协议可以使用 <xref:System.Net.Sockets.Socket.AcceptAsync%2A> 方法异步处理传入的连接尝试。 异步接受连接使你能够在单独的执行线程中发送和接收数据。 在调用 <xref:System.Net.Sockets.Socket.AcceptAsync%2A> 方法之前，必须调用 <xref:System.Net.Sockets.Socket.Listen%2A> 方法来侦听传入连接请求并对其进行排队。  
  
 若要在完成时收到通知，必须创建一个回调方法，用于实现 EventHandler\<SocketAsyncEventArgs > 委托，并将其挂接到 <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType> 事件。  
  
 需要 <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> 对象上的下列属性和事件：  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
 调用方可以选择指定要用于传入连接的现有 <xref:System.Net.Sockets.Socket>，方法是指定要与 <xref:System.Net.Sockets.SocketAsyncEventArgs.AcceptSocket%2A?displayProperty=nameWithType> 属性一起使用的 <xref:System.Net.Sockets.Socket>。  
  
 如果 <xref:System.Net.Sockets.SocketAsyncEventArgs.AcceptSocket%2A?displayProperty=nameWithType> 属性为 null，则将使用与当前 <xref:System.Net.Sockets.Socket.ProtocolType%2A> 相同的 <xref:System.Net.Sockets.Socket.AddressFamily%2A>、<xref:System.Net.Sockets.Socket.SocketType%2A>和 <xref:System.Net.Sockets.Socket> 构造新 <xref:System.Net.Sockets.Socket>，并将其设置为 <xref:System.Net.Sockets.SocketAsyncEventArgs.AcceptSocket%2A?displayProperty=nameWithType> 属性。  
  
 调用方可以在调用 <xref:System.Net.Sockets.Socket.AcceptAsync%2A> 方法之前将 <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> 属性设置为所需的任何用户状态对象，以便可以在回调方法中检索信息。 如果回调需要比单个对象更多的信息，则可以创建一个小类，以将其他所需的状态信息保存为成员。  
  
 （可选）可以在 <xref:System.Net.Sockets.Socket.ConnectAsync%2A> 方法成功完成后，提供缓冲区，用于接收套接字上的初始数据块。 在这种情况下，需要将 <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> 属性设置为包含要接收数据的缓冲区，并且 <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> 属性需要设置为要在缓冲区中接收的数据的最大字节数。 可以使用 <xref:System.Net.Sockets.SocketAsyncEventArgs.SetBuffer%2A?displayProperty=nameWithType> 方法设置这些属性。 传入的缓冲区部分将在内部使用，供基础 Winsock AcceptEx 调用使用。 这意味着返回的数据量将始终小于提供的 <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> 实例的 <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> 属性的值。 基于套接字的地址族，在内部使用的缓冲区量会有所不同。 所需的最小缓冲区大小为288个字节。 如果指定较大的缓冲区大小，则 <xref:System.Net.Sockets.Socket> 将需要一些额外的数据（而不是 Winsock AcceptEx 调用接收到的地址数据），并将等待，直到收到此额外的数据。 如果发生超时，则会重置连接。 因此，如果特定金额需要额外数据，则应将缓冲区大小设置为最小缓冲区大小加上此量。  
  
 完成回调方法应检查 <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType> 属性以确定 <xref:System.Net.Sockets.Socket.AcceptAsync%2A> 操作是否成功。  
  
 在某些情况下，如果未接受连接并导致 <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType> 属性设置为 <xref:System.Net.Sockets.SocketError.ConnectionReset>，则可能发生 <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType> 事件。 这种情况可能是通过使用半开放式 SYN 类型扫描（SYN > SYN-ACK-> RST 序列）进行端口扫描引起的。 应准备使用 <xref:System.Net.Sockets.Socket.AcceptAsync%2A> 方法的应用程序来处理这种情况。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">自变量无效。 如果所提供的缓冲区不够大，将会发生此异常。 缓冲区必须至少为 2 * (sizeof(SOCKADDR_STORAGE + 16) 字节。  
  
如果指定了多个缓冲区，即 <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /> 属性不为 null，也会发生此异常。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">参数超出范围。 如果 <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" /> 小于 0，将会发生此异常。</exception>
        <exception cref="T:System.InvalidOperationException">请求了无效操作。 如果接收方 <see cref="T:System.Net.Sockets.Socket" /> 未侦听连接或者绑定了接受的套接字，将发生此异常。  
  
<see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> 和 <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> 方法必须先于 <see cref="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)" /> 方法调用。  
  
如果套接字已连接或使用指定的 <paramref name="e" /> 参数的套接字操作已经在进行中，也会发生此异常。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.NotSupportedException">此方法需要 Windows XP 或更高版本。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.AcceptSocket" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="AddressFamily">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.AddressFamily AddressFamily { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Net.Sockets.AddressFamily AddressFamily" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.AddressFamily" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AddressFamily As AddressFamily" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Sockets::AddressFamily AddressFamily { System::Net::Sockets::AddressFamily get(); };" />
      <MemberSignature Language="F#" Value="member this.AddressFamily : System.Net.Sockets.AddressFamily" Usage="System.Net.Sockets.Socket.AddressFamily" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.AddressFamily</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取 <see cref="T:System.Net.Sockets.Socket" /> 的地址族。</summary>
        <value><see cref="T:System.Net.Sockets.AddressFamily" /> 值之一。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.AddressFamily> 指定 <xref:System.Net.Sockets.Socket> 类的实例可以使用的寻址方案。 此属性是只读的，在创建 <xref:System.Net.Sockets.Socket> 时设置。  
  
   
  
## Examples  
 下面的代码示例显示控制台 <xref:System.Net.Sockets.AddressFamily>、<xref:System.Net.Sockets.SocketType>和 <xref:System.Net.Sockets.ProtocolType>。  
  
 [!code-cpp[Socket_Socket_Options#3](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#3)]
 [!code-csharp[Socket_Socket_Options#3](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#3)]
 [!code-vb[Socket_Socket_Options#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.Sockets.AddressFamily" />
      </Docs>
    </Member>
    <Member MemberName="Available">
      <MemberSignature Language="C#" Value="public int Available { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Available" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.Available" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Available As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Available { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Available : int" Usage="System.Net.Sockets.Socket.Available" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取已经从网络接收且可供读取的数据量。</summary>
        <value>从网络接收的、可供读取的数据的字节数。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果使用非阻塞 <xref:System.Net.Sockets.Socket>，<xref:System.Net.Sockets.Socket.Available%2A> 是在调用 <xref:System.Net.Sockets.Socket.Receive%2A>之前确定数据是否排队等待读取的好方法。 可用数据是要读取的网络缓冲区中排队的数据总量。 如果网络缓冲区中没有数据排队，<xref:System.Net.Sockets.Socket.Available%2A> 将返回0。  
  
 如果远程主机关闭或关闭连接，<xref:System.Net.Sockets.Socket.Available%2A> 可能会引发 <xref:System.Net.Sockets.SocketException>。 如果收到 <xref:System.Net.Sockets.SocketException>，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。 获取此代码后，请参阅[Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2)文档，以获取有关错误的详细说明。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[.NET Framework 中的网络跟踪](/dotnet/framework/network-programming/network-tracing)。  
  
   
  
## Examples  
 下面的代码示例将调用 IOControl 和 FIONREAD 以及可用属性的结果进行比较。  
  
 [!code-cpp[NCLSocketIoControl#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketIoControl/CPP/iocontrolserver.cpp#1)]
 [!code-csharp[NCLSocketIoControl#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketIoControl/CS/iocontrolserver.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="T:System.IO.Stream" />
        <altmember cref="F:System.Net.Sockets.SocketType.Dgram" />
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginAccept">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>开始一个异步操作来接受一个传入的连接尝试。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginAccept">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginAccept (AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginAccept(class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginAccept (callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginAccept(AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginAccept : AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginAccept (callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.AsyncCallback" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="state" Type="System.Object" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="callback"><see cref="T:System.AsyncCallback" /> 委托。</param>
        <param name="state">包含此请求的状态信息的对象。</param>
        <summary>开始一个异步操作来接受一个传入的连接尝试。</summary>
        <returns>一个 <see cref="T:System.IAsyncResult" />，它引用异步 <see cref="T:System.Net.Sockets.Socket" /> 创建。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 面向连接的协议可以使用 <xref:System.Net.Sockets.Socket.BeginAccept%2A> 方法异步处理传入的连接尝试。 异步接受连接使你能够在单独的执行线程中发送和接收数据。 在调用 <xref:System.Net.Sockets.Socket.BeginAccept%2A> 方法之前，必须调用 <xref:System.Net.Sockets.Socket.Listen%2A> 方法来侦听传入连接请求并对其进行排队。  
  
 必须创建实现 <xref:System.AsyncCallback> 委托的回调方法，并将其名称传递到 <xref:System.Net.Sockets.Socket.BeginAccept%2A> 方法。 为此，必须至少通过 `state` 参数将侦听 <xref:System.Net.Sockets.Socket> 对象传递给 <xref:System.Net.Sockets.Socket.BeginAccept%2A>。 如果回调需要更多的信息，可以创建一个小类来容纳 <xref:System.Net.Sockets.Socket> 和其他所需的信息。 通过 `state` 参数将此类的实例传递给 <xref:System.Net.Sockets.Socket.BeginAccept%2A> 方法。  
  
 回调方法应调用 <xref:System.Net.Sockets.Socket.EndAccept%2A> 方法。 当应用程序调用 <xref:System.Net.Sockets.Socket.BeginAccept%2A>时，系统通常使用单独的线程来执行指定的回调方法，并在 <xref:System.Net.Sockets.Socket.EndAccept%2A> 上阻止，直到检索到挂起的连接。 <xref:System.Net.Sockets.Socket.EndAccept%2A> 将返回一个新的 <xref:System.Net.Sockets.Socket> 对象，可用于发送和接收与远程主机的数据。 不能使用返回的 <xref:System.Net.Sockets.Socket> 接受来自连接队列的任何其他连接。 如果希望在调用 <xref:System.Net.Sockets.Socket.BeginAccept%2A> 方法后原始线程被阻止，请使用 <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>。 如果希望原始线程继续执行，请在回调方法中的 <xref:System.Threading.ManualResetEvent> 上调用 Set 方法。  
  
 系统还可以使用调用线程调用回调方法。 在这种情况下，返回 <xref:System.IAsyncResult> 上的 <xref:System.IAsyncResult.CompletedSynchronously%2A> 属性将设置为指示 <xref:System.Net.Sockets.Socket.BeginAccept%2A> 方法同步完成。  
  
 有关编写回调方法的其他信息，请参阅将[委托作为回调方法进行封送处理](/dotnet/framework/interop/marshaling-a-delegate-as-a-callback-method)。  
  
 若要取消对 <xref:System.Net.Sockets.Socket.BeginAccept%2A> 方法的挂起调用，请关闭 <xref:System.Net.Sockets.Socket>。 当异步操作正在进行时调用 <xref:System.Net.Sockets.Socket.Close%2A> 方法时，会调用向 <xref:System.Net.Sockets.Socket.BeginAccept%2A> 方法提供的回调。  对 <xref:System.Net.Sockets.Socket.EndAccept%2A> 方法的后续调用将引发 <xref:System.ObjectDisposedException>，以指示该操作已取消。  
  
> [!NOTE]
>  您可以使用返回的 <xref:System.Net.Sockets.Socket> 的 <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> 属性来识别远程主机的网络地址和端口号。  
  
> [!NOTE]
>  如果收到 <xref:System.Net.Sockets.SocketException>，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。 获取此代码后，请参阅[Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2)文档，以获取有关错误的详细说明。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[.NET Framework 中的网络跟踪](/dotnet/framework/network-programming/network-tracing)。  
  
> [!NOTE]
>  对异步 <xref:System.Net.Sockets.Socket> 方法缓存执行上下文（安全上下文、模拟用户和调用上下文）。 第一次使用特定上下文（特定的异步 <xref:System.Net.Sockets.Socket> 方法、特定的 <xref:System.Net.Sockets.Socket> 实例和特定回调）后，该上下文的后续使用将会提高性能。  
  
   
  
## Examples  
 下面的代码示例尝试异步接收传入连接。  
  
 [!code-cpp[Socket_Async_Send_Receive#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#2)]
 [!code-csharp[Socket_Async_Send_Receive#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#2)]
 [!code-vb[Socket_Async_Send_Receive#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 对象已关闭。</exception>
        <exception cref="T:System.NotSupportedException">此方法需要 Windows NT。</exception>
        <exception cref="T:System.InvalidOperationException">正在接受的套接字不会侦听连接。 在调用 <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> 之前必须调用 <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> 和 <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />。  
  
-或- 
已接受的套接字是绑定的。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="receiveSize" /> 小于 0。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
        <altmember cref="T:System.Net.Sockets.Socket" />
        <altmember cref="P:System.Net.Sockets.Socket.RemoteEndPoint" />
        <related type="Article" href="/dotnet/framework/network-programming/asynchronous-client-socket-example">异步客户端套接字示例</related>
        <related type="Article" href="/dotnet/framework/network-programming/asynchronous-server-socket-example">异步服务器套接字示例</related>
      </Docs>
    </Member>
    <Member MemberName="BeginAccept">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginAccept (int receiveSize, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginAccept(int32 receiveSize, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginAccept (receiveSize As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginAccept(int receiveSize, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginAccept : int * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginAccept (receiveSize, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="receiveSize" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="state" Type="System.Object" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="receiveSize">要从发送方读取的字节数。</param>
        <param name="callback"><see cref="T:System.AsyncCallback" /> 委托。</param>
        <param name="state">包含此请求的状态信息的对象。</param>
        <summary>开始异步操作以接受传入的连接尝试并接收客户端应用程序发送的第一个数据块。</summary>
        <returns>一个 <see cref="T:System.IAsyncResult" />，它引用异步 <see cref="T:System.Net.Sockets.Socket" /> 创建。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 面向连接的协议可以使用 <xref:System.Net.Sockets.Socket.BeginAccept%2A> 方法异步处理传入的连接尝试。 通过异步接受连接，可以在单独的执行线程中发送和接收数据。 此重载允许您指定要在 `receiveSize` 参数的初始传输中接受的字节数。  
  
 在调用 <xref:System.Net.Sockets.Socket.BeginAccept%2A> 方法之前，必须调用 <xref:System.Net.Sockets.Socket.Listen%2A> 方法来侦听传入连接请求并对其进行排队。  
  
 必须创建实现 <xref:System.AsyncCallback> 委托的回调方法，并将其名称传递到 <xref:System.Net.Sockets.Socket.BeginAccept%2A> 方法。 为此，必须至少通过 `state` 参数将侦听 <xref:System.Net.Sockets.Socket> 对象传递给 <xref:System.Net.Sockets.Socket.BeginAccept%2A>。 如果回调需要更多的信息，可以创建一个小类来容纳 <xref:System.Net.Sockets.Socket> 和其他所需的信息。 通过 `state` 参数将此类的实例传递给 <xref:System.Net.Sockets.Socket.BeginAccept%2A> 方法。  
  
 回调方法应调用 <xref:System.Net.Sockets.Socket.EndAccept%2A> 方法。 当应用程序调用 <xref:System.Net.Sockets.Socket.BeginAccept%2A>时，系统通常使用单独的线程来执行指定的回调方法，并在 <xref:System.Net.Sockets.Socket.EndAccept%2A> 上阻止，直到检索到挂起的连接。  
  
 <xref:System.Net.Sockets.Socket.EndAccept%2A> 返回一个新的 <xref:System.Net.Sockets.Socket>，可用于发送和接收与远程主机的数据。 不能使用返回的 <xref:System.Net.Sockets.Socket> 接受来自连接队列的任何其他连接。 如果希望在调用 <xref:System.Net.Sockets.Socket.BeginAccept%2A> 方法后原始线程被阻止，请使用 <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>。 如果希望原始线程继续执行，请在回调方法中的 <xref:System.Threading.ManualResetEvent> 上调用 Set 方法。  
  
 系统还可以使用调用线程调用回调方法。 在这种情况下，返回 <xref:System.IAsyncResult> 上的 <xref:System.IAsyncResult.CompletedSynchronously%2A> 属性将设置为指示 <xref:System.Net.Sockets.Socket.BeginAccept%2A> 方法同步完成。  
  
 有关编写回调方法的其他信息，请参阅将[委托作为回调方法进行封送处理](/dotnet/framework/interop/marshaling-a-delegate-as-a-callback-method)。  
  
 若要取消对 <xref:System.Net.Sockets.Socket.BeginAccept%2A> 方法的挂起调用，请关闭 <xref:System.Net.Sockets.Socket>。  当异步操作正在进行时调用 <xref:System.Net.Sockets.Socket.Close%2A> 方法时，会调用向 <xref:System.Net.Sockets.Socket.BeginAccept%2A> 方法提供的回调。  对 <xref:System.Net.Sockets.Socket.EndAccept%2A> 方法的后续调用将引发 <xref:System.ObjectDisposedException>，以指示该操作已取消。  
  
> [!NOTE]
>  可以调用使用返回的 <xref:System.Net.Sockets.Socket> 对象的 <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> 属性来识别远程主机的网络地址和端口号。  
  
> [!NOTE]
>  如果收到 <xref:System.Net.Sockets.SocketException>，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。 获取此代码后，请参阅[Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2)文档，以获取有关错误的详细说明。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[.NET Framework 中的网络跟踪](/dotnet/framework/network-programming/network-tracing)。  
  
> [!NOTE]
>  对异步 <xref:System.Net.Sockets.Socket> 方法缓存执行上下文（安全上下文、模拟用户和调用上下文）。 第一次使用特定上下文（特定的异步 <xref:System.Net.Sockets.Socket> 方法、特定的 <xref:System.Net.Sockets.Socket> 实例和特定回调）后，该上下文的后续使用将会提高性能。  
  
   
  
## Examples  
 下面的代码示例打开套接字并接受异步连接。 在此示例中，套接字接受前10个字节的数据。 回调委托将接收的字节数和数据显示在控制台上。 有关如何接收剩余数据的说明，请参阅 <xref:System.Net.Sockets.Socket.BeginReceive%2A>。  
  
 [!code-cpp[NCLSocketEnhancements#6](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#6)]
 [!code-csharp[NCLSocketEnhancements#6](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 对象已关闭。</exception>
        <exception cref="T:System.NotSupportedException">此方法需要 Windows NT。</exception>
        <exception cref="T:System.InvalidOperationException">正在接受的套接字不会侦听连接。 在调用 <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> 之前必须调用 <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> 和 <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />。  
  
-或- 
已接受的套接字是绑定的。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="receiveSize" /> 小于 0。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
        <altmember cref="T:System.Net.Sockets.Socket" />
        <altmember cref="P:System.Net.Sockets.Socket.RemoteEndPoint" />
        <related type="Article" href="/dotnet/framework/network-programming/asynchronous-client-socket-example">异步客户端套接字示例</related>
        <related type="Article" href="/dotnet/framework/network-programming/asynchronous-server-socket-example">异步服务器套接字示例</related>
      </Docs>
    </Member>
    <Member MemberName="BeginAccept">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginAccept (System.Net.Sockets.Socket acceptSocket, int receiveSize, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginAccept(class System.Net.Sockets.Socket acceptSocket, int32 receiveSize, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginAccept (acceptSocket As Socket, receiveSize As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginAccept(System::Net::Sockets::Socket ^ acceptSocket, int receiveSize, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginAccept : System.Net.Sockets.Socket * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginAccept (acceptSocket, receiveSize, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="acceptSocket" Type="System.Net.Sockets.Socket" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="receiveSize" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="state" Type="System.Object" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="acceptSocket">接受的 <see cref="T:System.Net.Sockets.Socket" /> 对象。 此值可为 <see langword="null" />。</param>
        <param name="receiveSize">要接收的最大字节数。</param>
        <param name="callback"><see cref="T:System.AsyncCallback" /> 委托。</param>
        <param name="state">包含此请求的状态信息的对象。</param>
        <summary>开始异步操作以接受从指定套接字传入的连接尝试并接收客户端应用程序发送的第一个数据块。</summary>
        <returns>一个 <see cref="T:System.IAsyncResult" /> 对象，它引用异步 <see cref="T:System.Net.Sockets.Socket" /> 对象创建。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 面向连接的协议可以使用 <xref:System.Net.Sockets.Socket.BeginAccept%2A> 方法异步处理传入的连接尝试。 异步接受连接使你能够在单独的执行线程中发送和接收数据。 此重载允许您在 `acceptSocket` 参数中指定已接受的套接字。 如果 `null`此参数，则将通过 <xref:System.Net.Sockets.Socket.BeginAccept%2A> 方法创建已接受的套接字。 可以在 `receiveSize` 参数的初始传输中指定要接受的字节数。  
  
 在调用 <xref:System.Net.Sockets.Socket.BeginAccept%2A> 方法之前，必须调用 <xref:System.Net.Sockets.Socket.Listen%2A> 方法来侦听传入连接请求并对其进行排队。  
  
 必须创建实现 <xref:System.AsyncCallback> 委托的回调方法，并将其名称传递到 <xref:System.Net.Sockets.Socket.BeginAccept%2A> 方法。 为此，必须至少通过 `state` 参数将侦听 <xref:System.Net.Sockets.Socket> 对象传递给 <xref:System.Net.Sockets.Socket.BeginAccept%2A>。 如果回调需要更多的信息，可以创建一个小类来容纳 <xref:System.Net.Sockets.Socket> 和其他所需的信息。 通过 `state` 参数将此类的实例传递给 <xref:System.Net.Sockets.Socket.BeginAccept%2A> 方法。  
  
 回调方法应调用 <xref:System.Net.Sockets.Socket.EndAccept%2A> 方法。 当应用程序调用 <xref:System.Net.Sockets.Socket.BeginAccept%2A>时，系统通常使用单独的线程来执行指定的回调方法，并在 <xref:System.Net.Sockets.Socket.EndAccept%2A> 上阻止，直到检索到挂起的连接。  
  
 <xref:System.Net.Sockets.Socket.EndAccept%2A> 返回一个新的 <xref:System.Net.Sockets.Socket> 对象，可用于发送和接收与远程主机的数据。 不能使用返回的 <xref:System.Net.Sockets.Socket> 接受来自连接队列的任何其他连接。 如果希望在调用 <xref:System.Net.Sockets.Socket.BeginAccept%2A> 方法后原始线程被阻止，请使用 <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>。 如果希望原始线程继续执行，请在回调方法中的 <xref:System.Threading.ManualResetEvent> 上调用 Set 方法。  
  
 系统还可以使用调用线程调用回调方法。 在这种情况下，返回 <xref:System.IAsyncResult> 上的 <xref:System.IAsyncResult.CompletedSynchronously%2A> 属性将设置为指示 <xref:System.Net.Sockets.Socket.BeginAccept%2A> 方法同步完成。  
  
 有关编写回调方法的其他信息，请参阅将[委托作为回调方法进行封送处理](/dotnet/framework/interop/marshaling-a-delegate-as-a-callback-method)。  
  
 若要取消对 <xref:System.Net.Sockets.Socket.BeginAccept%2A> 方法的挂起调用，请关闭 <xref:System.Net.Sockets.Socket>。 当异步操作正在进行时调用 <xref:System.Net.Sockets.Socket.Close%2A> 方法时，会调用向 <xref:System.Net.Sockets.Socket.BeginAccept%2A> 方法提供的回调。  对 <xref:System.Net.Sockets.Socket.EndAccept%2A> 方法的后续调用将引发 <xref:System.ObjectDisposedException>，以指示该操作已取消。  
  
> [!NOTE]
>  您可以使用返回的 <xref:System.Net.Sockets.Socket> 对象的 <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> 属性来识别远程主机的网络地址和端口号。  
  
> [!NOTE]
>  如果收到 <xref:System.Net.Sockets.SocketException>，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。 获取此代码后，请参阅[Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2)文档，以获取有关错误的详细说明。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[.NET Framework 中的网络跟踪](/dotnet/framework/network-programming/network-tracing)。  
  
> [!NOTE]
>  对异步 <xref:System.Net.Sockets.Socket> 方法缓存执行上下文（安全上下文、模拟用户和调用上下文）。 第一次使用特定上下文（特定的异步 <xref:System.Net.Sockets.Socket> 方法、特定的 <xref:System.Net.Sockets.Socket> 实例和特定回调）后，该上下文的后续使用将会提高性能。  
  
   
  
## Examples  
 下面的代码示例打开套接字并接受异步连接。 在此示例中，套接字接受前10个字节的数据，`acceptSocket` 参数 `null`，这将强制 <xref:System.Net.Sockets.Socket.BeginAccept%2A> 方法创建接受的套接字。 回调委托将接收的字节数和数据显示在控制台上。 有关如何接收剩余数据的说明，请参阅 <xref:System.Net.Sockets.Socket.BeginReceive%2A>。  
  
 [!code-cpp[NCLSocketEnhancements#7](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#7)]
 [!code-csharp[NCLSocketEnhancements#7](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 对象已关闭。</exception>
        <exception cref="T:System.NotSupportedException">此方法需要 Windows NT。</exception>
        <exception cref="T:System.InvalidOperationException">正在接受的套接字不会侦听连接。 在调用 <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> 之前必须调用 <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> 和 <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />。  
  
-或- 
已接受的套接字是绑定的。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="receiveSize" /> 小于 0。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
        <altmember cref="T:System.Net.Sockets.Socket" />
        <altmember cref="P:System.Net.Sockets.Socket.RemoteEndPoint" />
        <related type="Article" href="/dotnet/framework/network-programming/asynchronous-client-socket-example">异步客户端套接字示例</related>
        <related type="Article" href="/dotnet/framework/network-programming/asynchronous-server-socket-example">异步服务器套接字示例</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginConnect">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>开始一个对远程主机连接的异步请求。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginConnect">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (System.Net.EndPoint remoteEP, AsyncCallback callback, object state);" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(class System.Net.EndPoint remoteEP, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (remoteEP As EndPoint, callback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(System::Net::EndPoint ^ remoteEP, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.BeginConnect : System.Net.EndPoint * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginConnect (remoteEP, callback, state)" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (System.Net.EndPoint end_point, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(class System.Net.EndPoint end_point, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (end_point As EndPoint, callback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(System::Net::EndPoint ^ end_point, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.BeginConnect : System.Net.EndPoint * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginConnect (end_point, callback, state)" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="end_point" Type="System.Net.EndPoint" Index="0" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="state" Type="System.Object" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="remoteEP">表示远程主机的 <see cref="T:System.Net.EndPoint" />。</param>
        <param name="end_point">表示远程主机的 <see cref="T:System.Net.EndPoint" />。</param>
        <param name="callback"><see cref="T:System.AsyncCallback" /> 委托。</param>
        <param name="state">包含此请求的状态信息的对象。</param>
        <summary>开始一个对远程主机连接的异步请求。</summary>
        <returns>引用异步连接的 <see cref="T:System.IAsyncResult" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果你使用的是面向连接的协议，则 <xref:System.Net.Sockets.Socket.BeginConnect%2A> 方法会启动到 `remoteEP` 参数的连接的异步请求。 如果使用的是无连接协议，<xref:System.Net.Sockets.Socket.BeginConnect%2A> 会建立默认远程主机。 使用异步方式连接或设置默认远程主机使你能够在单独的执行线程中发送和接收数据。  
  
 你可以创建一个实现 <xref:System.AsyncCallback> 委托的回调方法，并将其名称传递到 <xref:System.Net.Sockets.Socket.BeginConnect%2A> 方法。 至少必须将 <xref:System.Net.Sockets.Socket> 传递到 <xref:System.Net.Sockets.Socket.BeginConnect%2A> 通过 `state` 参数。 如果回调需要更多的信息，可以创建一个小类来保存 <xref:System.Net.Sockets.Socket>，并创建其他必需的信息。 通过 `state` 参数将此类的实例传递给 <xref:System.Net.Sockets.Socket.BeginConnect%2A> 方法。  
  
 回调方法应调用 <xref:System.Net.Sockets.Socket.EndConnect%2A> 方法。 当应用程序调用 <xref:System.Net.Sockets.Socket.BeginConnect%2A>时，系统将使用一个单独的线程来执行指定的回调方法，并将在 <xref:System.Net.Sockets.Socket.EndConnect%2A> 上受阻，直到 <xref:System.Net.Sockets.Socket> 成功连接或引发异常。 如果希望在调用 <xref:System.Net.Sockets.Socket.BeginConnect%2A> 方法后原始线程被阻止，请使用 <xref:System.Threading.WaitHandle.WaitOne%2A>。 如果希望原始线程继续执行，请在回调方法中的 <xref:System.Threading.ManualResetEvent> 上调用 Set 方法。 有关编写回调方法的其他信息，请参阅将[委托作为回调方法进行封送处理](/dotnet/framework/interop/marshaling-a-delegate-as-a-callback-method)。  
  
 如果使用的是无连接协议（如 UDP），则在发送和接收数据之前无需调用 <xref:System.Net.Sockets.Socket.BeginConnect%2A>。 您可以使用 <xref:System.Net.Sockets.Socket.BeginSendTo%2A> 和 <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> 与远程主机通信。 如果调用 <xref:System.Net.Sockets.Socket.BeginConnect%2A>，则从指定的默认值以外的地址到达的任何数据报都将被丢弃。 如果要将默认远程主机设置为广播地址，则必须先调用 <xref:System.Net.Sockets.Socket.SetSocketOption%2A> 并将广播设置为 `true`。 如果无法做到这一点，<xref:System.Net.Sockets.Socket.BeginConnect%2A> 将引发 <xref:System.Net.Sockets.SocketException>。  
  
 如果使用面向连接的协议，且在调用 <xref:System.Net.Sockets.Socket.BeginConnect%2A>之前未调用 <xref:System.Net.Sockets.Socket.Bind%2A>，则基础服务提供程序将分配最适当的本地网络地址和端口号。 如果使用的是无连接协议，则在调用 <xref:System.Net.Sockets.Socket.BeginSend%2A> 或 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 方法之前，服务提供程序将不会分配本地网络地址和端口号。 如果要更改默认远程主机，请通过所需的终结点再次调用 <xref:System.Net.Sockets.Socket.BeginConnect%2A> 方法。  
  
 若要取消对 <xref:System.Net.Sockets.Socket.BeginConnect%2A> 方法的挂起调用，请关闭 <xref:System.Net.Sockets.Socket>。 当异步操作正在进行时调用 <xref:System.Net.Sockets.Socket.Close%2A> 方法时，会调用向 <xref:System.Net.Sockets.Socket.BeginConnect%2A> 方法提供的回调。  对 <xref:System.Net.Sockets.Socket.EndConnect%2A> 方法的后续调用将引发 <xref:System.ObjectDisposedException>，以指示该操作已取消。  
  
> [!NOTE]
>  如果收到 <xref:System.Net.Sockets.SocketException>，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。 获取此代码后，请参阅[Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2)文档，以获取有关错误的详细说明。  
  
> [!NOTE]
>  如果此套接字之前已断开连接，则必须在操作完成之前，将不会退出的线程上调用 <xref:System.Net.Sockets.Socket.BeginConnect%2A>。 这是底层提供程序的限制。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[.NET Framework 中的网络跟踪](/dotnet/framework/network-programming/network-tracing)。  
  
> [!NOTE]
>  对异步 <xref:System.Net.Sockets.Socket> 方法缓存执行上下文（安全上下文、模拟用户和调用上下文）。 第一次使用特定上下文（特定的异步 <xref:System.Net.Sockets.Socket> 方法、特定的 <xref:System.Net.Sockets.Socket> 实例和特定回调）后，该上下文的后续使用将会提高性能。  
  
   
  
## Examples  
 下面的代码示例启动异步连接尝试。  
  
 [!code-cpp[Socket_Async_Send_Receive#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#1)]
 [!code-csharp[Socket_Async_Send_Receive#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#1)]
 [!code-vb[Socket_Async_Send_Receive#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="remoteEP" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <exception cref="T:System.Security.SecurityException">调用堆栈中的较高调用方无权执行所请求的操作。</exception>
        <exception cref="T:System.InvalidOperationException">已通过调用 <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> 将 <see cref="T:System.Net.Sockets.Socket" /> 置于侦听状态，或异步操作已在进行中。</exception>
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
        <related type="Article" href="/dotnet/framework/interop/marshaling-a-delegate-as-a-callback-method">将委托作为回调方法进行封送</related>
        <related type="Article" href="/dotnet/framework/network-programming/asynchronous-client-socket-example">异步客户端套接字示例</related>
        <related type="Article" href="/dotnet/framework/network-programming/asynchronous-server-socket-example">异步服务器套接字示例</related>
      </Docs>
    </Member>
    <Member MemberName="BeginConnect">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (System.Net.IPAddress address, int port, AsyncCallback requestCallback, object state);" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(class System.Net.IPAddress address, int32 port, class System.AsyncCallback requestCallback, object state) cil managed" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress,System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (address As IPAddress, port As Integer, requestCallback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(System::Net::IPAddress ^ address, int port, AsyncCallback ^ requestCallback, System::Object ^ state);" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.BeginConnect : System.Net.IPAddress * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginConnect (address, port, requestCallback, state)" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (System.Net.IPAddress address, int port, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(class System.Net.IPAddress address, int32 port, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (address As IPAddress, port As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(System::Net::IPAddress ^ address, int port, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.BeginConnect : System.Net.IPAddress * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginConnect (address, port, callback, state)" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Net.IPAddress" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="port" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="requestCallback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="address">远程主机的 <see cref="T:System.Net.IPAddress" />。</param>
        <param name="port">远程主机的端口号。</param>
        <param name="requestCallback">一个 <see cref="T:System.AsyncCallback" /> 委托，它引用连接操作完成时要调用的方法。</param>
        <param name="callback">一个 <see cref="T:System.AsyncCallback" /> 委托，它引用连接操作完成时要调用的方法。</param>
        <param name="state">一个用户定义对象，其中包含连接操作的相关信息。 当操作完成时，此对象会被传递给 <paramref name="requestCallback" /> 委托。</param>
        <summary>开始一个对远程主机连接的异步请求。 主机由 <see cref="T:System.Net.IPAddress" /> 和端口号指定。</summary>
        <returns>引用异步连接的 <see cref="T:System.IAsyncResult" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 异步 <xref:System.Net.Sockets.Socket.BeginConnect%2A> 操作必须通过调用 <xref:System.Net.Sockets.Socket.EndConnect%2A> 方法完成。 通常，方法由 `requestCallback` 委托调用。  
  
 在操作完成之前，此方法不会被阻止。 若要在操作完成之前一直阻止，请使用 <xref:System.Net.Sockets.Socket.Connect%2A> 方法重载之一，或 <xref:System.Net.Sockets.Socket.EndConnect%2A>。  
  
 若要取消对 <xref:System.Net.Sockets.Socket.BeginConnect%2A> 方法的挂起调用，请关闭 <xref:System.Net.Sockets.Socket>。 当异步操作正在进行时调用 <xref:System.Net.Sockets.Socket.Close%2A> 方法时，会调用向 <xref:System.Net.Sockets.Socket.BeginConnect%2A> 方法提供的回调。  对 <xref:System.Net.Sockets.Socket.EndConnect%2A> 方法的后续调用将引发 <xref:System.ObjectDisposedException>，以指示该操作已取消。  
  
 有关使用异步编程模型的详细信息，请参阅[以异步方式调用同步方法](/dotnet/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously)  
  
> [!NOTE]
>  如果收到 <xref:System.Net.Sockets.SocketException>，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。 获取此代码后，请参阅[Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2)文档，以获取有关错误的详细说明。  
  
> [!NOTE]
>  如果此套接字之前已断开连接，则必须在操作完成之前，将不会退出的线程上调用 <xref:System.Net.Sockets.Socket.BeginConnect%2A>。 这是底层提供程序的限制。 使用的 <xref:System.Net.EndPoint> 也必须不同。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[.NET Framework 中的网络跟踪](/dotnet/framework/network-programming/network-tracing)。  
  
> [!NOTE]
>  对异步 <xref:System.Net.Sockets.Socket> 方法缓存执行上下文（安全上下文、模拟用户和调用上下文）。 第一次使用特定上下文（特定的异步 <xref:System.Net.Sockets.Socket> 方法、特定的 <xref:System.Net.Sockets.Socket> 实例和特定回调）后，该上下文的后续使用将会提高性能。  
  
   
  
## Examples  
 下面的代码示例启动异步连接尝试。  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#1)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#1)]  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#7](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#7)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#7](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="address" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <exception cref="T:System.NotSupportedException"><see cref="T:System.Net.Sockets.Socket" /> 不在套接字族中。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">端口号无效。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="address" /> 的长度为零。</exception>
        <exception cref="T:System.InvalidOperationException">已通过调用 <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> 将 <see cref="T:System.Net.Sockets.Socket" /> 置于侦听状态，或异步操作已在进行中。</exception>
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
        <related type="Article" href="/dotnet/framework/interop/marshaling-a-delegate-as-a-callback-method">将委托作为回调方法进行封送</related>
        <related type="Article" href="/dotnet/framework/network-programming/asynchronous-client-socket-example">异步客户端套接字示例</related>
        <related type="Article" href="/dotnet/framework/network-programming/asynchronous-server-socket-example">异步服务器套接字示例</related>
      </Docs>
    </Member>
    <Member MemberName="BeginConnect">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (System.Net.IPAddress[] addresses, int port, AsyncCallback requestCallback, object state);" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(class System.Net.IPAddress[] addresses, int32 port, class System.AsyncCallback requestCallback, object state) cil managed" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress[],System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (addresses As IPAddress(), port As Integer, requestCallback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(cli::array &lt;System::Net::IPAddress ^&gt; ^ addresses, int port, AsyncCallback ^ requestCallback, System::Object ^ state);" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.BeginConnect : System.Net.IPAddress[] * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginConnect (addresses, port, requestCallback, state)" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (System.Net.IPAddress[] addresses, int port, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(class System.Net.IPAddress[] addresses, int32 port, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (addresses As IPAddress(), port As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(cli::array &lt;System::Net::IPAddress ^&gt; ^ addresses, int port, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.BeginConnect : System.Net.IPAddress[] * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginConnect (addresses, port, callback, state)" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="addresses" Type="System.Net.IPAddress[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="port" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="requestCallback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="addresses">至少一个用于指定远程主机的 <see cref="T:System.Net.IPAddress" />。</param>
        <param name="port">远程主机的端口号。</param>
        <param name="requestCallback">一个 <see cref="T:System.AsyncCallback" /> 委托，它引用连接操作完成时要调用的方法。</param>
        <param name="callback">一个 <see cref="T:System.AsyncCallback" /> 委托，它引用连接操作完成时要调用的方法。</param>
        <param name="state">一个用户定义对象，其中包含连接操作的相关信息。 当操作完成时，此对象会被传递给 <paramref name="requestCallback" /> 委托。</param>
        <summary>开始一个对远程主机连接的异步请求。 主机由 <see cref="T:System.Net.IPAddress" /> 数组和端口号指定。</summary>
        <returns>引用异步连接的 <see cref="T:System.IAsyncResult" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 异步 <xref:System.Net.Sockets.Socket.BeginConnect%2A> 操作必须通过调用 <xref:System.Net.Sockets.Socket.EndConnect%2A> 方法完成。 通常，方法由 `requestCallback` 委托调用。  
  
 在操作完成之前，此方法不会被阻止。 若要在操作完成之前一直阻止，请使用 <xref:System.Net.Sockets.Socket.Connect%2A> 方法重载之一。  
  
 若要取消对 <xref:System.Net.Sockets.Socket.BeginConnect%2A> 方法的挂起调用，请关闭 <xref:System.Net.Sockets.Socket>。 当异步操作正在进行时调用 <xref:System.Net.Sockets.Socket.Close%2A> 方法时，会调用向 <xref:System.Net.Sockets.Socket.BeginConnect%2A> 方法提供的回调。  对 <xref:System.Net.Sockets.Socket.EndConnect%2A> 方法的后续调用将引发 <xref:System.ObjectDisposedException>，以指示该操作已取消。  
  
 有关使用异步编程模型的详细信息，请参阅[以异步方式调用同步方法](/dotnet/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously)。  
  
> [!NOTE]
>  如果收到 <xref:System.Net.Sockets.SocketException>，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。 获取此代码后，请参阅[Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2)文档，以获取有关错误的详细说明。  
  
> [!NOTE]
>  如果此套接字之前已断开连接，则必须在操作完成之前，将不会退出的线程上调用 <xref:System.Net.Sockets.Socket.BeginConnect%2A>。 这是底层提供程序的限制。 使用的 <xref:System.Net.EndPoint> 也必须不同。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[.NET Framework 中的网络跟踪](/dotnet/framework/network-programming/network-tracing)。  
  
> [!NOTE]
>  对异步 <xref:System.Net.Sockets.Socket> 方法缓存执行上下文（安全上下文、模拟用户和调用上下文）。 第一次使用特定上下文（特定的异步 <xref:System.Net.Sockets.Socket> 方法、特定的 <xref:System.Net.Sockets.Socket> 实例和特定回调）后，该上下文的后续使用将会提高性能。  
  
   
  
## Examples  
 下面的代码示例启动异步连接尝试。  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#1)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#1)]  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#2](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#2)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#2](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="addresses" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <exception cref="T:System.NotSupportedException">此方法对使用 <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> 或 <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> 的套接字有效。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">端口号无效。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="address" /> 的长度为零。</exception>
        <exception cref="T:System.InvalidOperationException">已通过调用 <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> 将 <see cref="T:System.Net.Sockets.Socket" /> 置于侦听状态，或异步操作已在进行中。</exception>
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
        <related type="Article" href="/dotnet/framework/interop/marshaling-a-delegate-as-a-callback-method">将委托作为回调方法进行封送</related>
        <related type="Article" href="/dotnet/framework/network-programming/asynchronous-client-socket-example">异步客户端套接字示例</related>
        <related type="Article" href="/dotnet/framework/network-programming/asynchronous-server-socket-example">异步服务器套接字示例</related>
      </Docs>
    </Member>
    <Member MemberName="BeginConnect">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (string host, int port, AsyncCallback requestCallback, object state);" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(string host, int32 port, class System.AsyncCallback requestCallback, object state) cil managed" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginConnect(System.String,System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (host As String, port As Integer, requestCallback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(System::String ^ host, int port, AsyncCallback ^ requestCallback, System::Object ^ state);" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.BeginConnect : string * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginConnect (host, port, requestCallback, state)" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (string host, int port, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(string host, int32 port, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (host As String, port As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(System::String ^ host, int port, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.BeginConnect : string * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginConnect (host, port, callback, state)" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="host" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="port" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="requestCallback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="host">远程主机的名称。</param>
        <param name="port">远程主机的端口号。</param>
        <param name="requestCallback">一个 <see cref="T:System.AsyncCallback" /> 委托，它引用连接操作完成时要调用的方法。</param>
        <param name="callback">一个 <see cref="T:System.AsyncCallback" /> 委托，它引用连接操作完成时要调用的方法。</param>
        <param name="state">一个用户定义对象，其中包含连接操作的相关信息。 当操作完成时，此对象会被传递给 <paramref name="requestCallback" /> 委托。</param>
        <summary>开始一个对远程主机连接的异步请求。 主机由主机名和端口号指定。</summary>
        <returns>引用异步连接的 <see cref="T:System.IAsyncResult" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 异步 <xref:System.Net.Sockets.Socket.BeginConnect%2A> 操作必须通过调用 <xref:System.Net.Sockets.Socket.EndConnect%2A> 方法完成。 通常，方法由 `requestCallback` 委托调用。  
  
 在操作完成之前，此方法不会被阻止。 若要在操作完成之前一直阻止，请使用 <xref:System.Net.Sockets.Socket.Connect%2A> 方法重载之一。  
  
 若要取消对 <xref:System.Net.Sockets.Socket.BeginConnect%2A> 方法的挂起调用，请关闭 <xref:System.Net.Sockets.Socket>。 当异步操作正在进行时调用 <xref:System.Net.Sockets.Socket.Close%2A> 方法时，会调用向 <xref:System.Net.Sockets.Socket.BeginConnect%2A> 方法提供的回调。  对 <xref:System.Net.Sockets.Socket.EndConnect%2A> 方法的后续调用将引发 <xref:System.ObjectDisposedException>，以指示该操作已取消。  
  
 有关使用异步编程模型的详细信息，请参阅[以异步方式调用同步方法](/dotnet/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously)  
  
> [!NOTE]
>  如果收到 <xref:System.Net.Sockets.SocketException>，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。 获取此代码后，请参阅[Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2)文档，以获取有关错误的详细说明。  
  
> [!NOTE]
>  如果此套接字之前已断开连接，则必须在操作完成之前，将不会退出的线程上调用 <xref:System.Net.Sockets.Socket.BeginConnect%2A>。 这是底层提供程序的限制。 使用的 <xref:System.Net.EndPoint> 也必须不同。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[.NET Framework 中的网络跟踪](/dotnet/framework/network-programming/network-tracing)。  
  
> [!NOTE]
>  对异步 <xref:System.Net.Sockets.Socket> 方法缓存执行上下文（安全上下文、模拟用户和调用上下文）。 第一次使用特定上下文（特定的异步 <xref:System.Net.Sockets.Socket> 方法、特定的 <xref:System.Net.Sockets.Socket> 实例和特定回调）后，该上下文的后续使用将会提高性能。  
  
   
  
## Examples  
 下面的代码示例启动异步连接尝试。  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#1)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#1)]  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#3](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#3)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#3](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="host" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <exception cref="T:System.NotSupportedException">此方法对 <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> 或 <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> 系列中的套接字有效。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">端口号无效。</exception>
        <exception cref="T:System.InvalidOperationException">已通过调用 <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> 将 <see cref="T:System.Net.Sockets.Socket" /> 置于侦听状态，或异步操作已在进行中。</exception>
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
        <related type="Article" href="/dotnet/framework/interop/marshaling-a-delegate-as-a-callback-method">将委托作为回调方法进行封送</related>
        <related type="Article" href="/dotnet/framework/network-programming/asynchronous-client-socket-example">异步客户端套接字示例</related>
        <related type="Article" href="/dotnet/framework/network-programming/asynchronous-server-socket-example">异步服务器套接字示例</related>
      </Docs>
    </Member>
    <Member MemberName="BeginDisconnect">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginDisconnect (bool reuseSocket, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginDisconnect(bool reuseSocket, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginDisconnect(System.Boolean,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginDisconnect (reuseSocket As Boolean, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginDisconnect(bool reuseSocket, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginDisconnect : bool * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginDisconnect (reuseSocket, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reuseSocket" Type="System.Boolean" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="state" Type="System.Object" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="reuseSocket">如果关闭该连接后可以重用此套接字，则为 <see langword="true" />；否则为 <see langword="false" />。</param>
        <param name="callback"><see cref="T:System.AsyncCallback" /> 委托。</param>
        <param name="state">包含此请求的状态信息的对象。</param>
        <summary>开始异步请求从远程终结点断开连接。</summary>
        <returns>一个 <see cref="T:System.IAsyncResult" /> 对象，它引用异步操作。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果使用面向连接的协议，则可以调用 <xref:System.Net.Sockets.Socket.BeginDisconnect%2A> 方法从远程终结点请求断开连接。 如果 `true``reuseSocket`，则可以重复使用套接字。  
  
 <xref:System.Net.Sockets.Socket.BeginDisconnect%2A> 方法使用单独的线程来调用指定的回调方法。 在挂起的断开连接完成之前，<xref:System.Net.Sockets.Socket.EndDisconnect%2A> 方法将会阻止。 有关编写回调方法的其他信息，请参阅将[委托作为回调方法进行封送处理](/dotnet/framework/interop/marshaling-a-delegate-as-a-callback-method)。  
  
> [!NOTE]
>  如果收到 <xref:System.Net.Sockets.SocketException> 异常，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。 获取此代码后，请参阅[Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2)文档，以获取有关错误的详细说明。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[.NET Framework 中的网络跟踪](/dotnet/framework/network-programming/network-tracing)。  
  
   
  
## Examples  
 下面的代码示例为异步通信创建套接字，并将一些数据发送到远程主机。 发送数据后，将调用 <xref:System.Net.Sockets.Socket.Shutdown%2A> 来停止发送和接收活动。 然后调用 <xref:System.Net.Sockets.Socket.BeginDisconnect%2A> 以开始断开连接请求。 请求完成后，将查询 <xref:System.Net.Sockets.Socket.Connected%2A> 属性以测试套接字是否已断开连接。  
  
 [!code-cpp[Nclsocketenhancements#11](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#11)]
 [!code-csharp[Nclsocketenhancements#11](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 对象已关闭。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginReceive">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>开始从连接的 <see cref="T:System.Net.Sockets.Socket" /> 中异步接收数据。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginReceive (buffers As IList(Of ArraySegment(Of Byte)), socketFlags As SocketFlags, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginReceive : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.Net.Sockets.SocketFlags * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginReceive (buffers, socketFlags, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="state" Type="System.Object" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="buffers"><see cref="T:System.Byte" /> 类型的数组，它是存储接收到的数据的位置。</param>
        <param name="socketFlags"><see cref="T:System.Net.Sockets.SocketFlags" /> 值的按位组合。</param>
        <param name="callback">一个 <see cref="T:System.AsyncCallback" /> 委托，它引用操作完成时要调用的方法。</param>
        <param name="state">一个用户定义的对象，其中包含接收操作的相关信息。 当操作完成时，此对象会被传递给 <see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /> 委托。</param>
        <summary>开始从连接的 <see cref="T:System.Net.Sockets.Socket" /> 中异步接收数据。</summary>
        <returns>引用异步读的 <see cref="T:System.IAsyncResult" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 异步 <xref:System.Net.Sockets.Socket.BeginReceive%2A> 操作必须通过调用 <xref:System.Net.Sockets.Socket.EndReceive%2A> 方法完成。 通常，方法由 `callback` 委托调用。  
  
 在操作完成之前，此方法不会被阻止。 若要在操作完成之前一直阻止，请使用 <xref:System.Net.Sockets.Socket.Receive%2A> 方法重载之一。  
  
 若要取消挂起的 <xref:System.Net.Sockets.Socket.BeginReceive%2A>，请调用 <xref:System.Net.Sockets.Socket.Close%2A> 方法。  
  
 有关使用异步编程模型的详细信息，请参阅[以异步方式调用同步方法](/dotnet/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously)。  
  
> [!NOTE]
>  如果收到 <xref:System.Net.Sockets.SocketException>，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。 获取此代码后，请参阅[Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2)文档，以获取有关错误的详细说明。  
  
> [!NOTE]
>  给定线程启动的所有 i/o 都将在该线程退出时取消。 如果线程在操作完成之前退出，则挂起的异步操作可能会失败。  
  
> [!NOTE]
>  `state` 是用户定义的类的实例化。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[.NET Framework 中的网络跟踪](/dotnet/framework/network-programming/network-tracing)。  
  
> [!NOTE]
>  对异步 <xref:System.Net.Sockets.Socket> 方法缓存执行上下文（安全上下文、模拟用户和调用上下文）。 第一次使用特定上下文（特定的异步 <xref:System.Net.Sockets.Socket> 方法、特定的 <xref:System.Net.Sockets.Socket> 实例和特定回调）后，该上下文的后续使用将会提高性能。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
        <related type="Article" href="/dotnet/framework/interop/marshaling-a-delegate-as-a-callback-method">将委托作为回调方法进行封送</related>
        <related type="Article" href="/dotnet/framework/network-programming/asynchronous-client-socket-example">异步客户端套接字示例</related>
        <related type="Article" href="/dotnet/framework/network-programming/asynchronous-server-socket-example">异步服务器套接字示例</related>
      </Docs>
    </Member>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginReceive (buffers As IList(Of ArraySegment(Of Byte)), socketFlags As SocketFlags, ByRef errorCode As SocketError, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginReceive : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.Net.Sockets.SocketFlags * SocketError * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginReceive (buffers, socketFlags, errorCode, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="state" Type="System.Object" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="buffers"><see cref="T:System.Byte" /> 类型的数组，它是存储接收到的数据的位置。</param>
        <param name="socketFlags"><see cref="T:System.Net.Sockets.SocketFlags" /> 值的按位组合。</param>
        <param name="errorCode">一个 <see cref="T:System.Net.Sockets.SocketError" /> 对象，它存储套接字错误。</param>
        <param name="callback">一个 <see cref="T:System.AsyncCallback" /> 委托，它引用操作完成时要调用的方法。</param>
        <param name="state">一个用户定义的对象，其中包含接收操作的相关信息。 当操作完成时，此对象会被传递给 <see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /> 委托。</param>
        <summary>开始从连接的 <see cref="T:System.Net.Sockets.Socket" /> 中异步接收数据。</summary>
        <returns>引用异步读的 <see cref="T:System.IAsyncResult" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 异步 <xref:System.Net.Sockets.Socket.BeginReceive%2A> 操作必须通过调用 <xref:System.Net.Sockets.Socket.EndReceive%2A> 方法完成。 通常，方法由 `callback` 委托调用。  
  
 在操作完成之前，此方法不会被阻止。 若要在操作完成之前一直阻止，请使用 <xref:System.Net.Sockets.Socket.Receive%2A> 方法重载之一。  
  
 若要取消挂起的 <xref:System.Net.Sockets.Socket.BeginReceive%2A>，请调用 <xref:System.Net.Sockets.Socket.Close%2A> 方法。  
  
 有关使用异步编程模型的详细信息，请参阅[以异步方式调用同步方法](/dotnet/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously)。  
  
> [!NOTE]
>  如果收到 <xref:System.Net.Sockets.SocketException>，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。 获取此代码后，请参阅[Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2)文档，以获取有关错误的详细说明。  
  
> [!NOTE]
>  给定线程启动的所有 i/o 都将在该线程退出时取消。 如果线程在操作完成之前退出，则挂起的异步操作可能会失败。  
  
> [!NOTE]
>  `state` 是用户定义的类的实例化。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[.NET Framework 中的网络跟踪](/dotnet/framework/network-programming/network-tracing)。  
  
> [!NOTE]
>  对异步 <xref:System.Net.Sockets.Socket> 方法缓存执行上下文（安全上下文、模拟用户和调用上下文）。 第一次使用特定上下文（特定的异步 <xref:System.Net.Sockets.Socket> 方法、特定的 <xref:System.Net.Sockets.Socket> 实例和特定回调）后，该上下文的后续使用将会提高性能。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
        <related type="Article" href="/dotnet/framework/interop/marshaling-a-delegate-as-a-callback-method">将委托作为回调方法进行封送</related>
        <related type="Article" href="/dotnet/framework/network-programming/asynchronous-client-socket-example">异步客户端套接字示例</related>
        <related type="Article" href="/dotnet/framework/network-programming/asynchronous-server-socket-example">异步服务器套接字示例</related>
      </Docs>
    </Member>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, AsyncCallback callback, object state);" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginReceive (buffer As Byte(), offset As Integer, size As Integer, socketFlags As SocketFlags, callback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.BeginReceive : byte[] * int * int * System.Net.Sockets.SocketFlags * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginReceive (buffer, offset, size, socketFlags, callback, state)" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socket_flags, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socket_flags, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginReceive (buffer As Byte(), offset As Integer, size As Integer, socket_flags As SocketFlags, callback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socket_flags, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.BeginReceive : byte[] * int * int * System.Net.Sockets.SocketFlags * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginReceive (buffer, offset, size, socket_flags, callback, state)" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="socket_flags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="state" Type="System.Object" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="buffer"><see cref="T:System.Byte" /> 类型的数组，它是存储接收到的数据的位置。</param>
        <param name="offset"><paramref name="buffer" /> 参数中存储所接收数据的位置，该位置从零开始计数。</param>
        <param name="size">要接收的字节数。</param>
        <param name="socketFlags"><see cref="T:System.Net.Sockets.SocketFlags" /> 值的按位组合。</param>
        <param name="socket_flags"><see cref="T:System.Net.Sockets.SocketFlags" /> 值的按位组合。</param>
        <param name="callback">一个 <see cref="T:System.AsyncCallback" /> 委托，它引用操作完成时要调用的方法。</param>
        <param name="state">一个用户定义的对象，其中包含接收操作的相关信息。 当操作完成时，此对象会被传递给 <see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /> 委托。</param>
        <summary>开始从连接的 <see cref="T:System.Net.Sockets.Socket" /> 中异步接收数据。</summary>
        <returns>引用异步读的 <see cref="T:System.IAsyncResult" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 异步 <xref:System.Net.Sockets.Socket.BeginReceive%2A> 操作必须通过调用 <xref:System.Net.Sockets.Socket.EndReceive%2A> 方法完成。 通常，方法由 `callback` 委托调用。  
  
 在操作完成之前，此方法不会被阻止。 若要在操作完成之前一直阻止，请使用 <xref:System.Net.Sockets.Socket.Receive%2A> 方法重载之一。  
  
 若要取消挂起的 <xref:System.Net.Sockets.Socket.BeginReceive%2A>，请调用 <xref:System.Net.Sockets.Socket.Close%2A> 方法。  
  
 有关使用异步编程模型的详细信息，请参阅[以异步方式调用同步方法](/dotnet/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously)。  
  
> [!NOTE]
>  如果收到 <xref:System.Net.Sockets.SocketException>，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。 获取此代码后，请参阅[Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2)文档，以获取有关错误的详细说明。  
  
> [!NOTE]
>  给定线程启动的所有 i/o 都将在该线程退出时取消。 如果线程在操作完成之前退出，则挂起的异步操作可能会失败。  
  
> [!NOTE]
>  `state` 是用户定义的类的实例化。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[.NET Framework 中的网络跟踪](/dotnet/framework/network-programming/network-tracing)。  
  
> [!NOTE]
>  对异步 <xref:System.Net.Sockets.Socket> 方法缓存执行上下文（安全上下文、模拟用户和调用上下文）。 第一次使用特定上下文（特定的异步 <xref:System.Net.Sockets.Socket> 方法、特定的 <xref:System.Net.Sockets.Socket> 实例和特定回调）后，该上下文的后续使用将会提高性能。  
  
   
  
## Examples  
 下面的代码示例开始从连接的 <xref:System.Net.Sockets.Socket>中异步接收数据。  
  
 [!code-cpp[Socket_Async_Send_Receive#11](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#11)]
 [!code-csharp[Socket_Async_Send_Receive#11](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#11)]
 [!code-vb[Socket_Async_Send_Receive#11](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#11)]  
  
 [!code-cpp[Socket_Async_Send_Receive#7](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#7)]
 [!code-csharp[Socket_Async_Send_Receive#7](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#7)]
 [!code-vb[Socket_Async_Send_Receive#7](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#7)]  
  
 [!code-cpp[Socket_Async_Send_Receive#8](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#8)]
 [!code-csharp[Socket_Async_Send_Receive#8](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#8)]
 [!code-vb[Socket_Async_Send_Receive#8](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" /> 小于 0。  
  
-或- 
 <paramref name="offset" /> 大于 <paramref name="buffer" /> 的长度。  
  
-或- 
 <paramref name="size" /> 小于 0。  
  
-或- 
 <paramref name="size" /> 大于 <paramref name="buffer" /> 的长度减去 <paramref name="offset" /> 参数的值。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
        <related type="Article" href="/dotnet/framework/interop/marshaling-a-delegate-as-a-callback-method">将委托作为回调方法进行封送</related>
        <related type="Article" href="/dotnet/framework/network-programming/asynchronous-client-socket-example">异步客户端套接字示例</related>
        <related type="Article" href="/dotnet/framework/network-programming/asynchronous-server-socket-example">异步服务器套接字示例</related>
      </Docs>
    </Member>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode, AsyncCallback callback, object state);" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginReceive (buffer As Byte(), offset As Integer, size As Integer, socketFlags As SocketFlags, ByRef errorCode As SocketError, callback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.BeginReceive : byte[] * int * int * System.Net.Sockets.SocketFlags * SocketError * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginReceive (buffer, offset, size, socketFlags, errorCode, callback, state)" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags flags, out System.Net.Sockets.SocketError error, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags flags, [out] valuetype System.Net.Sockets.SocketError&amp; error, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginReceive (buffer As Byte(), offset As Integer, size As Integer, flags As SocketFlags, ByRef error As SocketError, callback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags flags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % error, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.BeginReceive : byte[] * int * int * System.Net.Sockets.SocketFlags * SocketError * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginReceive (buffer, offset, size, flags, error, callback, state)" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="flags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" Index="4" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="error" Type="System.Net.Sockets.SocketError" RefType="out" Index="4" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="state" Type="System.Object" Index="6" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="buffer"><see cref="T:System.Byte" /> 类型的数组，它是存储接收到的数据的位置。</param>
        <param name="offset"><paramref name="buffer" /> 中存储所接收数据的位置。</param>
        <param name="size">要接收的字节数。</param>
        <param name="socketFlags"><see cref="T:System.Net.Sockets.SocketFlags" /> 值的按位组合。</param>
        <param name="flags"><see cref="T:System.Net.Sockets.SocketFlags" /> 值的按位组合。</param>
        <param name="errorCode">一个 <see cref="T:System.Net.Sockets.SocketError" /> 对象，它存储套接字错误。</param>
        <param name="error">一个 <see cref="T:System.Net.Sockets.SocketError" /> 对象，它存储套接字错误。</param>
        <param name="callback">一个 <see cref="T:System.AsyncCallback" /> 委托，它引用操作完成时要调用的方法。</param>
        <param name="state">一个用户定义的对象，其中包含接收操作的相关信息。 当操作完成时，此对象会被传递给 <see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /> 委托。</param>
        <summary>开始从连接的 <see cref="T:System.Net.Sockets.Socket" /> 中异步接收数据。</summary>
        <returns>引用异步读的 <see cref="T:System.IAsyncResult" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 异步 <xref:System.Net.Sockets.Socket.BeginReceive%2A> 操作必须通过调用 <xref:System.Net.Sockets.Socket.EndReceive%2A> 方法完成。 通常，方法由 `callback` 委托调用。  
  
 在操作完成之前，此方法不会被阻止。 若要在操作完成之前一直阻止，请使用 <xref:System.Net.Sockets.Socket.Receive%2A> 方法重载之一。  
  
 若要取消挂起的 <xref:System.Net.Sockets.Socket.BeginReceive%2A>，请调用 <xref:System.Net.Sockets.Socket.Close%2A> 方法。  
  
 有关使用异步编程模型的详细信息，请参阅[以异步方式调用同步方法](/dotnet/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously)。  
  
> [!NOTE]
>  如果收到 <xref:System.Net.Sockets.SocketException>，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。 获取此代码后，请参阅[Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2)文档，以获取有关错误的详细说明。  
  
> [!NOTE]
>  给定线程启动的所有 i/o 都将在该线程退出时取消。 如果线程在操作完成之前退出，则挂起的异步操作可能会失败。  
  
> [!NOTE]
>  `state` 是用户定义的类的实例化。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[.NET Framework 中的网络跟踪](/dotnet/framework/network-programming/network-tracing)。  
  
> [!NOTE]
>  对异步 <xref:System.Net.Sockets.Socket> 方法缓存执行上下文（安全上下文、模拟用户和调用上下文）。 第一次使用特定上下文（特定的异步 <xref:System.Net.Sockets.Socket> 方法、特定的 <xref:System.Net.Sockets.Socket> 实例和特定回调）后，该上下文的后续使用将会提高性能。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" /> 小于 0。  
  
-或- 
 <paramref name="offset" /> 大于 <paramref name="buffer" /> 的长度。  
  
-或- 
 <paramref name="size" /> 小于 0。  
  
-或- 
 <paramref name="size" /> 大于 <paramref name="buffer" /> 的长度减去 <paramref name="offset" /> 参数的值。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
        <related type="Article" href="/dotnet/framework/interop/marshaling-a-delegate-as-a-callback-method">将委托作为回调方法进行封送</related>
        <related type="Article" href="/dotnet/framework/network-programming/asynchronous-client-socket-example">异步客户端套接字示例</related>
        <related type="Article" href="/dotnet/framework/network-programming/asynchronous-server-socket-example">异步服务器套接字示例</related>
      </Docs>
    </Member>
    <Member MemberName="BeginReceiveFrom">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceiveFrom (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint remoteEP, AsyncCallback callback, object state);" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceiveFrom(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint&amp; remoteEP, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginReceiveFrom (buffer As Byte(), offset As Integer, size As Integer, socketFlags As SocketFlags, ByRef remoteEP As EndPoint, callback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceiveFrom(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ % remoteEP, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.BeginReceiveFrom : byte[] * int * int * System.Net.Sockets.SocketFlags * EndPoint * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginReceiveFrom (buffer, offset, size, socketFlags, remoteEP, callback, state)" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceiveFrom (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socket_flags, ref System.Net.EndPoint remote_end, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceiveFrom(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socket_flags, class System.Net.EndPoint&amp; remote_end, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginReceiveFrom (buffer As Byte(), offset As Integer, size As Integer, socket_flags As SocketFlags, ByRef remote_end As EndPoint, callback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceiveFrom(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socket_flags, System::Net::EndPoint ^ % remote_end, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.BeginReceiveFrom : byte[] * int * int * System.Net.Sockets.SocketFlags * EndPoint * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginReceiveFrom (buffer, offset, size, socket_flags, remote_end, callback, state)" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="socket_flags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" RefType="ref" Index="4" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="remote_end" Type="System.Net.EndPoint" RefType="ref" Index="4" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="state" Type="System.Object" Index="6" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="buffer"><see cref="T:System.Byte" /> 类型的数组，它是存储接收到的数据的位置。</param>
        <param name="offset"><paramref name="buffer" /> 参数中存储数据的位置，该位置从零开始计数。</param>
        <param name="size">要接收的字节数。</param>
        <param name="socketFlags"><see cref="T:System.Net.Sockets.SocketFlags" /> 值的按位组合。</param>
        <param name="socket_flags"><see cref="T:System.Net.Sockets.SocketFlags" /> 值的按位组合。</param>
        <param name="remoteEP">一个 <see cref="T:System.Net.EndPoint" />，它表示数据的来源。</param>
        <param name="remote_end">一个 <see cref="T:System.Net.EndPoint" />，它表示数据的来源。</param>
        <param name="callback"><see cref="T:System.AsyncCallback" /> 委托。</param>
        <param name="state">包含此请求的状态信息的对象。</param>
        <summary>开始从指定网络设备中异步接收数据。</summary>
        <returns>引用异步读的 <see cref="T:System.IAsyncResult" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> 方法从远程主机异步读取无连接的数据报。 调用 <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> 方法使你能够在单独的执行线程中接收数据。  
  
 你可以创建一个实现 <xref:System.AsyncCallback> 委托的回调方法，并将其名称传递到 <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> 方法。 为此，你的 `state` 参数至少必须包含用于通信的已连接或默认 <xref:System.Net.Sockets.Socket>。 如果回调需要更多的信息，可以创建一个小类来容纳 <xref:System.Net.Sockets.Socket> 和其他所需的信息。 通过 `state` 参数将此类的实例传递给 <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> 方法。  
  
 回调方法应调用 <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> 方法。 当应用程序调用 <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>时，系统将使用一个单独的线程来执行指定的回调方法，并且它将在 <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> 上阻塞，直到 <xref:System.Net.Sockets.Socket> 读取数据或引发异常。 如果希望在调用 <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> 方法后原始线程被阻止，请使用 <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>。 如果希望原始线程继续执行，请在回调方法中的 T:System.Threading.ManualResetEvent 上调用 Set 方法。 有关编写回调方法的其他信息，请参阅将[委托作为回调方法进行封送处理](/dotnet/framework/interop/marshaling-a-delegate-as-a-callback-method)。  
  
> [!NOTE]
>  在调用 <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>之前，必须使用 <xref:System.Net.Sockets.Socket.Bind%2A> 方法将 <xref:System.Net.Sockets.Socket> 显式绑定到本地终结点，否则 <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> 将引发 <xref:System.Net.Sockets.SocketException>。  
  
 此方法将数据读取到 `buffer` 参数，并捕获从其发送数据的远程主机终结点。 有关如何检索此终结点的信息，请参阅 <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A>。 如果打算从未知主机或多台主机异步接收无连接的数据报，此方法非常有用。 在这些情况下，<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> 将读取接收到本地网络缓冲区中的第一个排队数据报。 如果接收的数据报大于 `buffer`的大小，则 <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> 方法会将尽可能多的消息填入 `buffer`，并引发 <xref:System.Net.Sockets.SocketException>。 如果使用的是不可靠的协议，则过量的数据将丢失。 如果你使用的是可靠协议，则会将多余的数据保留在服务提供程序中，并且你可以通过使用足够大的缓冲区调用 <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> 方法来检索它。  
  
 为了保证始终返回远程主机终结点，应用程序应使用 <xref:System.Net.Sockets.Socket.Bind%2A> 方法将 <xref:System.Net.Sockets.Socket> 显式绑定到本地终结点，然后调用 <xref:System.Net.Sockets.Socket.SetSocketOption%2A> 方法，将 `optionLevel` 参数设置为 <xref:System.Net.Sockets.SocketOptionLevel.IP> 或 <xref:System.Net.Sockets.SocketOptionLevel.IPv6>，将 `optionName` 参数设置为 <xref:System.Net.Sockets.SocketOptionName.PacketInformation>，并使用 `optionValue` 参数在调用 <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> 方法之前启用此选项。 否则，如果在接收方已调用 <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> 方法之前，发送方发送了大量的数据报，则可能不会返回远程主机终结点。  
  
 尽管 <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> 适用于无连接协议，但你也可以使用面向连接的协议。 如果选择这样做，则必须先通过调用 <xref:System.Net.Sockets.Socket.Connect%2A> / <xref:System.Net.Sockets.Socket.BeginConnect%2A> 方法建立远程主机连接，或通过调用 <xref:System.Net.Sockets.Socket.Accept%2A> 或 <xref:System.Net.Sockets.Socket.BeginAccept%2A> 方法接受传入的连接请求。 如果在建立或接受连接之前调用 <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> 方法，将获得 <xref:System.Net.Sockets.SocketException>。 还可以在调用 <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> 方法之前，为无连接协议建立默认远程主机。 在这两种情况下，<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> 方法将忽略 `remoteEP` 参数，并仅从已连接或默认的远程主机接收数据。  
  
 使用面向连接的套接字时，<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> 将读取尽可能多的数据，最多可达 `size` 参数指定的字节数。  
  
 若要取消挂起的 <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>，请调用 <xref:System.Net.Sockets.Socket.Close%2A> 方法。  
  
> [!NOTE]
>  如果收到 <xref:System.Net.Sockets.SocketException>，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。 获取此代码后，请参阅[Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2)文档，以获取有关错误的详细说明。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[.NET Framework 中的网络跟踪](/dotnet/framework/network-programming/network-tracing)。  
  
> [!NOTE]
>  对异步 <xref:System.Net.Sockets.Socket> 方法缓存执行上下文（安全上下文、模拟用户和调用上下文）。 第一次使用特定上下文（特定的异步 <xref:System.Net.Sockets.Socket> 方法、特定的 <xref:System.Net.Sockets.Socket> 实例和特定回调）后，该上下文的后续使用将会提高性能。  
  
   
  
## Examples  
 下面的代码示例从远程主机异步接收无连接的数据报。  
  
 [!code-cpp[Socket_Async_Send_Receive#41](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#41)]
 [!code-csharp[Socket_Async_Send_Receive#41](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#41)]
 [!code-vb[Socket_Async_Send_Receive#41](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#41)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> 为 <see langword="null" />。  
  
-或- 
 <paramref name="remoteEP" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" /> 小于 0。  
  
-或- 
 <paramref name="offset" /> 大于 <paramref name="buffer" /> 的长度。  
  
-或- 
 <paramref name="size" /> 小于 0。  
  
-或- 
 <paramref name="size" /> 大于 <paramref name="buffer" /> 的长度减去 <paramref name="offset" /> 参数的值。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <exception cref="T:System.Security.SecurityException">调用堆栈中的较高调用方无权执行所请求的操作。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Accept" />
        <related type="Article" href="/dotnet/framework/interop/marshaling-a-delegate-as-a-callback-method">将委托作为回调方法进行封送</related>
      </Docs>
    </Member>
    <Member MemberName="BeginReceiveMessageFrom">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceiveMessageFrom (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint remoteEP, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceiveMessageFrom(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint&amp; remoteEP, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginReceiveMessageFrom (buffer As Byte(), offset As Integer, size As Integer, socketFlags As SocketFlags, ByRef remoteEP As EndPoint, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceiveMessageFrom(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ % remoteEP, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginReceiveMessageFrom : byte[] * int * int * System.Net.Sockets.SocketFlags * EndPoint * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginReceiveMessageFrom (buffer, offset, size, socketFlags, remoteEP, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" RefType="ref" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="state" Type="System.Object" Index="6" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="buffer"><see cref="T:System.Byte" /> 类型的数组，它是存储接收到的数据的位置。</param>
        <param name="offset"><paramref name="buffer" /> 参数中存储数据的位置，该位置从零开始计数。</param>
        <param name="size">要接收的字节数。</param>
        <param name="socketFlags"><see cref="T:System.Net.Sockets.SocketFlags" /> 值的按位组合。</param>
        <param name="remoteEP">一个 <see cref="T:System.Net.EndPoint" />，它表示数据的来源。</param>
        <param name="callback"><see cref="T:System.AsyncCallback" /> 委托。</param>
        <param name="state">包含此请求的状态信息的对象。</param>
        <summary>开始使用指定的 <see cref="T:System.Net.Sockets.SocketFlags" /> 将指定字节数的数据异步接收到数据缓冲区的指定位置，然后存储终结点和数据包信息。</summary>
        <returns>引用异步读的 <see cref="T:System.IAsyncResult" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 异步接收操作必须通过调用 <xref:System.Net.Sockets.Socket.EndReceiveMessageFrom%2A> 方法完成。 通常，方法由 `asyncCallback` 委托调用。  
  
 在操作完成之前，此方法不会被阻止。 若要在操作完成之前一直阻止，请使用 <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> 方法。  
  
 若要取消挂起的 <xref:System.Net.Sockets.Socket.BeginReceiveMessageFrom%2A>，请调用 <xref:System.Net.Sockets.Socket.Close%2A> 方法。  
  
 有关使用异步编程模型的详细信息，请参阅[以异步方式调用同步方法](/dotnet/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously)  
  
 此方法将数据读取到 `buffer` 参数，并捕获从其发送数据的远程主机终结点以及有关已接收的数据包的信息。 有关如何检索此终结点的信息，请参阅 <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A>。 如果打算从未知主机或多台主机异步接收无连接的数据报，此方法非常有用。  
  
> [!NOTE]
>  如果收到 <xref:System.Net.Sockets.SocketException>，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。 获取此代码后，请参阅[Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2)文档，以获取有关错误的详细说明。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[.NET Framework 中的网络跟踪](/dotnet/framework/network-programming/network-tracing)。  
  
> [!NOTE]
>  对异步 <xref:System.Net.Sockets.Socket> 方法缓存执行上下文（安全上下文、模拟用户和调用上下文）。 第一次使用特定上下文（特定的异步 <xref:System.Net.Sockets.Socket> 方法、特定的 <xref:System.Net.Sockets.Socket> 实例和特定回调）后，该上下文的后续使用将会提高性能。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> 为 <see langword="null" />。  
  
-或- 
 <paramref name="remoteEP" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" /> 小于 0。  
  
-或- 
 <paramref name="offset" /> 大于 <paramref name="buffer" /> 的长度。  
  
-或- 
 <paramref name="size" /> 小于 0。  
  
-或- 
 <paramref name="size" /> 大于 <paramref name="buffer" /> 的长度减去 <paramref name="offset" /> 参数的值。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginSend">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>将数据异步发送到连接的 <see cref="T:System.Net.Sockets.Socket" />。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginSend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSend (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSend(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginSend (buffers As IList(Of ArraySegment(Of Byte)), socketFlags As SocketFlags, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSend(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginSend : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.Net.Sockets.SocketFlags * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginSend (buffers, socketFlags, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="state" Type="System.Object" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="buffers"><see cref="T:System.Byte" /> 类型的数组，它包含要发送的数据。</param>
        <param name="socketFlags"><see cref="T:System.Net.Sockets.SocketFlags" /> 值的按位组合。</param>
        <param name="callback"><see cref="T:System.AsyncCallback" /> 委托。</param>
        <param name="state">包含此请求的状态信息的对象。</param>
        <summary>将数据异步发送到连接的 <see cref="T:System.Net.Sockets.Socket" />。</summary>
        <returns>引用异步发送的 <see cref="T:System.IAsyncResult" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.BeginSend%2A> 方法开始异步发送操作到在 <xref:System.Net.Sockets.Socket.Connect%2A>、<xref:System.Net.Sockets.Socket.BeginConnect%2A>、<xref:System.Net.Sockets.Socket.Accept%2A>或 <xref:System.Net.Sockets.Socket.BeginAccept%2A> 方法中建立的远程主机。 如果你不首先调用 <xref:System.Net.Sockets.Socket.Accept%2A>、<xref:System.Net.Sockets.Socket.BeginAccept%2A>、<xref:System.Net.Sockets.Socket.Connect%2A>或 <xref:System.Net.Sockets.Socket.BeginConnect%2A>，<xref:System.Net.Sockets.Socket.BeginSend%2A> 会引发异常。 调用 <xref:System.Net.Sockets.Socket.BeginSend%2A> 方法使你能够在单独的执行线程中发送数据。  
  
 你可以创建一个实现 <xref:System.AsyncCallback> 委托的回调方法，并将其名称传递到 <xref:System.Net.Sockets.Socket.BeginSend%2A> 方法。 为此，你的 `state` 参数至少必须包含用于通信的已连接或默认 <xref:System.Net.Sockets.Socket>。 如果回调需要更多的信息，可以创建一个小型类或结构来保存 <xref:System.Net.Sockets.Socket> 和其他所需的信息。 通过 `state` 参数将此类的实例传递给 <xref:System.Net.Sockets.Socket.BeginSend%2A> 方法。  
  
 回调方法应调用 <xref:System.Net.Sockets.Socket.EndSend%2A> 方法。 当应用程序调用 <xref:System.Net.Sockets.Socket.BeginSend%2A>时，系统将使用一个单独的线程来执行指定的回调方法，并将在 <xref:System.Net.Sockets.Socket.EndSend%2A> 上阻塞，直到 <xref:System.Net.Sockets.Socket> 发送请求的字节数或引发异常。 如果希望在调用 <xref:System.Net.Sockets.Socket.BeginSend%2A> 方法后原始线程被阻止，请使用 <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType> 方法。 如果希望原始线程继续执行，请在回调方法中的 T:System.Threading.ManualResetEvent 上调用 Set 方法。 有关编写回调方法的其他信息，请参阅将[委托作为回调方法进行封送处理](/dotnet/framework/interop/marshaling-a-delegate-as-a-callback-method)。  
  
 尽管适用于面向连接的协议，但 <xref:System.Net.Sockets.Socket.BeginSend%2A> 也适用于无连接协议，前提是你首先调用 <xref:System.Net.Sockets.Socket.Connect%2A> 或 <xref:System.Net.Sockets.Socket.BeginConnect%2A> 方法来建立默认远程主机。 如果使用无连接协议并计划将数据发送到多个不同的主机，则应使用 <xref:System.Net.Sockets.Socket.BeginSendTo%2A>。 即使已使用 <xref:System.Net.Sockets.Socket.Connect%2A>建立默认远程主机，也可以使用 <xref:System.Net.Sockets.Socket.BeginSendTo%2A>。 还可以在调用 <xref:System.Net.Sockets.Socket.BeginSend%2A> 之前更改默认远程主机，方法是调用 <xref:System.Net.Sockets.Socket.Connect%2A> 或 <xref:System.Net.Sockets.Socket.BeginConnect%2A>。 对于无连接协议，还必须确保缓冲区的大小不超过基础服务提供程序的最大数据包大小。 如果是这样，则将不发送数据报并且 <xref:System.Net.Sockets.Socket.BeginSend%2A> 将引发 <xref:System.Net.Sockets.SocketException>。  
  
 如果指定 <xref:System.Net.Sockets.SocketFlags.DontRoute> 标志作为 `socketflags` 参数，则将不路由要发送的数据。  
  
> [!NOTE]
>  如果收到 <xref:System.Net.Sockets.SocketException>，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。 获取此代码后，请参阅[Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2)文档，以获取有关错误的详细说明。  
  
> [!NOTE]
>  给定线程启动的所有 i/o 都将在该线程退出时取消。 如果线程在操作完成之前退出，则挂起的异步操作可能会失败。  
  
> [!NOTE]
>  `state` 是用户定义的类的实例化。  
  
> [!NOTE]
>  成功完成发送并不表示数据已成功传递。 如果传输系统中没有可用于保存要传输的数据的缓冲区空间，则发送将会阻止，除非已将套接字置于非阻止模式。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[.NET Framework 中的网络跟踪](/dotnet/framework/network-programming/network-tracing)。  
  
> [!NOTE]
>  对异步 <xref:System.Net.Sockets.Socket> 方法缓存执行上下文（安全上下文、模拟用户和调用上下文）。 第一次使用特定上下文（特定的异步 <xref:System.Net.Sockets.Socket> 方法、特定的 <xref:System.Net.Sockets.Socket> 实例和特定回调）后，该上下文的后续使用将会提高性能。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffers" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="buffers" /> 为空。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。 请参见下面的备注部分。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" />
        <related type="Article" href="/dotnet/framework/interop/marshaling-a-delegate-as-a-callback-method">将委托作为回调方法进行封送</related>
        <related type="Article" href="/dotnet/framework/network-programming/asynchronous-client-socket-example">异步客户端套接字示例</related>
        <related type="Article" href="/dotnet/framework/network-programming/asynchronous-server-socket-example">异步服务器套接字示例</related>
      </Docs>
    </Member>
    <Member MemberName="BeginSend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSend (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSend(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginSend (buffers As IList(Of ArraySegment(Of Byte)), socketFlags As SocketFlags, ByRef errorCode As SocketError, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSend(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginSend : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.Net.Sockets.SocketFlags * SocketError * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginSend (buffers, socketFlags, errorCode, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="state" Type="System.Object" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="buffers"><see cref="T:System.Byte" /> 类型的数组，它包含要发送的数据。</param>
        <param name="socketFlags"><see cref="T:System.Net.Sockets.SocketFlags" /> 值的按位组合。</param>
        <param name="errorCode">一个 <see cref="T:System.Net.Sockets.SocketError" /> 对象，它存储套接字错误。</param>
        <param name="callback"><see cref="T:System.AsyncCallback" /> 委托。</param>
        <param name="state">包含此请求的状态信息的对象。</param>
        <summary>将数据异步发送到连接的 <see cref="T:System.Net.Sockets.Socket" />。</summary>
        <returns>引用异步发送的 <see cref="T:System.IAsyncResult" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.BeginSend%2A> 方法开始异步发送操作到在 <xref:System.Net.Sockets.Socket.Connect%2A>、<xref:System.Net.Sockets.Socket.BeginConnect%2A>、<xref:System.Net.Sockets.Socket.Accept%2A>或 <xref:System.Net.Sockets.Socket.BeginAccept%2A> 方法中建立的远程主机。 如果你不首先调用 <xref:System.Net.Sockets.Socket.Accept%2A>、<xref:System.Net.Sockets.Socket.BeginAccept%2A>、<xref:System.Net.Sockets.Socket.Connect%2A>或 <xref:System.Net.Sockets.Socket.BeginConnect%2A>，<xref:System.Net.Sockets.Socket.BeginSend%2A> 会引发异常。 调用 <xref:System.Net.Sockets.Socket.BeginSend%2A> 方法使你能够在单独的执行线程中发送数据。  
  
 你可以创建一个实现 <xref:System.AsyncCallback> 委托的回调方法，并将其名称传递到 <xref:System.Net.Sockets.Socket.BeginSend%2A> 方法。 为此，你的 `state` 参数至少必须包含用于通信的已连接或默认 <xref:System.Net.Sockets.Socket>。 如果回调需要更多的信息，可以创建一个小型类或结构来保存 <xref:System.Net.Sockets.Socket> 和其他所需的信息。 通过 `state` 参数将此类的实例传递给 <xref:System.Net.Sockets.Socket.BeginSend%2A> 方法。  
  
 回调方法应调用 <xref:System.Net.Sockets.Socket.EndSend%2A> 方法。 当应用程序调用 <xref:System.Net.Sockets.Socket.BeginSend%2A>时，系统将使用一个单独的线程来执行指定的回调方法，并将在 <xref:System.Net.Sockets.Socket.EndSend%2A> 上阻塞，直到 <xref:System.Net.Sockets.Socket> 发送请求的字节数或引发异常。 如果希望在调用 <xref:System.Net.Sockets.Socket.BeginSend%2A> 方法后原始线程被阻止，请使用 <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType> 方法。 如果希望原始线程继续执行，请在回调方法中的 <xref:System.Threading.ManualResetEvent> 上调用 Set 方法。 有关编写回调方法的其他信息，请参阅将[委托作为回调方法进行封送处理](/dotnet/framework/interop/marshaling-a-delegate-as-a-callback-method)。  
  
 尽管适用于面向连接的协议，但 <xref:System.Net.Sockets.Socket.BeginSend%2A> 也适用于无连接协议，前提是你首先调用 <xref:System.Net.Sockets.Socket.Connect%2A> 或 <xref:System.Net.Sockets.Socket.BeginConnect%2A> 方法来建立默认远程主机。 如果使用无连接协议并计划将数据发送到多个不同的主机，则应使用 <xref:System.Net.Sockets.Socket.BeginSendTo%2A>。 即使已使用 <xref:System.Net.Sockets.Socket.Connect%2A>建立默认远程主机，也可以使用 <xref:System.Net.Sockets.Socket.BeginSendTo%2A>。 还可以在调用 <xref:System.Net.Sockets.Socket.BeginSend%2A> 之前更改默认远程主机，方法是调用 <xref:System.Net.Sockets.Socket.Connect%2A> 或 <xref:System.Net.Sockets.Socket.BeginConnect%2A>。 对于无连接协议，还必须确保缓冲区的大小不超过基础服务提供程序的最大数据包大小。 如果是这样，则将不发送数据报并且 <xref:System.Net.Sockets.Socket.BeginSend%2A> 将引发 <xref:System.Net.Sockets.SocketException>。  
  
 如果指定 <xref:System.Net.Sockets.SocketFlags.DontRoute> 标志作为 `socketflags` 参数，则将不路由要发送的数据。  
  
> [!NOTE]
>  如果收到 <xref:System.Net.Sockets.SocketException>，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。 获取此代码后，请参阅[Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2)文档，以获取有关错误的详细说明。  
  
> [!NOTE]
>  给定线程启动的所有 i/o 都将在该线程退出时取消。 如果线程在操作完成之前退出，则挂起的异步操作可能会失败。  
  
> [!NOTE]
>  `state` 是用户定义的类的实例化。  
  
> [!NOTE]
>  成功完成发送并不表示数据已成功传递。 如果传输系统中没有可用于保存要传输的数据的缓冲区空间，则发送将会阻止，除非已将套接字置于非阻止模式。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[.NET Framework 中的网络跟踪](/dotnet/framework/network-programming/network-tracing)。  
  
> [!NOTE]
>  对异步 <xref:System.Net.Sockets.Socket> 方法缓存执行上下文（安全上下文、模拟用户和调用上下文）。 第一次使用特定上下文（特定的异步 <xref:System.Net.Sockets.Socket> 方法、特定的 <xref:System.Net.Sockets.Socket> 实例和特定回调）后，该上下文的后续使用将会提高性能。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffers" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="buffers" /> 为空。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。 请参见下面的备注部分。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" />
        <related type="Article" href="/dotnet/framework/interop/marshaling-a-delegate-as-a-callback-method">将委托作为回调方法进行封送</related>
        <related type="Article" href="/dotnet/framework/network-programming/asynchronous-client-socket-example">异步客户端套接字示例</related>
        <related type="Article" href="/dotnet/framework/network-programming/asynchronous-server-socket-example">异步服务器套接字示例</related>
      </Docs>
    </Member>
    <Member MemberName="BeginSend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSend (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSend(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginSend (buffer As Byte(), offset As Integer, size As Integer, socketFlags As SocketFlags, ByRef errorCode As SocketError, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSend(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginSend : byte[] * int * int * System.Net.Sockets.SocketFlags * SocketError * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginSend (buffer, offset, size, socketFlags, errorCode, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="state" Type="System.Object" Index="6" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="buffer"><see cref="T:System.Byte" /> 类型的数组，它包含要发送的数据。</param>
        <param name="offset"><paramref name="buffer" /> 参数中开始发送数据的位置，该位置从零开始计数。</param>
        <param name="size">要发送的字节数。</param>
        <param name="socketFlags"><see cref="T:System.Net.Sockets.SocketFlags" /> 值的按位组合。</param>
        <param name="errorCode">一个 <see cref="T:System.Net.Sockets.SocketError" /> 对象，它存储套接字错误。</param>
        <param name="callback"><see cref="T:System.AsyncCallback" /> 委托。</param>
        <param name="state">包含此请求的状态信息的对象。</param>
        <summary>将数据异步发送到连接的 <see cref="T:System.Net.Sockets.Socket" />。</summary>
        <returns>引用异步发送的 <see cref="T:System.IAsyncResult" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.BeginSend%2A> 方法开始异步发送操作到在 <xref:System.Net.Sockets.Socket.Connect%2A>、<xref:System.Net.Sockets.Socket.BeginConnect%2A>、<xref:System.Net.Sockets.Socket.Accept%2A>或 <xref:System.Net.Sockets.Socket.BeginAccept%2A> 方法中建立的远程主机。 如果你不首先调用 <xref:System.Net.Sockets.Socket.Accept%2A>、<xref:System.Net.Sockets.Socket.BeginAccept%2A>、<xref:System.Net.Sockets.Socket.Connect%2A>或 <xref:System.Net.Sockets.Socket.BeginConnect%2A>，<xref:System.Net.Sockets.Socket.BeginSend%2A> 会引发异常。 调用 <xref:System.Net.Sockets.Socket.BeginSend%2A> 方法使你能够在单独的执行线程中发送数据。  
  
 你可以创建一个实现 <xref:System.AsyncCallback> 委托的回调方法，并将其名称传递到 <xref:System.Net.Sockets.Socket.BeginSend%2A> 方法。 为此，你的 `state` 参数至少必须包含用于通信的已连接或默认 <xref:System.Net.Sockets.Socket>。 如果回调需要更多的信息，可以创建一个小型类或结构来保存 <xref:System.Net.Sockets.Socket> 和其他所需的信息。 通过 `state` 参数将此类的实例传递给 <xref:System.Net.Sockets.Socket.BeginSend%2A> 方法。  
  
 回调方法应调用 <xref:System.Net.Sockets.Socket.EndSend%2A> 方法。 当应用程序调用 <xref:System.Net.Sockets.Socket.BeginSend%2A>时，系统将使用一个单独的线程来执行指定的回调方法，并将在 <xref:System.Net.Sockets.Socket.EndSend%2A> 上阻塞，直到 <xref:System.Net.Sockets.Socket> 发送请求的字节数或引发异常。 如果希望在调用 <xref:System.Net.Sockets.Socket.BeginSend%2A> 方法后原始线程被阻止，请使用 <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType> 方法。 如果希望原始线程继续执行，请在回调方法中的 T:System.Threading.ManualResetEvent 上调用 Set 方法。 有关编写回调方法的其他信息，请参阅将[委托作为回调方法进行封送处理](/dotnet/framework/interop/marshaling-a-delegate-as-a-callback-method)。  
  
 尽管适用于面向连接的协议，但 <xref:System.Net.Sockets.Socket.BeginSend%2A> 也适用于无连接协议，前提是你首先调用 <xref:System.Net.Sockets.Socket.Connect%2A> 或 <xref:System.Net.Sockets.Socket.BeginConnect%2A> 方法来建立默认远程主机。 如果使用无连接协议并计划将数据发送到多个不同的主机，则应使用 <xref:System.Net.Sockets.Socket.BeginSendTo%2A>。 即使已使用 <xref:System.Net.Sockets.Socket.Connect%2A>建立默认远程主机，也可以使用 <xref:System.Net.Sockets.Socket.BeginSendTo%2A>。 还可以在调用 <xref:System.Net.Sockets.Socket.BeginSend%2A> 之前更改默认远程主机，方法是调用 <xref:System.Net.Sockets.Socket.Connect%2A> 或 <xref:System.Net.Sockets.Socket.BeginConnect%2A>。 对于无连接协议，还必须确保缓冲区的大小不超过基础服务提供程序的最大数据包大小。 如果是这样，则将不发送数据报并且 <xref:System.Net.Sockets.Socket.BeginSend%2A> 将引发 <xref:System.Net.Sockets.SocketException>。  
  
 如果指定 <xref:System.Net.Sockets.SocketFlags.DontRoute> 标志作为 `socketflags` 参数，则将不路由要发送的数据。  
  
> [!NOTE]
>  如果收到 <xref:System.Net.Sockets.SocketException>，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。 获取此代码后，请参阅[Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2)文档，以获取有关错误的详细说明。  
  
> [!NOTE]
>  给定线程启动的所有 i/o 都将在该线程退出时取消。 如果线程在操作完成之前退出，则挂起的异步操作可能会失败。  
  
> [!NOTE]
>  `state` 是用户定义的类的实例化。  
  
> [!NOTE]
>  成功完成发送并不表示数据已成功传递。 如果传输系统中没有可用于保存要传输的数据的缓冲区空间，则发送将会阻止，除非已将套接字置于非阻止模式。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[.NET Framework 中的网络跟踪](/dotnet/framework/network-programming/network-tracing)。  
  
> [!NOTE]
>  对异步 <xref:System.Net.Sockets.Socket> 方法缓存执行上下文（安全上下文、模拟用户和调用上下文）。 第一次使用特定上下文（特定的异步 <xref:System.Net.Sockets.Socket> 方法、特定的 <xref:System.Net.Sockets.Socket> 实例和特定回调）后，该上下文的后续使用将会提高性能。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。 请参见下面的备注部分。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" /> 小于 0。  
  
-或- 
 <paramref name="offset" /> 小于 <paramref name="buffer" /> 的长度。  
  
-或- 
 <paramref name="size" /> 小于 0。  
  
-或- 
 <paramref name="size" /> 大于 <paramref name="buffer" /> 的长度减去 <paramref name="offset" /> 参数的值。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" />
        <related type="Article" href="/dotnet/framework/interop/marshaling-a-delegate-as-a-callback-method">将委托作为回调方法进行封送</related>
        <related type="Article" href="/dotnet/framework/network-programming/asynchronous-client-socket-example">异步客户端套接字示例</related>
        <related type="Article" href="/dotnet/framework/network-programming/asynchronous-server-socket-example">异步服务器套接字示例</related>
      </Docs>
    </Member>
    <Member MemberName="BeginSend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSend (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, AsyncCallback callback, object state);" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSend(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginSend (buffer As Byte(), offset As Integer, size As Integer, socketFlags As SocketFlags, callback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSend(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.BeginSend : byte[] * int * int * System.Net.Sockets.SocketFlags * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginSend (buffer, offset, size, socketFlags, callback, state)" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSend (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socket_flags, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSend(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socket_flags, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginSend (buffer As Byte(), offset As Integer, size As Integer, socket_flags As SocketFlags, callback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSend(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socket_flags, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.BeginSend : byte[] * int * int * System.Net.Sockets.SocketFlags * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginSend (buffer, offset, size, socket_flags, callback, state)" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="socket_flags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="state" Type="System.Object" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="buffer"><see cref="T:System.Byte" /> 类型的数组，它包含要发送的数据。</param>
        <param name="offset"><paramref name="buffer" /> 参数中开始发送数据的位置，该位置从零开始计数。</param>
        <param name="size">要发送的字节数。</param>
        <param name="socketFlags"><see cref="T:System.Net.Sockets.SocketFlags" /> 值的按位组合。</param>
        <param name="socket_flags"><see cref="T:System.Net.Sockets.SocketFlags" /> 值的按位组合。</param>
        <param name="callback"><see cref="T:System.AsyncCallback" /> 委托。</param>
        <param name="state">包含此请求的状态信息的对象。</param>
        <summary>将数据异步发送到连接的 <see cref="T:System.Net.Sockets.Socket" />。</summary>
        <returns>引用异步发送的 <see cref="T:System.IAsyncResult" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.BeginSend%2A> 方法开始异步发送操作到在 <xref:System.Net.Sockets.Socket.Connect%2A>、<xref:System.Net.Sockets.Socket.BeginConnect%2A>、<xref:System.Net.Sockets.Socket.Accept%2A>或 <xref:System.Net.Sockets.Socket.BeginAccept%2A> 方法中建立的远程主机。 如果你不首先调用 <xref:System.Net.Sockets.Socket.Accept%2A>、<xref:System.Net.Sockets.Socket.BeginAccept%2A>、<xref:System.Net.Sockets.Socket.Connect%2A>或 <xref:System.Net.Sockets.Socket.BeginConnect%2A>，<xref:System.Net.Sockets.Socket.BeginSend%2A> 会引发异常。 调用 <xref:System.Net.Sockets.Socket.BeginSend%2A> 方法使你能够在单独的执行线程中发送数据。  
  
 你可以创建一个实现 <xref:System.AsyncCallback> 委托的回调方法，并将其名称传递到 <xref:System.Net.Sockets.Socket.BeginSend%2A> 方法。 为此，你的 `state` 参数至少必须包含用于通信的已连接或默认 <xref:System.Net.Sockets.Socket>。 如果回调需要更多的信息，可以创建一个小型类或结构来保存 <xref:System.Net.Sockets.Socket> 和其他所需的信息。 通过 `state` 参数将此类的实例传递给 <xref:System.Net.Sockets.Socket.BeginSend%2A> 方法。  
  
 回调方法应调用 <xref:System.Net.Sockets.Socket.EndSend%2A> 方法。 当应用程序调用 <xref:System.Net.Sockets.Socket.BeginSend%2A>时，系统将使用一个单独的线程来执行指定的回调方法，并将在 <xref:System.Net.Sockets.Socket.EndSend%2A> 上阻塞，直到 <xref:System.Net.Sockets.Socket> 发送请求的字节数或引发异常。 如果希望在调用 <xref:System.Net.Sockets.Socket.BeginSend%2A> 方法后原始线程被阻止，请使用 <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType> 方法。 如果希望原始线程继续执行，请在回调方法中的 T:System.Threading.ManualResetEvent 上调用 Set 方法。 有关编写回调方法的其他信息，请参阅将[委托作为回调方法进行封送处理](/dotnet/framework/interop/marshaling-a-delegate-as-a-callback-method)。  
  
 尽管适用于面向连接的协议，但 <xref:System.Net.Sockets.Socket.BeginSend%2A> 也适用于无连接协议，前提是你首先调用 <xref:System.Net.Sockets.Socket.Connect%2A> 或 <xref:System.Net.Sockets.Socket.BeginConnect%2A> 方法来建立默认远程主机。 如果使用无连接协议并计划将数据发送到多个不同的主机，则应使用 <xref:System.Net.Sockets.Socket.BeginSendTo%2A>。 即使已使用 <xref:System.Net.Sockets.Socket.Connect%2A>建立默认远程主机，也可以使用 <xref:System.Net.Sockets.Socket.BeginSendTo%2A>。 还可以在调用 <xref:System.Net.Sockets.Socket.BeginSend%2A> 之前更改默认远程主机，方法是调用 <xref:System.Net.Sockets.Socket.Connect%2A> 或 <xref:System.Net.Sockets.Socket.BeginConnect%2A>。 对于无连接协议，还必须确保缓冲区的大小不超过基础服务提供程序的最大数据包大小。 如果是这样，则将不发送数据报并且 <xref:System.Net.Sockets.Socket.BeginSend%2A> 将引发 <xref:System.Net.Sockets.SocketException>。  
  
 如果指定 <xref:System.Net.Sockets.SocketFlags.DontRoute> 标志作为 `socketflags` 参数，则将不路由要发送的数据。  
  
> [!NOTE]
>  如果收到 <xref:System.Net.Sockets.SocketException>，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。 获取此代码后，请参阅[Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2)文档，以获取有关错误的详细说明。  
  
> [!NOTE]
>  给定线程启动的所有 i/o 都将在该线程退出时取消。 如果线程在操作完成之前退出，则挂起的异步操作可能会失败。  
  
> [!NOTE]
>  `state` 是用户定义的类的实例化。  
  
> [!NOTE]
>  成功完成发送并不表示数据已成功传递。 如果传输系统中没有可用于保存要传输的数据的缓冲区空间，则发送将会阻止，除非已将套接字置于非阻止模式。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[.NET Framework 中的网络跟踪](/dotnet/framework/network-programming/network-tracing)。  
  
> [!NOTE]
>  对异步 <xref:System.Net.Sockets.Socket> 方法缓存执行上下文（安全上下文、模拟用户和调用上下文）。 第一次使用特定上下文（特定的异步 <xref:System.Net.Sockets.Socket> 方法、特定的 <xref:System.Net.Sockets.Socket> 实例和特定回调）后，该上下文的后续使用将会提高性能。  
  
   
  
## Examples  
 下面的代码示例开始将数据异步发送到远程主机。  
  
 [!code-cpp[Socket_Async_Send_Receive#5](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#5)]
 [!code-csharp[Socket_Async_Send_Receive#5](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#5)]
 [!code-vb[Socket_Async_Send_Receive#5](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。 请参见下面的备注部分。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" /> 小于 0。  
  
-或- 
 <paramref name="offset" /> 小于 <paramref name="buffer" /> 的长度。  
  
-或- 
 <paramref name="size" /> 小于 0。  
  
-或- 
 <paramref name="size" /> 大于 <paramref name="buffer" /> 的长度减去 <paramref name="offset" /> 参数的值。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" />
        <related type="Article" href="/dotnet/framework/interop/marshaling-a-delegate-as-a-callback-method">将委托作为回调方法进行封送</related>
        <related type="Article" href="/dotnet/framework/network-programming/asynchronous-client-socket-example">异步客户端套接字示例</related>
        <related type="Article" href="/dotnet/framework/network-programming/asynchronous-server-socket-example">异步服务器套接字示例</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginSendFile">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>将文件异步发送到连接的 <see cref="T:System.Net.Sockets.Socket" /> 对象。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginSendFile">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSendFile (string fileName, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSendFile(string fileName, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginSendFile (fileName As String, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSendFile(System::String ^ fileName, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginSendFile : string * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginSendFile (fileName, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="state" Type="System.Object" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="fileName">一个字符串，它包含要发送的文件的路径和名称。 此参数可以为 <see langword="null" />。</param>
        <param name="callback"><see cref="T:System.AsyncCallback" /> 委托。</param>
        <param name="state">包含此请求的状态信息的对象。</param>
        <summary>使用 <see cref="T:System.Net.Sockets.Socket" /> 标志，将文件 <paramref name="fileName" /> 发送到连接的 <see cref="F:System.Net.Sockets.TransmitFileOptions.UseDefaultWorkerThread" /> 对象。</summary>
        <returns>一个 <see cref="T:System.IAsyncResult" /> 对象，它表示异步发送。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此重载将文件 `fileName` 发送到连接的套接字。 如果 `fileName` 位于本地目录中，则只能用该文件的名称进行标识;否则，必须指定文件的完整路径和名称。 通配符（".。。支持\\\myfile.txt "）和 UNC 共享名称（"\\\\\\\shared 目录\\\myfile.txt "）。 如果找不到该文件，则将引发异常 <xref:System.IO.FileNotFoundException>。  
  
 此方法使用在 Windows Socket 2 API 中找到的 `TransmitFile` 函数。 有关 `TransmitFile` 函数及其标志的详细信息，请参阅[Windows 套接字](/windows/desktop/WinSock/)文档。  
  
 <xref:System.Net.Sockets.Socket.BeginSendFile%2A> 方法开始异步发送操作到在 <xref:System.Net.Sockets.Socket.Connect%2A>、<xref:System.Net.Sockets.Socket.BeginConnect%2A>、<xref:System.Net.Sockets.Socket.Accept%2A>或 <xref:System.Net.Sockets.Socket.BeginAccept%2A> 方法中建立的远程主机。 如果不首先调用 <xref:System.Net.Sockets.Socket.Accept%2A>、<xref:System.Net.Sockets.Socket.BeginAccept%2A>、<xref:System.Net.Sockets.Socket.Connect%2A>或 <xref:System.Net.Sockets.Socket.BeginConnect%2A>，<xref:System.Net.Sockets.Socket.BeginSendFile%2A> 会引发异常。 通过调用 <xref:System.Net.Sockets.Socket.BeginSendFile%2A> 方法，您可以在单独的执行线程中发送文件。  
  
 若要完成此操作，可以创建一个由 <xref:System.AsyncCallback> 委托参数调用的回调方法。 为此，至少 `state` 参数必须包含用于通信的 <xref:System.Net.Sockets.Socket> 对象。 如果回调需要更多的信息，可以创建一个类或结构来保存 <xref:System.Net.Sockets.Socket> 和其他所需的信息。 通过 `state` 参数向 <xref:System.Net.Sockets.Socket.BeginSendFile%2A> 方法传递此自定义对象的实例。  
  
 回调方法必须调用 <xref:System.Net.Sockets.Socket.EndSendFile%2A> 方法。 当应用程序调用 <xref:System.Net.Sockets.Socket.BeginSendFile%2A>时，系统将使用一个单独的线程来执行指定的回调方法，并在 <xref:System.Net.Sockets.Socket.EndSendFile%2A> 上阻止，直到 <xref:System.Net.Sockets.Socket> 发送整个文件或引发异常。 有关编写回调方法的其他信息，请参阅将[委托作为回调方法进行封送处理](/dotnet/framework/interop/marshaling-a-delegate-as-a-callback-method)。  
  
 尽管适用于面向连接的协议，但 <xref:System.Net.Sockets.Socket.BeginSendFile%2A> 也适用于无连接协议，前提是你首先调用 <xref:System.Net.Sockets.Socket.Connect%2A> 或 <xref:System.Net.Sockets.Socket.BeginConnect%2A> 方法来建立默认远程主机。 在无连接协议的情况下，必须确保文件大小不超过基础服务提供程序的最大数据包大小。 如果是这样，则不发送数据报并且 <xref:System.Net.Sockets.Socket.BeginSendFile%2A> 引发 <xref:System.Net.Sockets.SocketException> 异常。  
  
> [!NOTE]
>  如果收到 <xref:System.Net.Sockets.SocketException> 异常，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。 获取此代码后，请参阅[Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2)文档，以获取有关错误的详细说明。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[.NET Framework 中的网络跟踪](/dotnet/framework/network-programming/network-tracing)。  
  
> [!NOTE]
>  对异步 <xref:System.Net.Sockets.Socket> 方法缓存执行上下文（安全上下文、模拟用户和调用上下文）。 第一次使用特定上下文（特定的异步 <xref:System.Net.Sockets.Socket> 方法、特定的 <xref:System.Net.Sockets.Socket> 实例和特定回调）后，该上下文的后续使用将会提高性能。  
  
   
  
## Examples  
 下面的代码示例创建并连接套接字以进行异步通信。 首先，将文件 "text .txt" 异步发送到远程主机。 回调委托调用 <xref:System.Net.Sockets.Socket.EndSendFile%2A> 来完成传输。  
  
 [!code-cpp[NCLSocketEnhancements#9](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#9)]
 [!code-csharp[NCLSocketEnhancements#9](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 对象已关闭。</exception>
        <exception cref="T:System.NotSupportedException">套接字未连接到远程主机。</exception>
        <exception cref="T:System.IO.FileNotFoundException">未找到文件 <paramref name="fileName" />。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。 请参见下面的备注部分。</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginSendFile">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSendFile (string fileName, byte[] preBuffer, byte[] postBuffer, System.Net.Sockets.TransmitFileOptions flags, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSendFile(string fileName, unsigned int8[] preBuffer, unsigned int8[] postBuffer, valuetype System.Net.Sockets.TransmitFileOptions flags, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginSendFile (fileName As String, preBuffer As Byte(), postBuffer As Byte(), flags As TransmitFileOptions, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSendFile(System::String ^ fileName, cli::array &lt;System::Byte&gt; ^ preBuffer, cli::array &lt;System::Byte&gt; ^ postBuffer, System::Net::Sockets::TransmitFileOptions flags, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginSendFile : string * byte[] * byte[] * System.Net.Sockets.TransmitFileOptions * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginSendFile (fileName, preBuffer, postBuffer, flags, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="preBuffer" Type="System.Byte[]" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="postBuffer" Type="System.Byte[]" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="flags" Type="System.Net.Sockets.TransmitFileOptions" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="state" Type="System.Object" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="fileName">一个字符串，它包含要发送的文件的路径和名称。 此参数可以为 <see langword="null" />。</param>
        <param name="preBuffer">一个 <see cref="T:System.Byte" /> 数组，它包含发送文件前要发送的数据。 此参数可以为 <see langword="null" />。</param>
        <param name="postBuffer">一个 <see cref="T:System.Byte" /> 数组，它包含发送文件后要发送的数据。 此参数可以为 <see langword="null" />。</param>
        <param name="flags"><see cref="T:System.Net.Sockets.TransmitFileOptions" /> 值的按位组合。</param>
        <param name="callback">一个 <see cref="T:System.AsyncCallback" /> 委托，将在此操作完成时调用它。 此参数可以为 <see langword="null" />。</param>
        <param name="state">一个用户定义的对象，它包含此请求的状态信息。 此参数可以为 <see langword="null" />。</param>
        <summary>将文件和数据缓冲区异步发送到连接的 <see cref="T:System.Net.Sockets.Socket" /> 对象。</summary>
        <returns>一个 <see cref="T:System.IAsyncResult" /> 对象，它表示异步操作。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此重载要求要发送的文件的名称和 <xref:System.Net.Sockets.TransmitFileOptions> 值的按位组合。 `preBuffer` 参数包含要置于该文件之前的所有数据。 `postBuffer` 包含要跟踪文件的数据。 如果 `fileName` 位于本地目录中，则只能用该文件的名称进行标识;否则，必须指定文件的完整路径和名称。 通配符（".。。支持\\\myfile.txt "）和 UNC 共享名称（"\\\\\\\shared 目录\\\myfile.txt "）。 如果找不到该文件，则将引发异常 <xref:System.IO.FileNotFoundException>。  
  
 `flags` 参数为窗口套接字服务提供程序提供有关文件传输的其他信息。 有关如何使用此参数的详细信息，请参阅 <xref:System.Net.Sockets.TransmitFileOptions>。  
  
 此方法使用在 Windows Socket 2 API 中找到的 `TransmitFile` 函数。 有关 `TransmitFile` 函数及其标志的详细信息，请参阅[Windows 套接字](/windows/desktop/WinSock/)文档。  
  
 <xref:System.Net.Sockets.Socket.BeginSendFile%2A> 方法开始异步发送操作到在 <xref:System.Net.Sockets.Socket.Connect%2A>、<xref:System.Net.Sockets.Socket.BeginConnect%2A>、<xref:System.Net.Sockets.Socket.Accept%2A>或 <xref:System.Net.Sockets.Socket.BeginAccept%2A> 方法中建立的远程主机。 如果不首先调用 <xref:System.Net.Sockets.Socket.Accept%2A>、<xref:System.Net.Sockets.Socket.BeginAccept%2A>、<xref:System.Net.Sockets.Socket.Connect%2A>或 <xref:System.Net.Sockets.Socket.BeginConnect%2A>，<xref:System.Net.Sockets.Socket.BeginSendFile%2A> 会引发异常。 调用 <xref:System.Net.Sockets.Socket.BeginSendFile%2A> 方法使你能够在单独的执行线程中发送文件。  
  
 若要完成此操作，可以创建一个由 <xref:System.AsyncCallback> 委托参数调用的回调方法。 为此，至少 `state` 参数必须包含用于通信的 <xref:System.Net.Sockets.Socket> 对象。 如果回调需要更多的信息，可以创建一个类或结构来保存 <xref:System.Net.Sockets.Socket> 和其他所需的信息。 通过 `state` 参数向 <xref:System.Net.Sockets.Socket.BeginSendFile%2A> 方法传递此自定义对象的实例。  
  
 回调方法必须调用 <xref:System.Net.Sockets.Socket.EndSendFile%2A> 方法。 当应用程序调用 <xref:System.Net.Sockets.Socket.BeginSendFile%2A>时，系统将使用一个单独的线程来执行指定的回调方法，并在 <xref:System.Net.Sockets.Socket.EndSendFile%2A> 上阻止，直到 <xref:System.Net.Sockets.Socket> 发送整个文件或引发异常。 有关编写回调方法的其他信息，请参阅将[委托作为回调方法进行封送处理](/dotnet/framework/interop/marshaling-a-delegate-as-a-callback-method)。  
  
 尽管适用于面向连接的协议，但 <xref:System.Net.Sockets.Socket.BeginSendFile%2A> 也适用于无连接协议，前提是你首先调用 <xref:System.Net.Sockets.Socket.Connect%2A> 或 <xref:System.Net.Sockets.Socket.BeginConnect%2A> 方法来建立默认远程主机。 在无连接协议的情况下，你还必须确保文件大小不超过基础服务提供程序的最大数据包大小。 如果是这样，则不发送数据报并且 <xref:System.Net.Sockets.Socket.BeginSendFile%2A> 引发 <xref:System.Net.Sockets.SocketException> 异常。  
  
> [!NOTE]
>  如果收到 <xref:System.Net.Sockets.SocketException> 异常，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。 获取此代码后，请参阅[Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2)文档，以获取有关错误的详细说明。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[.NET Framework 中的网络跟踪](/dotnet/framework/network-programming/network-tracing)。  
  
> [!NOTE]
>  对异步 <xref:System.Net.Sockets.Socket> 方法缓存执行上下文（安全上下文、模拟用户和调用上下文）。 第一次使用特定上下文（特定的异步 <xref:System.Net.Sockets.Socket> 方法、特定的 <xref:System.Net.Sockets.Socket> 实例和特定回调）后，该上下文的后续使用将会提高性能。  
  
   
  
## Examples  
 下面的代码示例创建并连接套接字用于异步通信，并开始将文件 "test.txt" 异步发送到远程主机。 在此示例中，将创建一个与文件一起发送的 `preBuffer` 和 `postBuffer` 的数据，并使用默认的 <xref:System.Net.Sockets.TransmitFileOptions> 值。 回调委托调用 <xref:System.Net.Sockets.Socket.EndSendFile%2A> 来完成传输。  
  
 [!code-cpp[NCLSocketEnhancements#10](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#10)]
 [!code-csharp[NCLSocketEnhancements#10](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 对象已关闭。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。 请参见下面的备注部分。</exception>
        <exception cref="T:System.NotSupportedException">操作系统不是 Windows NT 或更高版本。  
  
-或-
  
 套接字未连接到远程主机。</exception>
        <exception cref="T:System.IO.FileNotFoundException">未找到文件 <paramref name="fileName" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginSendTo">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSendTo (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, System.Net.EndPoint remoteEP, AsyncCallback callback, object state);" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSendTo(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint remoteEP, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginSendTo (buffer As Byte(), offset As Integer, size As Integer, socketFlags As SocketFlags, remoteEP As EndPoint, callback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSendTo(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ remoteEP, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.BeginSendTo : byte[] * int * int * System.Net.Sockets.SocketFlags * System.Net.EndPoint * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginSendTo (buffer, offset, size, socketFlags, remoteEP, callback, state)" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSendTo (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socket_flags, System.Net.EndPoint remote_end, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSendTo(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socket_flags, class System.Net.EndPoint remote_end, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginSendTo (buffer As Byte(), offset As Integer, size As Integer, socket_flags As SocketFlags, remote_end As EndPoint, callback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSendTo(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socket_flags, System::Net::EndPoint ^ remote_end, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.BeginSendTo : byte[] * int * int * System.Net.Sockets.SocketFlags * System.Net.EndPoint * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginSendTo (buffer, offset, size, socket_flags, remote_end, callback, state)" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="socket_flags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" Index="4" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="remote_end" Type="System.Net.EndPoint" Index="4" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="state" Type="System.Object" Index="6" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="buffer"><see cref="T:System.Byte" /> 类型的数组，它包含要发送的数据。</param>
        <param name="offset"><paramref name="buffer" /> 中的从其开始发送数据的、从零开始编排的位置。</param>
        <param name="size">要发送的字节数。</param>
        <param name="socketFlags"><see cref="T:System.Net.Sockets.SocketFlags" /> 值的按位组合。</param>
        <param name="socket_flags"><see cref="T:System.Net.Sockets.SocketFlags" /> 值的按位组合。</param>
        <param name="remoteEP">表示远程设备的 <see cref="T:System.Net.EndPoint" />。</param>
        <param name="remote_end">表示远程设备的 <see cref="T:System.Net.EndPoint" />。</param>
        <param name="callback"><see cref="T:System.AsyncCallback" /> 委托。</param>
        <param name="state">包含此请求的状态信息的对象。</param>
        <summary>以异步方式将数据发送到特定远程主机。</summary>
        <returns>引用异步发送的 <see cref="T:System.IAsyncResult" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.BeginSendTo%2A> 方法对 `remoteEP` 参数中指定的远程主机启动异步发送操作。 调用 <xref:System.Net.Sockets.Socket.BeginSendTo%2A> 方法使你能够在单独的执行线程中发送数据。 尽管适用于无连接协议，但 <xref:System.Net.Sockets.Socket.BeginSendTo%2A> 适用于连接和面向连接的协议。  
  
 你可以创建一个实现 <xref:System.AsyncCallback> 委托的回调方法，并将其名称传递到 <xref:System.Net.Sockets.Socket.BeginSendTo%2A> 方法。 为此，你的 `state` 参数至少必须包含用于通信的已连接或默认 <xref:System.Net.Sockets.Socket>。 如果回调需要更多的信息，可以创建一个小类来保存 <xref:System.Net.Sockets.Socket>，并创建其他必需的信息。 通过 `state` 参数将此类的实例传递给 <xref:System.Net.Sockets.Socket.BeginSendTo%2A> 方法。  
  
 回调方法应调用 <xref:System.Net.Sockets.Socket.EndSendTo%2A> 方法。 当应用程序调用 <xref:System.Net.Sockets.Socket.BeginSendTo%2A>时，系统将使用一个单独的线程来执行指定的回调方法，并将在 <xref:System.Net.Sockets.Socket.EndSendTo%2A> 上阻塞，直到 <xref:System.Net.Sockets.Socket> 发送请求的字节数或引发异常。 如果希望在调用 <xref:System.Net.Sockets.Socket.BeginSendTo%2A> 方法后原始线程被阻止，请使用 <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType> 方法。 如果希望原始线程继续执行，请在回调方法中的 T:System.Threading.ManualResetEvent 上调用 Set 方法。 有关编写回调方法的其他信息，请参阅将[委托作为回调方法进行封送处理](/dotnet/framework/interop/marshaling-a-delegate-as-a-callback-method)。  
  
 如果使用面向连接的协议，则必须先调用 <xref:System.Net.Sockets.Socket.Connect%2A>、<xref:System.Net.Sockets.Socket.BeginConnect%2A>、<xref:System.Net.Sockets.Socket.Accept%2A>或 <xref:System.Net.Sockets.Socket.BeginAccept%2A> 方法，否则 <xref:System.Net.Sockets.Socket.BeginSendTo%2A> 将引发 <xref:System.Net.Sockets.SocketException>。 <xref:System.Net.Sockets.Socket.BeginSendTo%2A> 将忽略 `remoteEP` 参数，并将数据发送到 <xref:System.Net.Sockets.Socket.Connect%2A>、<xref:System.Net.Sockets.Socket.BeginConnect%2A>、<xref:System.Net.Sockets.Socket.Accept%2A>或 <xref:System.Net.Sockets.Socket.BeginAccept%2A> 方法中建立的 <xref:System.Net.EndPoint>。  
  
 如果使用的是无连接协议，则在调用 <xref:System.Net.Sockets.Socket.SendTo%2A>之前，无需使用 <xref:System.Net.Sockets.Socket.Connect%2A> 或 <xref:System.Net.Sockets.Socket.BeginConnect%2A> 方法建立默认远程主机。 如果要调用 <xref:System.Net.Sockets.Socket.BeginSend%2A> 方法，只需执行此操作。 如果在调用 <xref:System.Net.Sockets.Socket.SendTo%2A>之前调用了 <xref:System.Net.Sockets.Socket.Connect%2A> 或 <xref:System.Net.Sockets.Socket.BeginConnect%2A> 方法，则 `remoteEP` 参数只会重写该发送操作的指定默认远程主机。 您也不需要调用 <xref:System.Net.Sockets.Socket.Bind%2A> 方法。 在这种情况下，基础服务提供程序将分配最适当的本地网络地址和端口号。 如果希望基础服务提供商选择可用端口，请使用端口号零。 如果需要确定分配的本地网络地址和端口号，可以在 <xref:System.Net.Sockets.Socket.EndSendTo%2A> 方法成功完成后使用 <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> 属性。  
  
 如果要将数据发送到广播地址，则必须先调用 <xref:System.Net.Sockets.Socket.SetSocketOption%2A> 方法，并将套接字选项设置为 <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>。 -还必须确保缓冲区的大小不超过基础服务提供程序的最大数据包大小。 如果是这样，则将不发送数据报并且 <xref:System.Net.Sockets.Socket.EndSendTo%2A> 将引发 <xref:System.Net.Sockets.SocketException>。  
  
 如果指定 <xref:System.Net.Sockets.SocketFlags.DontRoute> 标志作为 `socketflags` 参数，则将不路由要发送的数据。  
  
> [!NOTE]
>  如果收到 <xref:System.Net.Sockets.SocketException>，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。 获取此代码后，请参阅[Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2)文档，以获取有关错误的详细说明。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[.NET Framework 中的网络跟踪](/dotnet/framework/network-programming/network-tracing)。  
  
> [!NOTE]
>  对异步 <xref:System.Net.Sockets.Socket> 方法缓存执行上下文（安全上下文、模拟用户和调用上下文）。 第一次使用特定上下文（特定的异步 <xref:System.Net.Sockets.Socket> 方法、特定的 <xref:System.Net.Sockets.Socket> 实例和特定回调）后，该上下文的后续使用将会提高性能。  
  
   
  
## Examples  
 下面的代码示例将数据异步发送到指定的远程主机。  
  
 [!code-cpp[Socket_Async_Send_Receive#3](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#3)]
 [!code-csharp[Socket_Async_Send_Receive#3](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#3)]
 [!code-vb[Socket_Async_Send_Receive#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> 为 <see langword="null" />。  
  
-或- 
 <paramref name="remoteEP" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" /> 小于 0。  
  
-或- 
 <paramref name="offset" /> 大于 <paramref name="buffer" /> 的长度。  
  
-或- 
 <paramref name="size" /> 小于 0。  
  
-或- 
 <paramref name="size" /> 大于 <paramref name="buffer" /> 的长度减去 <paramref name="offset" /> 参数的值。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <exception cref="T:System.Security.SecurityException">调用堆栈中的较高调用方无权执行所请求的操作。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="P:System.Net.Sockets.Socket.LocalEndPoint" />
        <altmember cref="F:System.Net.Sockets.SocketOptionName.Broadcast" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <related type="Article" href="/dotnet/framework/interop/marshaling-a-delegate-as-a-callback-method">将委托作为回调方法进行封送</related>
      </Docs>
    </Member>
    <Member MemberName="Bind">
      <MemberSignature Language="C#" Value="public void Bind (System.Net.EndPoint localEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Bind(class System.Net.EndPoint localEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Bind (localEP As EndPoint)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Bind(System::Net::EndPoint ^ localEP);" />
      <MemberSignature Language="F#" Value="member this.Bind : System.Net.EndPoint -&gt; unit" Usage="socket.Bind localEP" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localEP" Type="System.Net.EndPoint" />
      </Parameters>
      <Docs>
        <param name="localEP">要与 <see cref="T:System.Net.EndPoint" /> 关联的本地 <see cref="T:System.Net.Sockets.Socket" />。</param>
        <summary>使 <see cref="T:System.Net.Sockets.Socket" /> 与一个本地终结点相关联。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果需要使用特定的本地终结点，请使用 <xref:System.Net.Sockets.Socket.Bind%2A> 方法。 必须先调用 <xref:System.Net.Sockets.Socket.Bind%2A>，然后才能调用 <xref:System.Net.Sockets.Socket.Listen%2A> 方法。 除非需要使用特定的本地终结点，否则在使用 <xref:System.Net.Sockets.Socket.Connect%2A> 方法之前无需调用 <xref:System.Net.Sockets.Socket.Bind%2A>。 可以在无连接和面向连接的协议上使用 <xref:System.Net.Sockets.Socket.Bind%2A> 方法。  
  
 在调用 <xref:System.Net.Sockets.Socket.Bind%2A>之前，必须先创建要用于与数据通信的本地 <xref:System.Net.IPEndPoint>。 如果你不关心分配了哪个本地地址，则可以使用 <xref:System.Net.IPAddress.Any?displayProperty=nameWithType> 作为 address 参数创建 <xref:System.Net.IPEndPoint>，基础服务提供程序将分配最适当的网络地址。 如果你有多个网络接口，这可能有助于简化你的应用程序。 如果你不介意使用哪个本地端口，则可以使用0作为端口号来创建 <xref:System.Net.IPEndPoint>。 在这种情况下，服务提供商将分配介于1024和5000之间的可用端口号。  
  
 如果使用以上方法，则可以通过调用 <xref:System.Net.Sockets.Socket.LocalEndPoint%2A>来发现分配的本地网络地址和端口号。 如果你使用的是面向连接的协议，则在调用 <xref:System.Net.Sockets.Socket.Connect%2A> 或 <xref:System.Net.Sockets.Socket.EndConnect%2A> 方法之前，<xref:System.Net.Sockets.Socket.LocalEndPoint%2A> 不会返回本地分配的网络地址。 如果使用的是无连接协议，则在完成发送或接收之前，将无法访问此信息。  
  
 如果 UDP 套接字希望接收有关接收到的数据包的接口信息，应在调用 <xref:System.Net.Sockets.Socket.Bind%2A> 方法之后，使用套接字选项显式调用 <xref:System.Net.Sockets.Socket.SetSocketOption%2A> 方法 <xref:System.Net.Sockets.SocketOptionName.PacketInformation>。  
  
> [!NOTE]
>  如果打算接收多播数据报，则必须使用多播端口号调用 <xref:System.Net.Sockets.Socket.Bind%2A> 方法。  
  
> [!NOTE]
>  如果打算使用 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 方法接收无连接的数据报，则必须调用 <xref:System.Net.Sockets.Socket.Bind%2A> 方法。  
  
> [!NOTE]
>  如果在调用 <xref:System.Net.Sockets.Socket.Bind%2A> 方法时接收到 <xref:System.Net.Sockets.SocketException>，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性来获取特定的错误代码。 获取此代码后，请参阅[Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2)文档，以获取有关错误的详细说明。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[.NET Framework 中的网络跟踪](/dotnet/framework/network-programming/network-tracing)。  
  
   
  
## Examples  
 下面的代码示例使用指定的本地终结点绑定 <xref:System.Net.Sockets.Socket>。  
  
 [!code-cpp[Classic Socket.Bind Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Bind Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Bind Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Bind Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Bind Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Bind Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="localEP" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <exception cref="T:System.Security.SecurityException">调用堆栈中的较高调用方无权执行所请求的操作。</exception>
        <altmember cref="T:System.Net.IPEndPoint" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />
        <altmember cref="T:System.Net.IPAddress" />
        <altmember cref="P:System.Net.Sockets.Socket.LocalEndPoint" />
      </Docs>
    </Member>
    <Member MemberName="Blocking">
      <MemberSignature Language="C#" Value="public bool Blocking { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Blocking" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.Blocking" />
      <MemberSignature Language="VB.NET" Value="Public Property Blocking As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Blocking { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Blocking : bool with get, set" Usage="System.Net.Sockets.Socket.Blocking" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指示 <see cref="T:System.Net.Sockets.Socket" /> 是否处于阻止模式。</summary>
        <value>如果 <see cref="T:System.Net.Sockets.Socket" /> 将阻止，则为 <see langword="true" />；否则为 <see langword="false" />。 默认为 <see langword="true" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Blocking%2A> 属性指示 <xref:System.Net.Sockets.Socket> 是否处于阻止模式。  
  
 如果你处于阻止模式，并且你进行了一个不会立即完成的方法调用，则应用程序将在请求的操作完成前阻止执行。 如果希望在请求的操作未完成的情况下继续执行，请将 <xref:System.Net.Sockets.Socket.Blocking%2A> 属性更改为 `false`。 <xref:System.Net.Sockets.Socket.Blocking%2A> 属性对异步方法不起作用。 如果要异步发送和接收数据，并想要阻止执行，请使用 <xref:System.Threading.ManualResetEvent> 类。  
  
> [!NOTE]
>  如果收到 <xref:System.Net.Sockets.SocketException>，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。 获取此代码后，请参阅[Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2)文档，以获取有关错误的详细说明。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[.NET Framework 中的网络跟踪](/dotnet/framework/network-programming/network-tracing)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
      </Docs>
    </Member>
    <Member MemberName="CancelConnectAsync">
      <MemberSignature Language="C#" Value="public static void CancelConnectAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CancelConnectAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.CancelConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub CancelConnectAsync (e As SocketAsyncEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CancelConnectAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="static member CancelConnectAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; unit" Usage="System.Net.Sockets.Socket.CancelConnectAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> 对象，该对象用于通过调用 <see cref="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)" /> 方法之一，请求与远程主机的连接。</param>
        <summary>取消一个对远程主机连接的异步请求。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.CancelConnectAsync%2A> 方法取消对远程主机连接的异步请求。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="e" /> 参数不能为 null，并且 <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> 不能为空。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <exception cref="T:System.Security.SecurityException">调用堆栈中的较高调用方无权执行所请求的操作。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Close">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>关闭 <see cref="T:System.Net.Sockets.Socket" /> 连接并释放所有关联的资源。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberSignature Language="F#" Value="member this.Close : unit -&gt; unit" Usage="socket.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>关闭 <see cref="T:System.Net.Sockets.Socket" /> 连接并释放所有关联的资源。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Close%2A> 方法会关闭远程主机连接，并释放与 <xref:System.Net.Sockets.Socket>关联的所有托管资源和非托管资源。 关闭时，<xref:System.Net.Sockets.Socket.Connected%2A> 属性设置为 `false`。  
  
 对于面向连接的协议，建议你在调用 <xref:System.Net.Sockets.Socket.Close%2A> 方法之前调用 <xref:System.Net.Sockets.Socket.Shutdown%2A>。 这可确保所有数据在连接的套接字关闭之前都已发送和接收。  
  
 如果需要在不首先调用 <xref:System.Net.Sockets.Socket.Shutdown%2A>的情况下调用 <xref:System.Net.Sockets.Socket.Close%2A>，则可以通过将 <xref:System.Net.Sockets.SocketOptionName.DontLinger><xref:System.Net.Sockets.Socket> 选项设置为 `false` 并指定非零超时间隔来确保将排队等待传出传输的数据发送。 然后，<xref:System.Net.Sockets.Socket.Close%2A> 将被阻止，直到发送此数据或指定的超时过期。 如果将 <xref:System.Net.Sockets.SocketOptionName.DontLinger> 设置为 `false` 并指定零超时间隔，<xref:System.Net.Sockets.Socket.Close%2A> 会释放连接并自动丢弃传出的排队数据。  
  
> [!NOTE]
>  若要将 <xref:System.Net.Sockets.SocketOptionName.DontLinger> 套接字选项设置为 `false`，请创建 <xref:System.Net.Sockets.LingerOption>，将 "enabled" 属性设置为 `true`，并将 "<xref:System.Net.Sockets.LingerOption.LingerTime%2A>" 属性设置为所需的超时时间。 使用此 <xref:System.Net.Sockets.LingerOption> 和 <xref:System.Net.Sockets.SocketOptionName.DontLinger> 套接字选项来调用 <xref:System.Net.Sockets.Socket.SetSocketOption%2A> 方法。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[.NET Framework 中的网络跟踪](/dotnet/framework/network-programming/network-tracing)。  
  
   
  
## Examples  
 下面的代码示例关闭 <xref:System.Net.Sockets.Socket>。  
  
 [!code-cpp[Classic Socket.Close Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Close Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Close Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Close Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Close Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Close Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="F:System.Net.Sockets.SocketOptionName.DontLinger" />
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close (int timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close(int32 timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Close(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close (timeout As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close(int timeout);" />
      <MemberSignature Language="F#" Value="member this.Close : int -&gt; unit" Usage="socket.Close timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="timeout">等待最多 <paramref name="timeout" /> 秒钟后，即可发送任何剩余数据，然后关闭套接字。</param>
        <summary>关闭 <see cref="T:System.Net.Sockets.Socket" /> 连接并释放所有与指定超时关联的资源，以允许要发送的数据排队。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Close%2A> 方法会关闭远程主机连接，并释放与 <xref:System.Net.Sockets.Socket>关联的所有托管资源和非托管资源。 关闭时，<xref:System.Net.Sockets.Socket.Connected%2A> 属性设置为 `false`。  
  
 对于面向连接的协议，建议你在调用 <xref:System.Net.Sockets.Socket.Close%2A>之前调用 <xref:System.Net.Sockets.Socket.Shutdown%2A>。 这可确保所有数据在连接的套接字关闭之前都已发送和接收。  
  
 如果需要在不首先调用 <xref:System.Net.Sockets.Socket.Shutdown%2A>的情况下调用 <xref:System.Net.Sockets.Socket.Close%2A>，则可以通过将 <xref:System.Net.Sockets.SocketOptionName.DontLinger> 选项设置为 `false` 并指定一个非零超时间隔来确保将排队等待传出传输的数据发送。 然后，<xref:System.Net.Sockets.Socket.Close%2A> 将被阻止，直到发送此数据或指定的超时过期。 如果将 <xref:System.Net.Sockets.SocketOptionName.DontLinger> 设置为 `false` 并指定零超时间隔，<xref:System.Net.Sockets.Socket.Close%2A> 会释放连接并自动丢弃传出的排队数据。  
  
> [!NOTE]
>  若要将 <xref:System.Net.Sockets.SocketOptionName.DontLinger> 套接字选项设置为 `false`，请创建 <xref:System.Net.Sockets.LingerOption>，将 "enabled" 属性设置为 `true`，并将 "<xref:System.Net.Sockets.LingerOption.LingerTime%2A>" 属性设置为所需的超时期限。 使用此 <xref:System.Net.Sockets.LingerOption> 和 <xref:System.Net.Sockets.SocketOptionName.DontLinger> 套接字选项来调用 <xref:System.Net.Sockets.Socket.SetSocketOption%2A> 方法。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[.NET Framework 中的网络跟踪](/dotnet/framework/network-programming/network-tracing)。  
  
   
  
## Examples  
 下面的代码示例演示如何关闭 <xref:System.Net.Sockets.Socket>。  
  
 [!code-cpp[Classic Socket.Close Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Close Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Close Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Close Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Close Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Close Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="F:System.Net.Sockets.SocketOptionName.DontLinger" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Connect">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>与远程主机建立连接。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Connect">
      <MemberSignature Language="C#" Value="public void Connect (System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Connect(class System.Net.EndPoint remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Connect (remoteEP As EndPoint)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Connect(System::Net::EndPoint ^ remoteEP);" />
      <MemberSignature Language="F#" Value="member this.Connect : System.Net.EndPoint -&gt; unit" Usage="socket.Connect remoteEP" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="remoteEP">表示远程设备的 <see cref="T:System.Net.EndPoint" />。</param>
        <summary>与远程主机建立连接。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果你使用的是面向连接的协议（例如 TCP），<xref:System.Net.Sockets.Socket.Connect%2A> 方法将同步在 <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> 与指定的远程终结点之间建立网络连接。 如果使用的是无连接协议，<xref:System.Net.Sockets.Socket.Connect%2A> 会建立默认远程主机。 调用 <xref:System.Net.Sockets.Socket.Connect%2A>后，可以通过 <xref:System.Net.Sockets.Socket.Send%2A> 方法将数据发送到远程设备，或通过 <xref:System.Net.Sockets.Socket.Receive%2A> 方法从远程设备接收数据。  
  
 如果使用的是无连接协议（如 UDP），则在发送和接收数据之前无需调用 <xref:System.Net.Sockets.Socket.Connect%2A>。 您可以使用 <xref:System.Net.Sockets.Socket.SendTo%2A> 和 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 与远程主机同步通信。 如果调用 <xref:System.Net.Sockets.Socket.Connect%2A>，则从指定的默认值以外的地址到达的任何数据报都将被丢弃。 如果要将默认远程主机设置为广播地址，则必须先调用 <xref:System.Net.Sockets.Socket.SetSocketOption%2A> 方法，并将 socket 选项设置为 <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>，否则 <xref:System.Net.Sockets.Socket.Connect%2A> 将引发 <xref:System.Net.Sockets.SocketException>。 如果收到 <xref:System.Net.Sockets.SocketException>，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。 获取此代码后，请参阅[Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2)文档，以获取有关错误的详细说明。  
  
 除非在调用 <xref:System.Net.Sockets.Socket.Connect%2A>之前专门将 <xref:System.Net.Sockets.Socket.Blocking%2A> 属性设置为 `false`，否则 <xref:System.Net.Sockets.Socket.Connect%2A> 方法将会阻止。 如果使用面向连接的协议（如 TCP），并禁用阻止，<xref:System.Net.Sockets.Socket.Connect%2A> 将引发 <xref:System.Net.Sockets.SocketException>，因为它需要时间来建立连接。 无连接协议不会引发异常，因为它们只是建立默认远程主机。 您可以使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 获取特定的错误代码。 获取此代码后，请参阅[Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2)文档，以获取有关错误的详细说明。 如果错误返回了 WSAEWOULDBLOCK，则已通过面向连接的 <xref:System.Net.Sockets.Socket>启动了远程主机连接，但尚未成功完成。 使用 <xref:System.Net.Sockets.Socket.Poll%2A> 方法可确定 <xref:System.Net.Sockets.Socket> 连接完成的时间。  
  
> [!NOTE]
>  如果使用面向连接的协议，且在调用 <xref:System.Net.Sockets.Socket.Connect%2A>之前未调用 <xref:System.Net.Sockets.Socket.Bind%2A>，则基础服务提供程序将分配本地网络地址和端口号。 如果使用的是无连接协议，则在完成发送或接收操作之前，服务提供程序将不会分配本地网络地址和端口号。 如果要更改默认远程主机，请再次调用 <xref:System.Net.Sockets.Socket.Connect%2A> 所需的终结点。  
  
> [!NOTE]
>  如果先前已断开套接字连接，则不能使用此方法来还原连接。 使用异步 <xref:System.Net.Sockets.Socket.BeginConnect%2A> 方法之一重新连接。 这是底层提供程序的限制。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[.NET Framework 中的网络跟踪](/dotnet/framework/network-programming/network-tracing)。  
  
   
  
## Examples  
 下面的代码示例连接到远程终结点，并验证连接。  
  
 [!code-cpp[Classic Socket.Connect Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Connect Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Connect Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Connect Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Connect Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Connect Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="remoteEP" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <exception cref="T:System.Security.SecurityException">调用堆栈中的较高调用方无权执行所请求的操作。</exception>
        <exception cref="T:System.InvalidOperationException">已通过调用 <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> 将 <see cref="T:System.Net.Sockets.Socket" /> 置于侦听状态。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.LocalEndPoint" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="P:System.Net.Sockets.Socket.Blocking" />
        <altmember cref="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)" />
      </Docs>
    </Member>
    <Member MemberName="Connect">
      <MemberSignature Language="C#" Value="public void Connect (System.Net.IPAddress address, int port);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Connect(class System.Net.IPAddress address, int32 port) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Connect (address As IPAddress, port As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Connect(System::Net::IPAddress ^ address, int port);" />
      <MemberSignature Language="F#" Value="member this.Connect : System.Net.IPAddress * int -&gt; unit" Usage="socket.Connect (address, port)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Net.IPAddress" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="port" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="address">远程主机的 IP 地址。</param>
        <param name="port">远程主机的端口号。</param>
        <summary>与远程主机建立连接。 主机由 IP 地址和端口号指定。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果你使用的是面向连接的协议（例如 TCP），<xref:System.Net.Sockets.Socket.Connect%2A> 方法将同步在 <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> 与指定的远程终结点之间建立网络连接。 如果使用的是无连接协议，<xref:System.Net.Sockets.Socket.Connect%2A> 会建立默认远程主机。 调用 <xref:System.Net.Sockets.Socket.Connect%2A> 可以通过 <xref:System.Net.Sockets.Socket.Send%2A> 方法将数据发送到远程设备，或通过 <xref:System.Net.Sockets.Socket.Receive%2A> 方法从远程设备接收数据。  
  
 如果使用的是无连接协议（如 UDP），则在发送和接收数据之前无需调用 <xref:System.Net.Sockets.Socket.Connect%2A>。 您可以使用 <xref:System.Net.Sockets.Socket.SendTo%2A> 和 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 与远程主机同步通信。 如果确实调用 <xref:System.Net.Sockets.Socket.Connect%2A> 从指定的默认值以外的地址到达的任何数据报都将被丢弃。 如果要将默认远程主机设置为广播地址，则必须先调用 <xref:System.Net.Sockets.Socket.SetSocketOption%2A> 方法，并将 socket 选项设置为 <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>，否则 <xref:System.Net.Sockets.Socket.Connect%2A> 将引发 <xref:System.Net.Sockets.SocketException>。 如果收到 <xref:System.Net.Sockets.SocketException>，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。 获取此代码后，请参阅[Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2)文档，以获取有关错误的详细说明。  
  
 <xref:System.Net.Sockets.Socket.Connect%2A> 方法将会阻止，除非在调用 <xref:System.Net.Sockets.Socket.Connect%2A>之前专门将 <xref:System.Net.Sockets.Socket.Blocking%2A> 属性设置为 `false`。 如果使用面向连接的协议（如 TCP），并禁用阻止，<xref:System.Net.Sockets.Socket.Connect%2A> 将引发 <xref:System.Net.Sockets.SocketException>，因为它需要时间来建立连接。 无连接协议不会引发异常，因为它们只是建立默认远程主机。 您可以使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 获取特定的错误代码。 获取此代码后，请参阅[Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2)文档，以获取有关错误的详细说明。 如果错误返回了 WSAEWOULDBLOCK，则已通过面向连接的 <xref:System.Net.Sockets.Socket>启动了远程主机连接，但尚未成功完成。 使用 <xref:System.Net.Sockets.Socket.Poll%2A> 方法可确定 <xref:System.Net.Sockets.Socket> 连接完成的时间。  
  
> [!NOTE]
>  如果使用面向连接的协议，且在调用 <xref:System.Net.Sockets.Socket.Connect%2A>之前未调用 <xref:System.Net.Sockets.Socket.Bind%2A>，则基础服务提供程序将分配本地网络地址和端口号。 如果使用的是无连接协议，则在完成发送或接收操作之前，服务提供程序将不会分配本地网络地址和端口号。 如果要更改默认远程主机，请再次调用 <xref:System.Net.Sockets.Socket.Connect%2A> 所需的终结点。  
  
> [!NOTE]
>  如果先前已断开套接字连接，则不能使用此方法来还原连接。 使用异步 <xref:System.Net.Sockets.Socket.BeginConnect%2A> 方法之一重新连接。 这是底层提供程序的限制。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[.NET Framework 中的网络跟踪](/dotnet/framework/network-programming/network-tracing)。  
  
   
  
## Examples  
 下面的代码示例连接到远程终结点，并验证连接。  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#4](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#4)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#4](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="address" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">端口号无效。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <exception cref="T:System.NotSupportedException">此方法对 <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> 或 <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> 系列中的套接字有效。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="address" /> 的长度为零。</exception>
        <exception cref="T:System.InvalidOperationException">已通过调用 <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> 将 <see cref="T:System.Net.Sockets.Socket" /> 置于侦听状态。</exception>
      </Docs>
    </Member>
    <Member MemberName="Connect">
      <MemberSignature Language="C#" Value="public void Connect (System.Net.IPAddress[] addresses, int port);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Connect(class System.Net.IPAddress[] addresses, int32 port) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Connect (addresses As IPAddress(), port As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Connect(cli::array &lt;System::Net::IPAddress ^&gt; ^ addresses, int port);" />
      <MemberSignature Language="F#" Value="member this.Connect : System.Net.IPAddress[] * int -&gt; unit" Usage="socket.Connect (addresses, port)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="addresses" Type="System.Net.IPAddress[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="port" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="addresses">远程主机的 IP 地址。</param>
        <param name="port">远程主机的端口号。</param>
        <summary>与远程主机建立连接。 主机由 IP 地址数组和端口号指定。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法通常在调用 <xref:System.Net.Dns.GetHostAddresses%2A>后立即使用，这可能会为单个主机返回多个 IP 地址。 如果你使用的是面向连接的协议（例如 TCP），<xref:System.Net.Sockets.Socket.Connect%2A> 方法将同步在 <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> 与指定的远程终结点之间建立网络连接。 如果使用的是无连接协议，<xref:System.Net.Sockets.Socket.Connect%2A> 会建立默认远程主机。 调用 <xref:System.Net.Sockets.Socket.Connect%2A> 可以通过 <xref:System.Net.Sockets.Socket.Send%2A> 方法将数据发送到远程设备，或通过 <xref:System.Net.Sockets.Socket.Receive%2A> 方法从远程设备接收数据。  
  
 如果使用的是无连接协议（如 UDP），则在发送和接收数据之前无需调用 <xref:System.Net.Sockets.Socket.Connect%2A>。 您可以使用 <xref:System.Net.Sockets.Socket.SendTo%2A> 和 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 与远程主机同步通信。 如果确实调用 <xref:System.Net.Sockets.Socket.Connect%2A> 从指定的默认值以外的地址到达的任何数据报都将被丢弃。 如果要将默认远程主机设置为广播地址，则必须先调用 <xref:System.Net.Sockets.Socket.SetSocketOption%2A> 方法，并将 socket 选项设置为 <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>，否则 <xref:System.Net.Sockets.Socket.Connect%2A> 将引发 <xref:System.Net.Sockets.SocketException>。 如果收到 <xref:System.Net.Sockets.SocketException>，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。 获取此代码后，请参阅[Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2)文档，以获取有关错误的详细说明。  
  
 <xref:System.Net.Sockets.Socket.Connect%2A> 方法将会阻止，除非在调用 <xref:System.Net.Sockets.Socket.Connect%2A>之前专门将 <xref:System.Net.Sockets.Socket.Blocking%2A> 属性设置为 `false`。 如果使用面向连接的协议（如 TCP），并禁用阻止，<xref:System.Net.Sockets.Socket.Connect%2A> 将引发 <xref:System.Net.Sockets.SocketException>，因为它需要时间来建立连接。 无连接协议不会引发异常，因为它们只是建立默认远程主机。 您可以使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 获取特定的错误代码。 获取此代码后，请参阅[Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2)文档，以获取有关错误的详细说明。 如果错误返回了 WSAEWOULDBLOCK，则已通过面向连接的 <xref:System.Net.Sockets.Socket>启动了远程主机连接，但尚未成功完成。 使用 <xref:System.Net.Sockets.Socket.Poll%2A> 方法可确定 <xref:System.Net.Sockets.Socket> 连接完成的时间。  
  
> [!NOTE]
>  如果使用面向连接的协议，且在调用 <xref:System.Net.Sockets.Socket.Connect%2A>之前未调用 <xref:System.Net.Sockets.Socket.Bind%2A>，则基础服务提供程序将分配本地网络地址和端口号。 如果使用的是无连接协议，则在完成发送或接收操作之前，服务提供程序将不会分配本地网络地址和端口号。 如果要更改默认远程主机，请再次调用 <xref:System.Net.Sockets.Socket.Connect%2A> 所需的终结点。  
  
> [!NOTE]
>  如果先前已断开套接字连接，则不能使用此方法来还原连接。 使用异步 <xref:System.Net.Sockets.Socket.BeginConnect%2A> 方法之一重新连接。 这是底层提供程序的限制。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[.NET Framework 中的网络跟踪](/dotnet/framework/network-programming/network-tracing)。  
  
   
  
## Examples  
 下面的代码示例连接到远程终结点，并验证连接。  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#5](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#5)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#5](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="addresses" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">端口号无效。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <exception cref="T:System.NotSupportedException">此方法对 <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> 或 <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> 系列中的套接字有效。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="address" /> 的长度为零。</exception>
        <exception cref="T:System.InvalidOperationException">已通过调用 <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> 将 <see cref="T:System.Net.Sockets.Socket" /> 置于侦听状态。</exception>
      </Docs>
    </Member>
    <Member MemberName="Connect">
      <MemberSignature Language="C#" Value="public void Connect (string host, int port);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Connect(string host, int32 port) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Connect(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Connect (host As String, port As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Connect(System::String ^ host, int port);" />
      <MemberSignature Language="F#" Value="member this.Connect : string * int -&gt; unit" Usage="socket.Connect (host, port)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="host" Type="System.String" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="port" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="host">远程主机的名称。</param>
        <param name="port">远程主机的端口号。</param>
        <summary>与远程主机建立连接。 主机由主机名和端口号指定。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果使用面向连接的协议（例如 TCP），则 <xref:System.Net.Sockets.Socket.Connect%2A> 方法会在 <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> 与指定的远程主机之间同步建立网络连接。 如果使用的是无连接协议，<xref:System.Net.Sockets.Socket.Connect%2A> 会建立默认远程主机。 调用 <xref:System.Net.Sockets.Socket.Connect%2A> 可以通过 <xref:System.Net.Sockets.Socket.Send%2A> 方法将数据发送到远程设备，或通过 <xref:System.Net.Sockets.Socket.Receive%2A> 方法从远程设备接收数据。  
  
 如果使用的是无连接协议（如 UDP），则在发送和接收数据之前无需调用 <xref:System.Net.Sockets.Socket.Connect%2A>。 您可以使用 <xref:System.Net.Sockets.Socket.SendTo%2A> 和 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 与远程主机同步通信。 如果确实调用 <xref:System.Net.Sockets.Socket.Connect%2A> 从指定的默认值以外的地址到达的任何数据报都将被丢弃。 如果要将默认远程主机设置为广播地址，则必须先调用 <xref:System.Net.Sockets.Socket.SetSocketOption%2A> 方法，并将 socket 选项设置为 <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>，否则 <xref:System.Net.Sockets.Socket.Connect%2A> 将引发 <xref:System.Net.Sockets.SocketException>。 如果收到 <xref:System.Net.Sockets.SocketException>，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。 获取此代码后，请参阅[Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2)文档，以获取有关错误的详细说明。  
  
 <xref:System.Net.Sockets.Socket.Connect%2A> 方法将会阻止，除非在调用 <xref:System.Net.Sockets.Socket.Connect%2A>之前专门将 <xref:System.Net.Sockets.Socket.Blocking%2A> 属性设置为 `false`。 如果使用面向连接的协议（如 TCP），并禁用阻止，<xref:System.Net.Sockets.Socket.Connect%2A> 将引发 <xref:System.Net.Sockets.SocketException>，因为它需要时间来建立连接。 无连接协议不会引发异常，因为它们只是建立默认远程主机。 您可以使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 获取特定的错误代码。 获取此代码后，请参阅[Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2)文档，以获取有关错误的详细说明。 如果错误返回了 WSAEWOULDBLOCK，则已通过面向连接的 <xref:System.Net.Sockets.Socket>启动了远程主机连接，但尚未成功完成。 使用 <xref:System.Net.Sockets.Socket.Poll%2A> 方法可确定 <xref:System.Net.Sockets.Socket> 连接完成的时间。  
  
 如果启用了 IPv6，并且调用 <xref:System.Net.Sockets.Socket.Connect%28System.String%2CSystem.Int32%29> 方法连接到解析 IPv6 和 IPv4 地址的主机，则在 IPv4 地址之前将首先尝试连接到 IPv6 地址。 如果主机未侦听 IPv6 地址，则这可能会延迟建立连接的时间。  
  
> [!NOTE]
>  如果使用面向连接的协议，且在调用 <xref:System.Net.Sockets.Socket.Connect%2A>之前未调用 <xref:System.Net.Sockets.Socket.Bind%2A>，则基础服务提供程序将分配本地网络地址和端口号。 如果使用的是无连接协议，则在完成发送或接收操作之前，服务提供程序将不会分配本地网络地址和端口号。 如果要更改默认远程主机，请再次调用 <xref:System.Net.Sockets.Socket.Connect%2A> 所需的终结点。  
  
> [!NOTE]
>  如果先前已断开套接字连接，则不能使用此方法来还原连接。 使用异步 <xref:System.Net.Sockets.Socket.BeginConnect%2A> 方法之一重新连接。 这是底层提供程序的限制。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[.NET Framework 中的网络跟踪](/dotnet/framework/network-programming/network-tracing)。  
  
   
  
## Examples  
 下面的代码示例连接到远程终结点，并验证连接。  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#6](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#6)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#6](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="host" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">端口号无效。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <exception cref="T:System.NotSupportedException">此方法对 <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> 或 <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> 系列中的套接字有效。</exception>
        <exception cref="T:System.InvalidOperationException">已通过调用 <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> 将 <see cref="T:System.Net.Sockets.Socket" /> 置于侦听状态。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ConnectAsync">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>开始一个对远程主机连接的异步请求。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ConnectAsync">
      <MemberSignature Language="C#" Value="public bool ConnectAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ConnectAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function ConnectAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ConnectAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.ConnectAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="socket.ConnectAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="e">要用于此异步套接字操作的 <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> 对象。</param>
        <summary>开始一个对远程主机连接的异步请求。</summary>
        <returns>如果 I/O 操作挂起，则为 <see langword="true" />。 操作完成时，将引发 <paramref name="e" /> 参数的 <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> 事件。  
  
 如果 I/O 操作同步完成，则为 <see langword="false" />。 在这种情况下，将不会引发 <paramref name="e" /> 参数的 <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> 事件，并且可能在方法调用返回后立即检查作为参数传递的 <paramref name="e" /> 对象以检索操作的结果。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果使用面向连接的协议，则 <xref:System.Net.Sockets.Socket.ConnectAsync%2A> 方法会启动到远程主机的连接的异步请求。 如果使用的是无连接协议，<xref:System.Net.Sockets.Socket.ConnectAsync%2A> 会建立默认远程主机。  
  
 若要在完成时收到通知，您必须创建一个回调方法，用于实现 EventHandler\<SocketAsyncEventArgs > 委托并将回调附加到 <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType> 事件。  
  
 调用方必须将 <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> 属性设置为要连接到的远程主机的 <xref:System.Net.IPEndPoint>。  
  
 调用方可以在调用 <xref:System.Net.Sockets.Socket.ConnectAsync%2A> 方法之前将 <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> 属性设置为所需的任何用户状态对象，以便可以在回调方法中检索信息。 如果回调需要比单个对象更多的信息，则可以创建一个小类，以将其他所需的状态信息保存为成员。  
  
 如果使用的是无连接协议（如 UDP），则在发送和接收数据之前无需调用 <xref:System.Net.Sockets.Socket.ConnectAsync%2A>。 您可以使用 <xref:System.Net.Sockets.Socket.SendToAsync%2A> 和 <xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A> 与远程主机通信。 如果调用 <xref:System.Net.Sockets.Socket.ConnectAsync%2A>，则从指定的默认值以外的地址到达的任何数据报都将被丢弃。 如果要更改默认远程主机，请通过所需的终结点再次调用 <xref:System.Net.Sockets.Socket.ConnectAsync%2A> 方法。  
  
 如果要将默认远程主机设置为广播地址，则必须先调用 <xref:System.Net.Sockets.Socket.SetSocketOption%2A> 并将广播设置为 `true`。 如果未执行此操作，<xref:System.Net.Sockets.Socket.ConnectAsync%2A> 方法将引发 <xref:System.Net.Sockets.SocketException>。  
  
 需要 <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> 对象上的下列属性和事件：  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>  
  
 （可选）可以提供缓冲区，在 <xref:System.Net.Sockets.Socket.ConnectAsync%2A> 方法成功后，将以原子方式将其发送到套接字。 在这种情况下，需要将 <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> 属性设置为包含要发送的数据的缓冲区，并且 <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> 属性需要设置为要从缓冲区发送的数据的字节数。 建立连接后，将发送此数据缓冲区。  
  
 如果使用面向连接的协议，且在调用 <xref:System.Net.Sockets.Socket.ConnectAsync%2A>之前未调用 <xref:System.Net.Sockets.Socket.Bind%2A>，则基础服务提供程序将分配最适当的本地网络地址和端口号。  
  
 如果使用的是无连接协议，则在调用 <xref:System.Net.Sockets.Socket.SendAsync%2A> 或 <xref:System.Net.Sockets.Socket.ReceiveAsync%2A> 方法之前，服务提供程序将不会分配本地网络 IP 地址和端口号。  
  
 如果 <xref:System.Net.Sockets.Socket> 和 <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> 的地址系列不是同一地址族，则 <xref:System.Net.Sockets.Socket.ConnectAsync%2A> 方法会引发 <xref:System.NotSupportedException>。  
  
> [!NOTE]
>  如果在调用此方法时接收到 <xref:System.Net.Sockets.SocketException>，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。 获取此代码后，请参阅[Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2)文档，以获取有关错误的详细说明。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">自变量无效。 如果指定了多个缓冲区，即 <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /> 属性不为 null，将会发生此异常。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="e" /> 参数不能为 null，并且 <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> 不能为空。</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Net.Sockets.Socket" /> 正在侦听或已经在使用 <paramref name="e" /> 参数中指定的 <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> 对象执行套接字操作。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.NotSupportedException">此方法需要 Windows XP 或更高版本。 如果本地终结点和 <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> 不是相同的地址族，也会发生此异常。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <exception cref="T:System.Security.SecurityException">调用堆栈中的较高调用方无权执行所请求的操作。</exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="ConnectAsync">
      <MemberSignature Language="C#" Value="public static bool ConnectAsync (System.Net.Sockets.SocketType socketType, System.Net.Sockets.ProtocolType protocolType, System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool ConnectAsync(valuetype System.Net.Sockets.SocketType socketType, valuetype System.Net.Sockets.ProtocolType protocolType, class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ConnectAsync (socketType As SocketType, protocolType As ProtocolType, e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool ConnectAsync(System::Net::Sockets::SocketType socketType, System::Net::Sockets::ProtocolType protocolType, System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="static member ConnectAsync : System.Net.Sockets.SocketType * System.Net.Sockets.ProtocolType * System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="System.Net.Sockets.Socket.ConnectAsync (socketType, protocolType, e)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="socketType" Type="System.Net.Sockets.SocketType" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="protocolType" Type="System.Net.Sockets.ProtocolType" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" Index="2" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="socketType"><see cref="T:System.Net.Sockets.SocketType" /> 值之一。</param>
        <param name="protocolType"><see cref="T:System.Net.Sockets.ProtocolType" /> 值之一。</param>
        <param name="e">要用于此异步套接字操作的 <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> 对象。</param>
        <summary>开始一个对远程主机连接的异步请求。</summary>
        <returns>如果 I/O 操作挂起，则为 <see langword="true" />。 操作完成时，将引发 <paramref name="e" /> 参数的 <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> 事件。  
  
 如果 I/O 操作同步完成，则为 <see langword="false" />。 在这种情况下，将不会引发 <paramref name="e" /> 参数的 <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> 事件，并且可能在方法调用返回后立即检查作为参数传递的 <paramref name="e" /> 对象以检索操作的结果。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果你使用的是面向连接的协议，则 M:System.Net.Sockets.Socket.ConnectAsync （SocketType，系统 .net. ProtocolType，SocketAsyncEventArgs）方法会启动到远程主机的连接的异步请求。 如果使用的是无连接协议，<xref:System.Net.Sockets.Socket.ConnectAsync%2A> 将建立由 `socketType` 和 `protocolType` 参数指定的默认远程主机。  
  
 若要在完成时收到通知，您必须创建一个回调方法，用于实现 EventHandler\<SocketAsyncEventArgs > 委托并将回调附加到 <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType> 事件。  
  
 调用方必须将 <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> 属性设置为要连接到的远程主机的 <xref:System.Net.IPEndPoint>。  
  
 调用方可以在调用 <xref:System.Net.Sockets.Socket.ConnectAsync%2A> 方法之前将 <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> 属性设置为所需的任何用户状态对象，以便可以在回调方法中检索信息。 如果回调需要比单个对象更多的信息，则可以创建一个小类，以将其他所需的状态信息保存为成员。  
  
 如果使用的是无连接协议（如 UDP），则在发送和接收数据之前无需调用 <xref:System.Net.Sockets.Socket.ConnectAsync%2A>。 您可以使用 <xref:System.Net.Sockets.Socket.SendToAsync%2A> 和 <xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A> 与远程主机通信。 如果调用 <xref:System.Net.Sockets.Socket.ConnectAsync%2A>，则从指定的默认值以外的地址到达的任何数据报都将被丢弃。 如果要更改默认远程主机，请通过所需的终结点再次调用 <xref:System.Net.Sockets.Socket.ConnectAsync%2A> 方法。  
  
 如果要将默认远程主机设置为广播地址，则必须先调用 <xref:System.Net.Sockets.Socket.SetSocketOption%2A> 并将广播设置为 `true`。 如果未执行此操作，<xref:System.Net.Sockets.Socket.ConnectAsync%2A> 方法将引发 <xref:System.Net.Sockets.SocketException>。  
  
 需要 <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> 对象上的下列属性和事件：  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>  
  
 （可选）可以提供缓冲区，在 <xref:System.Net.Sockets.Socket.ConnectAsync%2A> 方法成功后，将以原子方式将其发送到套接字。 在这种情况下，需要将 <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> 属性设置为包含要发送的数据的缓冲区，并且 <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> 属性需要设置为要从缓冲区发送的数据的字节数。 建立连接后，将发送此数据缓冲区。  
  
 如果使用面向连接的协议，且在调用 <xref:System.Net.Sockets.Socket.ConnectAsync%2A>之前未调用 <xref:System.Net.Sockets.Socket.Bind%2A>，则基础服务提供程序将分配最适当的本地网络地址和端口号。  
  
 如果使用的是无连接协议，则在调用 <xref:System.Net.Sockets.Socket.SendAsync%2A> 或 <xref:System.Net.Sockets.Socket.ReceiveAsync%2A> 方法之前，服务提供程序将不会分配本地网络 IP 地址和端口号。  
  
 如果 <xref:System.Net.Sockets.Socket> 和 <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> 的地址系列不是同一地址族，则 <xref:System.Net.Sockets.Socket.ConnectAsync%2A> 方法会引发 <xref:System.NotSupportedException>。  
  
> [!NOTE]
>  如果在调用此方法时接收到 <xref:System.Net.Sockets.SocketException>，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。 获取此代码后，请参阅[Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2)文档，以获取有关错误的详细说明。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">自变量无效。 如果指定了多个缓冲区，即 <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /> 属性不为 null，将会发生此异常。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="e" /> 参数不能为 null，并且 <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> 不能为空。</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Net.Sockets.Socket" /> 正在侦听或已经在使用 <paramref name="e" /> 参数中指定的 <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> 对象执行套接字操作。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.NotSupportedException">此方法需要 Windows XP 或更高版本。 如果本地终结点和 <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> 不是相同的地址族，也会发生此异常。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <exception cref="T:System.Security.SecurityException">调用堆栈中的较高调用方无权执行所请求的操作。</exception>
      </Docs>
    </Member>
    <Member MemberName="Connected">
      <MemberSignature Language="C#" Value="public bool Connected { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Connected" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.Connected" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Connected As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Connected { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.Connected : bool" Usage="System.Net.Sockets.Socket.Connected" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示 <see cref="T:System.Net.Sockets.Socket" /> 是在上次 <see cref="Overload:System.Net.Sockets.Socket.Send" /> 还是 <see cref="Overload:System.Net.Sockets.Socket.Receive" /> 操作时连接到远程主机。</summary>
        <value>如果 <see cref="T:System.Net.Sockets.Socket" /> 在最近操作时连接到远程资源，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Connected` 属性获取自上次 i/o 操作到 <xref:System.Net.Sockets.Socket> 的连接状态。 如果它返回 `false`，则 <xref:System.Net.Sockets.Socket> 永远不会连接，或不再处于连接状态。  
  
 <xref:System.Net.Sockets.Socket.Connected%2A> 属性的值反映了最近操作的连接状态。 如果需要确定连接的当前状态，请发出非阻止的零字节发送调用。 如果调用成功返回或引发 WAEWOULDBLOCK 错误代码（10035），则套接字仍处于连接状态;否则，将不再连接套接字。  
  
 如果对用户数据报协议（UDP）套接字调用 <xref:System.Net.Sockets.Socket.Connect%2A>，则 <xref:System.Net.Sockets.Socket.Connected%2A> 属性始终返回 `true`;但是，此操作不会更改 UDP 的固有无连接特性。  
  
   
  
## Examples  
 下面的代码示例连接到远程终结点，检查 <xref:System.Net.Sockets.Socket.Connected%2A> 属性，并检查连接的当前状态。  
  
 [!code-cpp[Classic Socket.Connect Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Connect Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Connect Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Connect Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Connect Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Connect Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Disconnect">
      <MemberSignature Language="C#" Value="public void Disconnect (bool reuseSocket);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Disconnect(bool reuseSocket) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Disconnect(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Disconnect (reuseSocket As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Disconnect(bool reuseSocket);" />
      <MemberSignature Language="F#" Value="member this.Disconnect : bool -&gt; unit" Usage="socket.Disconnect reuseSocket" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reuseSocket" Type="System.Boolean" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="reuseSocket">如果关闭当前连接后可以重用此套接字，则为 <see langword="true" />；否则为 <see langword="false" />。</param>
        <summary>关闭套接字连接并允许重用套接字。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果使用面向连接的协议，则可以使用此方法关闭套接字。 此方法结束连接，并将 <xref:System.Net.Sockets.Socket.Connected%2A> 属性设置为 `false`。 但是，如果 `true``reuseSocket`，则可以重复使用套接字。  
  
 若要确保在关闭套接字之前发送和接收所有数据，应在调用 <xref:System.Net.Sockets.Socket.Disconnect%2A> 方法之前调用 <xref:System.Net.Sockets.Socket.Shutdown%2A>。  
  
 如果需要在不首先调用 <xref:System.Net.Sockets.Socket.Shutdown%2A>的情况下调用 <xref:System.Net.Sockets.Socket.Disconnect%2A>，则可以将 <xref:System.Net.Sockets.SocketOptionName.DontLinger><xref:System.Net.Sockets.Socket> 选项设置为 `false`，并指定非零超时间隔以确保发送排队等待传出传输的数据。 然后，<xref:System.Net.Sockets.Socket.Disconnect%2A> 会一直阻止到发送数据或直到指定的超时过期。 如果将 <xref:System.Net.Sockets.SocketOptionName.DontLinger> 设置为 `false` 并指定零超时间隔，<xref:System.Net.Sockets.Socket.Close%2A> 会释放连接并自动丢弃传出的排队数据。  
  
> [!NOTE]
>  如果收到 <xref:System.Net.Sockets.SocketException>，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。 获取此代码后，请参阅[Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2)文档，以获取有关错误的详细说明。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[.NET Framework 中的网络跟踪](/dotnet/framework/network-programming/network-tracing)。  
  
   
  
## Examples  
 下面的代码示例为同步通信创建套接字，并将一些数据发送到远程主机。 然后，它调用 <xref:System.Net.Sockets.Socket.Shutdown%2A>，停止发送和接收活动，并 <xref:System.Net.Sockets.Socket.Disconnect%2A>关闭套接字连接。  
  
 [!code-cpp[Nclsocketenhancements#12](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#12)]
 [!code-csharp[Nclsocketenhancements#12](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 对象已关闭。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
      </Docs>
    </Member>
    <Member MemberName="DisconnectAsync">
      <MemberSignature Language="C#" Value="public bool DisconnectAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool DisconnectAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.DisconnectAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function DisconnectAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool DisconnectAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.DisconnectAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="socket.DisconnectAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="e">要用于此异步套接字操作的 <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> 对象。</param>
        <summary>开始异步请求从远程终结点断开连接。</summary>
        <returns>如果 I/O 操作挂起，则为 <see langword="true" />。 操作完成时，将引发 <paramref name="e" /> 参数的 <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> 事件。  
  
 如果 I/O 操作同步完成，则为 <see langword="false" />。 在这种情况下，将不会引发 <paramref name="e" /> 参数的 <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> 事件，并且可能在方法调用返回后立即检查作为参数传递的 <paramref name="e" /> 对象以检索操作的结果。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用面向连接的协议时，调用 <xref:System.Net.Sockets.Socket.DisconnectAsync%2A> 方法会从远程终结点请求断开连接。 如果将 <xref:System.Net.Sockets.SocketAsyncEventArgs.DisconnectReuseSocket%2A?displayProperty=nameWithType> 设置为在 `e` 参数中 `true`，则可以重复使用套接字。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="e" /> 参数不能为 null。</exception>
        <exception cref="T:System.InvalidOperationException">已经在使用 <paramref name="e" /> 参数中指定的 <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> 对象执行套接字操作。</exception>
        <exception cref="T:System.NotSupportedException">此方法需要 Windows XP 或更高版本。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.DisconnectReuseSocket" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>释放由 <see cref="T:System.Net.Sockets.Socket" /> 类的当前实例占用的所有资源。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="socket.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>释放由 <see cref="T:System.Net.Sockets.Socket" /> 类的当前实例占用的所有资源。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在完成使用 `Dispose` 后，应调用 <xref:System.Net.Sockets.Socket>。 `Dispose` 方法使 <xref:System.Net.Sockets.Socket> 处于不可用状态。 调用 `Dispose`后，必须释放对 <xref:System.Net.Sockets.Socket> 的所有引用，以便垃圾回收器可以回收 <xref:System.Net.Sockets.Socket> 占用的内存。  
  
 有关详细信息，请参阅[清理非托管资源](/dotnet/standard/garbage-collection/unmanaged)和[实现 Dispose 方法](/dotnet/standard/garbage-collection/implementing-dispose)。  
  
> [!NOTE]
>  每次释放对 `Dispose` 的最后一个引用前，均应调用 <xref:System.Net.Sockets.Socket>。 否则，在垃圾回收器调用 <xref:System.Net.Sockets.Socket> 对象的 `Finalize` 方法之前，该对象正在使用的资源不会被释放。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit&#xA;override this.Dispose : bool -&gt; unit" Usage="socket.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">如果释放托管资源和非托管资源，则为 <see langword="true" />；如果仅释放非托管资源，则为 <see langword="false" />。</param>
        <summary>释放由 <see cref="T:System.Net.Sockets.Socket" /> 使用的非托管资源，并可根据需要释放托管资源。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法由 public `Dispose()` 方法和 <xref:System.Object.Finalize%2A> 方法调用。 `Dispose()` 调用受保护的 `Dispose(Boolean)` 方法，并将 `disposing` 参数设置为 `true`。 <xref:System.Object.Finalize%2A> 调用 `disposing` 设置为 `false`的 `Dispose`。  
  
 当 `disposing` 参数为 `true` 时，此方法释放该 <xref:System.Net.Sockets.Socket> 引用的、由任何托管对象持有的全部资源。 此方法将调用每个被引用对象的 `Dispose()` 方法。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[.NET Framework 中的网络跟踪](/dotnet/framework/network-programming/network-tracing)。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>
            <see langword="Dispose" /> 可以由其他对象多次调用。 重写 <see cref="M:System.Net.Sockets.Socket.Dispose(System.Boolean)" /> 时，请注意不要引用在以前调用 <see langword="Dispose" /> 时已释放的对象。 有关如何实现 <see cref="M:System.Net.Sockets.Socket.Dispose(System.Boolean)" />的详细信息，请参阅[实现 Dispose 方法](/dotnet/standard/garbage-collection/implementing-dispose)。  
  
有关 <see langword="Dispose" /> 和 <see cref="M:System.Object.Finalize" />的详细信息，请参阅[清理非托管资源](/dotnet/standard/garbage-collection/unmanaged)和[重写 Finalize 方法](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/ddae83kx(v=vs.100))。</para></block>
      </Docs>
    </Member>
    <Member MemberName="DontFragment">
      <MemberSignature Language="C#" Value="public bool DontFragment { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DontFragment" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.DontFragment" />
      <MemberSignature Language="VB.NET" Value="Public Property DontFragment As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool DontFragment { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.DontFragment : bool with get, set" Usage="System.Net.Sockets.Socket.DontFragment" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置 <see cref="T:System.Boolean" /> 值，该值指定 <see cref="T:System.Net.Sockets.Socket" /> 是否允许将 Internet 协议 (IP) 数据报分段。</summary>
        <value>如果 <see cref="T:System.Net.Sockets.Socket" /> 允许数据报分段，则为 <see langword="true" />；否则为 <see langword="false" />。 默认为 <see langword="true" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果数据报的大小超过传输介质的最大传输单位（MTU），则需要进行碎片整理。 数据报可以通过发送主机（所有 Internet 协议版本）或中间路由器（仅限 Internet 协议版本4）进行分段。 如果必须将数据报分段，并设置 <xref:System.Net.Sockets.Socket.DontFragment%2A> 选项，则会丢弃数据报，并将 Internet 控制消息协议（ICMP）错误消息发回到数据报的发件人。  
  
 对传输控制协议（TCP）套接字设置此属性将不起任何作用。  
  
   
  
## Examples  
 下面的代码示例演示如何使用 <xref:System.Net.Sockets.Socket.DontFragment%2A> 属性。  
  
 [!code-cpp[SocketPropertyTester#2](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#2)]
 [!code-csharp[SocketPropertyTester#2](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">只有对于在 <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> 或 <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> 族中的套接字，才可以设置此属性。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
      </Docs>
    </Member>
    <Member MemberName="DualMode">
      <MemberSignature Language="C#" Value="public bool DualMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DualMode" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.DualMode" />
      <MemberSignature Language="VB.NET" Value="Public Property DualMode As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool DualMode { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.DualMode : bool with get, set" Usage="System.Net.Sockets.Socket.DualMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个 <see cref="T:System.Boolean" /> 值，该值指定 <see cref="T:System.Net.Sockets.Socket" /> 是否是用于 IPv4 和 IPv6 的双模式套接字。</summary>
        <value>如果 <see cref="T:System.Net.Sockets.Socket" /> 是双模式套接字，则为 <see langword="true" />；否则为 <see langword="false" />。 默认为 <see langword="false" />。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DuplicateAndClose">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.SocketInformation DuplicateAndClose (int targetProcessId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Net.Sockets.SocketInformation DuplicateAndClose(int32 targetProcessId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.DuplicateAndClose(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function DuplicateAndClose (targetProcessId As Integer) As SocketInformation" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::Sockets::SocketInformation DuplicateAndClose(int targetProcessId);" />
      <MemberSignature Language="F#" Value="member this.DuplicateAndClose : int -&gt; System.Net.Sockets.SocketInformation" Usage="socket.DuplicateAndClose targetProcessId" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoLimitation("We do not support passing sockets across processes, we merely allow this API to pass the socket across AppDomains")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.SocketInformation</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="targetProcessId" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="targetProcessId">从中创建重复套接字引用的目标进程的 ID。</param>
        <summary>重复目标进程的套接字引用，并关闭此进程的套接字。</summary>
        <returns>要传递到目标进程的套接字引用。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 目标进程应使用 <xref:System.Net.Sockets.Socket.%23ctor%2A> 来创建重复的套接字实例。  
  
 如果多次调用 <xref:System.Net.Sockets.Socket.%23ctor%2A> 构造函数并将同一字节数组作为每次调用的参数，则将创建具有相同基础套接字的多个托管 <xref:System.Net.Sockets.Socket> 实例。 强烈建议您不要这样做。  
  
 如果创建套接字的进程使用异步方法（<xref:System.Net.Sockets.Socket.BeginReceive%2A> 或 <xref:System.Net.Sockets.Socket.BeginSend%2A>），则进程必须首先将 <xref:System.Net.Sockets.Socket.UseOnlyOverlappedIO%2A> 属性设置为 true;否则，套接字绑定到创建进程的完成端口，这可能导致在目标进程中引发 <xref:System.ArgumentNullException>。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><paramref name="targetProcessID" /> 不是有效的进程 ID。 
-或- 
套接字引用的复制失败。</exception>
      </Docs>
    </Member>
    <Member MemberName="EnableBroadcast">
      <MemberSignature Language="C#" Value="public bool EnableBroadcast { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableBroadcast" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.EnableBroadcast" />
      <MemberSignature Language="VB.NET" Value="Public Property EnableBroadcast As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EnableBroadcast { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnableBroadcast : bool with get, set" Usage="System.Net.Sockets.Socket.EnableBroadcast" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个 <see cref="T:System.Boolean" /> 值，该值指定 <see cref="T:System.Net.Sockets.Socket" /> 是否可以发送或接收广播数据包。</summary>
        <value>如果 <see cref="T:System.Net.Sockets.Socket" /> 允许广播数据包，则为 <see langword="true" />；否则为 <see langword="false" />。 默认为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 广播限制为特定的子网，并且必须使用用户数据报协议（UDP）。对于 Internet 协议版本4，可以通过将数据包发送到255.255.255.255 来广播到本地子网;或者，你可以使用定向广播地址，该地址是 Internet 协议（IP）地址的网络部分，其中的所有位均设置为主机部分。 例如，如果 IP 地址为192.168.1.40 （a 类 C 地址，子网掩码为255.255.255.0，网络部分为前三个八位字节，主机部分为最后一个八进制数），则定向广播地址为192.168.1.255。  
  
 对传输控制协议（TCP）套接字设置此属性将不起任何作用。  
  
   
  
## Examples  
 下面的代码示例演示如何使用 <xref:System.Net.Sockets.Socket.EnableBroadcast%2A> 属性。  
  
 [!code-cpp[SocketPropertyTester#2](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#2)]
 [!code-csharp[SocketPropertyTester#2](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">此选项仅对数据报套接字有效。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="EndAccept">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>异步接受传入的连接尝试。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="EndAccept">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.Socket EndAccept (out byte[] buffer, IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.Sockets.Socket EndAccept([out] unsigned int8[]&amp; buffer, class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndAccept (ByRef buffer As Byte(), asyncResult As IAsyncResult) As Socket" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::Sockets::Socket ^ EndAccept([Runtime::InteropServices::Out] cli::array &lt;System::Byte&gt; ^ % buffer, IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="member this.EndAccept : Byte[] * IAsyncResult -&gt; System.Net.Sockets.Socket" Usage="socket.EndAccept (buffer, asyncResult)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.Socket</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" RefType="out" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="buffer">包含所传输字节的类型 <see cref="T:System.Byte" /> 的数组。</param>
        <param name="asyncResult"><see cref="T:System.IAsyncResult" /> 对象，它存储此异步操作的状态信息以及任何用户定义数据。</param>
        <summary>异步接受传入的连接尝试，并创建新的 <see cref="T:System.Net.Sockets.Socket" /> 对象来处理远程主机通信。 此方法返回包含所传输的初始数据的缓冲区。</summary>
        <returns>一个 <see cref="T:System.Net.Sockets.Socket" /> 对象，它处理与远程主机的通信。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndAccept%2A> 完成对 <xref:System.Net.Sockets.Socket.BeginAccept%2A>的调用。 在调用 <xref:System.Net.Sockets.Socket.BeginAccept%2A>之前，需要创建由 <xref:System.AsyncCallback> 委托调用的回调方法。 此回调方法在单独的线程中执行，并在 <xref:System.Net.Sockets.Socket.BeginAccept%2A> 方法返回后由系统调用。  
  
 在回调方法中，调用 `asyncResult` 参数的 <xref:System.IAsyncResult.AsyncState%2A> 方法，以获取在其上进行连接尝试的 <xref:System.Net.Sockets.Socket>。 获取 <xref:System.Net.Sockets.Socket>后，可以调用 <xref:System.Net.Sockets.Socket.EndAccept%2A> 方法成功完成连接尝试。 此重载的 `buffer` 参数包含调用 <xref:System.Net.Sockets.Socket.BeginAccept%2A> 时收到的数据，`bytesTransferred` 参数包含在调用中传输的字节数。  
  
 在传入连接队列中等待连接之前，<xref:System.Net.Sockets.Socket.EndAccept%2A> 方法将会阻止。 <xref:System.Net.Sockets.Socket.EndAccept%2A> 方法接受传入连接，并返回可用于向远程主机发送数据并从远程主机接收数据的新 <xref:System.Net.Sockets.Socket>。  
  
> [!NOTE]
>  如果收到 <xref:System.Net.Sockets.SocketException>，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。 获取此代码后，请参阅[Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2)文档，以获取有关错误的详细说明。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[.NET Framework 中的网络跟踪](/dotnet/framework/network-programming/network-tracing)。  
  
   
  
## Examples  
 下面的代码示例使用 <xref:System.Net.Sockets.Socket.BeginAccept%2A> 创建并连接套接字，并接受前10个字节的数据。 回调委托调用 <xref:System.Net.Sockets.Socket.EndAccept%2A> 以结束异步请求。 传输的字节数和数据将在此方法的 `buffer` 和 `bytesTransferred` 参数中返回，并显示在控制台上。  
  
 [!code-cpp[NCLSocketEnhancements#6](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#6)]
 [!code-csharp[NCLSocketEnhancements#6](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">此方法需要 Windows NT。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 对象已关闭。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" /> 为空。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="asyncResult" /> 并不是通过对 <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" /> 的调用创建的。</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" /> 方法以前被调用过。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问 <see cref="T:System.Net.Sockets.Socket" /> 时出错</exception>
      </Docs>
    </Member>
    <Member MemberName="EndAccept">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.Socket EndAccept (IAsyncResult asyncResult);" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.Sockets.Socket EndAccept(class System.IAsyncResult asyncResult) cil managed" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndAccept (asyncResult As IAsyncResult) As Socket" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::Sockets::Socket ^ EndAccept(IAsyncResult ^ asyncResult);" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.EndAccept : IAsyncResult -&gt; System.Net.Sockets.Socket" Usage="socket.EndAccept asyncResult" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public System.Net.Sockets.Socket EndAccept (IAsyncResult result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.Sockets.Socket EndAccept(class System.IAsyncResult result) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function EndAccept (result As IAsyncResult) As Socket" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::Sockets::Socket ^ EndAccept(IAsyncResult ^ result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.EndAccept : IAsyncResult -&gt; System.Net.Sockets.Socket" Usage="socket.EndAccept result" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.Socket</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="result" Type="System.IAsyncResult" Index="0" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult"><see cref="T:System.IAsyncResult" />，它存储此异步操作的状态信息以及任何用户定义数据。</param>
        <param name="result"><see cref="T:System.IAsyncResult" />，它存储此异步操作的状态信息以及任何用户定义数据。</param>
        <summary>异步接受传入的连接尝试，并创建新的 <see cref="T:System.Net.Sockets.Socket" /> 来处理远程主机通信。</summary>
        <returns>一个 <see cref="T:System.Net.Sockets.Socket" />，它处理与远程主机的通信。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndAccept%2A> 完成对 <xref:System.Net.Sockets.Socket.BeginAccept%2A>的调用。 在调用 <xref:System.Net.Sockets.Socket.BeginAccept%2A>之前，需要创建实现 <xref:System.AsyncCallback> 委托的回调方法。 此回调方法在单独的线程中执行，并在 <xref:System.Net.Sockets.Socket.BeginAccept%2A> 方法返回后由系统调用。 它必须接受从 <xref:System.Net.Sockets.Socket.BeginAccept%2A> 方法返回的 `asyncResult` 参数。  
  
 在回调方法中，调用 `asyncResult` 参数的 <xref:System.IAsyncResult.AsyncState%2A> 方法，以获取在其上进行连接尝试的 <xref:System.Net.Sockets.Socket>。 获取 <xref:System.Net.Sockets.Socket>后，可以调用 <xref:System.Net.Sockets.Socket.EndAccept%2A> 方法成功完成连接尝试。  
  
 在传入连接队列中等待连接之前，<xref:System.Net.Sockets.Socket.EndAccept%2A> 方法将会阻止。 <xref:System.Net.Sockets.Socket.EndAccept%2A> 方法接受传入连接，并返回可用于向远程主机发送数据并从远程主机接收数据的新 <xref:System.Net.Sockets.Socket>。  
  
> [!NOTE]
>  如果收到 <xref:System.Net.Sockets.SocketException>，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。 获取此代码后，请参阅[Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2)文档，以获取有关错误的详细说明。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[.NET Framework 中的网络跟踪](/dotnet/framework/network-programming/network-tracing)。  
  
   
  
## Examples  
 下面的代码示例结束异步请求，并创建新的 <xref:System.Net.Sockets.Socket> 以接受传入的连接请求。 有关演示与套接字的异步通信的完整示例，请参阅[套接字代码示例](/dotnet/framework/network-programming/socket-code-examples)。  
  
 [!code-cpp[Socket_Async_Send_Receive#7](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#7)]
 [!code-csharp[Socket_Async_Send_Receive#7](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#7)]
 [!code-vb[Socket_Async_Send_Receive#7](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="asyncResult" /> 并不是通过对 <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" /> 的调用创建的。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。 有关详细信息，请参阅“备注”部分。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" /> 方法以前被调用过。</exception>
        <exception cref="T:System.NotSupportedException">此方法需要 Windows NT。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="P:System.IAsyncResult.AsyncState" />
      </Docs>
    </Member>
    <Member MemberName="EndAccept">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.Socket EndAccept (out byte[] buffer, out int bytesTransferred, IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.Sockets.Socket EndAccept([out] unsigned int8[]&amp; buffer, [out] int32&amp; bytesTransferred, class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.Int32@,System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndAccept (ByRef buffer As Byte(), ByRef bytesTransferred As Integer, asyncResult As IAsyncResult) As Socket" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::Sockets::Socket ^ EndAccept([Runtime::InteropServices::Out] cli::array &lt;System::Byte&gt; ^ % buffer, [Runtime::InteropServices::Out] int % bytesTransferred, IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="member this.EndAccept : Byte[] * int * IAsyncResult -&gt; System.Net.Sockets.Socket" Usage="socket.EndAccept (buffer, bytesTransferred, asyncResult)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.Socket</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" RefType="out" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="bytesTransferred" Type="System.Int32" RefType="out" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="buffer">包含所传输字节的类型 <see cref="T:System.Byte" /> 的数组。</param>
        <param name="bytesTransferred">传输的字节数。</param>
        <param name="asyncResult"><see cref="T:System.IAsyncResult" /> 对象，它存储此异步操作的状态信息以及任何用户定义数据。</param>
        <summary>异步接受传入的连接尝试，并创建新的 <see cref="T:System.Net.Sockets.Socket" /> 对象来处理远程主机通信。 此方法返回一个缓冲区，其中包含初始数据和传输的字节数。</summary>
        <returns>一个 <see cref="T:System.Net.Sockets.Socket" /> 对象，它处理与远程主机的通信。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndAccept%2A> 完成对 <xref:System.Net.Sockets.Socket.BeginAccept%2A>的调用。 在调用 <xref:System.Net.Sockets.Socket.BeginAccept%2A>之前，需要创建由 <xref:System.AsyncCallback> 委托调用的回调方法。 此回调方法在单独的线程中执行，并在 <xref:System.Net.Sockets.Socket.BeginAccept%2A> 方法返回后由系统调用。 它必须接受从 <xref:System.Net.Sockets.Socket.BeginAccept%2A> 方法返回的 `asyncResult` 参数。  
  
 在回调方法中，调用 `asyncResult` 参数的 <xref:System.IAsyncResult.AsyncState%2A> 方法，以获取在其上进行连接尝试的 <xref:System.Net.Sockets.Socket>。 获取 <xref:System.Net.Sockets.Socket>后，可以调用 <xref:System.Net.Sockets.Socket.EndAccept%2A> 方法成功完成连接尝试。 此重载的 `buffer` 参数包含调用 <xref:System.Net.Sockets.Socket.BeginAccept%2A> 时收到的数据，`bytesTransferred` 参数包含在调用中传输的字节数。  
  
 在传入连接队列中等待连接之前，<xref:System.Net.Sockets.Socket.EndAccept%2A> 方法将会阻止。 <xref:System.Net.Sockets.Socket.EndAccept%2A> 方法接受传入连接，并返回可用于向远程主机发送数据并从远程主机接收数据的新 <xref:System.Net.Sockets.Socket>。  
  
> [!NOTE]
>  如果收到 <xref:System.Net.Sockets.SocketException>，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。 获取此代码后，请参阅[Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2)文档，以获取有关错误的详细说明。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[.NET Framework 中的网络跟踪](/dotnet/framework/network-programming/network-tracing)。  
  
   
  
## Examples  
 下面的代码示例使用 <xref:System.Net.Sockets.Socket.BeginAccept%2A> 创建并连接套接字，并接受前10个字节的数据。 回调委托调用 <xref:System.Net.Sockets.Socket.EndAccept%2A> 以结束异步请求。 传输的字节数和数据将在此方法的 `buffer` 和 `bytesTransferred` 参数中返回，并显示在控制台上。  
  
 [!code-cpp[NCLSocketEnhancements#6](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#6)]
 [!code-csharp[NCLSocketEnhancements#6](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">此方法需要 Windows NT。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 对象已关闭。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" /> 为空。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="asyncResult" /> 并不是通过对 <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" /> 的调用创建的。</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" /> 方法以前被调用过。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问 <see cref="T:System.Net.Sockets.Socket" /> 时出错。</exception>
      </Docs>
    </Member>
    <Member MemberName="EndConnect">
      <MemberSignature Language="C#" Value="public void EndConnect (IAsyncResult asyncResult);" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EndConnect(class System.IAsyncResult asyncResult) cil managed" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndConnect (asyncResult As IAsyncResult)" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EndConnect(IAsyncResult ^ asyncResult);" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.EndConnect : IAsyncResult -&gt; unit" Usage="socket.EndConnect asyncResult" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public void EndConnect (IAsyncResult result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EndConnect(class System.IAsyncResult result) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndConnect (result As IAsyncResult)" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EndConnect(IAsyncResult ^ result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.EndConnect : IAsyncResult -&gt; unit" Usage="socket.EndConnect result" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="result" Type="System.IAsyncResult" Index="0" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult"><see cref="T:System.IAsyncResult" />，它存储此异步操作的状态信息以及所有用户定义的数据。</param>
        <param name="result"><see cref="T:System.IAsyncResult" />，它存储此异步操作的状态信息以及所有用户定义的数据。</param>
        <summary>结束挂起的异步连接请求。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndConnect%2A> 是一种阻止方法，用于完成在 <xref:System.Net.Sockets.Socket.BeginConnect%2A> 方法中启动的异步远程主机连接请求。  
  
 在调用 <xref:System.Net.Sockets.Socket.BeginConnect%2A>之前，需要创建实现 <xref:System.AsyncCallback> 委托的回调方法。 此回调方法在单独的线程中执行，并在 <xref:System.Net.Sockets.Socket.BeginConnect%2A> 返回后由系统调用。 回调方法必须接受 <xref:System.Net.Sockets.Socket.BeginConnect%2A> 方法作为参数返回的 <xref:System.IAsyncResult>。  
  
 在回调方法中，调用 <xref:System.IAsyncResult> 参数的 <xref:System.IAsyncResult.AsyncState%2A> 方法，以获取在其上进行连接尝试的 <xref:System.Net.Sockets.Socket>。 获取 <xref:System.Net.Sockets.Socket>后，可以调用 <xref:System.Net.Sockets.Socket.EndConnect%2A> 方法成功完成连接尝试。  
  
> [!NOTE]
>  如果收到 <xref:System.Net.Sockets.SocketException>，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。 获取此代码后，请参阅[Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2)文档，以获取有关错误的详细说明。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[.NET Framework 中的网络跟踪](/dotnet/framework/network-programming/network-tracing)。  
  
   
  
## Examples  
 下面的代码示例结束了异步连接尝试。 有关演示与套接字的异步通信的完整示例，请参阅[套接字代码示例](/dotnet/framework/network-programming/socket-code-examples)。  
  
 [!code-cpp[Socket_Async_Send_Receive#5](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#5)]
 [!code-csharp[Socket_Async_Send_Receive#5](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#5)]
 [!code-vb[Socket_Async_Send_Receive#5](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">对 <see cref="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)" /> 方法的调用未返回 <paramref name="asyncResult" />。</exception>
        <exception cref="T:System.InvalidOperationException">先前曾为异步连接调用过 <see cref="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)" />。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="P:System.IAsyncResult.AsyncState" />
      </Docs>
    </Member>
    <Member MemberName="EndDisconnect">
      <MemberSignature Language="C#" Value="public void EndDisconnect (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EndDisconnect(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndDisconnect(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndDisconnect (asyncResult As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EndDisconnect(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="member this.EndDisconnect : IAsyncResult -&gt; unit" Usage="socket.EndDisconnect asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult"><see cref="T:System.IAsyncResult" /> 对象，它存储此异步操作的状态信息以及所有用户定义数据。</param>
        <summary>结束挂起的异步断开连接请求。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndDisconnect%2A> 完成对 <xref:System.Net.Sockets.Socket.BeginDisconnect%2A>的调用。 直到断开连接完成后，才会阻止 <xref:System.Net.Sockets.Socket.EndDisconnect%2A> 方法。 有关异步操作的详细信息，请参阅 MSDN library 中的异步编程概述主题。  
  
> [!NOTE]
>  如果收到 <xref:System.Net.Sockets.SocketException>，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。 获取此代码后，请参阅[Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2)文档，以获取有关错误的详细说明。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[.NET Framework 中的网络跟踪](/dotnet/framework/network-programming/network-tracing)。  
  
   
  
## Examples  
 下面的代码示例为异步通信创建套接字，并将一些数据发送到远程主机。 发送数据后，将调用 <xref:System.Net.Sockets.Socket.Shutdown%2A> 来停止发送和接收活动。 然后调用 <xref:System.Net.Sockets.Socket.BeginDisconnect%2A> 以开始断开连接请求。 回调委托调用 <xref:System.Net.Sockets.Socket.EndDisconnect%2A> 以结束异步请求。 请求完成后，将查询 <xref:System.Net.Sockets.Socket.Connected%2A> 属性以测试套接字是否已断开连接。  
  
 [!code-cpp[Nclsocketenhancements#11](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#11)]
 [!code-csharp[Nclsocketenhancements#11](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 对象已关闭。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">对 <see cref="M:System.Net.Sockets.Socket.BeginDisconnect(System.Boolean,System.AsyncCallback,System.Object)" /> 方法的调用未返回 <paramref name="asyncResult" />。</exception>
        <exception cref="T:System.InvalidOperationException">先前曾为异步连接调用过 <see cref="M:System.Net.Sockets.Socket.EndDisconnect(System.IAsyncResult)" />。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.Net.WebException">断开连接请求已超时。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="EndReceive">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>结束挂起的异步读取。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="EndReceive">
      <MemberSignature Language="C#" Value="public int EndReceive (IAsyncResult asyncResult);" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndReceive(class System.IAsyncResult asyncResult) cil managed" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReceive (asyncResult As IAsyncResult) As Integer" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndReceive(IAsyncResult ^ asyncResult);" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.EndReceive : IAsyncResult -&gt; int" Usage="socket.EndReceive asyncResult" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public int EndReceive (IAsyncResult result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndReceive(class System.IAsyncResult result) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReceive (result As IAsyncResult) As Integer" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndReceive(IAsyncResult ^ result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.EndReceive : IAsyncResult -&gt; int" Usage="socket.EndReceive result" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="result" Type="System.IAsyncResult" Index="0" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult"><see cref="T:System.IAsyncResult" />，它存储此异步操作的状态信息以及所有用户定义的数据。</param>
        <param name="result"><see cref="T:System.IAsyncResult" />，它存储此异步操作的状态信息以及所有用户定义的数据。</param>
        <summary>结束挂起的异步读取。</summary>
        <returns>收到的字节数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndReceive%2A> 方法完成 <xref:System.Net.Sockets.Socket.BeginReceive%2A> 方法中启动的异步读取操作。  
  
 在调用 <xref:System.Net.Sockets.Socket.BeginReceive%2A>之前，需要创建实现 <xref:System.AsyncCallback> 委托的回调方法。 此回调方法在单独的线程中执行，并在 <xref:System.Net.Sockets.Socket.BeginReceive%2A> 返回后由系统调用。 回调方法必须接受 <xref:System.Net.Sockets.Socket.BeginReceive%2A> 方法作为参数返回的 <xref:System.IAsyncResult>。  
  
 在回调方法中，调用 <xref:System.IAsyncResult> 的 <xref:System.IAsyncResult.AsyncState%2A> 方法，以获取传递给 <xref:System.Net.Sockets.Socket.BeginReceive%2A> 方法的状态对象。 从此状态对象中提取接收 <xref:System.Net.Sockets.Socket>。 获取 <xref:System.Net.Sockets.Socket>后，可以调用 <xref:System.Net.Sockets.Socket.EndReceive%2A> 方法成功完成读取操作并返回所读取的字节数。  
  
 在数据可用之前，将阻止 <xref:System.Net.Sockets.Socket.EndReceive%2A> 方法。 如果使用的是无连接协议，<xref:System.Net.Sockets.Socket.EndReceive%2A> 将读取传入网络缓冲区中的第一个排队数据报。 如果使用面向连接的协议，<xref:System.Net.Sockets.Socket.EndReceive%2A> 方法将读取尽可能多的数据，最多可达在 <xref:System.Net.Sockets.Socket.BeginReceive%2A> 方法的 `size` 参数中指定的字节数。 如果远程主机使用 <xref:System.Net.Sockets.Socket.Shutdown%2A> 方法关闭 <xref:System.Net.Sockets.Socket> 连接，并且收到所有可用数据，则 <xref:System.Net.Sockets.Socket.EndReceive%2A> 方法会立即完成并返回零字节。  
  
 若要获取收到的数据，请调用 <xref:System.IAsyncResult>的 <xref:System.IAsyncResult.AsyncState%2A> 方法，然后提取所产生状态对象中包含的缓冲区。  
  
 若要取消挂起的 <xref:System.Net.Sockets.Socket.BeginReceive%2A>，请调用 <xref:System.Net.Sockets.Socket.Close%2A> 方法。  
  
> [!NOTE]
>  如果收到 <xref:System.Net.Sockets.SocketException>，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。 获取此代码后，请参阅[Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2)文档，以获取有关错误的详细说明。  
  
> [!NOTE]
>  给定线程启动的所有 i/o 都将在该线程退出时取消。 如果线程在操作完成之前退出，则挂起的异步操作可能会失败。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[.NET Framework 中的网络跟踪](/dotnet/framework/network-programming/network-tracing)。  
  
   
  
## Examples  
 下面的代码示例结束挂起的异步读取。 有关演示与套接字的异步通信的完整示例，请参阅[套接字代码示例](/dotnet/framework/network-programming/socket-code-examples)。  
  
 [!code-cpp[Socket_Async_Send_Receive#8](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#8)]
 [!code-csharp[Socket_Async_Send_Receive#8](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#8)]
 [!code-vb[Socket_Async_Send_Receive#8](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">对 <see cref="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" /> 方法的调用未返回 <paramref name="asyncResult" />。</exception>
        <exception cref="T:System.InvalidOperationException">先前曾为异步读取调用过 <see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" />。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="T:System.IAsyncResult" />
        <altmember cref="P:System.IAsyncResult.AsyncState" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
      </Docs>
    </Member>
    <Member MemberName="EndReceive">
      <MemberSignature Language="C#" Value="public int EndReceive (IAsyncResult asyncResult, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndReceive(class System.IAsyncResult asyncResult, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReceive (asyncResult As IAsyncResult, ByRef errorCode As SocketError) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndReceive(IAsyncResult ^ asyncResult, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberSignature Language="F#" Value="member this.EndReceive : IAsyncResult * SocketError -&gt; int" Usage="socket.EndReceive (asyncResult, errorCode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult"><see cref="T:System.IAsyncResult" />，它存储此异步操作的状态信息以及所有用户定义的数据。</param>
        <param name="errorCode">一个 <see cref="T:System.Net.Sockets.SocketError" /> 对象，它存储套接字错误。</param>
        <summary>结束挂起的异步读取。</summary>
        <returns>收到的字节数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndReceive%2A> 方法完成 <xref:System.Net.Sockets.Socket.BeginReceive%2A> 方法中启动的异步读取操作。  
  
 在调用 <xref:System.Net.Sockets.Socket.BeginReceive%2A>之前，需要创建实现 <xref:System.AsyncCallback> 委托的回调方法。 此回调方法在单独的线程中执行，并在 <xref:System.Net.Sockets.Socket.BeginReceive%2A> 返回后由系统调用。 回调方法必须接受 <xref:System.Net.Sockets.Socket.BeginReceive%2A> 方法作为参数返回的 <xref:System.IAsyncResult>。  
  
 在回调方法中，调用 <xref:System.IAsyncResult> 的 <xref:System.IAsyncResult.AsyncState%2A> 方法，以获取传递给 <xref:System.Net.Sockets.Socket.BeginReceive%2A> 方法的状态对象。 从此状态对象中提取接收 <xref:System.Net.Sockets.Socket>。 获取 <xref:System.Net.Sockets.Socket>后，可以调用 <xref:System.Net.Sockets.Socket.EndReceive%2A> 方法成功完成读取操作并返回所读取的字节数。  
  
 在数据可用之前，将阻止 <xref:System.Net.Sockets.Socket.EndReceive%2A> 方法。 如果使用的是无连接协议，<xref:System.Net.Sockets.Socket.EndReceive%2A> 将读取传入网络缓冲区中的第一个排队数据报。 如果使用面向连接的协议，<xref:System.Net.Sockets.Socket.EndReceive%2A> 方法将读取尽可能多的数据，最多可达在 <xref:System.Net.Sockets.Socket.BeginReceive%2A> 方法的 `size` 参数中指定的字节数。 如果远程主机使用 <xref:System.Net.Sockets.Socket.Shutdown%2A> 方法关闭 <xref:System.Net.Sockets.Socket> 连接，并且收到所有可用数据，则 <xref:System.Net.Sockets.Socket.EndReceive%2A> 方法会立即完成并返回零字节。  
  
 若要获取收到的数据，请调用 <xref:System.IAsyncResult>的 <xref:System.IAsyncResult.AsyncState%2A> 方法，然后提取所产生状态对象中包含的缓冲区。  
  
> [!NOTE]
>  如果收到 <xref:System.Net.Sockets.SocketException>，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。 获取此代码后，请参阅[Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2)文档，以获取有关错误的详细说明。  
  
> [!NOTE]
>  给定线程启动的所有 i/o 都将在该线程退出时取消。 如果线程在操作完成之前退出，则挂起的异步操作可能会失败。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[.NET Framework 中的网络跟踪](/dotnet/framework/network-programming/network-tracing)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">对 <see cref="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" /> 方法的调用未返回 <paramref name="asyncResult" />。</exception>
        <exception cref="T:System.InvalidOperationException">先前曾为异步读取调用过 <see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" />。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="T:System.IAsyncResult" />
        <altmember cref="P:System.IAsyncResult.AsyncState" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
      </Docs>
    </Member>
    <Member MemberName="EndReceiveFrom">
      <MemberSignature Language="C#" Value="public int EndReceiveFrom (IAsyncResult asyncResult, ref System.Net.EndPoint endPoint);" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndReceiveFrom(class System.IAsyncResult asyncResult, class System.Net.EndPoint&amp; endPoint) cil managed" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReceiveFrom (asyncResult As IAsyncResult, ByRef endPoint As EndPoint) As Integer" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndReceiveFrom(IAsyncResult ^ asyncResult, System::Net::EndPoint ^ % endPoint);" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.EndReceiveFrom : IAsyncResult * EndPoint -&gt; int" Usage="socket.EndReceiveFrom (asyncResult, endPoint)" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public int EndReceiveFrom (IAsyncResult result, ref System.Net.EndPoint end_point);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndReceiveFrom(class System.IAsyncResult result, class System.Net.EndPoint&amp; end_point) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReceiveFrom (result As IAsyncResult, ByRef end_point As EndPoint) As Integer" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndReceiveFrom(IAsyncResult ^ result, System::Net::EndPoint ^ % end_point);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.EndReceiveFrom : IAsyncResult * EndPoint -&gt; int" Usage="socket.EndReceiveFrom (result, end_point)" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="result" Type="System.IAsyncResult" Index="0" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="endPoint" Type="System.Net.EndPoint" RefType="ref" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="end_point" Type="System.Net.EndPoint" RefType="ref" Index="1" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult"><see cref="T:System.IAsyncResult" />，它存储此异步操作的状态信息以及所有用户定义的数据。</param>
        <param name="result"><see cref="T:System.IAsyncResult" />，它存储此异步操作的状态信息以及所有用户定义的数据。</param>
        <param name="endPoint">源 <see cref="T:System.Net.EndPoint" />。</param>
        <param name="end_point">源 <see cref="T:System.Net.EndPoint" />。</param>
        <summary>结束挂起的、从特定终结点进行异步读取。</summary>
        <returns>如果成功，则返回已接收的字节数。 如果不成功，则返回 0。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> 方法完成 <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> 方法中启动的异步读取操作。  
  
 在调用 <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>之前，需要创建实现 <xref:System.AsyncCallback> 委托的回调方法。 此回调方法在单独的线程中执行，并在 <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> 返回后由系统调用。 回调方法必须接受 <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> 方法作为参数返回的 <xref:System.IAsyncResult>。  
  
 在回调方法中，调用 <xref:System.IAsyncResult> 的 <xref:System.IAsyncResult.AsyncState%2A> 方法，以获取传递给 <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> 方法的状态对象。 从此状态对象中提取接收 <xref:System.Net.Sockets.Socket>。 获取 <xref:System.Net.Sockets.Socket>后，可以调用 <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> 方法成功完成读取操作并返回所读取的字节数。  
  
 在数据可用之前，将阻止 <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> 方法。 如果使用的是无连接协议，<xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> 将读取传入网络缓冲区中的第一个排队数据报。 如果使用面向连接的协议，<xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> 方法将读取尽可能多的数据，最多可达在 <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> 方法的 `size` 参数中指定的字节数。 如果远程主机使用 <xref:System.Net.Sockets.Socket.Shutdown%2A> 方法关闭 <xref:System.Net.Sockets.Socket> 连接，并且收到所有可用数据，则 <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> 方法会立即完成并返回零字节。 若要获取收到的数据，请调用 <xref:System.IAsyncResult> 对象的 <xref:System.IAsyncResult.AsyncState%2A> 方法，然后提取所产生状态对象中包含的缓冲区。 若要标识源主机，请提取 <xref:System.Net.EndPoint> 并将其转换为 <xref:System.Net.IPEndPoint>。 使用 <xref:System.Net.IPEndPoint.Address%2A?displayProperty=nameWithType> 方法来获取 IP 地址和 <xref:System.Net.IPEndPoint.Port%2A?displayProperty=nameWithType> 方法以获取端口号。  
  
> [!NOTE]
>  如果收到 <xref:System.Net.Sockets.SocketException>，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。 获取此代码后，请参阅[Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2)文档，以获取有关错误的详细说明。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[.NET Framework 中的网络跟踪](/dotnet/framework/network-programming/network-tracing)。  
  
   
  
## Examples  
 下面的代码示例结束了从特定 <xref:System.Net.EndPoint>进行的挂起的异步读取。  
  
 [!code-cpp[Socket_Async_Send_Receive#10](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#10)]
 [!code-csharp[Socket_Async_Send_Receive#10](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#10)]
 [!code-vb[Socket_Async_Send_Receive#10](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">对 <see cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" /> 方法的调用未返回 <paramref name="asyncResult" />。</exception>
        <exception cref="T:System.InvalidOperationException">先前曾为异步读取调用过 <see cref="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)" />。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
      </Docs>
    </Member>
    <Member MemberName="EndReceiveMessageFrom">
      <MemberSignature Language="C#" Value="public int EndReceiveMessageFrom (IAsyncResult asyncResult, ref System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint endPoint, out System.Net.Sockets.IPPacketInformation ipPacketInformation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndReceiveMessageFrom(class System.IAsyncResult asyncResult, valuetype System.Net.Sockets.SocketFlags&amp; socketFlags, class System.Net.EndPoint&amp; endPoint, [out] valuetype System.Net.Sockets.IPPacketInformation&amp; ipPacketInformation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndReceiveMessageFrom(System.IAsyncResult,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReceiveMessageFrom (asyncResult As IAsyncResult, ByRef socketFlags As SocketFlags, ByRef endPoint As EndPoint, ByRef ipPacketInformation As IPPacketInformation) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndReceiveMessageFrom(IAsyncResult ^ asyncResult, System::Net::Sockets::SocketFlags % socketFlags, System::Net::EndPoint ^ % endPoint, [Runtime::InteropServices::Out] System::Net::Sockets::IPPacketInformation % ipPacketInformation);" />
      <MemberSignature Language="F#" Value="member this.EndReceiveMessageFrom : IAsyncResult * SocketFlags * EndPoint * IPPacketInformation -&gt; int" Usage="socket.EndReceiveMessageFrom (asyncResult, socketFlags, endPoint, ipPacketInformation)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" RefType="ref" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="endPoint" Type="System.Net.EndPoint" RefType="ref" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="ipPacketInformation" Type="System.Net.Sockets.IPPacketInformation" RefType="out" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult"><see cref="T:System.IAsyncResult" />，它存储此异步操作的状态信息以及所有用户定义的数据。</param>
        <param name="socketFlags">所接收数据包的 <see cref="T:System.Net.Sockets.SocketFlags" /> 值的按位组合。</param>
        <param name="endPoint">源 <see cref="T:System.Net.EndPoint" />。</param>
        <param name="ipPacketInformation">所接收数据包的 <see cref="T:System.Net.IPAddress" /> 和接口。</param>
        <summary>结束挂起的、从特定终结点进行异步读取。 此方法还显示有关数据包而不是 <see cref="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)" /> 的更多信息。</summary>
        <returns>如果成功，则返回已接收的字节数。 如果不成功，则返回 0。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果操作尚未完成，则此方法将一直阻止到该操作。  
  
 若要同步执行此操作，请使用 <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> 方法。  
  
 如果需要知道是否使用单播、多播或广播地址发送了数据报，请检查 `ipPacketInformation`。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" /> 是 <see langword="null" />  
  
-或- 
 <paramref name="endPoint" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">对 <see cref="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" /> 方法的调用未返回 <paramref name="asyncResult" />。</exception>
        <exception cref="T:System.InvalidOperationException">先前曾为异步读取调用过 <see cref="M:System.Net.Sockets.Socket.EndReceiveMessageFrom(System.IAsyncResult,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)" />。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="EndSend">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>结束挂起的异步发送。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="EndSend">
      <MemberSignature Language="C#" Value="public int EndSend (IAsyncResult asyncResult);" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndSend(class System.IAsyncResult asyncResult) cil managed" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndSend (asyncResult As IAsyncResult) As Integer" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndSend(IAsyncResult ^ asyncResult);" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.EndSend : IAsyncResult -&gt; int" Usage="socket.EndSend asyncResult" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public int EndSend (IAsyncResult result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndSend(class System.IAsyncResult result) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function EndSend (result As IAsyncResult) As Integer" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndSend(IAsyncResult ^ result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.EndSend : IAsyncResult -&gt; int" Usage="socket.EndSend result" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="result" Type="System.IAsyncResult" Index="0" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult"><see cref="T:System.IAsyncResult" />，它存储此异步操作的状态信息。</param>
        <param name="result"><see cref="T:System.IAsyncResult" />，它存储此异步操作的状态信息。</param>
        <summary>结束挂起的异步发送。</summary>
        <returns>如果成功，则将返回向 <see cref="T:System.Net.Sockets.Socket" /> 发送的字节数；否则会返回无效 <see cref="T:System.Net.Sockets.Socket" /> 错误。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndSend%2A> 完成 <xref:System.Net.Sockets.Socket.BeginSend%2A>中启动的异步发送操作。  
  
 在调用 <xref:System.Net.Sockets.Socket.BeginSend%2A>之前，需要创建实现 <xref:System.AsyncCallback> 委托的回调方法。 此回调方法在单独的线程中执行，并在 <xref:System.Net.Sockets.Socket.BeginSend%2A> 返回后由系统调用。 回调方法必须接受 <xref:System.Net.Sockets.Socket.BeginSend%2A> 方法作为参数返回的 <xref:System.IAsyncResult>。  
  
 在回调方法中，调用 <xref:System.IAsyncResult> 参数的 <xref:System.IAsyncResult.AsyncState%2A> 方法以获取发送 <xref:System.Net.Sockets.Socket>。 获取 <xref:System.Net.Sockets.Socket>后，可以调用 <xref:System.Net.Sockets.Socket.EndSend%2A> 方法成功完成发送操作，并返回发送的字节数。  
  
 如果你使用的是无连接协议，则在发送数据报之前，<xref:System.Net.Sockets.Socket.EndSend%2A> 将会阻止。 如果你使用的是面向连接的协议，<xref:System.Net.Sockets.Socket.EndSend%2A> 会一直阻止，直到发送了某些缓冲区。 如果 <xref:System.Net.Sockets.Socket.EndSend%2A> 的返回值指示未完全发送缓冲区，请再次调用 <xref:System.Net.Sockets.Socket.BeginSend%2A> 方法，同时修改缓冲区以保存未发送的数据。  
  
 不能保证发送的数据会立即显示在网络上。 为了提高网络效率，基础系统可能会延迟传输，直到收集大量传出数据。 成功完成 <xref:System.Net.Sockets.Socket.BeginSend%2A> 方法意味着基础系统具有空间来缓冲用于网络发送的数据。  
  
> [!NOTE]
>  如果收到 <xref:System.Net.Sockets.SocketException>，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。 获取此代码后，请参阅[Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2)文档，以获取有关错误的详细说明。  
  
> [!NOTE]
>  给定线程启动的所有 i/o 都将在该线程退出时取消。 如果线程在操作完成之前退出，则挂起的异步操作可能会失败。  
  
> [!NOTE]
>  成功完成发送并不表示数据已成功传递。 如果传输系统中没有可用于保存要传输的数据的缓冲区空间，则发送将会阻止，除非已将套接字置于非阻止模式。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[.NET Framework 中的网络跟踪](/dotnet/framework/network-programming/network-tracing)。  
  
   
  
## Examples  
 下面的代码示例结束挂起的异步发送。  
  
 [!code-cpp[Socket_Async_Send_Receive#6](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#6)]
 [!code-csharp[Socket_Async_Send_Receive#6](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#6)]
 [!code-vb[Socket_Async_Send_Receive#6](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">对 <see cref="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" /> 方法的调用未返回 <paramref name="asyncResult" />。</exception>
        <exception cref="T:System.InvalidOperationException">先前为异步发送已调用过 <see cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" />。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="P:System.IAsyncResult.AsyncState" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="F:System.Net.Sockets.SocketOptionName.NoDelay" />
      </Docs>
    </Member>
    <Member MemberName="EndSend">
      <MemberSignature Language="C#" Value="public int EndSend (IAsyncResult asyncResult, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndSend(class System.IAsyncResult asyncResult, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndSend (asyncResult As IAsyncResult, ByRef errorCode As SocketError) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndSend(IAsyncResult ^ asyncResult, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberSignature Language="F#" Value="member this.EndSend : IAsyncResult * SocketError -&gt; int" Usage="socket.EndSend (asyncResult, errorCode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult"><see cref="T:System.IAsyncResult" />，它存储此异步操作的状态信息。</param>
        <param name="errorCode">一个 <see cref="T:System.Net.Sockets.SocketError" /> 对象，它存储套接字错误。</param>
        <summary>结束挂起的异步发送。</summary>
        <returns>如果成功，则将返回向 <see cref="T:System.Net.Sockets.Socket" /> 发送的字节数；否则会返回无效 <see cref="T:System.Net.Sockets.Socket" /> 错误。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndSend%2A> 完成 <xref:System.Net.Sockets.Socket.BeginSend%2A>中启动的异步发送操作。  
  
 在调用 <xref:System.Net.Sockets.Socket.BeginSend%2A>之前，需要创建实现 <xref:System.AsyncCallback> 委托的回调方法。 此回调方法在单独的线程中执行，并在 <xref:System.Net.Sockets.Socket.BeginSend%2A> 返回后由系统调用。 回调方法必须接受 <xref:System.Net.Sockets.Socket.BeginSend%2A> 方法作为参数返回的 <xref:System.IAsyncResult>。  
  
 在回调方法中，调用 <xref:System.IAsyncResult> 参数的 <xref:System.IAsyncResult.AsyncState%2A> 方法以获取发送 <xref:System.Net.Sockets.Socket>。 获取 <xref:System.Net.Sockets.Socket>后，可以调用 <xref:System.Net.Sockets.Socket.EndSend%2A> 方法成功完成发送操作，并返回发送的字节数。  
  
 如果你使用的是无连接协议，则在发送数据报之前，<xref:System.Net.Sockets.Socket.EndSend%2A> 将会阻止。 如果你使用的是面向连接的协议，<xref:System.Net.Sockets.Socket.EndSend%2A> 会一直阻止，直到发送了某些缓冲区。 如果 <xref:System.Net.Sockets.Socket.EndSend%2A> 的返回值指示未完全发送缓冲区，请再次调用 <xref:System.Net.Sockets.Socket.BeginSend%2A> 方法，同时修改缓冲区以保存未发送的数据。  
  
 不能保证发送的数据会立即显示在网络上。 为了提高网络效率，基础系统可能会延迟传输，直到收集大量传出数据。 成功完成 <xref:System.Net.Sockets.Socket.BeginSend%2A> 方法意味着基础系统具有空间来缓冲用于网络发送的数据。  
  
> [!NOTE]
>  如果收到 <xref:System.Net.Sockets.SocketException>，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。 获取此代码后，请参阅[Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2)文档，以获取有关错误的详细说明。  
  
> [!NOTE]
>  给定线程启动的所有 i/o 都将在该线程退出时取消。 如果线程在操作完成之前退出，则挂起的异步操作可能会失败。  
  
> [!NOTE]
>  成功完成发送并不表示数据已成功传递。 如果传输系统中没有可用于保存要传输的数据的缓冲区空间，则发送将会阻止，除非已将套接字置于非阻止模式。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[.NET Framework 中的网络跟踪](/dotnet/framework/network-programming/network-tracing)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">对 <see cref="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" /> 方法的调用未返回 <paramref name="asyncResult" />。</exception>
        <exception cref="T:System.InvalidOperationException">先前为异步发送已调用过 <see cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" />。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="P:System.IAsyncResult.AsyncState" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="F:System.Net.Sockets.SocketOptionName.NoDelay" />
      </Docs>
    </Member>
    <Member MemberName="EndSendFile">
      <MemberSignature Language="C#" Value="public void EndSendFile (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EndSendFile(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndSendFile(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndSendFile (asyncResult As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EndSendFile(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="member this.EndSendFile : IAsyncResult -&gt; unit" Usage="socket.EndSendFile asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult"><see cref="T:System.IAsyncResult" /> 对象，它存储此异步操作的状态信息。</param>
        <summary>结束文件的挂起异步发送。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndSendFile%2A> 完成 <xref:System.Net.Sockets.Socket.BeginSendFile%2A>中启动的异步发送操作。  
  
 在调用 <xref:System.Net.Sockets.Socket.BeginSendFile%2A>之前，必须创建实现 <xref:System.AsyncCallback> 委托的回调方法。 此回调方法在单独的线程中执行，并在 <xref:System.Net.Sockets.Socket.BeginSendFile%2A> 返回后由系统调用。 回调方法必须接受 <xref:System.Net.Sockets.Socket.BeginSendFile%2A> 方法返回的 <xref:System.IAsyncResult> 对象作为参数。  
  
 在回调方法中，调用 <xref:System.IAsyncResult> 参数的 <xref:System.IAsyncResult.AsyncState%2A> 方法以获取发送 <xref:System.Net.Sockets.Socket>。 获取 <xref:System.Net.Sockets.Socket>后，可以调用 <xref:System.Net.Sockets.Socket.EndSendFile%2A> 方法成功完成发送操作。  
  
 如果使用的是无连接协议，则在发送数据报之前 <xref:System.Net.Sockets.Socket.EndSendFile%2A> 阻止。 如果使用面向连接的协议，则在发送整个文件之前 <xref:System.Net.Sockets.Socket.EndSendFile%2A> 会阻止。 不能保证发送的数据会立即显示在网络上。 为了提高网络效率，基础系统可能会延迟传输，直到收集大量传出数据。 成功完成 <xref:System.Net.Sockets.Socket.BeginSendFile%2A> 方法意味着基础系统具有空间来缓冲用于网络发送的数据。  
  
> [!NOTE]
>  如果收到 <xref:System.Net.Sockets.SocketException>，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。 获取此代码后，请参阅[Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2)文档，以获取有关错误的详细说明。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[.NET Framework 中的网络跟踪](/dotnet/framework/network-programming/network-tracing)。  
  
   
  
## Examples  
 下面的代码示例创建并连接套接字用于异步通信，并开始将文件 "test.txt" 异步发送到远程主机。 回调委托调用 <xref:System.Net.Sockets.Socket.EndSendFile%2A> 来完成传输。  
  
 [!code-cpp[NCLSocketEnhancements#9](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#9)]
 [!code-csharp[NCLSocketEnhancements#9](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">此方法需要 Windows NT。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 对象已关闭。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" /> 为空。</exception>
        <exception cref="T:System.ArgumentException">对 <see cref="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)" /> 方法的调用未返回 <paramref name="asyncResult" />。</exception>
        <exception cref="T:System.InvalidOperationException">先前曾为异步 <see cref="M:System.Net.Sockets.Socket.EndSendFile(System.IAsyncResult)" /> 调用过 <see cref="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)" />。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。 请参见下面的备注部分。</exception>
      </Docs>
    </Member>
    <Member MemberName="EndSendTo">
      <MemberSignature Language="C#" Value="public int EndSendTo (IAsyncResult asyncResult);" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndSendTo(class System.IAsyncResult asyncResult) cil managed" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndSendTo (asyncResult As IAsyncResult) As Integer" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndSendTo(IAsyncResult ^ asyncResult);" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.EndSendTo : IAsyncResult -&gt; int" Usage="socket.EndSendTo asyncResult" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public int EndSendTo (IAsyncResult result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndSendTo(class System.IAsyncResult result) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function EndSendTo (result As IAsyncResult) As Integer" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndSendTo(IAsyncResult ^ result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.EndSendTo : IAsyncResult -&gt; int" Usage="socket.EndSendTo result" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="result" Type="System.IAsyncResult" Index="0" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult"><see cref="T:System.IAsyncResult" />，它存储此异步操作的状态信息以及所有用户定义的数据。</param>
        <param name="result"><see cref="T:System.IAsyncResult" />，它存储此异步操作的状态信息以及所有用户定义的数据。</param>
        <summary>结束挂起的、向指定位置进行的异步发送。</summary>
        <returns>如果成功，则返回已发送的字节数；否则会返回无效 <see cref="T:System.Net.Sockets.Socket" /> 错误。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndSendTo%2A> 完成 <xref:System.Net.Sockets.Socket.BeginSendTo%2A>中启动的异步发送操作。  
  
 在调用 <xref:System.Net.Sockets.Socket.BeginSendTo%2A>之前，需要创建实现 <xref:System.AsyncCallback> 委托的回调方法。 此回调方法在单独的线程中执行，并在 <xref:System.Net.Sockets.Socket.BeginReceive%2A> 返回后由系统调用。 回调方法必须接受 <xref:System.Net.Sockets.Socket.BeginSendTo%2A> 方法作为参数返回的 <xref:System.IAsyncResult>。  
  
 在回调方法中，调用 <xref:System.IAsyncResult> 参数的 <xref:System.IAsyncResult.AsyncState%2A> 方法以获取发送 <xref:System.Net.Sockets.Socket>。 获取 <xref:System.Net.Sockets.Socket>后，可以调用 <xref:System.Net.Sockets.Socket.EndSendTo%2A> 方法成功完成发送操作，并返回发送的字节数。  
  
 如果你使用的是无连接协议，则在发送数据报之前，<xref:System.Net.Sockets.Socket.EndSendTo%2A> 将会阻止。 如果使用面向连接的协议，则在发送请求的字节数之前，将阻止 <xref:System.Net.Sockets.Socket.EndSendTo%2A>。 不能保证发送的数据会立即显示在网络上。 为了提高网络效率，基础系统可能会延迟传输，直到收集大量传出数据。 成功完成 <xref:System.Net.Sockets.Socket.BeginSendTo%2A> 方法意味着基础系统具有空间来缓冲用于网络发送的数据。  
  
> [!NOTE]
>  如果收到 <xref:System.Net.Sockets.SocketException>，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。 获取此代码后，请参阅[Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2)文档，以获取有关错误的详细说明。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[.NET Framework 中的网络跟踪](/dotnet/framework/network-programming/network-tracing)。  
  
   
  
## Examples  
 下面的代码示例结束了到特定位置的异步发送。  
  
 [!code-cpp[Socket_Async_Send_Receive#9](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#9)]
 [!code-csharp[Socket_Async_Send_Receive#9](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#9)]
 [!code-vb[Socket_Async_Send_Receive#9](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">对 <see cref="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)" /> 方法的调用未返回 <paramref name="asyncResult" />。</exception>
        <exception cref="T:System.InvalidOperationException">先前为异步发送已调用过 <see cref="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)" />。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
      </Docs>
    </Member>
    <Member MemberName="ExclusiveAddressUse">
      <MemberSignature Language="C#" Value="public bool ExclusiveAddressUse { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ExclusiveAddressUse" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.ExclusiveAddressUse" />
      <MemberSignature Language="VB.NET" Value="Public Property ExclusiveAddressUse As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ExclusiveAddressUse { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ExclusiveAddressUse : bool with get, set" Usage="System.Net.Sockets.Socket.ExclusiveAddressUse" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置 <see cref="T:System.Boolean" /> 值，该值指定 <see cref="T:System.Net.Sockets.Socket" /> 是否仅允许一个进程绑定到端口。</summary>
        <value>如果 <see cref="T:System.Net.Sockets.Socket" /> 仅允许一个套接字绑定到特定端口，则为 <see langword="true" />；否则为 <see langword="false" />。 对于 Windows Server 2003 和 Windows XP Service Pack 2，默认值为 <see langword="true" />，对于所有其他版本，则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果 `false`<xref:System.Net.Sockets.Socket.ExclusiveAddressUse%2A>，则多个套接字可以使用 <xref:System.Net.Sockets.Socket.Bind%2A> 方法绑定到特定端口;但只有一个套接字可以对发送到端口的网络流量执行操作。 如果有多个套接字尝试使用 <xref:System.Net.Sockets.Socket.Bind%28System.Net.EndPoint%29> 方法绑定到特定端口，则具有更具体的 IP 地址的套接字将处理发送到该端口的网络流量。  
  
 如果 `true`<xref:System.Net.Sockets.Socket.ExclusiveAddressUse%2A>，则第一次使用 <xref:System.Net.Sockets.Socket.Bind%2A> 方法尝试绑定到特定端口，而不管 Internet 协议（IP）地址如何，都将成功;在销毁原始绑定套接字之前，所有后续使用 <xref:System.Net.Sockets.Socket.Bind%2A> 方法尝试绑定到该端口都将失败。  
  
 必须先设置此属性，然后才能调用 <xref:System.Net.Sockets.Socket.Bind%2A>;否则，将引发 <xref:System.InvalidOperationException>。  
  
   
  
## Examples  
 下面的代码示例演示如何使用 <xref:System.Net.Sockets.Socket.ExclusiveAddressUse%2A> 属性。  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <exception cref="T:System.InvalidOperationException">已为此 <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> 调用了 <see cref="T:System.Net.Sockets.Socket" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~Socket ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!Socket ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="socket.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>释放 <see cref="T:System.Net.Sockets.Socket" /> 类使用的资源。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket> 类终结器调用 <xref:System.Net.Sockets.Socket.Close%2A> 方法来关闭与 <xref:System.Net.Sockets.Socket>关联的 <xref:System.Net.Sockets.Socket> 和释放资源。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="socket.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回 <see cref="T:System.Net.Sockets.Socket" /> 实例的哈希值。</summary>
        <returns>整数哈希值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks  
GetHashCode 方法返回此实例的哈希代码。 此值可用作哈希表中的键。

]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetRawSocketOption">
      <MemberSignature Language="C#" Value="public int GetRawSocketOption (int optionLevel, int optionName, Span&lt;byte&gt; optionValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetRawSocketOption(int32 optionLevel, int32 optionName, valuetype System.Span`1&lt;unsigned int8&gt; optionValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.GetRawSocketOption(System.Int32,System.Int32,System.Span{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Function GetRawSocketOption (optionLevel As Integer, optionName As Integer, optionValue As Span(Of Byte)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetRawSocketOption(int optionLevel, int optionName, Span&lt;System::Byte&gt; optionValue);" />
      <MemberSignature Language="F#" Value="member this.GetRawSocketOption : int * int * Span&lt;byte&gt; -&gt; int" Usage="socket.GetRawSocketOption (optionLevel, optionName, optionValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Int32" Index="0" FrameworkAlternate="net-5.0" />
        <Parameter Name="optionName" Type="System.Int32" Index="1" FrameworkAlternate="net-5.0" />
        <Parameter Name="optionValue" Type="System.Span&lt;System.Byte&gt;" Index="2" FrameworkAlternate="net-5.0" />
      </Parameters>
      <Docs>
        <param name="optionLevel">To be added.</param>
        <param name="optionName">To be added.</param>
        <param name="optionValue">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetSocketOption">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>返回 <see cref="T:System.Net.Sockets.Socket" /> 选项的值。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetSocketOption">
      <MemberSignature Language="C#" Value="public object GetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetSocketOption (optionLevel As SocketOptionLevel, optionName As SocketOptionName) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetSocketOption(System::Net::Sockets::SocketOptionLevel optionLevel, System::Net::Sockets::SocketOptionName optionName);" />
      <MemberSignature Language="F#" Value="member this.GetSocketOption : System.Net.Sockets.SocketOptionLevel * System.Net.Sockets.SocketOptionName -&gt; obj" Usage="socket.GetSocketOption (optionLevel, optionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="optionLevel"><see cref="T:System.Net.Sockets.SocketOptionLevel" /> 值之一。</param>
        <param name="optionName"><see cref="T:System.Net.Sockets.SocketOptionName" /> 值之一。</param>
        <summary>返回指定的 <see cref="T:System.Net.Sockets.Socket" /> 选项的值，表示为一个对象。</summary>
        <returns>一个对象，表示选项的值。 当将 <paramref name="optionName" /> 参数设置为 <see cref="F:System.Net.Sockets.SocketOptionName.Linger" /> 时，返回值为 <see cref="T:System.Net.Sockets.LingerOption" /> 类的一个实例。 当将 <paramref name="optionName" /> 设置为 <see cref="F:System.Net.Sockets.SocketOptionName.AddMembership" /> 或 <see cref="F:System.Net.Sockets.SocketOptionName.DropMembership" /> 时，返回值为 <see cref="T:System.Net.Sockets.MulticastOption" /> 类的一个实例。 当 <paramref name="optionName" /> 为其他任何值时，返回值为整数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket> 选项确定当前 <xref:System.Net.Sockets.Socket>的行为。 使用此重载获取 <xref:System.Net.Sockets.SocketOptionName.Linger>、<xref:System.Net.Sockets.SocketOptionName.AddMembership>和 <xref:System.Net.Sockets.SocketOptionName.DropMembership><xref:System.Net.Sockets.Socket> 选项。 对于 <xref:System.Net.Sockets.SocketOptionName.Linger> 选项，请对 `optionLevel` 参数使用 <xref:System.Net.Sockets.Socket>。 对于 <xref:System.Net.Sockets.SocketOptionName.AddMembership> 和 <xref:System.Net.Sockets.SocketOptionName.DropMembership>，请使用 <xref:System.Net.Sockets.SocketOptionLevel.IP>。 如果要设置上面列出的任何选项的值，请使用 <xref:System.Net.Sockets.Socket.SetSocketOption%2A> 方法。  
  
> [!NOTE]
>  如果收到 <xref:System.Net.Sockets.SocketException>，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。 获取此代码后，请参阅[Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2)文档，以获取有关错误的详细说明。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[.NET Framework 中的网络跟踪](/dotnet/framework/network-programming/network-tracing)。  
  
   
  
## Examples  
 下面的代码示例检索 <xref:System.Net.Sockets.LingerOption> 和 <xref:System.Net.Sockets.Socket.Send%2A> 超时值，并将其显示在控制台中。  
  
 [!code-cpp[Socket_Socket_Options#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#2)]
 [!code-csharp[Socket_Socket_Options#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#2)]
 [!code-vb[Socket_Socket_Options#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。  
  
-或- 
 <paramref name="optionName" /> 设置为不支持的值 <see cref="F:System.Net.Sockets.SocketOptionName.MaxConnections" />。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="T:System.Net.Sockets.SocketOptionName" />
        <altmember cref="T:System.Net.Sockets.SocketOptionLevel" />
      </Docs>
    </Member>
    <Member MemberName="GetSocketOption">
      <MemberSignature Language="C#" Value="public void GetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName, byte[] optionValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void GetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName, unsigned int8[] optionValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub GetSocketOption (optionLevel As SocketOptionLevel, optionName As SocketOptionName, optionValue As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void GetSocketOption(System::Net::Sockets::SocketOptionLevel optionLevel, System::Net::Sockets::SocketOptionName optionName, cli::array &lt;System::Byte&gt; ^ optionValue);" />
      <MemberSignature Language="F#" Value="member this.GetSocketOption : System.Net.Sockets.SocketOptionLevel * System.Net.Sockets.SocketOptionName * byte[] -&gt; unit" Usage="socket.GetSocketOption (optionLevel, optionName, optionValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="optionValue" Type="System.Byte[]" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="optionLevel"><see cref="T:System.Net.Sockets.SocketOptionLevel" /> 值之一。</param>
        <param name="optionName"><see cref="T:System.Net.Sockets.SocketOptionName" /> 值之一。</param>
        <param name="optionValue"><see cref="T:System.Byte" /> 类型的数组，用于接收选项设置。</param>
        <summary>返回指定的 <see cref="T:System.Net.Sockets.Socket" /> 选项设置，表示为字节数组。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket> 选项确定当前 <xref:System.Net.Sockets.Socket>的行为。 此方法成功完成后，`optionValue` 参数指定的数组包含指定 <xref:System.Net.Sockets.Socket> 选项的值。  
  
 如果 `optionValue` 数组的长度小于存储指定的 <xref:System.Net.Sockets.Socket> 选项的值所需的字节数，<xref:System.Net.Sockets.Socket.GetSocketOption%2A> 将引发 <xref:System.Net.Sockets.SocketException>。 如果收到 <xref:System.Net.Sockets.SocketException>，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。 获取此代码后，请参阅[Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2)文档，以获取有关错误的详细说明。 将此重载用于由布尔值或整数表示的任何套接字。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[.NET Framework 中的网络跟踪](/dotnet/framework/network-programming/network-tracing)。  
  
   
  
## Examples  
 下面的代码示例检索 <xref:System.Net.Sockets.LingerOption> 和 <xref:System.Net.Sockets.Socket.Send%2A> 超时值，并将其显示在控制台中。  
  
 [!code-cpp[Socket_Socket_Options#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#2)]
 [!code-csharp[Socket_Socket_Options#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#2)]
 [!code-vb[Socket_Socket_Options#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。  
  
-或- 
在 .NET Compact Framework 应用程序中，Windows CE 默认缓冲区的空间被设置为 32768 字节。 通过调用 <see cref="Overload:System.Net.Sockets.Socket.SetSocketOption" />，可以更改每个套接字缓冲区的空间。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="T:System.Net.Sockets.SocketOptionName" />
        <altmember cref="T:System.Net.Sockets.SocketOptionLevel" />
      </Docs>
    </Member>
    <Member MemberName="GetSocketOption">
      <MemberSignature Language="C#" Value="public byte[] GetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName, int optionLength);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8[] GetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName, int32 optionLength) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetSocketOption (optionLevel As SocketOptionLevel, optionName As SocketOptionName, optionLength As Integer) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Byte&gt; ^ GetSocketOption(System::Net::Sockets::SocketOptionLevel optionLevel, System::Net::Sockets::SocketOptionName optionName, int optionLength);" />
      <MemberSignature Language="F#" Value="member this.GetSocketOption : System.Net.Sockets.SocketOptionLevel * System.Net.Sockets.SocketOptionName * int -&gt; byte[]" Usage="socket.GetSocketOption (optionLevel, optionName, optionLength)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="optionLength" Type="System.Int32" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="optionLevel"><see cref="T:System.Net.Sockets.SocketOptionLevel" /> 值之一。</param>
        <param name="optionName"><see cref="T:System.Net.Sockets.SocketOptionName" /> 值之一。</param>
        <param name="optionLength">所需返回值的长度（以字节为单位）。</param>
        <summary>返回数组中指定的 <see cref="T:System.Net.Sockets.Socket" /> 选项的值。</summary>
        <returns><see cref="T:System.Byte" /> 类型的数组，它包含套接字选项的值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `optionLength` 参数设置返回的字节数组的最大大小。 如果选项值需要较少的字节，则数组只包含很多字节。 如果选项值需要更多字节，<xref:System.Net.Sockets.Socket.GetSocketOption%2A> 将引发 <xref:System.Net.Sockets.SocketException>。 将此重载用于由布尔值或整数表示的任何套接字。  
  
> [!NOTE]
>  如果收到 <xref:System.Net.Sockets.SocketException>，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。 获取此代码后，请参阅[Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2)文档，以获取有关错误的详细说明。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[.NET Framework 中的网络跟踪](/dotnet/framework/network-programming/network-tracing)。  
  
   
  
## Examples  
 下面的代码示例检索 <xref:System.Net.Sockets.LingerOption> 和 <xref:System.Net.Sockets.Socket.Send%2A> 超时值，并将其显示在控制台中。  
  
 [!code-cpp[Socket_Socket_Options#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#2)]
 [!code-csharp[Socket_Socket_Options#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#2)]
 [!code-vb[Socket_Socket_Options#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。  
  
-或- 
在 .NET Compact Framework 应用程序中，Windows CE 默认缓冲区的空间被设置为 32768 字节。 通过调用 <see cref="Overload:System.Net.Sockets.Socket.SetSocketOption" />，可以更改每个套接字缓冲区的空间。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="T:System.Net.Sockets.SocketOptionName" />
        <altmember cref="T:System.Net.Sockets.SocketOptionLevel" />
      </Docs>
    </Member>
    <Member MemberName="Handle">
      <MemberSignature Language="C#" Value="public IntPtr Handle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int Handle" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.Handle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Handle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr Handle { IntPtr get(); };" />
      <MemberSignature Language="F#" Value="member this.Handle : nativeint" Usage="System.Net.Sockets.Socket.Handle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取 <see cref="T:System.Net.Sockets.Socket" /> 的操作系统句柄。</summary>
        <value>一个 <see cref="T:System.IntPtr" />，它表示 <see cref="T:System.Net.Sockets.Socket" /> 的操作系统句柄。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="IOControl">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>为 <see cref="T:System.Net.Sockets.Socket" /> 设置低级别操作模式。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IOControl">
      <MemberSignature Language="C#" Value="public int IOControl (int ioControlCode, byte[] optionInValue, byte[] optionOutValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IOControl(int32 ioControlCode, unsigned int8[] optionInValue, unsigned int8[] optionOutValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.IOControl(System.Int32,System.Byte[],System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Function IOControl (ioControlCode As Integer, optionInValue As Byte(), optionOutValue As Byte()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IOControl(int ioControlCode, cli::array &lt;System::Byte&gt; ^ optionInValue, cli::array &lt;System::Byte&gt; ^ optionOutValue);" />
      <MemberSignature Language="F#" Value="member this.IOControl : int * byte[] * byte[] -&gt; int" Usage="socket.IOControl (ioControlCode, optionInValue, optionOutValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ioControlCode" Type="System.Int32" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="optionInValue" Type="System.Byte[]" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="optionOutValue" Type="System.Byte[]" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="ioControlCode">一个 <see cref="T:System.Int32" /> 值，该值指定要执行的操作的控制代码。</param>
        <param name="optionInValue">一个 <see cref="T:System.Byte" /> 数组，它包含操作需要的输入数据。</param>
        <param name="optionOutValue">一个 <see cref="T:System.Byte" /> 数组，它包含操作返回的输出数据。</param>
        <summary>使用数字控制代码，为 <see cref="T:System.Net.Sockets.Socket" /> 设置低级操作模式。</summary>
        <returns><paramref name="optionOutValue" /> 参数中的字节数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.IOControl%2A> 方法提供对 <xref:System.Net.Sockets.Socket> <xref:System.Net.Sockets.Socket> 类的当前实例所基于的操作系统的低级访问。 有关详细信息，请参阅[WSAIoctl](/windows/win32/api/winsock2/nf-winsock2-wsaioctl)文档。  
  
> [!NOTE]
>  如果收到 <xref:System.Net.Sockets.SocketException>，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。 获取此代码后，请参阅[Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2)文档，以获取有关错误的详细说明。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[.NET Framework 中的网络跟踪](/dotnet/framework/network-programming/network-tracing)。  
  
   
  
## Examples  
 下面的代码示例将 FIONREAD 和可用属性的结果进行比较。  
  
 [!code-cpp[NCLSocketIoControl#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketIoControl/CPP/iocontrolserver.cpp#1)]
 [!code-csharp[NCLSocketIoControl#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketIoControl/CS/iocontrolserver.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <exception cref="T:System.InvalidOperationException">尝试不使用 <see cref="P:System.Net.Sockets.Socket.Blocking" /> 属性更改阻止模式。</exception>
        <exception cref="T:System.Security.SecurityException">调用堆栈中的调用方没有所需的权限。</exception>
      </Docs>
    </Member>
    <Member MemberName="IOControl">
      <MemberSignature Language="C#" Value="public int IOControl (System.Net.Sockets.IOControlCode ioControlCode, byte[] optionInValue, byte[] optionOutValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IOControl(valuetype System.Net.Sockets.IOControlCode ioControlCode, unsigned int8[] optionInValue, unsigned int8[] optionOutValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.IOControl(System.Net.Sockets.IOControlCode,System.Byte[],System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Function IOControl (ioControlCode As IOControlCode, optionInValue As Byte(), optionOutValue As Byte()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IOControl(System::Net::Sockets::IOControlCode ioControlCode, cli::array &lt;System::Byte&gt; ^ optionInValue, cli::array &lt;System::Byte&gt; ^ optionOutValue);" />
      <MemberSignature Language="F#" Value="member this.IOControl : System.Net.Sockets.IOControlCode * byte[] * byte[] -&gt; int" Usage="socket.IOControl (ioControlCode, optionInValue, optionOutValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ioControlCode" Type="System.Net.Sockets.IOControlCode" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="optionInValue" Type="System.Byte[]" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="optionOutValue" Type="System.Byte[]" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="ioControlCode">一个 <see cref="T:System.Net.Sockets.IOControlCode" /> 值，它指定要执行的操作的控制代码。</param>
        <param name="optionInValue"><see cref="T:System.Byte" /> 类型的数组，包含操作要求的输入数据。</param>
        <param name="optionOutValue"><see cref="T:System.Byte" /> 类型的数组，包含由操作返回的输出数据。</param>
        <summary>使用 <see cref="T:System.Net.Sockets.Socket" /> 枚举指定控制代码，为 <see cref="T:System.Net.Sockets.IOControlCode" /> 设置低级操作模式。</summary>
        <returns><paramref name="optionOutValue" /> 参数中的字节数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法提供对 <xref:System.Net.Sockets.Socket> 类的当前实例 <xref:System.Net.Sockets.Socket> 基础的操作系统的低级访问。 有关详细信息，请参阅[WSAIoctl](/windows/win32/api/winsock2/nf-winsock2-wsaioctl)文档。  
  
> [!NOTE]
>  如果收到 <xref:System.Net.Sockets.SocketException>，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。 获取此代码后，请参阅[Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2)文档，以获取有关错误的详细说明。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[.NET Framework 中的网络跟踪](/dotnet/framework/network-programming/network-tracing)。  
  
   
  
## Examples  
 下面的代码示例将调用 <xref:System.Net.Sockets.Socket.IOControl%2A> 的结果与 <xref:System.Net.Sockets.IOControlCode.DataToRead> 和 <xref:System.Net.Sockets.Socket.Available%2A> 属性进行比较。  
  
 [!code-cpp[NCLSocketIoControl1#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketIoControl1/CPP/iocontrolcode.cpp#1)]
 [!code-csharp[NCLSocketIoControl1#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketIoControl1/CS/iocontrolcode.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <exception cref="T:System.InvalidOperationException">尝试不使用 <see cref="P:System.Net.Sockets.Socket.Blocking" /> 属性更改阻止模式。</exception>
      </Docs>
    </Member>
    <Member MemberName="IsBound">
      <MemberSignature Language="C#" Value="public bool IsBound { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsBound" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.IsBound" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsBound As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsBound { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsBound : bool" Usage="System.Net.Sockets.Socket.IsBound" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示 <see cref="T:System.Net.Sockets.Socket" /> 是否绑定到特定本地端口。</summary>
        <value>如果 <see cref="T:System.Net.Sockets.Socket" /> 绑定到本地端口，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果套接字是通过调用 <xref:System.Net.Sockets.Socket.Bind%2A> 方法显式绑定的，或者通过调用 <xref:System.Net.Sockets.Socket.Connect%2A>、<xref:System.Net.Sockets.Socket.SendTo%2A>或 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>的成员（如操作系统选择的免费端口大于1024），则将套接字视为绑定到本地端口。服务器使用 <xref:System.Net.Sockets.Socket.Bind%2A> 方法绑定到众所周知的端口，以便客户端可以连接到它们。  
  
   
  
## Examples  
 下面的代码示例演示如何使用 <xref:System.Net.Sockets.Socket.IsBound%2A> 属性。  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LingerState">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.LingerOption LingerState { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.Sockets.LingerOption LingerState" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.LingerState" />
      <MemberSignature Language="VB.NET" Value="Public Property LingerState As LingerOption" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Sockets::LingerOption ^ LingerState { System::Net::Sockets::LingerOption ^ get(); void set(System::Net::Sockets::LingerOption ^ value); };" />
      <MemberSignature Language="F#" Value="member this.LingerState : System.Net.Sockets.LingerOption with get, set" Usage="System.Net.Sockets.Socket.LingerState" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.LingerOption</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指定 <see cref="T:System.Net.Sockets.Socket" /> 在尝试发送所有挂起数据时是否延迟关闭套接字。</summary>
        <value>一个 <see cref="T:System.Net.Sockets.LingerOption" />，它指定关闭套接字时如何逗留。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.LingerState%2A> 属性更改 <xref:System.Net.Sockets.Socket.Close%2A> 方法行为的方式。 设置此属性时，此属性修改 Winsock 可以重置连接时的条件。 仍然可以基于 IP 协议行为重置连接。  
  
 此属性控制在数据保留时，连接到 <xref:System.Net.Sockets.Socket.Close%2A> 后，面向连接的连接将保持打开状态的时间长度。  
  
 调用方法将数据发送到对等节点时，此数据将被置于传出网络缓冲区中。 此属性可用于确保在 <xref:System.Net.Sockets.TcpClient.Close%2A> 方法断开连接之前，将此数据发送到远程主机。  
  
 若要启用延迟，请创建包含所需值的 <xref:System.Net.Sockets.LingerOption> 实例，并将 <xref:System.Net.Sockets.Socket.LingerState%2A> 属性设置为此实例。  
  
 下表描述了 <xref:System.Net.Sockets.LingerOption.Enabled%2A> 属性的可能值和 <xref:System.Net.Sockets.Socket.LingerState%2A> 属性中存储的 <xref:System.Net.Sockets.LingerOption.LingerTime%2A> 属性的 <xref:System.Net.Sockets.Socket.Close%2A> 方法的行为。  
  
|LingerState.Enabled|LingerState.LingerTime|行为|  
|-------------------------|----------------------------|--------------|  
|`false` （已禁用），默认值为|超时不适用，（默认值）。|在默认 IP 协议超时过期之前，尝试发送挂起的数据。|  
|`true` （已启用）|非零超时|尝试发送挂起的数据直到指定的超时过期，如果尝试失败，Winsock 将重置连接。|  
|`true` （已启用）|零超时。|丢弃所有挂起的数据。 对于面向连接的套接字（例如 TCP），Winsock 重置连接。|  
  
 IP 堆栈根据连接的往返时间来计算要使用的默认 IP 协议超时期限。 在大多数情况下，堆栈计算出的超时比应用程序定义的超时更密切。 这是未设置 <xref:System.Net.Sockets.Socket.LingerState%2A> 属性时套接字的默认行为。  
  
 如果在 <xref:System.Net.Sockets.Socket.LingerState%2A> 属性中存储的 <xref:System.Net.Sockets.LingerOption.LingerTime%2A> 属性设置为大于默认 IP 协议超时值，则默认的 IP 协议超时将仍适用并将替代。  
  
   
  
## Examples  
 下面的代码示例演示如何使用 <xref:System.Net.Sockets.Socket.LingerState%2A> 属性。  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
      </Docs>
    </Member>
    <Member MemberName="Listen">
      <MemberSignature Language="C#" Value="public void Listen ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Listen() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Listen" />
      <MemberSignature Language="VB.NET" Value="Public Sub Listen ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Listen();" />
      <MemberSignature Language="F#" Value="member this.Listen : unit -&gt; unit" Usage="socket.Listen " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Listen">
      <MemberSignature Language="C#" Value="public void Listen (int backlog);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Listen(int32 backlog) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Listen(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Listen (backlog As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Listen(int backlog);" />
      <MemberSignature Language="F#" Value="member this.Listen : int -&gt; unit" Usage="socket.Listen backlog" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="backlog" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="backlog">挂起连接队列的最大长度。</param>
        <summary>将 <see cref="T:System.Net.Sockets.Socket" /> 置于侦听状态。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Listen%2A> 会导致面向连接的 <xref:System.Net.Sockets.Socket> 侦听传入的连接尝试。 `backlog` 参数指定可以排队等待接受的传入连接的数量。 若要确定可以指定的最大连接数，请检索 <xref:System.Net.Sockets.SocketOptionName.MaxConnections> 值。 <xref:System.Net.Sockets.Socket.Listen%2A> 不会阻止。  
  
 如果收到 <xref:System.Net.Sockets.SocketException>，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A> 属性获取特定的错误代码。 获取此代码后，请参阅[Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2)文档，以获取有关错误的详细说明。 使用 <xref:System.Net.Sockets.Socket.Accept%2A> 或 <xref:System.Net.Sockets.Socket.BeginAccept%2A> 接受队列中的连接。  
  
> [!NOTE]
>  必须先调用 <xref:System.Net.Sockets.Socket.Bind%2A> 方法，然后才能调用 <xref:System.Net.Sockets.Socket.Listen%2A>或 <xref:System.Net.Sockets.Socket.Listen%2A> 将引发 <xref:System.Net.Sockets.SocketException>。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[.NET Framework 中的网络跟踪](/dotnet/framework/network-programming/network-tracing)。  
  
> [!NOTE]
>  积压工作（backlog）参数限制为不同的值，具体取决于操作系统。 您可以指定较大的值，但积压工作（backlog）将基于操作系统进行限制。  
  
   
  
## Examples  
 下面的代码示例使用 <xref:System.Net.Sockets.Socket> 侦听传入连接。  
  
 [!code-cpp[Classic Socket.Listen Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Listen Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Listen Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Listen Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Listen Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Listen Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <altmember cref="F:System.Net.Sockets.SocketOptionName.MaxConnections" />
        <altmember cref="M:System.Net.Sockets.Socket.Accept" />
        <altmember cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
      </Docs>
    </Member>
    <Member MemberName="LocalEndPoint">
      <MemberSignature Language="C#" Value="public System.Net.EndPoint LocalEndPoint { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.EndPoint LocalEndPoint" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.LocalEndPoint" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LocalEndPoint As EndPoint" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::EndPoint ^ LocalEndPoint { System::Net::EndPoint ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.LocalEndPoint : System.Net.EndPoint" Usage="System.Net.Sockets.Socket.LocalEndPoint" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.EndPoint</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取本地终结点。</summary>
        <value><see cref="T:System.Net.EndPoint" /> 当前用以进行通信的 <see cref="T:System.Net.Sockets.Socket" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> 属性获取一个 <xref:System.Net.EndPoint>，其中包含 <xref:System.Net.Sockets.Socket> 绑定到的本地 IP 地址和端口号。 在检索任何信息之前，必须将此 <xref:System.Net.EndPoint> 强制转换为 <xref:System.Net.IPEndPoint>。 然后，可以调用 <xref:System.Net.IPEndPoint.Address%2A?displayProperty=nameWithType> 方法检索本地 <xref:System.Net.IPAddress>，并调用 <xref:System.Net.IPEndPoint.Port%2A?displayProperty=nameWithType> 方法来检索本地端口号。  
  
 <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> 属性通常是在调用 <xref:System.Net.Sockets.Socket.Bind%2A> 方法之后设置的。 如果允许系统分配套接字的本地 IP 地址和端口号，则在第一次 i/o 操作之后将设置 <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> 属性。 对于面向连接的协议，第一个 i/o 操作将是对 <xref:System.Net.Sockets.Socket.Connect%2A> 或 <xref:System.Net.Sockets.Socket.Accept%2A> 方法的调用。 对于无连接协议，第一个 i/o 操作将是任何发送或接收调用。  
  
> [!NOTE]
>  如果收到 <xref:System.Net.Sockets.SocketException>，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。 获取此代码后，请参阅[Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2)文档，以获取有关错误的详细说明。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[.NET Framework 中的网络跟踪](/dotnet/framework/network-programming/network-tracing)。  
  
   
  
## Examples  
 下面的代码示例检索并显示本地和远程终结点。  
  
 [!code-cpp[Socket_Socket_Options#4](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#4)]
 [!code-csharp[Socket_Socket_Options#4](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#4)]
 [!code-vb[Socket_Socket_Options#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <altmember cref="T:System.Net.EndPoint" />
        <altmember cref="T:System.Net.IPEndPoint" />
        <altmember cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
      </Docs>
    </Member>
    <Member MemberName="MulticastLoopback">
      <MemberSignature Language="C#" Value="public bool MulticastLoopback { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool MulticastLoopback" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.MulticastLoopback" />
      <MemberSignature Language="VB.NET" Value="Public Property MulticastLoopback As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool MulticastLoopback { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.MulticastLoopback : bool with get, set" Usage="System.Net.Sockets.Socket.MulticastLoopback" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指定传出的多路广播数据包是否传递到发送应用程序。</summary>
        <value>如果 <see cref="T:System.Net.Sockets.Socket" /> 接收传出的多路广播数据包，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 多播是 Internet 上多对多通信的可扩展方法。 进程订阅多路广播地址;然后，由订阅的进程发送的任何数据包都由订阅了多播地址的每个其他进程接收。  
  
 对传输控制协议（TCP）套接字设置此属性将不起任何作用。  
  
   
  
## Examples  
 下面的代码示例演示如何使用 <xref:System.Net.Sockets.Socket.MulticastLoopback%2A> 属性。  
  
 [!code-cpp[SocketPropertyTester#2](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#2)]
 [!code-csharp[SocketPropertyTester#2](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
      </Docs>
    </Member>
    <Member MemberName="NoDelay">
      <MemberSignature Language="C#" Value="public bool NoDelay { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool NoDelay" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.NoDelay" />
      <MemberSignature Language="VB.NET" Value="Public Property NoDelay As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool NoDelay { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.NoDelay : bool with get, set" Usage="System.Net.Sockets.Socket.NoDelay" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置 <see cref="T:System.Boolean" /> 值，该值指定流 <see cref="T:System.Net.Sockets.Socket" /> 是否正在使用 Nagle 算法。</summary>
        <value>如果 <see cref="T:System.Net.Sockets.Socket" /> 使用 Nagle 算法，则为 <see langword="false" />；否则为 <see langword="true" />。 默认为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nagle 算法旨在通过使套接字缓冲小数据包，然后在特定情况下将它们合并并发送到一个数据包，从而减少网络流量。 TCP 数据包包含40字节的标头以及要发送的数据。 当使用 TCP 发送小型数据包时，TCP 标头产生的开销可能会成为网络流量的重要部分。 在负载较重的网络上，由于这种开销导致的拥塞会导致丢失数据报和重新传输，以及拥塞导致的传播时间过大。 如果在连接上以前传输的数据保持未确认的情况，则 Nagle 算法将禁止发送新的 TCP 段。  
  
 大多数网络应用程序都应使用 Nagle 算法。  
  
 在用户数据报协议（UDP）套接字上设置此属性将不起作用。  
  
   
  
## Examples  
 下面的代码示例演示如何使用 <xref:System.Net.Sockets.Socket.NoDelay%2A> 属性。  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问 <see cref="T:System.Net.Sockets.Socket" /> 时出错。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
      </Docs>
    </Member>
    <Member MemberName="OSSupportsIPv4">
      <MemberSignature Language="C#" Value="public static bool OSSupportsIPv4 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool OSSupportsIPv4" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.OSSupportsIPv4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property OSSupportsIPv4 As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool OSSupportsIPv4 { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.OSSupportsIPv4 : bool" Usage="System.Net.Sockets.Socket.OSSupportsIPv4" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指示基础操作系统和网络适配器是否支持 Internet 协议第 4 版 (IPv4)。</summary>
        <value>如果操作系统和网络适配器支持 IPv4 协议，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 操作系统可能支持 IPv4 和 IPv6 协议。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Net.Sockets.Socket.OSSupportsIPv6" />
      </Docs>
    </Member>
    <Member MemberName="OSSupportsIPv6">
      <MemberSignature Language="C#" Value="public static bool OSSupportsIPv6 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool OSSupportsIPv6" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.OSSupportsIPv6" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property OSSupportsIPv6 As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool OSSupportsIPv6 { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.OSSupportsIPv6 : bool" Usage="System.Net.Sockets.Socket.OSSupportsIPv6" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指示基础操作系统和网络适配器是否支持 Internet 协议第 6 版 (IPv6)。</summary>
        <value>如果操作系统和网络适配器支持 IPv6 协议，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 操作系统可能支持 IPv4 和 IPv6 协议。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Net.Sockets.Socket.OSSupportsIPv4" />
      </Docs>
    </Member>
    <Member MemberName="OSSupportsUnixDomainSockets">
      <MemberSignature Language="C#" Value="public static bool OSSupportsUnixDomainSockets { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool OSSupportsUnixDomainSockets" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.OSSupportsUnixDomainSockets" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property OSSupportsUnixDomainSockets As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool OSSupportsUnixDomainSockets { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.OSSupportsUnixDomainSockets : bool" Usage="System.Net.Sockets.Socket.OSSupportsUnixDomainSockets" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Poll">
      <MemberSignature Language="C#" Value="public bool Poll (int microSeconds, System.Net.Sockets.SelectMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Poll(int32 microSeconds, valuetype System.Net.Sockets.SelectMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)" />
      <MemberSignature Language="VB.NET" Value="Public Function Poll (microSeconds As Integer, mode As SelectMode) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Poll(int microSeconds, System::Net::Sockets::SelectMode mode);" />
      <MemberSignature Language="F#" Value="member this.Poll : int * System.Net.Sockets.SelectMode -&gt; bool" Usage="socket.Poll (microSeconds, mode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="microSeconds" Type="System.Int32" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="mode" Type="System.Net.Sockets.SelectMode" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="microSeconds">等待响应的时间（以微秒为单位）。</param>
        <param name="mode"><see cref="T:System.Net.Sockets.SelectMode" /> 值之一。</param>
        <summary>确定 <see cref="T:System.Net.Sockets.Socket" /> 的状态。</summary>
        <returns>基于 <paramref name="mode" /> 参数中传递的轮询模式值的 <see cref="T:System.Net.Sockets.Socket" /> 的状态。  
  
 <list type="table"><listheader><term> “模式” 
 </term><description> 返回值 
 </description></listheader><item><term><see cref="F:System.Net.Sockets.SelectMode.SelectRead" /></term><description>如果已调用 <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> 并且有挂起的连接，则为 <see langword="true" />。 
-或- 
 如果有数据可供读取，则为 <see langword="true" />。 
-或- 
 如果连接已关闭、重置或终止，则返回 <see langword="true" />； 
否则，返回 <see langword="false" />。  
  
 </description></item><item><term><see cref="F:System.Net.Sockets.SelectMode.SelectWrite" /></term><description>如果正在处理 <see cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" /> 并且连接已成功，则为 <see langword="true" />； 
-或- 
 如果可以发送数据，则返回 <see langword="true" />； 
否则，返回 <see langword="false" />。  
  
 </description></item><item><term><see cref="F:System.Net.Sockets.SelectMode.SelectError" /></term><description>如果正在处理不阻止的 <see cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />，并且连接已失败，则为 <see langword="true" />； 
-或- 
 如果 <see cref="F:System.Net.Sockets.SocketOptionName.OutOfBandInline" /> 未设置，并且带外数据可用，则为 <see langword="true" />； 
否则，返回 <see langword="false" />。  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Poll%2A> 方法将检查 <xref:System.Net.Sockets.Socket>的状态。 指定 `selectMode` 参数 <xref:System.Net.Sockets.SelectMode.SelectRead?displayProperty=nameWithType>，以确定 <xref:System.Net.Sockets.Socket> 是否可读。 指定 <xref:System.Net.Sockets.SelectMode.SelectWrite?displayProperty=nameWithType> 确定 <xref:System.Net.Sockets.Socket> 是否可写。 使用 <xref:System.Net.Sockets.SelectMode.SelectError?displayProperty=nameWithType> 检测错误条件。 <xref:System.Net.Sockets.Socket.Poll%2A> 将阻止执行到指定时间段（以 `microseconds`为单位）。 如果要无限期等待响应，请将 `microSeconds` 参数设置为负整数。 如果要检查多个套接字的状态，可能更倾向于使用 <xref:System.Net.Sockets.Socket.Select%2A> 方法。  
  
> [!NOTE]
>  如果收到 <xref:System.Net.Sockets.SocketException>，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。 获取此代码后，请参阅[Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2)文档，以获取有关错误的详细说明。  
  
> [!NOTE]
>  此方法无法检测某些类型的连接问题，例如网络电缆损坏或远程主机已关闭意外。 您必须尝试发送或接收数据，以检测这些类型的错误。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[.NET Framework 中的网络跟踪](/dotnet/framework/network-programming/network-tracing)。  
  
   
  
## Examples  
 下面的代码示例创建套接字，连接到服务器，并使用 <xref:System.Net.Sockets.Socket.Poll%2A> 来检查套接字的状态。  
  
 [!code-cpp[SelectModeExample#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SelectModeExample/CPP/source.cpp#1)]
 [!code-csharp[SelectModeExample#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SelectModeExample/CS/source.cs#1)]
 [!code-vb[SelectModeExample#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/SelectModeExample/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><paramref name="mode" /> 参数不是一个 <see cref="T:System.Net.Sockets.SelectMode" /> 值。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。 请参阅下面的备注。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <altmember cref="T:System.Net.Sockets.SelectMode" />
        <altmember cref="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)" />
      </Docs>
    </Member>
    <Member MemberName="ProtocolType">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.ProtocolType ProtocolType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Net.Sockets.ProtocolType ProtocolType" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.ProtocolType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ProtocolType As ProtocolType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Sockets::ProtocolType ProtocolType { System::Net::Sockets::ProtocolType get(); };" />
      <MemberSignature Language="F#" Value="member this.ProtocolType : System.Net.Sockets.ProtocolType" Usage="System.Net.Sockets.Socket.ProtocolType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.ProtocolType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取 <see cref="T:System.Net.Sockets.Socket" /> 的协议类型。</summary>
        <value><see cref="T:System.Net.Sockets.ProtocolType" /> 值之一。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.ProtocolType%2A> 属性在创建 <xref:System.Net.Sockets.Socket> 时设置，并指定该 <xref:System.Net.Sockets.Socket>所使用的协议。  
  
   
  
## Examples  
 下面的代码示例显示控制台 <xref:System.Net.Sockets.AddressFamily>、<xref:System.Net.Sockets.SocketType>和 <xref:System.Net.Sockets.ProtocolType>。  
  
 [!code-cpp[Socket_Socket_Options#3](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#3)]
 [!code-csharp[Socket_Socket_Options#3](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#3)]
 [!code-vb[Socket_Socket_Options#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Receive">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>接收来自绑定的 <see cref="T:System.Net.Sockets.Socket" /> 的数据。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (byte[] buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(unsigned int8[] buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (buffer As Byte()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(cli::array &lt;System::Byte&gt; ^ buffer);" />
      <MemberSignature Language="F#" Value="member this.Receive : byte[] -&gt; int" Usage="socket.Receive buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="buffer"><see cref="T:System.Byte" /> 类型的数组，它是存储接收到的数据的位置。</param>
        <summary>从绑定的 <see cref="T:System.Net.Sockets.Socket" /> 套接字接收数据，将数据存入接收缓冲区。</summary>
        <returns>收到的字节数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Receive%2A> 方法将数据读入 buffer 参数，并返回成功读取的字节数。 可从面向连接的套接字和无连接套接字调用 <xref:System.Net.Sockets.Socket.Receive%2A>。  
  
 此重载只要求你提供接收缓冲区。 缓冲区偏移量默认为0，大小默认为 buffer 参数的长度，<xref:System.Net.Sockets.SocketFlags> 值默认为 <xref:System.Net.Sockets.SocketFlags.None>。  
  
 如果使用面向连接的协议，则必须调用 <xref:System.Net.Sockets.Socket.Connect%2A> 以建立远程主机连接，或在调用 <xref:System.Net.Sockets.Socket.Receive%2A>之前 <xref:System.Net.Sockets.Socket.Accept%2A> 接受传入连接。 <xref:System.Net.Sockets.Socket.Receive%2A> 方法将只读取从在 <xref:System.Net.Sockets.Socket.Connect%2A> 或 <xref:System.Net.Sockets.Socket.Accept%2A> 方法中建立的远程主机到达的数据。 如果使用的是无连接协议，则还可以使用 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 方法。 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 允许接收来自任何主机的数据。  
  
 如果没有可供读取的数据，则在数据可用之前，将阻止 <xref:System.Net.Sockets.Socket.Receive%2A> 方法，除非使用 <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>设置了超时值。 如果超过超时值，则 <xref:System.Net.Sockets.Socket.Receive%2A> 调用将引发 <xref:System.Net.Sockets.SocketException>。 如果处于非阻止模式，并且协议堆栈缓冲区中没有可用的数据，则 <xref:System.Net.Sockets.Socket.Receive%2A> 方法将立即完成，并引发 <xref:System.Net.Sockets.SocketException>。 您可以使用 <xref:System.Net.Sockets.Socket.Available%2A> 属性来确定数据是否可用于读取。 如果 <xref:System.Net.Sockets.Socket.Available%2A> 非零，则重试接收操作。  
  
 如果使用面向连接的 <xref:System.Net.Sockets.Socket>，<xref:System.Net.Sockets.Socket.Receive%2A> 方法将读取尽可能多的数据，直到达到缓冲区的大小。 如果远程主机使用 <xref:System.Net.Sockets.Socket.Shutdown%2A> 方法关闭 <xref:System.Net.Sockets.Socket> 连接，并且收到所有可用数据，则 <xref:System.Net.Sockets.Socket.Receive%2A> 方法会立即完成并返回零字节。  
  
 如果你使用的是无连接 <xref:System.Net.Sockets.Socket>，则 <xref:System.Net.Sockets.Socket.Receive%2A> 将从你在 <xref:System.Net.Sockets.Socket.Connect%2A> 方法中指定的目标地址读取第一个排队的数据报。 如果接收的数据报大于 `buffer` 参数的大小，则 `buffer` 会填充消息的第一部分，超过的数据将会丢失，并引发 <xref:System.Net.Sockets.SocketException>。  
  
> [!NOTE]
>  如果收到 <xref:System.Net.Sockets.SocketException>，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。 获取此代码后，请参阅[Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2)文档，以获取有关错误的详细说明。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[.NET Framework 中的网络跟踪](/dotnet/framework/network-programming/network-tracing)。  
  
   
  
## Examples  
 下面的代码示例接收已连接 <xref:System.Net.Sockets.Socket>上的数据。  
  
 [!code-cpp[Socket_Sync_Send_Receive#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#1)]
 [!code-csharp[Socket_Sync_Send_Receive#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#1)]
 [!code-vb[Socket_Sync_Send_Receive#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <exception cref="T:System.Security.SecurityException">调用堆栈中的调用方没有所需的权限。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (buffers As IList(Of ArraySegment(Of Byte))) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers);" />
      <MemberSignature Language="F#" Value="member this.Receive : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; -&gt; int" Usage="socket.Receive buffers" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="buffers"><see cref="T:System.ArraySegment`1" /> 类型的一个 <see cref="T:System.Byte" /> 列表，包含接收的数据。</param>
        <summary>从绑定的 <see cref="T:System.Net.Sockets.Socket" /> 接收数据，将数据存入接收缓冲区列表中。</summary>
        <returns>收到的字节数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法将数据读取到缓冲区参数，并返回成功读取的字节数。 可从面向连接的套接字和无连接套接字调用。  
  
 此重载要求提供一个或多个接收缓冲区。  
  
 如果使用面向连接的协议，则必须调用 <xref:System.Net.Sockets.Socket.Connect%2A> 以建立远程主机连接，或在调用 <xref:System.Net.Sockets.Socket.Receive%2A>之前 <xref:System.Net.Sockets.Socket.Accept%2A> 接受传入连接。 <xref:System.Net.Sockets.Socket.Receive%2A> 方法将只读取从在 <xref:System.Net.Sockets.Socket.Connect%2A> 或 <xref:System.Net.Sockets.Socket.Accept%2A> 方法中建立的远程主机连接到达的数据。 如果使用的是无连接协议，则还可以使用 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 方法。 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 允许接收来自任何主机的数据。  
  
 如果没有可供读取的数据，则在数据可用之前，将阻止 <xref:System.Net.Sockets.Socket.Receive%2A> 方法，除非使用 <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>设置了超时值。 如果超过超时值，则 <xref:System.Net.Sockets.Socket.Receive%2A> 调用将引发 <xref:System.Net.Sockets.SocketException>。 如果处于非阻止模式，并且协议堆栈缓冲区中没有可用的数据，则 <xref:System.Net.Sockets.Socket.Receive%2A> 方法将立即完成，并引发 <xref:System.Net.Sockets.SocketException>。 您可以使用 <xref:System.Net.Sockets.Socket.Available%2A> 属性来确定数据是否可用于读取。 如果 <xref:System.Net.Sockets.Socket.Available%2A> 非零，则重试接收操作。  
  
 如果使用面向连接的 <xref:System.Net.Sockets.Socket>，<xref:System.Net.Sockets.Socket.Receive%2A> 方法将读取尽可能多的数据，直到达到缓冲区的大小。 如果远程主机使用 <xref:System.Net.Sockets.Socket.Shutdown%2A> 方法关闭 <xref:System.Net.Sockets.Socket> 连接，并且收到所有可用数据，则 <xref:System.Net.Sockets.Socket.Receive%2A> 方法会立即完成并返回零字节。  
  
 如果你使用的是无连接 <xref:System.Net.Sockets.Socket>，<xref:System.Net.Sockets.Socket.Receive%2A> 将从你在 <xref:System.Net.Sockets.Socket.Connect%2A> 方法中指定的目标地址读取第一个排队的数据报。 如果接收的数据报大于 `buffers` 参数的大小，则 `buffers` 会填充消息的第一部分，超过的数据将会丢失，并引发 <xref:System.Net.Sockets.SocketException>。  
  
> [!NOTE]
>  如果收到 <xref:System.Net.Sockets.SocketException>，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。 获取此代码后，请参阅[Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2)文档，以获取有关错误的详细说明。  
  
 **注意**当你在应用程序中启用网络跟踪时，此成员将输出跟踪信息。 有关详细信息，请参阅[.NET Framework 中的网络跟踪](/dotnet/framework/network-programming/network-tracing)。  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Net.Sockets.Socket.Receive(System.Byte[])" />
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> 参数为 <see langword="null" />。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (Span&lt;byte&gt; buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(valuetype System.Span`1&lt;unsigned int8&gt; buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Span{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (buffer As Span(Of Byte)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(Span&lt;System::Byte&gt; buffer);" />
      <MemberSignature Language="F#" Value="member this.Receive : Span&lt;byte&gt; -&gt; int" Usage="socket.Receive buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Span&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="buffer">一个字节范围，它是所接收的数据的存储位置。</param>
        <summary>从绑定的 <see cref="T:System.Net.Sockets.Socket" /> 套接字接收数据，将数据存入接收缓冲区。</summary>
        <returns>收到的字节数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks

<xref:System.Net.Sockets.Socket.Receive%2A> 方法将数据读入 buffer 参数，并返回成功读取的字节数。 可从面向连接的套接字和无连接套接字调用 <xref:System.Net.Sockets.Socket.Receive%2A>。

此重载只要求你提供接收缓冲区。 缓冲区偏移量默认为0，大小默认为 buffer 参数的长度，<xref:System.Net.Sockets.SocketFlags> 值默认为 <xref:System.Net.Sockets.SocketFlags.None>。

如果使用面向连接的协议，则必须调用 <xref:System.Net.Sockets.Socket.Connect%2A> 以建立远程主机连接，或在调用 <xref:System.Net.Sockets.Socket.Receive%2A>之前 <xref:System.Net.Sockets.Socket.Accept%2A> 接受传入连接。 <xref:System.Net.Sockets.Socket.Receive%2A> 方法将只读取从在 <xref:System.Net.Sockets.Socket.Connect%2A> 或 <xref:System.Net.Sockets.Socket.Accept%2A> 方法中建立的远程主机到达的数据。 如果使用的是无连接协议，则还可以使用 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 方法。 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 允许接收来自任何主机的数据。

如果没有可供读取的数据，则在数据可用之前，将阻止 <xref:System.Net.Sockets.Socket.Receive%2A> 方法，除非使用 <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>设置了超时值。 超过超时值时，<xref:System.Net.Sockets.Socket.Receive%2A> 调用将引发 <xref:System.Net.Sockets.SocketException>。 如果处于非阻止模式，并且协议堆栈缓冲区中没有可用数据，则 <xref:System.Net.Sockets.Socket.Receive%2A> 方法将立即完成，并引发 <xref:System.Net.Sockets.SocketException>。 您可以使用 <xref:System.Net.Sockets.Socket.Available%2A> 属性来确定数据是否可用于读取。 如果 <xref:System.Net.Sockets.Socket.Available%2A> 非零，则重试接收操作。

如果使用面向连接的 <xref:System.Net.Sockets.Socket>，<xref:System.Net.Sockets.Socket.Receive%2A> 方法将读取尽可能多的数据，直到达到缓冲区的大小。 如果远程主机使用 <xref:System.Net.Sockets.Socket.Shutdown%2A> 方法关闭 <xref:System.Net.Sockets.Socket> 连接，并且收到所有可用数据，则 <xref:System.Net.Sockets.Socket.Receive%2A> 方法会立即完成并返回零字节。

如果你使用的是无连接 <xref:System.Net.Sockets.Socket>，则 <xref:System.Net.Sockets.Socket.Receive%2A> 将从你在 <xref:System.Net.Sockets.Socket.Connect%2A> 方法中指定的目标地址读取第一个排队的数据报。 如果接收的数据报大于 `buffer` 参数的大小，则 `buffer` 会填充消息的第一部分，超过的数据将会丢失，并引发 <xref:System.Net.Sockets.SocketException>。

> [!NOTE]
> 如果收到 <xref:System.Net.Sockets.SocketException>，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。 获取此代码后，请参阅[Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2)文档，以获取有关错误的详细说明。

当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[.NET Framework 中的网络跟踪](/dotnet/framework/network-programming/network-tracing)。
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <exception cref="T:System.Security.SecurityException">调用堆栈中的调用方没有所需的权限。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (byte[] buffer, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(unsigned int8[] buffer, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (buffer As Byte(), socketFlags As SocketFlags) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(cli::array &lt;System::Byte&gt; ^ buffer, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Receive : byte[] * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Receive (buffer, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="buffer"><see cref="T:System.Byte" /> 类型的数组，它是存储接收到的数据的位置。</param>
        <param name="socketFlags"><see cref="T:System.Net.Sockets.SocketFlags" /> 值的按位组合。</param>
        <summary>使用指定的 <see cref="T:System.Net.Sockets.Socket" />，从绑定的 <see cref="T:System.Net.Sockets.SocketFlags" /> 接收数据，将数据存入接收缓冲区。</summary>
        <returns>收到的字节数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Receive%2A> 方法将数据读入 buffer 参数，并返回成功读取的字节数。 可从面向连接的套接字和无连接套接字调用 <xref:System.Net.Sockets.Socket.Receive%2A>。  
  
 此重载只要求你提供接收缓冲区和必要的 <xref:System.Net.Sockets.SocketFlags>。 缓冲区偏移量默认为0，大小默认为 byte 参数的长度。  
  
 如果使用面向连接的协议，则必须调用 <xref:System.Net.Sockets.Socket.Connect%2A> 以建立远程主机连接，或在调用 <xref:System.Net.Sockets.Socket.Receive%2A>之前 <xref:System.Net.Sockets.Socket.Accept%2A> 接受传入连接。 <xref:System.Net.Sockets.Socket.Receive%2A> 方法将只读取从在 <xref:System.Net.Sockets.Socket.Connect%2A> 或 <xref:System.Net.Sockets.Socket.Accept%2A> 方法中建立的远程主机到达的数据。 如果使用的是无连接协议，则还可以使用 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 方法。 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 允许接收来自任何主机的数据。  
  
 如果没有可供读取的数据，<xref:System.Net.Sockets.Socket.Receive%2A> 方法将被阻止，直到数据可用。 如果处于非阻止模式，并且协议堆栈缓冲区中没有可用数据，则 <xref:System.Net.Sockets.Socket.Receive%2A> 方法将立即完成，并引发 <xref:System.Net.Sockets.SocketException>。 您可以使用 <xref:System.Net.Sockets.Socket.Available%2A> 属性来确定数据是否可用于读取。 如果 <xref:System.Net.Sockets.Socket.Available%2A> 非零，请重试接收操作。  
  
 如果使用面向连接的 <xref:System.Net.Sockets.Socket>，<xref:System.Net.Sockets.Socket.Receive%2A> 方法将读取尽可能多的数据，直到缓冲区大小可用。 如果远程主机使用 <xref:System.Net.Sockets.Socket.Shutdown%2A> 方法关闭 <xref:System.Net.Sockets.Socket> 连接，并且收到所有可用数据，则 <xref:System.Net.Sockets.Socket.Receive%2A> 方法会立即完成并返回零字节。  
  
 如果你使用的是无连接 <xref:System.Net.Sockets.Socket>，<xref:System.Net.Sockets.Socket.Receive%2A> 将从你在 <xref:System.Net.Sockets.Socket.Connect%2A> 方法中指定的目标地址读取第一个排队的数据报。 如果接收的数据报大于 `buffer` 参数的大小，则 `buffer` 会填充消息的第一部分，超过的数据将会丢失，并引发 <xref:System.Net.Sockets.SocketException>。  
  
> [!NOTE]
>  如果收到 <xref:System.Net.Sockets.SocketException>，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。 获取此代码后，请参阅[Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2)文档，以获取有关错误的详细说明。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[.NET Framework 中的网络跟踪](/dotnet/framework/network-programming/network-tracing)。  
  
   
  
## Examples  
 下面的代码示例指定了一个数据缓冲区，并 <xref:System.Net.Sockets.SocketFlags> 用于接收连接 <xref:System.Net.Sockets.Socket>上的数据。  
  
 [!code-cpp[Socket_Sync_Send_Receive#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#2)]
 [!code-csharp[Socket_Sync_Send_Receive#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#2)]
 [!code-vb[Socket_Sync_Send_Receive#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <exception cref="T:System.Security.SecurityException">调用堆栈中的调用方没有所需的权限。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (buffers As IList(Of ArraySegment(Of Byte)), socketFlags As SocketFlags) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Receive : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Receive (buffers, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="buffers"><see cref="T:System.ArraySegment`1" /> 类型的一个 <see cref="T:System.Byte" /> 列表，包含接收的数据。</param>
        <param name="socketFlags"><see cref="T:System.Net.Sockets.SocketFlags" /> 值的按位组合。</param>
        <summary>使用指定的 <see cref="T:System.Net.Sockets.Socket" />，从绑定的 <see cref="T:System.Net.Sockets.SocketFlags" /> 接收数据，将数据存入接收缓冲区列表中。</summary>
        <returns>收到的字节数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法将数据读取到 `buffers` 参数并返回成功读取的字节数。 可从面向连接的套接字和无连接套接字调用。  
  
 此重载要求提供一个或多个接收缓冲区。 <xref:System.Net.Sockets.SocketFlags> 值默认为 <xref:System.Net.Sockets.SocketFlags.None>。  
  
 如果使用面向连接的协议，则必须调用 <xref:System.Net.Sockets.Socket.Connect%2A> 以建立远程主机连接，或在调用 <xref:System.Net.Sockets.Socket.Receive%2A>之前 <xref:System.Net.Sockets.Socket.Accept%2A> 接受传入连接。 <xref:System.Net.Sockets.Socket.Receive%2A> 方法将只读取从在 <xref:System.Net.Sockets.Socket.Connect%2A> 或 <xref:System.Net.Sockets.Socket.Accept%2A> 方法中建立的远程主机连接到达的数据。 如果使用的是无连接协议，则还可以使用 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 方法。 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 允许接收来自任何主机的数据。  
  
 如果没有可供读取的数据，则在数据可用之前，将阻止 <xref:System.Net.Sockets.Socket.Receive%2A> 方法，除非使用 <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>设置了超时值。 如果超过超时值，则 <xref:System.Net.Sockets.Socket.Receive%2A> 调用将引发 <xref:System.Net.Sockets.SocketException>。 如果处于非阻止模式，并且协议堆栈缓冲区中没有可用的数据，则 <xref:System.Net.Sockets.Socket.Receive%2A> 方法将立即完成，并引发 <xref:System.Net.Sockets.SocketException>。 您可以使用 <xref:System.Net.Sockets.Socket.Available%2A> 属性来确定数据是否可用于读取。 如果 <xref:System.Net.Sockets.Socket.Available%2A> 非零，则重试接收操作。  
  
 如果使用面向连接的 <xref:System.Net.Sockets.Socket>，<xref:System.Net.Sockets.Socket.Receive%2A> 方法将读取尽可能多的数据，直到达到缓冲区的大小。 如果远程主机使用 <xref:System.Net.Sockets.Socket.Shutdown%2A> 方法关闭 <xref:System.Net.Sockets.Socket> 连接，并且收到所有可用数据，则 <xref:System.Net.Sockets.Socket.Receive%2A> 方法会立即完成并返回零字节。  
  
 如果你使用的是无连接 <xref:System.Net.Sockets.Socket>，<xref:System.Net.Sockets.Socket.Receive%2A> 将从你在 <xref:System.Net.Sockets.Socket.Connect%2A> 方法中指定的目标地址读取第一个排队的数据报。 如果接收的数据报大于 `buffers` 参数的大小，则 `buffers` 会填充消息的第一部分，超过的数据将会丢失，并引发 <xref:System.Net.Sockets.SocketException>。  
  
> [!NOTE]
>  如果收到 <xref:System.Net.Sockets.SocketException>，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。 获取此代码后，请参阅[Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2)文档，以获取有关错误的详细说明。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[.NET Framework 中的网络跟踪](/dotnet/framework/network-programming/network-tracing)。  
  
   
  
## Examples  
 下面的代码示例演示如何在连接的 <xref:System.Net.Sockets.Socket>上接收数据。  
  
 [!code-cpp[System.Net.Sockets.Socketgenerics#2](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socketgenerics/CPP/sendgeneric.cpp#2)]
 [!code-csharp[System.Net.Sockets.Socketgenerics#2](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socketgenerics/CS/sendgeneric.cs#2)]  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)" />
        <exception cref="T:System.ArgumentNullException"><paramref name="buffers" /> 为 <see langword="null" />。  
  
-或- 
 <paramref name="buffers" />.Count 是零。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (Span&lt;byte&gt; buffer, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(valuetype System.Span`1&lt;unsigned int8&gt; buffer, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Span{System.Byte},System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (buffer As Span(Of Byte), socketFlags As SocketFlags) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(Span&lt;System::Byte&gt; buffer, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Receive : Span&lt;byte&gt; * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Receive (buffer, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Span&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="buffer">一个字节范围，它是所接收的数据的存储位置。</param>
        <param name="socketFlags">枚举值的按位组合，它用于指定发送和接收行为。</param>
        <summary>使用指定的 <see cref="T:System.Net.Sockets.Socket" />，从绑定的 <see cref="T:System.Net.Sockets.SocketFlags" /> 接收数据，将数据存入接收缓冲区。</summary>
        <returns>收到的字节数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[
## Remarks

<xref:System.Net.Sockets.Socket.Receive%2A> 方法将数据读入 buffer 参数，并返回成功读取的字节数。 可从面向连接的套接字和无连接套接字调用 <xref:System.Net.Sockets.Socket.Receive%2A>。

此重载只要求你提供接收缓冲区。 缓冲区偏移量默认为0，大小默认为 buffer 参数的长度，<xref:System.Net.Sockets.SocketFlags> 值默认为 <xref:System.Net.Sockets.SocketFlags.None>。

如果使用面向连接的协议，则必须调用 <xref:System.Net.Sockets.Socket.Connect%2A> 以建立远程主机连接，或在调用 <xref:System.Net.Sockets.Socket.Receive%2A>之前 <xref:System.Net.Sockets.Socket.Accept%2A> 接受传入连接。 <xref:System.Net.Sockets.Socket.Receive%2A> 方法将只读取从在 <xref:System.Net.Sockets.Socket.Connect%2A> 或 <xref:System.Net.Sockets.Socket.Accept%2A> 方法中建立的远程主机到达的数据。 如果使用的是无连接协议，则还可以使用 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 方法。 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 允许接收来自任何主机的数据。

如果没有可供读取的数据，则在数据可用之前，将阻止 <xref:System.Net.Sockets.Socket.Receive%2A> 方法，除非使用 <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>设置了超时值。 超过超时值时，<xref:System.Net.Sockets.Socket.Receive%2A> 调用将引发 <xref:System.Net.Sockets.SocketException>。 如果处于非阻止模式，并且协议堆栈缓冲区中没有可用数据，则 <xref:System.Net.Sockets.Socket.Receive%2A> 方法将立即完成，并引发 <xref:System.Net.Sockets.SocketException>。 您可以使用 <xref:System.Net.Sockets.Socket.Available%2A> 属性来确定数据是否可用于读取。 如果 <xref:System.Net.Sockets.Socket.Available%2A> 非零，则重试接收操作。

如果使用面向连接的 <xref:System.Net.Sockets.Socket>，<xref:System.Net.Sockets.Socket.Receive%2A> 方法将读取尽可能多的数据，直到达到缓冲区的大小。 如果远程主机使用 <xref:System.Net.Sockets.Socket.Shutdown%2A> 方法关闭 <xref:System.Net.Sockets.Socket> 连接，并且收到所有可用数据，则 <xref:System.Net.Sockets.Socket.Receive%2A> 方法会立即完成并返回零字节。

如果你使用的是无连接 <xref:System.Net.Sockets.Socket>，则 <xref:System.Net.Sockets.Socket.Receive%2A> 将从你在 <xref:System.Net.Sockets.Socket.Connect%2A> 方法中指定的目标地址读取第一个排队的数据报。 如果接收的数据报大于 `buffer` 参数的大小，则 `buffer` 会填充消息的第一部分，超过的数据将会丢失，并引发 <xref:System.Net.Sockets.SocketException>。

> [!NOTE]
> 如果收到 <xref:System.Net.Sockets.SocketException>，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。 获取此代码后，请参阅[Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2)文档，以获取有关错误的详细说明。

当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[.NET Framework 中的网络跟踪](/dotnet/framework/network-programming/network-tracing)。

 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <exception cref="T:System.Security.SecurityException">调用堆栈中的调用方没有所需的权限。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (byte[] buffer, int size, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(unsigned int8[] buffer, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (buffer As Byte(), size As Integer, socketFlags As SocketFlags) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(cli::array &lt;System::Byte&gt; ^ buffer, int size, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Receive : byte[] * int * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Receive (buffer, size, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="size" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="buffer"><see cref="T:System.Byte" /> 类型的数组，它是存储接收到的数据的位置。</param>
        <param name="size">要接收的字节数。</param>
        <param name="socketFlags"><see cref="T:System.Net.Sockets.SocketFlags" /> 值的按位组合。</param>
        <summary>使用指定的 <see cref="T:System.Net.Sockets.Socket" />，从绑定的 <see cref="T:System.Net.Sockets.SocketFlags" /> 接收指定字节数的数据，并将数据存入接收缓冲区。</summary>
        <returns>收到的字节数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Receive%2A> 方法将数据读入 `buffer` 参数，并返回成功读取的字节数。 可从面向连接的套接字和无连接套接字调用 <xref:System.Net.Sockets.Socket.Receive%2A>。  
  
 此重载只要求你提供接收缓冲区、要接收的字节数以及必需的 <xref:System.Net.Sockets.SocketFlags>。  
  
 如果使用面向连接的协议，则必须调用 <xref:System.Net.Sockets.Socket.Connect%2A> 以建立远程主机连接，或在调用 <xref:System.Net.Sockets.Socket.Receive%2A>之前 <xref:System.Net.Sockets.Socket.Accept%2A> 接受传入连接。 <xref:System.Net.Sockets.Socket.Receive%2A> 方法将只读取从在 <xref:System.Net.Sockets.Socket.Connect%2A> 或 <xref:System.Net.Sockets.Socket.Accept%2A> 方法中建立的远程主机到达的数据。 如果使用的是无连接协议，则还可以使用 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 方法。 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 允许接收来自任何主机的数据。  
  
 如果没有可供读取的数据，则在数据可用之前，将阻止 <xref:System.Net.Sockets.Socket.Receive%2A> 方法，除非使用 <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>设置了超时值。 如果超过超时值，则 <xref:System.Net.Sockets.Socket.Receive%2A> 调用将引发 <xref:System.Net.Sockets.SocketException>。 如果处于非阻止模式，并且协议堆栈缓冲区中没有可用的数据，则 <xref:System.Net.Sockets.Socket.Receive%2A> 方法将立即完成，并引发 <xref:System.Net.Sockets.SocketException>。 您可以使用 <xref:System.Net.Sockets.Socket.Available%2A> 属性来确定数据是否可用于读取。 如果 <xref:System.Net.Sockets.Socket.Available%2A> 非零，请重试接收操作。  
  
 如果使用面向连接的 <xref:System.Net.Sockets.Socket>，<xref:System.Net.Sockets.Socket.Receive%2A> 方法将读取尽可能多的数据，直至 `size` 参数指定的字节数。 如果远程主机使用 <xref:System.Net.Sockets.Socket.Shutdown%2A> 方法关闭 <xref:System.Net.Sockets.Socket> 连接，并且收到所有可用数据，则 <xref:System.Net.Sockets.Socket.Receive%2A> 方法会立即完成并返回零字节。  
  
 如果你使用的是无连接 <xref:System.Net.Sockets.Socket>，则 <xref:System.Net.Sockets.Socket.Receive%2A> 将从你在 <xref:System.Net.Sockets.Socket.Connect%2A> 方法中指定的目标地址读取第一个排队的数据报。 如果接收的数据报大于 `buffer` 参数的大小，则 `buffer` 会填充消息的第一部分，超过的数据将会丢失，并引发 <xref:System.Net.Sockets.SocketException>。  
  
> [!NOTE]
>  如果收到 <xref:System.Net.Sockets.SocketException>，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。 获取此代码后，请参阅[Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2)文档，以获取有关错误的详细说明。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[.NET Framework 中的网络跟踪](/dotnet/framework/network-programming/network-tracing)。  
  
   
  
## Examples  
 下面的将接收到 `buffer`中找到的数据，并指定 <xref:System.Net.Sockets.SocketFlags><xref:System.Net.Sockets.SocketFlags.None>。  
  
 [!code-cpp[Socket_Send_Receive#4](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Send_Receive/CPP/source.cpp#4)]
 [!code-csharp[Socket_Send_Receive#4](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Send_Receive/CS/source.cs#4)]
 [!code-vb[Socket_Send_Receive#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Send_Receive/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="size" /> 超出了 <paramref name="buffer" /> 的大小。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <exception cref="T:System.Security.SecurityException">调用堆栈中的调用方没有所需的权限。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (buffers As IList(Of ArraySegment(Of Byte)), socketFlags As SocketFlags, ByRef errorCode As SocketError) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberSignature Language="F#" Value="member this.Receive : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.Net.Sockets.SocketFlags * SocketError -&gt; int" Usage="socket.Receive (buffers, socketFlags, errorCode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="buffers"><see cref="T:System.ArraySegment`1" /> 类型的一个 <see cref="T:System.Byte" /> 列表，包含接收的数据。</param>
        <param name="socketFlags"><see cref="T:System.Net.Sockets.SocketFlags" /> 值的按位组合。</param>
        <param name="errorCode">一个 <see cref="T:System.Net.Sockets.SocketError" /> 对象，它存储套接字错误。</param>
        <summary>使用指定的 <see cref="T:System.Net.Sockets.Socket" />，从绑定的 <see cref="T:System.Net.Sockets.SocketFlags" /> 接收数据，将数据存入接收缓冲区列表中。</summary>
        <returns>收到的字节数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法将数据读取到 `buffers` 参数并返回成功读取的字节数。 可从面向连接的套接字和无连接套接字调用。  
  
 此重载要求提供一个或多个接收缓冲区。 <xref:System.Net.Sockets.SocketFlags> 值默认为 <xref:System.Net.Sockets.SocketFlags.None>。  
  
 如果使用面向连接的协议，则必须调用 <xref:System.Net.Sockets.Socket.Connect%2A> 以建立远程主机连接，或在调用 <xref:System.Net.Sockets.Socket.Receive%2A>之前 <xref:System.Net.Sockets.Socket.Accept%2A> 接受传入连接。 <xref:System.Net.Sockets.Socket.Receive%2A> 方法将只读取从在 <xref:System.Net.Sockets.Socket.Connect%2A> 或 <xref:System.Net.Sockets.Socket.Accept%2A> 方法中建立的远程主机连接到达的数据。 如果使用的是无连接协议，则还可以使用 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 方法。 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 允许接收来自任何主机的数据。  
  
 如果没有可供读取的数据，则在数据可用之前，将阻止 <xref:System.Net.Sockets.Socket.Receive%2A> 方法，除非使用 <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>设置了超时值。 如果超过超时值，则 <xref:System.Net.Sockets.Socket.Receive%2A> 调用将引发 <xref:System.Net.Sockets.SocketException>。 如果处于非阻止模式，并且协议堆栈缓冲区中没有可用的数据，则 <xref:System.Net.Sockets.Socket.Receive%2A> 方法将立即完成，并引发 <xref:System.Net.Sockets.SocketException>。 您可以使用 <xref:System.Net.Sockets.Socket.Available%2A> 属性来确定数据是否可用于读取。 如果 <xref:System.Net.Sockets.Socket.Available%2A> 非零，则重试接收操作。  
  
 如果使用面向连接的 <xref:System.Net.Sockets.Socket>，<xref:System.Net.Sockets.Socket.Receive%2A> 方法将读取尽可能多的数据，直到达到缓冲区的大小。 如果远程主机使用 <xref:System.Net.Sockets.Socket.Shutdown%2A> 方法关闭 <xref:System.Net.Sockets.Socket> 连接，并且收到所有可用数据，则 <xref:System.Net.Sockets.Socket.Receive%2A> 方法会立即完成并返回零字节。  
  
 如果你使用的是无连接 <xref:System.Net.Sockets.Socket>，则<xref:System.Net.Sockets.Socket.Receive%2A> 将从你在 <xref:System.Net.Sockets.Socket.Connect%2A> 方法中指定的目标地址读取第一个排队的数据报。 如果接收的数据报大于 `buffers` 参数的大小，则 `buffers` 会填充消息的第一部分，超过的数据将会丢失，并引发 <xref:System.Net.Sockets.SocketException>。  
  
> [!NOTE]
>  如果收到 <xref:System.Net.Sockets.SocketException>，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。 获取此代码后，请参阅[Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2)文档，以获取有关错误的详细说明。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[.NET Framework 中的网络跟踪](/dotnet/framework/network-programming/network-tracing)。  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)" />
        <exception cref="T:System.ArgumentNullException"><paramref name="buffers" /> 为 <see langword="null" />。  
  
-或- 
 <paramref name="buffers" />.Count 是零。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (Span&lt;byte&gt; buffer, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(valuetype System.Span`1&lt;unsigned int8&gt; buffer, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Span{System.Byte},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (buffer As Span(Of Byte), socketFlags As SocketFlags, ByRef errorCode As SocketError) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(Span&lt;System::Byte&gt; buffer, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberSignature Language="F#" Value="member this.Receive : Span&lt;byte&gt; * System.Net.Sockets.SocketFlags * SocketError -&gt; int" Usage="socket.Receive (buffer, socketFlags, errorCode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Span&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="buffer">一个字节范围，它是所接收的数据的存储位置。</param>
        <param name="socketFlags">枚举值的按位组合，它用于指定发送和接收行为。</param>
        <param name="errorCode">当此方法返回时，将包含定义套接字错误代码的枚举值之一。</param>
        <summary>使用指定的 <see cref="T:System.Net.Sockets.Socket" />，从绑定的 <see cref="T:System.Net.Sockets.SocketFlags" /> 接收数据，将数据存入接收缓冲区。</summary>
        <returns>收到的字节数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
## Remarks

<xref:System.Net.Sockets.Socket.Receive%2A> 方法将数据读入 buffer 参数，并返回成功读取的字节数。 可从面向连接的套接字和无连接套接字调用 <xref:System.Net.Sockets.Socket.Receive%2A>。  

此重载只要求你提供接收缓冲区。 缓冲区偏移量默认为0，大小默认为 buffer 参数的长度，<xref:System.Net.Sockets.SocketFlags> 值默认为 <xref:System.Net.Sockets.SocketFlags.None>。  

如果使用面向连接的协议，则必须调用 <xref:System.Net.Sockets.Socket.Connect%2A> 以建立远程主机连接，或在调用 <xref:System.Net.Sockets.Socket.Receive%2A>之前 <xref:System.Net.Sockets.Socket.Accept%2A> 接受传入连接。 <xref:System.Net.Sockets.Socket.Receive%2A> 方法将只读取从在 <xref:System.Net.Sockets.Socket.Connect%2A> 或 <xref:System.Net.Sockets.Socket.Accept%2A> 方法中建立的远程主机到达的数据。 如果使用的是无连接协议，则还可以使用 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 方法。 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 允许接收来自任何主机的数据。  

如果没有可供读取的数据，则在数据可用之前，将阻止 <xref:System.Net.Sockets.Socket.Receive%2A> 方法，除非使用 <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>设置了超时值。 超过超时值时，<xref:System.Net.Sockets.Socket.Receive%2A> 调用将引发 <xref:System.Net.Sockets.SocketException>。 如果处于非阻止模式，并且协议堆栈缓冲区中没有可用数据，则 <xref:System.Net.Sockets.Socket.Receive%2A> 方法将立即完成，并引发 <xref:System.Net.Sockets.SocketException>。 您可以使用 <xref:System.Net.Sockets.Socket.Available%2A> 属性来确定数据是否可用于读取。 如果 <xref:System.Net.Sockets.Socket.Available%2A> 非零，则重试接收操作。  

如果使用面向连接的 <xref:System.Net.Sockets.Socket>，<xref:System.Net.Sockets.Socket.Receive%2A> 方法将读取尽可能多的数据，直到达到缓冲区的大小。 如果远程主机使用 <xref:System.Net.Sockets.Socket.Shutdown%2A> 方法关闭 <xref:System.Net.Sockets.Socket> 连接，并且收到所有可用数据，则 <xref:System.Net.Sockets.Socket.Receive%2A> 方法会立即完成并返回零字节。  

如果你使用的是无连接 <xref:System.Net.Sockets.Socket>，则 <xref:System.Net.Sockets.Socket.Receive%2A> 将从你在 <xref:System.Net.Sockets.Socket.Connect%2A> 方法中指定的目标地址读取第一个排队的数据报。 如果接收的数据报大于 `buffer` 参数的大小，则 `buffer` 会填充消息的第一部分，超过的数据将会丢失，并引发 <xref:System.Net.Sockets.SocketException>。  

> [!NOTE]
>  如果收到 <xref:System.Net.Sockets.SocketException>，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。 获取此代码后，请参阅[Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2)文档，以获取有关错误的详细说明。  

> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[.NET Framework 中的网络跟踪](/dotnet/framework/network-programming/network-tracing)。  

 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <exception cref="T:System.Security.SecurityException">调用堆栈中的调用方没有所需的权限。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (buffer As Byte(), offset As Integer, size As Integer, socketFlags As SocketFlags) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Receive : byte[] * int * int * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Receive (buffer, offset, size, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="buffer">类型 <see cref="T:System.Byte" /> 的数组，它是所接受的数据的存储位置。</param>
        <param name="offset"><paramref name="buffer" /> 中存储所接收数据的位置。</param>
        <param name="size">要接收的字节数。</param>
        <param name="socketFlags"><see cref="T:System.Net.Sockets.SocketFlags" /> 值的按位组合。</param>
        <summary>使用指定的 <see cref="T:System.Net.Sockets.Socket" />，从绑定的 <see cref="T:System.Net.Sockets.SocketFlags" /> 接收指定的字节数，存入接收缓冲区的指定偏移量位置。</summary>
        <returns>收到的字节数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Receive%2A> 方法将数据读入 buffer 参数，并返回成功读取的字节数。 可从面向连接的套接字和无连接套接字调用 <xref:System.Net.Sockets.Socket.Receive%2A>。  
  
 如果使用面向连接的协议，则必须调用 <xref:System.Net.Sockets.Socket.Connect%2A> 以建立远程主机连接，或在调用 <xref:System.Net.Sockets.Socket.Receive%2A>之前 <xref:System.Net.Sockets.Socket.Accept%2A> 接受传入连接。 <xref:System.Net.Sockets.Socket.Receive%2A> 方法将只读取从在 <xref:System.Net.Sockets.Socket.Connect%2A> 或 <xref:System.Net.Sockets.Socket.Accept%2A> 方法中建立的远程主机到达的数据。 如果使用的是无连接协议，则还可以使用 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 方法。 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 允许接收来自任何主机的数据。  
  
 如果没有可供读取的数据，则在数据可用之前，将阻止 <xref:System.Net.Sockets.Socket.Receive%2A> 方法，除非使用 <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>设置了超时值。 如果超过超时值，则 <xref:System.Net.Sockets.Socket.Receive%2A> 调用将引发 <xref:System.Net.Sockets.SocketException>。 如果处于非阻止模式，并且协议堆栈缓冲区中没有可用的数据，则 <xref:System.Net.Sockets.Socket.Receive%2A> 方法将立即完成，并引发 <xref:System.Net.Sockets.SocketException>。 尝试访问套接字时出错。 请参阅下面的备注。 您可以使用 <xref:System.Net.Sockets.Socket.Available%2A> 属性来确定数据是否可用于读取。 如果 <xref:System.Net.Sockets.Socket.Available%2A> 非零，则重试接收操作。  
  
 如果使用面向连接的 <xref:System.Net.Sockets.Socket>，<xref:System.Net.Sockets.Socket.Receive%2A> 方法将读取尽可能多的数据，最多可达 size 参数指定的字节数。 如果远程主机使用 <xref:System.Net.Sockets.Socket.Shutdown%2A> 方法关闭 <xref:System.Net.Sockets.Socket> 连接，并且收到所有可用数据，则 <xref:System.Net.Sockets.Socket.Receive%2A> 方法会立即完成并返回零字节。  
  
 如果你使用的是无连接 <xref:System.Net.Sockets.Socket>，则 <xref:System.Net.Sockets.Socket.Receive%2A> 将从你在 <xref:System.Net.Sockets.Socket.Connect%2A> 方法中指定的目标地址读取第一个排队的数据报。 如果接收的数据报大于 `buffer` 参数的大小，则 `buffer` 会填充消息的第一部分，超过的数据将会丢失，并引发 <xref:System.Net.Sockets.SocketException>。  
  
> [!NOTE]
>  如果收到 <xref:System.Net.Sockets.SocketException>，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。 获取此代码后，请参阅[Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2)文档，以获取有关错误的详细说明。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[.NET Framework 中的网络跟踪](/dotnet/framework/network-programming/network-tracing)。  
  
   
  
## Examples  
 下面的代码示例在连接 <xref:System.Net.Sockets.Socket>上接收数据之前，指定数据缓冲区、偏移量、大小和套接字标志。  
  
 [!code-cpp[Socket_Sync_Send_Receive#4](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#4)]
 [!code-csharp[Socket_Sync_Send_Receive#4](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#4)]
 [!code-vb[Socket_Sync_Send_Receive#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" /> 小于 0。  
  
-或- 
 <paramref name="offset" /> 大于 <paramref name="buffer" /> 的长度。  
  
-或- 
 <paramref name="size" /> 小于 0。  
  
-或- 
 <paramref name="size" /> 大于 <paramref name="buffer" /> 的长度减去 <paramref name="offset" /> 参数的值。</exception>
        <exception cref="T:System.Net.Sockets.SocketException"><paramref name="socketFlags" /> 不是有效的值组合。  
  
-或- 
未设置 <see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /> 属性。  
  
-或- 
访问 <see cref="T:System.Net.Sockets.Socket" /> 时出现操作系统错误。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <exception cref="T:System.Security.SecurityException">调用堆栈中的调用方没有所需的权限。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (buffer As Byte(), offset As Integer, size As Integer, socketFlags As SocketFlags, ByRef errorCode As SocketError) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberSignature Language="F#" Value="member this.Receive : byte[] * int * int * System.Net.Sockets.SocketFlags * SocketError -&gt; int" Usage="socket.Receive (buffer, offset, size, socketFlags, errorCode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" Index="4" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="buffer"><see cref="T:System.Byte" /> 类型的数组，它是存储接收到的数据的位置。</param>
        <param name="offset"><paramref name="buffer" /> 参数中的位置，用于存储所接收的数据。</param>
        <param name="size">要接收的字节数。</param>
        <param name="socketFlags"><see cref="T:System.Net.Sockets.SocketFlags" /> 值的按位组合。</param>
        <param name="errorCode">一个 <see cref="T:System.Net.Sockets.SocketError" /> 对象，它存储套接字错误。</param>
        <summary>使用指定的 <see cref="T:System.Net.Sockets.Socket" />，从绑定的 <see cref="T:System.Net.Sockets.SocketFlags" /> 接收数据，将数据存入接收缓冲区。</summary>
        <returns>收到的字节数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Receive%2A> 方法将数据读入 buffer 参数，并返回成功读取的字节数。 可从面向连接的套接字和无连接套接字调用 <xref:System.Net.Sockets.Socket.Receive%2A>。  
  
 如果使用面向连接的协议，则必须调用 <xref:System.Net.Sockets.Socket.Connect%2A> 以建立远程主机连接，或在调用 <xref:System.Net.Sockets.Socket.Receive%2A>之前 <xref:System.Net.Sockets.Socket.Accept%2A> 接受传入连接。 <xref:System.Net.Sockets.Socket.Receive%2A> 方法将只读取从在 <xref:System.Net.Sockets.Socket.Connect%2A> 或 <xref:System.Net.Sockets.Socket.Accept%2A> 方法中建立的远程主机到达的数据。 如果使用的是无连接协议，则还可以使用 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 方法。 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 允许接收来自任何主机的数据。  
  
 如果没有可供读取的数据，则在数据可用之前，将阻止 <xref:System.Net.Sockets.Socket.Receive%2A> 方法，除非使用 <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>设置了超时值。 如果超过超时值，则 <xref:System.Net.Sockets.Socket.Receive%2A> 调用将引发 <xref:System.Net.Sockets.SocketException>。 如果处于非阻止模式，并且协议堆栈缓冲区中没有可用的数据，则 <xref:System.Net.Sockets.Socket.Receive%2A> 方法将立即完成，并引发 <xref:System.Net.Sockets.SocketException>。 尝试访问套接字时出错。 请参阅下面的备注。 您可以使用 <xref:System.Net.Sockets.Socket.Available%2A> 属性来确定数据是否可用于读取。 如果 <xref:System.Net.Sockets.Socket.Available%2A> 非零，则重试接收操作。  
  
 如果使用面向连接的 <xref:System.Net.Sockets.Socket>，<xref:System.Net.Sockets.Socket.Receive%2A> 方法将读取尽可能多的数据，最多可达 size 参数指定的字节数。 如果远程主机使用 <xref:System.Net.Sockets.Socket.Shutdown%2A> 方法关闭 <xref:System.Net.Sockets.Socket> 连接，并且收到所有可用数据，则 <xref:System.Net.Sockets.Socket.Receive%2A> 方法会立即完成并返回零字节。  
  
 如果你使用的是无连接 <xref:System.Net.Sockets.Socket>，则 <xref:System.Net.Sockets.Socket.Receive%2A> 将从你在 <xref:System.Net.Sockets.Socket.Connect%2A> 方法中指定的目标地址读取第一个排队的数据报。 如果接收的数据报大于 `buffer` 参数的大小，则 `buffer` 会填充消息的第一部分，超过的数据将会丢失，并引发 <xref:System.Net.Sockets.SocketException>。  
  
> [!NOTE]
>  如果收到 <xref:System.Net.Sockets.SocketException>，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。 获取此代码后，请参阅[Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2)文档，以获取有关错误的详细说明。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[.NET Framework 中的网络跟踪](/dotnet/framework/network-programming/network-tracing)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" /> 小于 0。  
  
-或- 
 <paramref name="offset" /> 大于 <paramref name="buffer" /> 的长度。  
  
-或- 
 <paramref name="size" /> 小于 0。  
  
-或- 
 <paramref name="size" /> 大于 <paramref name="buffer" /> 的长度减去 <paramref name="offset" /> 参数的值。</exception>
        <exception cref="T:System.Net.Sockets.SocketException"><paramref name="socketFlags" /> 不是有效的值组合。  
  
-或- 
未设置 <see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /> 属性。  
  
-或- 
访问 <see cref="T:System.Net.Sockets.Socket" /> 时出现操作系统错误。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <exception cref="T:System.Security.SecurityException">调用堆栈中的调用方没有所需的权限。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveAsync">
      <MemberSignature Language="C#" Value="public bool ReceiveAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ReceiveAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ReceiveAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.ReceiveAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="socket.ReceiveAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="e">要用于此异步套接字操作的 <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> 对象。</param>
        <summary>开始一个异步请求以便从连接的 <see cref="T:System.Net.Sockets.Socket" /> 对象中接收数据。</summary>
        <returns>如果 I/O 操作挂起，则为 <see langword="true" />。 操作完成时，将引发 <paramref name="e" /> 参数的 <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> 事件。  
  
 如果 I/O 操作同步完成，则为 <see langword="false" />。 在这种情况下，将不会引发 <paramref name="e" /> 参数的 <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> 事件，并且可能在方法调用返回后立即检查作为参数传递的 <paramref name="e" /> 对象以检索操作的结果。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.ReceiveAsync%2A> 方法用于连接的套接字或绑定的无连接套接字，并用于读取传入的数据。 套接字的本地地址必须是已知的。  
  
 对于绑定的无连接套接字，此函数限制接受接收的消息的地址。 函数只从连接中指定的远程地址返回消息。 来自其他地址的消息将悄悄地丢弃。  
  
 `e` 参数的 <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags%2A?displayProperty=nameWithType> 属性为窗口套接字服务提供程序提供有关读取请求的其他信息。 有关如何使用此参数的详细信息，请参阅 <xref:System.Net.Sockets.SocketFlags?displayProperty=nameWithType>。  
  
 若要成功调用此方法，需要 <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> 对象上的下列属性和事件：  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> 或 <xref:System.Net.Sockets.SocketAsyncEventArgs.BufferList%2A?displayProperty=nameWithType>  
  
-   如果设置 <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType>，则 <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType>  
  
-   如果设置 <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType>，则 <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
 调用方可以在调用 <xref:System.Net.Sockets.Socket.ReceiveAsync%2A> 方法之前将 <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> 属性设置为所需的任何用户状态对象，以便可以在回调方法中检索信息。 如果回调需要比单个对象更多的信息，则可以创建一个小类，以将其他所需的状态信息保存为成员。  
  
 对于字节流样式的套接字，传入的数据将被放入缓冲区中，直到缓冲区填充完毕、连接关闭或内部缓冲的数据被耗尽。  
  
 对于面向消息的套接字，会将传入消息放入缓冲区中，直到与 `e` 参数相关联的缓冲区的总大小。 如果消息大于缓冲区，则缓冲区将用消息的第一部分进行填充。  
  
 对于面向连接的套接字，<xref:System.Net.Sockets.Socket.ReceiveAsync%2A> 方法可以通过以下两种方式之一指示虚拟线路的正常终止方式：取决于套接字是字节流还是面向消息。 对于字节流，已读取的零字节表示正常关闭，不会再读取更多的字节。 对于面向消息的套接字（通常允许使用零字节消息），将使用 <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType> 设置为本机 Winsock WSAEDISCON 错误代码（10101）的 <xref:System.Net.Sockets.SocketException> 来指示正常关闭。 在任何情况下，将 <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType> 设置为本机 Winsock WSAECONNRESET 错误代码（10054）的 <xref:System.Net.Sockets.SocketException> 表明发生了异常 close。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">参数无效。 <paramref name="e" /> 参数的 <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" /> 或 <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /> 属性必须引用有效的缓冲区。 可以设置这两个属性中的某一个，但不能同时设置这两个属性。</exception>
        <exception cref="T:System.InvalidOperationException">已经在使用 <paramref name="e" /> 参数中指定的 <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> 对象执行套接字操作。</exception>
        <exception cref="T:System.NotSupportedException">此方法需要 Windows XP 或更高版本。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Offset" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveBufferSize">
      <MemberSignature Language="C#" Value="public int ReceiveBufferSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ReceiveBufferSize" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.ReceiveBufferSize" />
      <MemberSignature Language="VB.NET" Value="Public Property ReceiveBufferSize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ReceiveBufferSize { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.ReceiveBufferSize : int with get, set" Usage="System.Net.Sockets.Socket.ReceiveBufferSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，它指定 <see cref="T:System.Net.Sockets.Socket" /> 接收缓冲区的大小。</summary>
        <value><see cref="T:System.Int32" />，它包含接收缓冲区的大小（以字节为单位）。 默认值为 8192。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 较大的缓冲区大小可能会减少空确认（没有数据部分的 TCP 数据包）的数目，但也可能会延迟连接问题的识别。 如果正在传输大文件，或者使用的是高带宽、高延迟连接（如卫星宽带提供程序），请考虑增加缓冲区大小。  
  
   
  
## Examples  
 下面的代码示例演示如何使用 <xref:System.Net.Sockets.Socket.ReceiveBufferSize%2A> 属性。  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">为设置操作指定的值小于 0。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReceiveFrom">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>接收数据报并存储源终结点。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReceiveFrom">
      <MemberSignature Language="C#" Value="public int ReceiveFrom (byte[] buffer, ref System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ReceiveFrom(unsigned int8[] buffer, class System.Net.EndPoint&amp; remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.EndPoint@)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveFrom (buffer As Byte(), ByRef remoteEP As EndPoint) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ReceiveFrom(cli::array &lt;System::Byte&gt; ^ buffer, System::Net::EndPoint ^ % remoteEP);" />
      <MemberSignature Language="F#" Value="member this.ReceiveFrom : byte[] * EndPoint -&gt; int" Usage="socket.ReceiveFrom (buffer, remoteEP)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" RefType="ref" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="buffer">类型 <see cref="T:System.Byte" /> 的数组，它是所接受的数据的存储位置。</param>
        <param name="remoteEP">通过引用传递的 <see cref="T:System.Net.EndPoint" />，表示远程服务器。</param>
        <summary>将数据报接收到数据缓冲区并存储终结点。</summary>
        <returns>收到的字节数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 方法将数据读入 `buffer` 参数，返回成功读取的字节数，并捕获从其发送数据的远程主机终结点。 如果打算从未知主机或多台主机接收无连接的数据报，此方法非常有用。  
  
 此重载只要求你提供接收 `buffer`和表示远程主机的 <xref:System.Net.EndPoint>。 缓冲区偏移量默认为0。 大小默认为 `buffer` 参数的长度，`socketFlags` 值默认为 <xref:System.Net.Sockets.SocketFlags.None>。  
  
> [!NOTE]
>  在调用 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>之前，必须使用 <xref:System.Net.Sockets.Socket.Bind%2A> 方法将 <xref:System.Net.Sockets.Socket> 显式绑定到本地终结点。 否则，<xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 将引发 <xref:System.Net.Sockets.SocketException>。  
  
 对于无连接协议，<xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 将读取接收到本地网络缓冲区中的第一个排队数据报。 如果接收的数据报大于 `buffer`的大小，则 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 方法会将尽可能多的消息填入 `buffer`，并引发 <xref:System.Net.Sockets.SocketException>。 如果使用的是不可靠的协议，则过量的数据将丢失。 如果你使用的是可靠协议，则会将多余的数据保留在服务提供程序中，并且你可以通过使用足够大的缓冲区调用 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 方法来检索它。  
  
 如果没有可供读取的数据，<xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 方法将被阻止，直到数据可用。 如果处于非阻止模式，并且协议堆栈缓冲区中没有可用的数据，则 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 方法将立即完成，并引发 <xref:System.Net.Sockets.SocketException>。 您可以使用 <xref:System.Net.Sockets.Socket.Available%2A> 属性来确定数据是否可用于读取。 如果 <xref:System.Net.Sockets.Socket.Available%2A> 非零，则重试接收操作。  
  
 尽管 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 适用于无连接协议，但你也可以使用面向连接的协议。 如果选择这样做，则必须先通过调用 <xref:System.Net.Sockets.Socket.Connect%2A> 方法建立远程主机连接，或通过调用 <xref:System.Net.Sockets.Socket.Accept%2A> 方法接受传入的远程主机连接。 如果在调用 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 方法之前未建立或接受连接，则将获得一个 <xref:System.Net.Sockets.SocketException>。 还可以在调用 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 方法之前，为无连接协议建立默认远程主机。 在这两种情况下，<xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 方法将忽略 `remoteEP` 参数，并仅从已连接或默认的远程主机接收数据。  
  
 使用面向连接的套接字时，<xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 将读取尽可能多的数据，直到 `buffer`的大小。 如果远程主机使用 <xref:System.Net.Sockets.Socket.Shutdown%2A> 方法关闭 <xref:System.Net.Sockets.Socket> 连接，并且收到所有可用数据，则 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 方法会立即完成并返回零字节。  
  
> [!NOTE]
>  如果收到 <xref:System.Net.Sockets.SocketException>，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。 获取此代码后，请参阅[Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2)文档，以获取有关错误的详细说明。  
  
> [!NOTE]
>  <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 中使用的 <xref:System.Net.EndPoint> 的 <xref:System.Net.Sockets.AddressFamily> 需要与 <xref:System.Net.EndPoint> 中使用的 <xref:System.Net.Sockets.Socket.SendTo%2A>的 <xref:System.Net.Sockets.AddressFamily> 匹配。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[.NET Framework 中的网络跟踪](/dotnet/framework/network-programming/network-tracing)。  
  
   
  
## Examples  
 下面的代码示例从远程主机接收无连接的数据报。  
  
 [!code-cpp[Socket_Sync_Send_Receive#9](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#9)]
 [!code-csharp[Socket_Sync_Send_Receive#9](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#9)]
 [!code-vb[Socket_Sync_Send_Receive#9](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> 为 <see langword="null" />。  
  
-或- 
 <paramref name="remoteEP" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <exception cref="T:System.Security.SecurityException">调用堆栈中的调用方没有所需的权限。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveFrom">
      <MemberSignature Language="C#" Value="public int ReceiveFrom (byte[] buffer, System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ReceiveFrom(unsigned int8[] buffer, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint&amp; remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveFrom (buffer As Byte(), socketFlags As SocketFlags, ByRef remoteEP As EndPoint) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ReceiveFrom(cli::array &lt;System::Byte&gt; ^ buffer, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ % remoteEP);" />
      <MemberSignature Language="F#" Value="member this.ReceiveFrom : byte[] * System.Net.Sockets.SocketFlags * EndPoint -&gt; int" Usage="socket.ReceiveFrom (buffer, socketFlags, remoteEP)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" RefType="ref" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="buffer"><see cref="T:System.Byte" /> 类型的数组，它是存储接收到的数据的位置。</param>
        <param name="socketFlags"><see cref="T:System.Net.Sockets.SocketFlags" /> 值的按位组合。</param>
        <param name="remoteEP">通过引用传递的 <see cref="T:System.Net.EndPoint" />，表示远程服务器。</param>
        <summary>使用指定的 <see cref="T:System.Net.Sockets.SocketFlags" /> 将数据报接收到数据缓冲区并存储终结点。</summary>
        <returns>收到的字节数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 方法将数据读入 `buffer` 参数，返回成功读取的字节数，并捕获从其发送数据的远程主机终结点。 如果打算从未知主机或多台主机接收无连接的数据报，此方法非常有用。  
  
 此重载只要求你提供接收缓冲区、必需的 <xref:System.Net.Sockets.SocketFlags>以及表示远程主机的 <xref:System.Net.EndPoint>。 偏移量默认为0，大小默认为 buffer 参数的长度。  
  
> [!NOTE]
>  在调用 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>之前，必须使用 <xref:System.Net.Sockets.Socket.Bind%2A> 方法将 <xref:System.Net.Sockets.Socket> 显式绑定到本地终结点。 否则，<xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 将引发 <xref:System.Net.Sockets.SocketException>。  
  
 对于无连接协议，<xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 将读取接收到本地网络缓冲区中的第一个排队数据报。 如果接收的数据报大于 `buffer`的大小，则 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 方法会将尽可能多的消息填入 `buffer`，并引发 <xref:System.Net.Sockets.SocketException>。 如果使用的是不可靠的协议，则过量的数据将丢失。 如果你使用的是可靠协议，则会将多余的数据保留在服务提供程序中，并且你可以通过使用足够大的缓冲区调用 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 方法来检索它。  
  
 如果没有可供读取的数据，<xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 方法将被阻止，直到数据可用。 如果处于非阻止模式，并且协议堆栈缓冲区中没有可用的数据，则 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 方法将立即完成，并引发 <xref:System.Net.Sockets.SocketException>。 您可以使用 <xref:System.Net.Sockets.Socket.Available%2A> 属性来确定数据是否可用于读取。 如果 <xref:System.Net.Sockets.Socket.Available%2A> 非零，则重试接收操作。  
  
 尽管 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 适用于无连接协议，但你也可以使用面向连接的协议。 如果选择这样做，则必须先通过调用 <xref:System.Net.Sockets.Socket.Connect%2A> 方法建立远程主机连接，或通过调用 <xref:System.Net.Sockets.Socket.Accept%2A> 方法接受传入的远程主机连接。 如果在调用 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 方法之前未建立或接受连接，则将获得一个 <xref:System.Net.Sockets.SocketException>。 还可以在调用 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 方法之前，为无连接协议建立默认远程主机。 在这两种情况下，<xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 方法将忽略 `remoteEP` 参数，并仅从已连接或默认的远程主机接收数据。  
  
 使用面向连接的套接字时，<xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 将读取尽可能多的数据，直到 `buffer`的大小。 如果远程主机使用 <xref:System.Net.Sockets.Socket.Shutdown%2A> 方法关闭 <xref:System.Net.Sockets.Socket> 连接，并且收到所有可用数据，则 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 方法会立即完成并返回零字节。  
  
> [!NOTE]
>  如果收到 <xref:System.Net.Sockets.SocketException>，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。 获取此代码后，请参阅[Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2)文档，以获取有关错误的详细说明。  
  
> [!NOTE]
>  <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 中使用的 <xref:System.Net.EndPoint> 的 <xref:System.Net.Sockets.AddressFamily> 需要与 <xref:System.Net.EndPoint> 中使用的 <xref:System.Net.Sockets.Socket.SendTo%2A>的 <xref:System.Net.Sockets.AddressFamily> 匹配。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[.NET Framework 中的网络跟踪](/dotnet/framework/network-programming/network-tracing)。  
  
   
  
## Examples  
 下面的代码示例从远程主机接收无连接的数据报。 <xref:System.Net.Sockets.SocketFlags> 传递到 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 方法。  
  
 [!code-cpp[Socket_Sync_Send_Receive#10](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#10)]
 [!code-csharp[Socket_Sync_Send_Receive#10](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#10)]
 [!code-vb[Socket_Sync_Send_Receive#10](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> 为 <see langword="null" />。  
  
-或- 
 <paramref name="remoteEP" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <exception cref="T:System.Security.SecurityException">调用堆栈中的调用方没有所需的权限。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveFrom">
      <MemberSignature Language="C#" Value="public int ReceiveFrom (byte[] buffer, int size, System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ReceiveFrom(unsigned int8[] buffer, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint&amp; remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveFrom (buffer As Byte(), size As Integer, socketFlags As SocketFlags, ByRef remoteEP As EndPoint) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ReceiveFrom(cli::array &lt;System::Byte&gt; ^ buffer, int size, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ % remoteEP);" />
      <MemberSignature Language="F#" Value="member this.ReceiveFrom : byte[] * int * System.Net.Sockets.SocketFlags * EndPoint -&gt; int" Usage="socket.ReceiveFrom (buffer, size, socketFlags, remoteEP)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="size" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" RefType="ref" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="buffer">类型 <see cref="T:System.Byte" /> 的数组，它是所接受的数据的存储位置。</param>
        <param name="size">要接收的字节数。</param>
        <param name="socketFlags"><see cref="T:System.Net.Sockets.SocketFlags" /> 值的按位组合。</param>
        <param name="remoteEP">通过引用传递的 <see cref="T:System.Net.EndPoint" />，表示远程服务器。</param>
        <summary>使用指定的 <see cref="T:System.Net.Sockets.SocketFlags" /> 将指定的字节数接收到数据缓冲区并存储终结点。</summary>
        <returns>收到的字节数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 方法将数据读入 `buffer` 参数，返回成功读取的字节数，并捕获从其发送数据的远程主机终结点。 如果打算从未知主机或多台主机接收无连接的数据报，此方法非常有用。  
  
 此重载只要求你提供接收缓冲区、要接收的字节数、必需的 <xref:System.Net.Sockets.SocketFlags>以及表示远程主机的 <xref:System.Net.EndPoint>。 缓冲区偏移量默认为0。  
  
 对于无连接协议，<xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 将读取接收到本地网络缓冲区中的第一个排队数据报。 如果接收的数据报大于 `buffer`的大小，则 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 方法会将尽可能多的消息填入 `buffer`，并引发 <xref:System.Net.Sockets.SocketException>。 如果使用的是不可靠的协议，则过量的数据将丢失。 如果你使用的是可靠协议，则会将多余的数据保留在服务提供程序中，并且你可以通过使用足够大的缓冲区调用 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 方法来检索它。  
  
 如果没有可供读取的数据，<xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 方法将被阻止，直到数据可用。 如果处于非阻止模式，并且协议堆栈缓冲区中没有可用的数据，则 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 方法将立即完成，并引发 <xref:System.Net.Sockets.SocketException>。 您可以使用 <xref:System.Net.Sockets.Socket.Available%2A> 属性来确定数据是否可用于读取。 如果 <xref:System.Net.Sockets.Socket.Available%2A> 非零，则重试接收操作。  
  
 尽管 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 适用于无连接协议，但你也可以使用面向连接的协议。 如果选择这样做，则必须先通过调用 <xref:System.Net.Sockets.Socket.Connect%2A> 方法建立远程主机连接，或通过调用 <xref:System.Net.Sockets.Socket.Accept%2A> 方法接受传入的远程主机连接。 如果在调用 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 方法之前未建立或接受连接，则将获得一个 <xref:System.Net.Sockets.SocketException>。 还可以在调用 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 方法之前，为无连接协议建立默认远程主机。 在这两种情况下，<xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 方法将忽略 `remoteEP` 参数，并仅从已连接或默认的远程主机接收数据。  
  
 使用面向连接的套接字时，<xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 将读取尽可能多的数据，最多可达 `size` 参数指定的字节数。 如果远程主机使用 <xref:System.Net.Sockets.Socket.Shutdown%2A> 方法关闭 <xref:System.Net.Sockets.Socket> 连接，并且收到所有可用数据，则 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 方法会立即完成并返回零字节。  
  
> [!NOTE]
>  在调用 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>之前，必须使用 <xref:System.Net.Sockets.Socket.Bind%2A> 方法将 <xref:System.Net.Sockets.Socket> 显式绑定到本地终结点。 否则，<xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 将引发 <xref:System.Net.Sockets.SocketException>。 如果收到 <xref:System.Net.Sockets.SocketException>，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。 获取此代码后，请参阅[Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2)文档，以获取有关错误的详细说明。  
  
> [!NOTE]
>  <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 中使用的 <xref:System.Net.EndPoint> 的 <xref:System.Net.Sockets.AddressFamily> 需要与 <xref:System.Net.EndPoint> 中使用的 <xref:System.Net.Sockets.Socket.SendTo%2A>的 <xref:System.Net.Sockets.AddressFamily> 匹配。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[.NET Framework 中的网络跟踪](/dotnet/framework/network-programming/network-tracing)。  
  
   
  
## Examples  
 下面的代码示例从远程主机接收无连接的数据报。 缓冲区大小和 <xref:System.Net.Sockets.SocketFlags> 会传递到 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 方法。  
  
 [!code-cpp[Socket_Sync_Send_Receive#11](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#11)]
 [!code-csharp[Socket_Sync_Send_Receive#11](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#11)]
 [!code-vb[Socket_Sync_Send_Receive#11](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> 为 <see langword="null" />。  
  
-或- 
 <paramref name="remoteEP" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="size" /> 小于 0。  
  
-或- 
 <paramref name="size" /> 大于 <paramref name="buffer" /> 的长度。</exception>
        <exception cref="T:System.Net.Sockets.SocketException"><paramref name="socketFlags" /> 不是有效的值组合。  
  
-或- 
未设置 <see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /> 属性。  
  
-或- 
访问 <see cref="T:System.Net.Sockets.Socket" /> 时出现操作系统错误。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <exception cref="T:System.Security.SecurityException">调用堆栈中的调用方没有所需的权限。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveFrom">
      <MemberSignature Language="C#" Value="public int ReceiveFrom (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ReceiveFrom(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint&amp; remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveFrom (buffer As Byte(), offset As Integer, size As Integer, socketFlags As SocketFlags, ByRef remoteEP As EndPoint) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ReceiveFrom(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ % remoteEP);" />
      <MemberSignature Language="F#" Value="member this.ReceiveFrom : byte[] * int * int * System.Net.Sockets.SocketFlags * EndPoint -&gt; int" Usage="socket.ReceiveFrom (buffer, offset, size, socketFlags, remoteEP)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" RefType="ref" Index="4" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="buffer">类型 <see cref="T:System.Byte" /> 的数组，它是所接受的数据的存储位置。</param>
        <param name="offset"><paramref name="buffer" /> 参数中的位置，用于存储所接收的数据。</param>
        <param name="size">要接收的字节数。</param>
        <param name="socketFlags"><see cref="T:System.Net.Sockets.SocketFlags" /> 值的按位组合。</param>
        <param name="remoteEP">通过引用传递的 <see cref="T:System.Net.EndPoint" />，表示远程服务器。</param>
        <summary>使用指定的 <see cref="T:System.Net.Sockets.SocketFlags" /> 将指定的数据字节数接收到数据缓冲区的指定位置，并存储终结点。</summary>
        <returns>收到的字节数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 方法将数据读入 `buffer` 参数，返回成功读取的字节数，并捕获从其发送数据的远程主机终结点。 如果打算从未知主机或多台主机接收无连接的数据报，此方法非常有用。  
  
 对于无连接协议，<xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 将读取接收到本地网络缓冲区中的第一个排队数据报。 如果接收的数据报大于 `buffer`的大小，则 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 方法会将尽可能多的消息填入 `buffer`，并引发 <xref:System.Net.Sockets.SocketException>。 如果使用的是不可靠的协议，则过量的数据将丢失。 如果你使用的是可靠协议，则会将多余的数据保留在服务提供程序中，并且你可以通过使用足够大的缓冲区调用 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 方法来检索它。  
  
 如果没有可供读取的数据，<xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 方法将被阻止，直到数据可用。 如果处于非阻止模式，并且协议堆栈缓冲区中没有可用的数据，则 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 方法将立即完成，并引发 <xref:System.Net.Sockets.SocketException>。 您可以使用 <xref:System.Net.Sockets.Socket.Available%2A> 属性来确定数据是否可用于读取。 如果 <xref:System.Net.Sockets.Socket.Available%2A> 非零，则重试接收操作。  
  
 尽管 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 适用于无连接协议，但你也可以使用面向连接的协议。 如果选择这样做，则必须先通过调用 <xref:System.Net.Sockets.Socket.Connect%2A> 方法建立远程主机连接，或通过调用 <xref:System.Net.Sockets.Socket.Accept%2A> 方法接受传入的远程主机连接。 如果在调用 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 方法之前未建立或接受连接，则将获得一个 <xref:System.Net.Sockets.SocketException>。 还可以在调用 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 方法之前，为无连接协议建立默认远程主机。 在这两种情况下，<xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 方法将忽略 `remoteEP` 参数，并仅从已连接或默认的远程主机接收数据。  
  
 使用面向连接的套接字时，<xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 将读取尽可能多的数据，直到 `size` 参数指定的字节数。 如果远程主机使用 <xref:System.Net.Sockets.Socket.Shutdown%2A> 方法关闭 <xref:System.Net.Sockets.Socket> 连接，并且收到所有可用数据，则 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 方法会立即完成并返回零字节。  
  
> [!NOTE]
>  在调用 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>之前，必须使用 <xref:System.Net.Sockets.Socket.Bind%2A> 方法将 <xref:System.Net.Sockets.Socket> 显式绑定到本地终结点。 否则，<xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 将引发 <xref:System.Net.Sockets.SocketException>。 如果收到 <xref:System.Net.Sockets.SocketException>，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。 获取此代码后，请参阅[Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2)文档，以获取有关错误的详细说明。  
  
> [!NOTE]
>  <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 中使用的 <xref:System.Net.EndPoint> 的 <xref:System.Net.Sockets.AddressFamily> 需要与 <xref:System.Net.EndPoint> 中使用的 <xref:System.Net.Sockets.Socket.SendTo%2A>的 <xref:System.Net.Sockets.AddressFamily> 匹配。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[.NET Framework 中的网络跟踪](/dotnet/framework/network-programming/network-tracing)。  
  
   
  
## Examples  
 下面的代码示例从远程主机接收无连接的数据报。 偏移量、缓冲区大小和 <xref:System.Net.Sockets.SocketFlags> 会传递到 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 方法。  
  
 [!code-cpp[Socket_Sync_Send_Receive#12](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#12)]
 [!code-csharp[Socket_Sync_Send_Receive#12](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#12)]
 [!code-vb[Socket_Sync_Send_Receive#12](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> 为 <see langword="null" />。  
  
-或- 
 <paramref name="remoteEP" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" /> 小于 0。  
  
-或- 
 <paramref name="offset" /> 大于 <paramref name="buffer" /> 的长度。  
  
-或- 
 <paramref name="size" /> 小于 0。  
  
-或- 
 <paramref name="size" /> 大于 <paramref name="buffer" /> 的长度减去偏移量参数的值。</exception>
        <exception cref="T:System.Net.Sockets.SocketException"><paramref name="socketFlags" /> 不是有效的值组合。  
  
-或- 
未设置 <see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /> 属性。  
  
-或- 
尝试访问套接字时出错。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveFromAsync">
      <MemberSignature Language="C#" Value="public bool ReceiveFromAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ReceiveFromAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveFromAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveFromAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ReceiveFromAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.ReceiveFromAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="socket.ReceiveFromAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="e">要用于此异步套接字操作的 <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> 对象。</param>
        <summary>开始从指定网络设备中异步接收数据。</summary>
        <returns>如果 I/O 操作挂起，则为 <see langword="true" />。 操作完成时，将引发 <paramref name="e" /> 参数的 <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> 事件。  
  
 如果 I/O 操作同步完成，则为 <see langword="false" />。 在这种情况下，将不会引发 <paramref name="e" /> 参数的 <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> 事件，并且可能在方法调用返回后立即检查作为参数传递的 <paramref name="e" /> 对象以检索操作的结果。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A> 方法主要用于接收无连接套接字上的数据。 套接字的本地地址必须是已知的。  
  
 调用方必须将 <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> 属性设置为从中接收数据的远程主机的 <xref:System.Net.IPEndPoint>。  
  
 `e` 参数的 <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags%2A?displayProperty=nameWithType> 属性为窗口套接字服务提供程序提供有关读取请求的其他信息。 有关如何使用此参数的详细信息，请参阅 <xref:System.Net.Sockets.SocketFlags?displayProperty=nameWithType>。  
  
 若要成功调用此方法，需要 <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> 对象上的下列属性和事件：  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
 调用方可以在调用 <xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A> 方法之前将 <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> 属性设置为所需的任何用户状态对象，以便可以在回调方法中检索信息。 如果回调需要比单个对象更多的信息，则可以创建一个小类，以将其他所需的状态信息保存为成员。  
  
 对于面向消息的套接字，传入消息会放入缓冲区中，直到缓冲区的总大小。 "<xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType>" 和 "<xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType> 属性" 确定数据放置到缓冲区中的位置以及数据量。  
  
 对于字节流样式的套接字，传入的数据将被放入缓冲区中，直到缓冲区填充完毕、连接关闭或内部缓冲的数据被耗尽。 "<xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType>" 和 "<xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType> 属性" 确定数据放置到缓冲区中的位置以及数据量。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> 不能为 null。</exception>
        <exception cref="T:System.InvalidOperationException">已经在使用 <paramref name="e" /> 参数中指定的 <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> 对象执行套接字操作。</exception>
        <exception cref="T:System.NotSupportedException">此方法需要 Windows XP 或更高版本。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Offset" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveMessageFrom">
      <MemberSignature Language="C#" Value="public int ReceiveMessageFrom (byte[] buffer, int offset, int size, ref System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint remoteEP, out System.Net.Sockets.IPPacketInformation ipPacketInformation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ReceiveMessageFrom(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags&amp; socketFlags, class System.Net.EndPoint&amp; remoteEP, [out] valuetype System.Net.Sockets.IPPacketInformation&amp; ipPacketInformation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveMessageFrom (buffer As Byte(), offset As Integer, size As Integer, ByRef socketFlags As SocketFlags, ByRef remoteEP As EndPoint, ByRef ipPacketInformation As IPPacketInformation) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ReceiveMessageFrom(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags % socketFlags, System::Net::EndPoint ^ % remoteEP, [Runtime::InteropServices::Out] System::Net::Sockets::IPPacketInformation % ipPacketInformation);" />
      <MemberSignature Language="F#" Value="member this.ReceiveMessageFrom : byte[] * int * int * SocketFlags * EndPoint * IPPacketInformation -&gt; int" Usage="socket.ReceiveMessageFrom (buffer, offset, size, socketFlags, remoteEP, ipPacketInformation)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO("Not implemented")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" RefType="ref" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" RefType="ref" Index="4" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="ipPacketInformation" Type="System.Net.Sockets.IPPacketInformation" RefType="out" Index="5" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="buffer">类型 <see cref="T:System.Byte" /> 的数组，它是所接受的数据的存储位置。</param>
        <param name="offset"><paramref name="buffer" /> 参数中的位置，用于存储所接收的数据。</param>
        <param name="size">要接收的字节数。</param>
        <param name="socketFlags"><see cref="T:System.Net.Sockets.SocketFlags" /> 值的按位组合。</param>
        <param name="remoteEP">通过引用传递的 <see cref="T:System.Net.EndPoint" />，表示远程服务器。</param>
        <param name="ipPacketInformation">保存地址和接口信息的 <see cref="T:System.Net.Sockets.IPPacketInformation" />。</param>
        <summary>使用指定的 <see cref="T:System.Net.Sockets.SocketFlags" /> 将指定字节数的数据接收到指定的数据缓冲区位置，并存储终结点和数据包信息。</summary>
        <returns>收到的字节数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> 方法将数据读入 `buffer` 参数，返回成功读取的字节数，并捕获从其发送数据的远程主机终结点以及有关已接收数据包的信息。  
  
 <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> 方法主要用于接收无连接套接字上的消息数据。 套接字的本地地址必须是已知的。 此方法只能用于数据报和原始套接字。 在调用此方法之前，必须用设置为 <xref:System.Net.Sockets.SocketType.Dgram> 或 <xref:System.Net.Sockets.SocketType.Raw> 的套接字类型来初始化套接字。 当使用 <xref:System.Net.Sockets.Socket.%23ctor%2A>构造套接字时，可以执行此操作。  
  
 对于面向消息的套接字，会将传入消息放入 `buffer` 参数，直到 `size` 参数中指定的总大小。 `offset` 参数确定放置数据的 `buffer` 位置。 放入 `buffer` 的实际数据量由 <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> 方法返回。  
  
 <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> 方法自动方法将 <xref:System.Net.Sockets.SocketOptionName.PacketInformation> 套接字选项设置为第一次为给定 <xref:System.Net.Sockets.Socket>调用时 `true`。 但是，返回的 <xref:System.Net.Sockets.IPPacketInformation> 对象将仅对在设置套接字选项后到达本地计算机的数据包有效。 如果套接字在绑定到本地终结点（显式由 <xref:System.Net.Sockets.Socket.Bind%2A> 方法或由 <xref:System.Net.Sockets.Socket.Connect%2A>、<xref:System.Net.Sockets.Socket.ConnectAsync%2A>、<xref:System.Net.Sockets.Socket.SendTo%2A>或 <xref:System.Net.Sockets.Socket.SendToAsync%2A> 方法之一隐式的情况下）和第一次调用 <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> 方法时发送，则对 <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> 方法的调用将为这些数据包返回无效 <xref:System.Net.Sockets.IPPacketInformation> 对象。  
  
 若要确保所有 <xref:System.Net.Sockets.IPPacketInformation> 对象都有效，应用程序应该先将 <xref:System.Net.Sockets.SocketOptionName.PacketInformation> 套接字选项设置为 `true`，然后再使用 <xref:System.Net.Sockets.Socket.SetSocketOption%28System.Net.Sockets.SocketOptionLevel%2CSystem.Net.Sockets.SocketOptionName%2CSystem.Boolean%29> 方法将其绑定到本地终结点。  
  
 如果应用程序需要知道是否使用单播、多播或广播地址发送了数据报，则该应用程序可以检查 `ipPacketInformation` 参数。  
  
> [!NOTE]
>  <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 中使用的 <xref:System.Net.EndPoint> 的 <xref:System.Net.Sockets.AddressFamily> 需要与 <xref:System.Net.EndPoint> 中使用的 <xref:System.Net.Sockets.Socket.SendTo%2A>的 <xref:System.Net.Sockets.AddressFamily> 匹配。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[.NET Framework 中的网络跟踪](/dotnet/framework/network-programming/network-tracing)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> 为 <see langword="null" />。  
  
-或- 
 <paramref name="remoteEP" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" /> 小于 0。  
  
-或- 
 <paramref name="offset" /> 大于 <paramref name="buffer" /> 的长度。  
  
-或- 
 <paramref name="size" /> 小于 0。  
  
-或- 
 <paramref name="size" /> 大于 <paramref name="buffer" /> 的长度减去偏移量参数的值。</exception>
        <exception cref="T:System.Net.Sockets.SocketException"><paramref name="socketFlags" /> 不是有效的值组合。  
  
-或- 
未设置 <see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /> 属性。  
  
-或- 
.NET Framework 运行在 AMD 64 位处理器上。  
  
-或- 
尝试访问套接字时出错。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveMessageFromAsync">
      <MemberSignature Language="C#" Value="public bool ReceiveMessageFromAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ReceiveMessageFromAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveMessageFromAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveMessageFromAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ReceiveMessageFromAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.ReceiveMessageFromAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="socket.ReceiveMessageFromAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO("Not implemented")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="e">要用于此异步套接字操作的 <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> 对象。</param>
        <summary>开始使用指定的 <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags" /> 将指定字节数的数据异步接收到数据缓冲区的指定位置，并存储终结点和数据包信息。</summary>
        <returns>如果 I/O 操作挂起，则为 <see langword="true" />。 操作完成时，将引发 <paramref name="e" /> 参数的 <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> 事件。  
  
 如果 I/O 操作同步完成，则为 <see langword="false" />。 在这种情况下，将不会引发 <paramref name="e" /> 参数的 <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> 事件，并且可能在方法调用返回后立即检查作为参数传递的 <paramref name="e" /> 对象以检索操作的结果。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A> 方法主要用于接收无连接套接字上的消息数据。 套接字的本地地址必须是已知的。 此方法只能用于数据报和原始套接字。 在调用此方法之前，必须用设置为 <xref:System.Net.Sockets.SocketType.Dgram> 或 <xref:System.Net.Sockets.SocketType.Raw> 的套接字类型来初始化套接字。 当使用 <xref:System.Net.Sockets.Socket.%23ctor%2A>构造套接字时，可以执行此操作。  
  
 调用方必须将 <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> 属性设置为从中接收数据的远程主机的 <xref:System.Net.IPEndPoint>。  
  
 若要成功调用此方法，需要 <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> 对象上的下列属性和事件：  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
 调用方可以在调用 <xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A> 方法之前将 <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> 属性设置为所需的任何用户状态对象，以便可以在回调方法中检索信息。 如果回调需要比单个对象更多的信息，则可以创建一个小类，以将其他所需的状态信息保存为成员。  
  
 对于面向消息的套接字，传入消息会放入缓冲区中，直到缓冲区的总大小。 "<xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType>" 和 "<xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType> 属性" 确定数据放置到缓冲区中的位置以及数据量。  
  
 <xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A> 方法自动将 <xref:System.Net.Sockets.SocketOptionName.PacketInformation> 套接字选项设置为第一次为给定 <xref:System.Net.Sockets.Socket>调用时 `true`。 但是，在设置套接字选项后，<xref:System.Net.Sockets.IPPacketInformation> 对象将仅对到达本地计算机的数据包有效。 如果套接字在将套接字绑定到本地终结点（由 <xref:System.Net.Sockets.Socket.Bind%2A> 方法显式调用，或由 <xref:System.Net.Sockets.Socket.Connect%2A>、<xref:System.Net.Sockets.Socket.ConnectAsync%2A>、<xref:System.Net.Sockets.Socket.SendTo%2A>或 <xref:System.Net.Sockets.Socket.SendToAsync%2A> 方法之一隐式或由第一次调用 <xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A> 方法）之间发送数据包，则对 <xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A> 方法的调用将导致这些包的 <xref:System.Net.Sockets.IPPacketInformation> 对象无效。  
  
 若要确保所有 <xref:System.Net.Sockets.IPPacketInformation> 对象都有效，应用程序应该先将 <xref:System.Net.Sockets.SocketOptionName.PacketInformation> 套接字选项设置为`true`，然后再使用 <xref:System.Net.Sockets.Socket.SetSocketOption%28System.Net.Sockets.SocketOptionLevel%2CSystem.Net.Sockets.SocketOptionName%2CSystem.Boolean%29> 方法将其绑定到本地终结点。  
  
 如果应用程序需要知道是否使用单播、多播或广播地址发送了数据报，则该应用程序可以检查生成的 <xref:System.Net.Sockets.IPPacketInformation> 对象。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> 不能为 null。</exception>
        <exception cref="T:System.NotSupportedException">此方法需要 Windows XP 或更高版本。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Offset" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveTimeout">
      <MemberSignature Language="C#" Value="public int ReceiveTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ReceiveTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.ReceiveTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Property ReceiveTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ReceiveTimeout { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.ReceiveTimeout : int with get, set" Usage="System.Net.Sockets.Socket.ReceiveTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指定之后同步 <see cref="Overload:System.Net.Sockets.Socket.Receive" /> 调用将超时的时间长度。</summary>
        <value>超时值（以毫秒为单位）。 默认值为 0，指示超时期限无限大。 指定 -1 还会指示超时期限无限大。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此选项仅适用于同步 <xref:System.Net.Sockets.Socket.Receive%2A> 调用。 如果超过超时期限，<xref:System.Net.Sockets.Socket.Receive%2A> 方法将引发 <xref:System.Net.Sockets.SocketException>。  
  
   
  
## Examples  
 下面的代码示例演示如何使用 <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A> 属性。  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">为设置操作指定的值小于 1。</exception>
      </Docs>
    </Member>
    <Member MemberName="RemoteEndPoint">
      <MemberSignature Language="C#" Value="public System.Net.EndPoint RemoteEndPoint { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.EndPoint RemoteEndPoint" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.RemoteEndPoint" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RemoteEndPoint As EndPoint" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::EndPoint ^ RemoteEndPoint { System::Net::EndPoint ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.RemoteEndPoint : System.Net.EndPoint" Usage="System.Net.Sockets.Socket.RemoteEndPoint" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.EndPoint</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取远程终结点。</summary>
        <value>当前和 <see cref="T:System.Net.EndPoint" /> 通信的 <see cref="T:System.Net.Sockets.Socket" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果使用面向连接的协议，则 <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> 属性将获取 <xref:System.Net.EndPoint>，其中包含 <xref:System.Net.Sockets.Socket> 连接到的远程 IP 地址和端口号。 如果使用的是无连接协议，<xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> 将包含 <xref:System.Net.Sockets.Socket> 将与之通信的默认远程 IP 地址和端口号。 在检索任何信息之前，必须将此 <xref:System.Net.EndPoint> 强制转换为 <xref:System.Net.IPEndPoint>。 然后，可以调用 <xref:System.Net.IPEndPoint.Address%2A?displayProperty=nameWithType> 方法检索远程 <xref:System.Net.IPAddress>，并调用 <xref:System.Net.IPEndPoint.Port%2A?displayProperty=nameWithType> 方法来检索远程端口号。  
  
 <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> 在调用 <xref:System.Net.Sockets.Socket.Accept%2A> 或 <xref:System.Net.Sockets.Socket.Connect%2A>后设置。 如果你之前尝试访问此属性，<xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> 将引发 <xref:System.Net.Sockets.SocketException>。 如果收到 <xref:System.Net.Sockets.SocketException>，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。 获取此代码后，请参阅[Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2)文档，以获取有关错误的详细说明。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[.NET Framework 中的网络跟踪](/dotnet/framework/network-programming/network-tracing)。  
  
   
  
## Examples  
 下面的代码示例检索并显示本地和远程终结点。  
  
 [!code-cpp[Socket_Socket_Options#4](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#4)]
 [!code-csharp[Socket_Socket_Options#4](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#4)]
 [!code-vb[Socket_Socket_Options#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <altmember cref="T:System.Net.EndPoint" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Accept" />
      </Docs>
    </Member>
    <Member MemberName="SafeHandle">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.SafeSocketHandle SafeHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.Sockets.SafeSocketHandle SafeHandle" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.SafeHandle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SafeHandle As SafeSocketHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Sockets::SafeSocketHandle ^ SafeHandle { System::Net::Sockets::SafeSocketHandle ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SafeHandle : System.Net.Sockets.SafeSocketHandle" Usage="System.Net.Sockets.Socket.SafeHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.SafeSocketHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个 <see cref="T:System.Net.Sockets.SafeSocketHandle" />，它表示当前 <see cref="T:System.Net.Sockets.Socket" /> 对象封装的套接字句柄。</summary>
        <value>以安全方式公开当前 <see cref="T:System.Net.Sockets.Socket" /> 对象封装的套接字的套接字句柄。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  

> [!IMPORTANT]
> 使用 <xref:System.Net.Sockets.SafeSocketHandle> 直接对套接字进行操作可能会导致未记录状态。 

         ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Select">
      <MemberSignature Language="C#" Value="public static void Select (System.Collections.IList checkRead, System.Collections.IList checkWrite, System.Collections.IList checkError, int microSeconds);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Select(class System.Collections.IList checkRead, class System.Collections.IList checkWrite, class System.Collections.IList checkError, int32 microSeconds) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Select(System.Collections.IList,System.Collections.IList,System.Collections.IList,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Select (checkRead As IList, checkWrite As IList, checkError As IList, microSeconds As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Select(System::Collections::IList ^ checkRead, System::Collections::IList ^ checkWrite, System::Collections::IList ^ checkError, int microSeconds);" />
      <MemberSignature Language="F#" Value="static member Select : System.Collections.IList * System.Collections.IList * System.Collections.IList * int -&gt; unit" Usage="System.Net.Sockets.Socket.Select (checkRead, checkWrite, checkError, microSeconds)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="checkRead" Type="System.Collections.IList" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="checkWrite" Type="System.Collections.IList" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="checkError" Type="System.Collections.IList" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="microSeconds" Type="System.Int32" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="checkRead">用于检查可读性的 <see cref="T:System.Net.Sockets.Socket" /> 实例的 <see cref="T:System.Collections.IList" />。</param>
        <param name="checkWrite">用于检查可写性的 <see cref="T:System.Net.Sockets.Socket" /> 实例的 <see cref="T:System.Collections.IList" />。</param>
        <param name="checkError">用于检查错误的 <see cref="T:System.Net.Sockets.Socket" /> 实例的 <see cref="T:System.Collections.IList" />。</param>
        <param name="microSeconds">超时值（以微秒为单位）。 值 -1 指示无限超时。</param>
        <summary>确定一个或多个套接字的状态。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Select%2A> 是一种静态方法，用于确定一个或多个 <xref:System.Net.Sockets.Socket> 实例的状态。 必须将一个或多个套接字置于 <xref:System.Collections.IList>，然后才能使用 <xref:System.Net.Sockets.Socket.Select%2A> 方法。 通过使用 <xref:System.Collections.IList> 作为 `checkRead` 参数调用 <xref:System.Net.Sockets.Socket.Select%2A> 来检查是否有可读性。 若要检查套接字是否可写性，请使用 `checkWrite` 参数。 对于检测错误条件，请使用 `checkError`。 调用 <xref:System.Net.Sockets.Socket.Select%2A>后，<xref:System.Collections.IList> 将只填充满足条件的那些套接字。  
  
 如果处于侦听状态，则可读性意味着对 <xref:System.Net.Sockets.Socket.Accept%2A> 的调用将成功，而不会受到阻止。 如果已接受连接，则可读性意味着数据可用于读取。 在这些情况下，所有接收操作都将成功，但不会被阻止。 可读性还可以指示远程 <xref:System.Net.Sockets.Socket> 是否已关闭连接;在这种情况下，对 <xref:System.Net.Sockets.Socket.Receive%2A> 的调用将立即返回，返回零个字节。  
  
 如果至少有一个感兴趣的套接字（`checkRead`、`checkWrite`和 `checkError` 列表中的套接字）满足指定的条件，或者超过了 `microSeconds` 参数（以第一个为准），<xref:System.Net.Sockets.Socket.Select%2A> 将返回。 将 `microSeconds` 设置为-1 表示无限期超时。  
  
 如果对 <xref:System.Net.Sockets.Socket.Connect%2A>进行非阻止调用，则可写性表示已成功连接。 如果已建立连接，可写性意味着所有发送操作都将成功，且不会阻止。  
  
 如果对 <xref:System.Net.Sockets.Socket.Connect%2A>进行了非阻塞调用，则 `checkerror` 参数将标识未成功连接的套接字。  
  
> [!NOTE]
>  如果只想确定单个 <xref:System.Net.Sockets.Socket>的状态，请使用 <xref:System.Net.Sockets.Socket.Poll%2A> 方法。  
  
> [!NOTE]
>  此方法无法检测某些类型的连接问题，例如网络电缆损坏或远程主机已关闭意外。 您必须尝试发送或接收数据，以检测这些类型的错误。  
  
> [!NOTE]
>  如果收到 <xref:System.Net.Sockets.SocketException>，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。 获取此代码后，请参阅[Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2)文档，以获取有关错误的详细说明。  
  
   
  
## Examples  
 下面的代码示例使用 <xref:System.Net.Sockets.Socket.Select%2A> 来确定哪些侦听套接字具有连接请求。  
  
 [!code-cpp[Socket_Select#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Select/CPP/source.cpp#1)]
 [!code-csharp[Socket_Select#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Select/CS/source.cs#1)]
 [!code-vb[Socket_Select#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Select/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="checkRead" /> 参数为 <see langword="null" /> 或为空。  
  
和 
<paramref name="checkWrite" /> 参数为 <see langword="null" /> 或为空 
和 
<paramref name="checkError" /> 参数为 <see langword="null" /> 或为空。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <altmember cref="T:System.Collections.IList" />
        <altmember cref="M:System.Net.Sockets.Socket.Accept" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Send">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>将数据发送到连接的 <see cref="T:System.Net.Sockets.Socket" />。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (byte[] buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(unsigned int8[] buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Send (buffer As Byte()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(cli::array &lt;System::Byte&gt; ^ buffer);" />
      <MemberSignature Language="F#" Value="member this.Send : byte[] -&gt; int" Usage="socket.Send buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="buffer">类型 <see cref="T:System.Byte" /> 的数组，其中包含要发送的数据。</param>
        <summary>将数据发送到连接的 <see cref="T:System.Net.Sockets.Socket" />。</summary>
        <returns>发送到 <see cref="T:System.Net.Sockets.Socket" /> 的字节数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Send%2A> 将数据同步发送到 <xref:System.Net.Sockets.Socket.Connect%2A> 或 <xref:System.Net.Sockets.Socket.Accept%2A> 方法中指定的远程主机，并返回成功发送的字节数。 <xref:System.Net.Sockets.Socket.Send%2A> 可用于面向连接的协议和无连接的协议。  
  
 此重载需要包含要发送的数据的缓冲区。 <xref:System.Net.Sockets.SocketFlags> 值默认为0，缓冲区偏移量默认为0，要发送的字节数默认为缓冲区的大小。  
  
 如果使用的是无连接协议，则必须在调用此方法之前调用 <xref:System.Net.Sockets.Socket.Connect%2A>，否则 <xref:System.Net.Sockets.Socket.Send%2A> 将引发 <xref:System.Net.Sockets.SocketException>。 如果使用面向连接的协议，则必须使用 <xref:System.Net.Sockets.Socket.Connect%2A> 建立远程主机连接，或使用 <xref:System.Net.Sockets.Socket.Accept%2A> 来接受传入连接。  
  
 如果使用无连接协议并计划将数据发送到多个不同的主机，则应使用 <xref:System.Net.Sockets.Socket.SendTo%2A> 方法。 如果不使用 <xref:System.Net.Sockets.Socket.SendTo%2A> 方法，则必须在每次调用 <xref:System.Net.Sockets.Socket.Send%2A>之前调用 <xref:System.Net.Sockets.Socket.Connect%2A>。 即使已使用 <xref:System.Net.Sockets.Socket.Connect%2A>建立默认远程主机，也可以使用 <xref:System.Net.Sockets.Socket.SendTo%2A>。 还可以在调用 <xref:System.Net.Sockets.Socket.Send%2A> 之前更改默认远程主机，方法是调用 <xref:System.Net.Sockets.Socket.Connect%2A>。  
  
 如果使用面向连接的协议，则在发送缓冲区中的所有字节之前，<xref:System.Net.Sockets.Socket.Send%2A> 会一直阻止，除非使用 <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>设置了超时。 如果超过超时值，则 <xref:System.Net.Sockets.Socket.Send%2A> 调用将引发 <xref:System.Net.Sockets.SocketException>。 在非阻止模式下，即使发送的字节数小于缓冲区中的字节数，<xref:System.Net.Sockets.Socket.Send%2A> 也可能成功完成。 应用程序负责跟踪发送的字节数，并在应用程序发送缓冲区中的字节之前重试该操作。 还不能保证发送的数据会立即显示在网络上。 为了提高网络效率，基础系统可能会延迟传输，直到收集大量传出数据。 成功完成 <xref:System.Net.Sockets.Socket.Send%2A> 方法意味着基础系统具有空间来缓冲用于网络发送的数据。  
  
> [!NOTE]
>  如果收到 <xref:System.Net.Sockets.SocketException>，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。 获取此代码后，请参阅[Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2)文档，以获取有关错误的详细说明。  
  
> [!NOTE]
>  成功完成发送并不表示数据已成功传递。 如果传输系统中没有可用于保存要传输的数据的缓冲区空间，则发送将会阻止，除非已将套接字置于非阻止模式。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[.NET Framework 中的网络跟踪](/dotnet/framework/network-programming/network-tracing)。  
  
   
  
## Examples  
 下面的代码示例演示如何在连接的 <xref:System.Net.Sockets.Socket>上发送数据。  
  
 [!code-cpp[Socket_Sync_Send_Receive#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#1)]
 [!code-csharp[Socket_Sync_Send_Receive#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#1)]
 [!code-vb[Socket_Sync_Send_Receive#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})" />
      <MemberSignature Language="VB.NET" Value="Public Function Send (buffers As IList(Of ArraySegment(Of Byte))) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers);" />
      <MemberSignature Language="F#" Value="member this.Send : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; -&gt; int" Usage="socket.Send buffers" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="buffers"><see cref="T:System.ArraySegment`1" /> 类型的 <see cref="T:System.Byte" /> 的列表，它包含要发送的数据。</param>
        <summary>将列表中的一组缓冲区发送到连接的 <see cref="T:System.Net.Sockets.Socket" />。</summary>
        <returns>发送到 <see cref="T:System.Net.Sockets.Socket" /> 的字节数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Send%2A> 可用于面向连接的协议和无连接的协议。  
  
 此重载至少需要一个包含要发送的数据的缓冲区。  
  
 如果使用的是无连接协议，则必须在调用此方法之前调用 <xref:System.Net.Sockets.Socket.Connect%2A>，否则 <xref:System.Net.Sockets.Socket.Send%2A> 将引发 <xref:System.Net.Sockets.SocketException>。 如果使用面向连接的协议，则必须使用 <xref:System.Net.Sockets.Socket.Connect%2A> 建立远程主机连接，或使用 <xref:System.Net.Sockets.Socket.Accept%2A> 来接受传入连接。  
  
 如果使用无连接协议并计划将数据发送到多个不同的主机，则应使用 <xref:System.Net.Sockets.Socket.SendTo%2A> 方法。 如果不使用 <xref:System.Net.Sockets.Socket.SendTo%2A> 方法，则必须在每次调用 <xref:System.Net.Sockets.Socket.Send%2A>之前调用 <xref:System.Net.Sockets.Socket.Connect%2A>。 即使已使用 <xref:System.Net.Sockets.Socket.Connect%2A>建立默认远程主机，也可以使用 <xref:System.Net.Sockets.Socket.SendTo%2A>。 还可以在调用 <xref:System.Net.Sockets.Socket.Send%2A> 之前更改默认远程主机，方法是调用 <xref:System.Net.Sockets.Socket.Connect%2A>。  
  
 如果使用面向连接的协议，则在发送缓冲区中的所有字节之前，<xref:System.Net.Sockets.Socket.Send%2A> 会一直阻止，除非使用 <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>设置了超时。 如果超过超时值，则 <xref:System.Net.Sockets.Socket.Send%2A> 调用将引发 <xref:System.Net.Sockets.SocketException>。 在非阻止模式下，即使发送的字节数小于缓冲区中的字节数，<xref:System.Net.Sockets.Socket.Send%2A> 也可能成功完成。 应用程序负责跟踪发送的字节数，并在应用程序发送缓冲区中的字节之前重试该操作。 还不能保证发送的数据会立即显示在网络上。 为了提高网络效率，基础系统可能会延迟传输，直到收集大量传出数据。 成功完成 <xref:System.Net.Sockets.Socket.Send%2A> 方法意味着基础系统具有空间来缓冲用于网络发送的数据。  
  
> [!NOTE]
>  如果收到 <xref:System.Net.Sockets.SocketException>，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。 获取此代码后，请参阅[Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2)文档，以获取有关错误的详细说明。  
  
> [!NOTE]
>  成功完成发送并不表示数据已成功传递。 如果传输系统中没有可用于保存要传输的数据的缓冲区空间，则发送将会阻止，除非已将套接字置于非阻止模式。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[.NET Framework 中的网络跟踪](/dotnet/framework/network-programming/network-tracing)。  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Net.Sockets.Socket.Send(System.Byte[])" />
        <exception cref="T:System.ArgumentNullException"><paramref name="buffers" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="buffers" /> 为空。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。 请参见下面的备注部分。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (ReadOnlySpan&lt;byte&gt; buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.ReadOnlySpan{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Function Send (buffer As ReadOnlySpan(Of Byte)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(ReadOnlySpan&lt;System::Byte&gt; buffer);" />
      <MemberSignature Language="F#" Value="member this.Send : ReadOnlySpan&lt;byte&gt; -&gt; int" Usage="socket.Send buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="buffer">一个字符范围，其中包含要发送的数据。</param>
        <summary>将数据发送到连接的 <see cref="T:System.Net.Sockets.Socket" />。</summary>
        <returns>发送到 <see cref="T:System.Net.Sockets.Socket" /> 的字节数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks

<xref:System.Net.Sockets.Socket.Send%2A> 将数据同步发送到 <xref:System.Net.Sockets.Socket.Connect%2A> 或 <xref:System.Net.Sockets.Socket.Accept%2A> 方法中指定的远程主机，并返回成功发送的字节数。 <xref:System.Net.Sockets.Socket.Send%2A> 可用于面向连接的协议和无连接的协议。

此重载需要包含要发送的数据的缓冲区。 <xref:System.Net.Sockets.SocketFlags> 值默认为0，缓冲区偏移量默认为0，要发送的字节数默认为缓冲区的大小。

如果使用的是无连接协议，则必须在调用此方法之前调用 <xref:System.Net.Sockets.Socket.Connect%2A>，否则 <xref:System.Net.Sockets.Socket.Send%2A> 将引发 <xref:System.Net.Sockets.SocketException>。 如果使用面向连接的协议，则必须使用 <xref:System.Net.Sockets.Socket.Connect%2A> 建立远程主机连接，或使用 <xref:System.Net.Sockets.Socket.Accept%2A> 来接受传入连接。

如果使用的是无连接协议并计划将数据发送到多个不同的主机，则应使用 <xref:System.Net.Sockets.Socket.SendTo%2A> 方法。 如果不使用 <xref:System.Net.Sockets.Socket.SendTo%2A> 方法，则必须在每次调用 <xref:System.Net.Sockets.Socket.Send%2A>之前调用 <xref:System.Net.Sockets.Socket.Connect%2A>。 即使已使用 <xref:System.Net.Sockets.Socket.Connect%2A>建立默认远程主机，也可以使用 <xref:System.Net.Sockets.Socket.SendTo%2A>。 还可以通过对 <xref:System.Net.Sockets.Socket.Connect%2A>进行另一次调用来更改默认远程主机，然后再调用 <xref:System.Net.Sockets.Socket.Send%2A>。

如果使用面向连接的协议，则在发送缓冲区中的所有字节之前，<xref:System.Net.Sockets.Socket.Send%2A> 会一直阻止，除非使用 <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>设置了超时。 如果超过超时值，则 <xref:System.Net.Sockets.Socket.Send%2A> 调用将引发 <xref:System.Net.Sockets.SocketException>。 在非阻止模式下，即使发送的字节数小于缓冲区中的字节数，<xref:System.Net.Sockets.Socket.Send%2A> 也可能成功完成。 应用程序负责跟踪发送的字节数，并在应用程序发送缓冲区中的字节之前重试该操作。 还不能保证发送的数据会立即显示在网络上。 为了提高网络效率，基础系统可能会延迟传输，直到收集大量传出数据。 成功完成 <xref:System.Net.Sockets.Socket.Send%2A> 方法意味着基础系统具有空间来缓冲用于网络发送的数据。

> [!NOTE]
>如果收到 <xref:System.Net.Sockets.SocketException>，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。 获取此代码后，请参阅[Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2)文档，以获取有关错误的详细说明。

当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[.NET Framework 中的网络跟踪](/dotnet/framework/network-programming/network-tracing)。

> [!IMPORTANT]
>成功完成发送并不表示数据已成功传递。 如果传输系统中没有可用于保存要传输的数据的缓冲区空间，则发送将会阻止，除非已将套接字置于非阻止模式。
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (byte[] buffer, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(unsigned int8[] buffer, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Function Send (buffer As Byte(), socketFlags As SocketFlags) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(cli::array &lt;System::Byte&gt; ^ buffer, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Send : byte[] * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Send (buffer, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="buffer">类型 <see cref="T:System.Byte" /> 的数组，其中包含要发送的数据。</param>
        <param name="socketFlags"><see cref="T:System.Net.Sockets.SocketFlags" /> 值的按位组合。</param>
        <summary>使用指定的 <see cref="T:System.Net.Sockets.Socket" /> 将数据发送到连接的 <see cref="T:System.Net.Sockets.SocketFlags" />。</summary>
        <returns>发送到 <see cref="T:System.Net.Sockets.Socket" /> 的字节数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Send%2A> 将数据同步发送到在 <xref:System.Net.Sockets.Socket.Connect%2A> 或 <xref:System.Net.Sockets.Socket.Accept%2A> 方法中建立的远程主机，并返回成功发送的字节数。 <xref:System.Net.Sockets.Socket.Send%2A> 方法可用于面向连接的协议和无连接的协议。  
  
 此重载需要包含要发送的数据的缓冲区和 <xref:System.Net.Sockets.SocketFlags>的按位组合。 缓冲区偏移量默认为0，要发送的字节数默认为缓冲区的大小。 如果指定 <xref:System.Net.Sockets.SocketFlags.DontRoute> 标志作为 `socketflags` 参数值，则将不路由要发送的数据。  
  
 如果使用的是无连接协议，则必须在调用此方法之前调用 <xref:System.Net.Sockets.Socket.Connect%2A>，否则 <xref:System.Net.Sockets.Socket.Send%2A> 将引发 <xref:System.Net.Sockets.SocketException>。 如果使用面向连接的协议，则必须使用 <xref:System.Net.Sockets.Socket.Connect%2A> 建立远程主机连接，或使用 <xref:System.Net.Sockets.Socket.Accept%2A> 来接受传入连接。  
  
 如果使用无连接协议并计划将数据发送到多个不同的主机，则应使用 <xref:System.Net.Sockets.Socket.SendTo%2A> 方法。 如果不使用 <xref:System.Net.Sockets.Socket.SendTo%2A> 方法，则必须在每次调用 <xref:System.Net.Sockets.Socket.Send%2A>之前调用 <xref:System.Net.Sockets.Socket.Connect%2A> 方法。 即使已使用 <xref:System.Net.Sockets.Socket.Connect%2A>建立默认远程主机，也可以使用 <xref:System.Net.Sockets.Socket.SendTo%2A>。 还可以在调用 <xref:System.Net.Sockets.Socket.Send%2A> 之前更改默认远程主机，方法是调用 <xref:System.Net.Sockets.Socket.Connect%2A>。  
  
 如果使用面向连接的协议，则在发送缓冲区中的所有字节之前，<xref:System.Net.Sockets.Socket.Send%2A> 会一直阻止，除非使用 <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>设置了超时。 如果超过超时值，则 <xref:System.Net.Sockets.Socket.Send%2A> 调用将引发 <xref:System.Net.Sockets.SocketException>。 在非阻止模式下，即使发送的字节数小于缓冲区中的字节数，<xref:System.Net.Sockets.Socket.Send%2A> 也可能成功完成。 应用程序负责跟踪发送的字节数，并重试操作，直到应用程序发送请求的字节数。 还不能保证发送的数据会立即显示在网络上。 为了提高网络效率，基础系统可能会延迟传输，直到收集大量传出数据。 成功完成 <xref:System.Net.Sockets.Socket.Send%2A> 方法意味着基础系统具有空间来缓冲用于网络发送的数据。  
  
> [!NOTE]
>  必须确保缓冲区的大小不超过基础服务提供程序的最大数据包大小。 如果是这样，则将不发送数据报并且 <xref:System.Net.Sockets.Socket.Send%2A> 将引发 <xref:System.Net.Sockets.SocketException>。 如果收到 <xref:System.Net.Sockets.SocketException>，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。 获取此代码后，请参阅[Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2)文档，以获取有关错误的详细说明。  
  
> [!NOTE]
>  成功完成发送并不表示数据已成功传递。 如果传输系统中没有可用于保存要传输的数据的缓冲区空间，则发送将会阻止，除非已将套接字置于非阻止模式。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[.NET Framework 中的网络跟踪](/dotnet/framework/network-programming/network-tracing)。  
  
   
  
## Examples  
 下面的代码示例演示如何在连接的 <xref:System.Net.Sockets.Socket>上发送数据。  
  
 [!code-cpp[Socket_Sync_Send_Receive#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#2)]
 [!code-csharp[Socket_Sync_Send_Receive#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#2)]
 [!code-vb[Socket_Sync_Send_Receive#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Function Send (buffers As IList(Of ArraySegment(Of Byte)), socketFlags As SocketFlags) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Send : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Send (buffers, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="buffers"><see cref="T:System.ArraySegment`1" /> 类型的 <see cref="T:System.Byte" /> 的列表，它包含要发送的数据。</param>
        <param name="socketFlags"><see cref="T:System.Net.Sockets.SocketFlags" /> 值的按位组合。</param>
        <summary>使用指定的 <see cref="T:System.Net.Sockets.Socket" />，将列表中的一组缓冲区发送到连接的 <see cref="T:System.Net.Sockets.SocketFlags" />。</summary>
        <returns>发送到 <see cref="T:System.Net.Sockets.Socket" /> 的字节数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此重载至少需要一个包含要发送的数据的缓冲区。 <xref:System.Net.Sockets.SocketFlags> 值默认为0。 如果指定 <xref:System.Net.Sockets.SocketFlags.DontRoute> 标志作为 `socketFlags` 参数，则将不路由要发送的数据。  
  
 如果使用的是无连接协议，则必须在调用此方法之前调用 <xref:System.Net.Sockets.Socket.Connect%2A>，否则 <xref:System.Net.Sockets.Socket.Send%2A> 将引发 <xref:System.Net.Sockets.SocketException>。 如果使用面向连接的协议，则必须使用 <xref:System.Net.Sockets.Socket.Connect%2A> 建立远程主机连接，或使用 <xref:System.Net.Sockets.Socket.Accept%2A> 来接受传入连接。  
  
 如果使用无连接协议并计划将数据发送到多个不同的主机，则应使用 <xref:System.Net.Sockets.Socket.SendTo%2A> 方法。 如果不使用 <xref:System.Net.Sockets.Socket.SendTo%2A> 方法，则必须在每次调用 <xref:System.Net.Sockets.Socket.Send%2A>之前调用 <xref:System.Net.Sockets.Socket.Connect%2A>。 即使已使用 <xref:System.Net.Sockets.Socket.Connect%2A>建立默认远程主机，也可以使用 <xref:System.Net.Sockets.Socket.SendTo%2A>。 还可以在调用 <xref:System.Net.Sockets.Socket.Send%2A> 之前更改默认远程主机，方法是调用 <xref:System.Net.Sockets.Socket.Connect%2A>。  
  
 如果使用面向连接的协议，则在发送缓冲区中的所有字节之前，<xref:System.Net.Sockets.Socket.Send%2A> 会一直阻止，除非使用 <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>设置了超时。 如果超过超时值，则 <xref:System.Net.Sockets.Socket.Send%2A> 调用将引发 <xref:System.Net.Sockets.SocketException>。 在非阻止模式下，即使发送的字节数小于缓冲区中的字节数，<xref:System.Net.Sockets.Socket.Send%2A> 也可能成功完成。 应用程序负责跟踪发送的字节数，并在应用程序发送缓冲区中的字节之前重试该操作。 还不能保证发送的数据会立即显示在网络上。 为了提高网络效率，基础系统可能会延迟传输，直到收集大量传出数据。 成功完成 <xref:System.Net.Sockets.Socket.Send%2A> 方法意味着基础系统具有空间来缓冲用于网络发送的数据。  
  
> [!NOTE]
>  如果收到 <xref:System.Net.Sockets.SocketException>，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。 获取此代码后，请参阅[Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2)文档，以获取有关错误的详细说明。  
  
> [!NOTE]
>  成功完成发送并不表示数据已成功传递。 如果传输系统中没有可用于保存要传输的数据的缓冲区空间，则发送将会阻止，除非已将套接字置于非阻止模式。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[.NET Framework 中的网络跟踪](/dotnet/framework/network-programming/network-tracing)。  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <exception cref="T:System.ArgumentNullException"><paramref name="buffers" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="buffers" /> 为空。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (ReadOnlySpan&lt;byte&gt; buffer, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; buffer, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.ReadOnlySpan{System.Byte},System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Function Send (buffer As ReadOnlySpan(Of Byte), socketFlags As SocketFlags) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(ReadOnlySpan&lt;System::Byte&gt; buffer, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Send : ReadOnlySpan&lt;byte&gt; * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Send (buffer, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="buffer">一个字符范围，其中包含要发送的数据。</param>
        <param name="socketFlags">枚举值的按位组合，它用于指定发送和接收行为。</param>
        <summary>使用指定的 <see cref="T:System.Net.Sockets.Socket" /> 将数据发送到连接的 <see cref="T:System.Net.Sockets.SocketFlags" />。</summary>
        <returns>发送到 <see cref="T:System.Net.Sockets.Socket" /> 的字节数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  

  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (byte[] buffer, int size, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(unsigned int8[] buffer, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Function Send (buffer As Byte(), size As Integer, socketFlags As SocketFlags) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(cli::array &lt;System::Byte&gt; ^ buffer, int size, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Send : byte[] * int * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Send (buffer, size, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="size" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="buffer">类型 <see cref="T:System.Byte" /> 的数组，其中包含要发送的数据。</param>
        <param name="size">要发送的字节数。</param>
        <param name="socketFlags"><see cref="T:System.Net.Sockets.SocketFlags" /> 值的按位组合。</param>
        <summary>使用指定的 <see cref="T:System.Net.Sockets.Socket" />，将指定字节数的数据发送到已连接的 <see cref="T:System.Net.Sockets.SocketFlags" />。</summary>
        <returns>发送到 <see cref="T:System.Net.Sockets.Socket" /> 的字节数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
## Remarks

<xref:System.Net.Sockets.Socket.Send%2A> 将数据同步发送到在 <xref:System.Net.Sockets.Socket.Connect%2A> 或 <xref:System.Net.Sockets.Socket.Accept%2A> 方法中建立的远程主机，并返回成功发送的字节数。 <xref:System.Net.Sockets.Socket.Send%2A> 可用于面向连接的协议和无连接的协议。

此重载需要包含要发送的数据的缓冲区、要发送的字节数以及任何 <xref:System.Net.Sockets.SocketFlags>的按位组合。 如果指定 <xref:System.Net.Sockets.SocketFlags.DontRoute> 标志作为 `socketflags` 参数，则不会路由正在发送的数据。

如果使用的是无连接协议，则必须在调用此方法之前调用 <xref:System.Net.Sockets.Socket.Connect%2A>，否则 <xref:System.Net.Sockets.Socket.Send%2A> 将引发 <xref:System.Net.Sockets.SocketException>。 如果使用面向连接的协议，则必须使用 <xref:System.Net.Sockets.Socket.Connect%2A> 建立远程主机连接，或使用 <xref:System.Net.Sockets.Socket.Accept%2A> 来接受传入连接。

如果使用的是无连接协议并计划将数据发送到多个不同的主机，则应使用 <xref:System.Net.Sockets.Socket.SendTo%2A> 方法。 如果 don'tuse <xref:System.Net.Sockets.Socket.SendTo%2A> 方法，则必须在每次调用 <xref:System.Net.Sockets.Socket.Send%2A> 方法之前调用 <xref:System.Net.Sockets.Socket.Connect%2A> 方法。 即使已使用 <xref:System.Net.Sockets.Socket.Connect%2A>建立默认远程主机，也可以使用 <xref:System.Net.Sockets.Socket.SendTo%2A>。 还可以通过对 <xref:System.Net.Sockets.Socket.Connect%2A>进行另一次调用来更改默认远程主机，然后再调用 <xref:System.Net.Sockets.Socket.Send%2A>。

使用面向连接的协议时，除非使用 <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>设置了超时，否则 <xref:System.Net.Sockets.Socket.Send%2A> 会一直阻止到发送请求的字节数。 如果超过超时值，则 <xref:System.Net.Sockets.Socket.Send%2A> 调用将引发 <xref:System.Net.Sockets.SocketException>。 在非阻止模式下，即使发送的字节数少于你请求的字节数，<xref:System.Net.Sockets.Socket.Send%2A> 也可能成功完成。 应用程序负责跟踪发送的字节数，并重试操作，直到应用程序发送请求的字节数。 还不能保证发送的数据会立即显示在网络上。 为了提高网络效率，基础系统可能会延迟传输，直到收集大量传出数据。 成功完成 <xref:System.Net.Sockets.Socket.Send%2A> 方法意味着基础系统具有空间来缓冲用于网络发送的数据。

> [!NOTE]
> 必须确保大小不超过基础服务提供程序的最大数据包大小。 如果是这样，则不会发送数据报并且 <xref:System.Net.Sockets.Socket.Send%2A> 将引发 <xref:System.Net.Sockets.SocketException>。 如果收到 <xref:System.Net.Sockets.SocketException>，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。 获取此代码后，请参阅[Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2)文档，以获取有关错误的详细说明。

当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[.NET Framework 中的网络跟踪](/dotnet/framework/network-programming/network-tracing)。

> [!IMPORTANT]
>成功完成发送并不表示数据已成功传递。 如果传输系统中没有可用于保存要传输的数据的缓冲区空间，则发送将会阻止，除非已将套接字置于非阻止模式。

## Examples

下面的代码示例发送缓冲区中找到的数据，并为 <xref:System.Net.Sockets.SocketFlags>指定 <xref:System.Net.Sockets.SocketFlags.None>。

[!code-cpp[Socket_Sync_Send_Receive#3](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#3)]
[!code-csharp[Socket_Sync_Send_Receive#3](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#3)]
[!code-vb[Socket_Sync_Send_Receive#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#3)]
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="size" /> 小于 0 或超过缓冲区的大小。</exception>
        <exception cref="T:System.Net.Sockets.SocketException"><paramref name="socketFlags" /> 不是有效的值组合。  
  
-或- 
访问套接字时发生操作系统错误。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Send (buffers As IList(Of ArraySegment(Of Byte)), socketFlags As SocketFlags, ByRef errorCode As SocketError) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberSignature Language="F#" Value="member this.Send : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.Net.Sockets.SocketFlags * SocketError -&gt; int" Usage="socket.Send (buffers, socketFlags, errorCode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="buffers"><see cref="T:System.ArraySegment`1" /> 类型的 <see cref="T:System.Byte" /> 的列表，它包含要发送的数据。</param>
        <param name="socketFlags"><see cref="T:System.Net.Sockets.SocketFlags" /> 值的按位组合。</param>
        <param name="errorCode">一个 <see cref="T:System.Net.Sockets.SocketError" /> 对象，它存储套接字错误。</param>
        <summary>使用指定的 <see cref="T:System.Net.Sockets.Socket" />，将列表中的一组缓冲区发送到连接的 <see cref="T:System.Net.Sockets.SocketFlags" />。</summary>
        <returns>发送到 <see cref="T:System.Net.Sockets.Socket" /> 的字节数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此重载至少需要一个包含要发送的数据的缓冲区。 <xref:System.Net.Sockets.SocketFlags> 值默认为0。 如果指定 <xref:System.Net.Sockets.SocketFlags.DontRoute> 标志作为 `socketFlags` 参数，则将不路由要发送的数据。  
  
 如果使用的是无连接协议，则必须在调用此方法之前调用 <xref:System.Net.Sockets.Socket.Connect%2A>，否则 <xref:System.Net.Sockets.Socket.Send%2A> 将引发 <xref:System.Net.Sockets.SocketException>。 如果使用面向连接的协议，则必须使用 <xref:System.Net.Sockets.Socket.Connect%2A> 建立远程主机连接，或使用 <xref:System.Net.Sockets.Socket.Accept%2A> 来接受传入连接。  
  
 如果使用无连接协议并计划将数据发送到多个不同的主机，则应使用 <xref:System.Net.Sockets.Socket.SendTo%2A> 方法。 如果不使用 <xref:System.Net.Sockets.Socket.SendTo%2A> 方法，则必须在每次调用 <xref:System.Net.Sockets.Socket.Send%2A>之前调用 <xref:System.Net.Sockets.Socket.Connect%2A>。 即使已使用 <xref:System.Net.Sockets.Socket.Connect%2A>建立默认远程主机，也可以使用 <xref:System.Net.Sockets.Socket.SendTo%2A>。 还可以在调用 <xref:System.Net.Sockets.Socket.Send%2A> 之前更改默认远程主机，方法是调用 <xref:System.Net.Sockets.Socket.Connect%2A>。  
  
 如果使用面向连接的协议，则在发送缓冲区中的所有字节之前，<xref:System.Net.Sockets.Socket.Send%2A> 会一直阻止，除非使用 <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>设置了超时。 如果超过超时值，则 <xref:System.Net.Sockets.Socket.Send%2A> 调用将引发 <xref:System.Net.Sockets.SocketException>。 在非阻止模式下，即使发送的字节数小于缓冲区中的字节数，<xref:System.Net.Sockets.Socket.Send%2A> 也可能成功完成。 应用程序负责跟踪发送的字节数，并在应用程序发送缓冲区中的字节之前重试该操作。 还不能保证发送的数据会立即显示在网络上。 为了提高网络效率，基础系统可能会延迟传输，直到收集大量传出数据。 成功完成 <xref:System.Net.Sockets.Socket.Send%2A> 方法意味着基础系统具有空间来缓冲用于网络发送的数据。  
  
> [!NOTE]
>  如果收到 <xref:System.Net.Sockets.SocketException>，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。 获取此代码后，请参阅[Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2)文档，以获取有关错误的详细说明。  
  
> [!NOTE]
>  成功完成发送并不表示数据已成功传递。 如果传输系统中没有可用于保存要传输的数据的缓冲区空间，则发送将会阻止，除非已将套接字置于非阻止模式。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[.NET Framework 中的网络跟踪](/dotnet/framework/network-programming/network-tracing)。  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <exception cref="T:System.ArgumentNullException"><paramref name="buffers" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="buffers" /> 为空。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (ReadOnlySpan&lt;byte&gt; buffer, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; buffer, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.ReadOnlySpan{System.Byte},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Send (buffer As ReadOnlySpan(Of Byte), socketFlags As SocketFlags, ByRef errorCode As SocketError) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(ReadOnlySpan&lt;System::Byte&gt; buffer, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberSignature Language="F#" Value="member this.Send : ReadOnlySpan&lt;byte&gt; * System.Net.Sockets.SocketFlags * SocketError -&gt; int" Usage="socket.Send (buffer, socketFlags, errorCode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="buffer">一个字符范围，其中包含要发送的数据。</param>
        <param name="socketFlags">枚举值的按位组合，它用于指定发送和接收行为。</param>
        <param name="errorCode">当此方法返回时，将包含定义套接字错误代码的枚举值之一。</param>
        <summary>使用指定的 <see cref="T:System.Net.Sockets.Socket" /> 将数据发送到连接的 <see cref="T:System.Net.Sockets.SocketFlags" />。</summary>
        <returns>发送到 <see cref="T:System.Net.Sockets.Socket" /> 的字节数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
## Remarks

<xref:System.Net.Sockets.Socket.Send%2A> 将数据同步发送到 <xref:System.Net.Sockets.Socket.Connect%2A> 或 <xref:System.Net.Sockets.Socket.Accept%2A> 方法中指定的远程主机，并返回成功发送的字节数。 <xref:System.Net.Sockets.Socket.Send%2A> 可用于面向连接的协议和无连接的协议。

此重载需要包含要发送的数据的缓冲区。 <xref:System.Net.Sockets.SocketFlags> 值默认为0，缓冲区偏移量默认为0，要发送的字节数默认为缓冲区的大小。

如果使用的是无连接协议，则必须在调用此方法之前调用 <xref:System.Net.Sockets.Socket.Connect%2A>，否则 <xref:System.Net.Sockets.Socket.Send%2A> 将引发 <xref:System.Net.Sockets.SocketException>。 如果使用面向连接的协议，则必须使用 <xref:System.Net.Sockets.Socket.Connect%2A> 建立远程主机连接，或使用 <xref:System.Net.Sockets.Socket.Accept%2A> 来接受传入连接。

如果使用的是无连接协议并计划将数据发送到多个不同的主机，则应使用 <xref:System.Net.Sockets.Socket.SendTo%2A> 方法。 如果不使用 <xref:System.Net.Sockets.Socket.SendTo%2A> 方法，则必须在每次调用 <xref:System.Net.Sockets.Socket.Send%2A>之前调用 <xref:System.Net.Sockets.Socket.Connect%2A>。 即使已使用 <xref:System.Net.Sockets.Socket.Connect%2A>建立默认远程主机，也可以使用 <xref:System.Net.Sockets.Socket.SendTo%2A>。 还可以通过对 <xref:System.Net.Sockets.Socket.Connect%2A>进行另一次调用来更改默认远程主机，然后再调用 <xref:System.Net.Sockets.Socket.Send%2A>。

如果使用面向连接的协议，则在发送缓冲区中的所有字节之前，<xref:System.Net.Sockets.Socket.Send%2A> 会一直阻止，除非使用 <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>设置了超时。 如果超过超时值，则 <xref:System.Net.Sockets.Socket.Send%2A> 调用将引发 <xref:System.Net.Sockets.SocketException>。 在非阻止模式下，即使发送的字节数小于缓冲区中的字节数，<xref:System.Net.Sockets.Socket.Send%2A> 也可能成功完成。 应用程序负责跟踪发送的字节数，并在应用程序发送缓冲区中的字节之前重试该操作。 还不能保证发送的数据会立即显示在网络上。 为了提高网络效率，基础系统可能会延迟传输，直到收集大量传出数据。 成功完成 <xref:System.Net.Sockets.Socket.Send%2A> 方法意味着基础系统具有空间来缓冲用于网络发送的数据。

> [!NOTE]
>如果收到 <xref:System.Net.Sockets.SocketException>，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。 获取此代码后，请参阅[Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2)文档，以获取有关错误的详细说明。

当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[.NET Framework 中的网络跟踪](/dotnet/framework/network-programming/network-tracing)。

> [!IMPORTANT]
>成功完成发送并不表示数据已成功传递。 如果传输系统中没有可用于保存要传输的数据的缓冲区空间，则发送将会阻止，除非已将套接字置于非阻止模式。

 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Function Send (buffer As Byte(), offset As Integer, size As Integer, socketFlags As SocketFlags) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Send : byte[] * int * int * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Send (buffer, offset, size, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="buffer">类型 <see cref="T:System.Byte" /> 的数组，其中包含要发送的数据。</param>
        <param name="offset">开始发送数据的缓冲区中的位置。</param>
        <param name="size">要发送的字节数。</param>
        <param name="socketFlags"><see cref="T:System.Net.Sockets.SocketFlags" /> 值的按位组合。</param>
        <summary>从指定偏移量开始，使用指定 <see cref="T:System.Net.Sockets.SocketFlags" />，将指定的数据字节数发送到已连接的 <see cref="T:System.Net.Sockets.Socket" />。</summary>
        <returns>发送到 <see cref="T:System.Net.Sockets.Socket" /> 的字节数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Send%2A> 将数据同步发送到 <xref:System.Net.Sockets.Socket.Connect%2A> 或 <xref:System.Net.Sockets.Socket.Accept%2A> 方法中指定的远程主机，并返回成功发送的字节数。 <xref:System.Net.Sockets.Socket.Send%2A> 可用于面向连接的协议和无连接的协议。  
  
 在此重载中，如果指定 <xref:System.Net.Sockets.SocketFlags.DontRoute> 标志作为 `socketflags` 参数，则将不会路由你要发送的数据。  
  
 如果使用的是无连接协议，则必须在调用此方法之前调用 <xref:System.Net.Sockets.Socket.Connect%2A>，否则 <xref:System.Net.Sockets.Socket.Send%2A> 将引发 <xref:System.Net.Sockets.SocketException>。 如果使用面向连接的协议，则必须使用 <xref:System.Net.Sockets.Socket.Connect%2A> 建立远程主机连接，或使用 <xref:System.Net.Sockets.Socket.Accept%2A> 来接受传入连接。  
  
 如果使用无连接协议并计划将数据发送到多个不同的主机，则应使用 <xref:System.Net.Sockets.Socket.SendTo%2A>。 如果不使用 <xref:System.Net.Sockets.Socket.SendTo%2A>，则必须在每次调用 <xref:System.Net.Sockets.Socket.Send%2A>之前调用 <xref:System.Net.Sockets.Socket.Connect%2A>。 即使已使用 <xref:System.Net.Sockets.Socket.Connect%2A>建立默认远程主机，也可以使用 <xref:System.Net.Sockets.Socket.SendTo%2A>。 还可以在调用 <xref:System.Net.Sockets.Socket.Send%2A> 之前更改默认远程主机，方法是调用 <xref:System.Net.Sockets.Socket.Connect%2A>。  
  
 您还必须确保大小不超过基础服务提供程序的最大数据包大小。 如果是这样，则将不发送数据报并且 <xref:System.Net.Sockets.Socket.Send%2A> 将引发 <xref:System.Net.Sockets.SocketException>。  
  
 如果你使用的是面向连接的协议，除非使用 <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>设置了超时值，否则 <xref:System.Net.Sockets.Socket.Send%2A> 会一直阻止到发送请求的字节数。 如果超过超时值，则 <xref:System.Net.Sockets.Socket.Send%2A> 调用将引发 <xref:System.Net.Sockets.SocketException>。 在非阻止模式下，即使发送的字节数少于你请求的字节数，<xref:System.Net.Sockets.Socket.Send%2A> 也可能成功完成。 应用程序负责跟踪发送的字节数，并重试操作，直到应用程序发送请求的字节数。 还不能保证发送的数据会立即显示在网络上。 为了提高网络效率，基础系统可能会延迟传输，直到收集大量传出数据。 成功完成 <xref:System.Net.Sockets.Socket.Send%2A> 方法意味着基础系统具有空间来缓冲用于网络发送的数据。  
  
> [!NOTE]
>  如果收到 <xref:System.Net.Sockets.SocketException>，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。 获取此代码后，请参阅[Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2)文档，以获取有关错误的详细说明。  
  
> [!NOTE]
>  成功完成发送并不表示数据已成功传递。 如果传输系统中没有可用于保存要传输的数据的缓冲区空间，则发送将会阻止，除非已将套接字置于非阻止模式。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[.NET Framework 中的网络跟踪](/dotnet/framework/network-programming/network-tracing)。  
  
   
  
## Examples  
 下面的代码示例指定了用于将数据发送到连接的 <xref:System.Net.Sockets.Socket>的数据缓冲区、偏移量、大小和 <xref:System.Net.Sockets.SocketFlags>。  
  
 [!code-cpp[Socket_Sync_Send_Receive#4](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#4)]
 [!code-csharp[Socket_Sync_Send_Receive#4](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#4)]
 [!code-vb[Socket_Sync_Send_Receive#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" /> 小于 0。  
  
-或- 
 <paramref name="offset" /> 大于 <paramref name="buffer" /> 的长度。  
  
-或- 
 <paramref name="size" /> 小于 0。  
  
-或- 
 <paramref name="size" /> 大于 <paramref name="buffer" /> 的长度减去 <paramref name="offset" /> 参数的值。</exception>
        <exception cref="T:System.Net.Sockets.SocketException"><paramref name="socketFlags" /> 不是有效的值组合。  
  
-或- 
访问 <see cref="T:System.Net.Sockets.Socket" /> 时出现操作系统错误。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Send (buffer As Byte(), offset As Integer, size As Integer, socketFlags As SocketFlags, ByRef errorCode As SocketError) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberSignature Language="F#" Value="member this.Send : byte[] * int * int * System.Net.Sockets.SocketFlags * SocketError -&gt; int" Usage="socket.Send (buffer, offset, size, socketFlags, errorCode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" Index="4" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="buffer">类型 <see cref="T:System.Byte" /> 的数组，其中包含要发送的数据。</param>
        <param name="offset">开始发送数据的缓冲区中的位置。</param>
        <param name="size">要发送的字节数。</param>
        <param name="socketFlags"><see cref="T:System.Net.Sockets.SocketFlags" /> 值的按位组合。</param>
        <param name="errorCode">一个 <see cref="T:System.Net.Sockets.SocketError" /> 对象，它存储套接字错误。</param>
        <summary>从指定偏移量开始，使用指定 <see cref="T:System.Net.Sockets.Socket" />，将指定的数据字节数发送到已连接的 <see cref="T:System.Net.Sockets.SocketFlags" /></summary>
        <returns>发送到 <see cref="T:System.Net.Sockets.Socket" /> 的字节数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Send%2A> 将数据同步发送到 <xref:System.Net.Sockets.Socket.Connect%2A> 或 <xref:System.Net.Sockets.Socket.Accept%2A> 方法中指定的远程主机，并返回成功发送的字节数。 <xref:System.Net.Sockets.Socket.Send%2A> 可用于面向连接的协议和无连接的协议。  
  
 在此重载中，如果指定 <xref:System.Net.Sockets.SocketFlags.DontRoute> 标志作为 `socketflags` 参数，则将不会路由你要发送的数据。  
  
 如果使用的是无连接协议，则必须在调用此方法之前调用 <xref:System.Net.Sockets.Socket.Connect%2A>，否则 <xref:System.Net.Sockets.Socket.Send%2A> 将引发 <xref:System.Net.Sockets.SocketException>。 如果使用面向连接的协议，则必须使用 <xref:System.Net.Sockets.Socket.Connect%2A> 建立远程主机连接，或使用 <xref:System.Net.Sockets.Socket.Accept%2A> 来接受传入连接。  
  
 如果使用无连接协议并计划将数据发送到多个不同的主机，则应使用 <xref:System.Net.Sockets.Socket.SendTo%2A>。 如果不使用 <xref:System.Net.Sockets.Socket.SendTo%2A>，则必须在每次调用 <xref:System.Net.Sockets.Socket.Send%2A>之前调用 <xref:System.Net.Sockets.Socket.Connect%2A>。 即使已使用 <xref:System.Net.Sockets.Socket.Connect%2A>建立默认远程主机，也可以使用 <xref:System.Net.Sockets.Socket.SendTo%2A>。 还可以在调用 <xref:System.Net.Sockets.Socket.Send%2A> 之前更改默认远程主机，方法是调用 <xref:System.Net.Sockets.Socket.Connect%2A>。  
  
 您还必须确保大小不超过基础服务提供程序的最大数据包大小。 如果是这样，则将不发送数据报并且 <xref:System.Net.Sockets.Socket.Send%2A> 将引发 <xref:System.Net.Sockets.SocketException>。  
  
 如果你使用的是面向连接的协议，除非使用 <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>设置了超时值，否则 <xref:System.Net.Sockets.Socket.Send%2A> 会一直阻止到发送请求的字节数。 如果超过超时值，则 <xref:System.Net.Sockets.Socket.Send%2A> 调用将引发 <xref:System.Net.Sockets.SocketException>。 在非阻止模式下，即使发送的字节数少于你请求的字节数，<xref:System.Net.Sockets.Socket.Send%2A> 也可能成功完成。 应用程序负责跟踪发送的字节数，并重试操作，直到应用程序发送请求的字节数。 还不能保证发送的数据会立即显示在网络上。 为了提高网络效率，基础系统可能会延迟传输，直到收集大量传出数据。 成功完成 <xref:System.Net.Sockets.Socket.Send%2A> 方法意味着基础系统具有空间来缓冲用于网络发送的数据。  
  
> [!NOTE]
>  如果收到 <xref:System.Net.Sockets.SocketException>，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。 获取此代码后，请参阅[Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2)文档，以获取有关错误的详细说明。  
  
> [!NOTE]
>  成功完成发送并不表示数据已成功传递。 如果传输系统中没有可用于保存要传输的数据的缓冲区空间，则发送将会阻止，除非已将套接字置于非阻止模式。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[.NET Framework 中的网络跟踪](/dotnet/framework/network-programming/network-tracing)。  
  
   
  
## Examples  
 下面的代码示例指定了用于将数据发送到连接的 <xref:System.Net.Sockets.Socket>的数据缓冲区、偏移量、大小和 <xref:System.Net.Sockets.SocketFlags>。  
  
 [!code-cpp[Socket_Sync_Send_Receive#4](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#4)]
 [!code-csharp[Socket_Sync_Send_Receive#4](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#4)]
 [!code-vb[Socket_Sync_Send_Receive#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" /> 小于 0。  
  
-或- 
 <paramref name="offset" /> 大于 <paramref name="buffer" /> 的长度。  
  
-或- 
 <paramref name="size" /> 小于 0。  
  
-或- 
 <paramref name="size" /> 大于 <paramref name="buffer" /> 的长度减去 <paramref name="offset" /> 参数的值。</exception>
        <exception cref="T:System.Net.Sockets.SocketException"><paramref name="socketFlags" /> 不是有效的值组合。  
  
-或- 
访问 <see cref="T:System.Net.Sockets.Socket" /> 时出现操作系统错误。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="SendAsync">
      <MemberSignature Language="C#" Value="public bool SendAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool SendAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function SendAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool SendAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.SendAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="socket.SendAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="e">要用于此异步套接字操作的 <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> 对象。</param>
        <summary>将数据异步发送到连接的 <see cref="T:System.Net.Sockets.Socket" /> 对象。</summary>
        <returns>如果 I/O 操作挂起，则为 <see langword="true" />。 操作完成时，将引发 <paramref name="e" /> 参数的 <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> 事件。  
  
 如果 I/O 操作同步完成，则为 <see langword="false" />。 在这种情况下，将不会引发 <paramref name="e" /> 参数的 <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> 事件，并且可能在方法调用返回后立即检查作为参数传递的 <paramref name="e" /> 对象以检索操作的结果。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.SendAsync%2A> 方法用于从面向连接的套接字上的一个或多个缓冲区写入传出数据。 但是，也可以在连接操作上已指定远程主机的无连接套接字上使用此方法。  
  
 <xref:System.Net.Sockets.Socket.SendAsync%2A> 方法开始异步发送操作到 <xref:System.Net.Sockets.Socket.Accept%2A>、<xref:System.Net.Sockets.Socket.AcceptAsync%2A>、<xref:System.Net.Sockets.Socket.BeginAccept%2A>、<xref:System.Net.Sockets.Socket.BeginConnect%2A>、<xref:System.Net.Sockets.Socket.Connect%2A>或 <xref:System.Net.Sockets.Socket.ConnectAsync%2A> 方法中建立的远程主机。  
  
 若要成功调用此方法，需要 <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> 对象上的下列属性和事件：  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> 或 <xref:System.Net.Sockets.SocketAsyncEventArgs.BufferList%2A?displayProperty=nameWithType>  
  
-   如果设置 <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType>，则 <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType>  
  
-   如果设置 <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType>，则 <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
 调用方可以在调用 <xref:System.Net.Sockets.Socket.SendAsync%2A> 方法之前将 <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> 属性设置为所需的任何用户状态对象，以便可以在回调方法中检索信息。 如果回调需要比单个对象更多的信息，则可以创建一个小类，以将其他所需的状态信息保存为成员。  
  
 如果你不首先调用 <xref:System.Net.Sockets.Socket.Accept%2A>、<xref:System.Net.Sockets.Socket.AcceptAsync%2A>、<xref:System.Net.Sockets.Socket.BeginAccept%2A><xref:System.Net.Sockets.Socket.BeginConnect%2A>、<xref:System.Net.Sockets.Socket.Connect%2A>或 <xref:System.Net.Sockets.Socket.ConnectAsync%2A>，则 <xref:System.Net.Sockets.Socket.SendAsync%2A> 方法将引发异常。  
  
 调用 <xref:System.Net.Sockets.Socket.SendAsync%2A> 方法使你能够在单独的执行线程中发送数据。  
  
 对于面向消息的套接字，不要超过底层 Windows 套接字服务提供程序的最大消息大小。 如果数据太长，无法通过基础服务提供程序以原子方式传递，则不会传输任何数据，并且 <xref:System.Net.Sockets.Socket.SendAsync%2A> 方法将引发 <xref:System.Net.Sockets.SocketException> 并将 <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType> 设置为本机 Winsock WSAEMSGSIZE 错误代码（10040）。  
  
 请注意，<xref:System.Net.Sockets.Socket.SendAsync%2A> 方法的成功完成并不表示数据已成功传递。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="e" /> 参数的 <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" /> 或 <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /> 属性必须引用有效的缓冲区。 可以设置这两个属性中的某一个，但不能同时设置这两个属性。</exception>
        <exception cref="T:System.InvalidOperationException">已经在使用 <paramref name="e" /> 参数中指定的 <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> 对象执行套接字操作。</exception>
        <exception cref="T:System.NotSupportedException">此方法需要 Windows XP 或更高版本。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <exception cref="T:System.Net.Sockets.SocketException"><see cref="T:System.Net.Sockets.Socket" /> 尚未连接或者尚未通过 <see cref="M:System.Net.Sockets.Socket.Accept" />、<see cref="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)" /> 或 <see cref="Overload:System.Net.Sockets.Socket.BeginAccept" /> 方法获得。</exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Offset" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="SendBufferSize">
      <MemberSignature Language="C#" Value="public int SendBufferSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 SendBufferSize" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.SendBufferSize" />
      <MemberSignature Language="VB.NET" Value="Public Property SendBufferSize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int SendBufferSize { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.SendBufferSize : int with get, set" Usage="System.Net.Sockets.Socket.SendBufferSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指定 <see cref="T:System.Net.Sockets.Socket" /> 发送缓冲区的大小。</summary>
        <value><see cref="T:System.Int32" />，它包含发送缓冲区的大小（以字节为单位）。 默认值为 8192。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 缓冲区大小越大，可能会延迟连接的识别问题。 如果正在传输大文件，或者使用的是高带宽、高延迟连接（如卫星宽带提供程序），请考虑增加缓冲区大小。  
  
   
  
## Examples  
 下面的代码示例演示如何使用 <xref:System.Net.Sockets.Socket.SendBufferSize%2A> 属性。  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">为设置操作指定的值小于 0。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="SendFile">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>将文件和可选数据异步发送到连接的 <see cref="T:System.Net.Sockets.Socket" />。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SendFile">
      <MemberSignature Language="C#" Value="public void SendFile (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SendFile(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendFile(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SendFile (fileName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SendFile(System::String ^ fileName);" />
      <MemberSignature Language="F#" Value="member this.SendFile : string -&gt; unit" Usage="socket.SendFile fileName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="fileName">一个 <see cref="T:System.String" />，它包含要发送的文件的路径和名称。 此参数可以为 <see langword="null" />。</param>
        <summary>使用 <see cref="T:System.Net.Sockets.Socket" /> 传输标志，将文件 <paramref name="fileName" /> 发送到连接的 <see cref="F:System.Net.Sockets.TransmitFileOptions.UseDefaultWorkerThread" /> 对象。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此重载将文件 `fileName` 发送到连接的套接字。 `flags` 参数默认为 <xref:System.Net.Sockets.TransmitFileOptions.UseDefaultWorkerThread> （0），`preBuffer` 和 `postBuffer` 参数默认为 `null`。 如果 `fileName` 位于本地目录中，则只能用该文件的名称进行标识;否则，必须指定文件的完整路径和名称。 通配符（".。。支持\\\myfile.txt "）和 UNC 共享名称（"\\\\\\\shared 目录\\\myfile.txt "）。 如果找不到该文件，则将引发异常 <xref:System.IO.FileNotFoundException>。  
  
 此方法使用在 Windows Socket 2 API 中找到的 `TransmitFile` 函数。 有关 `TransmitFile` 函数及其标志的详细信息，请参阅[Windows 套接字](/windows/desktop/WinSock/)文档。  
  
 <xref:System.Net.Sockets.Socket.SendFile%2A> 将文件同步发送到 <xref:System.Net.Sockets.Socket.Connect%2A> 或 <xref:System.Net.Sockets.Socket.Accept%2A> 方法中指定的远程主机。 <xref:System.Net.Sockets.Socket.SendFile%2A> 可用于面向连接的协议和无连接协议。  
  
 如果使用的是无连接协议，则必须在调用此方法之前调用 <xref:System.Net.Sockets.Socket.Connect%2A>，否则 <xref:System.Net.Sockets.Socket.SendFile%2A> 会引发 <xref:System.Net.Sockets.SocketException> 异常。 如果使用面向连接的协议，则必须使用 <xref:System.Net.Sockets.Socket.Connect%2A> 来建立远程主机连接，或使用 <xref:System.Net.Sockets.Socket.Accept%2A> 来接受传入连接。  
  
 如果使用面向连接的协议，则在发送文件之前 <xref:System.Net.Sockets.Socket.SendFile%2A> 阻止。 在非阻止模式下，在发送整个文件之前，<xref:System.Net.Sockets.Socket.SendFile%2A> 可能会成功完成。 不能保证发送的数据会立即显示在网络上。 为了提高网络效率，基础系统可能会延迟传输，直到收集大量传出数据。 成功完成 <xref:System.Net.Sockets.Socket.SendFile%2A> 方法意味着基础系统具有空间来缓冲用于网络发送的数据。  
  
> [!NOTE]
>  如果收到 <xref:System.Net.Sockets.SocketException>，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。 获取此代码后，请参阅[Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2)文档，以获取有关错误的详细说明。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[.NET Framework 中的网络跟踪](/dotnet/framework/network-programming/network-tracing)。  
  
   
  
## Examples  
 下面的代码示例创建并连接套接字，然后将文件发送到远程主机。 文件 "test.txt" 位于本地计算机的根目录中。  
  
 [!code-cpp[NCLSocketEnhancements#3](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#3)]
 [!code-csharp[NCLSocketEnhancements#3](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">套接字未连接到远程主机。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 对象已关闭。</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Net.Sockets.Socket" /> 对象未处于阻止模式，无法接受此同步调用。</exception>
        <exception cref="T:System.IO.FileNotFoundException">未找到文件 <paramref name="fileName" />。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
      </Docs>
    </Member>
    <Member MemberName="SendFile">
      <MemberSignature Language="C#" Value="public void SendFile (string fileName, byte[] preBuffer, byte[] postBuffer, System.Net.Sockets.TransmitFileOptions flags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SendFile(string fileName, unsigned int8[] preBuffer, unsigned int8[] postBuffer, valuetype System.Net.Sockets.TransmitFileOptions flags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SendFile (fileName As String, preBuffer As Byte(), postBuffer As Byte(), flags As TransmitFileOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SendFile(System::String ^ fileName, cli::array &lt;System::Byte&gt; ^ preBuffer, cli::array &lt;System::Byte&gt; ^ postBuffer, System::Net::Sockets::TransmitFileOptions flags);" />
      <MemberSignature Language="F#" Value="member this.SendFile : string * byte[] * byte[] * System.Net.Sockets.TransmitFileOptions -&gt; unit" Usage="socket.SendFile (fileName, preBuffer, postBuffer, flags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="preBuffer" Type="System.Byte[]" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="postBuffer" Type="System.Byte[]" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="flags" Type="System.Net.Sockets.TransmitFileOptions" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="fileName">一个 <see cref="T:System.String" />，它包含要发送的文件的路径和名称。 此参数可以为 <see langword="null" />。</param>
        <param name="preBuffer">一个 <see cref="T:System.Byte" /> 数组，它包含发送文件前要发送的数据。 此参数可以为 <see langword="null" />。</param>
        <param name="postBuffer">一个 <see cref="T:System.Byte" /> 数组，它包含发送文件后要发送的数据。 此参数可以为 <see langword="null" />。</param>
        <param name="flags">一个或多个 <see cref="T:System.Net.Sockets.TransmitFileOptions" /> 值。</param>
        <summary>通过指定的 <see cref="T:System.Net.Sockets.TransmitFileOptions" /> 值，将文件 <paramref name="fileName" /> 和数据缓冲区发送到连接的 <see cref="T:System.Net.Sockets.Socket" /> 对象。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此重载要求要发送的文件的名称和 <xref:System.Net.Sockets.TransmitFileOptions> 值的按位组合。 `preBuffer` 参数包含要置于该文件之前的所有数据。 `postBuffer` 包含要跟踪文件的数据。 如果 `fileName` 在当前工作目录中，则可以只使用文件的名称进行标识;否则，必须指定文件的完整路径和名称。 通配符（".。。支持\\\myfile.txt "）和 UNC 共享名称（"\\\\\\\shared 目录\\\myfile.txt "）。  
  
 `flags` 参数为窗口套接字服务提供程序提供有关文件传输的其他信息。 有关如何使用此参数的详细信息，请参阅 <xref:System.Net.Sockets.TransmitFileOptions>。  
  
 此方法使用在 Windows Socket 2 API 中找到的 `TransmitFile` 函数。 有关 `TransmitFile` 函数及其标志的详细信息，请参阅[Windows 套接字](/windows/desktop/WinSock/)文档。  
  
 <xref:System.Net.Sockets.Socket.SendFile%2A> 将文件同步发送到 <xref:System.Net.Sockets.Socket.Connect%2A> 或 <xref:System.Net.Sockets.Socket.Accept%2A> 方法中指定的远程主机。 <xref:System.Net.Sockets.Socket.SendFile%2A> 可用于面向连接的协议和无连接协议。  
  
 如果使用的是无连接协议，则必须在调用此方法之前调用 <xref:System.Net.Sockets.Socket.Connect%2A>;否则 <xref:System.Net.Sockets.Socket.SendFile%2A> 会引发 <xref:System.Net.Sockets.SocketException>。 如果使用面向连接的协议，则必须使用 <xref:System.Net.Sockets.Socket.Connect%2A> 建立远程主机连接，或使用 <xref:System.Net.Sockets.Socket.Accept%2A> 来接受传入连接。  
  
 如果使用面向连接的协议，则在发送整个文件之前 <xref:System.Net.Sockets.Socket.SendFile%2A> 会阻止。 在非阻止模式下，在发送整个文件之前，<xref:System.Net.Sockets.Socket.SendFile%2A> 可能会成功完成。 不能保证发送的数据会立即显示在网络上。 为了提高网络效率，基础系统可能会延迟传输，直到收集大量传出数据。 成功完成 <xref:System.Net.Sockets.Socket.SendFile%2A> 方法意味着基础系统具有空间来缓冲用于网络发送的数据。  
  
> [!NOTE]
>  如果收到 <xref:System.Net.Sockets.SocketException>，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。 获取此代码后，请参阅[Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2)文档，以获取有关错误的详细说明。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[.NET Framework 中的网络跟踪](/dotnet/framework/network-programming/network-tracing)。  
  
   
  
## Examples  
 下面的代码示例创建并连接套接字。 文件 "test.txt" 位于本地计算机的根目录中。 在此示例中，我们将创建 prebuffer 和以增大 postbuffer 数据，并使用该文件将其发送到远程主机。 使用默认 <xref:System.Net.Sockets.TransmitFileOptions>。  
  
 [!code-cpp[NCLSocketEnhancements#4](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#4)]
 [!code-csharp[NCLSocketEnhancements#4](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">操作系统不是 Windows NT 或更高版本。  
  
-或-
  
 套接字未连接到远程主机。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 对象已关闭。</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Net.Sockets.Socket" /> 对象未处于阻止模式，无法接受此同步调用。</exception>
        <exception cref="T:System.IO.FileNotFoundException">未找到文件 <paramref name="fileName" />。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
      </Docs>
    </Member>
    <Member MemberName="SendPacketsAsync">
      <MemberSignature Language="C#" Value="public bool SendPacketsAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool SendPacketsAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function SendPacketsAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool SendPacketsAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.SendPacketsAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="socket.SendPacketsAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO("Not implemented")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="e">要用于此异步套接字操作的 <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> 对象。</param>
        <summary>将文件集合或者内存中的数据缓冲区以异步方法发送给连接的 <see cref="T:System.Net.Sockets.Socket" /> 对象。</summary>
        <returns>如果 I/O 操作挂起，则为 <see langword="true" />。 操作完成时，将引发 <paramref name="e" /> 参数的 <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> 事件。  
  
 如果 I/O 操作同步完成，则为 <see langword="false" />。 在这种情况下，将不会引发 <paramref name="e" /> 参数的 <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> 事件，并且可能在方法调用返回后立即检查作为参数传递的 <paramref name="e" /> 对象以检索操作的结果。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> 方法用于向远程主机发送一组文件或内存中的数据缓冲区。 <xref:System.Net.Sockets.Socket> 必须已连接到远程主机。  
  
 如果 <xref:System.Net.Sockets.SendPacketsElement?displayProperty=nameWithType> 引用工作目录中的文件，则可以只使用文件的名称标识该文件;否则，必须指定文件的完整路径和名称。 支持通配符和 UNC 共享名。 如果找不到该文件，则会引发 <xref:System.IO.FileNotFoundException>。  
  
 若要在完成时收到通知，您必须创建一个回调方法，用于实现 EventHandler\<SocketAsyncEventArgs > 委托并将回调附加到 <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType> 事件。  
  
 `e` 参数的 <xref:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsFlags%2A?displayProperty=nameWithType> 属性为窗口套接字服务提供程序提供有关文件传输的其他信息。 有关如何使用此参数的详细信息，请参阅 <xref:System.Net.Sockets.TransmitFileOptions>。  
  
 若要成功调用此方法，需要 <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> 对象上的下列属性和事件：  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsElements%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
 调用方可以在调用 <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> 方法之前将 <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> 属性设置为所需的任何用户状态对象，以便可以在回调方法中检索信息。 如果回调需要比单个对象更多的信息，则可以创建一个小类，以将其他所需的状态信息保存为成员。  
  
 此方法使用在 Windows Socket 2 API 中找到的 TransmitPackets 函数。 有关 TransmitPackets 函数及其标志的详细信息，请参阅[Windows 套接字](/windows/desktop/WinSock/)文档。  
  
 尽管适用于面向连接的协议，但 <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> 方法也适用于无连接协议，前提是你首先调用 <xref:System.Net.Sockets.Socket.BeginConnect%2A>、<xref:System.Net.Sockets.Socket.Connect%2A>或 <xref:System.Net.Sockets.Socket.ConnectAsync%2A> 方法来建立默认远程主机。 在无连接协议的情况下，你还必须确保文件大小不超过基础服务提供程序的最大数据包大小。 如果是这样，则不发送数据报并且 <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> 引发 <xref:System.Net.Sockets.SocketException> 异常。  
  
 <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> 方法根据使用它的操作系统进行了优化。 在 Windows server 版本上，<xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> 方法针对高性能进行了优化。  
  
 在 Windows 客户端版本上，<xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> 方法针对最小内存和资源利用率进行了优化。  
  
 在 `e` 参数的 <xref:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsFlags%2A?displayProperty=nameWithType> 属性中使用 <xref:System.Net.Sockets.TransmitFileOptions.UseKernelApc?displayProperty=nameWithType> 标志可以提供显著的性能优势。 如果发起 <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> 方法调用的线程用于繁重计算，则可能会阻止 Apc 启动，但这种情况很可能无法启动。 请注意，内核模式和用户模式 Apc 之间存在差异。 当线程处于等待状态时，内核 Apc 启动。 当线程处于可报警等待状态时，用户模式 Apc 启动  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException">未找到在 <see cref="P:System.Net.Sockets.SendPacketsElement.FilePath" /> 属性中指定的文件。</exception>
        <exception cref="T:System.InvalidOperationException">已经在使用 <paramref name="e" /> 参数中指定的 <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> 对象执行套接字操作。</exception>
        <exception cref="T:System.NotSupportedException">此方法需要 Windows XP 或更高版本。 如果 <see cref="T:System.Net.Sockets.Socket" /> 未连接到远程主机，也会发生此异常。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">使用的是无连接 <see cref="T:System.Net.Sockets.Socket" />，并且所发送的文件超过了基础传输的最大数据包大小。</exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsElements" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsFlags" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="SendTimeout">
      <MemberSignature Language="C#" Value="public int SendTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 SendTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.SendTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Property SendTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int SendTimeout { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.SendTimeout : int with get, set" Usage="System.Net.Sockets.Socket.SendTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指定之后同步 <see cref="Overload:System.Net.Sockets.Socket.Send" /> 调用将超时的时间长度。</summary>
        <value>超时值（以毫秒为单位）。 如果将该属性设置为 1 到 499 之间的值，该值将被更改为 500。 默认值为 0，指示超时期限无限大。 指定 -1 还会指示超时期限无限大。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此选项仅适用于同步 <xref:System.Net.Sockets.Socket.Send%2A> 调用。 如果超过超时期限，<xref:System.Net.Sockets.Socket.Send%2A> 方法将引发 <xref:System.Net.Sockets.SocketException>。  
  
   
  
## Examples  
 下面的代码示例演示如何使用 <xref:System.Net.Sockets.Socket.SendTimeout%2A> 属性。  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">为设置操作指定的值小于 1。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="SendTo">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>将数据发送到特定终结点。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SendTo">
      <MemberSignature Language="C#" Value="public int SendTo (byte[] buffer, System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 SendTo(unsigned int8[] buffer, class System.Net.EndPoint remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.EndPoint)" />
      <MemberSignature Language="VB.NET" Value="Public Function SendTo (buffer As Byte(), remoteEP As EndPoint) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int SendTo(cli::array &lt;System::Byte&gt; ^ buffer, System::Net::EndPoint ^ remoteEP);" />
      <MemberSignature Language="F#" Value="member this.SendTo : byte[] * System.Net.EndPoint -&gt; int" Usage="socket.SendTo (buffer, remoteEP)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="buffer">类型 <see cref="T:System.Byte" /> 的数组，其中包含要发送的数据。</param>
        <param name="remoteEP"><see cref="T:System.Net.EndPoint" />，它表示数据的目标位置。</param>
        <summary>将数据发送到指定的终结点。</summary>
        <returns>已发送的字节数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在此重载中，缓冲区偏移量默认为0，发送的字节数默认为 `buffer` 参数的大小，<xref:System.Net.Sockets.SocketFlags> 值默认为0。  
  
 如果使用的是无连接协议，则在调用 <xref:System.Net.Sockets.Socket.SendTo%2A>之前，无需使用 <xref:System.Net.Sockets.Socket.Connect%2A> 方法建立默认远程主机。 如果要调用 <xref:System.Net.Sockets.Socket.Send%2A> 方法，只需执行此操作。 如果在调用 <xref:System.Net.Sockets.Socket.SendTo%2A>之前调用 <xref:System.Net.Sockets.Socket.Connect%2A> 方法，`remoteEP` 参数将重写该发送操作的指定默认远程主机。 你还不需要调用 <xref:System.Net.Sockets.Socket.Bind%2A> 方法，因为基础服务提供程序将分配最适当的本地网络地址和端口号。 如果需要确定分配的本地网络地址和端口号，可以在 <xref:System.Net.Sockets.Socket.SendTo%2A> 方法成功完成后使用 <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> 属性。  
  
 尽管适用于无连接协议，但 <xref:System.Net.Sockets.Socket.SendTo%2A> 也适用于面向连接的协议。 如果使用面向连接的协议，则必须先通过调用 <xref:System.Net.Sockets.Socket.Connect%2A> 方法来建立远程主机连接，或使用 <xref:System.Net.Sockets.Socket.Accept%2A> 方法接受传入的连接请求。 如果未建立或接受远程主机连接，<xref:System.Net.Sockets.Socket.SendTo%2A> 将引发 <xref:System.Net.Sockets.SocketException>。 还可以在调用 <xref:System.Net.Sockets.Socket.SendTo%2A> 方法之前，为无连接协议建立默认远程主机。 在这两种情况下，<xref:System.Net.Sockets.Socket.SendTo%2A> 将忽略 `remoteEP` 参数，只将数据发送到已连接或默认的远程主机。  
  
 在发送缓冲区中的所有字节之前，阻止套接字将会阻止。 由于非阻止 <xref:System.Net.Sockets.Socket> 会立即完成，因此它可能不会发送 `buffer`中的所有字节。 应用程序负责跟踪发送的字节数，并重试该操作，直到应用程序发送 `buffer`中的所有字节。 还不能保证发送的数据会立即显示在网络上。 为了提高网络效率，基础系统可能会延迟传输，直到收集大量传出数据。 成功完成 <xref:System.Net.Sockets.Socket.SendTo%2A> 方法意味着基础系统具有空间来缓冲用于网络发送的数据。  
  
 如果在阻止模式下使用无连接协议，则在发送数据报之前，将阻止 <xref:System.Net.Sockets.Socket.SendTo%2A>。 如果要将数据发送到广播地址，则必须先调用 <xref:System.Net.Sockets.Socket.SetSocketOption%2A> 方法，并将套接字选项设置为 <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>。 还必须确保发送的字节数不超过基础服务提供程序的最大数据包大小。 如果是这样，则将不发送数据报并且 <xref:System.Net.Sockets.Socket.SendTo%2A> 将引发 <xref:System.Net.Sockets.SocketException>。  
  
> [!NOTE]
>  如果收到 <xref:System.Net.Sockets.SocketException>，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。 获取此代码后，请参阅[Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2)文档，以获取有关错误的详细说明。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[.NET Framework 中的网络跟踪](/dotnet/framework/network-programming/network-tracing)。  
  
   
  
## Examples  
 下面的代码示例将无连接数据报发送到指定的远程主机。  
  
 [!code-cpp[Socket_Sync_Send_Receive#5](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#5)]
 [!code-csharp[Socket_Sync_Send_Receive#5](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#5)]
 [!code-vb[Socket_Sync_Send_Receive#5](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> 为 <see langword="null" />。  
  
-或- 
 <paramref name="remoteEP" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="P:System.Net.Sockets.Socket.LocalEndPoint" />
      </Docs>
    </Member>
    <Member MemberName="SendTo">
      <MemberSignature Language="C#" Value="public int SendTo (byte[] buffer, System.Net.Sockets.SocketFlags socketFlags, System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 SendTo(unsigned int8[] buffer, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
      <MemberSignature Language="VB.NET" Value="Public Function SendTo (buffer As Byte(), socketFlags As SocketFlags, remoteEP As EndPoint) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int SendTo(cli::array &lt;System::Byte&gt; ^ buffer, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ remoteEP);" />
      <MemberSignature Language="F#" Value="member this.SendTo : byte[] * System.Net.Sockets.SocketFlags * System.Net.EndPoint -&gt; int" Usage="socket.SendTo (buffer, socketFlags, remoteEP)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="buffer">类型 <see cref="T:System.Byte" /> 的数组，其中包含要发送的数据。</param>
        <param name="socketFlags"><see cref="T:System.Net.Sockets.SocketFlags" /> 值的按位组合。</param>
        <param name="remoteEP"><see cref="T:System.Net.EndPoint" />，它表示数据的目标位置。</param>
        <summary>使用指定的 <see cref="T:System.Net.Sockets.SocketFlags" />，将数据发送到特定的终结点。</summary>
        <returns>已发送的字节数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在此重载中，缓冲区偏移量默认为0，发送的字节数默认为 `buffer`的大小。 如果指定 <xref:System.Net.Sockets.SocketFlags.DontRoute> 标志作为 `socketflags` 参数，则将不路由要发送的数据。  
  
 如果使用的是无连接协议，则在调用 <xref:System.Net.Sockets.Socket.SendTo%2A>之前，无需使用 <xref:System.Net.Sockets.Socket.Connect%2A> 方法建立默认远程主机。 如果要调用 <xref:System.Net.Sockets.Socket.Send%2A> 方法，只需执行此操作。 如果在调用 <xref:System.Net.Sockets.Socket.SendTo%2A>之前调用 <xref:System.Net.Sockets.Socket.Connect%2A> 方法，`remoteEP` 参数将重写该发送操作的指定默认远程主机。 你还不需要调用 <xref:System.Net.Sockets.Socket.Bind%2A> 方法，因为基础服务提供程序将分配最适当的本地网络地址和端口号。 如果需要确定分配的本地网络地址和端口号，可以在 <xref:System.Net.Sockets.Socket.SendTo%2A> 方法成功完成后使用 <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> 属性。  
  
 尽管适用于无连接协议，但 <xref:System.Net.Sockets.Socket.SendTo%2A> 也适用于面向连接的协议。 如果使用面向连接的协议，则必须先通过调用 <xref:System.Net.Sockets.Socket.Connect%2A> 方法来建立远程主机连接，或使用 <xref:System.Net.Sockets.Socket.Accept%2A> 方法接受传入的连接请求。 如果未建立或接受远程主机连接，<xref:System.Net.Sockets.Socket.SendTo%2A> 将引发 <xref:System.Net.Sockets.SocketException>。 还可以在调用 <xref:System.Net.Sockets.Socket.SendTo%2A> 方法之前，为无连接协议建立默认远程主机。 在这两种情况下，<xref:System.Net.Sockets.Socket.SendTo%2A> 将忽略 `remoteEP` 参数，只将数据发送到已连接或默认的远程主机。  
  
 阻止套接字将会阻塞，直到发送了 `buffer` 中的所有字节。 由于非阻止 <xref:System.Net.Sockets.Socket> 会立即完成，因此它可能不会发送 `buffer`中的所有字节。 应用程序负责跟踪发送的字节数，并重试该操作，直到应用程序发送 `buffer`中的所有字节。 还不能保证发送的数据会立即显示在网络上。 为了提高网络效率，基础系统可能会延迟传输，直到收集了大量的传出数据。 成功完成 <xref:System.Net.Sockets.Socket.SendTo%2A> 方法意味着基础系统具有空间来缓冲用于网络发送的数据。  
  
 如果在阻止模式下使用无连接协议，则在发送数据报之前，将阻止 <xref:System.Net.Sockets.Socket.SendTo%2A>。 如果要将数据发送到广播地址，则必须先调用 <xref:System.Net.Sockets.Socket.SetSocketOption%2A> 方法，并将套接字选项设置为 <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>。 还必须确保发送的字节数不超过基础服务提供程序的最大数据包大小。 如果是这样，则将不发送数据报并且 <xref:System.Net.Sockets.Socket.SendTo%2A> 将引发 <xref:System.Net.Sockets.SocketException>。  
  
> [!NOTE]
>  如果收到 <xref:System.Net.Sockets.SocketException>，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。 获取此代码后，请参阅[Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2)文档，以获取有关错误的详细说明。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[.NET Framework 中的网络跟踪](/dotnet/framework/network-programming/network-tracing)。  
  
   
  
## Examples  
 下面的代码示例将无连接数据报发送到指定的远程主机。 <xref:System.Net.Sockets.SocketFlags> 传递到 <xref:System.Net.Sockets.Socket.SendTo%2A> 方法。  
  
 [!code-cpp[Socket_Sync_Send_Receive#6](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#6)]
 [!code-csharp[Socket_Sync_Send_Receive#6](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#6)]
 [!code-vb[Socket_Sync_Send_Receive#6](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> 为 <see langword="null" />。  
  
-或- 
 <paramref name="remoteEP" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="P:System.Net.Sockets.Socket.LocalEndPoint" />
      </Docs>
    </Member>
    <Member MemberName="SendTo">
      <MemberSignature Language="C#" Value="public int SendTo (byte[] buffer, int size, System.Net.Sockets.SocketFlags socketFlags, System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 SendTo(unsigned int8[] buffer, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
      <MemberSignature Language="VB.NET" Value="Public Function SendTo (buffer As Byte(), size As Integer, socketFlags As SocketFlags, remoteEP As EndPoint) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int SendTo(cli::array &lt;System::Byte&gt; ^ buffer, int size, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ remoteEP);" />
      <MemberSignature Language="F#" Value="member this.SendTo : byte[] * int * System.Net.Sockets.SocketFlags * System.Net.EndPoint -&gt; int" Usage="socket.SendTo (buffer, size, socketFlags, remoteEP)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="size" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="buffer">类型 <see cref="T:System.Byte" /> 的数组，其中包含要发送的数据。</param>
        <param name="size">要发送的字节数。</param>
        <param name="socketFlags"><see cref="T:System.Net.Sockets.SocketFlags" /> 值的按位组合。</param>
        <param name="remoteEP"><see cref="T:System.Net.EndPoint" />，它表示数据的目标位置。</param>
        <summary>使用指定的 <see cref="T:System.Net.Sockets.SocketFlags" />，将指定字节数的数据发送到指定的终结点。</summary>
        <returns>已发送的字节数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在此重载中，缓冲区偏移量默认为0。 如果指定 <xref:System.Net.Sockets.SocketFlags.DontRoute> 标志作为 `socketflags` 参数，则将不路由要发送的数据。  
  
 如果使用的是无连接协议，则在调用 <xref:System.Net.Sockets.Socket.SendTo%2A>之前，无需使用 <xref:System.Net.Sockets.Socket.Connect%2A> 方法建立默认远程主机。 如果要调用 <xref:System.Net.Sockets.Socket.Send%2A> 方法，只需执行此操作。 如果在调用 <xref:System.Net.Sockets.Socket.SendTo%2A>之前调用 <xref:System.Net.Sockets.Socket.Connect%2A> 方法，`remoteEP` 参数将重写该发送操作的指定默认远程主机。 你还不需要调用 <xref:System.Net.Sockets.Socket.Bind%2A> 方法，因为基础服务提供程序将分配最适当的本地网络地址和端口号。 如果需要确定分配的本地网络地址和端口号，可以在 <xref:System.Net.Sockets.Socket.SendTo%2A> 方法成功完成后使用 <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> 属性。  
  
 尽管适用于无连接协议，但 <xref:System.Net.Sockets.Socket.SendTo%2A> 也适用于面向连接的协议。 如果使用面向连接的协议，则必须先通过调用 <xref:System.Net.Sockets.Socket.Connect%2A> 方法来建立远程主机连接，或使用 <xref:System.Net.Sockets.Socket.Accept%2A> 方法接受传入的连接请求。 如果未建立或接受远程主机连接，<xref:System.Net.Sockets.Socket.SendTo%2A> 将引发 <xref:System.Net.Sockets.SocketException>。 还可以在调用 <xref:System.Net.Sockets.Socket.SendTo%2A> 方法之前，为无连接协议建立默认远程主机。 在这两种情况下，<xref:System.Net.Sockets.Socket.SendTo%2A> 将忽略 `remoteEP` 参数，只将数据发送到已连接或默认的远程主机。  
  
 阻止套接字将会阻止，直到发送请求的字节数。 由于非阻止 <xref:System.Net.Sockets.Socket> 会立即完成，因此它可能不会在单个操作中发送所有请求的字节。 应用程序负责跟踪发送的字节数，并重试操作，直到应用程序发送请求的字节数。 还不能保证发送的数据会立即显示在网络上。 为了提高网络效率，基础系统可能会延迟传输，直到收集了大量的传出数据。 成功完成 <xref:System.Net.Sockets.Socket.SendTo%2A> 方法意味着基础系统具有空间来缓冲用于网络发送的数据。  
  
 如果在阻止模式下使用无连接协议，则在发送数据报之前，将阻止 <xref:System.Net.Sockets.Socket.SendTo%2A>。 如果要将数据发送到广播地址，则必须先调用 <xref:System.Net.Sockets.Socket.SetSocketOption%2A> 方法，并将套接字选项设置为 <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>。 还必须确保发送的字节数不超过基础服务提供程序的最大数据包大小。 如果是这样，则将不发送数据报并且 <xref:System.Net.Sockets.Socket.SendTo%2A> 将引发 <xref:System.Net.Sockets.SocketException>。  
  
> [!NOTE]
>  如果收到 <xref:System.Net.Sockets.SocketException>，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。 获取此代码后，请参阅[Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2)文档，以获取有关错误的详细说明。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[.NET Framework 中的网络跟踪](/dotnet/framework/network-programming/network-tracing)。  
  
   
  
## Examples  
 下面的代码示例将无连接数据报发送到指定的远程主机。 将大小和 <xref:System.Net.Sockets.SocketFlags> 传递到 <xref:System.Net.Sockets.Socket.SendTo%2A> 方法。  
  
 [!code-cpp[Socket_Sync_Send_Receive#7](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#7)]
 [!code-csharp[Socket_Sync_Send_Receive#7](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#7)]
 [!code-vb[Socket_Sync_Send_Receive#7](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> 为 <see langword="null" />。  
  
-或- 
 <paramref name="remoteEP" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">指定的 <paramref name="size" /> 超出 <paramref name="buffer" /> 的大小。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="P:System.Net.Sockets.Socket.LocalEndPoint" />
      </Docs>
    </Member>
    <Member MemberName="SendTo">
      <MemberSignature Language="C#" Value="public int SendTo (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 SendTo(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
      <MemberSignature Language="VB.NET" Value="Public Function SendTo (buffer As Byte(), offset As Integer, size As Integer, socketFlags As SocketFlags, remoteEP As EndPoint) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int SendTo(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ remoteEP);" />
      <MemberSignature Language="F#" Value="member this.SendTo : byte[] * int * int * System.Net.Sockets.SocketFlags * System.Net.EndPoint -&gt; int" Usage="socket.SendTo (buffer, offset, size, socketFlags, remoteEP)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" Index="4" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="buffer">类型 <see cref="T:System.Byte" /> 的数组，其中包含要发送的数据。</param>
        <param name="offset">开始发送数据的缓冲区中的位置。</param>
        <param name="size">要发送的字节数。</param>
        <param name="socketFlags"><see cref="T:System.Net.Sockets.SocketFlags" /> 值的按位组合。</param>
        <param name="remoteEP"><see cref="T:System.Net.EndPoint" />，它表示数据的目标位置。</param>
        <summary>使用指定的 <see cref="T:System.Net.Sockets.SocketFlags" />，将指定字节数的数据发送到指定终结点（从缓冲区中的指定位置开始）。</summary>
        <returns>已发送的字节数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在此重载中，如果指定 <xref:System.Net.Sockets.SocketFlags.DontRoute> 标志作为 `socketflags` 参数，则将不会路由你要发送的数据。  
  
 如果使用的是无连接协议，则在调用 <xref:System.Net.Sockets.Socket.SendTo%2A>之前，无需使用 <xref:System.Net.Sockets.Socket.Connect%2A> 方法建立默认远程主机。 如果要调用 <xref:System.Net.Sockets.Socket.Send%2A> 方法，只需执行此操作。 如果在调用 <xref:System.Net.Sockets.Socket.SendTo%2A>之前调用 <xref:System.Net.Sockets.Socket.Connect%2A> 方法，`remoteEP` 参数将重写该发送操作的指定默认远程主机。 你还不需要调用 <xref:System.Net.Sockets.Socket.Bind%2A> 方法，因为基础服务提供程序将分配最适当的本地网络地址和端口号。 如果需要确定分配的本地网络地址和端口号，可以在 <xref:System.Net.Sockets.Socket.SendTo%2A> 方法成功完成后使用 <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> 属性。  
  
 尽管适用于无连接协议，但 <xref:System.Net.Sockets.Socket.SendTo%2A> 也适用于面向连接的协议。 如果使用面向连接的协议，则必须先通过调用 <xref:System.Net.Sockets.Socket.Connect%2A> 方法来建立远程主机连接，或使用 <xref:System.Net.Sockets.Socket.Accept%2A> 方法接受传入的连接请求。 如果未建立或接受远程主机连接，<xref:System.Net.Sockets.Socket.SendTo%2A> 将引发 <xref:System.Net.Sockets.SocketException>。 还可以在调用 <xref:System.Net.Sockets.Socket.SendTo%2A> 方法之前，为无连接协议建立默认远程主机。 在这两种情况下，<xref:System.Net.Sockets.Socket.SendTo%2A> 将忽略 `remoteEP` 参数，只将数据发送到已连接或默认的远程主机。  
  
 阻止套接字将会阻止，直到发送请求的字节数。 由于非阻止性 <xref:System.Net.Sockets.Socket> 会立即完成，因此它可能不会在单个操作中发送所有请求的字节。 应用程序负责跟踪发送的字节数，并重试操作，直到应用程序发送请求的字节数。 还不能保证发送的数据会立即显示在网络上。 为了提高网络效率，基础系统可能会延迟传输，直到收集了大量的传出数据。 成功完成 <xref:System.Net.Sockets.Socket.SendTo%2A> 方法意味着基础系统具有空间来缓冲用于网络发送的数据。  
  
 如果在阻止模式下使用无连接协议，则在发送数据报之前，将阻止 <xref:System.Net.Sockets.Socket.SendTo%2A>。 如果要将数据发送到广播地址，则必须先调用 <xref:System.Net.Sockets.Socket.SetSocketOption%2A> 方法，并将套接字选项设置为 <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>。 您还必须确保大小不超过基础服务提供程序的最大数据包大小。 如果是这样，则将不发送数据报并且 <xref:System.Net.Sockets.Socket.SendTo%2A> 将引发 <xref:System.Net.Sockets.SocketException>。  
  
> [!NOTE]
>  如果收到 <xref:System.Net.Sockets.SocketException>，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。 获取此代码后，请参阅[Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2)文档，以获取有关错误的详细说明。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[.NET Framework 中的网络跟踪](/dotnet/framework/network-programming/network-tracing)。  
  
   
  
## Examples  
 下面的代码示例将无连接数据报发送到指定的远程主机。 偏移量、大小和 <xref:System.Net.Sockets.SocketFlags> 传递到 <xref:System.Net.Sockets.Socket.SendTo%2A> 方法。  
  
 [!code-cpp[Socket_Sync_Send_Receive#8](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#8)]
 [!code-csharp[Socket_Sync_Send_Receive#8](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#8)]
 [!code-vb[Socket_Sync_Send_Receive#8](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> 为 <see langword="null" />。  
  
-或- 
 <paramref name="remoteEP" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" /> 小于 0。  
  
-或- 
 <paramref name="offset" /> 大于 <paramref name="buffer" /> 的长度。  
  
-或- 
 <paramref name="size" /> 小于 0。  
  
-或- 
 <paramref name="size" /> 大于 <paramref name="buffer" /> 的长度减去 <paramref name="offset" /> 参数的值。</exception>
        <exception cref="T:System.Net.Sockets.SocketException"><paramref name="socketFlags" /> 不是有效的值组合。  
  
-或- 
访问 <see cref="T:System.Net.Sockets.Socket" /> 时出现操作系统错误。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <exception cref="T:System.Security.SecurityException">调用堆栈中的调用方没有所需的权限。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="P:System.Net.Sockets.Socket.LocalEndPoint" />
      </Docs>
    </Member>
    <Member MemberName="SendToAsync">
      <MemberSignature Language="C#" Value="public bool SendToAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool SendToAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function SendToAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool SendToAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.SendToAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="socket.SendToAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="e">要用于此异步套接字操作的 <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> 对象。</param>
        <summary>以异步方式将数据发送到特定远程主机。</summary>
        <returns>如果 I/O 操作挂起，则为 <see langword="true" />。 操作完成时，将引发 <paramref name="e" /> 参数的 <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> 事件。  
  
 如果 I/O 操作同步完成，则为 <see langword="false" />。 在这种情况下，将不会引发 <paramref name="e" /> 参数的 <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> 事件，并且可能在方法调用返回后立即检查作为参数传递的 <paramref name="e" /> 对象以检索操作的结果。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.SendToAsync%2A> 方法将异步发送操作发送到 `e` 参数的 <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> 属性中指定的远程主机。 调用 <xref:System.Net.Sockets.Socket.SendToAsync%2A> 方法使你能够在单独的执行线程中发送数据。 尽管此方法用于无连接协议，但 <xref:System.Net.Sockets.Socket.SendToAsync%2A> 适用于连接和面向连接的协议。  
  
 若要在完成时收到通知，您必须创建一个回调方法，用于实现 EventHandler\<SocketAsyncEventArgs > 委托并将回调附加到 <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType> 事件。  
  
 若要成功调用此方法，需要 <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> 对象上的下列属性和事件：  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
 调用方可以在调用 <xref:System.Net.Sockets.Socket.SendToAsync%2A> 方法之前将 <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> 属性设置为所需的任何用户状态对象，以便可以在回调方法中检索信息。 如果回调需要比单个对象更多的信息，则可以创建一个小类，以将其他所需的状态信息保存为成员。  
  
 如果使用面向连接的协议，则必须先调用 <xref:System.Net.Sockets.Socket.Accept%2A>、<xref:System.Net.Sockets.Socket.AcceptAsync%2A>、<xref:System.Net.Sockets.Socket.BeginAccept%2A>、<xref:System.Net.Sockets.Socket.BeginConnect%2A>、<xref:System.Net.Sockets.Socket.Connect%2A>或 <xref:System.Net.Sockets.Socket.ConnectAsync%2A> 方法。 否则 <xref:System.Net.Sockets.Socket.SendToAsync%2A> 将引发 <xref:System.Net.Sockets.SocketException>。 使用面向连接的协议时，<xref:System.Net.Sockets.Socket.SendToAsync%2A> 方法将忽略 <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> 属性，并将数据发送到 <xref:System.Net.Sockets.Socket.Accept%2A>、<xref:System.Net.Sockets.Socket.AcceptAsync%2A>、<xref:System.Net.Sockets.Socket.BeginAccept%2A>、<xref:System.Net.Sockets.Socket.BeginConnect%2A>、<xref:System.Net.Sockets.Socket.Connect%2A>或 <xref:System.Net.Sockets.Socket.ConnectAsync%2A> 方法中建立的 <xref:System.Net.EndPoint?displayProperty=nameWithType>。  
  
 如果使用的是无连接协议，则在调用 <xref:System.Net.Sockets.Socket.SendToAsync%2A>之前，无需使用 <xref:System.Net.Sockets.Socket.BeginConnect%2A>、<xref:System.Net.Sockets.Socket.Connect%2A>或 <xref:System.Net.Sockets.Socket.ConnectAsync%2A> 方法建立默认远程主机。 仅当要调用 <xref:System.Net.Sockets.Socket.BeginSend%2A> 或 <xref:System.Net.Sockets.Socket.SendAsync%2A> 方法时，才需要执行此操作。 如果在调用 <xref:System.Net.Sockets.Socket.SendToAsync%2A>之前调用了 <xref:System.Net.Sockets.Socket.BeginConnect%2A>、<xref:System.Net.Sockets.Socket.Connect%2A>或 <xref:System.Net.Sockets.Socket.ConnectAsync%2A> 方法，则 <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> 属性将为该发送操作重写指定的默认远程主机。 您也不需要调用 <xref:System.Net.Sockets.Socket.Bind%2A> 方法。 在这种情况下，基础服务提供程序将分配最适当的本地网络 IP 地址和端口号。 如果希望基础服务提供商选择可用端口，请使用端口号零。 如果需要确定分配的本地网络 IP 地址和端口号，可以在 <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType> 事件终止后使用 <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> 属性，并调用关联的委托。  
  
 如果要将数据发送到广播地址，则必须先调用 <xref:System.Net.Sockets.Socket.SetSocketOption%2A> 方法，并将 <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType> 的套接字选项设置为 true。 还必须确保缓冲区的大小不超过基础服务提供程序的最大数据包大小。 如果是这样，则将不发送数据报并且 <xref:System.Net.Sockets.Socket.SendToAsync%2A> 将引发 <xref:System.Net.Sockets.SocketException>。  
  
 如果在 <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags%2A?displayProperty=nameWithType> 属性中指定 DontRoute 标志，则将不路由要发送的数据。  
  
 对于面向消息的套接字，必须注意不要超出基础传输的最大消息大小。 如果缓冲区的大小超过了基础服务提供程序的最大数据包大小，则不会发送数据报并且 <xref:System.Net.Sockets.Socket.SendToAsync%2A> 将引发 <xref:System.Net.Sockets.SocketException>。 成功完成 <xref:System.Net.Sockets.Socket.SendToAsync%2A> 方法并不表示数据已成功传递。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> 不能为 null。</exception>
        <exception cref="T:System.InvalidOperationException">已经在使用 <paramref name="e" /> 参数中指定的 <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> 对象执行套接字操作。</exception>
        <exception cref="T:System.NotSupportedException">此方法需要 Windows XP 或更高版本。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">指定的协议是面向连接的，但 <see cref="T:System.Net.Sockets.Socket" /> 尚未连接。</exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Offset" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="SetIPProtectionLevel">
      <MemberSignature Language="C#" Value="public void SetIPProtectionLevel (System.Net.Sockets.IPProtectionLevel level);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetIPProtectionLevel(valuetype System.Net.Sockets.IPProtectionLevel level) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SetIPProtectionLevel(System.Net.Sockets.IPProtectionLevel)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetIPProtectionLevel (level As IPProtectionLevel)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetIPProtectionLevel(System::Net::Sockets::IPProtectionLevel level);" />
      <MemberSignature Language="F#" Value="member this.SetIPProtectionLevel : System.Net.Sockets.IPProtectionLevel -&gt; unit" Usage="socket.SetIPProtectionLevel level" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="level" Type="System.Net.Sockets.IPProtectionLevel" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="level">要为此套接字设置的 IP 保护级别。</param>
        <summary>设置套接字的 IP 保护级别。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用 <xref:System.Net.Sockets.Socket.SetIPProtectionLevel%2A> 方法可以限制 IPv6 或 IP 套接字侦听指定的作用域（例如，具有相同的链接本地或站点本地前缀的地址）。 此套接字选项使应用程序可以对 IPv6 或 IP 套接字设置访问限制。 通过应用此类限制，可让在专用局域网上运行的应用程序能够通过简单的方式很好地增强自身的安全性，以便防范外部攻击。 如果 `level` 参数设置为 <xref:System.Net.Sockets.IPProtectionLevel.Unrestricted>，则也可以使用此套接字选项来删除访问限制。 此套接字选项可以扩大或缩小侦听套接字的范围，从而使得公共用户和私人用户可以在适当情况下对站点进行无限制的访问，或者可以根据需要对同一站点进行有限制的访问。  
  
 此套接字选项具有 <xref:System.Net.Sockets.IPProtectionLevel> 枚举中指定的已定义保护级别。  
  
 <xref:System.Net.Sockets.Socket.SetIPProtectionLevel%2A> 方法用于为 <xref:System.Net.Sockets.Socket> 实例启用或禁用网络地址遍历（NAT）。 可以使用 Teredo、6to4 或 ISATAP 隧道来提供 NAT 遍历。  
  
 将 `level` 参数设置为 <xref:System.Net.Sockets.IPProtectionLevel.EdgeRestricted>或 <xref:System.Net.Sockets.IPProtectionLevel.Restricted>时，这会显式禁用 <xref:System.Net.Sockets.Socket> 实例的 NAT 遍历。  
  
 将 `level` 参数设置为 <xref:System.Net.Sockets.IPProtectionLevel.EdgeRestricted>时，这可能会允许 NAT <xref:System.Net.Sockets.Socket> 遍历系统上的防火墙规则。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="level" /> 参数不能为 <see cref="F:System.Net.Sockets.IPProtectionLevel.Unspecified" />。 IP 保护级别不能设置为未指定。</exception>
        <exception cref="T:System.NotSupportedException">套接字的 <see cref="T:System.Net.Sockets.AddressFamily" /> 必须为 <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> 或 <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" />。</exception>
        <altmember cref="P:System.Net.IPAddress.IsIPv6Teredo" />
        <altmember cref="T:System.Net.Sockets.IPProtectionLevel" />
        <altmember cref="F:System.Net.Sockets.SocketOptionName.IPProtectionLevel" />
        <altmember cref="M:System.Net.Sockets.TcpListener.AllowNatTraversal(System.Boolean)" />
        <altmember cref="M:System.Net.Sockets.UdpClient.AllowNatTraversal(System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="SetRawSocketOption">
      <MemberSignature Language="C#" Value="public void SetRawSocketOption (int optionLevel, int optionName, ReadOnlySpan&lt;byte&gt; optionValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetRawSocketOption(int32 optionLevel, int32 optionName, valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; optionValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SetRawSocketOption(System.Int32,System.Int32,System.ReadOnlySpan{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetRawSocketOption (optionLevel As Integer, optionName As Integer, optionValue As ReadOnlySpan(Of Byte))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetRawSocketOption(int optionLevel, int optionName, ReadOnlySpan&lt;System::Byte&gt; optionValue);" />
      <MemberSignature Language="F#" Value="member this.SetRawSocketOption : int * int * ReadOnlySpan&lt;byte&gt; -&gt; unit" Usage="socket.SetRawSocketOption (optionLevel, optionName, optionValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Int32" Index="0" FrameworkAlternate="net-5.0" />
        <Parameter Name="optionName" Type="System.Int32" Index="1" FrameworkAlternate="net-5.0" />
        <Parameter Name="optionValue" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="2" FrameworkAlternate="net-5.0" />
      </Parameters>
      <Docs>
        <param name="optionLevel">To be added.</param>
        <param name="optionName">To be added.</param>
        <param name="optionValue">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="SetSocketOption">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>设置 <see cref="T:System.Net.Sockets.Socket" /> 选项。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetSocketOption">
      <MemberSignature Language="C#" Value="public void SetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName, bool optionValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName, bool optionValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetSocketOption (optionLevel As SocketOptionLevel, optionName As SocketOptionName, optionValue As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetSocketOption(System::Net::Sockets::SocketOptionLevel optionLevel, System::Net::Sockets::SocketOptionName optionName, bool optionValue);" />
      <MemberSignature Language="F#" Value="member this.SetSocketOption : System.Net.Sockets.SocketOptionLevel * System.Net.Sockets.SocketOptionName * bool -&gt; unit" Usage="socket.SetSocketOption (optionLevel, optionName, optionValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="optionValue" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="optionLevel"><see cref="T:System.Net.Sockets.SocketOptionLevel" /> 值之一。</param>
        <param name="optionName"><see cref="T:System.Net.Sockets.SocketOptionName" /> 值之一。</param>
        <param name="optionValue">选项的值，表示为 <see cref="T:System.Boolean" />。</param>
        <summary>将指定的 <see cref="T:System.Net.Sockets.Socket" /> 选项设置为指定的 <see cref="T:System.Boolean" /> 值。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket> 选项确定当前 <xref:System.Net.Sockets.Socket>的行为。 将 `optionValue` 设置为 `true` 以启用该选项，或设置为 `false` 禁用该选项。  
  
 <xref:System.Net.Sockets.Socket> 选项按协议支持级别进行分组。  
  
 下面列出了可以使用此重载设置的各种 <xref:System.Net.Sockets.Socket> 选项。 这些选项按适当的 <xref:System.Net.Sockets.SocketOptionLevel> 值进行分组。 如果要设置这些选项中的任何一个，请确保对 `optionLevel` 参数使用适当的 <xref:System.Net.Sockets.SocketOptionLevel> 值。 您选择设置的选项必须在 `optionName` 参数中指定。 如果要获取所列出的任何选项的当前值，请使用 <xref:System.Net.Sockets.Socket.GetSocketOption%2A> 方法。  
  
 可以使用此重载设置 <xref:System.Net.Sockets.SocketOptionLevel.Socket?displayProperty=nameWithType> 选项。  
  
-   <xref:System.Net.Sockets.SocketOptionName.AcceptConnection>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Broadcast>  
  
-   <xref:System.Net.Sockets.SocketOptionName.DontLinger>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Debug>  
  
-   <xref:System.Net.Sockets.SocketOptionName.KeepAlive>  
  
-   <xref:System.Net.Sockets.SocketOptionName.OutOfBandInline>  
  
-   <xref:System.Net.Sockets.SocketOptionName.ReuseAddress>  
  
 可以使用此重载设置 <xref:System.Net.Sockets.SocketOptionLevel.IP?displayProperty=nameWithType> 选项。  
  
-   <xref:System.Net.Sockets.SocketOptionName.HeaderIncluded>  
  
-   <xref:System.Net.Sockets.SocketOptionName.MulticastLoopback>  
  
-   <xref:System.Net.Sockets.SocketOptionName.UseLoopback>  
  
 可以使用此重载设置 <xref:System.Net.Sockets.SocketOptionLevel.Tcp?displayProperty=nameWithType> 选项。  
  
-   <xref:System.Net.Sockets.SocketOptionName.BsdUrgent>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Expedited>  
  
-   <xref:System.Net.Sockets.SocketOptionName.NoDelay>  
  
 可以使用此重载设置 <xref:System.Net.Sockets.SocketOptionLevel.Udp?displayProperty=nameWithType> 选项。  
  
-   <xref:System.Net.Sockets.SocketOptionName.NoChecksum>  
  
 有关这些选项的详细信息，请参阅 <xref:System.Net.Sockets.SocketOptionName> 枚举。  
  
> [!NOTE]
>  如果收到 <xref:System.Net.Sockets.SocketException> 异常，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。 获取此代码后，请参阅[Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2)文档，以获取有关错误的详细说明。  
  
   
  
## Examples  
 下面的代码示例打开套接字，并启用 `DontLinger` 和 `OutOfBandInline` 套接字选项。  
  
 [!code-cpp[NCLSocketEnhancements#5](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#5)]
 [!code-csharp[NCLSocketEnhancements#5](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 对象已关闭。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
      </Docs>
    </Member>
    <Member MemberName="SetSocketOption">
      <MemberSignature Language="C#" Value="public void SetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName, byte[] optionValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName, unsigned int8[] optionValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetSocketOption (optionLevel As SocketOptionLevel, optionName As SocketOptionName, optionValue As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetSocketOption(System::Net::Sockets::SocketOptionLevel optionLevel, System::Net::Sockets::SocketOptionName optionName, cli::array &lt;System::Byte&gt; ^ optionValue);" />
      <MemberSignature Language="F#" Value="member this.SetSocketOption : System.Net.Sockets.SocketOptionLevel * System.Net.Sockets.SocketOptionName * byte[] -&gt; unit" Usage="socket.SetSocketOption (optionLevel, optionName, optionValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="optionValue" Type="System.Byte[]" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="optionLevel"><see cref="T:System.Net.Sockets.SocketOptionLevel" /> 值之一。</param>
        <param name="optionName"><see cref="T:System.Net.Sockets.SocketOptionName" /> 值之一。</param>
        <param name="optionValue"><see cref="T:System.Byte" /> 类型的数组，表示选项值。</param>
        <summary>将指定的 <see cref="T:System.Net.Sockets.Socket" /> 选项设置为指定的值，表示为字节数组。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket> 选项确定当前 <xref:System.Net.Sockets.Socket>的行为。 使用此重载设置那些需要字节数组作为选项值 <xref:System.Net.Sockets.Socket> 选项。  
  
> [!NOTE]
>  如果收到 <xref:System.Net.Sockets.SocketException>，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。 获取此代码后，请参阅[Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2)文档，以获取有关错误的详细说明。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[.NET Framework 中的网络跟踪](/dotnet/framework/network-programming/network-tracing)。  
  
   
  
## Examples  
 下面的代码示例将 <xref:System.Net.Sockets.LingerOption> 和 <xref:System.Net.Sockets.Socket.Send%2A> 超时值。  
  
 [!code-cpp[Socket_Socket_Options#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#1)]
 [!code-csharp[Socket_Socket_Options#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#1)]
 [!code-vb[Socket_Socket_Options#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <altmember cref="T:System.Net.Sockets.SocketOptionName" />
        <altmember cref="T:System.Net.Sockets.SocketOptionLevel" />
        <altmember cref="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)" />
      </Docs>
    </Member>
    <Member MemberName="SetSocketOption">
      <MemberSignature Language="C#" Value="public void SetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName, int optionValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName, int32 optionValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetSocketOption (optionLevel As SocketOptionLevel, optionName As SocketOptionName, optionValue As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetSocketOption(System::Net::Sockets::SocketOptionLevel optionLevel, System::Net::Sockets::SocketOptionName optionName, int optionValue);" />
      <MemberSignature Language="F#" Value="member this.SetSocketOption : System.Net.Sockets.SocketOptionLevel * System.Net.Sockets.SocketOptionName * int -&gt; unit" Usage="socket.SetSocketOption (optionLevel, optionName, optionValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="optionValue" Type="System.Int32" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="optionLevel"><see cref="T:System.Net.Sockets.SocketOptionLevel" /> 值之一。</param>
        <param name="optionName"><see cref="T:System.Net.Sockets.SocketOptionName" /> 值之一。</param>
        <param name="optionValue">该选项的值。</param>
        <summary>将指定的 <see cref="T:System.Net.Sockets.Socket" /> 选项设置为指定的整数值。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket> 选项确定当前 <xref:System.Net.Sockets.Socket>的行为。 对于具有 <xref:System.Boolean> 数据类型的选项，请指定一个非零值以启用该选项，并指定零值以禁用该选项。 对于整数数据类型的选项，请指定相应的值。 <xref:System.Net.Sockets.Socket> 选项按协议支持级别进行分组。  
  
 下面列出了可以使用此重载设置的各种 <xref:System.Net.Sockets.Socket> 选项。 这些选项按适当的 <xref:System.Net.Sockets.SocketOptionLevel>分组。 如果要设置这些选项中的任何一个，请确保对 `optionLevel` 参数使用适当的 <xref:System.Net.Sockets.SocketOptionLevel>。 您选择设置的选项必须在 `optionName` 参数中指定。 如果要获取所列出的任何选项的当前值，请使用 <xref:System.Net.Sockets.Socket.GetSocketOption%2A> 方法。  
  
 可以使用此重载设置 <xref:System.Net.Sockets.SocketOptionLevel.Socket?displayProperty=nameWithType> 选项。  
  
-   <xref:System.Net.Sockets.SocketOptionName.Broadcast>  
  
-   <xref:System.Net.Sockets.SocketOptionName.DontLinger>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Debug>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Error>  
  
-   <xref:System.Net.Sockets.SocketOptionName.KeepAlive>  
  
-   <xref:System.Net.Sockets.SocketOptionName.OutOfBandInline>  
  
-   <xref:System.Net.Sockets.SocketOptionName.ReceiveBuffer>  
  
-   <xref:System.Net.Sockets.SocketOptionName.ReceiveTimeout>  
  
-   <xref:System.Net.Sockets.SocketOptionName.ReuseAddress>  
  
-   <xref:System.Net.Sockets.SocketOptionName.SendBuffer>  
  
-   <xref:System.Net.Sockets.SocketOptionName.SendTimeout>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Type>  
  
 可以使用此重载设置 <xref:System.Net.Sockets.SocketOptionLevel.IP?displayProperty=nameWithType> 选项。  
  
-   <xref:System.Net.Sockets.SocketOptionName.HeaderIncluded>  
  
-   <xref:System.Net.Sockets.SocketOptionName.IPOptions>  
  
-   <xref:System.Net.Sockets.SocketOptionName.IpTimeToLive>  
  
-   <xref:System.Net.Sockets.SocketOptionName.MulticastInterface>  
  
-   <xref:System.Net.Sockets.SocketOptionName.MulticastLoopback>  
  
-   <xref:System.Net.Sockets.SocketOptionName.MulticastTimeToLive>  
  
-   <xref:System.Net.Sockets.SocketOptionName.TypeOfService>  
  
-   <xref:System.Net.Sockets.SocketOptionName.UseLoopback>  
  
 可以使用此重载设置 <xref:System.Net.Sockets.SocketOptionLevel.Tcp?displayProperty=nameWithType> 选项。  
  
-   <xref:System.Net.Sockets.SocketOptionName.BsdUrgent>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Expedited>  
  
-   <xref:System.Net.Sockets.SocketOptionName.NoDelay>  
  
 可以使用此重载设置 <xref:System.Net.Sockets.SocketOptionLevel.Udp?displayProperty=nameWithType> 选项。  
  
-   <xref:System.Net.Sockets.SocketOptionName.ChecksumCoverage>  
  
-   <xref:System.Net.Sockets.SocketOptionName.NoChecksum>  
  
 可以使用此重载设置 <xref:System.Net.Sockets.SocketOptionLevel.IPv6?displayProperty=nameWithType> 选项。  
  
-   <xref:System.Net.Sockets.SocketOptionName.HopLimit>  
  
 有关这些选项的详细信息，请参阅 <xref:System.Net.Sockets.SocketOptionName> 枚举。  
  
> [!NOTE]
>  如果收到 <xref:System.Net.Sockets.SocketException>，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。 获取此代码后，请参阅[Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2)文档，以获取有关错误的详细说明。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[.NET Framework 中的网络跟踪](/dotnet/framework/network-programming/network-tracing)。  
  
   
  
## Examples  
 下面的代码示例将 <xref:System.Net.Sockets.LingerOption> 和 <xref:System.Net.Sockets.Socket.Send%2A> 超时值。  
  
 [!code-cpp[Socket_Socket_Options#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#1)]
 [!code-csharp[Socket_Socket_Options#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#1)]
 [!code-vb[Socket_Socket_Options#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <altmember cref="T:System.Net.Sockets.SocketOptionName" />
        <altmember cref="T:System.Net.Sockets.SocketOptionLevel" />
        <altmember cref="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)" />
      </Docs>
    </Member>
    <Member MemberName="SetSocketOption">
      <MemberSignature Language="C#" Value="public void SetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName, object optionValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName, object optionValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetSocketOption (optionLevel As SocketOptionLevel, optionName As SocketOptionName, optionValue As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetSocketOption(System::Net::Sockets::SocketOptionLevel optionLevel, System::Net::Sockets::SocketOptionName optionName, System::Object ^ optionValue);" />
      <MemberSignature Language="F#" Value="member this.SetSocketOption : System.Net.Sockets.SocketOptionLevel * System.Net.Sockets.SocketOptionName * obj -&gt; unit" Usage="socket.SetSocketOption (optionLevel, optionName, optionValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="optionValue" Type="System.Object" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="optionLevel"><see cref="T:System.Net.Sockets.SocketOptionLevel" /> 值之一。</param>
        <param name="optionName"><see cref="T:System.Net.Sockets.SocketOptionName" /> 值之一。</param>
        <param name="optionValue">一个 <see cref="T:System.Net.Sockets.LingerOption" /> 或 <see cref="T:System.Net.Sockets.MulticastOption" />，它包含该选项的值。</param>
        <summary>将指定的 <see cref="T:System.Net.Sockets.Socket" /> 选项设置为指定值，表示为对象。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket> 选项确定当前 <xref:System.Net.Sockets.Socket>的行为。 使用此重载设置 <xref:System.Net.Sockets.SocketOptionName.Linger>、<xref:System.Net.Sockets.SocketOptionName.AddMembership>和 <xref:System.Net.Sockets.SocketOptionName.DropMembership><xref:System.Net.Sockets.Socket> 选项。 对于 <xref:System.Net.Sockets.SocketOptionName.Linger> 选项，请对 `optionLevel` 参数使用 <xref:System.Net.Sockets.Socket>。 对于 <xref:System.Net.Sockets.SocketOptionName.AddMembership> 和 <xref:System.Net.Sockets.SocketOptionName.DropMembership>，请使用 <xref:System.Net.Sockets.SocketOptionLevel.IP>。 如果要获取上面列出的任何选项的当前值，请使用 <xref:System.Net.Sockets.Socket.GetSocketOption%2A> 方法。  
  
> [!NOTE]
>  如果收到 <xref:System.Net.Sockets.SocketException>，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。 获取此代码后，请参阅[Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2)文档，以获取有关错误的详细说明。  
  
   
  
## Examples  
 下面的代码示例设置 <xref:System.Net.Sockets.LingerOption> 和 <xref:System.Net.Sockets.Socket.Send%2A> 超时值。  
  
 [!code-cpp[Socket_Socket_Options#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#1)]
 [!code-csharp[Socket_Socket_Options#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#1)]
 [!code-vb[Socket_Socket_Options#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="optionValue" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <altmember cref="T:System.Net.Sockets.SocketOptionName" />
        <altmember cref="T:System.Net.Sockets.SocketOptionLevel" />
        <altmember cref="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)" />
      </Docs>
    </Member>
    <Member MemberName="Shutdown">
      <MemberSignature Language="C#" Value="public void Shutdown (System.Net.Sockets.SocketShutdown how);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Shutdown(valuetype System.Net.Sockets.SocketShutdown how) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Shutdown (how As SocketShutdown)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Shutdown(System::Net::Sockets::SocketShutdown how);" />
      <MemberSignature Language="F#" Value="member this.Shutdown : System.Net.Sockets.SocketShutdown -&gt; unit" Usage="socket.Shutdown how" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="how" Type="System.Net.Sockets.SocketShutdown" />
      </Parameters>
      <Docs>
        <param name="how"><see cref="T:System.Net.Sockets.SocketShutdown" /> 值之一，它指定不再允许执行的操作。</param>
        <summary>禁用某 <see cref="T:System.Net.Sockets.Socket" /> 上的发送和接收。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用面向连接的 <xref:System.Net.Sockets.Socket>时，请在关闭 <xref:System.Net.Sockets.Socket>之前始终调用 <xref:System.Net.Sockets.Socket.Shutdown%2A> 方法。 这可确保所有数据在连接的套接字关闭之前都已发送和接收。  
  
 调用 <xref:System.Net.Sockets.Socket.Close%2A> 方法，释放与 <xref:System.Net.Sockets.Socket>关联的所有托管资源和非托管资源。 请勿尝试在关闭后重用 <xref:System.Net.Sockets.Socket>。  
  
 下表显示了对 `how` 参数有效的 <xref:System.Net.Sockets.SocketShutdown> 枚举值。  
  
|值|说明|  
|-----------|-----------------|  
|Send|禁用此 <xref:System.Net.Sockets.Socket>上的发送。|  
|接收|禁用此 <xref:System.Net.Sockets.Socket>上的接收。|  
|推送、请求和匿名|在此 <xref:System.Net.Sockets.Socket>上禁用发送和接收。|  
  
 将 `how` 设置为 <xref:System.Net.Sockets.SocketShutdown.Send> 指定不允许对 <xref:System.Net.Sockets.Socket.Send%2A> 的后续调用。 如果使用的是无连接 <xref:System.Net.Sockets.Socket>，则指定 <xref:System.Net.Sockets.SocketShutdown.Send> 将不起作用。  
  
 将 `how` 设置为 <xref:System.Net.Sockets.SocketShutdown.Receive> 指定不允许对 <xref:System.Net.Sockets.Socket.Receive%2A> 的后续调用。 这在较低的协议层上不起作用。 如果使用面向连接的协议，则在调用 <xref:System.Net.Sockets.Socket.Shutdown%2A> 后，如果存在以下任一条件，则将终止连接：  
  
-   数据位于传入网络缓冲区中等待接收。  
  
-   已到达更多数据。  
  
 如果使用的是无连接协议，则接受并排队数据报。 但是，如果没有可用于附加传入数据报的缓冲区空间，则将丢弃这些数据，并且不会将错误返回给发件人。 不建议对无连接 <xref:System.Net.Sockets.Socket> 使用 <xref:System.Net.Sockets.Socket.Shutdown%2A>。  
  
 将 `how` 设置为 <xref:System.Net.Sockets.SocketShutdown.Both> 将按如上所述禁用发送和接收。  
  
> [!NOTE]
>  如果在调用 <xref:System.Net.Sockets.Socket.Shutdown%2A> 方法时接收到 <xref:System.Net.Sockets.SocketException>，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性来获取特定的错误代码。 获取此代码后，请参阅[Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2)文档，以获取有关错误的详细说明。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[.NET Framework 中的网络跟踪](/dotnet/framework/network-programming/network-tracing)。  
  
   
  
## Examples  
 下面的代码示例使用 <xref:System.Net.Sockets.Socket.Shutdown%2A> 禁用 <xref:System.Net.Sockets.Socket>。  
  
 [!code-cpp[Classic Socket.Close Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Close Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Close Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Close Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Close Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Close Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
        <altmember cref="T:System.Net.Sockets.SocketShutdown" />
      </Docs>
    </Member>
    <Member MemberName="SocketType">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.SocketType SocketType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Net.Sockets.SocketType SocketType" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.SocketType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SocketType As SocketType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Sockets::SocketType SocketType { System::Net::Sockets::SocketType get(); };" />
      <MemberSignature Language="F#" Value="member this.SocketType : System.Net.Sockets.SocketType" Usage="System.Net.Sockets.Socket.SocketType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.SocketType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取 <see cref="T:System.Net.Sockets.Socket" /> 的类型。</summary>
        <value><see cref="T:System.Net.Sockets.SocketType" /> 值之一。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.SocketType%2A> 为只读，并在创建 <xref:System.Net.Sockets.Socket> 时设置。  
  
   
  
## Examples  
 下面的代码示例显示控制台 <xref:System.Net.Sockets.AddressFamily>、<xref:System.Net.Sockets.SocketType>和 <xref:System.Net.Sockets.ProtocolType>。  
  
 [!code-cpp[Socket_Socket_Options#3](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#3)]
 [!code-csharp[Socket_Socket_Options#3](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#3)]
 [!code-vb[Socket_Socket_Options#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.Sockets.SocketType" />
      </Docs>
    </Member>
    <Member MemberName="SupportsIPv4">
      <MemberSignature Language="C#" Value="public static bool SupportsIPv4 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool SupportsIPv4" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.SupportsIPv4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SupportsIPv4 As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool SupportsIPv4 { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.SupportsIPv4 : bool" Usage="System.Net.Sockets.Socket.SupportsIPv4" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use OSSupportsIPv4 instead")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0">
          <AttributeName>System.Obsolete("SupportsIPv4 is obsoleted for this type, please use OSSupportsIPv4 instead. https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("SupportsIPv4 is obsoleted for this type, please use OSSupportsIPv4 instead. https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0">
          <AttributeName>System.Obsolete("SupportsIPv4 is obsoleted for this type, please use OSSupportsIPv4 instead. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示在当前主机上 IPv4 支持是否可用并且已启用。</summary>
        <value>如果当前主机支持 IPv4 协议，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 操作系统可能支持 IPv4 和 IPv6 协议。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Net.Sockets.Socket.SupportsIPv6" />
      </Docs>
    </Member>
    <Member MemberName="SupportsIPv6">
      <MemberSignature Language="C#" Value="public static bool SupportsIPv6 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool SupportsIPv6" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.SupportsIPv6" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SupportsIPv6 As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool SupportsIPv6 { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.SupportsIPv6 : bool" Usage="System.Net.Sockets.Socket.SupportsIPv6" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use OSSupportsIPv6 instead")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0">
          <AttributeName>System.Obsolete("SupportsIPv6 is obsoleted for this type, please use OSSupportsIPv6 instead. https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("SupportsIPv6 is obsoleted for this type, please use OSSupportsIPv6 instead. https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0">
          <AttributeName>System.Obsolete("SupportsIPv6 is obsoleted for this type, please use OSSupportsIPv6 instead. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示 Framework 对某些已过时的 <see cref="T:System.Net.Dns" /> 成员是否支持 IPv6。</summary>
        <value>如果 Framework 对某些已过时的 <see cref="T:System.Net.Dns" /> 方法支持 IPv6，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 操作系统可能支持 IPv4 和 IPv6 协议。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Net.Sockets.Socket.OSSupportsIPv6" />
        <altmember cref="P:System.Net.Sockets.Socket.SupportsIPv4" />
      </Docs>
    </Member>
    <Member MemberName="System.IDisposable.Dispose">
      <MemberSignature Language="C#" Value="void IDisposable.Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.IDisposable.Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.System#IDisposable#Dispose" />
      <MemberSignature Language="VB.NET" Value="Sub Dispose () Implements IDisposable.Dispose" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.IDisposable.Dispose() = IDisposable::Dispose;" />
      <MemberSignature Language="F#" Value="abstract member System.IDisposable.Dispose : unit -&gt; unit&#xA;override this.System.IDisposable.Dispose : unit -&gt; unit" Usage="socket.System.IDisposable.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>释放 <see cref="T:System.Net.Sockets.Socket" /> 使用的所有资源。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks  
使用完 <xref:System.Net.Sockets.Socket>后，请调用 IDisposable。 IDisposable 方法将 <xref:System.Net.Sockets.Socket> 保持为不可用状态。 调用 IDisposable 之后，必须释放对 <xref:System.Net.Sockets.Socket> 的所有引用，以便垃圾回收器可以回收 <xref:System.Net.Sockets.Socket> 占用的内存。 有关详细信息，请参阅[清理非托管资源](/dotnet/standard/garbage-collection/unmanaged)和[实现 Dispose 方法](/dotnet/standard/garbage-collection/implementing-dispose)。

> [!NOTE] 
> 在释放对 <xref:System.Net.Sockets.Socket>的最后一个引用之前，请始终调用 IDisposable。 否则，在垃圾回收器调用 <xref:System.Net.Sockets.Socket> 对象的 `Finalize` 方法之前，该对象正在使用的资源不会被释放。

]]></format>
        </remarks>
        <forInternalUseOnly />
      </Docs>
    </Member>
    <Member MemberName="Ttl">
      <MemberSignature Language="C#" Value="public short Ttl { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int16 Ttl" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.Ttl" />
      <MemberSignature Language="VB.NET" Value="Public Property Ttl As Short" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property short Ttl { short get(); void set(short value); };" />
      <MemberSignature Language="F#" Value="member this.Ttl : int16 with get, set" Usage="System.Net.Sockets.Socket.Ttl" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，指定 <see cref="T:System.Net.Sockets.Socket" /> 发送的 Internet 协议 (IP) 数据包的生存时间 (TTL) 值。</summary>
        <value>TTL 值。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 TTL 值表示在路由器丢弃数据包并且 Internet 控制消息协议（ICMP） "超过 TTL" 错误消息返回给发件人之前，数据包可以遍历的路由器的最大数目。  
  
 TTL 值可以设置为0到255之间的值。 如果未设置此属性，则套接字的默认 TTL 值为32。  
  
 如果使用套接字建立成功的连接，则 TCP/IP 堆栈将忽略对传输控制协议（TCP）套接字设置此属性。  
  
 如果收到 <xref:System.Net.Sockets.SocketException>，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。 获取此代码后，请参阅[Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2)文档，以获取有关错误的详细说明。  
  
   
  
## Examples  
 下面的代码示例演示如何使用 <xref:System.Net.Sockets.Socket.Ttl%2A> 属性。  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">TTL 值不能设置为负数。</exception>
        <exception cref="T:System.NotSupportedException">只有对于在 <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> 或 <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> 族中的套接字，才可以设置此属性。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。 在尝试将 TTL 设置为大于 255 的值时，也将返回此错误。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
      </Docs>
    </Member>
    <Member MemberName="UseOnlyOverlappedIO">
      <MemberSignature Language="C#" Value="public bool UseOnlyOverlappedIO { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseOnlyOverlappedIO" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.UseOnlyOverlappedIO" />
      <MemberSignature Language="VB.NET" Value="Public Property UseOnlyOverlappedIO As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UseOnlyOverlappedIO { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UseOnlyOverlappedIO : bool with get, set" Usage="System.Net.Sockets.Socket.UseOnlyOverlappedIO" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO("This doesn't do anything on Mono yet")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指定套接字是否应仅使用重叠 I/O 模式。</summary>
        <value>如果 <see cref="T:System.Net.Sockets.Socket" /> 仅使用重叠 I/O，则为 <see langword="true" />；否则为 <see langword="false" />。 默认为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 将此属性设置为要对其调用 <xref:System.Net.Sockets.Socket.DuplicateAndClose%2A>的 <xref:System.Net.Sockets.Socket> 的 `true`。 否则，框架可能会为套接字分配完成端口，这将禁止使用 <xref:System.Net.Sockets.Socket.DuplicateAndClose%2A>。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">套接字已绑定到完成端口。</exception>
      </Docs>
    </Member>
  </Members>
</Type>
