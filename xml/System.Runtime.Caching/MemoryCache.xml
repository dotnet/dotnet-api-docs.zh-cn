<Type Name="MemoryCache" FullName="System.Runtime.Caching.MemoryCache">
  <Metadata><Meta Name="ms.openlocfilehash" Value="8a5e7c8ab9dab691bba880d9398bb5da07f52844" /><Meta Name="ms.sourcegitcommit" Value="c982ad9e10a242d90f1e631b5981570f9e5d9f34" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-CN" /><Meta Name="ms.lasthandoff" Value="09/10/2020" /><Meta Name="ms.locfileid" Value="89707328" /></Metadata><TypeSignature Language="C#" Value="public class MemoryCache : System.Runtime.Caching.ObjectCache, IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit MemoryCache extends System.Runtime.Caching.ObjectCache implements class System.Collections.IEnumerable, class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Runtime.Caching.MemoryCache" />
  <TypeSignature Language="VB.NET" Value="Public Class MemoryCache&#xA;Inherits ObjectCache&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class MemoryCache : System::Runtime::Caching::ObjectCache, IDisposable" />
  <TypeSignature Language="F#" Value="type MemoryCache = class&#xA;    inherit ObjectCache&#xA;    interface IEnumerable&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Caching</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Runtime.Caching.ObjectCache</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.IEnumerable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>表示实现内存中缓存的类型。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.Caching.MemoryCache> 类是抽象 <xref:System.Runtime.Caching.ObjectCache> 类的具体实现。  
  
> [!NOTE]
>  <xref:System.Runtime.Caching.MemoryCache>类类似于 ASP.NET <xref:System.Web.Caching.Cache> 类。 <xref:System.Runtime.Caching.MemoryCache>如果你使用了 ASP.NET 类，则类有许多用于访问缓存的属性和方法 <xref:System.Web.Caching.Cache> 。 和类之间的主要区别在于， <xref:System.Web.Caching.Cache> <xref:System.Runtime.Caching.MemoryCache> 类已 <xref:System.Runtime.Caching.MemoryCache> 更改，使其可供 [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] 不是 ASP.NET 应用程序的应用程序使用。 例如，类对 <xref:System.Runtime.Caching.MemoryCache> 程序集没有依赖项 `System.Web` 。 另一差别在于，您可以创建类的多个实例， <xref:System.Runtime.Caching.MemoryCache> 以便在同一个应用程序和同一个实例中使用 <xref:System.AppDomain> 。  
  
 <xref:System.Runtime.Caching.MemoryCache>类不允许 `null` 作为缓存中的值。 任何添加或更改值为的缓存条目的尝试 `null` 都将失败。  
  
 该 <xref:System.Runtime.Caching.MemoryCache> 类型不实现 *缓存区域*。 因此，在调用 <xref:System.Runtime.Caching.MemoryCache> 实现包含区域参数的基方法的方法时，不要传递参数的值。 使用 region 参数的方法均提供默认 `null` 值。 例如， <xref:System.Runtime.Caching.MemoryCache.AddOrGetExisting%2A?displayProperty=nameWithType> 方法重载具有一个参数， `regionName` 其默认值为 `null` 。  
  
   
  
## Examples  
 下面的示例声明对默认内存缓存实例的引用。 缓存项使用 <xref:System.Runtime.Caching.CacheItemPolicy> 对象来提供该缓存项的逐出和过期详细信息。 它还使用 <xref:System.Runtime.Caching.ChangeMonitor> 对象来监视源数据的状态， (是文件系统上的文件) 。  
  
```vb  
Private Sub btnGet_Click(ByVal sender As Object, ByVal e As EventArgs)   
    Dim cache As ObjectCache = MemoryCache.[Default]   
    Dim fileContents As String = TryCast(cache("filecontents"), String)   
  
    If fileContents Is Nothing Then   
        Dim policy As New CacheItemPolicy()   
        Dim filePaths As New List(Of String)()   
        filePaths.Add("c:\cache\example.txt")   
  
        policy.ChangeMonitors.Add(New HostFileChangeMonitor(filePaths))   
  
        ' Fetch the file contents.  
        fileContents = File.ReadAllText("c:\cache\example.txt")   
  
        cache.[Set]("filecontents", fileContents, policy)   
    End If   
  
    Label1.Text = fileContents  
End Sub  
```  
  
```csharp  
private void btnGet_Click(object sender, EventArgs e)  
{  
    ObjectCache cache = MemoryCache.Default;  
    string fileContents = cache["filecontents"] as string;  
  
    if (fileContents == null)  
    {  
        CacheItemPolicy policy = new CacheItemPolicy();  
  
        List<string> filePaths = new List<string>();  
        filePaths.Add("c:\\cache\\example.txt");  
  
        policy.ChangeMonitors.Add(new   
        HostFileChangeMonitor(filePaths));  
  
        // Fetch the file contents.  
        fileContents =   
            File.ReadAllText("c:\\cache\\example.txt");  
  
        cache.Set("filecontents", fileContents, policy);  
    }  
  
    Label1.Text = fileContents;  
}  
```  
  
 ]]></format>
    </remarks>
    <threadsafe>此类型是线程安全的。</threadsafe>
    <altmember cref="T:System.Runtime.Caching.ObjectCache" />
    <related type="Article" href="https://docs.microsoft.com/previous-versions/ff477235(v=vs.140)">演练：在 ASP.NET 中缓存应用程序数据</related>
    <related type="Article" href="/dotnet/framework/performance/caching-in-net-framework-applications">.NET Framework 应用程序中的缓存</related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MemoryCache (string name, System.Collections.Specialized.NameValueCollection config = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name, class System.Collections.Specialized.NameValueCollection config) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.MemoryCache.#ctor(System.String,System.Collections.Specialized.NameValueCollection)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As String, Optional config As NameValueCollection = Nothing)" />
      <MemberSignature Language="F#" Value="new System.Runtime.Caching.MemoryCache : string * System.Collections.Specialized.NameValueCollection -&gt; System.Runtime.Caching.MemoryCache" Usage="new System.Runtime.Caching.MemoryCache (name, config)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="config" Type="System.Collections.Specialized.NameValueCollection" />
      </Parameters>
      <Docs>
        <param name="name">用于查找配置信息的名称。  
  
 请注意<c></c>，不要求每个名称都存在配置信息。  
  
如果存在匹配的配置项，则使用该配置信息来配置 <see cref="T:System.Runtime.Caching.MemoryCache" /> 实例。 如果不存在匹配的配置项，则可以通过 <see cref="P:System.Runtime.Caching.MemoryCache.Name" /> 属性访问名称，因为指定的名称与 <see cref="T:System.Runtime.Caching.MemoryCache" /> 实例相关联。 有关内存缓存配置的信息，请参见 <see cref="T:System.Runtime.Caching.Configuration.MemoryCacheElement" />。</param>
        <param name="config">用于配置缓存的配置信息的名称/值对集合。</param>
        <summary>初始化 <see cref="T:System.Runtime.Caching.MemoryCache" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在 <xref:System.Runtime.Caching.MemoryCache> 初始化类时，它将检查可能已使用构造函数中的可选参数重写的配置项 `config` 。 可以在参数中传递以下参数 `config` 。 所有值都可以作为整数传递。  
  
-   <xref:System.Runtime.Caching.Configuration.MemoryCacheElement.CacheMemoryLimitMegabytes%2A>  
  
-   <xref:System.Runtime.Caching.Configuration.MemoryCacheElement.PhysicalMemoryLimitPercentage%2A>  
  
-   <xref:System.Runtime.Caching.Configuration.MemoryCacheElement.PollingInterval%2A>  
  
 调用此构造函数时，将首先从应用程序配置文件中检索配置设置。 如果应用程序配置文件中不存在任何配置项，则仅应用中提供的设置 `config` 。 如果应用程序配置中存在配置条目，并且还传入了信息 `config` ，则中的信息会 `config` 重写从配置文件中读取的信息。  
  
 分配给缓存实例的名称值通过两种方式使用：  
  
-   当存在多个实例时，帮助您跟踪多个缓存实例。  
  
-   在初始化实例时引用配置文件中的设置 <xref:System.Runtime.Caching.MemoryCache> 。  
  
    > [!NOTE]
    >  没有任何机制来强制缓存实例的唯一名称。 因此，可以有多个具有相同名称的缓存实例。  
  
    > [!CAUTION]
    >  除非需要，否则不要创建 <xref:System.Runtime.Caching.MemoryCache> 实例。 如果在客户端和 Web 应用程序中创建缓存实例，则 <xref:System.Runtime.Caching.MemoryCache> 应在应用程序生命周期的早期创建实例。 必须仅创建将在应用程序中使用的缓存实例数，并将对缓存实例的引用存储在可全局访问的变量中。 例如，在 ASP.NET 应用程序中，可以将引用存储在应用程序状态中。 如果只在应用程序中创建一个缓存实例， <xref:System.Runtime.Caching.MemoryCache.Default%2A> 则在需要访问缓存时，请使用默认缓存并从属性获取对该实例的引用。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">未能分析 <paramref name="config" /> 参数中的名称或值。</exception>
        <exception cref="T:System.Configuration.ConfigurationException"><paramref name="config" /> 集合中的值无效。</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MemoryCache (string name, System.Collections.Specialized.NameValueCollection config, bool ignoreConfigSection);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name, class System.Collections.Specialized.NameValueCollection config, bool ignoreConfigSection) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.MemoryCache.#ctor(System.String,System.Collections.Specialized.NameValueCollection,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As String, config As NameValueCollection, ignoreConfigSection As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MemoryCache(System::String ^ name, System::Collections::Specialized::NameValueCollection ^ config, bool ignoreConfigSection);" />
      <MemberSignature Language="F#" Value="new System.Runtime.Caching.MemoryCache : string * System.Collections.Specialized.NameValueCollection * bool -&gt; System.Runtime.Caching.MemoryCache" Usage="new System.Runtime.Caching.MemoryCache (name, config, ignoreConfigSection)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;dotnet-plat-ext-3.1;dotnet-plat-ext-5.0;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="config" Type="System.Collections.Specialized.NameValueCollection" Index="1" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;dotnet-plat-ext-3.1;dotnet-plat-ext-5.0;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="ignoreConfigSection" Type="System.Boolean" Index="2" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;dotnet-plat-ext-3.1;dotnet-plat-ext-5.0;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="name">用于查找配置信息的名称。</param>
        <param name="config">用于配置缓存的配置信息的名称/值对集合。</param>
        <param name="ignoreConfigSection">指示是否应忽略配置部分。</param>
        <summary>初始化 <see cref="T:System.Runtime.Caching.MemoryCache" /> 类的新实例。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public override bool Add (System.Runtime.Caching.CacheItem item, System.Runtime.Caching.CacheItemPolicy policy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Add(class System.Runtime.Caching.CacheItem item, class System.Runtime.Caching.CacheItemPolicy policy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.MemoryCache.Add(System.Runtime.Caching.CacheItem,System.Runtime.Caching.CacheItemPolicy)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Add (item As CacheItem, policy As CacheItemPolicy) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Add(System::Runtime::Caching::CacheItem ^ item, System::Runtime::Caching::CacheItemPolicy ^ policy);" />
      <MemberSignature Language="F#" Value="override this.Add : System.Runtime.Caching.CacheItem * System.Runtime.Caching.CacheItemPolicy -&gt; bool" Usage="memoryCache.Add (item, policy)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Runtime.Caching.CacheItem" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;dotnet-plat-ext-3.1;dotnet-plat-ext-5.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="policy" Type="System.Runtime.Caching.CacheItemPolicy" Index="1" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;dotnet-plat-ext-3.1;dotnet-plat-ext-5.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="item">要添加的对象。</param>
        <param name="policy">一个包含该缓存项的逐出详细信息的对象。 此对象提供比简单绝对过期更多的逐出选项。</param>
        <summary>将缓存项作为 <see cref="T:System.Runtime.Caching.CacheItem" /> 实例插入到缓存中，并添加有关如何逐出该项的详细信息。</summary>
        <returns>如果插入成功，则为 <see langword="true" />；如果缓存中已存在具有与项相同的键，则为 false。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!WARNING]
>  <xref:System.Runtime.Caching.ObjectCache.Add%2A> 和 <xref:System.Runtime.Caching.ObjectCache.AddOrGetExisting%2A> 方法重载不支持 <xref:System.Runtime.Caching.CacheItemPolicy.UpdateCallback%2A> 属性。 因此，若要设置缓存项的 <xref:System.Runtime.Caching.CacheItemPolicy.UpdateCallback%2A> 属性，请改用 <xref:System.Runtime.Caching.MemoryCache.Set%2A> 方法重载。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AddOrGetExisting">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>将某个缓存项插入缓存中。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.Caching.MemoryCache.AddOrGetExisting%2A>方法重载用于将缓存项插入缓存中。 如果具有匹配键的缓存项不存在，则这些方法将插入一个新项。 如果已存在具有匹配键的缓存项，则它们将返回现有的项。  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddOrGetExisting">
      <MemberSignature Language="C#" Value="public override System.Runtime.Caching.CacheItem AddOrGetExisting (System.Runtime.Caching.CacheItem item, System.Runtime.Caching.CacheItemPolicy policy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Runtime.Caching.CacheItem AddOrGetExisting(class System.Runtime.Caching.CacheItem item, class System.Runtime.Caching.CacheItemPolicy policy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.MemoryCache.AddOrGetExisting(System.Runtime.Caching.CacheItem,System.Runtime.Caching.CacheItemPolicy)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function AddOrGetExisting (item As CacheItem, policy As CacheItemPolicy) As CacheItem" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Runtime::Caching::CacheItem ^ AddOrGetExisting(System::Runtime::Caching::CacheItem ^ item, System::Runtime::Caching::CacheItemPolicy ^ policy);" />
      <MemberSignature Language="F#" Value="override this.AddOrGetExisting : System.Runtime.Caching.CacheItem * System.Runtime.Caching.CacheItemPolicy -&gt; System.Runtime.Caching.CacheItem" Usage="memoryCache.AddOrGetExisting (item, policy)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Caching.CacheItem</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Runtime.Caching.CacheItem" />
        <Parameter Name="policy" Type="System.Runtime.Caching.CacheItemPolicy" />
      </Parameters>
      <Docs>
        <param name="item">要添加的对象。</param>
        <param name="policy">一个包含该缓存项的逐出详细信息的对象。 此对象提供比简单绝对过期更多的逐出选项。</param>
        <summary>使用指定的 <see cref="T:System.Runtime.Caching.CacheItem" /> 实例以及有关如何逐出该项的详细信息将某个缓存项添加到缓存中。</summary>
        <returns>如果存在具有相同键的缓存项，则为现有的缓存项；否则为 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `item`参数提供方法所使用的键和值。 如果缓存中的缓存项与参数的键具有相同的键 `item` ，则该方法将现有项作为 <xref:System.Runtime.Caching.CacheItem> 实例返回。 如果没有现有缓存项，该方法将使用参数提供的键和值 `item` 以及指定的逐出详细信息创建一个新的 `policy` 。  
  
> [!WARNING]
>  <xref:System.Runtime.Caching.ObjectCache.Add%2A> 和 <xref:System.Runtime.Caching.ObjectCache.AddOrGetExisting%2A> 方法重载不支持 <xref:System.Runtime.Caching.CacheItemPolicy.UpdateCallback%2A> 属性。 因此，若要设置缓存项的 <xref:System.Runtime.Caching.CacheItemPolicy.UpdateCallback%2A> 属性，请改用 <xref:System.Runtime.Caching.MemoryCache.Set%2A> 方法重载。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><see cref="P:System.Runtime.Caching.CacheItem.Value" /> 属性为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><see cref="T:System.Runtime.Caching.CacheItemPolicy" /> 对象的局对和可调过期值都设置为除 <see cref="F:System.Runtime.Caching.ObjectCache.InfiniteAbsoluteExpiration" /> 和 <see cref="F:System.Runtime.Caching.ObjectCache.NoSlidingExpiration" /> 字段的默认值以外的值。 <see cref="T:System.Runtime.Caching.MemoryCache" /> 类不能基于绝对过期和可调过期的组合设置过期策略。 只有使用 <see cref="T:System.Runtime.Caching.MemoryCache" /> 实例，才能显式设定一个过期设置。 另一过期设置必须设置为 <see cref="F:System.Runtime.Caching.ObjectCache.InfiniteAbsoluteExpiration" /> 字段或 <see cref="F:System.Runtime.Caching.ObjectCache.NoSlidingExpiration" /> 字段。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><see cref="P:System.Runtime.Caching.CacheItemPolicy.SlidingExpiration" /> 属性设置为一个小于 <see cref="F:System.TimeSpan.Zero" /> 的值。  
  
- 或 - 
<see cref="P:System.Runtime.Caching.CacheItemPolicy.SlidingExpiration" /> 属性设置为大于一年的值。  
  
- 或 - 
<see cref="P:System.Runtime.Caching.CacheItemPolicy.Priority" /> 属性不是 <see cref="T:System.Runtime.Caching.CacheItemPriority" /> 枚举的值。</exception>
      </Docs>
    </Member>
    <Member MemberName="AddOrGetExisting">
      <MemberSignature Language="C#" Value="public override object AddOrGetExisting (string key, object value, DateTimeOffset absoluteExpiration, string regionName = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object AddOrGetExisting(string key, object value, valuetype System.DateTimeOffset absoluteExpiration, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.MemoryCache.AddOrGetExisting(System.String,System.Object,System.DateTimeOffset,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function AddOrGetExisting (key As String, value As Object, absoluteExpiration As DateTimeOffset, Optional regionName As String = Nothing) As Object" />
      <MemberSignature Language="F#" Value="override this.AddOrGetExisting : string * obj * DateTimeOffset * string -&gt; obj" Usage="memoryCache.AddOrGetExisting (key, value, absoluteExpiration, regionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="absoluteExpiration" Type="System.DateTimeOffset" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">要添加的缓存项的唯一标识符。</param>
        <param name="value">该缓存项的数据。</param>
        <param name="absoluteExpiration">缓存项的固定的过期日期和时间。</param>
        <param name="regionName">缓存中的一个可向其添加缓存项的命名区域。 不要为该参数传递值。 默认情况下，此参数为<see langword="null" />，因为 <see cref="T:System.Runtime.Caching.MemoryCache" /> 类未实现区域。</param>
        <summary>通过使用指定的键、值和绝对过期值，将某个缓存项添加到缓存中。</summary>
        <returns>如果存在具有相同键的缓存项，则为现有的缓存项；否则为 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果缓存中没有与参数匹配的缓存项 `key` ，则将创建一个新的缓存条目，并且 <xref:System.Runtime.Caching.MemoryCache.AddOrGetExisting%2A?displayProperty=nameWithType> 方法重载将返回 `null` 。 如果存在匹配的缓存项，则返回现有的项。  
  
> [!WARNING]
>  <xref:System.Runtime.Caching.ObjectCache.Add%2A> 和 <xref:System.Runtime.Caching.ObjectCache.AddOrGetExisting%2A> 方法重载不支持 <xref:System.Runtime.Caching.CacheItemPolicy.UpdateCallback%2A> 属性。 因此，若要设置缓存项的 <xref:System.Runtime.Caching.CacheItemPolicy.UpdateCallback%2A> 属性，请改用 <xref:System.Runtime.Caching.MemoryCache.Set%2A> 方法重载。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> 不是 <see langword="null" />。</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="regionName" /> 不是 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><see cref="T:System.Runtime.Caching.CacheItemPolicy" /> 对象的局对和可调过期值都设置为除 <see cref="F:System.Runtime.Caching.ObjectCache.InfiniteAbsoluteExpiration" /> 和 <see cref="F:System.Runtime.Caching.ObjectCache.NoSlidingExpiration" /> 字段的默认值以外的值。 <see cref="T:System.Runtime.Caching.MemoryCache" /> 类不能基于绝对过期和可调过期的组合设置过期策略。 只有使用 <see cref="T:System.Runtime.Caching.MemoryCache" /> 实例，才能显式设定一个过期设置。 另一过期设置必须设置为 <see cref="F:System.Runtime.Caching.ObjectCache.InfiniteAbsoluteExpiration" /> 或 <see cref="F:System.Runtime.Caching.ObjectCache.NoSlidingExpiration" /></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><see cref="P:System.Runtime.Caching.CacheItemPolicy.SlidingExpiration" /> 属性设置为一个小于 <see cref="F:System.TimeSpan.Zero" /> 的值。  
  
- 或 - 
<see cref="P:System.Runtime.Caching.CacheItemPolicy.SlidingExpiration" /> 属性设置为大于一年的值。  
  
- 或 - 
<see cref="P:System.Runtime.Caching.CacheItemPolicy.Priority" /> 属性不是 <see cref="T:System.Runtime.Caching.CacheItemPriority" /> 枚举的值。</exception>
      </Docs>
    </Member>
    <Member MemberName="AddOrGetExisting">
      <MemberSignature Language="C#" Value="public override object AddOrGetExisting (string key, object value, System.Runtime.Caching.CacheItemPolicy policy, string regionName = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object AddOrGetExisting(string key, object value, class System.Runtime.Caching.CacheItemPolicy policy, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.MemoryCache.AddOrGetExisting(System.String,System.Object,System.Runtime.Caching.CacheItemPolicy,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function AddOrGetExisting (key As String, value As Object, policy As CacheItemPolicy, Optional regionName As String = Nothing) As Object" />
      <MemberSignature Language="F#" Value="override this.AddOrGetExisting : string * obj * System.Runtime.Caching.CacheItemPolicy * string -&gt; obj" Usage="memoryCache.AddOrGetExisting (key, value, policy, regionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="policy" Type="System.Runtime.Caching.CacheItemPolicy" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">要添加或获取的缓存项的唯一标识符。</param>
        <param name="value">该缓存项的数据。</param>
        <param name="policy">一个包含该缓存项的逐出详细信息的对象。 此对象提供比简单绝对过期更多的逐出选项。</param>
        <param name="regionName">缓存中的一个可向其添加缓存项的命名区域。 不要为该参数传递值。 默认情况下，此参数为 <see langword="null" />，因为 <see cref="T:System.Runtime.Caching.MemoryCache" /> 类未实现区域。</param>
        <summary>通过使用指定的键、值和有关如何逐出缓存项的指定详细信息，将某个缓存项插入缓存中。</summary>
        <returns>如果已存在匹配的缓存项，则为该缓存项；否则为 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!WARNING]
>  <xref:System.Runtime.Caching.ObjectCache.Add%2A> 和 <xref:System.Runtime.Caching.ObjectCache.AddOrGetExisting%2A> 方法重载不支持 <xref:System.Runtime.Caching.CacheItemPolicy.UpdateCallback%2A> 属性。 因此，若要设置缓存项的 <xref:System.Runtime.Caching.CacheItemPolicy.UpdateCallback%2A> 属性，请改用 <xref:System.Runtime.Caching.MemoryCache.Set%2A> 方法重载。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><see cref="T:System.Runtime.Caching.CacheItemPolicy" /> 对象的绝对和可调过期值设置为除 <see cref="F:System.Runtime.Caching.ObjectCache.InfiniteAbsoluteExpiration" /> 和 <see cref="F:System.Runtime.Caching.ObjectCache.NoSlidingExpiration" /> 的默认值以外的值。 <see cref="T:System.Runtime.Caching.MemoryCache" /> 类不能基于绝对和可调过期的组合设置过期策略。 使用 <see cref="T:System.Runtime.Caching.MemoryCache" /> 类时，只能显式设定一个过期设置。 另一设置必须设置为 <see cref="F:System.Runtime.Caching.ObjectCache.InfiniteAbsoluteExpiration" /> 或 <see cref="F:System.Runtime.Caching.ObjectCache.NoSlidingExpiration" />。  
  
- 或 - 
已经为 <see cref="T:System.Runtime.Caching.CacheItemPolicy" /> 指定了删除回调和更新回调。 <see cref="T:System.Runtime.Caching.MemoryCache" /> 仅支持每个缓存项使用一种类型的回调。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><see cref="P:System.Runtime.Caching.CacheItemPolicy.SlidingExpiration" /> 属性设置为一个小于 <see cref="F:System.TimeSpan.Zero" /> 的值。  
  
- 或 - 
已将 <see cref="P:System.Runtime.Caching.CacheItemPolicy.SlidingExpiration" /> 设置为大于一年的值。  
  
- 或 - 
<see cref="P:System.Runtime.Caching.CacheItemPolicy.Priority" /> 属性不是 <see cref="T:System.Runtime.Caching.CacheItemPriority" /> 枚举的值。</exception>
      </Docs>
    </Member>
    <Member MemberName="CacheMemoryLimit">
      <MemberSignature Language="C#" Value="public long CacheMemoryLimit { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 CacheMemoryLimit" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Caching.MemoryCache.CacheMemoryLimit" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CacheMemoryLimit As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long CacheMemoryLimit { long get(); };" />
      <MemberSignature Language="F#" Value="member this.CacheMemoryLimit : int64" Usage="System.Runtime.Caching.MemoryCache.CacheMemoryLimit" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取计算机上缓存可使用的内存量（以字节为单位）。</summary>
        <value>内存量（以字节为单位）。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果缓存的当前实例超出了由属性设置的内存限制 <xref:System.Runtime.Caching.MemoryCache.CacheMemoryLimit%2A> ，则缓存实现将删除缓存条目。 应用程序中的每个缓存实例都可以使用由属性指定的内存量 <xref:System.Runtime.Caching.MemoryCache.CacheMemoryLimit%2A> 。  
  
 <xref:System.Runtime.Caching.MemoryCache.CacheMemoryLimit%2A>可以在应用程序配置文件中指定属性的设置。 此外，还可以在初始化类时在构造函数中传递它们 <xref:System.Runtime.Caching.MemoryCache> 。 有关如何配置此属性的详细信息，请参阅[ &lt; namedCaches &gt; 元素 (缓存设置) ](/dotnet/framework/configure-apps/file-schema/runtime/namedcaches-element-cache-settings)。 有关如何在初始化类时设置此值的详细信息 <xref:System.Runtime.Caching.MemoryCache> ，请参阅 <xref:System.Runtime.Caching.MemoryCache.%23ctor%2A> 方法。  
  
 <xref:System.Runtime.Caching.MemoryCache><xref:System.Runtime.Caching.MemoryCache.CacheMemoryLimit%2A>每次将新项添加到实例时，不会立即强制执行 <xref:System.Runtime.Caching.MemoryCache> 。 内部试探法（逐出中的附加项）从垃圾回收器中进行额外的项操作 <xref:System.Runtime.Caching.MemoryCache> ，并将信息从垃圾回收器中考虑 (参阅 [垃圾](/dotnet/standard/garbage-collection/) 回收) 和其他因素（如当前缓存大小和整体系统内存压力）。 因此，即使 <xref:System.Runtime.Caching.MemoryCache> 尝试在已配置的中保留缓存大小，也可以 <xref:System.Runtime.Caching.MemoryCache.CacheMemoryLimit%2A> 通过以非常高的速率添加缓存项来暂时超出限制。  
  
 ]]></format>
        </remarks>
        <related type="Article" href="/dotnet/framework/configure-apps/file-schema/runtime/namedcaches-element-cache-settings">&lt;&gt; (缓存设置的 namedCaches 元素) </related>
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public override bool Contains (string key, string regionName = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Contains(string key, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.MemoryCache.Contains(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Contains (key As String, Optional regionName As String = Nothing) As Boolean" />
      <MemberSignature Language="F#" Value="override this.Contains : string * string -&gt; bool" Usage="memoryCache.Contains (key, regionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">要搜索的缓存项的唯一标识符。</param>
        <param name="regionName">缓存中的一个添加了缓存项的命名区域。 不要为该参数传递值。 默认情况下，此参数为<see langword="null" />，因为 <see cref="T:System.Runtime.Caching.MemoryCache" /> 类未实现区域。</param>
        <summary>确定缓存中是否存在某个缓存项。</summary>
        <returns>如果缓存中包含其键与 <paramref name="key" /> 匹配的缓存项，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="key" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="regionName" /> 不是 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateCacheEntryChangeMonitor">
      <MemberSignature Language="C#" Value="public override System.Runtime.Caching.CacheEntryChangeMonitor CreateCacheEntryChangeMonitor (System.Collections.Generic.IEnumerable&lt;string&gt; keys, string regionName = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Runtime.Caching.CacheEntryChangeMonitor CreateCacheEntryChangeMonitor(class System.Collections.Generic.IEnumerable`1&lt;string&gt; keys, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.MemoryCache.CreateCacheEntryChangeMonitor(System.Collections.Generic.IEnumerable{System.String},System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function CreateCacheEntryChangeMonitor (keys As IEnumerable(Of String), Optional regionName As String = Nothing) As CacheEntryChangeMonitor" />
      <MemberSignature Language="F#" Value="override this.CreateCacheEntryChangeMonitor : seq&lt;string&gt; * string -&gt; System.Runtime.Caching.CacheEntryChangeMonitor" Usage="memoryCache.CreateCacheEntryChangeMonitor (keys, regionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Caching.CacheEntryChangeMonitor</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keys" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="keys"><see cref="T:System.Runtime.Caching.CacheEntryChangeMonitor" /> 对象的唯一缓存项键的枚举。</param>
        <param name="regionName">缓存中的一个可向其添加缓存项的命名区域。 不要为该参数传递值。 默认情况下，此参数为<see langword="null" />，因为 <see cref="T:System.Runtime.Caching.MemoryCache" /> 类未实现区域。</param>
        <summary>创建一个 <see cref="T:System.Runtime.Caching.CacheEntryChangeMonitor" /> 对象，该对象可触发事件以响应对指定缓存项的更改。</summary>
        <returns>用于监视缓存中的项的更改监视器。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.Caching.MemoryCache.CreateCacheEntryChangeMonitor%2A>方法创建一个 <xref:System.Runtime.Caching.CacheEntryChangeMonitor> 实例。 此专用更改监视器用于监视集合中指定的缓存项， `keys` 并在项发生更改时触发事件。  
  
 监视的条目出于以下任何原因而被视为已更改：  
  
-   调用方法时，该键不存在 <xref:System.Runtime.Caching.MemoryCache.CreateCacheEntryChangeMonitor%2A> 。 在这种情况下，生成的 <xref:System.Runtime.Caching.CacheEntryChangeMonitor> 实例将立即设置为已更改状态。 这意味着，当代码随后绑定更改通知回调时，将立即触发回调。  
  
-   关联的缓存项已从缓存中移除。 如果该项已显式删除（如果该项过期，或被逐出恢复内存），则可能会发生这种情况。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><paramref name="regionName" /> 不是 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="keys" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="keys" /> 集合中有一项是 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="Default">
      <MemberSignature Language="C#" Value="public static System.Runtime.Caching.MemoryCache Default { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Runtime.Caching.MemoryCache Default" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Caching.MemoryCache.Default" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Default As MemoryCache" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Runtime::Caching::MemoryCache ^ Default { System::Runtime::Caching::MemoryCache ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Default : System.Runtime.Caching.MemoryCache" Usage="System.Runtime.Caching.MemoryCache.Default" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Caching.MemoryCache</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取对默认 <see cref="T:System.Runtime.Caching.MemoryCache" /> 实例的引用。</summary>
        <value>缓存的默认实例。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此属性始终返回对默认缓存实例的引用。 对于典型的应用程序方案，只需要一个实例 <xref:System.Runtime.Caching.MemoryCache> 。  
  
 因为默认缓存实例不是由构造函数创建的，所以必须使用配置来显式设置默认缓存实例的内存和轮询值。 有关详细信息，请参阅[ &lt; memoryCache &gt; 元素 (缓存设置) ](/dotnet/framework/configure-apps/file-schema/runtime/memorycache-element-cache-settings)。  
  
 ]]></format>
        </remarks>
        <related type="Article" href="/dotnet/framework/configure-apps/file-schema/runtime/memorycache-element-cache-settings">&lt;&gt; (缓存设置的 memoryCache 元素) </related>
      </Docs>
    </Member>
    <Member MemberName="DefaultCacheCapabilities">
      <MemberSignature Language="C#" Value="public override System.Runtime.Caching.DefaultCacheCapabilities DefaultCacheCapabilities { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Runtime.Caching.DefaultCacheCapabilities DefaultCacheCapabilities" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Caching.MemoryCache.DefaultCacheCapabilities" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property DefaultCacheCapabilities As DefaultCacheCapabilities" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Runtime::Caching::DefaultCacheCapabilities DefaultCacheCapabilities { System::Runtime::Caching::DefaultCacheCapabilities get(); };" />
      <MemberSignature Language="F#" Value="member this.DefaultCacheCapabilities : System.Runtime.Caching.DefaultCacheCapabilities" Usage="System.Runtime.Caching.MemoryCache.DefaultCacheCapabilities" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Caching.DefaultCacheCapabilities</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取缓存提供的功能的说明。</summary>
        <value>标志的按位组合，这些标志指示缓存实现的默认功能。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 缓存实现的功能是以下值的组合：  
  
-   <xref:System.Runtime.Caching.DefaultCacheCapabilities.InMemoryProvider>  
  
-   <xref:System.Runtime.Caching.DefaultCacheCapabilities.CacheEntryChangeMonitors>  
  
-   <xref:System.Runtime.Caching.DefaultCacheCapabilities.AbsoluteExpirations>  
  
-   <xref:System.Runtime.Caching.DefaultCacheCapabilities.SlidingExpirations>  
  
-   <xref:System.Runtime.Caching.DefaultCacheCapabilities.CacheEntryUpdateCallback>  
  
-   <xref:System.Runtime.Caching.DefaultCacheCapabilities.CacheEntryRemovedCallback>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.MemoryCache.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="memoryCache.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>释放由 <see cref="T:System.Runtime.Caching.MemoryCache" /> 类的当前实例占用的所有资源。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 每个 <xref:System.Runtime.Caching.MemoryCache> 实例都绑定到 <xref:System.Web.Compilation.ClientBuildManager.AppDomainUnloaded> 事件。 但是，在应用程序域关闭期间，如果基于内存的缓存尚未显式释放，则缓存实例会自动调用 <xref:System.Runtime.Caching.MemoryCache.Dispose%2A> 方法。  
  
 已释放的缓存实例将使用以下步骤关闭：  
  
1.  缓存的状态设置为指示缓存已释放。 尝试调用将更改缓存状态的公共缓存方法（例如添加、删除或检索缓存条目的方法）时，可能会导致意外的行为。 例如，如果在 <xref:System.Runtime.Caching.MemoryCache.Set%2A> 释放缓存后调用方法，则不会发生 op 错误。 如果尝试从缓存中检索项，则该 <xref:System.Runtime.Caching.MemoryCache.Get%2A> 方法将始终返回 `null` 。  
  
2.  不再从当前缓存实例中引发性能计数器信息。  
  
3.  释放对当前缓存实例所包含的缓存对象的所有引用。  
  
4.  将 <xref:System.Runtime.Caching.CacheEntryChangeMonitor> 通知当前正在监视缓存中的条目的任何实例。  
  
5.  将调用为这些监视器提供更改通知的回调对象。  
  
6.  <xref:System.Web.Caching.CacheItemRemovedCallback>向缓存中的条目注册的任何实例都将被调用。 传递给回调的删除原因为 <xref:System.Runtime.Caching.CacheEntryRemovedReason.CacheSpecificEviction> 。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Get">
      <MemberSignature Language="C#" Value="public override object Get (string key, string regionName = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object Get(string key, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.MemoryCache.Get(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Get (key As String, Optional regionName As String = Nothing) As Object" />
      <MemberSignature Language="F#" Value="override this.Get : string * string -&gt; obj" Usage="memoryCache.Get (key, regionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">要获取的缓存项的唯一标识符。</param>
        <param name="regionName">缓存中的一个添加了缓存项的命名区域。 不要为该参数传递值。 默认情况下，此参数为<see langword="null" />，因为 <see cref="T:System.Runtime.Caching.MemoryCache" /> 类未实现区域。</param>
        <summary>从缓存中返回一个项。</summary>
        <returns>如果该项存在，则为对 <paramref name="key" /> 标识的缓存项的引用；否则为 <see langword="null" />。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException"><paramref name="regionName" /> 不是 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="key" /> 为 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetCacheItem">
      <MemberSignature Language="C#" Value="public override System.Runtime.Caching.CacheItem GetCacheItem (string key, string regionName = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Runtime.Caching.CacheItem GetCacheItem(string key, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.MemoryCache.GetCacheItem(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetCacheItem (key As String, Optional regionName As String = Nothing) As CacheItem" />
      <MemberSignature Language="F#" Value="override this.GetCacheItem : string * string -&gt; System.Runtime.Caching.CacheItem" Usage="memoryCache.GetCacheItem (key, regionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Caching.CacheItem</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">要获取的缓存项的唯一标识符。</param>
        <param name="regionName">缓存中的一个添加了缓存项的命名区域。 不要为该参数传递值。 默认情况下，此参数为<see langword="null" />，因为 <see cref="T:System.Runtime.Caching.MemoryCache" /> 类未实现区域。</param>
        <summary>从缓存中返回 <see cref="T:System.Runtime.Caching.CacheItem" /> 实例形式的指定项。</summary>
        <returns>如果该项存在，则为对 <paramref name="key" /> 标识的缓存项的引用；否则为 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果缓存中存在由指定的缓存项 `key` ，则此 <xref:System.Runtime.Caching.MemoryCache.GetCacheItem%2A> 方法会将其作为 <xref:System.Runtime.Caching.CacheItem> 实例返回。 <xref:System.Runtime.Caching.CacheItem.Key%2A> <xref:System.Runtime.Caching.CacheItem.Value%2A> <xref:System.Runtime.Caching.CacheItem> 将设置实例的和属性。 但是， <xref:System.Runtime.Caching.CacheItem.RegionName%2A> `null` 由于未在类中实现区域，因此属性将为 <xref:System.Runtime.Caching.MemoryCache> 。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><paramref name="regionName" /> 不是 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="key" /> 为 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetCount">
      <MemberSignature Language="C#" Value="public override long GetCount (string regionName = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int64 GetCount(string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.MemoryCache.GetCount(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetCount (Optional regionName As String = Nothing) As Long" />
      <MemberSignature Language="F#" Value="override this.GetCount : string -&gt; int64" Usage="memoryCache.GetCount regionName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="regionName">缓存中的一个添加了缓存项的命名区域。 不要为该参数传递值。 默认情况下，此参数为<see langword="null" />，因为 <see cref="T:System.Runtime.Caching.MemoryCache" /> 类未实现区域。</param>
        <summary>返回缓存中的缓存项总数。</summary>
        <returns>缓存中的项数。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException"><paramref name="regionName" /> 不是 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="protected override System.Collections.Generic.IEnumerator&lt;System.Collections.Generic.KeyValuePair&lt;string,object&gt;&gt; GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Collections.Generic.IEnumerator`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;string, object&gt;&gt; GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.MemoryCache.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function GetEnumerator () As IEnumerator(Of KeyValuePair(Of String, Object))" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Collections::Generic::IEnumerator&lt;System::Collections::Generic::KeyValuePair&lt;System::String ^, System::Object ^&gt;&gt; ^ GetEnumerator();" />
      <MemberSignature Language="F#" Value="override this.GetEnumerator : unit -&gt; System.Collections.Generic.IEnumerator&lt;System.Collections.Generic.KeyValuePair&lt;string, obj&gt;&gt;" Usage="memoryCache.GetEnumerator " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerator&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Object&gt;&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>创建一个枚举器，它可用于循环访问缓存项的集合。</summary>
        <returns>可提供对缓存中的项的访问的枚举器对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 方法返回的枚举数 <xref:System.Runtime.Caching.MemoryCache.GetEnumerator%2A> 可用于循环访问缓存中的项。  
  
> [!IMPORTANT]
>  检索实例的枚举器 <xref:System.Runtime.Caching.MemoryCache> 是消耗大量资源的操作。 因此，不应在生产应用程序中使用枚举器。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetLastSize">
      <MemberSignature Language="C#" Value="public long GetLastSize (string regionName = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int64 GetLastSize(string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.MemoryCache.GetLastSize(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetLastSize (Optional regionName As String = Nothing) As Long" />
      <MemberSignature Language="F#" Value="member this.GetLastSize : string -&gt; int64" Usage="memoryCache.GetLastSize regionName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="regionName" Type="System.String" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;dotnet-plat-ext-3.1;dotnet-plat-ext-5.0;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="regionName">区域的名称。</param>
        <summary>获取已命名区域的大小。</summary>
        <returns>已命名区域的大小。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetValues">
      <MemberSignature Language="C#" Value="public override System.Collections.Generic.IDictionary&lt;string,object&gt; GetValues (System.Collections.Generic.IEnumerable&lt;string&gt; keys, string regionName = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Collections.Generic.IDictionary`2&lt;string, object&gt; GetValues(class System.Collections.Generic.IEnumerable`1&lt;string&gt; keys, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.MemoryCache.GetValues(System.Collections.Generic.IEnumerable{System.String},System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetValues (keys As IEnumerable(Of String), Optional regionName As String = Nothing) As IDictionary(Of String, Object)" />
      <MemberSignature Language="F#" Value="override this.GetValues : seq&lt;string&gt; * string -&gt; System.Collections.Generic.IDictionary&lt;string, obj&gt;" Usage="memoryCache.GetValues (keys, regionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IDictionary&lt;System.String,System.Object&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keys" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="keys">要返回的缓存项的一组唯一标识符。</param>
        <param name="regionName">缓存中的一个添加了缓存项的命名区域。 不要为该参数传递值。 默认情况下，此参数为<see langword="null" />，因为 <see cref="T:System.Runtime.Caching.MemoryCache" /> 类未实现区域。</param>
        <summary>返回与指定的键对应的一组缓存项。</summary>
        <returns>与指定的键对应的一组缓存项。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果表示的缓存项 `keys` 不存在，则将字典中返回的对象的相应值设置为 `null` 。 因此，返回的字典始终具有与中的元素数相同的项数 `keys` 。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><paramref name="regionName" /> 不是 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="keys" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">集合中的单个键为 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public override object this[string key] { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Item(string)" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Caching.MemoryCache.Item(System.String)" />
      <MemberSignature Language="VB.NET" Value="Default Public Overrides Property Item(key As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Object ^ default[System::String ^] { System::Object ^ get(System::String ^ key); void set(System::String ^ key, System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Item(string) : obj with get, set" Usage="System.Runtime.Caching.MemoryCache.Item" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">要获取或设置的缓存值的唯一标识符。</param>
        <summary>通过使用 <see cref="T:System.Runtime.Caching.MemoryCache" /> 类的实例的默认索引器属性，获取或设置缓存中的值。</summary>
        <value>如果该项存在，则为指定键的缓存实例中的值；否则为 <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 设置此属性时，值将插入到缓存中。 缓存条目的过期策略设置为 <xref:System.Runtime.Caching.ObjectCache.InfiniteAbsoluteExpiration> 。 如果已存在具有匹配键的缓存项，则将更新其值。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="key" /> 为 <see langword="null" />。  
  
- 或 - 
插入的值为 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public override string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Caching.MemoryCache.Name" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Name { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Name : string" Usage="System.Runtime.Caching.MemoryCache.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取缓存的名称。</summary>
        <value>缓存的名称。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.Caching.MemoryCache.Name%2A>属性返回类的当前实例的名称 <xref:System.Runtime.Caching.MemoryCache> 。 在使用多个缓存实例的应用程序中，可以使用 <xref:System.Runtime.Caching.MemoryCache.Name%2A> 属性来帮助区分实例。 有关更多信息，请参见 <xref:System.Runtime.Caching.MemoryCache.%23ctor%28System.String%2CSystem.Collections.Specialized.NameValueCollection%29?displayProperty=nameWithType> 方法。 默认的基于内存的缓存返回默认名称。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PhysicalMemoryLimit">
      <MemberSignature Language="C#" Value="public long PhysicalMemoryLimit { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 PhysicalMemoryLimit" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Caching.MemoryCache.PhysicalMemoryLimit" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PhysicalMemoryLimit As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long PhysicalMemoryLimit { long get(); };" />
      <MemberSignature Language="F#" Value="member this.PhysicalMemoryLimit : int64" Usage="System.Runtime.Caching.MemoryCache.PhysicalMemoryLimit" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取缓存可使用的物理内存的百分比。</summary>
        <value>缓存可使用的物理内存的百分比。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.Caching.MemoryCache.PhysicalMemoryLimit%2A>属性返回类的单个实例可使用的物理计算机总内存的百分比 <xref:System.Runtime.Caching.MemoryCache> 。 如果缓存实例超过指定的限制，则会删除缓存项。  
  
 <xref:System.Runtime.Caching.MemoryCache.PhysicalMemoryLimit%2A>可以在应用程序配置文件中指定属性的设置。 或者，在初始化类时，调用方可以传递它们 <xref:System.Runtime.Caching.MemoryCache> 。 有关如何配置此属性的详细信息，请参阅[ &lt; namedCaches &gt; 元素 (缓存设置) ](/dotnet/framework/configure-apps/file-schema/runtime/namedcaches-element-cache-settings)。 有关如何在初始化类时配置属性的详细信息 <xref:System.Runtime.Caching.MemoryCache> ，请参阅 <xref:System.Runtime.Caching.MemoryCache.%23ctor%28System.String%2CSystem.Collections.Specialized.NameValueCollection%29?displayProperty=nameWithType> 方法。  
  
 ]]></format>
        </remarks>
        <related type="Article" href="/dotnet/framework/configure-apps/file-schema/runtime/namedcaches-element-cache-settings">&lt;&gt; (缓存设置的 namedCaches 元素) </related>
      </Docs>
    </Member>
    <Member MemberName="PollingInterval">
      <MemberSignature Language="C#" Value="public TimeSpan PollingInterval { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan PollingInterval" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Caching.MemoryCache.PollingInterval" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PollingInterval As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan PollingInterval { TimeSpan get(); };" />
      <MemberSignature Language="F#" Value="member this.PollingInterval : TimeSpan" Usage="System.Runtime.Caching.MemoryCache.PollingInterval" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取在缓存更新其内存统计信息之前需等待的最大时间量。</summary>
        <value>在更新内存统计信息之前需等待的最大时间量。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.Caching.MemoryCache.PollingInterval%2A>可以在应用程序配置文件中指定属性的设置。 也可以在初始化类时传递 <xref:System.Runtime.Caching.MemoryCache> 。 有关如何配置此属性的详细信息，请参阅[ &lt; namedCaches &gt; 元素 (缓存设置) ](/dotnet/framework/configure-apps/file-schema/runtime/namedcaches-element-cache-settings)。 有关如何在初始化类时配置属性的详细信息 <xref:System.Runtime.Caching.MemoryCache> ，请参阅 <xref:System.Runtime.Caching.MemoryCache.%23ctor%28System.String%2CSystem.Collections.Specialized.NameValueCollection%29?displayProperty=nameWithType> 方法。  
  
 ]]></format>
        </remarks>
        <related type="Article" href="/dotnet/framework/configure-apps/file-schema/runtime/namedcaches-element-cache-settings">&lt;&gt; (缓存设置的 namedCaches 元素) </related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Remove">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>从缓存中移除指定的项。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public override object Remove (string key, string regionName = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object Remove(string key, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.MemoryCache.Remove(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Remove (key As String, Optional regionName As String = Nothing) As Object" />
      <MemberSignature Language="F#" Value="override this.Remove : string * string -&gt; obj" Usage="memoryCache.Remove (key, regionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">要移除的缓存项的唯一标识符。</param>
        <param name="regionName">缓存中的一个添加了缓存项的命名区域。 不要为该参数传递值。 默认情况下，此参数为<see langword="null" />，因为 <see cref="T:System.Runtime.Caching.MemoryCache" /> 类未实现区域。</param>
        <summary>从缓存中移除某个缓存项。</summary>
        <returns>如果在缓存中找到该项，则为已移除的缓存项；否则为 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果在缓存中存在由指定的条目 `key` ，则删除项目会触发任何关联的更改监视器。 如果移除的项与 <xref:System.Web.Caching.CacheItemUpdateCallback> 对象或对象关联，则 <xref:System.Web.Caching.CacheItemRemovedCallback> 传递到回调的原因为 <xref:System.Runtime.Caching.CacheEntryRemovedReason.Removed> 。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><paramref name="regionName" /> 不是 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="key" /> 为 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public object Remove (string key, System.Runtime.Caching.CacheEntryRemovedReason reason, string regionName = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object Remove(string key, valuetype System.Runtime.Caching.CacheEntryRemovedReason reason, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.MemoryCache.Remove(System.String,System.Runtime.Caching.CacheEntryRemovedReason,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Remove (key As String, reason As CacheEntryRemovedReason, Optional regionName As String = Nothing) As Object" />
      <MemberSignature Language="F#" Value="override this.Remove : string * System.Runtime.Caching.CacheEntryRemovedReason * string -&gt; obj" Usage="memoryCache.Remove (key, reason, regionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;dotnet-plat-ext-3.1;dotnet-plat-ext-5.0;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="reason" Type="System.Runtime.Caching.CacheEntryRemovedReason" Index="1" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;dotnet-plat-ext-3.1;dotnet-plat-ext-5.0;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="regionName" Type="System.String" Index="2" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;dotnet-plat-ext-3.1;dotnet-plat-ext-5.0;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="key">要移除的缓存项的唯一标识符。</param>
        <param name="reason">删除项的原因。</param>
        <param name="regionName">缓存中的一个添加了缓存项的命名区域。 不要为该参数传递值。 默认情况下，此参数为<see langword="null" />，因为 <see cref="T:System.Runtime.Caching.MemoryCache" /> 类未实现区域。</param>
        <summary>使用原因从缓存中删除缓存项。</summary>
        <returns>如果在缓存中找到该项，则为已移除的缓存项；否则为 <see langword="null" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Set">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>将某个缓存项插入缓存中。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果指定的项不存在，则创建它。 如果指定的项存在，则将更新该项。  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Set">
      <MemberSignature Language="C#" Value="public override void Set (System.Runtime.Caching.CacheItem item, System.Runtime.Caching.CacheItemPolicy policy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Set(class System.Runtime.Caching.CacheItem item, class System.Runtime.Caching.CacheItemPolicy policy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.MemoryCache.Set(System.Runtime.Caching.CacheItem,System.Runtime.Caching.CacheItemPolicy)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Set (item As CacheItem, policy As CacheItemPolicy)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Set(System::Runtime::Caching::CacheItem ^ item, System::Runtime::Caching::CacheItemPolicy ^ policy);" />
      <MemberSignature Language="F#" Value="override this.Set : System.Runtime.Caching.CacheItem * System.Runtime.Caching.CacheItemPolicy -&gt; unit" Usage="memoryCache.Set (item, policy)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Runtime.Caching.CacheItem" />
        <Parameter Name="policy" Type="System.Runtime.Caching.CacheItemPolicy" />
      </Parameters>
      <Docs>
        <param name="item">表示要插入的缓存项的对象。</param>
        <param name="policy">一个包含该缓存项的逐出详细信息的对象。 此对象提供比简单绝对过期更多的逐出选项。</param>
        <summary>使用 <see cref="T:System.Runtime.Caching.CacheItem" /> 实例将某个缓存项插入缓存中，以便为该缓存项提供键和值。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 与其他 <xref:System.Runtime.Caching.MemoryCache.Set%2A> 方法重载一样， <xref:System.Runtime.Caching.MemoryCache.Set%2A> 方法始终将缓存值放在缓存中，而不考虑是否已存在具有相同键的项。 如果缓存中不存在指定的条目，则插入新的缓存条目。 如果指定的项已存在，则将更新其值。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="item" /> 为 <see langword="null" />。  
  
- 或 - 
<see cref="P:System.Runtime.Caching.CacheItem.Key" /> 属性为 <see langword="null" />。  
  
- 或 - 
<see cref="P:System.Runtime.Caching.CacheItem.Value" /> 属性为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">为高速缓存项传递了无效的参数组合。 如果缓存项的策略对象上设置了以下过期详细信息，将发生这种情况： 
-   如果 <see cref="T:System.Runtime.Caching.CacheItemPolicy" /> 对象的绝对和可调过期值都设置为除 <see cref="F:System.Runtime.Caching.ObjectCache.InfiniteAbsoluteExpiration" /> 和 <see cref="F:System.Runtime.Caching.ObjectCache.NoSlidingExpiration" /> 字段的默认值以外的值。 <see cref="T:System.Runtime.Caching.MemoryCache" /> 类不能基于绝对过期和可调过期设置过期策略。 使用 <see cref="T:System.Runtime.Caching.MemoryCache" /> 类时，只能显式设定一个过期设置。 其他设置必须设置为 <see cref="F:System.Runtime.Caching.ObjectCache.InfiniteAbsoluteExpiration" /> 或 <see cref="F:System.Runtime.Caching.ObjectCache.NoSlidingExpiration" /> 属性。  
  
-   如果为 <see cref="T:System.Runtime.Caching.CacheItemPolicy" /> 对象同时指定了删除回调和更新回调。 <see cref="T:System.Runtime.Caching.MemoryCache" /> 类仅支持每个缓存项使用一种类型的回调。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><see cref="P:System.Runtime.Caching.CacheItemPolicy.SlidingExpiration" /> 属性设置为一个小于 <see cref="F:System.TimeSpan.Zero" /> 的值。  
  
- 或 - 
<see cref="P:System.Runtime.Caching.CacheItemPolicy.SlidingExpiration" /> 属性设置为大于一年的值。  
  
- 或 - 
<see cref="P:System.Runtime.Caching.CacheItemPolicy.Priority" /> 不是 <see cref="T:System.Runtime.Caching.CacheItemPriority" /> 枚举的值。</exception>
      </Docs>
    </Member>
    <Member MemberName="Set">
      <MemberSignature Language="C#" Value="public override void Set (string key, object value, DateTimeOffset absoluteExpiration, string regionName = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Set(string key, object value, valuetype System.DateTimeOffset absoluteExpiration, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.MemoryCache.Set(System.String,System.Object,System.DateTimeOffset,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Set (key As String, value As Object, absoluteExpiration As DateTimeOffset, Optional regionName As String = Nothing)" />
      <MemberSignature Language="F#" Value="override this.Set : string * obj * DateTimeOffset * string -&gt; unit" Usage="memoryCache.Set (key, value, absoluteExpiration, regionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="absoluteExpiration" Type="System.DateTimeOffset" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">要插入的缓存项的唯一标识符。</param>
        <param name="value">该缓存项的数据。</param>
        <param name="absoluteExpiration">缓存项的固定的过期日期和时间。</param>
        <param name="regionName">缓存中的一个可向其添加缓存项的命名区域。 不要为该参数传递值。 默认情况下，此参数为<see langword="null" />，因为 <see cref="T:System.Runtime.Caching.MemoryCache" /> 类未实现区域。</param>
        <summary>使用键和值将某个缓存项插入缓存中，并指定基于时间的过期详细信息。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 与其他 <xref:System.Runtime.Caching.MemoryCache.Set%2A> 方法重载一样， <xref:System.Runtime.Caching.MemoryCache.Set%2A> 方法始终将缓存值放在缓存中，而不考虑是否已存在具有相同键的项。 如果指定的项不存在，则插入一个新的缓存项。 如果指定的项存在，则将更新该项。  
  
 `absoluteExpiration`参数指示应从缓存中删除项的时间。  
  
 删除某个条目会触发任何关联的更改监视器。 如果移除的项与 <xref:System.Web.Caching.CacheItemUpdateCallback> 对象或 <xref:System.Web.Caching.CacheItemRemovedCallback> 对象关联，则传递到回调的删除原因将包含在 <xref:System.Runtime.Caching.CacheEntryRemovedReason.Removed> 属性中。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><paramref name="regionName" /> 不是 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="key" /> 为 <see langword="null" />。  
  
- 或 - 
 <paramref name="Value" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">-   为高速缓存项传递了无效的参数组合。 如果缓存项的策略对象上设置了以下过期详细信息，将发生这种情况： 
-   如果 <see cref="T:System.Runtime.Caching.CacheItemPolicy" /> 对象上的绝对和可调过期值都设置为除 <see cref="F:System.Runtime.Caching.ObjectCache.InfiniteAbsoluteExpiration" /> 和 <see cref="F:System.Runtime.Caching.ObjectCache.NoSlidingExpiration" /> 的默认值以外的值。 发生这种情况是因为 <see cref="T:System.Runtime.Caching.MemoryCache" /> 类不支持基于绝对和可调过期的过期项。 使用 <see cref="T:System.Runtime.Caching.MemoryCache" /> 类时，只能显式设定一个过期设置。 另一设置必须设置为 <see cref="F:System.Runtime.Caching.ObjectCache.InfiniteAbsoluteExpiration" /> 或 <see cref="F:System.Runtime.Caching.ObjectCache.NoSlidingExpiration" />。  
  
-   如果在 <see cref="T:System.Runtime.Caching.CacheItemPolicy" /> 对象上同时指定了删除回调和更新回调。 <see cref="T:System.Runtime.Caching.MemoryCache" /> 类仅支持每个缓存项使用一种类型的回调。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><see cref="P:System.Runtime.Caching.CacheItemPolicy.SlidingExpiration" /> 属性设置为一个小于 <see cref="F:System.TimeSpan.Zero" /> 的值。  
  
- 或 - 
<see cref="P:System.Runtime.Caching.CacheItemPolicy.SlidingExpiration" /> 属性设置为大于一年的值。  
  
- 或 - 
-   <see cref="P:System.Runtime.Caching.CacheItemPolicy.Priority" /> 属性不是 <see cref="T:System.Runtime.Caching.CacheItemPriority" /> 枚举的值。</exception>
      </Docs>
    </Member>
    <Member MemberName="Set">
      <MemberSignature Language="C#" Value="public override void Set (string key, object value, System.Runtime.Caching.CacheItemPolicy policy, string regionName = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Set(string key, object value, class System.Runtime.Caching.CacheItemPolicy policy, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.MemoryCache.Set(System.String,System.Object,System.Runtime.Caching.CacheItemPolicy,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Set (key As String, value As Object, policy As CacheItemPolicy, Optional regionName As String = Nothing)" />
      <MemberSignature Language="F#" Value="override this.Set : string * obj * System.Runtime.Caching.CacheItemPolicy * string -&gt; unit" Usage="memoryCache.Set (key, value, policy, regionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="policy" Type="System.Runtime.Caching.CacheItemPolicy" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">要插入的缓存项的唯一标识符。</param>
        <param name="value">该缓存项的数据。</param>
        <param name="policy">一个包含该缓存项的逐出详细信息的对象。 此对象提供比简单绝对过期更多的逐出选项。</param>
        <param name="regionName">缓存中的一个可向其添加缓存项的命名区域。 不要为该参数传递值。 默认情况下，此参数为<see langword="null" />，因为 <see cref="T:System.Runtime.Caching.MemoryCache" /> 类未实现区域。</param>
        <summary>通过使用键、值和逐出设置，将某个缓存项插入缓存中。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 与其他 <xref:System.Runtime.Caching.MemoryCache.Set%2A> 方法重载一样， <xref:System.Runtime.Caching.MemoryCache.Set%2A> 方法始终将缓存值放在缓存中，而不考虑匹配项是否已存在。 如果缓存中不存在指定的条目，则插入新的缓存条目。 如果指定的项存在，则将更新该项。  
  
 删除某个条目会触发任何关联的更改监视器。 如果移除的项与 <xref:System.Web.Caching.CacheItemUpdateCallback> 对象或 <xref:System.Web.Caching.CacheItemRemovedCallback> 对象关联，则传递到回调的删除原因将包含在 <xref:System.Runtime.Caching.CacheEntryRemovedReason.Removed> 属性中。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="key" /> 为 <see langword="null" />。  
  
- 或 - 
 <paramref name="value" /> 为 <see langword="null" />  
  
- 或 - 
已传递给 <see cref="P:System.Runtime.Caching.CacheItemPolicy.UpdateCallback" /> 属性中的帮助程序方法的回调引用为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">-   高速缓存项存在无效的参数组合。 如果缓存项的策略对象上设置了以下过期详细信息，将发生这种情况： 
-   如果 <see cref="T:System.Runtime.Caching.CacheItemPolicy" /> 对象上的绝对和可调过期值都设置为除 <see cref="F:System.Runtime.Caching.ObjectCache.InfiniteAbsoluteExpiration" /> 和 <see cref="F:System.Runtime.Caching.ObjectCache.NoSlidingExpiration" /> 的默认值以外的值。 这是因为 <see cref="T:System.Runtime.Caching.MemoryCache" /> 类不支持基于绝对和可调过期的过期项。 使用 <see cref="T:System.Runtime.Caching.MemoryCache" /> 类时，只能显式设定一个过期设置。 另一设置必须设置为 <see cref="F:System.Runtime.Caching.ObjectCache.InfiniteAbsoluteExpiration" /> 或 <see cref="F:System.Runtime.Caching.ObjectCache.NoSlidingExpiration" />。  
  
-   如果在 <see cref="T:System.Runtime.Caching.CacheItemPolicy" /> 类上同时指定了删除回调和更新回调。 <see cref="T:System.Runtime.Caching.MemoryCache" /> 类仅支持每个缓存项使用一种类型的回调。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><see cref="P:System.Runtime.Caching.CacheItemPolicy.SlidingExpiration" /> 属性设置为一个小于 <see cref="F:System.TimeSpan.Zero" /> 的值。  
  
- 或 - 
<see cref="P:System.Runtime.Caching.CacheItemPolicy.SlidingExpiration" /> 属性设置为大于一年的值。  
  
- 或 - 
<see cref="P:System.Runtime.Caching.CacheItemPolicy.Priority" /> 属性不是 <see cref="T:System.Runtime.Caching.CacheItemPriority" /> 枚举的值。</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="regionName" /> 不是 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerable.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IEnumerator IEnumerable.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.MemoryCache.System#Collections#IEnumerable#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator Implements IEnumerable.GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IEnumerator ^ System.Collections.IEnumerable.GetEnumerator() = System::Collections::IEnumerable::GetEnumerator;" />
      <MemberSignature Language="F#" Value="override this.System.Collections.IEnumerable.GetEnumerator : unit -&gt; System.Collections.IEnumerator" Usage="memoryCache.System.Collections.IEnumerable.GetEnumerator " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>为在泛型集合上进行迭代提供支持。</summary>
        <returns>可提供对缓存中的项的访问的枚举器对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此成员是显式接口成员的实现。 它只能在 <xref:System.Runtime.Caching.MemoryCache> 实例被强制转换为接口时使用 <xref:System.Collections.IEnumerable> 。  
  
 您可以使用此方法循环访问缓存项的泛型集合。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Trim">
      <MemberSignature Language="C#" Value="public long Trim (int percent);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int64 Trim(int32 percent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.MemoryCache.Trim(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Trim (percent As Integer) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; long Trim(int percent);" />
      <MemberSignature Language="F#" Value="member this.Trim : int -&gt; int64" Usage="memoryCache.Trim percent" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="percent" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="percent">要移除的缓存项总数的百分比。</param>
        <summary>从缓存对象中移除指定百分比的缓存项。</summary>
        <returns>从缓存中移除的项数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.Caching.MemoryCache.Trim%2A>属性首先删除超出绝对或可调过期的条目。 为删除的项注册的任何回调都将被传递，原因是 <xref:System.Web.Caching.CacheItemRemovedReason.Expired> 。  
  
 如果删除过期条目不足以达到指定的剪裁百分比，则将根据最近最少使用 (LRU) 算法从缓存中删除其他条目，直到达到请求的剪裁百分比。 为以这种方式删除的项注册的任何回调都将被传递删除原因 <xref:System.Runtime.Caching.CacheEntryRemovedReason.Evicted> 。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
