<Type Name="IPAddress" FullName="System.Net.IPAddress">
  <Metadata><Meta Name="ms.openlocfilehash" Value="f31070bfd4d3de160b36fed6f68f3132fed46f18" /><Meta Name="ms.sourcegitcommit" Value="13a6cb6fba7e05947f15d8d6cc802703ae9c21d5" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-CN" /><Meta Name="ms.lasthandoff" Value="09/18/2020" /><Meta Name="ms.locfileid" Value="90799619" /></Metadata><TypeSignature Language="C#" Value="public class IPAddress" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit IPAddress extends System.Object" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1" />
  <TypeSignature Language="DocId" Value="T:System.Net.IPAddress" />
  <TypeSignature Language="VB.NET" Value="Public Class IPAddress" />
  <TypeSignature Language="C++ CLI" Value="public ref class IPAddress" />
  <TypeSignature Language="F#" Value="type IPAddress = class" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit IPAddress extends System.Object" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <AssemblyInfo>
    <AssemblyName>System.Net.Primitives</AssemblyName>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
    <AssemblyVersion>4.1.2.0</AssemblyVersion>
    <AssemblyVersion>5.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Net</AssemblyName>
  </AssemblyInfo>
  <TypeForwardingChain>
    <TypeForwarding From="netstandard" FromVersion="2.1.0.0" To="System.Net.Primitives" ToVersion="5.0.0.0" FrameworkAlternate="net-5.0" />
    <TypeForwarding From="System.Net" FromVersion="4.0.0.0" To="System" ToVersion="4.0.0.0" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
  </TypeForwardingChain>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName Language="C#">[System.Serializable]</AttributeName>
      <AttributeName Language="F#">[&lt;System.Serializable&gt;]</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="a3202-101">提供 Internet 协议 (IP) 地址。</span><span class="sxs-lookup"><span data-stu-id="a3202-101">Provides an Internet Protocol (IP) address.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a3202-102"><xref:System.Net.IPAddress>类包含 IP 网络上的计算机的地址。</span><span class="sxs-lookup"><span data-stu-id="a3202-102">The <xref:System.Net.IPAddress> class contains the address of a computer on an IP network.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a3202-103">下面的代码示例演示如何查询服务器以获取其所支持的系列地址和 IP 地址。</span><span class="sxs-lookup"><span data-stu-id="a3202-103">The following code example shows how to query a server to obtain the family addresses and the IP addresses it supports.</span></span>  
  
 [!code-cpp[System.Net.IPAddress#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.IPAddress/CPP/ipaddress.cpp#1)]
 [!code-csharp[System.Net.IPAddress#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.IPAddress/CS/ipaddress.cs#1)]
 [!code-vb[System.Net.IPAddress#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.IPAddress/VB/ipaddress.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="a3202-104">初始化 <see cref="T:System.Net.IPAddress" /> 类的新实例。</span><span class="sxs-lookup"><span data-stu-id="a3202-104">Initializes a new instance of the <see cref="T:System.Net.IPAddress" /> class.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public IPAddress (byte[] address);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(unsigned int8[] address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.IPAddress.#ctor(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (address As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IPAddress(cli::array &lt;System::Byte&gt; ^ address);" />
      <MemberSignature Language="F#" Value="new System.Net.IPAddress : byte[] -&gt; System.Net.IPAddress" Usage="new System.Net.IPAddress address" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="address" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="a3202-105">IP 地址的字节数组值。</span><span class="sxs-lookup"><span data-stu-id="a3202-105">The byte array value of the IP address.</span></span></param>
        <summary><span data-ttu-id="a3202-106">使用指定为 <see cref="T:System.Net.IPAddress" /> 数组的地址初始化 <see cref="T:System.Byte" /> 类的新实例。</span><span class="sxs-lookup"><span data-stu-id="a3202-106">Initializes a new instance of the <see cref="T:System.Net.IPAddress" /> class with the address specified as a <see cref="T:System.Byte" /> array.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a3202-107"><xref:System.Net.IPAddress>创建时， <xref:System.Net.IPAddress.Address%2A> 属性设置为 `address` 。</span><span class="sxs-lookup"><span data-stu-id="a3202-107">The <xref:System.Net.IPAddress> is created with the <xref:System.Net.IPAddress.Address%2A> property set to `address`.</span></span>  
  
 <span data-ttu-id="a3202-108">如果的长度 `address` 为4，则 <xref:System.Net.IPAddress.%23ctor%28System.Byte%5B%5D%29> 构造 IPv4 地址; 否则，将构造范围为0的 IPv6 地址。</span><span class="sxs-lookup"><span data-stu-id="a3202-108">If the length of `address` is 4, <xref:System.Net.IPAddress.%23ctor%28System.Byte%5B%5D%29> constructs an IPv4 address; otherwise, an IPv6 address with a scope of 0 is constructed.</span></span>  
  
 <span data-ttu-id="a3202-109"><xref:System.Byte>假定数组为网络字节顺序，最高有效字节优先于索引位置0。</span><span class="sxs-lookup"><span data-stu-id="a3202-109">The <xref:System.Byte> array is assumed to be in network byte order with the most significant byte first in index position 0.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="a3202-110"><paramref name="address" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="a3202-110"><paramref name="address" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="a3202-111"><paramref name="address" /> 包含错误的 IP 地址。</span><span class="sxs-lookup"><span data-stu-id="a3202-111"><paramref name="address" /> contains a bad IP address.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public IPAddress (long newAddress);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int64 newAddress) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.IPAddress.#ctor(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (newAddress As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IPAddress(long newAddress);" />
      <MemberSignature Language="F#" Value="new System.Net.IPAddress : int64 -&gt; System.Net.IPAddress" Usage="new System.Net.IPAddress newAddress" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="newAddress" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="newAddress"><span data-ttu-id="a3202-112">IP 地址的长值。</span><span class="sxs-lookup"><span data-stu-id="a3202-112">The long value of the IP address.</span></span> <span data-ttu-id="a3202-113">例如，大端格式的值 0x2414188f 可能为 IP 地址“143.24.20.36”。</span><span class="sxs-lookup"><span data-stu-id="a3202-113">For example, the value 0x2414188f in big-endian format would be the IP address "143.24.20.36".</span></span></param>
        <summary><span data-ttu-id="a3202-114">使用指定为 <see cref="T:System.Net.IPAddress" /> 的地址初始化 <see cref="T:System.Int64" /> 类的新实例。</span><span class="sxs-lookup"><span data-stu-id="a3202-114">Initializes a new instance of the <see cref="T:System.Net.IPAddress" /> class with the address specified as an <see cref="T:System.Int64" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a3202-115"><xref:System.Net.IPAddress>创建实例时， <xref:System.Net.IPAddress.Address%2A> 属性设置为 `newAddress` 。</span><span class="sxs-lookup"><span data-stu-id="a3202-115">The <xref:System.Net.IPAddress> instance is created with the <xref:System.Net.IPAddress.Address%2A> property set to `newAddress`.</span></span>  
  
 <span data-ttu-id="a3202-116"><xref:System.Int64>假定值为网络字节顺序。</span><span class="sxs-lookup"><span data-stu-id="a3202-116">The <xref:System.Int64> value is assumed to be in network byte order.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="a3202-117"><paramref name="newAddress" />&lt; 0 或</span><span class="sxs-lookup"><span data-stu-id="a3202-117"><paramref name="newAddress" /> &lt; 0 or</span></span> 
 <span data-ttu-id="a3202-118"><paramref name="newAddress" />&gt; 0x00000000FFFFFFFF</span><span class="sxs-lookup"><span data-stu-id="a3202-118"><paramref name="newAddress" /> &gt; 0x00000000FFFFFFFF</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public IPAddress (ReadOnlySpan&lt;byte&gt; address);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.IPAddress.#ctor(System.ReadOnlySpan{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (address As ReadOnlySpan(Of Byte))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IPAddress(ReadOnlySpan&lt;System::Byte&gt; address);" />
      <MemberSignature Language="F#" Value="new System.Net.IPAddress : ReadOnlySpan&lt;byte&gt; -&gt; System.Net.IPAddress" Usage="new System.Net.IPAddress address" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="address" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="a3202-119">按网络字节顺序表示 IP 地址的字节，其最高有效字节在索引位置 0 前面。</span><span class="sxs-lookup"><span data-stu-id="a3202-119">The byte representation of the IP address, in network byte order, with the most significant byte first in index position 0.</span></span></param>
        <summary><span data-ttu-id="a3202-120">使用指定为字节范围的地址初始化 <see cref="T:System.Net.IPAddress" /> 类的新实例。</span><span class="sxs-lookup"><span data-stu-id="a3202-120">Initializes a new instance of the <see cref="T:System.Net.IPAddress" /> class with the address specified as a byte span.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a3202-121"><xref:System.Net.IPAddress>创建时， <xref:System.Net.IPAddress.Address> 属性设置为 `address` 。</span><span class="sxs-lookup"><span data-stu-id="a3202-121">The <xref:System.Net.IPAddress> is created with the <xref:System.Net.IPAddress.Address> property set to `address`.</span></span>  
  
 <span data-ttu-id="a3202-122">如果的长度 `address` 为4，则此方法将构造一个 IPv4 地址; 否则，将构造范围为0的 IPv6 地址。</span><span class="sxs-lookup"><span data-stu-id="a3202-122">If the length of `address` is 4, this method constructs an IPv4 address; otherwise, an IPv6 address with a scope of 0 is constructed.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="a3202-123"><paramref name="address" /> 包含错误的 IP 地址。</span><span class="sxs-lookup"><span data-stu-id="a3202-123"><paramref name="address" /> contains a bad IP address.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public IPAddress (byte[] address, long scopeid);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(unsigned int8[] address, int64 scopeid) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.IPAddress.#ctor(System.Byte[],System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (address As Byte(), scopeid As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IPAddress(cli::array &lt;System::Byte&gt; ^ address, long scopeid);" />
      <MemberSignature Language="F#" Value="new System.Net.IPAddress : byte[] * int64 -&gt; System.Net.IPAddress" Usage="new System.Net.IPAddress (address, scopeid)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="address" Type="System.Byte[]" />
        <Parameter Name="scopeid" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="a3202-124">IP 地址的字节数组值。</span><span class="sxs-lookup"><span data-stu-id="a3202-124">The byte array value of the IP address.</span></span></param>
        <param name="scopeid"><span data-ttu-id="a3202-125">范围标识符的长值。</span><span class="sxs-lookup"><span data-stu-id="a3202-125">The long value of the scope identifier.</span></span></param>
        <summary><span data-ttu-id="a3202-126">使用指定为 <see cref="T:System.Net.IPAddress" /> 数组的地址和指定的范围标识符初始化 <see cref="T:System.Byte" /> 类的新实例。</span><span class="sxs-lookup"><span data-stu-id="a3202-126">Initializes a new instance of the <see cref="T:System.Net.IPAddress" /> class with the address specified as a <see cref="T:System.Byte" /> array and the specified scope identifier.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a3202-127">此构造函数实例化一个 IPv6 地址。</span><span class="sxs-lookup"><span data-stu-id="a3202-127">This constructor instantiates an IPv6 address.</span></span> <span data-ttu-id="a3202-128">`scopeid`如果是链接本地地址，则标识网络接口。</span><span class="sxs-lookup"><span data-stu-id="a3202-128">The `scopeid` identifies a network interface in the case of a link-local address.</span></span> <span data-ttu-id="a3202-129">作用域仅对本地和站点本地地址有效。</span><span class="sxs-lookup"><span data-stu-id="a3202-129">The scope is valid only for link-local and site-local addresses.</span></span>  
  
 <span data-ttu-id="a3202-130"><xref:System.Byte>假定数组为网络字节顺序，最高有效字节优先于索引位置0。</span><span class="sxs-lookup"><span data-stu-id="a3202-130">The <xref:System.Byte> array is assumed to be in network byte order with the most significant byte first in index position 0.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="a3202-131"><paramref name="address" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="a3202-131"><paramref name="address" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="a3202-132"><paramref name="address" /> 包含错误的 IP 地址。</span><span class="sxs-lookup"><span data-stu-id="a3202-132"><paramref name="address" /> contains a bad IP address.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="a3202-133"><paramref name="scopeid" />&lt; 0 或</span><span class="sxs-lookup"><span data-stu-id="a3202-133"><paramref name="scopeid" /> &lt; 0 or</span></span> 
 <span data-ttu-id="a3202-134"><paramref name="scopeid" />&gt; 0x00000000FFFFFFFF</span><span class="sxs-lookup"><span data-stu-id="a3202-134"><paramref name="scopeid" /> &gt; 0x00000000FFFFFFFF</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public IPAddress (ReadOnlySpan&lt;byte&gt; address, long scopeid);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; address, int64 scopeid) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.IPAddress.#ctor(System.ReadOnlySpan{System.Byte},System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (address As ReadOnlySpan(Of Byte), scopeid As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IPAddress(ReadOnlySpan&lt;System::Byte&gt; address, long scopeid);" />
      <MemberSignature Language="F#" Value="new System.Net.IPAddress : ReadOnlySpan&lt;byte&gt; * int64 -&gt; System.Net.IPAddress" Usage="new System.Net.IPAddress (address, scopeid)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="address" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="scopeid" Type="System.Int64" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="a3202-135">IP 地址的字节跨度值。</span><span class="sxs-lookup"><span data-stu-id="a3202-135">The byte span value of the IP address.</span></span></param>
        <param name="scopeid"><span data-ttu-id="a3202-136">范围标识符的长值。</span><span class="sxs-lookup"><span data-stu-id="a3202-136">The long value of the scope identifier.</span></span></param>
        <summary><span data-ttu-id="a3202-137">使用指定为字节范围的地址和指定的范围标识符初始化 <see cref="T:System.Net.IPAddress" /> 类的新实例。</span><span class="sxs-lookup"><span data-stu-id="a3202-137">Initializes a new instance of the <see cref="T:System.Net.IPAddress" /> class with the address specified as a byte span and the specified scope identifier.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a3202-138">此构造函数实例化一个 IPv6 地址。</span><span class="sxs-lookup"><span data-stu-id="a3202-138">This constructor instantiates an IPv6 address.</span></span> <span data-ttu-id="a3202-139">`scopeid`如果是链接本地地址，则标识网络接口。</span><span class="sxs-lookup"><span data-stu-id="a3202-139">The `scopeid` identifies a network interface in the case of a link-local address.</span></span> <span data-ttu-id="a3202-140">作用域仅对本地和站点本地地址有效。</span><span class="sxs-lookup"><span data-stu-id="a3202-140">The scope is valid only for link-local and site-local addresses.</span></span>  
  
 <span data-ttu-id="a3202-141">字节跨度假定为网络字节顺序，最高有效字节优先于索引位置0。</span><span class="sxs-lookup"><span data-stu-id="a3202-141">The byte span is assumed to be in network byte order with the most significant byte first in index position 0.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="a3202-142"><paramref name="address" /> 包含错误的 IP 地址。</span><span class="sxs-lookup"><span data-stu-id="a3202-142"><paramref name="address" /> contains a bad IP address.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="a3202-143"><paramref name="scopeid" /> &lt; 0</span><span class="sxs-lookup"><span data-stu-id="a3202-143"><paramref name="scopeid" /> &lt; 0</span></span>

<span data-ttu-id="a3202-144">- 或 -</span><span class="sxs-lookup"><span data-stu-id="a3202-144">-or-</span></span>

<span data-ttu-id="a3202-145"><paramref name="scopeid" />&gt; 0x00000000FFFFFFFF</span><span class="sxs-lookup"><span data-stu-id="a3202-145"><paramref name="scopeid" /> &gt; 0x00000000FFFFFFFF</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Address">
      <MemberSignature Language="C#" Value="public long Address { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Address" />
      <MemberSignature Language="DocId" Value="P:System.Net.IPAddress.Address" />
      <MemberSignature Language="VB.NET" Value="Public Property Address As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long Address { long get(); void set(long value); };" />
      <MemberSignature Language="F#" Value="member this.Address : int64 with get, set" Usage="System.Net.IPAddress.Address" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Obsolete("This property has been deprecated. It is address family dependent. Please use IPAddress.Equals method to perform comparisons. http://go.microsoft.com/fwlink/?linkid=14202")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Obsolete("This property has been deprecated. It is address family dependent. Please use IPAddress.Equals method to perform comparisons. http://go.microsoft.com/fwlink/?linkid=14202")&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netcore-3.1;netstandard-2.1">
          <AttributeName Language="C#">[System.Obsolete("This property has been deprecated. It is address family dependent. Please use IPAddress.Equals method to perform comparisons. https://go.microsoft.com/fwlink/?linkid=14202")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Obsolete("This property has been deprecated. It is address family dependent. Please use IPAddress.Equals method to perform comparisons. https://go.microsoft.com/fwlink/?linkid=14202")&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName Language="C#">[System.Obsolete("IPAddress.Address is address family dependant, use Equals method for comparison.")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Obsolete("IPAddress.Address is address family dependant, use Equals method for comparison.")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a3202-146">Internet 协议 (IP) 地址。</span><span class="sxs-lookup"><span data-stu-id="a3202-146">An Internet Protocol (IP) address.</span></span></summary>
        <value><span data-ttu-id="a3202-147">IP 地址的长值。</span><span class="sxs-lookup"><span data-stu-id="a3202-147">The long value of the IP address.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a3202-148">此属性已过时。</span><span class="sxs-lookup"><span data-stu-id="a3202-148">This property is obsolete.</span></span> <span data-ttu-id="a3202-149">请使用 <xref:System.Net.IPAddress.GetAddressBytes%2A>。</span><span class="sxs-lookup"><span data-stu-id="a3202-149">Use <xref:System.Net.IPAddress.GetAddressBytes%2A>.</span></span>  
  
 <span data-ttu-id="a3202-150">若要转换 <xref:System.Net.IPAddress.Address%2A> 为以点分隔的四部分表示法，请使用 <xref:System.Net.IPAddress.ToString%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="a3202-150">To convert <xref:System.Net.IPAddress.Address%2A> to dotted-quad notation, use the <xref:System.Net.IPAddress.ToString%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="a3202-151">该地址族为 <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" />。</span><span class="sxs-lookup"><span data-stu-id="a3202-151">The address family is <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="AddressFamily">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.AddressFamily AddressFamily { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Net.Sockets.AddressFamily AddressFamily" />
      <MemberSignature Language="DocId" Value="P:System.Net.IPAddress.AddressFamily" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AddressFamily As AddressFamily" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Sockets::AddressFamily AddressFamily { System::Net::Sockets::AddressFamily get(); };" />
      <MemberSignature Language="F#" Value="member this.AddressFamily : System.Net.Sockets.AddressFamily" Usage="System.Net.IPAddress.AddressFamily" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.AddressFamily</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a3202-152">获取 IP 地址的地址族。</span><span class="sxs-lookup"><span data-stu-id="a3202-152">Gets the address family of the IP address.</span></span></summary>
        <value><span data-ttu-id="a3202-153">对于 IPv4，返回 <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" />；对于 IPv6，返回 <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" />。</span><span class="sxs-lookup"><span data-stu-id="a3202-153">Returns <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> for IPv4 or <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> for IPv6.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="a3202-154">请参阅类主题中的示例 <xref:System.Net.IPAddress> 。</span><span class="sxs-lookup"><span data-stu-id="a3202-154">Refer to the example in the <xref:System.Net.IPAddress> class topic.</span></span>  
  
 [!code-cpp[System.Net.IPAddress#3](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.IPAddress/CPP/ipaddress.cpp#3)]
 [!code-csharp[System.Net.IPAddress#3](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.IPAddress/CS/ipaddress.cs#3)]
 [!code-vb[System.Net.IPAddress#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.IPAddress/VB/ipaddress.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Any">
      <MemberSignature Language="C#" Value="public static readonly System.Net.IPAddress Any;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Net.IPAddress Any" />
      <MemberSignature Language="DocId" Value="F:System.Net.IPAddress.Any" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Any As IPAddress " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Net::IPAddress ^ Any;" />
      <MemberSignature Language="F#" Value=" staticval mutable Any : System.Net.IPAddress" Usage="System.Net.IPAddress.Any" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.IPAddress</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a3202-155">提供一个 IP 地址，指示服务器必须侦听所有网络接口上的客户端活动。</span><span class="sxs-lookup"><span data-stu-id="a3202-155">Provides an IP address that indicates that the server must listen for client activity on all network interfaces.</span></span> <span data-ttu-id="a3202-156">此字段为只读。</span><span class="sxs-lookup"><span data-stu-id="a3202-156">This field is read-only.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a3202-157"><xref:System.Net.Sockets.Socket.Bind%2A?displayProperty=nameWithType>方法使用 <xref:System.Net.IPAddress.Any> 字段指示 <xref:System.Net.Sockets.Socket> 实例必须侦听所有网络接口上的客户端活动。</span><span class="sxs-lookup"><span data-stu-id="a3202-157">The <xref:System.Net.Sockets.Socket.Bind%2A?displayProperty=nameWithType> method uses the <xref:System.Net.IPAddress.Any> field to indicate that a <xref:System.Net.Sockets.Socket> instance must listen for client activity on all network interfaces.</span></span>  
  
 <span data-ttu-id="a3202-158">此 <xref:System.Net.IPAddress.Any> 字段等效于以点分隔的四部分表示法形式的0.0.0.0。</span><span class="sxs-lookup"><span data-stu-id="a3202-158">The <xref:System.Net.IPAddress.Any> field is equivalent to 0.0.0.0 in dotted-quad notation.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Broadcast">
      <MemberSignature Language="C#" Value="public static readonly System.Net.IPAddress Broadcast;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Net.IPAddress Broadcast" />
      <MemberSignature Language="DocId" Value="F:System.Net.IPAddress.Broadcast" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Broadcast As IPAddress " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Net::IPAddress ^ Broadcast;" />
      <MemberSignature Language="F#" Value=" staticval mutable Broadcast : System.Net.IPAddress" Usage="System.Net.IPAddress.Broadcast" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.IPAddress</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a3202-159">提供 IP 广播地址。</span><span class="sxs-lookup"><span data-stu-id="a3202-159">Provides the IP broadcast address.</span></span> <span data-ttu-id="a3202-160">此字段为只读。</span><span class="sxs-lookup"><span data-stu-id="a3202-160">This field is read-only.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a3202-161">此 <xref:System.Net.IPAddress.Broadcast> 字段等效于以点分隔的四部分表示法的255.255.255.255。</span><span class="sxs-lookup"><span data-stu-id="a3202-161">The <xref:System.Net.IPAddress.Broadcast> field is equivalent to 255.255.255.255 in dotted-quad notation.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a3202-162">下面的示例将 <xref:System.Net.IPAddress.Broadcast> 地址输出到控制台。</span><span class="sxs-lookup"><span data-stu-id="a3202-162">The following example prints the <xref:System.Net.IPAddress.Broadcast> address to the console.</span></span>  
  
 [!code-cpp[IPAddress_Broadcast_Loopback#2](~/samples/snippets/cpp/VS_Snippets_Remoting/IPAddress_Broadcast_Loopback/CPP/ipaddress_broadcast_loopback.cpp#2)]
 [!code-csharp[IPAddress_Broadcast_Loopback#2](~/samples/snippets/csharp/VS_Snippets_Remoting/IPAddress_Broadcast_Loopback/CS/ipaddress_broadcast_loopback.cs#2)]
 [!code-vb[IPAddress_Broadcast_Loopback#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/IPAddress_Broadcast_Loopback/VB/ipaddress_broadcast_loopback.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object comparand);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object comparand) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.IPAddress.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (comparand As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ comparand);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="iPAddress.Equals comparand" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="comparand" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="comparand"><span data-ttu-id="a3202-163">要与当前实例比较的 <see cref="T:System.Net.IPAddress" /> 实例。</span><span class="sxs-lookup"><span data-stu-id="a3202-163">An <see cref="T:System.Net.IPAddress" /> instance to compare to the current instance.</span></span></param>
        <summary><span data-ttu-id="a3202-164">比较两个 IP 地址。</span><span class="sxs-lookup"><span data-stu-id="a3202-164">Compares two IP addresses.</span></span></summary>
        <returns><span data-ttu-id="a3202-165">如果两个地址相等，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="a3202-165"><see langword="true" /> if the two addresses are equal; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a3202-166"><xref:System.Net.IPAddress.Equals%2A>方法将当前的 <xref:System.Net.IPAddress> 实例与参数进行比较 `comparand` ， `true` 如果两个实例包含相同的 IP 地址，则返回。</span><span class="sxs-lookup"><span data-stu-id="a3202-166">The <xref:System.Net.IPAddress.Equals%2A> method compares the current <xref:System.Net.IPAddress> instance with the `comparand` parameter and returns `true` if the two instances contain the same IP address.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetAddressBytes">
      <MemberSignature Language="C#" Value="public byte[] GetAddressBytes ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8[] GetAddressBytes() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.IPAddress.GetAddressBytes" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAddressBytes () As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Byte&gt; ^ GetAddressBytes();" />
      <MemberSignature Language="F#" Value="member this.GetAddressBytes : unit -&gt; byte[]" Usage="iPAddress.GetAddressBytes " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="a3202-167">以字节数组形式提供 <see cref="T:System.Net.IPAddress" /> 的副本。</span><span class="sxs-lookup"><span data-stu-id="a3202-167">Provides a copy of the <see cref="T:System.Net.IPAddress" /> as an array of bytes.</span></span></summary>
        <returns><span data-ttu-id="a3202-168"><see cref="T:System.Byte" /> 数组。</span><span class="sxs-lookup"><span data-stu-id="a3202-168">A <see cref="T:System.Byte" /> array.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="a3202-169">下面的代码示例演示如何以字节格式获取服务器 IP 地址。</span><span class="sxs-lookup"><span data-stu-id="a3202-169">The following code example shows how to get a server IP address in byte format.</span></span>  
  
 [!code-cpp[System.Net.IPAddress#2](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.IPAddress/CPP/ipaddress.cpp#2)]
 [!code-csharp[System.Net.IPAddress#2](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.IPAddress/CS/ipaddress.cs#2)]
 [!code-vb[System.Net.IPAddress#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.IPAddress/VB/ipaddress.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.IPAddress.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="iPAddress.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="a3202-170">返回 IP 地址的哈希值。</span><span class="sxs-lookup"><span data-stu-id="a3202-170">Returns a hash value for an IP address.</span></span></summary>
        <returns><span data-ttu-id="a3202-171">整数哈希值。</span><span class="sxs-lookup"><span data-stu-id="a3202-171">An integer hash value.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a3202-172"><xref:System.Net.IPAddress.GetHashCode%2A>方法返回 IP 地址的哈希代码。</span><span class="sxs-lookup"><span data-stu-id="a3202-172">The <xref:System.Net.IPAddress.GetHashCode%2A> method returns a hash code of the IP address.</span></span> <span data-ttu-id="a3202-173">此值可用作哈希表中的键。</span><span class="sxs-lookup"><span data-stu-id="a3202-173">This value can be used as a key in hash tables.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="HostToNetworkOrder">
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="a3202-174">将值由主机字节顺序转换为网络字节顺序。</span><span class="sxs-lookup"><span data-stu-id="a3202-174">Converts a value from host byte order to network byte order.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="HostToNetworkOrder">
      <MemberSignature Language="C#" Value="public static short HostToNetworkOrder (short host);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int16 HostToNetworkOrder(int16 host) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.IPAddress.HostToNetworkOrder(System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function HostToNetworkOrder (host As Short) As Short" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static short HostToNetworkOrder(short host);" />
      <MemberSignature Language="F#" Value="static member HostToNetworkOrder : int16 -&gt; int16" Usage="System.Net.IPAddress.HostToNetworkOrder host" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="host" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="host"><span data-ttu-id="a3202-175">以主机字节顺序表示的要转换的数字。</span><span class="sxs-lookup"><span data-stu-id="a3202-175">The number to convert, expressed in host byte order.</span></span></param>
        <summary><span data-ttu-id="a3202-176">将短值由主机字节顺序转换为网络字节顺序。</span><span class="sxs-lookup"><span data-stu-id="a3202-176">Converts a short value from host byte order to network byte order.</span></span></summary>
        <returns><span data-ttu-id="a3202-177">以网络字节顺序表示的短值。</span><span class="sxs-lookup"><span data-stu-id="a3202-177">A short value, expressed in network byte order.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a3202-178">不同的计算机使用不同的约定对多字节整数值中的字节进行排序。</span><span class="sxs-lookup"><span data-stu-id="a3202-178">Different computers use different conventions for ordering the bytes within multibyte integer values.</span></span> <span data-ttu-id="a3202-179">某些计算机先将最重要的字节 (称为大字节序顺序) ，其他计算机会首先 (称为小字节序顺序) 的最小有效字节。</span><span class="sxs-lookup"><span data-stu-id="a3202-179">Some computers put the most significant byte first (known as big-endian order) and others put the least-significant byte first (known as little-endian order).</span></span> <span data-ttu-id="a3202-180">若要处理使用不同字节排序的计算机，则通过网络发送的所有整数值都以网络字节顺序发送，该顺序首先具有最重要的字节。</span><span class="sxs-lookup"><span data-stu-id="a3202-180">To work with computers that use different byte ordering, all integer values that are sent over the network are sent in network byte order which has the most significant byte first.</span></span>  
  
 <span data-ttu-id="a3202-181"><xref:System.Net.IPAddress.HostToNetworkOrder%2A>方法将主机系统上存储的多字节整数值从主机使用的字节顺序转换为网络使用的字节顺序。</span><span class="sxs-lookup"><span data-stu-id="a3202-181">The <xref:System.Net.IPAddress.HostToNetworkOrder%2A> method converts multibyte integer values that are stored on the host system from the byte order used by the host to the byte order used by the network.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Net.IPAddress.NetworkToHostOrder(System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="HostToNetworkOrder">
      <MemberSignature Language="C#" Value="public static int HostToNetworkOrder (int host);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 HostToNetworkOrder(int32 host) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.IPAddress.HostToNetworkOrder(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function HostToNetworkOrder (host As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int HostToNetworkOrder(int host);" />
      <MemberSignature Language="F#" Value="static member HostToNetworkOrder : int -&gt; int" Usage="System.Net.IPAddress.HostToNetworkOrder host" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="host" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="host"><span data-ttu-id="a3202-182">以主机字节顺序表示的要转换的数字。</span><span class="sxs-lookup"><span data-stu-id="a3202-182">The number to convert, expressed in host byte order.</span></span></param>
        <summary><span data-ttu-id="a3202-183">将整数值由主机字节顺序转换为网络字节顺序。</span><span class="sxs-lookup"><span data-stu-id="a3202-183">Converts an integer value from host byte order to network byte order.</span></span></summary>
        <returns><span data-ttu-id="a3202-184">以网络字节顺序表示的整数值。</span><span class="sxs-lookup"><span data-stu-id="a3202-184">An integer value, expressed in network byte order.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a3202-185">不同的计算机使用不同的约定对多字节整数值中的字节进行排序。</span><span class="sxs-lookup"><span data-stu-id="a3202-185">Different computers use different conventions for ordering the bytes within multibyte integer values.</span></span> <span data-ttu-id="a3202-186">某些计算机先将最重要的字节 (称为大字节序顺序) ，其他计算机会首先 (称为小字节序顺序) 的最小有效字节。</span><span class="sxs-lookup"><span data-stu-id="a3202-186">Some computers put the most significant byte first (known as big-endian order) and others put the least-significant byte first (known as little-endian order).</span></span> <span data-ttu-id="a3202-187">若要处理使用不同字节排序的计算机，则通过网络发送的所有整数值都以网络字节顺序发送，该顺序首先具有最重要的字节。</span><span class="sxs-lookup"><span data-stu-id="a3202-187">To work with computers that use different byte ordering, all integer values that are sent over the network are sent in network byte order which has the most significant byte first.</span></span>  
  
 <span data-ttu-id="a3202-188"><xref:System.Net.IPAddress.HostToNetworkOrder%2A>方法将主机系统上存储的多字节整数值从主机使用的字节顺序转换为网络使用的字节顺序。</span><span class="sxs-lookup"><span data-stu-id="a3202-188">The <xref:System.Net.IPAddress.HostToNetworkOrder%2A> method converts multibyte integer values that are stored on the host system from the byte order used by the host to the byte order used by the network.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Net.IPAddress.NetworkToHostOrder(System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="HostToNetworkOrder">
      <MemberSignature Language="C#" Value="public static long HostToNetworkOrder (long host);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 HostToNetworkOrder(int64 host) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.IPAddress.HostToNetworkOrder(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function HostToNetworkOrder (host As Long) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long HostToNetworkOrder(long host);" />
      <MemberSignature Language="F#" Value="static member HostToNetworkOrder : int64 -&gt; int64" Usage="System.Net.IPAddress.HostToNetworkOrder host" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="host" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="host"><span data-ttu-id="a3202-189">以主机字节顺序表示的要转换的数字。</span><span class="sxs-lookup"><span data-stu-id="a3202-189">The number to convert, expressed in host byte order.</span></span></param>
        <summary><span data-ttu-id="a3202-190">将长值由主机字节顺序转换为网络字节顺序。</span><span class="sxs-lookup"><span data-stu-id="a3202-190">Converts a long value from host byte order to network byte order.</span></span></summary>
        <returns><span data-ttu-id="a3202-191">以网络字节顺序表示的长值。</span><span class="sxs-lookup"><span data-stu-id="a3202-191">A long value, expressed in network byte order.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a3202-192">不同的计算机使用不同的约定对多字节整数值中的字节进行排序。</span><span class="sxs-lookup"><span data-stu-id="a3202-192">Different computers use different conventions for ordering the bytes within multibyte integer values.</span></span> <span data-ttu-id="a3202-193">某些计算机先将最重要的字节 (称为大字节序顺序) ，其他计算机会首先 (称为小字节序顺序) 的最小有效字节。</span><span class="sxs-lookup"><span data-stu-id="a3202-193">Some computers put the most significant byte first (known as big-endian order) and others put the least-significant byte first (known as little-endian order).</span></span> <span data-ttu-id="a3202-194">若要处理使用不同字节排序的计算机，则通过网络发送的所有整数值都以网络字节顺序发送，该顺序首先具有最重要的字节。</span><span class="sxs-lookup"><span data-stu-id="a3202-194">To work with computers that use different byte ordering, all integer values that are sent over the network are sent in network byte order which has the most significant byte first.</span></span>  
  
 <span data-ttu-id="a3202-195"><xref:System.Net.IPAddress.HostToNetworkOrder%2A>方法将主机系统上存储的多字节整数值从主机使用的字节顺序转换为网络使用的字节顺序。</span><span class="sxs-lookup"><span data-stu-id="a3202-195">The <xref:System.Net.IPAddress.HostToNetworkOrder%2A> method converts multibyte integer values that are stored on the host system from the byte order used by the host to the byte order used by the network.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Net.IPAddress.NetworkToHostOrder(System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="IPv6Any">
      <MemberSignature Language="C#" Value="public static readonly System.Net.IPAddress IPv6Any;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Net.IPAddress IPv6Any" />
      <MemberSignature Language="DocId" Value="F:System.Net.IPAddress.IPv6Any" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IPv6Any As IPAddress " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Net::IPAddress ^ IPv6Any;" />
      <MemberSignature Language="F#" Value=" staticval mutable IPv6Any : System.Net.IPAddress" Usage="System.Net.IPAddress.IPv6Any" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.IPAddress</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a3202-196"><see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> 方法使用 <see cref="F:System.Net.IPAddress.IPv6Any" /> 字段指示 <see cref="T:System.Net.Sockets.Socket" /> 必须侦听所有网络接口上的客户端活动。</span><span class="sxs-lookup"><span data-stu-id="a3202-196">The <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> method uses the <see cref="F:System.Net.IPAddress.IPv6Any" /> field to indicate that a <see cref="T:System.Net.Sockets.Socket" /> must listen for client activity on all network interfaces.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a3202-197">此 <xref:System.Net.IPAddress.IPv6Any> 字段等效于冒号十六进制表示法中的0:0:0:0:0:0:0:0，或与：： in compact 表示法等效。</span><span class="sxs-lookup"><span data-stu-id="a3202-197">The <xref:System.Net.IPAddress.IPv6Any> field is equivalent to 0:0:0:0:0:0:0:0 in colon-hexadecimal notation, or to :: in compact notation.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a3202-198">下面的代码示例以标准压缩格式显示当前主机的任何地址的值。</span><span class="sxs-lookup"><span data-stu-id="a3202-198">The following code example displays the value of the current host's Any address in standard compressed format.</span></span>  
  
 [!code-cpp[System.Net.IPAddress.IPv6NoneAnyLoopback#2](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.IPAddress.IPv6NoneAnyLoopback/CPP/noneanyloopback.cpp#2)]
 [!code-csharp[System.Net.IPAddress.IPv6NoneAnyLoopback#2](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.IPAddress.IPv6NoneAnyLoopback/CS/noneanyloopback.cs#2)]
 [!code-vb[System.Net.IPAddress.IPv6NoneAnyLoopback#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.IPAddress.IPv6NoneAnyLoopback/VB/noneanyloopback.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IPv6Loopback">
      <MemberSignature Language="C#" Value="public static readonly System.Net.IPAddress IPv6Loopback;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Net.IPAddress IPv6Loopback" />
      <MemberSignature Language="DocId" Value="F:System.Net.IPAddress.IPv6Loopback" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IPv6Loopback As IPAddress " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Net::IPAddress ^ IPv6Loopback;" />
      <MemberSignature Language="F#" Value=" staticval mutable IPv6Loopback : System.Net.IPAddress" Usage="System.Net.IPAddress.IPv6Loopback" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.IPAddress</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a3202-199">提供 IP 环回地址。</span><span class="sxs-lookup"><span data-stu-id="a3202-199">Provides the IP loopback address.</span></span> <span data-ttu-id="a3202-200">此属性是只读的。</span><span class="sxs-lookup"><span data-stu-id="a3202-200">This property is read-only.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a3202-201">此 <xref:System.Net.IPAddress.IPv6Loopback> 字段等效于冒号十六进制表示法中的0:0:0:0:0:0:0:1，或等于：：1，采用精简表示法。</span><span class="sxs-lookup"><span data-stu-id="a3202-201">The <xref:System.Net.IPAddress.IPv6Loopback> field is equivalent to 0:0:0:0:0:0:0:1 in colon-hexadecimal notation, or to ::1 in compact notation.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a3202-202">下面的代码示例以标准压缩格式显示当前主机的环回地址的值。</span><span class="sxs-lookup"><span data-stu-id="a3202-202">The following code example displays the value of the current host's loopback address in standard compressed format.</span></span>  
  
 [!code-cpp[System.Net.IPAddress.IPv6NoneAnyLoopback#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.IPAddress.IPv6NoneAnyLoopback/CPP/noneanyloopback.cpp#1)]
 [!code-csharp[System.Net.IPAddress.IPv6NoneAnyLoopback#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.IPAddress.IPv6NoneAnyLoopback/CS/noneanyloopback.cs#1)]
 [!code-vb[System.Net.IPAddress.IPv6NoneAnyLoopback#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.IPAddress.IPv6NoneAnyLoopback/VB/noneanyloopback.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IPv6None">
      <MemberSignature Language="C#" Value="public static readonly System.Net.IPAddress IPv6None;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Net.IPAddress IPv6None" />
      <MemberSignature Language="DocId" Value="F:System.Net.IPAddress.IPv6None" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IPv6None As IPAddress " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Net::IPAddress ^ IPv6None;" />
      <MemberSignature Language="F#" Value=" staticval mutable IPv6None : System.Net.IPAddress" Usage="System.Net.IPAddress.IPv6None" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.IPAddress</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a3202-203">提供指示不应使用任何网络接口的 IP 地址。</span><span class="sxs-lookup"><span data-stu-id="a3202-203">Provides an IP address that indicates that no network interface should be used.</span></span> <span data-ttu-id="a3202-204">此属性是只读的。</span><span class="sxs-lookup"><span data-stu-id="a3202-204">This property is read-only.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a3202-205"><xref:System.Net.Sockets.Socket.Bind%2A?displayProperty=nameWithType>方法使用 <xref:System.Net.IPAddress.IPv6None> 字段指示 <xref:System.Net.Sockets.Socket> 不得侦听客户端活动。</span><span class="sxs-lookup"><span data-stu-id="a3202-205">The <xref:System.Net.Sockets.Socket.Bind%2A?displayProperty=nameWithType> method uses the <xref:System.Net.IPAddress.IPv6None> field to indicate that a <xref:System.Net.Sockets.Socket> must not listen for client activity.</span></span> <span data-ttu-id="a3202-206">此 <xref:System.Net.IPAddress.IPv6None> 字段等效于冒号十六进制表示法中的0:0:0:0:0:0:0:0 或 to：：0采用精简表示法。</span><span class="sxs-lookup"><span data-stu-id="a3202-206">The <xref:System.Net.IPAddress.IPv6None> field is equivalent to 0:0:0:0:0:0:0:0 in colon-hexadecimal notation, or to ::0 in compact notation.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a3202-207">下面的代码示例以标准压缩格式显示当前主机的 None 地址的值。</span><span class="sxs-lookup"><span data-stu-id="a3202-207">The following code example displays the value of the current host's None address in standard compressed format.</span></span>  
  
 [!code-cpp[System.Net.IPAddress.IPv6NoneAnyLoopback#3](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.IPAddress.IPv6NoneAnyLoopback/CPP/noneanyloopback.cpp#3)]
 [!code-csharp[System.Net.IPAddress.IPv6NoneAnyLoopback#3](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.IPAddress.IPv6NoneAnyLoopback/CS/noneanyloopback.cs#3)]
 [!code-vb[System.Net.IPAddress.IPv6NoneAnyLoopback#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.IPAddress.IPv6NoneAnyLoopback/VB/noneanyloopback.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsIPv4MappedToIPv6">
      <MemberSignature Language="C#" Value="public bool IsIPv4MappedToIPv6 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsIPv4MappedToIPv6" />
      <MemberSignature Language="DocId" Value="P:System.Net.IPAddress.IsIPv4MappedToIPv6" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsIPv4MappedToIPv6 As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsIPv4MappedToIPv6 { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsIPv4MappedToIPv6 : bool" Usage="System.Net.IPAddress.IsIPv4MappedToIPv6" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a3202-208">了解 IP 地址是否为 IPv4 映射的 IPv6 地址。</span><span class="sxs-lookup"><span data-stu-id="a3202-208">Gets whether the IP address is an IPv4-mapped IPv6 address.</span></span></summary>
        <value><span data-ttu-id="a3202-209">返回 <see cref="T:System.Boolean" />。</span><span class="sxs-lookup"><span data-stu-id="a3202-209">Returns <see cref="T:System.Boolean" />.</span></span>  
  
 <span data-ttu-id="a3202-210">如果 IP 地址为 IPv4 映射的 IPv6 地址，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="a3202-210"><see langword="true" /> if the IP address is an IPv4-mapped IPv6 address; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a3202-211">双堆栈套接字始终需要 IPv6 地址。</span><span class="sxs-lookup"><span data-stu-id="a3202-211">Dual-stack sockets always require IPv6 addresses.</span></span> <span data-ttu-id="a3202-212">与 IPv4 地址进行交互的功能需要使用 IPv4 映射的 IPv6 地址格式。</span><span class="sxs-lookup"><span data-stu-id="a3202-212">The ability to interact with an IPv4 address requires the use of the IPv4-mapped IPv6 address format.</span></span> <span data-ttu-id="a3202-213">所有 IPv4 地址必须以 IPv4 映射的 IPv6 地址格式表示，这使得仅支持 IPv6 的应用程序能够与 IPv4 节点通信。</span><span class="sxs-lookup"><span data-stu-id="a3202-213">Any IPv4 addresses must be represented in the IPv4-mapped IPv6 address format which enables an IPv6 only application to communicate with an IPv4 node.</span></span> <span data-ttu-id="a3202-214">IPv4 映射的 IPv6 地址格式允许 IPv4 节点的 IPv4 地址表示为 IPv6 地址。</span><span class="sxs-lookup"><span data-stu-id="a3202-214">The IPv4-mapped IPv6 address format allows the IPv4 address of an IPv4 node to be represented as an IPv6 address.</span></span> <span data-ttu-id="a3202-215">IPv4 地址编码为 IPv6 地址的低序位32位，高序位96位保存固定前缀0：0：0：0：0： FFFF。</span><span class="sxs-lookup"><span data-stu-id="a3202-215">The IPv4 address is encoded into the low-order 32 bits of the IPv6 address, and the high-order 96 bits hold the fixed prefix 0:0:0:0:0:FFFF.</span></span> <span data-ttu-id="a3202-216">在 RFC 4291 中指定了 IPv4 映射的 IPv6 地址格式。</span><span class="sxs-lookup"><span data-stu-id="a3202-216">The IPv4-mapped IPv6 address format is specified in RFC 4291.</span></span> <span data-ttu-id="a3202-217">有关详细信息，请参阅 [www.ietf.org/rfc/rfc4291.txt](https://go.microsoft.com/fwlink/?LinkID=92231)。</span><span class="sxs-lookup"><span data-stu-id="a3202-217">For more information, see [www.ietf.org/rfc/rfc4291.txt](https://go.microsoft.com/fwlink/?LinkID=92231).</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsIPv6LinkLocal">
      <MemberSignature Language="C#" Value="public bool IsIPv6LinkLocal { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsIPv6LinkLocal" />
      <MemberSignature Language="DocId" Value="P:System.Net.IPAddress.IsIPv6LinkLocal" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsIPv6LinkLocal As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsIPv6LinkLocal { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsIPv6LinkLocal : bool" Usage="System.Net.IPAddress.IsIPv6LinkLocal" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a3202-218">了解地址是否为 IPv6 链路本地地址。</span><span class="sxs-lookup"><span data-stu-id="a3202-218">Gets whether the address is an IPv6 link local address.</span></span></summary>
        <value><span data-ttu-id="a3202-219">如果 IP 地址为 IPv6 链接本地地址，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="a3202-219"><see langword="true" /> if the IP address is an IPv6 link local address; otherwise, <see langword="false" />.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsIPv6Multicast">
      <MemberSignature Language="C#" Value="public bool IsIPv6Multicast { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsIPv6Multicast" />
      <MemberSignature Language="DocId" Value="P:System.Net.IPAddress.IsIPv6Multicast" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsIPv6Multicast As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsIPv6Multicast { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsIPv6Multicast : bool" Usage="System.Net.IPAddress.IsIPv6Multicast" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a3202-220">了解地址是否为 IPv6 多播全局地址。</span><span class="sxs-lookup"><span data-stu-id="a3202-220">Gets whether the address is an IPv6 multicast global address.</span></span></summary>
        <value><span data-ttu-id="a3202-221">如果 IP 地址为 IPv6 多路广播全局地址，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="a3202-221"><see langword="true" /> if the IP address is an IPv6 multicast global address; otherwise, <see langword="false" />.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsIPv6SiteLocal">
      <MemberSignature Language="C#" Value="public bool IsIPv6SiteLocal { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsIPv6SiteLocal" />
      <MemberSignature Language="DocId" Value="P:System.Net.IPAddress.IsIPv6SiteLocal" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsIPv6SiteLocal As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsIPv6SiteLocal { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsIPv6SiteLocal : bool" Usage="System.Net.IPAddress.IsIPv6SiteLocal" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a3202-222">了解地址是否为 IPv6 站点本地地址。</span><span class="sxs-lookup"><span data-stu-id="a3202-222">Gets whether the address is an IPv6 site local address.</span></span></summary>
        <value><span data-ttu-id="a3202-223">如果 IP 地址为 IPv6 站点本地地址，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="a3202-223"><see langword="true" /> if the IP address is an IPv6 site local address; otherwise, <see langword="false" />.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsIPv6Teredo">
      <MemberSignature Language="C#" Value="public bool IsIPv6Teredo { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsIPv6Teredo" />
      <MemberSignature Language="DocId" Value="P:System.Net.IPAddress.IsIPv6Teredo" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsIPv6Teredo As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsIPv6Teredo { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsIPv6Teredo : bool" Usage="System.Net.IPAddress.IsIPv6Teredo" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a3202-224">了解地址是否为 IPv6 Teredo 地址。</span><span class="sxs-lookup"><span data-stu-id="a3202-224">Gets whether the address is an IPv6 Teredo address.</span></span></summary>
        <value><span data-ttu-id="a3202-225">如果 IP 地址为 IPv6 Teredo 地址，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="a3202-225"><see langword="true" /> if the IP address is an IPv6 Teredo address; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a3202-226">Teredo 地址是前缀为2001::/32 的 IPv6 地址。</span><span class="sxs-lookup"><span data-stu-id="a3202-226">A Teredo address is an IPv6 address with the prefix of 2001::/32.</span></span> <span data-ttu-id="a3202-227">可以通过正常的 DNS 名称解析来返回 Teredo 地址，或将其枚举为分配给本地接口的 IPv6 地址。</span><span class="sxs-lookup"><span data-stu-id="a3202-227">Teredo addresses can be returned through normal DNS name resolution or enumerated as an IPv6 address assigned to a local interface.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Net.NetworkInformation.IPGlobalProperties.BeginGetUnicastAddresses(System.AsyncCallback,System.Object)" />
        <altmember cref="M:System.Net.NetworkInformation.IPGlobalProperties.EndGetUnicastAddresses(System.IAsyncResult)" />
        <altmember cref="M:System.Net.NetworkInformation.IPGlobalProperties.GetUnicastAddresses" />
        <altmember cref="T:System.Net.Sockets.IPProtectionLevel" />
        <altmember cref="M:System.Net.Sockets.Socket.SetIPProtectionLevel(System.Net.Sockets.IPProtectionLevel)" />
        <altmember cref="M:System.Net.Sockets.TcpListener.AllowNatTraversal(System.Boolean)" />
        <altmember cref="M:System.Net.Sockets.UdpClient.AllowNatTraversal(System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="IsLoopback">
      <MemberSignature Language="C#" Value="public static bool IsLoopback (System.Net.IPAddress address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsLoopback(class System.Net.IPAddress address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.IPAddress.IsLoopback(System.Net.IPAddress)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsLoopback (address As IPAddress) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsLoopback(System::Net::IPAddress ^ address);" />
      <MemberSignature Language="F#" Value="static member IsLoopback : System.Net.IPAddress -&gt; bool" Usage="System.Net.IPAddress.IsLoopback address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Net.IPAddress" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="a3202-228">IP 地址。</span><span class="sxs-lookup"><span data-stu-id="a3202-228">An IP address.</span></span></param>
        <summary><span data-ttu-id="a3202-229">指示指定的 IP 地址是否为环回地址。</span><span class="sxs-lookup"><span data-stu-id="a3202-229">Indicates whether the specified IP address is the loopback address.</span></span></summary>
        <returns><span data-ttu-id="a3202-230">如果 <paramref name="address" /> 是环回地址，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="a3202-230"><see langword="true" /> if <paramref name="address" /> is the loopback address; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a3202-231"><xref:System.Net.IPAddress.IsLoopback%2A> `address` <xref:System.Net.IPAddress.Loopback> `true` 如果两个 IP 地址相同，则方法会比较并返回。</span><span class="sxs-lookup"><span data-stu-id="a3202-231">The <xref:System.Net.IPAddress.IsLoopback%2A> method compares `address` to <xref:System.Net.IPAddress.Loopback> and returns `true` if the two IP addresses are the same.</span></span>  
  
 <span data-ttu-id="a3202-232">对于 IPv4，此 <xref:System.Net.IPAddress.IsLoopback%2A> 方法返回的 `true` 任何 IP 地址的格式为 127. X. (z，其中 X、Y 和 z 的范围为 0-255) ，而不只是 <xref:System.Net.IPAddress.Loopback> (127.0.0.1) 。</span><span class="sxs-lookup"><span data-stu-id="a3202-232">In the case of IPv4, that the <xref:System.Net.IPAddress.IsLoopback%2A> method returns `true` for any IP address of the form 127.X.Y.Z (where X, Y, and Z are in the range 0-255), not just <xref:System.Net.IPAddress.Loopback> (127.0.0.1).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a3202-233">下面的代码示例使用 <xref:System.Net.IPAddress.IsLoopback%2A> 方法来确定指定的地址是否为环回地址。</span><span class="sxs-lookup"><span data-stu-id="a3202-233">The following code example uses the <xref:System.Net.IPAddress.IsLoopback%2A> method to determine whether the specified address is a loopback address.</span></span>  
  
 [!code-cpp[System.Net.IPAddress.IsLoopback#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.IPAddress.IsLoopback/CPP/isloopback.cpp#1)]
 [!code-csharp[System.Net.IPAddress.IsLoopback#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.IPAddress.IsLoopback/CS/isloopback.cs#1)]
 [!code-vb[System.Net.IPAddress.IsLoopback#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.IPAddress.IsLoopback/VB/isloopback.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Loopback">
      <MemberSignature Language="C#" Value="public static readonly System.Net.IPAddress Loopback;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Net.IPAddress Loopback" />
      <MemberSignature Language="DocId" Value="F:System.Net.IPAddress.Loopback" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Loopback As IPAddress " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Net::IPAddress ^ Loopback;" />
      <MemberSignature Language="F#" Value=" staticval mutable Loopback : System.Net.IPAddress" Usage="System.Net.IPAddress.Loopback" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.IPAddress</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a3202-234">提供 IP 环回地址。</span><span class="sxs-lookup"><span data-stu-id="a3202-234">Provides the IP loopback address.</span></span> <span data-ttu-id="a3202-235">此字段为只读。</span><span class="sxs-lookup"><span data-stu-id="a3202-235">This field is read-only.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a3202-236">此 <xref:System.Net.IPAddress.Loopback> 字段等效于以点分隔的四部分表示法中的127.0.0.1。</span><span class="sxs-lookup"><span data-stu-id="a3202-236">The <xref:System.Net.IPAddress.Loopback> field is equivalent to 127.0.0.1 in dotted-quad notation.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a3202-237">下面的示例将 <xref:System.Net.IPAddress.Loopback> 地址输出到控制台。</span><span class="sxs-lookup"><span data-stu-id="a3202-237">The following example prints the <xref:System.Net.IPAddress.Loopback> address to the console.</span></span>  
  
 [!code-cpp[IPAddress_Broadcast_Loopback#1](~/samples/snippets/cpp/VS_Snippets_Remoting/IPAddress_Broadcast_Loopback/CPP/ipaddress_broadcast_loopback.cpp#1)]
 [!code-csharp[IPAddress_Broadcast_Loopback#1](~/samples/snippets/csharp/VS_Snippets_Remoting/IPAddress_Broadcast_Loopback/CS/ipaddress_broadcast_loopback.cs#1)]
 [!code-vb[IPAddress_Broadcast_Loopback#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/IPAddress_Broadcast_Loopback/VB/ipaddress_broadcast_loopback.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MapToIPv4">
      <MemberSignature Language="C#" Value="public System.Net.IPAddress MapToIPv4 ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.IPAddress MapToIPv4() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.IPAddress.MapToIPv4" />
      <MemberSignature Language="VB.NET" Value="Public Function MapToIPv4 () As IPAddress" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::IPAddress ^ MapToIPv4();" />
      <MemberSignature Language="F#" Value="member this.MapToIPv4 : unit -&gt; System.Net.IPAddress" Usage="iPAddress.MapToIPv4 " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.IPAddress</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="a3202-238">将 <see cref="T:System.Net.IPAddress" /> 对象映射到 IPv4 地址。</span><span class="sxs-lookup"><span data-stu-id="a3202-238">Maps the <see cref="T:System.Net.IPAddress" /> object to an IPv4 address.</span></span></summary>
        <returns><span data-ttu-id="a3202-239">返回 <see cref="T:System.Net.IPAddress" />。</span><span class="sxs-lookup"><span data-stu-id="a3202-239">Returns <see cref="T:System.Net.IPAddress" />.</span></span>  
  
<span data-ttu-id="a3202-240">IPv4 地址。</span><span class="sxs-lookup"><span data-stu-id="a3202-240">An IPv4 address.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a3202-241">双堆栈套接字始终需要 IPv6 地址。</span><span class="sxs-lookup"><span data-stu-id="a3202-241">Dual-stack sockets always require IPv6 addresses.</span></span> <span data-ttu-id="a3202-242">与 IPv4 地址进行交互的功能需要使用 IPv4 映射的 IPv6 地址格式。</span><span class="sxs-lookup"><span data-stu-id="a3202-242">The ability to interact with an IPv4 address requires the use of the IPv4-mapped IPv6 address format.</span></span> <span data-ttu-id="a3202-243">所有 IPv4 地址必须以 IPv4 映射的 IPv6 地址格式表示，这使得仅支持 IPv6 的应用程序能够与 IPv4 节点通信。</span><span class="sxs-lookup"><span data-stu-id="a3202-243">Any IPv4 addresses must be represented in the IPv4-mapped IPv6 address format which enables an IPv6 only application to communicate with an IPv4 node.</span></span> <span data-ttu-id="a3202-244">IPv4 映射的 IPv6 地址格式允许 IPv4 节点的 IPv4 地址表示为 IPv6 地址。</span><span class="sxs-lookup"><span data-stu-id="a3202-244">The IPv4-mapped IPv6 address format allows the IPv4 address of an IPv4 node to be represented as an IPv6 address.</span></span> <span data-ttu-id="a3202-245">IPv4 地址编码为 IPv6 地址的低序位32位，高序位96位保存固定前缀0：0：0：0：0： FFFF。</span><span class="sxs-lookup"><span data-stu-id="a3202-245">The IPv4 address is encoded into the low-order 32 bits of the IPv6 address, and the high-order 96 bits hold the fixed prefix 0:0:0:0:0:FFFF.</span></span> <span data-ttu-id="a3202-246">在 RFC 4291 中指定了 IPv4 映射的 IPv6 地址格式。</span><span class="sxs-lookup"><span data-stu-id="a3202-246">The IPv4-mapped IPv6 address format is specified in RFC 4291.</span></span> <span data-ttu-id="a3202-247">有关详细信息，请参阅 [www.ietf.org/rfc/rfc4291.txt](https://go.microsoft.com/fwlink/?LinkID=92231)。</span><span class="sxs-lookup"><span data-stu-id="a3202-247">For more information, see [www.ietf.org/rfc/rfc4291.txt](https://go.microsoft.com/fwlink/?LinkID=92231).</span></span>  
  
 <span data-ttu-id="a3202-248">如果要使用 <xref:System.Net.IPAddress.MapToIPv4%2A> 将 ipv4 地址从 IPv6 格式转换为 ipv4 格式，则必须首先确保已获得 ipv4 地址。</span><span class="sxs-lookup"><span data-stu-id="a3202-248">If you want to use <xref:System.Net.IPAddress.MapToIPv4%2A> to convert an IPv4 address from IPv6 format to IPv4 format, you must first ensure that you've got an IPv4 address.</span></span> <span data-ttu-id="a3202-249">调用 <xref:System.Net.IPAddress.IsIPv4MappedToIPv6%2A> ， `true` 如果 IP 地址最初被 IPv4 写入为 IPv6，则返回，否则返回 `false` 。</span><span class="sxs-lookup"><span data-stu-id="a3202-249">Call <xref:System.Net.IPAddress.IsIPv4MappedToIPv6%2A>, which will return `true` if the IP address is originally IPv4 written as IPv6, or `false` otherwise.</span></span> <span data-ttu-id="a3202-250">如果 <xref:System.Net.IPAddress.IsIPv4MappedToIPv6%2A> 返回 `true` ，则使用 <xref:System.Net.IPAddress.MapToIPv4%2A> 进行转换。</span><span class="sxs-lookup"><span data-stu-id="a3202-250">If <xref:System.Net.IPAddress.IsIPv4MappedToIPv6%2A> returns `true`, use <xref:System.Net.IPAddress.MapToIPv4%2A> to make the conversion.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MapToIPv6">
      <MemberSignature Language="C#" Value="public System.Net.IPAddress MapToIPv6 ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.IPAddress MapToIPv6() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.IPAddress.MapToIPv6" />
      <MemberSignature Language="VB.NET" Value="Public Function MapToIPv6 () As IPAddress" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::IPAddress ^ MapToIPv6();" />
      <MemberSignature Language="F#" Value="member this.MapToIPv6 : unit -&gt; System.Net.IPAddress" Usage="iPAddress.MapToIPv6 " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.IPAddress</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="a3202-251">将 <see cref="T:System.Net.IPAddress" /> 对象映射到 IPv6 地址。</span><span class="sxs-lookup"><span data-stu-id="a3202-251">Maps the <see cref="T:System.Net.IPAddress" /> object to an IPv6 address.</span></span></summary>
        <returns><span data-ttu-id="a3202-252">返回 <see cref="T:System.Net.IPAddress" />。</span><span class="sxs-lookup"><span data-stu-id="a3202-252">Returns <see cref="T:System.Net.IPAddress" />.</span></span>  
  
<span data-ttu-id="a3202-253">IPv6 地址。</span><span class="sxs-lookup"><span data-stu-id="a3202-253">An IPv6 address.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a3202-254">双堆栈套接字始终需要 IPv6 地址。</span><span class="sxs-lookup"><span data-stu-id="a3202-254">Dual-stack sockets always require IPv6 addresses.</span></span> <span data-ttu-id="a3202-255">与 IPv4 地址进行交互的功能需要使用 IPv4 映射的 IPv6 地址格式。</span><span class="sxs-lookup"><span data-stu-id="a3202-255">The ability to interact with an IPv4 address requires the use of the IPv4-mapped IPv6 address format.</span></span> <span data-ttu-id="a3202-256">所有 IPv4 地址必须以 IPv4 映射的 IPv6 地址格式表示，这使得仅支持 IPv6 的应用程序能够与 IPv4 节点通信。</span><span class="sxs-lookup"><span data-stu-id="a3202-256">Any IPv4 addresses must be represented in the IPv4-mapped IPv6 address format which enables an IPv6 only application to communicate with an IPv4 node.</span></span> <span data-ttu-id="a3202-257">IPv4 映射的 IPv6 地址格式允许 IPv4 节点的 IPv4 地址表示为 IPv6 地址。</span><span class="sxs-lookup"><span data-stu-id="a3202-257">The IPv4-mapped IPv6 address format allows the IPv4 address of an IPv4 node to be represented as an IPv6 address.</span></span> <span data-ttu-id="a3202-258">IPv4 地址编码为 IPv6 地址的低序位32位，高序位96位保存固定前缀0：0：0：0：0： FFFF。</span><span class="sxs-lookup"><span data-stu-id="a3202-258">The IPv4 address is encoded into the low-order 32 bits of the IPv6 address, and the high-order 96 bits hold the fixed prefix 0:0:0:0:0:FFFF.</span></span> <span data-ttu-id="a3202-259">在 RFC 4291 中指定了 IPv4 映射的 IPv6 地址格式。</span><span class="sxs-lookup"><span data-stu-id="a3202-259">The IPv4-mapped IPv6 address format is specified in RFC 4291.</span></span> <span data-ttu-id="a3202-260">有关详细信息，请参阅 [www.ietf.org/rfc/rfc4291.txt](https://go.microsoft.com/fwlink/?LinkID=92231)。</span><span class="sxs-lookup"><span data-stu-id="a3202-260">For more information, see [www.ietf.org/rfc/rfc4291.txt](https://go.microsoft.com/fwlink/?LinkID=92231).</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="NetworkToHostOrder">
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="a3202-261">将数字由网络字节顺序转换为主机字节顺序。</span><span class="sxs-lookup"><span data-stu-id="a3202-261">Converts a number from network byte order to host byte order.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="NetworkToHostOrder">
      <MemberSignature Language="C#" Value="public static short NetworkToHostOrder (short network);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int16 NetworkToHostOrder(int16 network) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.IPAddress.NetworkToHostOrder(System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function NetworkToHostOrder (network As Short) As Short" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static short NetworkToHostOrder(short network);" />
      <MemberSignature Language="F#" Value="static member NetworkToHostOrder : int16 -&gt; int16" Usage="System.Net.IPAddress.NetworkToHostOrder network" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="network" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="network"><span data-ttu-id="a3202-262">以网络字节顺序表示的要转换的数字。</span><span class="sxs-lookup"><span data-stu-id="a3202-262">The number to convert, expressed in network byte order.</span></span></param>
        <summary><span data-ttu-id="a3202-263">将短值由网络字节顺序转换为主机字节顺序。</span><span class="sxs-lookup"><span data-stu-id="a3202-263">Converts a short value from network byte order to host byte order.</span></span></summary>
        <returns><span data-ttu-id="a3202-264">以主机字节顺序表示的短值。</span><span class="sxs-lookup"><span data-stu-id="a3202-264">A short value, expressed in host byte order.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a3202-265">不同的计算机使用不同的约定对多字节整数值中的字节进行排序。</span><span class="sxs-lookup"><span data-stu-id="a3202-265">Different computers use different conventions for ordering the bytes within multibyte integer values.</span></span> <span data-ttu-id="a3202-266">某些计算机先将最重要的字节 (称为大字节序顺序) ，其他计算机会首先 (称为小字节序顺序) 的最小有效字节。</span><span class="sxs-lookup"><span data-stu-id="a3202-266">Some computers put the most significant byte first (known as big-endian order) and others put the least-significant byte first (known as little-endian order).</span></span> <span data-ttu-id="a3202-267">若要处理使用不同字节排序的计算机，则通过网络发送的所有整数值都以网络字节顺序发送，该顺序首先具有最重要的字节。</span><span class="sxs-lookup"><span data-stu-id="a3202-267">To work with computers that use different byte ordering, all integer values that are sent over the network are sent in network byte order which has the most significant byte first.</span></span>  
  
 <span data-ttu-id="a3202-268"><xref:System.Net.IPAddress.NetworkToHostOrder%2A>方法将主机系统上存储的多字节整数值从网络使用的字节顺序转换为主机使用的字节顺序。</span><span class="sxs-lookup"><span data-stu-id="a3202-268">The <xref:System.Net.IPAddress.NetworkToHostOrder%2A> method converts multibyte integer values that are stored on the host system from the byte order used by the network to the byte order used by the host.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a3202-269">下面的示例使用 <xref:System.Net.IPAddress.NetworkToHostOrder%2A> 方法将短值由网络字节顺序转换为主机字节顺序。</span><span class="sxs-lookup"><span data-stu-id="a3202-269">The following example uses the <xref:System.Net.IPAddress.NetworkToHostOrder%2A> method to convert a short value from network byte order to host byte order.</span></span>  
  
 [!code-cpp[IPAddress_NetworkToHost#1](~/samples/snippets/cpp/VS_Snippets_Remoting/IPAddress_NetworkToHost/CPP/ipaddress_networktohost.cpp#1)]
 [!code-csharp[IPAddress_NetworkToHost#1](~/samples/snippets/csharp/VS_Snippets_Remoting/IPAddress_NetworkToHost/CS/ipaddress_networktohost.cs#1)]
 [!code-vb[IPAddress_NetworkToHost#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/IPAddress_NetworkToHost/VB/ipaddress_networktohost.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Net.IPAddress.HostToNetworkOrder(System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="NetworkToHostOrder">
      <MemberSignature Language="C#" Value="public static int NetworkToHostOrder (int network);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 NetworkToHostOrder(int32 network) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.IPAddress.NetworkToHostOrder(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function NetworkToHostOrder (network As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int NetworkToHostOrder(int network);" />
      <MemberSignature Language="F#" Value="static member NetworkToHostOrder : int -&gt; int" Usage="System.Net.IPAddress.NetworkToHostOrder network" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="network" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="network"><span data-ttu-id="a3202-270">以网络字节顺序表示的要转换的数字。</span><span class="sxs-lookup"><span data-stu-id="a3202-270">The number to convert, expressed in network byte order.</span></span></param>
        <summary><span data-ttu-id="a3202-271">将整数值由网络字节顺序转换为主机字节顺序。</span><span class="sxs-lookup"><span data-stu-id="a3202-271">Converts an integer value from network byte order to host byte order.</span></span></summary>
        <returns><span data-ttu-id="a3202-272">以主机字节顺序表示的整数值。</span><span class="sxs-lookup"><span data-stu-id="a3202-272">An integer value, expressed in host byte order.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a3202-273">不同的计算机使用不同的约定对多字节整数值中的字节进行排序。</span><span class="sxs-lookup"><span data-stu-id="a3202-273">Different computers use different conventions for ordering the bytes within multibyte integer values.</span></span> <span data-ttu-id="a3202-274">某些计算机先将最重要的字节 (称为大字节序顺序) ，其他计算机会首先 (称为小字节序顺序) 的最小有效字节。</span><span class="sxs-lookup"><span data-stu-id="a3202-274">Some computers put the most significant byte first (known as big-endian order) and others put the least-significant byte first (known as little-endian order).</span></span> <span data-ttu-id="a3202-275">若要处理使用不同字节排序的计算机，则通过网络发送的所有整数值都以网络字节顺序发送，该顺序首先具有最重要的字节。</span><span class="sxs-lookup"><span data-stu-id="a3202-275">To work with computers that use different byte ordering, all integer values that are sent over the network are sent in network byte order which has the most significant byte first.</span></span>  
  
 <span data-ttu-id="a3202-276"><xref:System.Net.IPAddress.NetworkToHostOrder%2A>方法将主机系统上存储的多字节整数值从网络使用的字节顺序转换为主机使用的字节顺序。</span><span class="sxs-lookup"><span data-stu-id="a3202-276">The <xref:System.Net.IPAddress.NetworkToHostOrder%2A> method converts multibyte integer values that are stored on the host system from the byte order used by the network to the byte order used by the host.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a3202-277">下面的示例使用 <xref:System.Net.IPAddress.NetworkToHostOrder%2A> 方法将整数值由网络字节顺序转换为主机字节顺序。</span><span class="sxs-lookup"><span data-stu-id="a3202-277">The following example uses the <xref:System.Net.IPAddress.NetworkToHostOrder%2A> method to convert an integer value from network byte order to host byte order.</span></span>  
  
 [!code-cpp[IPAddress_NetworkToHost#2](~/samples/snippets/cpp/VS_Snippets_Remoting/IPAddress_NetworkToHost/CPP/ipaddress_networktohost.cpp#2)]
 [!code-csharp[IPAddress_NetworkToHost#2](~/samples/snippets/csharp/VS_Snippets_Remoting/IPAddress_NetworkToHost/CS/ipaddress_networktohost.cs#2)]
 [!code-vb[IPAddress_NetworkToHost#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/IPAddress_NetworkToHost/VB/ipaddress_networktohost.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Net.IPAddress.HostToNetworkOrder(System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="NetworkToHostOrder">
      <MemberSignature Language="C#" Value="public static long NetworkToHostOrder (long network);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 NetworkToHostOrder(int64 network) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.IPAddress.NetworkToHostOrder(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function NetworkToHostOrder (network As Long) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long NetworkToHostOrder(long network);" />
      <MemberSignature Language="F#" Value="static member NetworkToHostOrder : int64 -&gt; int64" Usage="System.Net.IPAddress.NetworkToHostOrder network" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="network" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="network"><span data-ttu-id="a3202-278">以网络字节顺序表示的要转换的数字。</span><span class="sxs-lookup"><span data-stu-id="a3202-278">The number to convert, expressed in network byte order.</span></span></param>
        <summary><span data-ttu-id="a3202-279">将长值由网络字节顺序转换为主机字节顺序。</span><span class="sxs-lookup"><span data-stu-id="a3202-279">Converts a long value from network byte order to host byte order.</span></span></summary>
        <returns><span data-ttu-id="a3202-280">以主机字节顺序表示的长值。</span><span class="sxs-lookup"><span data-stu-id="a3202-280">A long value, expressed in host byte order.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a3202-281">不同的计算机使用不同的约定对多字节整数值中的字节进行排序。</span><span class="sxs-lookup"><span data-stu-id="a3202-281">Different computers use different conventions for ordering the bytes within multibyte integer values.</span></span> <span data-ttu-id="a3202-282">某些计算机先将最重要的字节 (称为大字节序顺序) ，其他计算机会首先 (称为小字节序顺序) 的最小有效字节。</span><span class="sxs-lookup"><span data-stu-id="a3202-282">Some computers put the most significant byte first (known as big-endian order) and others put the least-significant byte first (known as little-endian order).</span></span> <span data-ttu-id="a3202-283">若要处理使用不同字节排序的计算机，则通过网络发送的所有整数值都以网络字节顺序发送，该顺序首先具有最重要的字节。</span><span class="sxs-lookup"><span data-stu-id="a3202-283">To work with computers that use different byte ordering, all integer values that are sent over the network are sent in network byte order which has the most significant byte first.</span></span>  
  
 <span data-ttu-id="a3202-284"><xref:System.Net.IPAddress.NetworkToHostOrder%2A>方法将主机系统上存储的多字节整数值从网络使用的字节顺序转换为主机使用的字节顺序。</span><span class="sxs-lookup"><span data-stu-id="a3202-284">The <xref:System.Net.IPAddress.NetworkToHostOrder%2A> method converts multibyte integer values that are stored on the host system from the byte order used by the network to the byte order used by the host.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a3202-285">下面的示例使用 <xref:System.Net.IPAddress.NetworkToHostOrder%2A> 方法将长值由网络字节顺序转换为主机字节顺序。</span><span class="sxs-lookup"><span data-stu-id="a3202-285">The following example uses the <xref:System.Net.IPAddress.NetworkToHostOrder%2A> method to convert a long value from network byte order to host byte order.</span></span>  
  
 [!code-cpp[IPAddress_NetworkToHost#3](~/samples/snippets/cpp/VS_Snippets_Remoting/IPAddress_NetworkToHost/CPP/ipaddress_networktohost.cpp#3)]
 [!code-csharp[IPAddress_NetworkToHost#3](~/samples/snippets/csharp/VS_Snippets_Remoting/IPAddress_NetworkToHost/CS/ipaddress_networktohost.cs#3)]
 [!code-vb[IPAddress_NetworkToHost#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/IPAddress_NetworkToHost/VB/ipaddress_networktohost.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Net.IPAddress.HostToNetworkOrder(System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="None">
      <MemberSignature Language="C#" Value="public static readonly System.Net.IPAddress None;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Net.IPAddress None" />
      <MemberSignature Language="DocId" Value="F:System.Net.IPAddress.None" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly None As IPAddress " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Net::IPAddress ^ None;" />
      <MemberSignature Language="F#" Value=" staticval mutable None : System.Net.IPAddress" Usage="System.Net.IPAddress.None" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.IPAddress</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a3202-286">提供指示不应使用任何网络接口的 IP 地址。</span><span class="sxs-lookup"><span data-stu-id="a3202-286">Provides an IP address that indicates that no network interface should be used.</span></span> <span data-ttu-id="a3202-287">此字段为只读。</span><span class="sxs-lookup"><span data-stu-id="a3202-287">This field is read-only.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a3202-288"><xref:System.Net.Sockets.Socket.Bind%2A?displayProperty=nameWithType>方法使用 <xref:System.Net.IPAddress.None> 字段指示 <xref:System.Net.Sockets.Socket> 不得侦听客户端活动。</span><span class="sxs-lookup"><span data-stu-id="a3202-288">The <xref:System.Net.Sockets.Socket.Bind%2A?displayProperty=nameWithType> method uses the <xref:System.Net.IPAddress.None> field to indicate that a <xref:System.Net.Sockets.Socket> must not listen for client activity.</span></span> <span data-ttu-id="a3202-289">此 <xref:System.Net.IPAddress.None> 字段等效于以点分隔的四部分表示法的255.255.255.255。</span><span class="sxs-lookup"><span data-stu-id="a3202-289">The <xref:System.Net.IPAddress.None> field is equivalent to 255.255.255.255 in dotted-quad notation.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a3202-290">下面的示例使用 <xref:System.Net.IPAddress.None> 属性指示不应使用任何网络接口。</span><span class="sxs-lookup"><span data-stu-id="a3202-290">The following example uses the <xref:System.Net.IPAddress.None> property to indicate that no network interface should be used.</span></span>  
  
 [!code-cpp[IPAddress_None#1](~/samples/snippets/cpp/VS_Snippets_Remoting/IPAddress_None/CPP/ipaddress_none.cpp#1)]
 [!code-csharp[IPAddress_None#1](~/samples/snippets/csharp/VS_Snippets_Remoting/IPAddress_None/CS/ipaddress_none.cs#1)]
 [!code-vb[IPAddress_None#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/IPAddress_None/VB/ipaddress_none.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static System.Net.IPAddress Parse (string ipString);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Net.IPAddress Parse(string ipString) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.IPAddress.Parse(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (ipString As String) As IPAddress" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Net::IPAddress ^ Parse(System::String ^ ipString);" />
      <MemberSignature Language="F#" Value="static member Parse : string -&gt; System.Net.IPAddress" Usage="System.Net.IPAddress.Parse ipString" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.IPAddress</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ipString" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="ipString"><span data-ttu-id="a3202-291">包含 IP 地址（IPv4 使用点分四组表示法，IPv6 使用冒号十六进制表示法）的字符串。</span><span class="sxs-lookup"><span data-stu-id="a3202-291">A string that contains an IP address in dotted-quad notation for IPv4 and in colon-hexadecimal notation for IPv6.</span></span></param>
        <summary><span data-ttu-id="a3202-292">将 IP 地址字符串转换为 <see cref="T:System.Net.IPAddress" /> 实例。</span><span class="sxs-lookup"><span data-stu-id="a3202-292">Converts an IP address string to an <see cref="T:System.Net.IPAddress" /> instance.</span></span></summary>
        <returns><span data-ttu-id="a3202-293">一个 <see cref="T:System.Net.IPAddress" /> 实例。</span><span class="sxs-lookup"><span data-stu-id="a3202-293">An <see cref="T:System.Net.IPAddress" /> instance.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a3202-294">静态方法根据 IPv4 的以点分隔的四部分表示 <xref:System.Net.IPAddress.Parse%2A> <xref:System.Net.IPAddress> 法和 IPv6 的冒号十六进制表示法创建一个实例。</span><span class="sxs-lookup"><span data-stu-id="a3202-294">The static <xref:System.Net.IPAddress.Parse%2A> method creates an <xref:System.Net.IPAddress> instance from an IP address expressed in dotted-quad notation for IPv4 and in colon-hexadecimal notation for IPv6.</span></span>  
  
 <span data-ttu-id="a3202-295">每个部件 (的部分数以句点分隔) ， `ipString` 确定如何构造 IP 地址。</span><span class="sxs-lookup"><span data-stu-id="a3202-295">The number of parts (each part is separated by a period) in `ipString` determines how the IP address is constructed.</span></span> <span data-ttu-id="a3202-296">一个部分地址直接存储在网络地址中。</span><span class="sxs-lookup"><span data-stu-id="a3202-296">A one part address is stored directly in the network address.</span></span> <span data-ttu-id="a3202-297">两部分寻址，方便于指定 a 类地址，并将前导部分放在第一个字节，并将尾随部分放在网络地址的最右侧三个字节中。</span><span class="sxs-lookup"><span data-stu-id="a3202-297">A two part address, convenient for specifying a class A address, puts the leading part in the first byte and the trailing part in the right-most three bytes of the network address.</span></span> <span data-ttu-id="a3202-298">三个部分地址（方便指定 B 类地址）将第一个部分放在第一个字节中，第二个部分位于第二个字节，第二个部分位于网络地址最右侧的两个字节中。</span><span class="sxs-lookup"><span data-stu-id="a3202-298">A three part address, convenient for specifying a class B address, puts the first part in the first byte, the second part in the second byte, and the final part in the right-most two bytes of the network address.</span></span> <span data-ttu-id="a3202-299">例如：</span><span class="sxs-lookup"><span data-stu-id="a3202-299">For example:</span></span>  
  
|<span data-ttu-id="a3202-300">部分数量和示例 `ipString`</span><span class="sxs-lookup"><span data-stu-id="a3202-300">Number of parts and example `ipString`</span></span>|<span data-ttu-id="a3202-301">Ip 地址的 IPv4 地址</span><span class="sxs-lookup"><span data-stu-id="a3202-301">IPv4 address for IPAddress</span></span>|  
|--------------------------------------------|--------------------------------|  
|<span data-ttu-id="a3202-302">1--"65535"</span><span class="sxs-lookup"><span data-stu-id="a3202-302">1 -- "65535"</span></span>|<span data-ttu-id="a3202-303">0.0.255.255</span><span class="sxs-lookup"><span data-stu-id="a3202-303">0.0.255.255</span></span>|  
|<span data-ttu-id="a3202-304">2 -- "20.2"</span><span class="sxs-lookup"><span data-stu-id="a3202-304">2 -- "20.2"</span></span>|<span data-ttu-id="a3202-305">20.0.0.2</span><span class="sxs-lookup"><span data-stu-id="a3202-305">20.0.0.2</span></span>|  
|<span data-ttu-id="a3202-306">2 -- "20.65535"</span><span class="sxs-lookup"><span data-stu-id="a3202-306">2 -- "20.65535"</span></span>|<span data-ttu-id="a3202-307">20.0.255.255</span><span class="sxs-lookup"><span data-stu-id="a3202-307">20.0.255.255</span></span>|  
|<span data-ttu-id="a3202-308">3 -- "128.1.2"</span><span class="sxs-lookup"><span data-stu-id="a3202-308">3 -- "128.1.2"</span></span>|<span data-ttu-id="a3202-309">128.1.0.2</span><span class="sxs-lookup"><span data-stu-id="a3202-309">128.1.0.2</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="a3202-310">下面的代码将包含 IP 地址的字符串转换为 IPv4 的以点分隔的四部分表示法，在 IPv6 中将其转换为类的实例 <xref:System.Net.IPAddress> 。</span><span class="sxs-lookup"><span data-stu-id="a3202-310">The following code converts a string that contains an IP address, in dotted-quad notation for IPv4 or in colon-hexadecimal notation for IPv6, into an instance of the <xref:System.Net.IPAddress> class.</span></span> <span data-ttu-id="a3202-311">然后，它使用重载 <xref:System.Net.IPAddress.ToString%2A> 的方法以标准表示法显示地址。</span><span class="sxs-lookup"><span data-stu-id="a3202-311">Then it uses the overloaded <xref:System.Net.IPAddress.ToString%2A> method to display the address in standard notation.</span></span>  
  
 [!code-cpp[System.Net.IPAddress.Parse#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.IPAddress.Parse/CPP/parse.cpp#1)]
 [!code-csharp[System.Net.IPAddress.Parse#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.IPAddress.Parse/CS/parse.cs#1)]
 [!code-vb[System.Net.IPAddress.Parse#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.IPAddress.Parse/VB/parse.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="a3202-312"><paramref name="ipString" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="a3202-312"><paramref name="ipString" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.FormatException"><span data-ttu-id="a3202-313"><paramref name="ipString" /> 不是有效的 IP 地址。</span><span class="sxs-lookup"><span data-stu-id="a3202-313"><paramref name="ipString" /> is not a valid IP address.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static System.Net.IPAddress? Parse (ReadOnlySpan&lt;char&gt; ipSpan);" FrameworkAlternate="net-5.0" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Net.IPAddress Parse(valuetype System.ReadOnlySpan`1&lt;char&gt; ipSpan) cil managed" FrameworkAlternate="net-5.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.IPAddress.Parse(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (ipSpan As ReadOnlySpan(Of Char)) As IPAddress" FrameworkAlternate="net-5.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Net::IPAddress ^ Parse(ReadOnlySpan&lt;char&gt; ipSpan);" FrameworkAlternate="net-5.0" />
      <MemberSignature Language="F#" Value="static member Parse : ReadOnlySpan&lt;char&gt; -&gt; System.Net.IPAddress" Usage="System.Net.IPAddress.Parse ipSpan" FrameworkAlternate="net-5.0" />
      <MemberSignature Language="C#" Value="public static System.Net.IPAddress Parse (ReadOnlySpan&lt;char&gt; ipString);" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Net.IPAddress Parse(valuetype System.ReadOnlySpan`1&lt;char&gt; ipString) cil managed" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (ipString As ReadOnlySpan(Of Char)) As IPAddress" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Net::IPAddress ^ Parse(ReadOnlySpan&lt;char&gt; ipString);" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1" />
      <MemberSignature Language="F#" Value="static member Parse : ReadOnlySpan&lt;char&gt; -&gt; System.Net.IPAddress" Usage="System.Net.IPAddress.Parse ipString" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.IPAddress</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ipString" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="ipSpan" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="net-5.0" />
      </Parameters>
      <Docs>
        <param name="ipString"><span data-ttu-id="a3202-314">包含 IP 地址（IPv4 使用点分四组表示法，IPv6 使用冒号十六进制表示法）的字符跨度。</span><span class="sxs-lookup"><span data-stu-id="a3202-314">A character span that contains an IP address in dotted-quad notation for IPv4 and in colon-hexadecimal notation for IPv6.</span></span></param>
        <param name="ipSpan">To be added.</param>
        <summary><span data-ttu-id="a3202-315">将以字符范围表示的 IP 地址转换为 <see cref="T:System.Net.IPAddress" /> 实例。</span><span class="sxs-lookup"><span data-stu-id="a3202-315">Converts an IP address represented as a character span to an <see cref="T:System.Net.IPAddress" /> instance.</span></span></summary>
        <returns><span data-ttu-id="a3202-316">转换后的 IP 地址。</span><span class="sxs-lookup"><span data-stu-id="a3202-316">The converted IP address.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.FormatException"><span data-ttu-id="a3202-317"><paramref name="ipString" /> 不是有效的 IP 地址。</span><span class="sxs-lookup"><span data-stu-id="a3202-317"><paramref name="ipString" /> is not a valid IP address.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ScopeId">
      <MemberSignature Language="C#" Value="public long ScopeId { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 ScopeId" />
      <MemberSignature Language="DocId" Value="P:System.Net.IPAddress.ScopeId" />
      <MemberSignature Language="VB.NET" Value="Public Property ScopeId As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long ScopeId { long get(); void set(long value); };" />
      <MemberSignature Language="F#" Value="member this.ScopeId : int64 with get, set" Usage="System.Net.IPAddress.ScopeId" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a3202-318">获取或设置 IPv6 地址范围标识符。</span><span class="sxs-lookup"><span data-stu-id="a3202-318">Gets or sets the IPv6 address scope identifier.</span></span></summary>
        <value><span data-ttu-id="a3202-319">指定地址范围的长整数。</span><span class="sxs-lookup"><span data-stu-id="a3202-319">A long integer that specifies the scope of the address.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a3202-320">更改的含义 <xref:System.Net.IPAddress.ScopeId%2A> 取决于使用它的上下文。</span><span class="sxs-lookup"><span data-stu-id="a3202-320">The meaning of <xref:System.Net.IPAddress.ScopeId%2A> changes depending on the context in which it is used.</span></span>  
  
-   <span data-ttu-id="a3202-321">链接-本地地址。</span><span class="sxs-lookup"><span data-stu-id="a3202-321">Link-local address.</span></span> <span data-ttu-id="a3202-322">在多个接口连接到不同链接的主机上，可以将同一链接本地地址分配给多个接口。</span><span class="sxs-lookup"><span data-stu-id="a3202-322">On a host with multiple interfaces connected to separate links, the same link-local address can be assigned to multiple interfaces.</span></span> <span data-ttu-id="a3202-323">为了消除这种不明确性，范围标识符用于指定交换消息所使用的接口。</span><span class="sxs-lookup"><span data-stu-id="a3202-323">To eliminate this ambiguity, a scope identifier is used to specify the interface over which messages are exchanged.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="a3202-324">链接本地地址（由格式前缀 (FP) FE80）在与同一链接上的相邻节点通信时由节点使用。</span><span class="sxs-lookup"><span data-stu-id="a3202-324">Link-local addresses, identified by the Format Prefix (FP) FE80, are used by nodes when communicating with neighboring nodes on the same link.</span></span>  
  
-   <span data-ttu-id="a3202-325">站点本地地址。</span><span class="sxs-lookup"><span data-stu-id="a3202-325">Site-local addresses.</span></span> <span data-ttu-id="a3202-326">主机可以连接到多个站点。</span><span class="sxs-lookup"><span data-stu-id="a3202-326">A host can be connected to multiple sites.</span></span> <span data-ttu-id="a3202-327">在这种情况下，作用域标识符用于指示要与之通信的特定站点。</span><span class="sxs-lookup"><span data-stu-id="a3202-327">In this case, a scope identifier is used to indicate a specific site to communicate with.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="a3202-328">站点本地地址，由节点在专用 intranet 上通信时使用 (FP) FEC0 的格式前缀标识。</span><span class="sxs-lookup"><span data-stu-id="a3202-328">Site-local addresses, identified by the Format Prefix (FP) FEC0, are used by nodes when communicating on private intranets.</span></span>  
  
 <span data-ttu-id="a3202-329">用于指定地址的符号 `ScopeId` 为 `Address%ScopeId` 。</span><span class="sxs-lookup"><span data-stu-id="a3202-329">The notation that is used to specify the `ScopeId` with an address is `Address%ScopeId`.</span></span> <span data-ttu-id="a3202-330">例如，`FE80::5EFE:192.168.41.30%2.`</span><span class="sxs-lookup"><span data-stu-id="a3202-330">For example, `FE80::5EFE:192.168.41.30%2.`</span></span>  
  
   
  
## Examples  
 [!code-cpp[System.Net.IPAddress#3](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.IPAddress/CPP/ipaddress.cpp#3)]
 [!code-csharp[System.Net.IPAddress#3](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.IPAddress/CS/ipaddress.cs#3)]
 [!code-vb[System.Net.IPAddress#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.IPAddress/VB/ipaddress.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="a3202-331"><see langword="AddressFamily" /> = <see langword="InterNetwork" />。</span><span class="sxs-lookup"><span data-stu-id="a3202-331"><see langword="AddressFamily" /> = <see langword="InterNetwork" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="a3202-332"><paramref name="scopeId" /> &lt; 0</span><span class="sxs-lookup"><span data-stu-id="a3202-332"><paramref name="scopeId" /> &lt; 0</span></span> 
<span data-ttu-id="a3202-333">- 或 -</span><span class="sxs-lookup"><span data-stu-id="a3202-333">-or-</span></span> 
<span data-ttu-id="a3202-334"><paramref name="scopeId" />&gt; 0x00000000FFFFFFFF</span><span class="sxs-lookup"><span data-stu-id="a3202-334"><paramref name="scopeId" /> &gt; 0x00000000FFFFFFFF</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.IPAddress.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="iPAddress.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="a3202-335">将 Internet 地址转换为标准表示法。</span><span class="sxs-lookup"><span data-stu-id="a3202-335">Converts an Internet address to its standard notation.</span></span></summary>
        <returns><span data-ttu-id="a3202-336">包含 IP 地址（IPv4 使用点分四组表示法，IPv6 使用冒号十六进制表示法）的字符串。</span><span class="sxs-lookup"><span data-stu-id="a3202-336">A string that contains the IP address in either IPv4 dotted-quad or in IPv6 colon-hexadecimal notation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a3202-337"><xref:System.Net.IPAddress.ToString%2A>方法会将存储在属性中的 IP 地址转换 <xref:System.Net.IPAddress.Address%2A> 为 IPv4 点分四位或 IPv6 冒号十六进制表示法。</span><span class="sxs-lookup"><span data-stu-id="a3202-337">The <xref:System.Net.IPAddress.ToString%2A> method converts the IP address that is stored in the <xref:System.Net.IPAddress.Address%2A> property to either IPv4 dotted-quad or IPv6 colon-hexadecimal notation.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="a3202-338">该地址族为 <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" />，而且该地址是错误的。</span><span class="sxs-lookup"><span data-stu-id="a3202-338">The address family is <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> and the address is bad.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="TryFormat">
      <MemberSignature Language="C#" Value="public bool TryFormat (Span&lt;char&gt; destination, out int charsWritten);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryFormat(valuetype System.Span`1&lt;char&gt; destination, [out] int32&amp; charsWritten) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.IPAddress.TryFormat(System.Span{System.Char},System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryFormat (destination As Span(Of Char), ByRef charsWritten As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryFormat(Span&lt;char&gt; destination, [Runtime::InteropServices::Out] int % charsWritten);" />
      <MemberSignature Language="F#" Value="member this.TryFormat : Span&lt;char&gt; * int -&gt; bool" Usage="iPAddress.TryFormat (destination, charsWritten)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="charsWritten" Type="System.Int32" RefType="out" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="destination"><span data-ttu-id="a3202-339">此方法返回时，IP 地址为一段字符。</span><span class="sxs-lookup"><span data-stu-id="a3202-339">When this method returns, the IP address as a span of characters.</span></span></param>
        <param name="charsWritten"><span data-ttu-id="a3202-340">此方法返回时，写入范围的字符数。</span><span class="sxs-lookup"><span data-stu-id="a3202-340">When this method returns, the number of characters written into the span.</span></span></param>
        <summary><span data-ttu-id="a3202-341">尝试将当前 IP 地址格式化为提供的范围。</span><span class="sxs-lookup"><span data-stu-id="a3202-341">Tries to format the current IP address into the provided span.</span></span></summary>
        <returns><span data-ttu-id="a3202-342">如果格式设置成功，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="a3202-342"><see langword="true" /> if the formatting was successful; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (string ipString, out System.Net.IPAddress address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(string ipString, [out] class System.Net.IPAddress&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.IPAddress.TryParse(System.String,System.Net.IPAddress@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (ipString As String, ByRef address As IPAddress) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(System::String ^ ipString, [Runtime::InteropServices::Out] System::Net::IPAddress ^ % address);" />
      <MemberSignature Language="F#" Value="static member TryParse : string * IPAddress -&gt; bool" Usage="System.Net.IPAddress.TryParse (ipString, address)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ipString" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="address" Type="System.Net.IPAddress" RefType="out" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="ipString"><span data-ttu-id="a3202-343">要验证的字符串。</span><span class="sxs-lookup"><span data-stu-id="a3202-343">The string to validate.</span></span></param>
        <param name="address"><span data-ttu-id="a3202-344">字符串的 <see cref="T:System.Net.IPAddress" /> 版本。</span><span class="sxs-lookup"><span data-stu-id="a3202-344">The <see cref="T:System.Net.IPAddress" /> version of the string.</span></span></param>
        <summary><span data-ttu-id="a3202-345">确定字符串是否为有效的 IP 地址。</span><span class="sxs-lookup"><span data-stu-id="a3202-345">Determines whether a string is a valid IP address.</span></span></summary>
        <returns><span data-ttu-id="a3202-346">如果 <paramref name="ipString" /> 能解析 IP 地址，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="a3202-346"><see langword="true" /> if <paramref name="ipString" /> was able to be parsed as an IP address; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a3202-347">请注意，此方法接受可分析为的 ipString 值 <xref:System.Int64> ，然后将该 Int64 视为网络字节顺序中 IP 地址的长值，这与 <xref:System.Net.IPAddress.%23ctor%2A> 构造函数的作用类似。</span><span class="sxs-lookup"><span data-stu-id="a3202-347">Note that this method accepts as valid an ipString value that can be parsed as an <xref:System.Int64>, and then treats that Int64 as the long value of an IP address in network byte order, similar to the way that the <xref:System.Net.IPAddress.%23ctor%2A> constructor does.</span></span> <span data-ttu-id="a3202-348">这意味着，如果 Int64 分析成功，则此方法返回 true，即使它表示的地址不是有效的 IP 地址也是如此。</span><span class="sxs-lookup"><span data-stu-id="a3202-348">This means that this method returns true if the Int64 is parsed successfully, even if it represents an address that's not a valid IP address.</span></span> <span data-ttu-id="a3202-349">例如，如果 ipString 为 "1"，则此方法返回 true，即使 "1" (或 0.0.0.1) 不是有效的 IP 地址，也可能希望此方法返回 false。</span><span class="sxs-lookup"><span data-stu-id="a3202-349">For example, if ipString is "1", this method returns true even though "1" (or 0.0.0.1) is not a valid IP address and you might expect this method to return false.</span></span> <span data-ttu-id="a3202-350">修复此 bug 会破坏现有应用程序，因此不会更改当前行为。</span><span class="sxs-lookup"><span data-stu-id="a3202-350">Fixing this bug would break existing apps, so the current behavior will not be changed.</span></span> <span data-ttu-id="a3202-351">你的代码可以通过确保它只使用此方法来分析以点分隔的十进制格式的 IP 地址，从而避免此行为。</span><span class="sxs-lookup"><span data-stu-id="a3202-351">Your code can avoid this behavior by ensuring that it only uses this method to parse IP addresses in dotted-decimal format.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="a3202-352"><paramref name="ipString" /> 为 null。</span><span class="sxs-lookup"><span data-stu-id="a3202-352"><paramref name="ipString" /> is null.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (ReadOnlySpan&lt;char&gt; ipSpan, out System.Net.IPAddress? address);" FrameworkAlternate="net-5.0" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(valuetype System.ReadOnlySpan`1&lt;char&gt; ipSpan, [out] class System.Net.IPAddress&amp; address) cil managed" FrameworkAlternate="net-5.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.IPAddress.TryParse(System.ReadOnlySpan{System.Char},System.Net.IPAddress@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (ipSpan As ReadOnlySpan(Of Char), ByRef address As IPAddress) As Boolean" FrameworkAlternate="net-5.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(ReadOnlySpan&lt;char&gt; ipSpan, [Runtime::InteropServices::Out] System::Net::IPAddress ^ % address);" FrameworkAlternate="net-5.0" />
      <MemberSignature Language="F#" Value="static member TryParse : ReadOnlySpan&lt;char&gt; * IPAddress -&gt; bool" Usage="System.Net.IPAddress.TryParse (ipSpan, address)" FrameworkAlternate="net-5.0" />
      <MemberSignature Language="C#" Value="public static bool TryParse (ReadOnlySpan&lt;char&gt; ipString, out System.Net.IPAddress address);" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(valuetype System.ReadOnlySpan`1&lt;char&gt; ipString, [out] class System.Net.IPAddress&amp; address) cil managed" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (ipString As ReadOnlySpan(Of Char), ByRef address As IPAddress) As Boolean" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(ReadOnlySpan&lt;char&gt; ipString, [Runtime::InteropServices::Out] System::Net::IPAddress ^ % address);" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1" />
      <MemberSignature Language="F#" Value="static member TryParse : ReadOnlySpan&lt;char&gt; * IPAddress -&gt; bool" Usage="System.Net.IPAddress.TryParse (ipString, address)" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ipString" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="ipSpan" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="net-5.0" />
        <Parameter Name="address" Type="System.Net.IPAddress" RefType="out" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="ipString"><span data-ttu-id="a3202-353">要验证的字节范围。</span><span class="sxs-lookup"><span data-stu-id="a3202-353">The byte span to validate.</span></span></param>
        <param name="address"><span data-ttu-id="a3202-354">此方法返回时，字节范围的 <see cref="T:System.Net.IPAddress" /> 版本。</span><span class="sxs-lookup"><span data-stu-id="a3202-354">When this method returns, the <see cref="T:System.Net.IPAddress" /> version of the byte span.</span></span></param>
        <param name="ipSpan">To be added.</param>
        <summary><span data-ttu-id="a3202-355">确定指定的字节范围是否表示有效的 IP 地址。</span><span class="sxs-lookup"><span data-stu-id="a3202-355">Determines whether the specified byte span represents a valid IP address.</span></span></summary>
        <returns><span data-ttu-id="a3202-356">如果 <paramref name="ipString" /> 能解析 IP 地址，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="a3202-356"><see langword="true" /> if <paramref name="ipString" /> was able to be parsed as an IP address; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryWriteBytes">
      <MemberSignature Language="C#" Value="public bool TryWriteBytes (Span&lt;byte&gt; destination, out int bytesWritten);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryWriteBytes(valuetype System.Span`1&lt;unsigned int8&gt; destination, [out] int32&amp; bytesWritten) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.IPAddress.TryWriteBytes(System.Span{System.Byte},System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryWriteBytes (destination As Span(Of Byte), ByRef bytesWritten As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryWriteBytes(Span&lt;System::Byte&gt; destination, [Runtime::InteropServices::Out] int % bytesWritten);" />
      <MemberSignature Language="F#" Value="member this.TryWriteBytes : Span&lt;byte&gt; * int -&gt; bool" Usage="iPAddress.TryWriteBytes (destination, bytesWritten)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="bytesWritten" Type="System.Int32" RefType="out" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="destination"><span data-ttu-id="a3202-357">此方法返回时，IP 地址为一段字节。</span><span class="sxs-lookup"><span data-stu-id="a3202-357">When this method returns, the IP address as a span of bytes.</span></span></param>
        <param name="bytesWritten"><span data-ttu-id="a3202-358">此方法返回时，写入范围的字节数。</span><span class="sxs-lookup"><span data-stu-id="a3202-358">When this method returns, the number of bytes written into the span.</span></span></param>
        <summary><span data-ttu-id="a3202-359">尝试将当前 IP 地址写为一段字节。</span><span class="sxs-lookup"><span data-stu-id="a3202-359">Tries to write the current IP address into a span of bytes.</span></span></summary>
        <returns><span data-ttu-id="a3202-360">如果 IP 地址已成功写入给定范围，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="a3202-360"><see langword="true" /> if the IP address is successfully written to the given span; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
