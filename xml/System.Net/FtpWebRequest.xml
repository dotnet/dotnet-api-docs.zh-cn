<Type Name="FtpWebRequest" FullName="System.Net.FtpWebRequest">
  <Metadata><Meta Name="ms.openlocfilehash" Value="d54e5c477aa8d73cc262254822a7b4caece38a5c" /><Meta Name="ms.sourcegitcommit" Value="943c8cdbe5b47c6c296a6f4b73038bbd43da0dd2" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-CN" /><Meta Name="ms.lasthandoff" Value="02/12/2021" /><Meta Name="ms.locfileid" Value="100320697" /></Metadata><TypeSignature Language="C#" Value="public sealed class FtpWebRequest : System.Net.WebRequest" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit FtpWebRequest extends System.Net.WebRequest" />
  <TypeSignature Language="DocId" Value="T:System.Net.FtpWebRequest" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class FtpWebRequest&#xA;Inherits WebRequest" />
  <TypeSignature Language="C++ CLI" Value="public ref class FtpWebRequest sealed : System::Net::WebRequest" />
  <TypeSignature Language="F#" Value="type FtpWebRequest = class&#xA;    inherit WebRequest" />
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Net.Requests</AssemblyName>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
    <AssemblyVersion>4.1.2.0</AssemblyVersion>
    <AssemblyVersion>5.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeForwardingChain>
    <TypeForwarding From="netstandard" FromVersion="2.1.0.0" To="System.Net.Requests" ToVersion="5.0.0.0" FrameworkAlternate="net-5.0" />
  </TypeForwardingChain>
  <Base>
    <BaseTypeName>System.Net.WebRequest</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>实现文件传输协议 (FTP) 客户端。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks

> [!IMPORTANT]
>  不建议使用 `FtpWebRequest` 类进行新的开发。 有关的详细信息和替代方法 `FtpWebRequest` ，请参阅 [WebRequest 不应](https://github.com/dotnet/platform-compat/blob/master/docs/DE0003.md) 在 GitHub 上使用。

 若要获取的实例 <xref:System.Net.FtpWebRequest> ，请使用 <xref:System.Net.WebRequest.Create%2A> 方法。 你还可以使用 <xref:System.Net.WebClient> 类从 FTP 服务器上传和下载信息。 使用这两种方法中的任意一种，在指定使用 FTP 方案的网络资源时 (例如， `"ftp://contoso.com"`) <xref:System.Net.FtpWebRequest> 类提供以编程方式与 FTP 服务器交互的功能。  
  
 该 URI 可以是相对路径或绝对 URI。 如果 URI 的格式 `"ftp://contoso.com/%2fpath"` (% 2f 是转义的 "/" ) ，则 uri 为绝对 uri，当前目录为 `/path` 。 但是，如果 URI 的形式为 `"ftp://contoso.com/path"` ，则首先 .NET Framework 使用属性) 设置的用户名和密码登录到 FTP 服务器 (<xref:System.Net.FtpWebRequest.Credentials%2A> ，然后将当前目录设置为 `<UserLoginDirectory>/path` 。  
  
 必须为服务器提供有效的用户名和密码，否则服务器必须允许匿名登录。 您可以通过设置属性来指定用于连接到服务器的凭据， <xref:System.Net.FtpWebRequest.Credentials%2A> 也可以在 <xref:System.Uri.UserInfo%2A> 传递给该方法的 URI 部分中包含它们 <xref:System.Net.WebRequest.Create%2A> 。 如果在 <xref:System.Uri.UserInfo%2A> URI 中包含信息，则 <xref:System.Net.FtpWebRequest.Credentials%2A> 使用指定的用户名和密码信息将属性设置为新的网络凭据。  
  
> [!CAUTION]
>  除非 <xref:System.Net.FtpWebRequest.EnableSsl%2A> 属性为 `true` ，否则所有数据和命令（包括你的用户名和密码信息）都将以明文形式发送到服务器。 监视网络流量的任何人都可以查看凭据并使用它们连接到服务器。 如果要连接到需要凭据的 FTP 服务器并支持安全套接字层 (SSL) ，则应将设置 <xref:System.Net.FtpWebRequest.EnableSsl%2A> 为 `true` 。  
  
 您必须 <xref:System.Net.WebPermission> 访问 FTP 资源; 否则，将 <xref:System.Security.SecurityException> 引发异常。  
  
 通过将 <xref:System.Net.FtpWebRequest.Method%2A> 属性设置为结构中定义的值来指定要发送到服务器的 FTP 命令 <xref:System.Net.WebRequestMethods.Ftp> 。 若要传输文本数据，请将 <xref:System.Net.FtpWebRequest.UseBinary%2A> 属性从其默认值更改 (`true`) 设置为 `false` 。 有关详细信息和限制，请参阅 <xref:System.Net.FtpWebRequest.Method%2A> 。  
  
 使用 <xref:System.Net.FtpWebRequest> 对象将文件上载到服务器时，必须将文件内容写入通过调用 <xref:System.Net.FtpWebRequest.GetRequestStream%2A> 方法或其异步对应项（和方法）获得的请求流 <xref:System.Net.FtpWebRequest.BeginGetRequestStream%2A> <xref:System.Net.FtpWebRequest.EndGetRequestStream%2A> 。 在发送请求之前，必须写入流并关闭流。  
  
 通过调用 <xref:System.Net.FtpWebRequest.GetResponse%2A> 方法或其异步对应项、和方法将请求发送到服务器 <xref:System.Net.FtpWebRequest.BeginGetResponse%2A> <xref:System.Net.FtpWebRequest.EndGetResponse%2A> 。 当请求的操作完成时， <xref:System.Net.FtpWebResponse> 将返回一个对象。 <xref:System.Net.FtpWebResponse>对象提供操作的状态以及从服务器下载的任何数据。  
  
 您可以使用属性设置用于读取或写入服务器的超时值 <xref:System.Net.FtpWebRequest.ReadWriteTimeout%2A> 。 如果超过超时期限，则调用方法会引发， <xref:System.Net.WebException> 并 <xref:System.Net.WebExceptionStatus> 将设置为 <xref:System.Net.WebExceptionStatus.Timeout> 。  
  
 从 FTP 服务器下载文件时，如果命令成功，则所请求文件的内容可用于响应对象的流中。 可以通过调用方法访问此流 <xref:System.Net.FtpWebResponse.GetResponseStream%2A> 。 有关详细信息，请参阅 <xref:System.Net.FtpWebResponse>。  
  
 如果该 <xref:System.Net.FtpWebRequest.Proxy%2A> 属性是直接设置的，或者是在配置文件中设置的，则通过指定的代理建立与 FTP 服务器的通信。 如果指定的代理是 HTTP 代理，则仅 <xref:System.Net.WebRequestMethods.Ftp.DownloadFile> 支持、 <xref:System.Net.WebRequestMethods.Ftp.ListDirectory> 和 <xref:System.Net.WebRequestMethods.Ftp.ListDirectoryDetails> 命令。  
  
 仅缓存下载的二进制内容;也就是说，使用命令接收的内容，其 <xref:System.Net.WebRequestMethods.Ftp.DownloadFile> <xref:System.Net.FtpWebRequest.UseBinary%2A> 属性设置为 `true` 。  
  
 <xref:System.Net.FtpWebRequest>如果可能，多个重复使用现有连接。  
  
 有关 FTP 协议的详细信息，请参阅 [RFC 959：文件传输协议](https://www.ietf.org/rfc/rfc959.txt)。  
  
   
  
## Examples  
 下面的代码示例演示如何从 FTP 服务器中删除文件。  
  
 [!code-cpp[NCLFtpClient#4](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLFtpClient/CPP/ftptests.cpp#4)]
 [!code-csharp[NCLFtpClient#4](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLFtpClient/CS/ftptests.cs#4)]  
  
 下面的代码示例演示如何使用类从 FTP 服务器下载文件 <xref:System.Net.WebClient> 。  
  
 [!code-cpp[NCLFtpClient#5](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLFtpClient/CPP/ftptests.cpp#5)]
 [!code-csharp[NCLFtpClient#5](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLFtpClient/CS/ftptests.cs#5)]  
  
 下面的代码示例演示如何使用异步操作将文件上载到 FTP 服务器。  
  
 [!code-cpp[NCLFtpAsync#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLFtpAsync/CPP/async.cpp#1)]
 [!code-csharp[NCLFtpAsync#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLFtpAsync/CS/async.cs#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Net.FtpWebResponse" />
    <altmember cref="T:System.Net.FtpStatusCode" />
    <altmember cref="T:System.Net.WebRequestMethods.Ftp" />
    <altmember cref="T:System.Net.WebRequest" />
    <altmember cref="T:System.Net.WebResponse" />
    <altmember cref="T:System.Net.WebClient" />
  </Docs>
  <Members>
    <Member MemberName="Abort">
      <MemberSignature Language="C#" Value="public override void Abort ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Abort() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.FtpWebRequest.Abort" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Abort ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Abort();" />
      <MemberSignature Language="F#" Value="override this.Abort : unit -&gt; unit" Usage="ftpWebRequest.Abort " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>终止异步 FTP 操作。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果没有正在进行的操作，此方法不执行任何操作。 如果文件传输正在进行，则此方法将终止传输。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅 [.NET Framework 中的网络跟踪](/dotnet/framework/network-programming/network-tracing)。  
  
   
  
## Examples  
 下面的代码示例演示了用户可以如何终止从本地目录到服务器的异步文件上传。  
  
 [!code-cpp[NCLFtpClient#10](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLFtpClient/CPP/ftptests.cpp#10)]
 [!code-csharp[NCLFtpClient#10](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLFtpClient/CS/ftptests.cs#10)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.FtpWebResponse" />
        <altmember cref="T:System.Net.FtpStatusCode" />
        <altmember cref="T:System.Net.WebRequestMethods.Ftp" />
        <altmember cref="T:System.Net.WebRequest" />
        <altmember cref="T:System.Net.WebResponse" />
        <altmember cref="T:System.Net.WebClient" />
      </Docs>
    </Member>
    <Member MemberName="BeginGetRequestStream">
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginGetRequestStream (AsyncCallback? callback, object? state);" FrameworkAlternate="net-5.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IAsyncResult BeginGetRequestStream(class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.FtpWebRequest.BeginGetRequestStream(System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function BeginGetRequestStream (callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override IAsyncResult ^ BeginGetRequestStream(AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="override this.BeginGetRequestStream : AsyncCallback * obj -&gt; IAsyncResult" Usage="ftpWebRequest.BeginGetRequestStream (callback, state)" />
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginGetRequestStream (AsyncCallback callback, object state);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="callback">一个 <see cref="T:System.AsyncCallback" /> 委托，它引用操作完成时要调用的方法。</param>
        <param name="state">一个用户定义对象，其中包含操作的相关信息。 操作完成时，此对象传递给 <paramref name="callback" /> 委托。</param>
        <summary>开始以异步方式打开请求的内容流以便写入。</summary>
        <returns><see cref="T:System.IAsyncResult" /> 实例，指示操作的状态。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 必须通过调用方法来完成异步操作 <xref:System.Net.FtpWebRequest.EndGetRequestStream%2A> 。 通常，由 <xref:System.Net.FtpWebRequest.EndGetRequestStream%2A> 引用的方法调用 `callback` 。 若要确定操作的状态，请检查 <xref:System.IAsyncResult> 由此方法返回的对象中的属性。  
  
 在等待流时，此方法不会被阻止。 若要阻止，请调用 <xref:System.Net.FtpWebRequest.GetRequestStream%2A> 以替换此方法。  
  
 有关使用异步编程模型的详细信息，请参阅 [以异步方式调用同步方法](/dotnet/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously)。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅 [.NET Framework 中的网络跟踪](/dotnet/framework/network-programming/network-tracing)。  
  
   
  
## Examples  
 下面的代码示例演示如何开始异步操作以获取请求的流。 此代码示例是为类概述提供的更大示例的一部分 <xref:System.Net.FtpWebRequest> 。  
  
 [!code-cpp[NCLFtpAsync#4](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLFtpAsync/CPP/async.cpp#4)]
 [!code-csharp[NCLFtpAsync#4](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLFtpAsync/CS/async.cs#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">此前对此方法或 <see cref="M:System.Net.FtpWebRequest.GetRequestStream" /> 的调用尚未完成。</exception>
        <exception cref="T:System.Net.WebException">未能建立到 FTP 服务器的连接。</exception>
        <exception cref="T:System.Net.ProtocolViolationException"><see cref="P:System.Net.FtpWebRequest.Method" /> 属性没有设置为 <see cref="F:System.Net.WebRequestMethods.Ftp.UploadFile" />。</exception>
        <block subset="none" type="usage"><para>此方法生成网络流量。</para></block>
        <altmember cref="T:System.Net.FtpWebResponse" />
        <altmember cref="T:System.Net.FtpStatusCode" />
        <altmember cref="T:System.Net.WebRequestMethods.Ftp" />
        <altmember cref="T:System.Net.WebRequest" />
        <altmember cref="T:System.Net.WebResponse" />
        <altmember cref="T:System.Net.WebClient" />
      </Docs>
    </Member>
    <Member MemberName="BeginGetResponse">
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginGetResponse (AsyncCallback? callback, object? state);" FrameworkAlternate="net-5.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IAsyncResult BeginGetResponse(class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.FtpWebRequest.BeginGetResponse(System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function BeginGetResponse (callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override IAsyncResult ^ BeginGetResponse(AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="override this.BeginGetResponse : AsyncCallback * obj -&gt; IAsyncResult" Usage="ftpWebRequest.BeginGetResponse (callback, state)" />
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginGetResponse (AsyncCallback callback, object state);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="callback">一个 <see cref="T:System.AsyncCallback" /> 委托，它引用操作完成时要调用的方法。</param>
        <param name="state">一个用户定义对象，其中包含操作的相关信息。 操作完成时，此对象传递给 <paramref name="callback" /> 委托。</param>
        <summary>开始以异步方式向 FTP 服务器发送请求并从 FTP 服务器接收响应。</summary>
        <returns><see cref="T:System.IAsyncResult" /> 实例，指示操作的状态。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 必须通过调用方法来完成异步操作 <xref:System.Net.FtpWebRequest.EndGetResponse%2A> 。 通常，由 <xref:System.Net.FtpWebRequest.EndGetResponse%2A> 引用的方法调用 `callback` 。 若要确定操作的状态，请检查方法返回的对象中的属性 <xref:System.IAsyncResult> <xref:System.Net.FtpWebRequest.BeginGetResponse%2A> 。  
  
 如果该 <xref:System.Net.FtpWebRequest.Proxy%2A> 属性是直接设置的，或者是在配置文件中设置的，则通过指定的代理建立与 FTP 服务器的通信。  
  
 <xref:System.Net.FtpWebRequest.BeginGetResponse%2A> 等待服务器的响应时不会阻止。 若要阻止，请调用 <xref:System.Net.FtpWebRequest.GetResponse%2A> 方法代替 <xref:System.Net.FtpWebRequest.BeginGetResponse%2A> 。  
  
 有关使用异步编程模型的详细信息，请参阅 [以异步方式调用同步方法](/dotnet/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously)。  
  
 当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅 [.NET Framework 中的网络跟踪](/dotnet/framework/network-programming/network-tracing)。  
  
> [!NOTE]
>  如果 <xref:System.Net.WebException> 引发了，则使用 <xref:System.Net.WebException.Response%2A> 异常的和 <xref:System.Net.WebException.Status%2A> 属性来确定来自服务器的响应。  
  
   
  
## Examples  
 下面的代码示例演示如何结束异步操作以获取请求的流，然后启动请求以获取响应。 此代码示例是为类概述提供的更大示例的一部分 <xref:System.Net.FtpWebRequest> 。  
  
 [!code-cpp[NCLFtpAsync#5](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLFtpAsync/CPP/async.cpp#5)]
 [!code-csharp[NCLFtpAsync#5](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLFtpAsync/CS/async.cs#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">已经为此实例调用了 <see cref="M:System.Net.FtpWebRequest.GetResponse" /> 或 <see cref="M:System.Net.FtpWebRequest.BeginGetResponse(System.AsyncCallback,System.Object)" />。</exception>
        <block subset="none" type="usage"><para>此方法生成网络流量。</para></block>
        <altmember cref="T:System.Net.FtpWebResponse" />
        <altmember cref="T:System.Net.FtpStatusCode" />
        <altmember cref="T:System.Net.WebRequestMethods.Ftp" />
        <altmember cref="T:System.Net.WebRequest" />
        <altmember cref="T:System.Net.WebResponse" />
        <altmember cref="T:System.Net.WebClient" />
      </Docs>
    </Member>
    <Member MemberName="ClientCertificates">
      <MemberSignature Language="C#" Value="public System.Security.Cryptography.X509Certificates.X509CertificateCollection ClientCertificates { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Cryptography.X509Certificates.X509CertificateCollection ClientCertificates" />
      <MemberSignature Language="DocId" Value="P:System.Net.FtpWebRequest.ClientCertificates" />
      <MemberSignature Language="VB.NET" Value="Public Property ClientCertificates As X509CertificateCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Cryptography::X509Certificates::X509CertificateCollection ^ ClientCertificates { System::Security::Cryptography::X509Certificates::X509CertificateCollection ^ get(); void set(System::Security::Cryptography::X509Certificates::X509CertificateCollection ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ClientCertificates : System.Security.Cryptography.X509Certificates.X509CertificateCollection with get, set" Usage="System.Net.FtpWebRequest.ClientCertificates" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.MonoTODO]</AttributeName>
          <AttributeName Language="F#">[&lt;System.MonoTODO&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.X509Certificates.X509CertificateCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取用于建立到 FTP 服务器的加密连接的证书。</summary>
        <value>包含客户端证书的 <see cref="T:System.Security.Cryptography.X509Certificates.X509CertificateCollection" /> 对象。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在初始 SSL 连接协商过程中，客户端证书用于对客户端进行身份验证。 有关详细信息，请参阅 <xref:System.Net.FtpWebRequest.EnableSsl%2A>。  
  
> [!NOTE]
>  .NET Framework 在创建 SSL 会话时将其缓存，并尝试为新请求重用缓存会话（如果可能）。 尝试重用 SSL 会话时，如果存在一个) ，则 .NET Framework 使用 (的第一个元素 <xref:System.Net.HttpWebRequest.ClientCertificates%2A> ，或者如果为空，则尝试重用匿名会话 <xref:System.Net.HttpWebRequest.ClientCertificates%2A> 。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">为集运算指定的值为 <see langword="null" />。</exception>
        <altmember cref="T:System.Net.FtpWebResponse" />
        <altmember cref="T:System.Net.FtpStatusCode" />
        <altmember cref="T:System.Net.WebRequestMethods.Ftp" />
        <altmember cref="T:System.Net.WebRequest" />
        <altmember cref="T:System.Net.WebResponse" />
        <altmember cref="T:System.Net.WebClient" />
      </Docs>
    </Member>
    <Member MemberName="ConnectionGroupName">
      <MemberSignature Language="C#" Value="public override string? ConnectionGroupName { get; set; }" FrameworkAlternate="net-5.0" />
      <MemberSignature Language="ILAsm" Value=".property instance string ConnectionGroupName" />
      <MemberSignature Language="DocId" Value="P:System.Net.FtpWebRequest.ConnectionGroupName" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property ConnectionGroupName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ ConnectionGroupName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ConnectionGroupName : string with get, set" Usage="System.Net.FtpWebRequest.ConnectionGroupName" />
      <MemberSignature Language="C#" Value="public override string ConnectionGroupName { get; set; }" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.MonoTODO]</AttributeName>
          <AttributeName Language="F#">[&lt;System.MonoTODO&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置连接组的名称，该连接组包含用于发送当前请求的服务点。</summary>
        <value>包含连接组名称的 <see cref="T:System.String" /> 值。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 连接组将一组请求与特定连接或连接集相关联。 连接组中的连接只能由同一应用程序域中的请求重复使用，前提是请求上的凭据相同，并且请求指定连接组名称。 如果请求未指定连接组名称，则可以使用与连接组不关联的任何已请求服务器的现有连接。 如果凭据不相同，则会关闭现有连接，必须重新对新请求进行身份验证。  
  
 使用连接组可以提高性能，因为这允许用户的所有请求重用使用用户凭据进行身份验证的连接。  
  
 <xref:System.Net.FtpWebRequest.ConnectionGroupName%2A>在调用 <xref:System.Net.FtpWebRequest.GetRequestStream%2A> 、、或方法之后更改属性将 <xref:System.Net.FtpWebRequest.BeginGetRequestStream%2A> <xref:System.Net.FtpWebRequest.GetResponse%2A> <xref:System.Net.FtpWebRequest.BeginGetResponse%2A> 导致 <xref:System.InvalidOperationException> 异常。  
  
   
  
## Examples  
 下面的代码示例检索此属性的值。  
  
 [!code-cpp[NCLFtpClient#16](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLFtpClient/CPP/ftptests.cpp#16)]
 [!code-csharp[NCLFtpClient#16](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLFtpClient/CS/ftptests.cs#16)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">对于一个已在进行的请求为此属性指定了一个新值。</exception>
        <altmember cref="T:System.Net.FtpWebResponse" />
        <altmember cref="T:System.Net.FtpStatusCode" />
        <altmember cref="T:System.Net.WebRequestMethods.Ftp" />
        <altmember cref="T:System.Net.WebRequest" />
        <altmember cref="T:System.Net.WebResponse" />
        <altmember cref="T:System.Net.WebClient" />
        <related type="Article" href="/dotnet/framework/network-programming/managing-connections">管理连接</related>
      </Docs>
    </Member>
    <Member MemberName="ContentLength">
      <MemberSignature Language="C#" Value="public override long ContentLength { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 ContentLength" />
      <MemberSignature Language="DocId" Value="P:System.Net.FtpWebRequest.ContentLength" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property ContentLength As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property long ContentLength { long get(); void set(long value); };" />
      <MemberSignature Language="F#" Value="member this.ContentLength : int64 with get, set" Usage="System.Net.FtpWebRequest.ContentLength" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置被 <see cref="T:System.Net.FtpWebRequest" /> 类忽略的值。</summary>
        <value>应忽略的 <see cref="T:System.Int64" /> 值。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.FtpWebRequest.ContentLength%2A>提供属性只是为了与和类的其他实现兼容 <xref:System.Net.WebRequest> <xref:System.Net.WebResponse> 。 没有理由使用 <xref:System.Net.FtpWebRequest.ContentLength%2A> 。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContentOffset">
      <MemberSignature Language="C#" Value="public long ContentOffset { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 ContentOffset" />
      <MemberSignature Language="DocId" Value="P:System.Net.FtpWebRequest.ContentOffset" />
      <MemberSignature Language="VB.NET" Value="Public Property ContentOffset As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long ContentOffset { long get(); void set(long value); };" />
      <MemberSignature Language="F#" Value="member this.ContentOffset : int64 with get, set" Usage="System.Net.FtpWebRequest.ContentOffset" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置请求所下载的文件的字节偏移量。</summary>
        <value>指定文件偏移量（以字节为单位）的 <see cref="T:System.Int64" /> 实例。 默认值为零。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.FtpWebRequest.ContentOffset%2A>从 FTP 服务器下载文件时设置属性。 此偏移量指示服务器文件中用于标记要下载的数据开始位置的位置。 偏移量指定为从文件开头开始的字节数;第一个字节的偏移量为零。  
  
 设置 <xref:System.Net.FtpWebRequest.ContentOffset%2A> 会导致将 <xref:System.Net.FtpWebRequest> 重新启动 (`REST`) 命令发送到服务器。 如果要将数据上传到服务器，则多数 FTP 服务器实现将忽略此命令。  
  
 <xref:System.Net.FtpWebRequest.ContentOffset%2A>在调用 <xref:System.Net.FtpWebRequest.GetRequestStream%2A> 、 <xref:System.Net.FtpWebRequest.BeginGetRequestStream%2A> 、或方法之后更改将 <xref:System.Net.FtpWebRequest.GetResponse%2A> <xref:System.Net.FtpWebRequest.BeginGetResponse%2A> 导致 <xref:System.InvalidOperationException> 异常。  
  
   
  
## Examples  
 下面的代码示例演示如何从服务器下载部分文件，并将下载的数据追加到本地文件。  
  
 [!code-cpp[NclFtpClient#7](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLFtpClient/CPP/ftptests.cpp#7)]
 [!code-csharp[NclFtpClient#7](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLFtpClient/CS/ftptests.cs#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">对于一个已在进行的请求为此属性指定了一个新值。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">为该属性指定的值小于 0。</exception>
        <altmember cref="T:System.Net.FtpWebResponse" />
        <altmember cref="T:System.Net.FtpStatusCode" />
        <altmember cref="T:System.Net.WebRequestMethods.Ftp" />
        <altmember cref="T:System.Net.WebRequest" />
        <altmember cref="T:System.Net.WebResponse" />
        <altmember cref="T:System.Net.WebClient" />
      </Docs>
    </Member>
    <Member MemberName="ContentType">
      <MemberSignature Language="C#" Value="public override string? ContentType { get; set; }" FrameworkAlternate="net-5.0" />
      <MemberSignature Language="ILAsm" Value=".property instance string ContentType" />
      <MemberSignature Language="DocId" Value="P:System.Net.FtpWebRequest.ContentType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property ContentType As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ ContentType { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ContentType : string with get, set" Usage="System.Net.FtpWebRequest.ContentType" />
      <MemberSignature Language="C#" Value="public override string ContentType { get; set; }" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>总是引发 <see cref="T:System.NotSupportedException" />。</summary>
        <value>总是引发 <see cref="T:System.NotSupportedException" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.FtpWebRequest.ContentType%2A>提供属性只是为了与和类的其他实现兼容 <xref:System.Net.WebRequest> <xref:System.Net.WebResponse> 。 没有理由使用 <xref:System.Net.FtpWebRequest.ContentType%2A> 。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">FTP 不支持内容类型信息。</exception>
      </Docs>
    </Member>
    <Member MemberName="Credentials">
      <MemberSignature Language="C#" Value="public override System.Net.ICredentials? Credentials { get; set; }" FrameworkAlternate="net-5.0" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.ICredentials Credentials" />
      <MemberSignature Language="DocId" Value="P:System.Net.FtpWebRequest.Credentials" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Credentials As ICredentials" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Net::ICredentials ^ Credentials { System::Net::ICredentials ^ get(); void set(System::Net::ICredentials ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Credentials : System.Net.ICredentials with get, set" Usage="System.Net.FtpWebRequest.Credentials" />
      <MemberSignature Language="C#" Value="public override System.Net.ICredentials Credentials { get; set; }" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.ICredentials</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置用于与 FTP 服务器通信的凭据。</summary>
        <value><see cref="T:System.Net.ICredentials" /> 实例；如果还未设置该属性，则为 <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用匿名登录进行连接时，不需要指定凭据。 必须 <xref:System.Net.FtpWebRequest.Credentials%2A> 通过使用类型的凭据来设置属性 <xref:System.Net.NetworkCredential> ; 这可以确保可读取和发送到服务器的用户名和密码。  
  
> [!CAUTION]
>  除非将属性设置为，否则传输到服务器时不会加密凭据信息 <xref:System.Net.FtpWebRequest.EnableSsl%2A> `true` 。  
  
 <xref:System.Net.FtpWebRequest.Credentials%2A>在调用 <xref:System.Net.FtpWebRequest.GetRequestStream%2A> 、 <xref:System.Net.FtpWebRequest.BeginGetRequestStream%2A> 、或方法之后更改将 <xref:System.Net.FtpWebRequest.GetResponse%2A> <xref:System.Net.FtpWebRequest.BeginGetResponse%2A> 导致 <xref:System.InvalidOperationException> 异常。  
  
   
  
## Examples  
 下面的代码示例检索此属性的值，并使用它来显示该用户名。  
  
 [!code-cpp[NCLFtpClient#14](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLFtpClient/CPP/ftptests.cpp#14)]
 [!code-csharp[NCLFtpClient#14](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLFtpClient/CS/ftptests.cs#14)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">为集运算指定的值为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">为 Set 操作指定了 <see cref="T:System.Net.ICredentials" /> 以外的 <see cref="T:System.Net.NetworkCredential" /> 类型。</exception>
        <exception cref="T:System.InvalidOperationException">对于一个已在进行的请求为此属性指定了一个新值。</exception>
        <altmember cref="T:System.Net.FtpWebResponse" />
        <altmember cref="T:System.Net.FtpStatusCode" />
        <altmember cref="T:System.Net.WebRequestMethods.Ftp" />
        <altmember cref="T:System.Net.WebRequest" />
        <altmember cref="T:System.Net.WebResponse" />
        <altmember cref="T:System.Net.WebClient" />
      </Docs>
    </Member>
    <Member MemberName="DefaultCachePolicy">
      <MemberSignature Language="C#" Value="public static System.Net.Cache.RequestCachePolicy? DefaultCachePolicy { get; set; }" FrameworkAlternate="net-5.0" />
      <MemberSignature Language="ILAsm" Value=".property class System.Net.Cache.RequestCachePolicy DefaultCachePolicy" />
      <MemberSignature Language="DocId" Value="P:System.Net.FtpWebRequest.DefaultCachePolicy" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property DefaultCachePolicy As RequestCachePolicy" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Net::Cache::RequestCachePolicy ^ DefaultCachePolicy { System::Net::Cache::RequestCachePolicy ^ get(); void set(System::Net::Cache::RequestCachePolicy ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DefaultCachePolicy : System.Net.Cache.RequestCachePolicy with get, set" Usage="System.Net.FtpWebRequest.DefaultCachePolicy" />
      <MemberSignature Language="C#" Value="public static System.Net.Cache.RequestCachePolicy DefaultCachePolicy { get; set; }" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinmac-3.0" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName Language="C#">[System.MonoTODO]</AttributeName>
          <AttributeName Language="F#">[&lt;System.MonoTODO&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.Cache.RequestCachePolicy</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>定义所有 FTP 请求的默认缓存策略。</summary>
        <value><see cref="T:System.Net.Cache.RequestCachePolicy" />，定义 FTP 请求的缓存策略。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 仅缓存使用命令接收的内容 <xref:System.Net.WebRequestMethods.Ftp.DownloadFile> 。  
  
 下表描述了 FTP 缓存策略对的影响 <xref:System.Net.FtpWebRequest> 。  
  
|策略|效果|  
|------------|------------|  
|<xref:System.Net.Cache.RequestCacheLevel.Default>|如果资源是最新的，则返回缓存的资源，内容长度准确，并且存在过期、修改和内容长度属性。|  
|<xref:System.Net.Cache.RequestCacheLevel.BypassCache>|从服务器返回资源。|  
|<xref:System.Net.Cache.RequestCacheLevel.CacheOnly>|如果内容长度存在并且与条目大小匹配，则返回缓存的资源;否则，将引发 <xref:System.Net.WebException> 。|  
|<xref:System.Net.Cache.RequestCacheLevel.CacheIfAvailable>|如果提供了内容长度并与条目大小匹配，则返回缓存的资源;否则，将从服务器下载资源，并将其返回给调用方。|  
|<xref:System.Net.Cache.RequestCacheLevel.Revalidate>|如果缓存资源的时间戳与服务器上资源的时间戳相同，则返回缓存的资源;否则，将从服务器下载资源，并将其存储在缓存中，并将其返回给调用方。|  
|<xref:System.Net.Cache.RequestCacheLevel.Reload>|从服务器下载资源，将其存储在缓存中，并将资源返回给调用方。|  
|<xref:System.Net.Cache.RequestCacheLevel.NoCacheNoStore>|如果缓存的资源存在，则将其删除。 从服务器下载资源，并将其返回给调用方。|  
  
> [!NOTE]
>  设置将 <xref:System.Net.FtpWebRequest.DefaultCachePolicy%2A> 替代任何配置设置。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">调用方尝试将此属性设置为 <see langword="null" />。</exception>
        <related type="Article" href="/dotnet/framework/configure-apps/file-schema/network/defaultftpcachepolicy-element-network-settings">defaultFtpCachePolicy (网络设置) </related>
      </Docs>
    </Member>
    <Member MemberName="EnableSsl">
      <MemberSignature Language="C#" Value="public bool EnableSsl { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableSsl" />
      <MemberSignature Language="DocId" Value="P:System.Net.FtpWebRequest.EnableSsl" />
      <MemberSignature Language="VB.NET" Value="Public Property EnableSsl As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EnableSsl { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnableSsl : bool with get, set" Usage="System.Net.FtpWebRequest.EnableSsl" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置 <see cref="T:System.Boolean" />，它指定是否使用 SSL 连接。</summary>
        <value>如果控制和数据传输是加密的，则为 <see langword="true" />；否则为 <see langword="false" />。 默认值是 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!CAUTION]
>  除非 <xref:System.Net.FtpWebRequest.EnableSsl%2A> 属性为 `true` ，否则所有数据和命令（包括你的用户名和密码信息）都将以明文形式发送到服务器。 监视网络流量的任何人都可以查看凭据并使用它们连接到服务器。 如果要连接到需要凭据并支持 SSL 的 FTP 服务器，则应将设置 <xref:System.Net.FtpWebRequest.EnableSsl%2A> 为 `true` 。  
  
 此 `"AUTH TLS"` 命令将发送到服务器以请求加密会话。 如果服务器无法识别此命令，将收到一个 <xref:System.Net.WebException> 异常。  
  
   
  
## Examples  
 下面的代码示例使用加密连接从 FTP 服务器下载目录列表。  
  
 [!code-cpp[NCLFtpClient#8](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLFtpClient/CPP/ftptests.cpp#8)]
 [!code-csharp[NCLFtpClient#8](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLFtpClient/CS/ftptests.cs#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">到 FTP 服务器的连接已经建立。</exception>
        <altmember cref="T:System.Net.FtpWebResponse" />
        <altmember cref="T:System.Net.FtpStatusCode" />
        <altmember cref="T:System.Net.WebRequestMethods.Ftp" />
        <altmember cref="T:System.Net.WebRequest" />
        <altmember cref="T:System.Net.WebResponse" />
        <altmember cref="T:System.Net.WebClient" />
      </Docs>
    </Member>
    <Member MemberName="EndGetRequestStream">
      <MemberSignature Language="C#" Value="public override System.IO.Stream EndGetRequestStream (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IO.Stream EndGetRequestStream(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.FtpWebRequest.EndGetRequestStream(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function EndGetRequestStream (asyncResult As IAsyncResult) As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::IO::Stream ^ EndGetRequestStream(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="override this.EndGetRequestStream : IAsyncResult -&gt; System.IO.Stream" Usage="ftpWebRequest.EndGetRequestStream asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">在操作开始时返回的 <see cref="T:System.IAsyncResult" /> 对象。</param>
        <summary>结束由 <see cref="M:System.Net.FtpWebRequest.BeginGetRequestStream(System.AsyncCallback,System.Object)" /> 启动的挂起的异步操作。</summary>
        <returns>与此实例关联的可写 <see cref="T:System.IO.Stream" /> 实例。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果操作尚未完成，则方法将被 <xref:System.Net.FtpWebRequest.EndGetRequestStream%2A> 阻止，直到操作完成。 若要确定操作是否已完成，请 <xref:System.IAsyncResult.IsCompleted%2A> 在调用前检查 <xref:System.Net.FtpWebRequest.EndGetRequestStream%2A> 属性。  
  
 除了 "异常" 中所述的异常之外，还会重新 <xref:System.Net.FtpWebRequest.EndGetRequestStream%2A> 引发打开要写入的流时引发的异常。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅 [.NET Framework 中的网络跟踪](/dotnet/framework/network-programming/network-tracing)。  
  
   
  
## Examples  
 下面的代码示例演示如何结束异步操作以获取请求的流。 此代码示例是为类概述提供的更大示例的一部分 <xref:System.Net.FtpWebRequest> 。  
  
 [!code-cpp[NCLFtpAsync#5](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLFtpAsync/CPP/async.cpp#5)]
 [!code-csharp[NCLFtpAsync#5](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLFtpAsync/CS/async.cs#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">未能通过调用 <see cref="M:System.Net.FtpWebRequest.BeginGetRequestStream(System.AsyncCallback,System.Object)" /> 获取 <paramref name="asyncResult" />。</exception>
        <exception cref="T:System.InvalidOperationException">已为 <paramref name="asyncResult" /> 标识的操作调用了此方法。</exception>
        <altmember cref="T:System.Net.FtpWebResponse" />
        <altmember cref="T:System.Net.FtpStatusCode" />
        <altmember cref="T:System.Net.WebRequestMethods.Ftp" />
        <altmember cref="T:System.Net.WebRequest" />
        <altmember cref="T:System.Net.WebResponse" />
        <altmember cref="T:System.Net.WebClient" />
      </Docs>
    </Member>
    <Member MemberName="EndGetResponse">
      <MemberSignature Language="C#" Value="public override System.Net.WebResponse EndGetResponse (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Net.WebResponse EndGetResponse(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.FtpWebRequest.EndGetResponse(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function EndGetResponse (asyncResult As IAsyncResult) As WebResponse" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Net::WebResponse ^ EndGetResponse(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="override this.EndGetResponse : IAsyncResult -&gt; System.Net.WebResponse" Usage="ftpWebRequest.EndGetResponse asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.WebResponse</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">在操作开始时返回的 <see cref="T:System.IAsyncResult" />。</param>
        <summary>结束由 <see cref="M:System.Net.FtpWebRequest.BeginGetResponse(System.AsyncCallback,System.Object)" /> 启动的挂起的异步操作。</summary>
        <returns>包含一个 <see cref="T:System.Net.FtpWebResponse" /> 实例的 <see cref="T:System.Net.WebResponse" /> 引用。 此对象包含 FTP 服务器对请求的响应。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果在调用方法时操作尚未完成，则 <xref:System.Net.FtpWebRequest.EndGetResponse%2A> 会 <xref:System.Net.FtpWebRequest.EndGetResponse%2A> 阻止操作完成。 若要防止阻塞，请 <xref:System.IAsyncResult.IsCompleted%2A> 在调用前检查属性 <xref:System.Net.FtpWebRequest.EndGetResponse%2A> 。  
  
 除了 "异常" 中所述的异常，还会重新 <xref:System.Net.FtpWebRequest.EndGetResponse%2A> 引发与服务器通信时引发的异常。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅 [.NET Framework 中的网络跟踪](/dotnet/framework/network-programming/network-tracing)。  
  
   
  
## Examples  
 下面的代码示例演示如何结束异步操作以获取响应。 此代码示例是为类概述提供的更大示例的一部分 <xref:System.Net.FtpWebRequest> 。  
  
 [!code-cpp[NCLFtpAsync#6](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLFtpAsync/CPP/async.cpp#6)]
 [!code-csharp[NCLFtpAsync#6](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLFtpAsync/CS/async.cs#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">未能通过调用 <see cref="M:System.Net.FtpWebRequest.BeginGetResponse(System.AsyncCallback,System.Object)" /> 获取 <paramref name="asyncResult" />。</exception>
        <exception cref="T:System.InvalidOperationException">已为 <paramref name="asyncResult" /> 标识的操作调用了此方法。</exception>
        <exception cref="T:System.Net.WebException">使用 HTTP 代理时出错。</exception>
        <block subset="none" type="usage"><para>此方法生成网络流量。</para></block>
        <altmember cref="T:System.Net.FtpWebResponse" />
        <altmember cref="T:System.Net.FtpStatusCode" />
        <altmember cref="T:System.Net.WebRequestMethods.Ftp" />
        <altmember cref="T:System.Net.WebRequest" />
        <altmember cref="T:System.Net.WebResponse" />
        <altmember cref="T:System.Net.WebClient" />
        <altmember cref="M:System.Net.FtpWebRequest.GetResponse" />
      </Docs>
    </Member>
    <Member MemberName="GetRequestStream">
      <MemberSignature Language="C#" Value="public override System.IO.Stream GetRequestStream ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IO.Stream GetRequestStream() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.FtpWebRequest.GetRequestStream" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetRequestStream () As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::IO::Stream ^ GetRequestStream();" />
      <MemberSignature Language="F#" Value="override this.GetRequestStream : unit -&gt; System.IO.Stream" Usage="ftpWebRequest.GetRequestStream " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>检索用于向 FTP 服务器上载数据的流。</summary>
        <returns>可写 <see cref="T:System.IO.Stream" /> 实例，用于存储要由当前请求发送到服务器的数据。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在调用方法之前设置请求属性 <xref:System.Net.FtpWebRequest.GetRequestStream%2A> 。 将数据写入流后，必须在发送请求前关闭流。  
  
 如果未将 <xref:System.Net.FtpWebRequest.Method%2A> 属性设置为 <xref:System.Net.WebRequestMethods.Ftp.UploadFile> 或 <xref:System.Net.WebRequestMethods.Ftp.AppendFile> ，则无法获取该流。  
  
 <xref:System.Net.FtpWebRequest.GetRequestStream%2A> 等待流时阻止。 若要防止出现这种情况，请调用 <xref:System.Net.FtpWebRequest.BeginGetRequestStream%2A> 方法代替 <xref:System.Net.FtpWebRequest.GetRequestStream%2A> 。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅 [.NET Framework 中的网络跟踪](/dotnet/framework/network-programming/network-tracing)。  
  
   
  
## Examples  
 下面的代码示例演示如何将文件复制到请求的数据流，以及如何将请求发送到服务器以上载数据并将其追加到文件中。  
  
 [!code-cpp[NCLFtpClient#3](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLFtpClient/CPP/ftptests.cpp#3)]
 [!code-csharp[NCLFtpClient#3](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLFtpClient/CS/ftptests.cs#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="M:System.Net.FtpWebRequest.BeginGetRequestStream(System.AsyncCallback,System.Object)" /> 已被调用并且尚未完成。  
  
- 或 - 
HTTP 代理被启用，而您尝试使用 FTP 命令而非 <see cref="F:System.Net.WebRequestMethods.Ftp.DownloadFile" />、<see cref="F:System.Net.WebRequestMethods.Ftp.ListDirectory" /> 或 <see cref="F:System.Net.WebRequestMethods.Ftp.ListDirectoryDetails" />。</exception>
        <exception cref="T:System.Net.WebException">未能建立到 FTP 服务器的连接。</exception>
        <exception cref="T:System.Net.ProtocolViolationException"><see cref="P:System.Net.FtpWebRequest.Method" /> 属性未设置为 <see cref="F:System.Net.WebRequestMethods.Ftp.UploadFile" /> 或 <see cref="F:System.Net.WebRequestMethods.Ftp.AppendFile" />。</exception>
        <block subset="none" type="usage"><para>此方法生成网络流量。</para></block>
        <altmember cref="T:System.Net.FtpWebResponse" />
        <altmember cref="T:System.Net.FtpStatusCode" />
        <altmember cref="T:System.Net.WebRequestMethods.Ftp" />
        <altmember cref="T:System.Net.WebRequest" />
        <altmember cref="T:System.Net.WebResponse" />
        <altmember cref="T:System.Net.WebClient" />
      </Docs>
    </Member>
    <Member MemberName="GetResponse">
      <MemberSignature Language="C#" Value="public override System.Net.WebResponse GetResponse ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Net.WebResponse GetResponse() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.FtpWebRequest.GetResponse" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetResponse () As WebResponse" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Net::WebResponse ^ GetResponse();" />
      <MemberSignature Language="F#" Value="override this.GetResponse : unit -&gt; System.Net.WebResponse" Usage="ftpWebRequest.GetResponse " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.WebResponse</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回 FTP 服务器响应。</summary>
        <returns>包含一个 <see cref="T:System.Net.FtpWebResponse" /> 实例的 <see cref="T:System.Net.WebResponse" /> 引用。 此对象包含 FTP 服务器对请求的响应。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要访问特定于 FTP 的属性，必须将 <xref:System.Net.WebResponse> 此方法返回的对象强制转换为 <xref:System.Net.FtpWebResponse> 。  
  
 <xref:System.Net.FtpWebRequest.GetResponse%2A> 导致建立控制连接，并且还可能会创建数据连接。 <xref:System.Net.FtpWebRequest.GetResponse%2A> 阻止，直到收到响应。 若要防止出现这种情况，可以通过调用 <xref:System.Net.FtpWebRequest.BeginGetResponse%2A> 和方法替换来异步执行此操作 <xref:System.Net.FtpWebRequest.EndGetResponse%2A> <xref:System.Net.FtpWebRequest.GetResponse%2A> 。  
  
 如果该 <xref:System.Net.FtpWebRequest.Proxy%2A> 属性是直接设置的，或者是在配置文件中设置的，则通过代理建立与 FTP 服务器的通信。  
  
 如果 <xref:System.Net.WebException> 引发了，则使用 <xref:System.Net.WebException.Response%2A> 异常的和 <xref:System.Net.WebException.Status%2A> 属性来确定来自服务器的响应。  
  
 当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅 [.NET Framework 中的网络跟踪](/dotnet/framework/network-programming/network-tracing)。  
  
> [!NOTE]
>  多次调用将 <xref:System.Net.FtpWebRequest.GetResponse%2A> 返回相同的响应对象; 不会重新发出该请求。  
  
   
  
## Examples  
 下面的代码示例演示如何将文件复制到请求的数据流，以及如何将请求发送到向服务器追加数据。 该示例调用 <xref:System.Net.FtpWebRequest.GetResponse%2A> 发送请求，并阻止服务器返回响应。  
  
 [!code-cpp[NCLFtpClient#3](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLFtpClient/CPP/ftptests.cpp#3)]
 [!code-csharp[NCLFtpClient#3](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLFtpClient/CS/ftptests.cs#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">已经为此实例调用了 <see cref="M:System.Net.FtpWebRequest.GetResponse" /> 或 <see cref="M:System.Net.FtpWebRequest.BeginGetResponse(System.AsyncCallback,System.Object)" />。  
  
- 或 - 
HTTP 代理被启用，而您尝试使用 FTP 命令而非 <see cref="F:System.Net.WebRequestMethods.Ftp.DownloadFile" />、<see cref="F:System.Net.WebRequestMethods.Ftp.ListDirectory" /> 或 <see cref="F:System.Net.WebRequestMethods.Ftp.ListDirectoryDetails" />。</exception>
        <exception cref="T:System.Net.WebException"><see cref="P:System.Net.FtpWebRequest.EnableSsl" /> 设置为 <see langword="true" />，但服务器不支持此功能。  
  
- 或 - 
<see cref="P:System.Net.FtpWebRequest.Timeout" /> 已指定，且已超时。</exception>
        <block subset="none" type="usage"><para>此方法生成网络流量。</para></block>
        <altmember cref="T:System.Net.FtpWebResponse" />
        <altmember cref="T:System.Net.FtpStatusCode" />
        <altmember cref="T:System.Net.WebRequestMethods.Ftp" />
        <altmember cref="T:System.Net.WebRequest" />
        <altmember cref="T:System.Net.WebResponse" />
        <altmember cref="T:System.Net.WebClient" />
      </Docs>
    </Member>
    <Member MemberName="Headers">
      <MemberSignature Language="C#" Value="public override System.Net.WebHeaderCollection Headers { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.WebHeaderCollection Headers" />
      <MemberSignature Language="DocId" Value="P:System.Net.FtpWebRequest.Headers" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Headers As WebHeaderCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Net::WebHeaderCollection ^ Headers { System::Net::WebHeaderCollection ^ get(); void set(System::Net::WebHeaderCollection ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Headers : System.Net.WebHeaderCollection with get, set" Usage="System.Net.FtpWebRequest.Headers" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.MonoTODO]</AttributeName>
          <AttributeName Language="F#">[&lt;System.MonoTODO&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.WebHeaderCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取空 <see cref="T:System.Net.WebHeaderCollection" /> 对象。</summary>
        <value>空的 <see cref="T:System.Net.WebHeaderCollection" /> 对象。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.FtpWebRequest.Headers%2A>提供属性只是为了与和类的其他实现兼容 <xref:System.Net.WebRequest> <xref:System.Net.WebResponse> 。 没有理由使用 <xref:System.Net.FtpWebRequest.Headers%2A> 。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="KeepAlive">
      <MemberSignature Language="C#" Value="public bool KeepAlive { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool KeepAlive" />
      <MemberSignature Language="DocId" Value="P:System.Net.FtpWebRequest.KeepAlive" />
      <MemberSignature Language="VB.NET" Value="Public Property KeepAlive As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool KeepAlive { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.KeepAlive : bool with get, set" Usage="System.Net.FtpWebRequest.KeepAlive" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.MonoTODO("We don't support KeepAlive = true")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.MonoTODO("We don't support KeepAlive = true")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个 <see cref="T:System.Boolean" /> 值，该值指定在请求完成之后是否关闭到 FTP 服务器的控制连接。</summary>
        <value>如果不应销毁到服务器的连接，则为 <see langword="true" />；否则为 <see langword="false" />。 默认值是 <see langword="true" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当 <xref:System.Net.FtpWebRequest.KeepAlive%2A> 属性设置为时，将在 `false` 调用方法时关闭控件连接 <xref:System.Net.FtpWebResponse.Close%2A> 。  
  
 <xref:System.Net.FtpWebRequest.KeepAlive%2A>在调用 <xref:System.Net.FtpWebRequest.GetRequestStream%2A> 、 <xref:System.Net.FtpWebRequest.BeginGetRequestStream%2A> 、或方法之后更改将 <xref:System.Net.FtpWebRequest.GetResponse%2A> <xref:System.Net.FtpWebRequest.BeginGetResponse%2A> 导致 <xref:System.InvalidOperationException> 异常。  
  
   
  
## Examples  
 下面的代码示例检索并显示指定的对象的属性值 <xref:System.Net.FtpWebRequest> 。  
  
 [!code-cpp[NCLFtpClient#15](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLFtpClient/CPP/ftptests.cpp#15)]
 [!code-csharp[NCLFtpClient#15](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLFtpClient/CS/ftptests.cs#15)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">对于一个已在进行的请求为此属性指定了一个新值。</exception>
        <altmember cref="T:System.Net.FtpWebResponse" />
        <altmember cref="T:System.Net.FtpStatusCode" />
        <altmember cref="T:System.Net.WebRequestMethods.Ftp" />
        <altmember cref="T:System.Net.WebRequest" />
        <altmember cref="T:System.Net.WebResponse" />
        <altmember cref="T:System.Net.WebClient" />
      </Docs>
    </Member>
    <Member MemberName="Method">
      <MemberSignature Language="C#" Value="public override string Method { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Method" />
      <MemberSignature Language="DocId" Value="P:System.Net.FtpWebRequest.Method" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Method As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Method { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Method : string with get, set" Usage="System.Net.FtpWebRequest.Method" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置要发送到 FTP 服务器的命令。</summary>
        <value><see cref="T:System.String" /> 值，包含要发送到服务器的 FTP 命令。 默认值是 <see cref="F:System.Net.WebRequestMethods.Ftp.DownloadFile" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.FtpWebRequest.Method%2A>属性确定将哪个命令发送到服务器。 您可以 <xref:System.Net.FtpWebRequest.Method%2A> 使用类的公共字段成员中定义的字符串来设置 <xref:System.Net.WebRequestMethods.Ftp> 。 请注意，在类中定义的字符串 <xref:System.Net.WebRequestMethods.Ftp> 是唯一受支持的 <xref:System.Net.FtpWebRequest.Method%2A> 属性选项。 <xref:System.Net.FtpWebRequest.Method%2A>将属性设置为任何其他值将导致 <xref:System.ArgumentException> 异常。  
  
 如果将设置 <xref:System.Net.FtpWebRequest.Method%2A> 为 <xref:System.Net.WebRequestMethods.Ftp.UploadFile> ，则必须在调用方法之前执行此操作 <xref:System.Net.FtpWebRequest.GetRequestStream%2A> 。 如果未能按正确的顺序调用这些成员，则会在 <xref:System.Net.ProtocolViolationException> 你尝试获取请求流时引发异常。  
  
 为对象提供的凭据 <xref:System.Net.FtpWebRequest> 必须具有执行指定方法的权限。 否则，FTP 命令将失败。  
  
 若要确定命令是成功还是失败，请检查 <xref:System.Net.FtpWebResponse.StatusCode%2A> 和 <xref:System.Net.FtpWebResponse.StatusDescription%2A> 属性。  
  
   
  
## Examples  
 下面的代码示例将此属性设置为 <xref:System.Net.WebRequestMethods.Ftp.DeleteFile> 。  
  
 [!code-cpp[NCLFtpClient#4](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLFtpClient/CPP/ftptests.cpp#4)]
 [!code-csharp[NCLFtpClient#4](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLFtpClient/CS/ftptests.cs#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">对于一个已在进行的请求为此属性指定了一个新值。</exception>
        <exception cref="T:System.ArgumentException">此方法无效。  
  
- 或 -
  
 不支持该方法。  
  
- 或 -
  
 指定了多个方法。</exception>
        <altmember cref="T:System.Net.FtpWebResponse" />
        <altmember cref="T:System.Net.FtpStatusCode" />
        <altmember cref="T:System.Net.WebRequestMethods.Ftp" />
        <altmember cref="T:System.Net.WebRequest" />
        <altmember cref="T:System.Net.WebResponse" />
        <altmember cref="T:System.Net.WebClient" />
      </Docs>
    </Member>
    <Member MemberName="PreAuthenticate">
      <MemberSignature Language="C#" Value="public override bool PreAuthenticate { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool PreAuthenticate" />
      <MemberSignature Language="DocId" Value="P:System.Net.FtpWebRequest.PreAuthenticate" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property PreAuthenticate As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool PreAuthenticate { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.PreAuthenticate : bool with get, set" Usage="System.Net.FtpWebRequest.PreAuthenticate" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>总是引发 <see cref="T:System.NotSupportedException" />。</summary>
        <value>总是引发 <see cref="T:System.NotSupportedException" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.FtpWebRequest.PreAuthenticate%2A>提供属性只是为了与和类的其他实现兼容 <xref:System.Net.WebRequest> <xref:System.Net.WebResponse> 。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">FTP 不支持预身份验证。</exception>
      </Docs>
    </Member>
    <Member MemberName="Proxy">
      <MemberSignature Language="C#" Value="public override System.Net.IWebProxy? Proxy { get; set; }" FrameworkAlternate="net-5.0" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.IWebProxy Proxy" />
      <MemberSignature Language="DocId" Value="P:System.Net.FtpWebRequest.Proxy" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Proxy As IWebProxy" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Net::IWebProxy ^ Proxy { System::Net::IWebProxy ^ get(); void set(System::Net::IWebProxy ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Proxy : System.Net.IWebProxy with get, set" Usage="System.Net.FtpWebRequest.Proxy" />
      <MemberSignature Language="C#" Value="public override System.Net.IWebProxy Proxy { get; set; }" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.IWebProxy</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置用于与 FTP 服务器通信的代理。</summary>
        <value>负责与 FTP 服务器通信的 <see cref="T:System.Net.IWebProxy" /> 实例。 在 .NET Core 中，其值为 <see langword="null" /> 。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

### <a name="on-net-framework"></a>.NET Framework 上

 <xref:System.Net.FtpWebRequest.Proxy%2A>属性标识 <xref:System.Net.IWebProxy> 与 FTP 服务器通信的实例。 代理由系统通过使用配置文件和 Internet Explorer 局域网设置进行设置。 若要指定不应使用代理，请将设置 <xref:System.Net.FtpWebRequest.Proxy%2A> 为方法返回的代理实例 <xref:System.Net.GlobalProxySelection.GetEmptyWebProxy%2A?displayProperty=nameWithType> 。 有关自动代理检测的详细信息，请参阅 [自动代理检测](/dotnet/framework/network-programming/automatic-proxy-detection)。  
  
 在将 <xref:System.Net.FtpWebRequest.Proxy%2A> 数据写入请求的流或获取响应之前，必须设置。 <xref:System.Net.FtpWebRequest.Proxy%2A>在调用 <xref:System.Net.FtpWebRequest.GetRequestStream%2A> 、 <xref:System.Net.FtpWebRequest.BeginGetRequestStream%2A> 、或方法之后更改将 <xref:System.Net.FtpWebRequest.GetResponse%2A> <xref:System.Net.FtpWebRequest.BeginGetResponse%2A> 导致 <xref:System.InvalidOperationException> 异常。  
  
 <xref:System.Net.FtpWebRequest>类支持 HTTP 和 ISA 防火墙客户端代理。  
  
 如果指定的代理是 HTTP 代理，则仅 <xref:System.Net.WebRequestMethods.Ftp.DownloadFile> 支持、 <xref:System.Net.WebRequestMethods.Ftp.ListDirectory> 和 <xref:System.Net.WebRequestMethods.Ftp.ListDirectoryDetails> 命令。  
  
### <a name="on-net-core"></a>.NET Core 上的   

`FtpWebRequest.Proxy`不支持该属性。 设置属性不起作用。 获取属性值返回 `null` 。 


## Examples  
 下面的代码示例显示此属性值。  
  
 [!code-cpp[NCLFtpClient#16](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLFtpClient/CPP/ftptests.cpp#16)]
 [!code-csharp[NCLFtpClient#16](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLFtpClient/CS/ftptests.cs#16)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">此属性不能设置为 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">对于一个已在进行的请求为此属性指定了一个新值。</exception>
        <altmember cref="T:System.Net.FtpWebResponse" />
        <altmember cref="T:System.Net.FtpStatusCode" />
        <altmember cref="T:System.Net.WebRequestMethods.Ftp" />
        <altmember cref="T:System.Net.WebRequest" />
        <altmember cref="T:System.Net.WebResponse" />
        <altmember cref="T:System.Net.WebClient" />
        <altmember cref="T:System.Net.WebProxy" />
        <altmember cref="T:System.Net.GlobalProxySelection" />
      </Docs>
    </Member>
    <Member MemberName="ReadWriteTimeout">
      <MemberSignature Language="C#" Value="public int ReadWriteTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ReadWriteTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Net.FtpWebRequest.ReadWriteTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Property ReadWriteTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ReadWriteTimeout { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.ReadWriteTimeout : int with get, set" Usage="System.Net.FtpWebRequest.ReadWriteTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置写入或读取流时的超时。</summary>
        <value>读取或写入超时之前的毫秒数。默认值为300000毫秒 (5 分钟) 。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.FtpWebRequest.ReadWriteTimeout%2A>当写入由方法返回的流 <xref:System.Net.FtpWebRequest.GetRequestStream%2A> 或从方法返回的流中读取时，将使用 <xref:System.Net.FtpWebResponse.GetResponseStream%2A> 。  
  
 具体而言， <xref:System.Net.FtpWebRequest.ReadWriteTimeout%2A> 属性控制方法的超时时间，该 <xref:System.IO.Stream.Read%2A> 方法用于读取方法返回的流 <xref:System.Net.FtpWebResponse.GetResponseStream%2A> ，为用于 <xref:System.IO.Stream.Write%2A> 写入方法返回的流的方法进行读取 <xref:System.Net.FtpWebRequest.GetRequestStream%2A> 。 如果超过超时期限，则调用方法会引发， <xref:System.Net.WebException> 并 <xref:System.Net.WebExceptionStatus> 将设置为 <xref:System.Net.WebExceptionStatus.Timeout> 。  
  
 若要指定等待请求完成的时间量，请使用 <xref:System.Net.FtpWebRequest.Timeout%2A> 属性。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">已发送请求。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">为 Set 操作指定的值小于或等于零，并且不等于 <see cref="F:System.Threading.Timeout.Infinite" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="RenameTo">
      <MemberSignature Language="C#" Value="public string? RenameTo { get; set; }" FrameworkAlternate="net-5.0" />
      <MemberSignature Language="ILAsm" Value=".property instance string RenameTo" />
      <MemberSignature Language="DocId" Value="P:System.Net.FtpWebRequest.RenameTo" />
      <MemberSignature Language="VB.NET" Value="Public Property RenameTo As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ RenameTo { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.RenameTo : string with get, set" Usage="System.Net.FtpWebRequest.RenameTo" />
      <MemberSignature Language="C#" Value="public string RenameTo { get; set; }" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置重命名文件的新名称。</summary>
        <value>重命名文件的新名称。</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">为 Set 操作指定的值为 <see langword="null" /> 或是空字符串。</exception>
        <exception cref="T:System.InvalidOperationException">对于一个已在进行的请求为此属性指定了一个新值。</exception>
      </Docs>
    </Member>
    <Member MemberName="RequestUri">
      <MemberSignature Language="C#" Value="public override Uri RequestUri { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Uri RequestUri" />
      <MemberSignature Language="DocId" Value="P:System.Net.FtpWebRequest.RequestUri" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property RequestUri As Uri" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Uri ^ RequestUri { Uri ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.RequestUri : Uri" Usage="System.Net.FtpWebRequest.RequestUri" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Uri</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取此实例所请求的 URI。</summary>
        <value><see cref="T:System.Uri" /> 实例，标识使用文件传输协议访问的资源。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 属性的值 <xref:System.Net.FtpWebRequest.RequestUri%2A> 是在 <xref:System.Net.WebRequest.Create%2A> 调用方法获取此实例时指定的 URI。  
  
   
  
## Examples  
 下面的代码示例显示此属性值。  
  
 [!code-cpp[NCLFtpClient#14](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLFtpClient/CPP/ftptests.cpp#14)]
 [!code-csharp[NCLFtpClient#14](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLFtpClient/CS/ftptests.cs#14)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.FtpWebResponse" />
        <altmember cref="T:System.Net.FtpStatusCode" />
        <altmember cref="T:System.Net.WebRequestMethods.Ftp" />
        <altmember cref="T:System.Net.WebRequest" />
        <altmember cref="T:System.Net.WebResponse" />
        <altmember cref="T:System.Net.WebClient" />
      </Docs>
    </Member>
    <Member MemberName="ServicePoint">
      <MemberSignature Language="C#" Value="public System.Net.ServicePoint ServicePoint { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.ServicePoint ServicePoint" />
      <MemberSignature Language="DocId" Value="P:System.Net.FtpWebRequest.ServicePoint" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ServicePoint As ServicePoint" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::ServicePoint ^ ServicePoint { System::Net::ServicePoint ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ServicePoint : System.Net.ServicePoint" Usage="System.Net.FtpWebRequest.ServicePoint" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.ServicePoint</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取用于连接 FTP 服务器的 <see cref="T:System.Net.ServicePoint" /> 对象。</summary>
        <value>可用于自定义连接行为的 <see cref="T:System.Net.ServicePoint" /> 对象。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果 <xref:System.Net.ServicePoint> 对象不存在，则为 FTP 服务器创建一个。 若要设置可为 FTP 服务器打开的最大连接数，请设置 <xref:System.Net.ServicePoint.ConnectionLimit%2A> <xref:System.Net.ServicePoint> 此属性返回的实例的属性。  
  
   
  
## Examples  
 下面的代码示例从请求中检索服务点，并将最大连接数设置为1。  
  
 [!code-cpp[NCLFtpClient#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLFtpClient/CPP/ftptests.cpp#1)]
 [!code-csharp[NCLFtpClient#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLFtpClient/CS/ftptests.cs#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.FtpWebResponse" />
        <altmember cref="T:System.Net.FtpStatusCode" />
        <altmember cref="T:System.Net.WebRequestMethods.Ftp" />
        <altmember cref="T:System.Net.WebRequest" />
        <altmember cref="T:System.Net.WebResponse" />
        <altmember cref="T:System.Net.WebClient" />
      </Docs>
    </Member>
    <Member MemberName="Timeout">
      <MemberSignature Language="C#" Value="public override int Timeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Timeout" />
      <MemberSignature Language="DocId" Value="P:System.Net.FtpWebRequest.Timeout" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Timeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int Timeout { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.Timeout : int with get, set" Usage="System.Net.FtpWebRequest.Timeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置等待请求的毫秒数。</summary>
        <value>一个 <see cref="T:System.Int32" /> 值，该值包含请求超时前等待的毫秒数。默认值为 <see cref="F:System.Threading.Timeout.Infinite" /> 。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要指定无限值，请将 <xref:System.Net.FtpWebRequest.Timeout%2A> 属性设置为 <xref:System.Threading.Timeout.Infinite> (-1) 。 这是默认值。  
  
 <xref:System.Net.FtpWebRequest.Timeout%2A> 使用方法发出的同步请求 <xref:System.Net.FtpWebRequest.GetResponse%2A> 等待响应并且该 <xref:System.Net.FtpWebRequest.GetRequestStream%2A> 方法等待流的毫秒数。 如果资源在超时期限内未响应，则该请求将引发，并将 <xref:System.Net.WebException> <xref:System.Net.WebException.Status%2A> 属性设置为 <xref:System.Net.WebExceptionStatus.Timeout> 。  
  
 <xref:System.Net.FtpWebRequest.Timeout%2A>在调用 <xref:System.Net.FtpWebRequest.GetRequestStream%2A> 、 <xref:System.Net.FtpWebRequest.BeginGetRequestStream%2A> 、或方法之后更改将 <xref:System.Net.FtpWebRequest.GetResponse%2A> <xref:System.Net.FtpWebRequest.BeginGetResponse%2A> 导致 <xref:System.InvalidOperationException> 异常。  
  
 域名系统 (DNS) 查询可能需要长达15秒钟的时间来返回或超时。如果你的请求包含需要解析的主机名，并且你将其设置 <xref:System.Net.FtpWebRequest.Timeout%2A> 为小于15秒的值，则可能需要15秒或更长时间，然后才会 <xref:System.Net.WebException> 引发以指示请求超时。  
  
   
  
## Examples  
 下面的代码示例设置此属性。  
  
 [!code-cpp[NCLFtpClient#23](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLFtpClient/CPP/ftptests.cpp#23)]
 [!code-csharp[NCLFtpClient#23](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLFtpClient/CS/ftptests.cs#23)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">指定的值是小于零，且不是 <see cref="F:System.Threading.Timeout.Infinite" />。</exception>
        <exception cref="T:System.InvalidOperationException">对于一个已在进行的请求为此属性指定了一个新值。</exception>
        <altmember cref="T:System.Net.FtpWebResponse" />
        <altmember cref="T:System.Net.FtpStatusCode" />
        <altmember cref="T:System.Net.WebRequestMethods.Ftp" />
        <altmember cref="T:System.Net.WebRequest" />
        <altmember cref="T:System.Net.WebResponse" />
        <altmember cref="T:System.Net.WebClient" />
      </Docs>
    </Member>
    <Member MemberName="UseBinary">
      <MemberSignature Language="C#" Value="public bool UseBinary { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseBinary" />
      <MemberSignature Language="DocId" Value="P:System.Net.FtpWebRequest.UseBinary" />
      <MemberSignature Language="VB.NET" Value="Public Property UseBinary As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UseBinary { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UseBinary : bool with get, set" Usage="System.Net.FtpWebRequest.UseBinary" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个 <see cref="T:System.Boolean" /> 值，该值指定文件传输的数据类型。</summary>
        <value><see langword="true" />，指示服务器要传输的是二进制数据；<see langword="false" />，指示数据为文本。 默认值是 <see langword="true" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果要发送二进制数据（如图像），请将此属性设置为 `true` 。 如果要发送文本，请将属性设置为 `false` 。 如果指定， `true` 则会将 <xref:System.Net.FtpWebRequest> `"TYPE I"` 命令发送到服务器。 如果指定， `false` 则会将 <xref:System.Net.FtpWebRequest> `"Type A"` 命令发送到服务器。 FTP 服务器可以忽略这些命令。  
  
 <xref:System.Net.FtpWebRequest.UseBinary%2A>在调用 <xref:System.Net.FtpWebRequest.GetRequestStream%2A> 、 <xref:System.Net.FtpWebRequest.BeginGetRequestStream%2A> 、或方法之后更改将 <xref:System.Net.FtpWebRequest.GetResponse%2A> <xref:System.Net.FtpWebRequest.BeginGetResponse%2A> 导致 <xref:System.InvalidOperationException> 异常。  
  
   
  
## Examples  
 下面的代码示例检索并显示指定的对象的属性值 <xref:System.Net.FtpWebRequest> 。  
  
 [!code-cpp[NCLFtpClient#15](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLFtpClient/CPP/ftptests.cpp#15)]
 [!code-csharp[NCLFtpClient#15](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLFtpClient/CS/ftptests.cs#15)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">对于一个已在进行的请求为此属性指定了一个新值。</exception>
        <altmember cref="T:System.Net.FtpWebResponse" />
        <altmember cref="T:System.Net.FtpStatusCode" />
        <altmember cref="T:System.Net.WebRequestMethods.Ftp" />
        <altmember cref="T:System.Net.WebRequest" />
        <altmember cref="T:System.Net.WebResponse" />
        <altmember cref="T:System.Net.WebClient" />
      </Docs>
    </Member>
    <Member MemberName="UseDefaultCredentials">
      <MemberSignature Language="C#" Value="public override bool UseDefaultCredentials { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseDefaultCredentials" />
      <MemberSignature Language="DocId" Value="P:System.Net.FtpWebRequest.UseDefaultCredentials" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property UseDefaultCredentials As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool UseDefaultCredentials { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UseDefaultCredentials : bool with get, set" Usage="System.Net.FtpWebRequest.UseDefaultCredentials" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.MonoTODO]</AttributeName>
          <AttributeName Language="F#">[&lt;System.MonoTODO&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>总是引发 <see cref="T:System.NotSupportedException" />。</summary>
        <value>总是引发 <see cref="T:System.NotSupportedException" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.FtpWebRequest.UseDefaultCredentials%2A>提供属性只是为了与和类的其他实现兼容 <xref:System.Net.WebRequest> <xref:System.Net.WebResponse> 。 没有理由使用 <xref:System.Net.FtpWebRequest.UseDefaultCredentials%2A> 。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">FTP 不支持默认凭据。</exception>
      </Docs>
    </Member>
    <Member MemberName="UsePassive">
      <MemberSignature Language="C#" Value="public bool UsePassive { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UsePassive" />
      <MemberSignature Language="DocId" Value="P:System.Net.FtpWebRequest.UsePassive" />
      <MemberSignature Language="VB.NET" Value="Public Property UsePassive As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UsePassive { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UsePassive : bool with get, set" Usage="System.Net.FtpWebRequest.UsePassive" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置客户端应用程序的数据传输过程的行为。</summary>
        <value>如果客户端应用程序的数据传输过程侦听数据端口上的连接，则为 <see langword="false" />；如果客户端应在数据端口上启动连接，则为 <see langword="true" />。 默认值是 <see langword="true" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 设置 <xref:System.Net.FtpWebRequest.UsePassive%2A> 属性以 `true` 将 "命令发送 `PASV"` 到服务器。 此命令请求服务器侦听数据端口并等待连接，而不是在接收到传输命令时启动连接。  
  
 有关使用指定的行为的说明 <xref:System.Net.FtpWebRequest.UsePassive%2A> ，请参阅 [RFC 959： "文件传输协议"，第3.2 节： "建立数据连接" 和第4.1.2 节： "传输参数命令"](https://www.ietf.org/rfc/rfc959.txt)。  
  
 <xref:System.Net.FtpWebRequest.UsePassive%2A>在调用 <xref:System.Net.FtpWebRequest.GetRequestStream%2A> 、 <xref:System.Net.FtpWebRequest.BeginGetRequestStream%2A> 、或方法之后更改将 <xref:System.Net.FtpWebRequest.GetResponse%2A> <xref:System.Net.FtpWebRequest.BeginGetResponse%2A> 导致 <xref:System.InvalidOperationException> 异常。  
  
 如果 <xref:System.Net.FtpWebRequest.UsePassive%2A> 设置为 `true` ，FTP 服务器可能不会发送文件的大小，并且下载进度始终可以为零。 如果 <xref:System.Net.FtpWebRequest.UsePassive%2A> 设置为 `false` ，则防火墙可能会引发警报并阻止文件下载。  
  
   
  
## Examples  
 下面的代码示例检索并显示指定的对象的属性值 <xref:System.Net.FtpWebRequest> 。  
  
 [!code-cpp[NCLFtpClient#6](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLFtpClient/CPP/ftptests.cpp#6)]
 [!code-csharp[NCLFtpClient#6](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLFtpClient/CS/ftptests.cs#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">对于一个已在进行的请求为此属性指定了一个新值。</exception>
        <altmember cref="T:System.Net.FtpWebResponse" />
        <altmember cref="T:System.Net.FtpStatusCode" />
        <altmember cref="T:System.Net.WebRequestMethods.Ftp" />
        <altmember cref="T:System.Net.WebRequest" />
        <altmember cref="T:System.Net.WebResponse" />
        <altmember cref="T:System.Net.WebClient" />
      </Docs>
    </Member>
  </Members>
</Type>
