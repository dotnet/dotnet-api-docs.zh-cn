<Type Name="UpDownBase" FullName="System.Windows.Forms.UpDownBase">
  <Metadata><Meta Name="ms.openlocfilehash" Value="6a232fa888672f8107ad766026bbe9c311067f35" /><Meta Name="ms.sourcegitcommit" Value="13a6cb6fba7e05947f15d8d6cc802703ae9c21d5" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-CN" /><Meta Name="ms.lasthandoff" Value="09/18/2020" /><Meta Name="ms.locfileid" Value="90794419" /></Metadata><TypeSignature Language="C#" Value="public abstract class UpDownBase : System.Windows.Forms.ContainerControl" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit UpDownBase extends System.Windows.Forms.ContainerControl" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Forms.UpDownBase" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class UpDownBase&#xA;Inherits ContainerControl" />
  <TypeSignature Language="C++ CLI" Value="public ref class UpDownBase abstract : System::Windows::Forms::ContainerControl" />
  <TypeSignature Language="F#" Value="type UpDownBase = class&#xA;    inherit ContainerControl" />
  <AssemblyInfo>
    <AssemblyName>System.Windows.Forms</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>5.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Forms.ContainerControl</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName Language="C#">[System.ComponentModel.Designer("System.Windows.Forms.Design.UpDownBaseDesigner, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")]</AttributeName>
      <AttributeName Language="F#">[&lt;System.ComponentModel.Designer("System.Windows.Forms.Design.UpDownBaseDesigner, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")&gt;]</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName Language="C#">[System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.AutoDispatch)]</AttributeName>
      <AttributeName Language="F#">[&lt;System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.AutoDispatch)&gt;]</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName Language="C#">[System.Runtime.InteropServices.ComVisible(true)]</AttributeName>
      <AttributeName Language="F#">[&lt;System.Runtime.InteropServices.ComVisible(true)&gt;]</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1">
      <AttributeName Language="C#">[System.ComponentModel.Designer("System.Windows.Forms.Design.UpDownBaseDesigner, System.Design, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")]</AttributeName>
      <AttributeName Language="F#">[&lt;System.ComponentModel.Designer("System.Windows.Forms.Design.UpDownBaseDesigner, System.Design, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")&gt;]</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
      <AttributeName Language="C#">[System.ComponentModel.Designer("System.Windows.Forms.Design.UpDownBaseDesigner, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")]</AttributeName>
      <AttributeName Language="F#">[&lt;System.ComponentModel.Designer("System.Windows.Forms.Design.UpDownBaseDesigner, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")&gt;]</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>实现数字显示框（也称为 up-down 控件）所需的基本功能。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 数字显示框由一个文本框和一个小垂直滚动条组成，通常称为数值调节钮控件。 <xref:System.Windows.Forms.UpDownBase>类链接这两个控件，并允许用户通过单击向上或向下按钮或直接在文本框中输入适当类型的值，来更改文本框中的显示内容。 如果要限制用户可以选择的值列表，请使用数字调整框，类似于列表框或组合框。 根据要显示的列表的类型，使用数字显示框的优势在于，它允许快速设置有效值的范围，而不是一次添加一个值。 实现数字显示框需要的数据验证比文本框少，因为当从派生类时，可以限制数据类型 <xref:System.Windows.Forms.UpDownBase> 。 此类的一个示例是 <xref:System.Windows.Forms.NumericUpDown> 类，它将值限制为数值类型，并使用 <xref:System.Windows.Forms.NumericUpDown.Minimum%2A> 和 <xref:System.Windows.Forms.NumericUpDown.Maximum%2A> 属性来验证数据。  
  
 若要允许用户使用箭头键来更改数字显示框的内容，请将 <xref:System.Windows.Forms.UpDownBase.InterceptArrowKeys%2A> 属性设置为 `true` 。 若要将用户限制为指定的值，请将 <xref:System.Windows.Forms.UpDownBase.ReadOnly%2A> 属性设置为 `true` 。 若要在数字显示框中控制文本的对齐方式，请设置 <xref:System.Windows.Forms.UpDownBase.TextAlign%2A> 属性。 若要设置与控件的文本框部分相关的向上和向下按钮的对齐方式，请将属性设置 <xref:System.Windows.Forms.UpDownBase.UpDownAlign%2A> 为 <xref:System.Windows.Forms.LeftRightAlignment.Left> 或 <xref:System.Windows.Forms.LeftRightAlignment.Right> 。  
  
 <xref:System.Windows.Forms.UpDownBase.UpButton%2A> <xref:System.Windows.Forms.UpDownBase.DownButton%2A> 重写时，和方法会处理单击向上或向下按钮。 重写时， <xref:System.Windows.Forms.UpDownBase.ValidateEditText%2A> 和 <xref:System.Windows.Forms.UpDownBase.UpdateEditText%2A> 方法将验证 (选择或输入的值) 并更新数字显示框中显示的文本。 如果值验证失败，请使用 <xref:System.Windows.Forms.UpDownBase.Select%2A> 方法选择无效文本。 这样，用户就可以快速更正文本，只需键入新值，就不必手动选择或删除现有文本。  
  
 从 .NET Framework 4.6 开始， <xref:System.Windows.Forms.UpDownBase> 当 app.config 文件包含以下项时，将根据系统 DPI 设置调整控件的大小：  
  
```  
<appSettings>  
  <add key="EnableWindowsFormsHighDpiAutoResizing" value="true" />  
</appSettings>  
  
```  
  
   
  
## Examples  
 下面的代码示例使用派生类 <xref:System.Windows.Forms.NumericUpDown> 并设置派生自的部分属性 <xref:System.Windows.Forms.UpDownBase> 。 此代码要求你有一个名为的 <xref:System.Windows.Forms.NumericUpDown> 控件和 `numericUpDown1` 两个名 <xref:System.Windows.Forms.ComboBox> 为和的控件 `comboBox1` `comboBox2` ，以及 <xref:System.Windows.Forms.CheckBox> `checkBox1` `checkBox2` `checkBox2` 在窗体上创建的名为、和的三个控件。 将以下项添加到 `comboBox1` ： `None` 、 `Fixed3D` 和 `FixedSingle` 。 将以下项添加到 `comboBox2` ： `Left` 、 `Right` 和 `Center` 。  
  
 代码允许您在运行时更改属性值，并查看每个属性值如何影响数字显示框的外观和行为。  
  
 [!code-cpp[Classic UpDownBase Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic UpDownBase Example/CPP/source.cpp#1)]
 [!code-csharp[Classic UpDownBase Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic UpDownBase Example/CS/source.cs#1)]
 [!code-vb[Classic UpDownBase Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic UpDownBase Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <block subset="none" type="overrides"><para>当从继承时 <see cref="T:System.Windows.Forms.UpDownBase" /> ，必须重写以下成员： <see cref="M:System.Windows.Forms.UpDownBase.DownButton" /> 、 <see cref="M:System.Windows.Forms.UpDownBase.UpButton" /> 、 <see cref="M:System.Windows.Forms.UpDownBase.UpdateEditText" /> 和 <see cref="M:System.Windows.Forms.UpDownBase.ValidateEditText" /> 。</para></block>
    <altmember cref="T:System.Windows.Forms.NumericUpDown" />
    <altmember cref="T:System.Windows.Forms.DomainUpDown" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UpDownBase ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.UpDownBase.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; UpDownBase();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>初始化 <see cref="T:System.Windows.Forms.UpDownBase" /> 类的新实例。</summary>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.Windows.Forms.NumericUpDown" />
        <altmember cref="T:System.Windows.Forms.DomainUpDown" />
      </Docs>
    </Member>
    <Member MemberName="AutoScroll">
      <MemberSignature Language="C#" Value="public override bool AutoScroll { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AutoScroll" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.UpDownBase.AutoScroll" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property AutoScroll As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool AutoScroll { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AutoScroll : bool with get, set" Usage="System.Windows.Forms.UpDownBase.AutoScroll" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.Browsable(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.Browsable(false)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示容器是否允许用户滚动到任何放置在它的可视边界之外的控件。</summary>
        <value>在所有情况下均为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.UpDownBase>控件不使用 <xref:System.Windows.Forms.UpDownBase.AutoScroll%2A> 属性。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AutoScrollMargin">
      <MemberSignature Language="C#" Value="public System.Drawing.Size AutoScrollMargin { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Size AutoScrollMargin" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.UpDownBase.AutoScrollMargin" />
      <MemberSignature Language="VB.NET" Value="Public Property AutoScrollMargin As Size" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Size AutoScrollMargin { System::Drawing::Size get(); void set(System::Drawing::Size value); };" />
      <MemberSignature Language="F#" Value="member this.AutoScrollMargin : System.Drawing.Size with get, set" Usage="System.Windows.Forms.UpDownBase.AutoScrollMargin" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.Browsable(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.Browsable(false)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Size</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置自动滚动边距的大小。</summary>
        <value>表示自动滚动边距的高度和宽度的 <see cref="T:System.Drawing.Size" />，单位为像素。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.UpDownBase>控件不使用 <xref:System.Windows.Forms.UpDownBase.AutoScrollMargin%2A> 属性。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><see cref="P:System.Drawing.Size.Height" /> 或 <see cref="P:System.Drawing.Size.Width" /> 小于 0。</exception>
      </Docs>
    </Member>
    <Member MemberName="AutoScrollMinSize">
      <MemberSignature Language="C#" Value="public System.Drawing.Size AutoScrollMinSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Size AutoScrollMinSize" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.UpDownBase.AutoScrollMinSize" />
      <MemberSignature Language="VB.NET" Value="Public Property AutoScrollMinSize As Size" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Size AutoScrollMinSize { System::Drawing::Size get(); void set(System::Drawing::Size value); };" />
      <MemberSignature Language="F#" Value="member this.AutoScrollMinSize : System.Drawing.Size with get, set" Usage="System.Windows.Forms.UpDownBase.AutoScrollMinSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.Browsable(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.Browsable(false)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Size</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置自动滚动区域的最小大小。</summary>
        <value>表示滚动条的最小高度和宽度的 <see cref="T:System.Drawing.Size" />，单位为像素。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.UpDownBase>控件不使用 <xref:System.Windows.Forms.UpDownBase.AutoScrollMinSize%2A> 属性。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AutoSize">
      <MemberSignature Language="C#" Value="public override bool AutoSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AutoSize" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.UpDownBase.AutoSize" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property AutoSize As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool AutoSize { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AutoSize : bool with get, set" Usage="System.Windows.Forms.UpDownBase.AutoSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.ComponentModel.Browsable(true)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.Browsable(true)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Visible)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Visible)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Always)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Always)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指示是否应根据控件的内容自动调整控件的大小。</summary>
        <value>如果指示应根据控件的内容自动调整控件的大小，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AutoSizeChanged">
      <MemberSignature Language="C#" Value="public event EventHandler AutoSizeChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler AutoSizeChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.UpDownBase.AutoSizeChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event AutoSizeChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ AutoSizeChanged;" />
      <MemberSignature Language="F#" Value="member this.AutoSizeChanged : EventHandler " Usage="member this.AutoSizeChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.ComponentModel.Browsable(true)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.Browsable(true)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Always)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Always)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当 <see cref="P:System.Windows.Forms.UpDownBase.AutoSize" /> 属性的值更改时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 有关处理事件的详细信息，请参阅 [处理和引发事件](/dotnet/standard/events/)。  
  
   
  
## Examples  
 下面的代码示例演示如何使用此成员。 在此示例中，事件处理程序报告事件的发生 <xref:System.Windows.Forms.UpDownBase.AutoSizeChanged> 。 此报表可帮助你了解何时发生事件，并可帮助你进行调试。 若要报告多个事件或频繁发生的事件，请考虑 <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> 将消息替换为多行或将其追加到多行 <xref:System.Windows.Forms.TextBox> 。  
  
 若要运行示例代码，请将其粘贴到一个项目中，该项目包含从继承的类型的实例 <xref:System.Windows.Forms.UpDownBase> ，如 <xref:System.Windows.Forms.NumericUpDown> 或 <xref:System.Windows.Forms.DomainUpDown> 。 然后命名该实例 `UpDownBase1` ，并确保事件处理程序与事件相关联 <xref:System.Windows.Forms.UpDownBase.AutoSizeChanged> 。  
  
 [!code-csharp[System.Windows.Forms.EventExamples#380](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#380)]
 [!code-vb[System.Windows.Forms.EventExamples#380](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#380)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BackColor">
      <MemberSignature Language="C#" Value="public override System.Drawing.Color BackColor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Color BackColor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.UpDownBase.BackColor" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property BackColor As Color" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Drawing::Color BackColor { System::Drawing::Color get(); void set(System::Drawing::Color value); };" />
      <MemberSignature Language="F#" Value="member this.BackColor : System.Drawing.Color with get, set" Usage="System.Windows.Forms.UpDownBase.BackColor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Color</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置数字显示框（也称为 up-down 控件）的文本框部分的背景色。</summary>
        <value>表示数字显示框的文本框部分背景色的 <see cref="T:System.Drawing.Color" />。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BackgroundImage">
      <MemberSignature Language="C#" Value="public override System.Drawing.Image BackgroundImage { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Drawing.Image BackgroundImage" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.UpDownBase.BackgroundImage" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property BackgroundImage As Image" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Drawing::Image ^ BackgroundImage { System::Drawing::Image ^ get(); void set(System::Drawing::Image ^ value); };" />
      <MemberSignature Language="F#" Value="member this.BackgroundImage : System.Drawing.Image with get, set" Usage="System.Windows.Forms.UpDownBase.BackgroundImage" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.Browsable(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.Browsable(false)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Image</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置 <see cref="T:System.Windows.Forms.UpDownBase" /> 的背景图像。</summary>
        <value><see cref="T:System.Windows.Forms.UpDownBase" /> 的背景图像。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.UpDownBase.BackgroundImage%2A>属性对控件的外观没有影响 <xref:System.Windows.Forms.UpDownBase> ; 因此，它在设计器和 IntelliSense 中是隐藏的。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BackgroundImageChanged">
      <MemberSignature Language="C#" Value="public event EventHandler BackgroundImageChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler BackgroundImageChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.UpDownBase.BackgroundImageChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event BackgroundImageChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ BackgroundImageChanged;" />
      <MemberSignature Language="F#" Value="member this.BackgroundImageChanged : EventHandler " Usage="member this.BackgroundImageChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.Browsable(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.Browsable(false)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当 <see cref="P:System.Windows.Forms.UpDownBase.BackgroundImage" /> 属性的值更改时发生。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BackgroundImageLayout">
      <MemberSignature Language="C#" Value="public override System.Windows.Forms.ImageLayout BackgroundImageLayout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.ImageLayout BackgroundImageLayout" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.UpDownBase.BackgroundImageLayout" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property BackgroundImageLayout As ImageLayout" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Windows::Forms::ImageLayout BackgroundImageLayout { System::Windows::Forms::ImageLayout get(); void set(System::Windows::Forms::ImageLayout value); };" />
      <MemberSignature Language="F#" Value="member this.BackgroundImageLayout : System.Windows.Forms.ImageLayout with get, set" Usage="System.Windows.Forms.UpDownBase.BackgroundImageLayout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.ComponentModel.Browsable(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.Browsable(false)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.ImageLayout</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置 <see cref="P:System.Windows.Forms.UpDownBase.BackgroundImage" /> 的 <see cref="T:System.Windows.Forms.UpDownBase" /> 的布局。</summary>
        <value><see cref="T:System.Windows.Forms.ImageLayout" /> 值之一。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.UpDownBase.BackgroundImageLayout%2A>属性对控件的外观没有影响 <xref:System.Windows.Forms.UpDownBase> ; 因此，它在设计器和 IntelliSense 中是隐藏的。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BackgroundImageLayoutChanged">
      <MemberSignature Language="C#" Value="public event EventHandler BackgroundImageLayoutChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler BackgroundImageLayoutChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.UpDownBase.BackgroundImageLayoutChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event BackgroundImageLayoutChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ BackgroundImageLayoutChanged;" />
      <MemberSignature Language="F#" Value="member this.BackgroundImageLayoutChanged : EventHandler " Usage="member this.BackgroundImageLayoutChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.ComponentModel.Browsable(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.Browsable(false)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当 <see cref="P:System.Windows.Forms.UpDownBase.BackgroundImageLayout" /> 属性的值更改时发生。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BorderStyle">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.BorderStyle BorderStyle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.BorderStyle BorderStyle" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.UpDownBase.BorderStyle" />
      <MemberSignature Language="VB.NET" Value="Public Property BorderStyle As BorderStyle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::BorderStyle BorderStyle { System::Windows::Forms::BorderStyle get(); void set(System::Windows::Forms::BorderStyle value); };" />
      <MemberSignature Language="F#" Value="member this.BorderStyle : System.Windows.Forms.BorderStyle with get, set" Usage="System.Windows.Forms.UpDownBase.BorderStyle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.InteropServices.DispId(-504)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.InteropServices.DispId(-504)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.BorderStyle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置数字显示框（也称为 up-down 控件）的边框样式。</summary>
        <value><see cref="T:System.Windows.Forms.BorderStyle" /> 值之一。 默认值是 <see cref="F:System.Windows.Forms.BorderStyle.Fixed3D" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.TextBoxBase.BorderStyle%2A>除了默认的三维控件外，还可以使用属性创建无边框控件和平面控件。  
  
   
  
## Examples  
 下面的代码示例使用派生类 <xref:System.Windows.Forms.NumericUpDown> 并设置派生自的部分属性 <xref:System.Windows.Forms.UpDownBase> 。 此代码要求你有一个名为的 <xref:System.Windows.Forms.NumericUpDown> 控件和 `numericUpDown1` 两个名 <xref:System.Windows.Forms.ComboBox> 为和的控件 `comboBox1` `comboBox2` ，以及 <xref:System.Windows.Forms.CheckBox> `checkBox1` `checkBox2` `checkBox2` 在窗体上创建的名为、和的三个控件。 将以下项添加到 `comboBox1` ： `None` 、 `Fixed3D` 和 `FixedSingle` 。 将以下项添加到 `comboBox2` ： `Left` 、 `Right` 和 `Center` 。  
  
 代码允许您在运行时更改属性值，并查看每个属性值如何影响数字显示框的外观和行为。  
  
 [!code-cpp[Classic UpDownBase Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic UpDownBase Example/CPP/source.cpp#1)]
 [!code-csharp[Classic UpDownBase Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic UpDownBase Example/CS/source.cs#1)]
 [!code-vb[Classic UpDownBase Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic UpDownBase Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">分配的值不是 <see cref="T:System.Windows.Forms.BorderStyle" /> 值之一。</exception>
        <altmember cref="T:System.Windows.Forms.BorderStyle" />
      </Docs>
    </Member>
    <Member MemberName="ChangingText">
      <MemberSignature Language="C#" Value="protected bool ChangingText { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ChangingText" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.UpDownBase.ChangingText" />
      <MemberSignature Language="VB.NET" Value="Protected Property ChangingText As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property bool ChangingText { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ChangingText : bool with get, set" Usage="System.Windows.Forms.UpDownBase.ChangingText" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指示文本属性是否由其父类内部更改。</summary>
        <value>如果 <see cref="P:System.Windows.Forms.UpDownBase.Text" /> 属性由 <see cref="T:System.Windows.Forms.UpDownBase" /> 类内部更改，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.UpDownBase.ChangingText%2A>属性充当类的标志 <xref:System.Windows.Forms.UpDownBase> 。 派生类使用此属性来指示类在内部更改当前属性的时间 <xref:System.Windows.Forms.UpDownBase.Text%2A> 。 如果将此属性设置为 `false` ，则控件要求用户正在更改 <xref:System.Windows.Forms.UpDownBase.Text%2A> 属性，并将 <xref:System.Windows.Forms.UpDownBase.UserEdit%2A> 属性设置为 `true` 。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.UpDownBase.UserEdit" />
        <altmember cref="P:System.Windows.Forms.UpDownBase.Text" />
      </Docs>
    </Member>
    <Member MemberName="ContextMenu">
      <MemberSignature Language="C#" Value="public override System.Windows.Forms.ContextMenu ContextMenu { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.ContextMenu ContextMenu" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.UpDownBase.ContextMenu" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property ContextMenu As ContextMenu" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Windows::Forms::ContextMenu ^ ContextMenu { System::Windows::Forms::ContextMenu ^ get(); void set(System::Windows::Forms::ContextMenu ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ContextMenu : System.Windows.Forms.ContextMenu with get, set" Usage="System.Windows.Forms.UpDownBase.ContextMenu" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.ContextMenu</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置与数字显示框（也称为 up-down 控件）关联的快捷菜单。</summary>
        <value>与数字显示框关联的 <see cref="T:System.Windows.Forms.ContextMenu" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 与树节点关联的快捷菜单的首选方法是使用 <xref:System.Windows.Forms.UpDownBase.ContextMenuStrip%2A> 属性。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContextMenuStrip">
      <MemberSignature Language="C#" Value="public override System.Windows.Forms.ContextMenuStrip ContextMenuStrip { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.ContextMenuStrip ContextMenuStrip" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.UpDownBase.ContextMenuStrip" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property ContextMenuStrip As ContextMenuStrip" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Windows::Forms::ContextMenuStrip ^ ContextMenuStrip { System::Windows::Forms::ContextMenuStrip ^ get(); void set(System::Windows::Forms::ContextMenuStrip ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ContextMenuStrip : System.Windows.Forms.ContextMenuStrip with get, set" Usage="System.Windows.Forms.UpDownBase.ContextMenuStrip" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.ContextMenuStrip</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置数字显示框（也称为 up-down 控件）的快捷菜单。</summary>
        <value>与控件关联的 <see cref="T:System.Windows.Forms.ContextMenuStrip" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当用户右键单击数字显示框时，将显示快捷菜单。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateParams">
      <MemberSignature Language="C#" Value="protected override System.Windows.Forms.CreateParams CreateParams { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.CreateParams CreateParams" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.UpDownBase.CreateParams" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides ReadOnly Property CreateParams As CreateParams" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property System::Windows::Forms::CreateParams ^ CreateParams { System::Windows::Forms::CreateParams ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CreateParams : System.Windows.Forms.CreateParams" Usage="System.Windows.Forms.UpDownBase.CreateParams" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.CreateParams</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取创建控件句柄时所需要的创建参数。</summary>
        <value>创建参数。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultSize">
      <MemberSignature Language="C#" Value="protected override System.Drawing.Size DefaultSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Size DefaultSize" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.UpDownBase.DefaultSize" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides ReadOnly Property DefaultSize As Size" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property System::Drawing::Size DefaultSize { System::Drawing::Size get(); };" />
      <MemberSignature Language="F#" Value="member this.DefaultSize : System.Drawing.Size" Usage="System.Windows.Forms.UpDownBase.DefaultSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Size</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取控件的默认大小。</summary>
        <value>控件的默认 <see cref="T:System.Drawing.Size" />。</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.Forms.Control.DefaultSize" />
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.UpDownBase.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="override this.Dispose : bool -&gt; unit" Usage="upDownBase.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" Index="0" FrameworkAlternate="netframework-1.1" />
      </Parameters>
      <Docs>
        <param name="disposing">若要释放托管资源和非托管资源，则为 <see langword="true" />；若仅释放非托管资源，则为 <see langword="false" />。</param>
        <summary>释放由此控件及其子控件占用的非托管资源，另外还可释放托管资源。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DockPadding">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.ScrollableControl.DockPaddingEdges DockPadding { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.ScrollableControl/DockPaddingEdges DockPadding" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.UpDownBase.DockPadding" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DockPadding As ScrollableControl.DockPaddingEdges" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::ScrollableControl::DockPaddingEdges ^ DockPadding { System::Windows::Forms::ScrollableControl::DockPaddingEdges ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DockPadding : System.Windows.Forms.ScrollableControl.DockPaddingEdges" Usage="System.Windows.Forms.UpDownBase.DockPadding" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.Browsable(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.Browsable(false)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.ScrollableControl+DockPaddingEdges</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取 <see cref="T:System.Windows.Forms.UpDownBase" /> 控件所有边缘的停靠边距设置。</summary>
        <value>此控件的停靠边距设置。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.UpDownBase>控件不使用 <xref:System.Windows.Forms.UpDownBase.DockPadding%2A> 属性。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DownButton">
      <MemberSignature Language="C#" Value="public abstract void DownButton ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void DownButton() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.UpDownBase.DownButton" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub DownButton ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void DownButton();" />
      <MemberSignature Language="F#" Value="abstract member DownButton : unit -&gt; unit" Usage="upDownBase.DownButton " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>在派生类中被重写时，处理单击数字显示框（也称为 up-down 控件）上向下按钮的操作。</summary>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides"><para>在派生类中重写此方法时，请确保调用 <see cref="M:System.Windows.Forms.UpDownBase.UpdateEditText" /> 方法。</para></block>
        <altmember cref="M:System.Windows.Forms.UpDownBase.UpButton" />
      </Docs>
    </Member>
    <Member MemberName="Focused">
      <MemberSignature Language="C#" Value="public override bool Focused { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Focused" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.UpDownBase.Focused" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Focused As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool Focused { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.Focused : bool" Usage="System.Windows.Forms.UpDownBase.Focused" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.Browsable(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.Browsable(false)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示控件是否有输入焦点。</summary>
        <value>如果控件有焦点，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.Forms.Control.Focused" />
      </Docs>
    </Member>
    <Member MemberName="ForeColor">
      <MemberSignature Language="C#" Value="public override System.Drawing.Color ForeColor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Color ForeColor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.UpDownBase.ForeColor" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property ForeColor As Color" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Drawing::Color ForeColor { System::Drawing::Color get(); void set(System::Drawing::Color value); };" />
      <MemberSignature Language="F#" Value="member this.ForeColor : System.Drawing.Color with get, set" Usage="System.Windows.Forms.UpDownBase.ForeColor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Color</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置数字显示框（也称为 up-down 控件）的前景色。</summary>
        <value>数字显示框的前景 <see cref="T:System.Drawing.Color" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.UpDownBase.ForeColor%2A>属性将更改数字显示框的文本框部分中的文本颜色。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InterceptArrowKeys">
      <MemberSignature Language="C#" Value="public bool InterceptArrowKeys { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool InterceptArrowKeys" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.UpDownBase.InterceptArrowKeys" />
      <MemberSignature Language="VB.NET" Value="Public Property InterceptArrowKeys As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool InterceptArrowKeys { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.InterceptArrowKeys : bool with get, set" Usage="System.Windows.Forms.UpDownBase.InterceptArrowKeys" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.DefaultValue(true)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.DefaultValue(true)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指示用户是否可以使用向上键和向下键选择值。</summary>
        <value>如果控件允许用户使用向上键和向下键选择值，则为 <see langword="true" />；否则为 <see langword="false" />。 默认值是 <see langword="true" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果 <xref:System.Windows.Forms.UpDownBase.InterceptArrowKeys%2A> 属性设置为 `true` ，并且数字显示框 (也称为 up-down 控件) 具有焦点，则用户可以使用向上键和向下键选择值。  
  
   
  
## Examples  
 下面的代码示例使用派生类 <xref:System.Windows.Forms.NumericUpDown> 并设置派生自的部分属性 <xref:System.Windows.Forms.UpDownBase> 。 此代码要求你有一个名为的 <xref:System.Windows.Forms.NumericUpDown> 控件和 `numericUpDown1` 两个名 <xref:System.Windows.Forms.ComboBox> 为和的控件 `comboBox1` `comboBox2` ，以及 <xref:System.Windows.Forms.CheckBox> `checkBox1` `checkBox2` `checkBox2` 在窗体上创建的名为、和的三个控件。 将以下项添加到 `comboBox1` ： `None` 、 `Fixed3D` 和 `FixedSingle` 。 将以下项添加到 `comboBox2` ： `Left` 、 `Right` 和 `Center` 。  
  
 代码允许您在运行时更改属性值，并查看每个属性值如何影响数字显示框的外观和行为。  
  
 [!code-cpp[Classic UpDownBase Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic UpDownBase Example/CPP/source.cpp#1)]
 [!code-csharp[Classic UpDownBase Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic UpDownBase Example/CS/source.cs#1)]
 [!code-vb[Classic UpDownBase Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic UpDownBase Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MaximumSize">
      <MemberSignature Language="C#" Value="public override System.Drawing.Size MaximumSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Size MaximumSize" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.UpDownBase.MaximumSize" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property MaximumSize As Size" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Drawing::Size MaximumSize { System::Drawing::Size get(); void set(System::Drawing::Size value); };" />
      <MemberSignature Language="F#" Value="member this.MaximumSize : System.Drawing.Size with get, set" Usage="System.Windows.Forms.UpDownBase.MaximumSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Size</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置数字显示框（也称为 up-down 控件）的最大大小。</summary>
        <value><see cref="T:System.Drawing.Size" />，它是数字显示框的最大大小。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 无论指定的值是什么， <xref:System.Drawing.Size.Height%2A> 最大大小的都将始终为0。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MinimumSize">
      <MemberSignature Language="C#" Value="public override System.Drawing.Size MinimumSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Size MinimumSize" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.UpDownBase.MinimumSize" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property MinimumSize As Size" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Drawing::Size MinimumSize { System::Drawing::Size get(); void set(System::Drawing::Size value); };" />
      <MemberSignature Language="F#" Value="member this.MinimumSize : System.Drawing.Size with get, set" Usage="System.Windows.Forms.UpDownBase.MinimumSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Size</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置数字显示框（也称为 up-down 控件）的最小大小。</summary>
        <value><see cref="T:System.Drawing.Size" />，它是数字显示框的最小大小。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseEnter">
      <MemberSignature Language="C#" Value="public event EventHandler MouseEnter;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler MouseEnter" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.UpDownBase.MouseEnter" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseEnter As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ MouseEnter;" />
      <MemberSignature Language="F#" Value="member this.MouseEnter : EventHandler " Usage="member this.MouseEnter : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.Browsable(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.Browsable(false)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在鼠标指针进入 <see cref="T:System.Windows.Forms.UpDownBase" /> 控件时发生。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseHover">
      <MemberSignature Language="C#" Value="public event EventHandler MouseHover;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler MouseHover" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.UpDownBase.MouseHover" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseHover As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ MouseHover;" />
      <MemberSignature Language="F#" Value="member this.MouseHover : EventHandler " Usage="member this.MouseHover : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.Browsable(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.Browsable(false)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在鼠标指针悬停在 <see cref="T:System.Windows.Forms.UpDownBase" /> 控件上时发生。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseLeave">
      <MemberSignature Language="C#" Value="public event EventHandler MouseLeave;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler MouseLeave" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.UpDownBase.MouseLeave" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseLeave As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ MouseLeave;" />
      <MemberSignature Language="F#" Value="member this.MouseLeave : EventHandler " Usage="member this.MouseLeave : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.Browsable(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.Browsable(false)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在鼠标指针离开 <see cref="T:System.Windows.Forms.UpDownBase" /> 控件时发生。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseMove">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.MouseEventHandler MouseMove;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.MouseEventHandler MouseMove" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.UpDownBase.MouseMove" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseMove As MouseEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::MouseEventHandler ^ MouseMove;" />
      <MemberSignature Language="F#" Value="member this.MouseMove : System.Windows.Forms.MouseEventHandler " Usage="member this.MouseMove : System.Windows.Forms.MouseEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.Browsable(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.Browsable(false)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.MouseEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在用户将鼠标指针移动到 <see cref="T:System.Windows.Forms.UpDownBase" /> 控件上时发生。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnChanged (object source, EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnChanged(object source, class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.UpDownBase.OnChanged(System.Object,System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnChanged (source As Object, e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnChanged(System::Object ^ source, EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnChanged : obj * EventArgs -&gt; unit&#xA;override this.OnChanged : obj * EventArgs -&gt; unit" Usage="upDownBase.OnChanged (source, e)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Object" />
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="source">事件源。</param>
        <param name="e">包含事件数据的 <see cref="T:System.EventArgs" />。</param>
        <summary>当在派生类中被重写时，引发 Changed 事件。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnFontChanged">
      <MemberSignature Language="C#" Value="protected override void OnFontChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnFontChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.UpDownBase.OnFontChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnFontChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnFontChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnFontChanged : EventArgs -&gt; unit" Usage="upDownBase.OnFontChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.EventArgs" />。</param>
        <summary>引发 <see cref="E:System.Windows.Forms.Control.FontChanged" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 引发事件时，将通过委托调用事件处理程序。 有关详细信息，请参阅 [处理和引发事件](/dotnet/standard/events/)。  
  
 <xref:System.Windows.Forms.UpDownBase.OnFontChanged%2A> 方法还允许派生类对事件进行处理而不必附加委托。 这是在派生类中处理事件的首选技术。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>在派生类中重写 <see cref="M:System.Windows.Forms.UpDownBase.OnFontChanged(System.EventArgs)" /> 时，一定要调用基类的 <see cref="M:System.Windows.Forms.UpDownBase.OnFontChanged(System.EventArgs)" /> 方法，以便已注册的委托对事件进行接收。</para></block>
      </Docs>
    </Member>
    <Member MemberName="OnHandleCreated">
      <MemberSignature Language="C#" Value="protected override void OnHandleCreated (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnHandleCreated(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.UpDownBase.OnHandleCreated(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnHandleCreated (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnHandleCreated(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnHandleCreated : EventArgs -&gt; unit" Usage="upDownBase.OnHandleCreated e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.EventArgs" />。</param>
        <summary>引发 <see cref="E:System.Windows.Forms.Control.HandleCreated" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 引发事件时，将通过委托调用事件处理程序。 有关详细信息，请参阅 [处理和引发事件](/dotnet/standard/events/)。  
  
 <xref:System.Windows.Forms.UpDownBase.OnHandleCreated%2A> 方法还允许派生类对事件进行处理而不必附加委托。 这是在派生类中处理事件的首选技术。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>在派生类中重写 <see cref="M:System.Windows.Forms.UpDownBase.OnHandleCreated(System.EventArgs)" /> 时，一定要调用基类的 <see cref="M:System.Windows.Forms.UpDownBase.OnHandleCreated(System.EventArgs)" /> 方法，以便已注册的委托对事件进行接收。</para></block>
      </Docs>
    </Member>
    <Member MemberName="OnHandleDestroyed">
      <MemberSignature Language="C#" Value="protected override void OnHandleDestroyed (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnHandleDestroyed(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.UpDownBase.OnHandleDestroyed(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnHandleDestroyed (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnHandleDestroyed(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnHandleDestroyed : EventArgs -&gt; unit" Usage="upDownBase.OnHandleDestroyed e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" Index="0" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.EventArgs" />。</param>
        <summary>引发 <see cref="E:System.Windows.Forms.Control.HandleDestroyed" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 引发事件时，将通过委托调用事件处理程序。 有关详细信息，请参阅 [处理和引发事件](/dotnet/standard/events/)。  
  
 <xref:System.Windows.Forms.UpDownBase.OnHandleDestroyed%2A> 方法还允许派生类对事件进行处理而不必附加委托。 这是在派生类中处理事件的首选技术。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>在派生类中重写 <see cref="M:System.Windows.Forms.UpDownBase.OnHandleDestroyed(System.EventArgs)" /> 时，一定要调用基类的 <see cref="M:System.Windows.Forms.UpDownBase.OnHandleDestroyed(System.EventArgs)" /> 方法，以便已注册的委托对事件进行接收。</para></block>
      </Docs>
    </Member>
    <Member MemberName="OnLayout">
      <MemberSignature Language="C#" Value="protected override void OnLayout (System.Windows.Forms.LayoutEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnLayout(class System.Windows.Forms.LayoutEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.UpDownBase.OnLayout(System.Windows.Forms.LayoutEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnLayout (e As LayoutEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnLayout(System::Windows::Forms::LayoutEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnLayout : System.Windows.Forms.LayoutEventArgs -&gt; unit" Usage="upDownBase.OnLayout e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.LayoutEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Windows.Forms.LayoutEventArgs" />。</param>
        <summary>引发 <see cref="E:System.Windows.Forms.Control.Layout" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 引发事件时，将通过委托调用事件处理程序。 有关详细信息，请参阅 [处理和引发事件](/dotnet/standard/events/)。  
  
 <xref:System.Windows.Forms.UpDownBase.OnLayout%2A> 方法还允许派生类对事件进行处理而不必附加委托。 这是在派生类中处理事件的首选技术。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>在派生类中重写 <see cref="M:System.Windows.Forms.UpDownBase.OnLayout(System.Windows.Forms.LayoutEventArgs)" /> 时，一定要调用基类的 <see cref="M:System.Windows.Forms.UpDownBase.OnLayout(System.Windows.Forms.LayoutEventArgs)" /> 方法，以便已注册的委托对事件进行接收。  
  
示例</para></block>
      </Docs>
    </Member>
    <Member MemberName="OnMouseDown">
      <MemberSignature Language="C#" Value="protected override void OnMouseDown (System.Windows.Forms.MouseEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnMouseDown(class System.Windows.Forms.MouseEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.UpDownBase.OnMouseDown(System.Windows.Forms.MouseEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnMouseDown (e As MouseEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnMouseDown(System::Windows::Forms::MouseEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnMouseDown : System.Windows.Forms.MouseEventArgs -&gt; unit" Usage="upDownBase.OnMouseDown e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.MouseEventArgs" Index="0" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Windows.Forms.MouseEventArgs" />。</param>
        <summary>引发 <see cref="E:System.Windows.Forms.Control.MouseDown" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 引发事件时，将通过委托调用事件处理程序。 有关详细信息，请参阅 [处理和引发事件](/dotnet/standard/events/)。  
  
 <xref:System.Windows.Forms.UpDownBase.OnMouseDown%2A> 方法还允许派生类对事件进行处理而不必附加委托。 这是在派生类中处理事件的首选技术。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>在派生类中重写 <see cref="M:System.Windows.Forms.UpDownBase.OnMouseDown(System.Windows.Forms.MouseEventArgs)" /> 时，一定要调用基类的 <see cref="M:System.Windows.Forms.UpDownBase.OnMouseDown(System.Windows.Forms.MouseEventArgs)" /> 方法，以便已注册的委托对事件进行接收。</para></block>
      </Docs>
    </Member>
    <Member MemberName="OnMouseUp">
      <MemberSignature Language="C#" Value="protected override void OnMouseUp (System.Windows.Forms.MouseEventArgs mevent);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnMouseUp(class System.Windows.Forms.MouseEventArgs mevent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.UpDownBase.OnMouseUp(System.Windows.Forms.MouseEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnMouseUp (mevent As MouseEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnMouseUp(System::Windows::Forms::MouseEventArgs ^ mevent);" />
      <MemberSignature Language="F#" Value="override this.OnMouseUp : System.Windows.Forms.MouseEventArgs -&gt; unit" Usage="upDownBase.OnMouseUp mevent" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mevent" Type="System.Windows.Forms.MouseEventArgs" Index="0" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="mevent">包含事件数据的 <see cref="T:System.Windows.Forms.MouseEventArgs" />。</param>
        <summary>引发 <see cref="E:System.Windows.Forms.Control.MouseUp" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果双击发生， <xref:System.Windows.Forms.UpDownBase.OnMouseUp%2A> 方法将引发 <xref:System.Windows.Forms.Control.DoubleClick> 事件。  
  
 引发事件时，将通过委托调用事件处理程序。 有关详细信息，请参阅 [处理和引发事件](/dotnet/standard/events/)。  
  
 <xref:System.Windows.Forms.UpDownBase.OnMouseUp%2A> 方法还允许派生类对事件进行处理而不必附加委托。 这是在派生类中处理事件的首选技术。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>在派生类中重写 <see cref="M:System.Windows.Forms.UpDownBase.OnMouseUp(System.Windows.Forms.MouseEventArgs)" /> 时，一定要调用基类的 <see cref="M:System.Windows.Forms.UpDownBase.OnMouseUp(System.Windows.Forms.MouseEventArgs)" /> 方法，以便已注册的委托对事件进行接收。</para></block>
      </Docs>
    </Member>
    <Member MemberName="OnMouseWheel">
      <MemberSignature Language="C#" Value="protected override void OnMouseWheel (System.Windows.Forms.MouseEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnMouseWheel(class System.Windows.Forms.MouseEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.UpDownBase.OnMouseWheel(System.Windows.Forms.MouseEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnMouseWheel (e As MouseEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnMouseWheel(System::Windows::Forms::MouseEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnMouseWheel : System.Windows.Forms.MouseEventArgs -&gt; unit" Usage="upDownBase.OnMouseWheel e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.MouseEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Windows.Forms.MouseEventArgs" />。</param>
        <summary>引发 <see cref="E:System.Windows.Forms.Control.MouseWheel" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果数字显示框 (也称为 up-down 控件) 在此事件发生时有焦点，则确定用户滚动鼠标滚轮的方向，然后 <xref:System.Windows.Forms.UpDownBase.UpButton%2A> <xref:System.Windows.Forms.UpDownBase.DownButton%2A> 调用或方法。  
  
 引发事件时，将通过委托调用事件处理程序。 有关详细信息，请参阅 [处理和引发事件](/dotnet/standard/events/)。  
  
 <xref:System.Windows.Forms.UpDownBase.OnMouseWheel%2A> 方法还允许派生类对事件进行处理而不必附加委托。 这是在派生类中处理事件的首选技术。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>在派生类中重写 <see cref="M:System.Windows.Forms.UpDownBase.OnMouseWheel(System.Windows.Forms.MouseEventArgs)" /> 时，一定要调用基类的 <see cref="M:System.Windows.Forms.UpDownBase.OnMouseWheel(System.Windows.Forms.MouseEventArgs)" /> 方法，以便已注册的委托对事件进行接收。</para></block>
        <altmember cref="M:System.Windows.Forms.UpDownBase.UpButton" />
        <altmember cref="M:System.Windows.Forms.UpDownBase.DownButton" />
      </Docs>
    </Member>
    <Member MemberName="OnPaint">
      <MemberSignature Language="C#" Value="protected override void OnPaint (System.Windows.Forms.PaintEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnPaint(class System.Windows.Forms.PaintEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.UpDownBase.OnPaint(System.Windows.Forms.PaintEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnPaint (e As PaintEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnPaint(System::Windows::Forms::PaintEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnPaint : System.Windows.Forms.PaintEventArgs -&gt; unit" Usage="upDownBase.OnPaint e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.PaintEventArgs" Index="0" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Windows.Forms.PaintEventArgs" />。</param>
        <summary>引发 <see cref="E:System.Windows.Forms.Control.Paint" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 引发事件时，将通过委托调用事件处理程序。 有关详细信息，请参阅 [处理和引发事件](/dotnet/standard/events/)。  
  
 <xref:System.Windows.Forms.UpDownBase.OnPaint%2A> 方法还允许派生类对事件进行处理而不必附加委托。 这是在派生类中处理事件的首选技术。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>在派生类中重写 <see cref="M:System.Windows.Forms.UpDownBase.OnPaint(System.Windows.Forms.PaintEventArgs)" /> 时，一定要调用基类的 <see cref="M:System.Windows.Forms.UpDownBase.OnPaint(System.Windows.Forms.PaintEventArgs)" /> 方法，以便已注册的委托对事件进行接收。</para></block>
      </Docs>
    </Member>
    <Member MemberName="OnTextBoxKeyDown">
      <MemberSignature Language="C#" Value="protected virtual void OnTextBoxKeyDown (object source, System.Windows.Forms.KeyEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnTextBoxKeyDown(object source, class System.Windows.Forms.KeyEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.UpDownBase.OnTextBoxKeyDown(System.Object,System.Windows.Forms.KeyEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnTextBoxKeyDown (source As Object, e As KeyEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnTextBoxKeyDown(System::Object ^ source, System::Windows::Forms::KeyEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnTextBoxKeyDown : obj * System.Windows.Forms.KeyEventArgs -&gt; unit&#xA;override this.OnTextBoxKeyDown : obj * System.Windows.Forms.KeyEventArgs -&gt; unit" Usage="upDownBase.OnTextBoxKeyDown (source, e)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Object" />
        <Parameter Name="e" Type="System.Windows.Forms.KeyEventArgs" />
      </Parameters>
      <Docs>
        <param name="source">事件源。</param>
        <param name="e">包含事件数据的 <see cref="T:System.Windows.Forms.KeyEventArgs" />。</param>
        <summary>引发 <see cref="E:System.Windows.Forms.Control.KeyDown" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果将 <xref:System.Windows.Forms.UpDownBase.InterceptArrowKeys%2A> 属性设置为 `true` ，并且用户按向上键，则 <xref:System.Windows.Forms.UpDownBase.UpButton%2A> 调用方法。 同样，如果用户按下箭头键，则 <xref:System.Windows.Forms.UpDownBase.DownButton%2A> 调用方法。  
  
 引发事件时，将通过委托调用事件处理程序。 有关详细信息，请参阅 [处理和引发事件](/dotnet/standard/events/)。  
  
 <xref:System.Windows.Forms.UpDownBase.OnTextBoxKeyDown%2A> 方法还允许派生类对事件进行处理而不必附加委托。 这是在派生类中处理事件的首选技术。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>在派生类中重写 <see cref="M:System.Windows.Forms.UpDownBase.OnTextBoxKeyDown(System.Object,System.Windows.Forms.KeyEventArgs)" /> 时，一定要调用基类的 <see cref="M:System.Windows.Forms.UpDownBase.OnTextBoxKeyDown(System.Object,System.Windows.Forms.KeyEventArgs)" /> 方法，以便已注册的委托对事件进行接收。</para></block>
        <altmember cref="P:System.Windows.Forms.UpDownBase.InterceptArrowKeys" />
        <altmember cref="M:System.Windows.Forms.UpDownBase.UpButton" />
        <altmember cref="M:System.Windows.Forms.UpDownBase.DownButton" />
        <altmember cref="E:System.Windows.Forms.Control.KeyDown" />
      </Docs>
    </Member>
    <Member MemberName="OnTextBoxKeyPress">
      <MemberSignature Language="C#" Value="protected virtual void OnTextBoxKeyPress (object source, System.Windows.Forms.KeyPressEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnTextBoxKeyPress(object source, class System.Windows.Forms.KeyPressEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.UpDownBase.OnTextBoxKeyPress(System.Object,System.Windows.Forms.KeyPressEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnTextBoxKeyPress (source As Object, e As KeyPressEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnTextBoxKeyPress(System::Object ^ source, System::Windows::Forms::KeyPressEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnTextBoxKeyPress : obj * System.Windows.Forms.KeyPressEventArgs -&gt; unit&#xA;override this.OnTextBoxKeyPress : obj * System.Windows.Forms.KeyPressEventArgs -&gt; unit" Usage="upDownBase.OnTextBoxKeyPress (source, e)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Object" />
        <Parameter Name="e" Type="System.Windows.Forms.KeyPressEventArgs" />
      </Parameters>
      <Docs>
        <param name="source">事件源。</param>
        <param name="e">包含事件数据的 <see cref="T:System.Windows.Forms.KeyPressEventArgs" />。</param>
        <summary>引发 <see cref="E:System.Windows.Forms.Control.KeyPress" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 引发事件时，将通过委托调用事件处理程序。 有关详细信息，请参阅 [处理和引发事件](/dotnet/standard/events/)。  
  
 <xref:System.Windows.Forms.UpDownBase.OnTextBoxKeyPress%2A> 方法还允许派生类对事件进行处理而不必附加委托。 这是在派生类中处理事件的首选技术。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>在派生类中重写 <see cref="M:System.Windows.Forms.UpDownBase.OnTextBoxKeyPress(System.Object,System.Windows.Forms.KeyPressEventArgs)" /> 时，一定要调用基类的 <see cref="M:System.Windows.Forms.UpDownBase.OnTextBoxKeyPress(System.Object,System.Windows.Forms.KeyPressEventArgs)" /> 方法，以便已注册的委托对事件进行接收。</para></block>
        <altmember cref="E:System.Windows.Forms.Control.KeyPress" />
      </Docs>
    </Member>
    <Member MemberName="OnTextBoxLostFocus">
      <MemberSignature Language="C#" Value="protected virtual void OnTextBoxLostFocus (object source, EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnTextBoxLostFocus(object source, class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.UpDownBase.OnTextBoxLostFocus(System.Object,System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnTextBoxLostFocus (source As Object, e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnTextBoxLostFocus(System::Object ^ source, EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnTextBoxLostFocus : obj * EventArgs -&gt; unit&#xA;override this.OnTextBoxLostFocus : obj * EventArgs -&gt; unit" Usage="upDownBase.OnTextBoxLostFocus (source, e)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Object" />
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="source">事件源。</param>
        <param name="e">包含事件数据的 <see cref="T:System.EventArgs" />。</param>
        <summary>引发 <see cref="E:System.Windows.Forms.Control.LostFocus" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当数字显示框 (也称为 up-down 控件) 失去焦点时，此方法将验证控件的文本框部分中的文本。  
  
 引发事件时，将通过委托调用事件处理程序。 有关详细信息，请参阅 [处理和引发事件](/dotnet/standard/events/)。  
  
 <xref:System.Windows.Forms.UpDownBase.OnTextBoxLostFocus%2A> 方法还允许派生类对事件进行处理而不必附加委托。 这是在派生类中处理事件的首选技术。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>在派生类中重写 <see cref="M:System.Windows.Forms.UpDownBase.OnTextBoxLostFocus(System.Object,System.EventArgs)" /> 时，一定要调用基类的 <see cref="M:System.Windows.Forms.UpDownBase.OnTextBoxLostFocus(System.Object,System.EventArgs)" /> 方法，以便已注册的委托对事件进行接收。</para></block>
        <altmember cref="E:System.Windows.Forms.Control.LostFocus" />
      </Docs>
    </Member>
    <Member MemberName="OnTextBoxResize">
      <MemberSignature Language="C#" Value="protected virtual void OnTextBoxResize (object source, EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnTextBoxResize(object source, class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.UpDownBase.OnTextBoxResize(System.Object,System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnTextBoxResize (source As Object, e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnTextBoxResize(System::Object ^ source, EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnTextBoxResize : obj * EventArgs -&gt; unit&#xA;override this.OnTextBoxResize : obj * EventArgs -&gt; unit" Usage="upDownBase.OnTextBoxResize (source, e)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Object" />
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="source">事件源。</param>
        <param name="e">包含事件数据的 <see cref="T:System.EventArgs" />。</param>
        <summary>引发 <see cref="E:System.Windows.Forms.Control.Resize" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法调整数字显示框的大小， (也称为 up-down 控件) 在控件的文本框部分调整大小时。  
  
 引发事件时，将通过委托调用事件处理程序。 有关详细信息，请参阅 [处理和引发事件](/dotnet/standard/events/)。  
  
 <xref:System.Windows.Forms.UpDownBase.OnTextBoxResize%2A> 方法还允许派生类对事件进行处理而不必附加委托。 这是在派生类中处理事件的首选技术。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>在派生类中重写 <see cref="M:System.Windows.Forms.UpDownBase.OnTextBoxResize(System.Object,System.EventArgs)" /> 时，一定要调用基类的 <see cref="M:System.Windows.Forms.UpDownBase.OnTextBoxResize(System.Object,System.EventArgs)" /> 方法，以便已注册的委托对事件进行接收。</para></block>
        <altmember cref="E:System.Windows.Forms.Control.Resize" />
      </Docs>
    </Member>
    <Member MemberName="OnTextBoxTextChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnTextBoxTextChanged (object source, EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnTextBoxTextChanged(object source, class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.UpDownBase.OnTextBoxTextChanged(System.Object,System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnTextBoxTextChanged (source As Object, e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnTextBoxTextChanged(System::Object ^ source, EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnTextBoxTextChanged : obj * EventArgs -&gt; unit&#xA;override this.OnTextBoxTextChanged : obj * EventArgs -&gt; unit" Usage="upDownBase.OnTextBoxTextChanged (source, e)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Object" />
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="source">事件源。</param>
        <param name="e">包含事件数据的 <see cref="T:System.EventArgs" />。</param>
        <summary>引发 <see cref="E:System.Windows.Forms.Control.TextChanged" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 引发事件时，将通过委托调用事件处理程序。 有关详细信息，请参阅 [处理和引发事件](/dotnet/standard/events/)。  
  
 <xref:System.Windows.Forms.UpDownBase.OnTextBoxTextChanged%2A> 方法还允许派生类对事件进行处理而不必附加委托。 这是在派生类中处理事件的首选技术。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>在派生类中重写 <see cref="M:System.Windows.Forms.UpDownBase.OnTextBoxTextChanged(System.Object,System.EventArgs)" /> 时，一定要调用基类的 <see cref="M:System.Windows.Forms.UpDownBase.OnTextBoxTextChanged(System.Object,System.EventArgs)" /> 方法，以便已注册的委托对事件进行接收。</para></block>
        <altmember cref="E:System.Windows.Forms.Control.TextChanged" />
      </Docs>
    </Member>
    <Member MemberName="PreferredHeight">
      <MemberSignature Language="C#" Value="public int PreferredHeight { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 PreferredHeight" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.UpDownBase.PreferredHeight" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PreferredHeight As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int PreferredHeight { int get(); };" />
      <MemberSignature Language="F#" Value="member this.PreferredHeight : int" Usage="System.Windows.Forms.UpDownBase.PreferredHeight" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.Browsable(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.Browsable(false)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取数字显示框（也称为 up-down 控件）的高度。</summary>
        <value>数字显示框的高度，以像素为单位。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.UpDownBase.PreferredHeight%2A>属性值基于 <xref:System.Windows.Forms.TextBoxBase.PreferredHeight%2A> 控件的文本框部分的属性，并针对边框样式进行调整。  
  
   
  
## Examples  
 下面的代码示例使用派生类 <xref:System.Windows.Forms.NumericUpDown> 并设置派生自的部分属性 <xref:System.Windows.Forms.UpDownBase> 。 此代码要求在 <xref:System.Windows.Forms.NumericUpDown> 窗体上创建一个控件、两个 <xref:System.Windows.Forms.ComboBox> 控件和三个控件 <xref:System.Windows.Forms.CheckBox> 。 为 <xref:System.Windows.Forms.ComboBox> 控件和添加标签 <xref:System.Windows.Forms.UpDownBase.BorderStyle%2A> <xref:System.Windows.Forms.UpDownBase.TextAlign%2A> 。 为 <xref:System.Windows.Forms.CheckBox> 控件、和添加标签 <xref:System.Windows.Forms.UpDownBase.InterceptArrowKeys%2A> <xref:System.Windows.Forms.UpDownBase.ReadOnly%2A> <xref:System.Windows.Forms.UpDownBase.UpDownAlign%2A> 。 代码允许您在运行时更改属性值，并查看每个属性值如何影响数字显示框的外观和行为。 将以下项添加到标有 BorderStyle：、和的组合框 `None` `Fixed3D` `FixedSingle` 。 将以下项添加到标记为 "文本对齐" 的组合框 `Left` 中：、 `Right` 和 `Center` 。  
  
 [!code-cpp[Classic UpDownBase.BorderStyle Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic UpDownBase.BorderStyle Example/CPP/source.cpp#1)]
 [!code-csharp[Classic UpDownBase.BorderStyle Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic UpDownBase.BorderStyle Example/CS/source.cs#1)]
 [!code-vb[Classic UpDownBase.BorderStyle Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic UpDownBase.BorderStyle Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.TextBoxBase.PreferredHeight" />
      </Docs>
    </Member>
    <Member MemberName="ReadOnly">
      <MemberSignature Language="C#" Value="public bool ReadOnly { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.UpDownBase.ReadOnly" />
      <MemberSignature Language="VB.NET" Value="Public Property ReadOnly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ReadOnly { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ReadOnly : bool with get, set" Usage="System.Windows.Forms.UpDownBase.ReadOnly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.DefaultValue(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.DefaultValue(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指示是否只能使用向上或向下按钮更改文本。</summary>
        <value>如果只能使用向上或向下按钮更改文本，则为 <see langword="true" />；否则为 <see langword="false" />。 默认值是 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 通过将 <xref:System.Windows.Forms.UpDownBase.ReadOnly%2A> 属性设置为 `true` ，您将无需对属性进行很多验证 <xref:System.Windows.Forms.UpDownBase.Text%2A> 。 用户将被限制为使用 "上移" 和 "下移" 按钮来更改 <xref:System.Windows.Forms.UpDownBase.Text%2A> 值。 它将只允许他们选择指定的值。  
  
> [!NOTE]
>  在派生类中 <xref:System.Windows.Forms.DomainUpDown> ，描述的行为稍有不同。 当 <xref:System.Windows.Forms.UpDownBase.ReadOnly%2A> 设置为 `true` 并按下某个键时，控件将选择集合中第一个字符与按下的键匹配的第一项。  
  
   
  
## Examples  
 下面的代码示例使用派生类 <xref:System.Windows.Forms.NumericUpDown> 并设置派生自的部分属性 <xref:System.Windows.Forms.UpDownBase> 。 此代码要求在 <xref:System.Windows.Forms.NumericUpDown> 窗体上创建一个控件、两个 <xref:System.Windows.Forms.ComboBox> 控件和三个控件 <xref:System.Windows.Forms.CheckBox> 。 为 <xref:System.Windows.Forms.ComboBox> 控件和添加标签 <xref:System.Windows.Forms.UpDownBase.BorderStyle%2A> <xref:System.Windows.Forms.UpDownBase.TextAlign%2A> 。 为 <xref:System.Windows.Forms.CheckBox> 控件、和添加标签 <xref:System.Windows.Forms.UpDownBase.InterceptArrowKeys%2A> <xref:System.Windows.Forms.UpDownBase.ReadOnly%2A> <xref:System.Windows.Forms.UpDownBase.UpDownAlign%2A> 。 代码允许您在运行时更改属性值，并查看每个属性值如何影响数字显示框的外观和行为。 将以下项添加到标有 BorderStyle：、和的组合框 `None` `Fixed3D` `FixedSingle` 。 将以下项添加到标记为 "文本对齐" 的组合框 `Left` 中：、 `Right` 和 `Center` 。  
  
 [!code-cpp[Classic UpDownBase Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic UpDownBase Example/CPP/source.cpp#1)]
 [!code-csharp[Classic UpDownBase Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic UpDownBase Example/CS/source.cs#1)]
 [!code-vb[Classic UpDownBase Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic UpDownBase Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.UpDownBase.Text" />
      </Docs>
    </Member>
    <Member MemberName="RescaleConstantsForDpi">
      <MemberSignature Language="C#" Value="protected override void RescaleConstantsForDpi (int deviceDpiOld, int deviceDpiNew);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void RescaleConstantsForDpi(int32 deviceDpiOld, int32 deviceDpiNew) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.UpDownBase.RescaleConstantsForDpi(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub RescaleConstantsForDpi (deviceDpiOld As Integer, deviceDpiNew As Integer)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void RescaleConstantsForDpi(int deviceDpiOld, int deviceDpiNew);" />
      <MemberSignature Language="F#" Value="override this.RescaleConstantsForDpi : int * int -&gt; unit" Usage="upDownBase.RescaleConstantsForDpi (deviceDpiOld, deviceDpiNew)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="deviceDpiOld" Type="System.Int32" Index="0" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="deviceDpiNew" Type="System.Int32" Index="1" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="deviceDpiOld">更改前的 DPI 值。</param>
        <param name="deviceDpiNew">更改后的 DPI 值。</param>
        <summary>发生 DPI 更改时，提供用于重新缩放控件的常数。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Select">
      <MemberSignature Language="C#" Value="public void Select (int start, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Select(int32 start, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.UpDownBase.Select(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Select (start As Integer, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Select(int start, int length);" />
      <MemberSignature Language="F#" Value="override this.Select : int * int -&gt; unit" Usage="upDownBase.Select (start, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="start" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="start">要选择的第一个字符的位置。</param>
        <param name="length">要选择的总字符数。</param>
        <summary>在数字显示框（也称为 up-down 控件）中选择一个文本范围，该范围指定起始位置和要选择的字符数。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当 <xref:System.Windows.Forms.UpDownBase.Select%2A> 数字显示框获得焦点时，或在属性无法进行数据验证时，可以使用方法 <xref:System.Windows.Forms.UpDownBase.Text%2A> 。 在派生类中添加方法的验证代码时 <xref:System.Windows.Forms.UpDownBase.ValidateEditText%2A> ，在 <xref:System.Windows.Forms.UpDownBase.Select%2A> 验证失败时调用方法。  
  
   
  
## Examples  
 下面的代码示例使用派生类 <xref:System.Windows.Forms.NumericUpDown> 。 此代码要求 <xref:System.Windows.Forms.NumericUpDown> <xref:System.Windows.Forms.Button> 在窗体上创建了控件和，并将 <xref:System.Drawing> 命名空间添加为引用。 在 <xref:System.Windows.Forms.Control.Click> 按钮的事件上，控件中文本的点大小将 <xref:System.Windows.Forms.NumericUpDown> 增加。 这会提示控件调整其 <xref:System.Windows.Forms.UpDownBase.PreferredHeight%2A> 属性，以便所有文本在控件中可见。 用户输入新值并离开 <xref:System.Windows.Forms.NumericUpDown> 控件后，文本将转换为字符串值的数值，并验证为介于 <xref:System.Windows.Forms.NumericUpDown.Minimum%2A> 和 <xref:System.Windows.Forms.NumericUpDown.Maximum%2A> 值之间。 如果值无效， <xref:System.Windows.Forms.MessageBox> 则会显示错误， <xref:System.Windows.Forms.UpDownBase.Select%2A> 方法将选择文本，以便用户可以输入新值。  
  
 [!code-cpp[Classic UpDownBase.Text Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic UpDownBase.Text Example/CPP/source.cpp#1)]
 [!code-csharp[Classic UpDownBase.Text Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic UpDownBase.Text Example/CS/source.cs#1)]
 [!code-vb[Classic UpDownBase.Text Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic UpDownBase.Text Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.UpDownBase.ValidateEditText" />
      </Docs>
    </Member>
    <Member MemberName="SetBoundsCore">
      <MemberSignature Language="C#" Value="protected override void SetBoundsCore (int x, int y, int width, int height, System.Windows.Forms.BoundsSpecified specified);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void SetBoundsCore(int32 x, int32 y, int32 width, int32 height, valuetype System.Windows.Forms.BoundsSpecified specified) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.UpDownBase.SetBoundsCore(System.Int32,System.Int32,System.Int32,System.Int32,System.Windows.Forms.BoundsSpecified)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub SetBoundsCore (x As Integer, y As Integer, width As Integer, height As Integer, specified As BoundsSpecified)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void SetBoundsCore(int x, int y, int width, int height, System::Windows::Forms::BoundsSpecified specified);" />
      <MemberSignature Language="F#" Value="override this.SetBoundsCore : int * int * int * int * System.Windows.Forms.BoundsSpecified -&gt; unit" Usage="upDownBase.SetBoundsCore (x, y, width, height, specified)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Int32" Index="0" FrameworkAlternate="netframework-1.1" />
        <Parameter Name="y" Type="System.Int32" Index="1" FrameworkAlternate="netframework-1.1" />
        <Parameter Name="width" Type="System.Int32" Index="2" FrameworkAlternate="netframework-1.1" />
        <Parameter Name="height" Type="System.Int32" Index="3" FrameworkAlternate="netframework-1.1" />
        <Parameter Name="specified" Type="System.Windows.Forms.BoundsSpecified" Index="4" FrameworkAlternate="netframework-1.1" />
      </Parameters>
      <Docs>
        <param name="x">控件的新 <see cref="P:System.Windows.Forms.Control.Left" /> 属性值。</param>
        <param name="y">控件的新 <see cref="P:System.Windows.Forms.Control.Top" /> 属性值。</param>
        <param name="width">控件的新 <see cref="P:System.Windows.Forms.Control.Width" /> 属性值。</param>
        <param name="height">控件的新 <see cref="P:System.Windows.Forms.Control.Height" /> 属性值。</param>
        <param name="specified">枚举值的按位组合。</param>
        <summary>执行设置该控件的指定边界的工作。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Text">
      <MemberSignature Language="C#" Value="public override string Text { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Text" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.UpDownBase.Text" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Text As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Text { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Text : string with get, set" Usage="System.Windows.Forms.UpDownBase.Text" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.Localizable(true)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.Localizable(true)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置数字显示框（也称为 up-down 控件）中显示的文本。</summary>
        <value>数字显示框中显示的字符串值。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.UpDownBase.UpdateEditText%2A>如果在 <xref:System.Windows.Forms.UpDownBase.Text%2A> 属性设置为时设置了属性，则调用方法 <xref:System.Windows.Forms.UpDownBase.UserEdit%2A> `true` 。 <xref:System.Windows.Forms.UpDownBase.ValidateEditText%2A>如果在 <xref:System.Windows.Forms.UpDownBase.Text%2A> 属性设置为时设置了属性，则调用方法 <xref:System.Windows.Forms.UpDownBase.UserEdit%2A> `false` 。  
  
   
  
## Examples  
 下面的代码示例使用派生类 <xref:System.Windows.Forms.NumericUpDown> 。 此代码要求 <xref:System.Windows.Forms.NumericUpDown> <xref:System.Windows.Forms.Button> 在窗体上创建了控件和，并将 <xref:System.Drawing> 命名空间添加为引用。 在 <xref:System.Windows.Forms.Control.Click> 按钮的事件上，控件中文本的点大小将 <xref:System.Windows.Forms.NumericUpDown> 增加。 这会提示控件调整其 <xref:System.Windows.Forms.UpDownBase.PreferredHeight%2A> 属性，以便所有文本在控件中可见。 用户输入新值并离开 <xref:System.Windows.Forms.NumericUpDown> 控件后，文本将转换为字符串值的数值，并验证为介于 <xref:System.Windows.Forms.NumericUpDown.Minimum%2A> 和 <xref:System.Windows.Forms.NumericUpDown.Maximum%2A> 值之间。 如果值无效， <xref:System.Windows.Forms.MessageBox> 则会显示错误， <xref:System.Windows.Forms.UpDownBase.Select%2A> 方法将选择文本，以便用户可以输入新值。  
  
 [!code-cpp[Classic UpDownBase.Text Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic UpDownBase.Text Example/CPP/source.cpp#1)]
 [!code-csharp[Classic UpDownBase.Text Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic UpDownBase.Text Example/CS/source.cs#1)]
 [!code-vb[Classic UpDownBase.Text Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic UpDownBase.Text Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.UpDownBase.UserEdit" />
        <altmember cref="M:System.Windows.Forms.UpDownBase.UpdateEditText" />
        <altmember cref="M:System.Windows.Forms.UpDownBase.ValidateEditText" />
      </Docs>
    </Member>
    <Member MemberName="TextAlign">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.HorizontalAlignment TextAlign { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.HorizontalAlignment TextAlign" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.UpDownBase.TextAlign" />
      <MemberSignature Language="VB.NET" Value="Public Property TextAlign As HorizontalAlignment" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::HorizontalAlignment TextAlign { System::Windows::Forms::HorizontalAlignment get(); void set(System::Windows::Forms::HorizontalAlignment value); };" />
      <MemberSignature Language="F#" Value="member this.TextAlign : System.Windows.Forms.HorizontalAlignment with get, set" Usage="System.Windows.Forms.UpDownBase.TextAlign" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.Localizable(true)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.Localizable(true)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HorizontalAlignment</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置数字显示框（也称为 up-down 控件）中文本的对齐方式。</summary>
        <value><see cref="T:System.Windows.Forms.HorizontalAlignment" /> 值之一。 默认值是 <see cref="F:System.Windows.Forms.HorizontalAlignment.Left" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下面的代码示例使用派生类 <xref:System.Windows.Forms.NumericUpDown> 并设置派生自的部分属性 <xref:System.Windows.Forms.UpDownBase> 。 此代码要求你有一个名为的 <xref:System.Windows.Forms.NumericUpDown> 控件和 `numericUpDown1` 两个名 <xref:System.Windows.Forms.ComboBox> 为和的控件 `comboBox1` `comboBox2` ，以及 <xref:System.Windows.Forms.CheckBox> `checkBox1` `checkBox2` `checkBox2` 在窗体上创建的名为、和的三个控件。 将以下项添加到 `comboBox1` ： `None` 、 `Fixed3D` 和 `FixedSingle` 。 将以下项添加到 `comboBox2` ： `Left` 、 `Right` 和 `Center` 。  
  
 代码允许您在运行时更改属性值，并查看每个属性值如何影响数字显示框的外观和行为。  
  
 [!code-cpp[Classic UpDownBase Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic UpDownBase Example/CPP/source.cpp#1)]
 [!code-csharp[Classic UpDownBase Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic UpDownBase Example/CS/source.cs#1)]
 [!code-vb[Classic UpDownBase Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic UpDownBase Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">分配的值不是 <see cref="T:System.Windows.Forms.HorizontalAlignment" /> 值之一。</exception>
        <altmember cref="P:System.Windows.Forms.UpDownBase.UpDownAlign" />
      </Docs>
    </Member>
    <Member MemberName="UpButton">
      <MemberSignature Language="C#" Value="public abstract void UpButton ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void UpButton() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.UpDownBase.UpButton" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub UpButton ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void UpButton();" />
      <MemberSignature Language="F#" Value="abstract member UpButton : unit -&gt; unit" Usage="upDownBase.UpButton " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>在派生类中被重写时，处理单击数字显示框（也称为 up-down 控件）上向上按钮的操作。</summary>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides"><para>在派生类中重写此方法时，请确保调用 <see cref="M:System.Windows.Forms.UpDownBase.UpdateEditText" /> 方法。</para></block>
        <altmember cref="M:System.Windows.Forms.UpDownBase.DownButton" />
      </Docs>
    </Member>
    <Member MemberName="UpdateEditText">
      <MemberSignature Language="C#" Value="protected abstract void UpdateEditText ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void UpdateEditText() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.UpDownBase.UpdateEditText" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Sub UpdateEditText ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract void UpdateEditText();" />
      <MemberSignature Language="F#" Value="abstract member UpdateEditText : unit -&gt; unit" Usage="upDownBase.UpdateEditText " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>在派生类中被重写时，更新在数字显示框（也称为 up-down 控件）中显示的文本。</summary>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides"><para>在派生类中重写此方法时，请确保更新 <see cref="P:System.Windows.Forms.UpDownBase.Text" /> 数字显示框的属性。</para></block>
        <altmember cref="M:System.Windows.Forms.UpDownBase.UpButton" />
        <altmember cref="M:System.Windows.Forms.UpDownBase.DownButton" />
      </Docs>
    </Member>
    <Member MemberName="UpDownAlign">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.LeftRightAlignment UpDownAlign { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.LeftRightAlignment UpDownAlign" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.UpDownBase.UpDownAlign" />
      <MemberSignature Language="VB.NET" Value="Public Property UpDownAlign As LeftRightAlignment" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::LeftRightAlignment UpDownAlign { System::Windows::Forms::LeftRightAlignment get(); void set(System::Windows::Forms::LeftRightAlignment value); };" />
      <MemberSignature Language="F#" Value="member this.UpDownAlign : System.Windows.Forms.LeftRightAlignment with get, set" Usage="System.Windows.Forms.UpDownBase.UpDownAlign" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.Localizable(true)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.Localizable(true)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.LeftRightAlignment</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置数字显示框（也称为 up-down 控件）中向上和向下按钮的对齐方式。</summary>
        <value><see cref="T:System.Windows.Forms.LeftRightAlignment" /> 值之一。 默认值是 <see cref="F:System.Windows.Forms.LeftRightAlignment.Right" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下面的代码示例使用派生类 <xref:System.Windows.Forms.NumericUpDown> 并设置派生自的部分属性 <xref:System.Windows.Forms.UpDownBase> 。 此代码要求你有一个名为的 <xref:System.Windows.Forms.NumericUpDown> 控件和 `numericUpDown1` 两个名 <xref:System.Windows.Forms.ComboBox> 为和的控件 `comboBox1` `comboBox2` ，以及 <xref:System.Windows.Forms.CheckBox> `checkBox1` `checkBox2` `checkBox2` 在窗体上创建的名为、和的三个控件。 将以下项添加到 `comboBox1` ： `None` 、 `Fixed3D` 和 `FixedSingle` 。 将以下项添加到 `comboBox2` ： `Left` 、 `Right` 和 `Center` 。  
  
 代码允许您在运行时更改属性值，并查看每个属性值如何影响数字显示框的外观和行为。  
  
 [!code-cpp[Classic UpDownBase Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic UpDownBase Example/CPP/source.cpp#1)]
 [!code-csharp[Classic UpDownBase Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic UpDownBase Example/CS/source.cs#1)]
 [!code-vb[Classic UpDownBase Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic UpDownBase Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">分配的值不是 <see cref="T:System.Windows.Forms.LeftRightAlignment" /> 值之一。</exception>
        <altmember cref="T:System.Windows.Forms.HorizontalAlignment" />
      </Docs>
    </Member>
    <Member MemberName="UserEdit">
      <MemberSignature Language="C#" Value="protected bool UserEdit { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UserEdit" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.UpDownBase.UserEdit" />
      <MemberSignature Language="VB.NET" Value="Protected Property UserEdit As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property bool UserEdit { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UserEdit : bool with get, set" Usage="System.Windows.Forms.UpDownBase.UserEdit" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指示用户是否已输入值。</summary>
        <value>如果用户已更改了 <see cref="P:System.Windows.Forms.UpDownBase.Text" /> 属性，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果在 <xref:System.Windows.Forms.UpDownBase.Text%2A> 属性设置为时设置了该属性 <xref:System.Windows.Forms.UpDownBase.UserEdit%2A> `true` ，则 <xref:System.Windows.Forms.UpDownBase.UpdateEditText%2A> 调用方法。 如果在 <xref:System.Windows.Forms.UpDownBase.Text%2A> 属性设置为时设置了该属性 <xref:System.Windows.Forms.UpDownBase.UserEdit%2A> `false` ，则 <xref:System.Windows.Forms.UpDownBase.ValidateEditText%2A> 调用方法。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.UpDownBase.Text" />
        <altmember cref="M:System.Windows.Forms.UpDownBase.UpdateEditText" />
        <altmember cref="M:System.Windows.Forms.UpDownBase.ValidateEditText" />
      </Docs>
    </Member>
    <Member MemberName="ValidateEditText">
      <MemberSignature Language="C#" Value="protected virtual void ValidateEditText ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void ValidateEditText() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.UpDownBase.ValidateEditText" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub ValidateEditText ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void ValidateEditText();" />
      <MemberSignature Language="F#" Value="abstract member ValidateEditText : unit -&gt; unit&#xA;override this.ValidateEditText : unit -&gt; unit" Usage="upDownBase.ValidateEditText " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>在派生类中被重写时，验证在数字显示框（也称为 up-down 控件）中显示的文本。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 验证的一些示例包括将输入的文本与派生类中设置的数据类型进行比较，将文本与值列表进行比较，或验证文本是否在值范围内。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>在派生类中重写此方法时，请确保在此方法中添加代码以验证数字显示框的文本。 如果属性设置为，则将调用此方法 <see cref="P:System.Windows.Forms.UpDownBase.UserEdit" /> <see langword="false" /> <see cref="P:System.Windows.Forms.UpDownBase.Text" /> 。</para></block>
        <altmember cref="P:System.Windows.Forms.UpDownBase.UserEdit" />
        <altmember cref="P:System.Windows.Forms.UpDownBase.Text" />
      </Docs>
    </Member>
    <Member MemberName="WndProc">
      <MemberSignature Language="C#" Value="protected override void WndProc (ref System.Windows.Forms.Message m);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void WndProc(valuetype System.Windows.Forms.Message&amp; m) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.UpDownBase.WndProc(System.Windows.Forms.Message@)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub WndProc (ByRef m As Message)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void WndProc(System::Windows::Forms::Message % m);" />
      <MemberSignature Language="F#" Value="override this.WndProc : Message -&gt; unit" Usage="upDownBase.WndProc m" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="m" Type="System.Windows.Forms.Message" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="m">要处理的 Windows <see cref="T:System.Windows.Forms.Message" />。</param>
        <summary>处理 Windows 消息。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
