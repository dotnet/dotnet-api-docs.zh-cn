<Type Name="TextBoxBase" FullName="System.Windows.Forms.TextBoxBase">
  <Metadata><Meta Name="ms.openlocfilehash" Value="c77061fe819b7bd71b81bd3c05acddb4ae80956c" /><Meta Name="ms.sourcegitcommit" Value="c982ad9e10a242d90f1e631b5981570f9e5d9f34" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-CN" /><Meta Name="ms.lasthandoff" Value="09/10/2020" /><Meta Name="ms.locfileid" Value="89779879" /></Metadata><TypeSignature Language="C#" Value="public abstract class TextBoxBase : System.Windows.Forms.Control" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit TextBoxBase extends System.Windows.Forms.Control" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Forms.TextBoxBase" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class TextBoxBase&#xA;Inherits Control" />
  <TypeSignature Language="C++ CLI" Value="public ref class TextBoxBase abstract : System::Windows::Forms::Control" />
  <TypeSignature Language="F#" Value="type TextBoxBase = class&#xA;    inherit Control" />
  <AssemblyInfo>
    <AssemblyName>System.Windows.Forms</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>5.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Forms.Control</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName Language="C#">[System.ComponentModel.DefaultBindingProperty("Text")]</AttributeName>
      <AttributeName Language="F#">[&lt;System.ComponentModel.DefaultBindingProperty("Text")&gt;]</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName Language="C#">[System.ComponentModel.DefaultEvent("TextChanged")]</AttributeName>
      <AttributeName Language="F#">[&lt;System.ComponentModel.DefaultEvent("TextChanged")&gt;]</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName Language="C#">[System.ComponentModel.Designer("System.Windows.Forms.Design.TextBoxBaseDesigner, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")]</AttributeName>
      <AttributeName Language="F#">[&lt;System.ComponentModel.Designer("System.Windows.Forms.Design.TextBoxBaseDesigner, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")&gt;]</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName Language="C#">[System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.AutoDispatch)]</AttributeName>
      <AttributeName Language="F#">[&lt;System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.AutoDispatch)&gt;]</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName Language="C#">[System.Runtime.InteropServices.ComVisible(true)]</AttributeName>
      <AttributeName Language="F#">[&lt;System.Runtime.InteropServices.ComVisible(true)&gt;]</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1">
      <AttributeName Language="C#">[System.ComponentModel.Designer("System.Windows.Forms.Design.TextBoxBaseDesigner, System.Design, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")]</AttributeName>
      <AttributeName Language="F#">[&lt;System.ComponentModel.Designer("System.Windows.Forms.Design.TextBoxBaseDesigner, System.Design, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")&gt;]</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
      <AttributeName Language="C#">[System.ComponentModel.Designer("System.Windows.Forms.Design.TextBoxBaseDesigner, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")]</AttributeName>
      <AttributeName Language="F#">[&lt;System.ComponentModel.Designer("System.Windows.Forms.Design.TextBoxBaseDesigner, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")&gt;]</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>实现文本控件要求的基本功能。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此类实现文本操作控件（如和）的核心功能 <xref:System.Windows.Forms.TextBox> <xref:System.Windows.Forms.RichTextBox> 。 其中包括文本选择、 **剪贴板** 功能、多行文本控件支持和多个事件。  
  
   
  
## Examples  
 下面的代码示例使用 <xref:System.Windows.Forms.TextBox> 派生类创建 <xref:System.Windows.Forms.TextBox> 具有垂直滚动条的多行控件。 此示例还使用 <xref:System.Windows.Forms.TextBoxBase.AcceptsTab%2A> 、 <xref:System.Windows.Forms.TextBox.AcceptsReturn%2A> 和 <xref:System.Windows.Forms.TextBoxBase.WordWrap%2A> 属性使 "多行文本框" 控件对创建文本文档有用。  
  
 [!code-cpp[Classic TextBoxBase.AcceptsTab Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic TextBoxBase.AcceptsTab Example/CPP/source.cpp#1)]
 [!code-csharp[Classic TextBoxBase.AcceptsTab Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic TextBoxBase.AcceptsTab Example/CS/source.cs#1)]
 [!code-vb[Classic TextBoxBase.AcceptsTab Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic TextBoxBase.AcceptsTab Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <block subset="none" type="overrides"><para>通常不会从继承 <see cref="T:System.Windows.Forms.TextBoxBase" /> 。 若要创建自己的文本控件类，请从 <see cref="T:System.Windows.Forms.TextBox" /> 或继承 <see cref="T:System.Windows.Forms.RichTextBox" /> 。</para></block>
    <altmember cref="T:System.Windows.Forms.TextBox" />
    <altmember cref="T:System.Windows.Forms.RichTextBox" />
  </Docs>
  <Members>
    <Member MemberName="AcceptsTab">
      <MemberSignature Language="C#" Value="public bool AcceptsTab { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AcceptsTab" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.TextBoxBase.AcceptsTab" />
      <MemberSignature Language="VB.NET" Value="Public Property AcceptsTab As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AcceptsTab { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AcceptsTab : bool with get, set" Usage="System.Windows.Forms.TextBoxBase.AcceptsTab" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.DefaultValue(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.DefaultValue(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指示在多行文本框控件中按 Tab 键时，是否在控件中键入一个 Tab 字符，而不是按选项卡的顺序将焦点移动到下一个控件。</summary>
        <value>如果用户可以使用 Tab 键在多行文本框控件中输入 Tab 字符，则为 <see langword="true" />；如果按 Tab 键移动焦点，则为 <see langword="false" />。 默认值为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.TextBoxBase.Multiline%2A>属性还必须为 `true` 以在控件中获取制表符。  
  
 如果 <xref:System.Windows.Forms.TextBoxBase.AcceptsTab%2A> 属性设置为 `true` ，则用户必须按 CTRL + tab 将焦点按 tab 键顺序移到下一个控件。  
  
   
  
## Examples  
 下面的代码示例使用 <xref:System.Windows.Forms.TextBox> 派生类创建 <xref:System.Windows.Forms.TextBox> 具有垂直滚动条的多行控件。 此示例还使用 <xref:System.Windows.Forms.TextBoxBase.AcceptsTab%2A> 、 <xref:System.Windows.Forms.TextBox.AcceptsReturn%2A> 和 <xref:System.Windows.Forms.TextBoxBase.WordWrap%2A> 属性使 "多行文本框" 控件对创建文本文档有用。  
  
 [!code-cpp[Classic TextBoxBase.AcceptsTab Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic TextBoxBase.AcceptsTab Example/CPP/source.cpp#1)]
 [!code-csharp[Classic TextBoxBase.AcceptsTab Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic TextBoxBase.AcceptsTab Example/CS/source.cs#1)]
 [!code-vb[Classic TextBoxBase.AcceptsTab Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic TextBoxBase.AcceptsTab Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.TextBox.AcceptsReturn" />
      </Docs>
    </Member>
    <Member MemberName="AcceptsTabChanged">
      <MemberSignature Language="C#" Value="public event EventHandler AcceptsTabChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler AcceptsTabChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.TextBoxBase.AcceptsTabChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event AcceptsTabChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ AcceptsTabChanged;" />
      <MemberSignature Language="F#" Value="member this.AcceptsTabChanged : EventHandler " Usage="member this.AcceptsTabChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在 <see cref="P:System.Windows.Forms.TextBoxBase.AcceptsTab" /> 属性的值更改后发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 有关如何处理事件的详细信息，请参阅 [处理和引发事件](/dotnet/standard/events/)。  
  
   
  
## Examples  
 下面的代码示例演示如何使用此成员。 在此示例中，事件处理程序报告事件的发生 <xref:System.Windows.Forms.TextBoxBase.AcceptsTabChanged> 。 此报表可帮助你了解何时发生事件，并可帮助你进行调试。 若要报告多个事件或频繁发生的事件，请考虑 <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> 将消息替换为多行或将其追加到多行 <xref:System.Windows.Forms.TextBox> 。  
  
 若要运行示例代码，请将其粘贴到一个项目中，该项目包含从继承的类型的实例 <xref:System.Windows.Forms.TextBoxBase> ，如 <xref:System.Windows.Forms.TextBox> 或 <xref:System.Windows.Forms.TextBoxBase> 。 然后命名该实例 `TextBoxBase1` ，并确保事件处理程序与事件相关联 <xref:System.Windows.Forms.TextBoxBase.AcceptsTabChanged> 。  
  
 [!code-csharp[System.Windows.Forms.EventExamples#241](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#241)]
 [!code-vb[System.Windows.Forms.EventExamples#241](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#241)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.TextBoxBase.AcceptsTab" />
      </Docs>
    </Member>
    <Member MemberName="AppendText">
      <MemberSignature Language="C#" Value="public void AppendText (string text);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AppendText(string text) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.TextBoxBase.AppendText(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AppendText (text As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AppendText(System::String ^ text);" />
      <MemberSignature Language="F#" Value="member this.AppendText : string -&gt; unit" Usage="textBoxBase.AppendText text" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="text" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="text">要向文本框的当前内容追加的文本。</param>
        <summary>向文本框的当前文本追加文本。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 您可以使用此方法将文本添加到控件中的现有文本，而不是使用串联运算符 (+) 将文本连接到 <xref:System.Windows.Forms.TextBoxBase.Text%2A> 属性。  
  
   
  
## Examples  
 下面的代码示例演示如何使用 <xref:System.Windows.Forms.TextBoxBase.AppendText%2A> 方法和 <xref:System.Windows.Forms.TextBoxBase.TextLength%2A> 属性将文本从一个复制 <xref:System.Windows.Forms.TextBox> 到另一个。 此示例要求 <xref:System.Windows.Forms.TextBox> 在窗体中添加了名为和的两个控件， `textBox1` 并将文本分配给了 `textBox2` `textBox1` 其 <xref:System.Windows.Forms.Control.Text%2A> 属性。  
  
 [!code-cpp[TextBoxBase.AppendText#1](~/samples/snippets/cpp/VS_Snippets_Winforms/TextBoxBase.AppendText/CPP/form1.cpp#1)]
 [!code-csharp[TextBoxBase.AppendText#1](~/samples/snippets/csharp/VS_Snippets_Winforms/TextBoxBase.AppendText/CS/form1.cs#1)]
 [!code-vb[TextBoxBase.AppendText#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/TextBoxBase.AppendText/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.TextBoxBase.Copy" />
        <altmember cref="M:System.Windows.Forms.TextBoxBase.Paste" />
      </Docs>
    </Member>
    <Member MemberName="AutoSize">
      <MemberSignature Language="C#" Value="public override bool AutoSize { get; set; }" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AutoSize" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.TextBoxBase.AutoSize" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property AutoSize As Boolean" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool AutoSize { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AutoSize : bool with get, set" Usage="System.Windows.Forms.TextBoxBase.AutoSize" />
      <MemberSignature Language="C#" Value="public virtual bool AutoSize { get; set; }" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property AutoSize As Boolean" FrameworkAlternate="netframework-1.1" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.ComponentModel.Browsable(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.Browsable(false)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.DefaultValue(true)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.DefaultValue(true)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.Localizable(true)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.Localizable(true)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.RefreshProperties(System.ComponentModel.RefreshProperties.Repaint)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.RefreshProperties(System.ComponentModel.RefreshProperties.Repaint)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指示当更改分配给控件的字体时，是否自动调整控件的高度。</summary>
        <value>如果在更改字体时自动调整控件的高度，则为 <see langword="true" />；否则为 <see langword="false" />。 默认值为 <see langword="true" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果将的 <xref:System.Windows.Forms.TextBoxBase.AutoSize%2A> 属性设置为，则在更改时，将 `true` <xref:System.Windows.Forms.TextBox> <xref:System.Windows.Forms.Control.Font%2A> <xref:System.Windows.Forms.TextBox> 展开或收缩 <xref:System.Windows.Forms.Control.Height%2A> 以容纳更大或更小的文本。 的 <xref:System.Windows.Forms.Control.Width%2A> <xref:System.Windows.Forms.TextBox> 不会更改。  
  
 如果要在用户输入文本时更改控件的大小，则可以使用 <xref:System.Windows.Forms.RichTextBox> 控件并使用其 <xref:System.Windows.Forms.RichTextBox.ContentsResized> 事件更改其大小。  
  
   
  
## Examples  
 此示例假设你有一个窗体，其中包含两个文本框，两个按钮，然后单击每个按钮的 "事件"。 该示例演示 <xref:System.Windows.Forms.TextBoxBase.AutoSize%2A> 属性，方法是将其设置为，将其设置为，并将其设置为 `true` `false` 。 单击一个按钮时，文本框将用较小的文本进行填充，单击另一个按钮时，文本框将用较大的文本进行填充。 已 <xref:System.Windows.Forms.TextBoxBase.AutoSize%2A> 设置为 `true` 容纳较大文本的文本框。 不会更改宽度。  
  
 [!code-csharp[SystemWindowsFormsAutoSize#1](~/samples/snippets/csharp/VS_Snippets_Winforms/SystemWindowsFormsAutoSize/CS/Form1.cs#1)]
 [!code-vb[SystemWindowsFormsAutoSize#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/SystemWindowsFormsAutoSize/VB/Form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AutoSizeChanged">
      <MemberSignature Language="C#" Value="public event EventHandler AutoSizeChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler AutoSizeChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.TextBoxBase.AutoSizeChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event AutoSizeChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ AutoSizeChanged;" />
      <MemberSignature Language="F#" Value="member this.AutoSizeChanged : EventHandler " Usage="member this.AutoSizeChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.ComponentModel.Browsable(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.Browsable(false)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>此事件与此类无关。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此事件与此类无关。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BackColor">
      <MemberSignature Language="C#" Value="public override System.Drawing.Color BackColor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Color BackColor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.TextBoxBase.BackColor" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property BackColor As Color" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Drawing::Color BackColor { System::Drawing::Color get(); void set(System::Drawing::Color value); };" />
      <MemberSignature Language="F#" Value="member this.BackColor : System.Drawing.Color with get, set" Usage="System.Windows.Forms.TextBoxBase.BackColor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.InteropServices.DispId(-501)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.InteropServices.DispId(-501)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Color</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置控件的背景色。</summary>
        <value>表示控件背景色的 <see cref="T:System.Drawing.Color" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 您可以使用 <xref:System.Windows.Forms.TextBoxBase.BackColor%2A> 属性更改文本控件的背景色，以将其与窗体的配色方案混合。  
  
 若要更改控件中的文本的颜色，请使用 <xref:System.Windows.Forms.TextBoxBase.ForeColor%2A> 属性。 设置 <xref:System.Windows.Forms.TextBoxBase.BackColor%2A> 文本控件的属性时，请确保所选颜色不会导致控件文本消失。 例如，如果 <xref:System.Windows.Forms.TextBoxBase.BackColor%2A> 和属性都 <xref:System.Windows.Forms.TextBoxBase.ForeColor%2A> 设置为 `Color.Black` ，则 textbox 控件中的文本将不可见。  
  
 如果将 <xref:System.Windows.Forms.TextBoxBase.ReadOnly%2A> 的属性设置为，则此属性可能会超过替代 <xref:System.Windows.Forms.TextBoxBase> `true` 。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.TextBoxBase.ForeColor" />
      </Docs>
    </Member>
    <Member MemberName="BackgroundImage">
      <MemberSignature Language="C#" Value="public override System.Drawing.Image BackgroundImage { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Drawing.Image BackgroundImage" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.TextBoxBase.BackgroundImage" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property BackgroundImage As Image" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Drawing::Image ^ BackgroundImage { System::Drawing::Image ^ get(); void set(System::Drawing::Image ^ value); };" />
      <MemberSignature Language="F#" Value="member this.BackgroundImage : System.Drawing.Image with get, set" Usage="System.Windows.Forms.TextBoxBase.BackgroundImage" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.Browsable(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.Browsable(false)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Image</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>此属性与此类无关。</summary>
        <value>对象的背景图像。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此属性与此类无关。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BackgroundImageChanged">
      <MemberSignature Language="C#" Value="public event EventHandler BackgroundImageChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler BackgroundImageChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.TextBoxBase.BackgroundImageChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event BackgroundImageChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ BackgroundImageChanged;" />
      <MemberSignature Language="F#" Value="member this.BackgroundImageChanged : EventHandler " Usage="member this.BackgroundImageChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.Browsable(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.Browsable(false)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当 <see cref="P:System.Windows.Forms.TextBoxBase.BackgroundImage" /> 属性的值更改时发生。 此事件与此类无关。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此事件与此类无关。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BackgroundImageLayout">
      <MemberSignature Language="C#" Value="public override System.Windows.Forms.ImageLayout BackgroundImageLayout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.ImageLayout BackgroundImageLayout" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.TextBoxBase.BackgroundImageLayout" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property BackgroundImageLayout As ImageLayout" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Windows::Forms::ImageLayout BackgroundImageLayout { System::Windows::Forms::ImageLayout get(); void set(System::Windows::Forms::ImageLayout value); };" />
      <MemberSignature Language="F#" Value="member this.BackgroundImageLayout : System.Windows.Forms.ImageLayout with get, set" Usage="System.Windows.Forms.TextBoxBase.BackgroundImageLayout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.ComponentModel.Browsable(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.Browsable(false)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.ImageLayout</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>此属性与此类无关。</summary>
        <value><see cref="T:System.Windows.Forms.ImageLayout" /> 值之一。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此属性与此类无关。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BackgroundImageLayoutChanged">
      <MemberSignature Language="C#" Value="public event EventHandler BackgroundImageLayoutChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler BackgroundImageLayoutChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.TextBoxBase.BackgroundImageLayoutChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event BackgroundImageLayoutChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ BackgroundImageLayoutChanged;" />
      <MemberSignature Language="F#" Value="member this.BackgroundImageLayoutChanged : EventHandler " Usage="member this.BackgroundImageLayoutChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.ComponentModel.Browsable(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.Browsable(false)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当 <see cref="P:System.Windows.Forms.TextBoxBase.BackgroundImageLayout" /> 属性的值更改时发生。 此事件与此类无关。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此事件与此类无关。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BorderStyle">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.BorderStyle BorderStyle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.BorderStyle BorderStyle" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.TextBoxBase.BorderStyle" />
      <MemberSignature Language="VB.NET" Value="Public Property BorderStyle As BorderStyle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::BorderStyle BorderStyle { System::Windows::Forms::BorderStyle get(); void set(System::Windows::Forms::BorderStyle value); };" />
      <MemberSignature Language="F#" Value="member this.BorderStyle : System.Windows.Forms.BorderStyle with get, set" Usage="System.Windows.Forms.TextBoxBase.BorderStyle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.InteropServices.DispId(-504)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.InteropServices.DispId(-504)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.BorderStyle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置文本框控件的边框类型。</summary>
        <value>表示文本框控件边框类型的 <see cref="T:System.Windows.Forms.BorderStyle" />。 默认值为 <see langword="Fixed3D" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.TextBoxBase.BorderStyle%2A>除了默认的三维控件外，还可以使用属性创建无边框和平面样式的控件。  
  
> [!NOTE]
>  派生类 <xref:System.Windows.Forms.RichTextBox> 不支持 `BorderStyle.FixedSingle` 样式。 此样式将导致 <xref:System.Windows.Forms.BorderStyle> 改为使用 `BorderStyle.Fixed3D` 样式。  
  
   
  
## Examples  
 下面的代码示例使用 <xref:System.Windows.Forms.TextBox> 派生类来创建一个文本框，该文本框可使用带有单一边框的20点 Arial 来正确显示文本。 此示例使用 <xref:System.Windows.Forms.TextBoxBase.PreferredHeight%2A> 属性来确定控件在字体后的适当高度，并将 <xref:System.Windows.Forms.TextBoxBase.BorderStyle%2A> 其分配给控件。  
  
 [!code-cpp[Classic TextBoxBase.BorderStyle Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic TextBoxBase.BorderStyle Example/CPP/source.cpp#1)]
 [!code-csharp[Classic TextBoxBase.BorderStyle Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic TextBoxBase.BorderStyle Example/CS/source.cs#1)]
 [!code-vb[Classic TextBoxBase.BorderStyle Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic TextBoxBase.BorderStyle Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">分配给该属性的值不在该枚举的有效值范围内。</exception>
      </Docs>
    </Member>
    <Member MemberName="BorderStyleChanged">
      <MemberSignature Language="C#" Value="public event EventHandler BorderStyleChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler BorderStyleChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.TextBoxBase.BorderStyleChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event BorderStyleChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ BorderStyleChanged;" />
      <MemberSignature Language="F#" Value="member this.BorderStyleChanged : EventHandler " Usage="member this.BorderStyleChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在 <see cref="P:System.Windows.Forms.TextBoxBase.BorderStyle" /> 属性的值更改后发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 有关如何处理事件的详细信息，请参阅 [处理和引发事件](/dotnet/standard/events/)。  
  
   
  
## Examples  
 下面的代码示例演示如何使用此成员。 在此示例中，事件处理程序报告事件的发生 <xref:System.Windows.Forms.TextBoxBase.BorderStyleChanged> 。 此报表可帮助你了解何时发生事件，并可帮助你进行调试。 若要报告多个事件或频繁发生的事件，请考虑 <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> 将消息替换为多行或将其追加到多行 <xref:System.Windows.Forms.TextBox> 。  
  
 若要运行示例代码，请将其粘贴到一个项目中，该项目包含从继承的类型的实例 <xref:System.Windows.Forms.TextBoxBase> ，如 <xref:System.Windows.Forms.TextBox> 或 <xref:System.Windows.Forms.TextBoxBase> 。 然后命名该实例 `TextBoxBase1` ，并确保事件处理程序与事件相关联 <xref:System.Windows.Forms.TextBoxBase.BorderStyleChanged> 。  
  
 [!code-csharp[System.Windows.Forms.EventExamples#242](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#242)]
 [!code-vb[System.Windows.Forms.EventExamples#242](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#242)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.TextBoxBase.BorderStyle" />
      </Docs>
    </Member>
    <Member MemberName="CanEnableIme">
      <MemberSignature Language="C#" Value="protected override bool CanEnableIme { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanEnableIme" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.TextBoxBase.CanEnableIme" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides ReadOnly Property CanEnableIme As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property bool CanEnableIme { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanEnableIme : bool" Usage="System.Windows.Forms.TextBoxBase.CanEnableIme" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个用以指示是否可以将 <see cref="P:System.Windows.Forms.Control.ImeMode" /> 属性设置为活动值的值，以启用 IME 支持。</summary>
        <value>如果 <see cref="P:System.Windows.Forms.TextBoxBase.ReadOnly" /> 属性为 <see langword="false" /> 或将此 <see cref="T:System.Windows.Forms.TextBoxBase" /> 类设置为使用密码掩码字符，则为 <see langword="true" />；否则为 <see langword="true" />。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CanUndo">
      <MemberSignature Language="C#" Value="public bool CanUndo { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanUndo" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.TextBoxBase.CanUndo" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CanUndo As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanUndo { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanUndo : bool" Usage="System.Windows.Forms.TextBoxBase.CanUndo" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.Browsable(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.Browsable(false)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示用户在文本框控件中能否撤消前一操作。</summary>
        <value>如果用户可以撤消在文本框控件中执行的前一操作，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果此方法返回 `true` ，则可以调用 <xref:System.Windows.Forms.TextBoxBase.Undo%2A> 方法来撤消文本框中的上一个操作。 你可以在的事件中使用此方法 <xref:System.Windows.Forms.MenuItem.Popup> <xref:System.Windows.Forms.MenuItem> ，或在管理上的按钮状态的代码中使用， <xref:System.Windows.Forms.ToolBar> 以启用或禁用在文本框控件中撤消上一操作的功能。  
  
   
  
## Examples  
 下面的代码示例使用 <xref:System.Windows.Forms.TextBox> 派生类。 它 <xref:System.Windows.Forms.MenuItem.Click> 为 <xref:System.Windows.Forms.MenuItem> 执行剪切、复制、粘贴和撤消操作的对象提供事件处理程序。 此示例需要 <xref:System.Windows.Forms.TextBox> 创建名为的 `textBox1` 控件。  
  
 [!code-cpp[Classic TextBoxBase.CanUndo Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic TextBoxBase.CanUndo Example/CPP/source.cpp#1)]
 [!code-csharp[Classic TextBoxBase.CanUndo Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic TextBoxBase.CanUndo Example/CS/source.cs#1)]
 [!code-vb[Classic TextBoxBase.CanUndo Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic TextBoxBase.CanUndo Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.TextBoxBase.Cut" />
        <altmember cref="M:System.Windows.Forms.TextBoxBase.Copy" />
        <altmember cref="M:System.Windows.Forms.TextBoxBase.Paste" />
        <altmember cref="M:System.Windows.Forms.TextBoxBase.Undo" />
        <altmember cref="M:System.Windows.Forms.TextBoxBase.Clear" />
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.TextBoxBase.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Sub Clear ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Clear();" />
      <MemberSignature Language="F#" Value="member this.Clear : unit -&gt; unit" Usage="textBoxBase.Clear " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>从文本框控件中清除所有文本。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 您可以使用此方法清除控件的内容，而不是为属性分配 <xref:System.Windows.Forms.TextBoxBase.Text%2A> 一个空字符串。  
  
   
  
## Examples  
 下面的代码示例使用 <xref:System.Windows.Forms.TextBox> 派生类，为事件创建事件处理程序 <xref:System.Windows.Forms.Control.TextChanged> 。 事件处理程序中的代码将数据限制为数字。 在控件中输入文本后，代码会确定输入的文本是否为数字。 如果文本不是数字，则代码将清除控件中的文本，并 <xref:System.Windows.Forms.MessageBox> 显示以提醒用户仅接受数字。 该示例要求 `Boolean` 名为的变量 `flag` 和一个 <xref:System.Windows.Forms.TextBox> 名为的控件在 `textBox1` 此方法的外部定义。 此示例演示如何在事件中使用标志变量来避免级联事件 <xref:System.Windows.Forms.Control.TextChanged> 。  
  
 [!code-cpp[Classic TextBoxBase.Clear Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic TextBoxBase.Clear Example/CPP/source.cpp#1)]
 [!code-csharp[Classic TextBoxBase.Clear Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic TextBoxBase.Clear Example/CS/source.cs#1)]
 [!code-vb[Classic TextBoxBase.Clear Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic TextBoxBase.Clear Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.TextBoxBase.Cut" />
        <altmember cref="M:System.Windows.Forms.TextBoxBase.Copy" />
        <altmember cref="M:System.Windows.Forms.TextBoxBase.Paste" />
        <altmember cref="P:System.Windows.Forms.TextBoxBase.CanUndo" />
        <altmember cref="M:System.Windows.Forms.TextBoxBase.ClearUndo" />
      </Docs>
    </Member>
    <Member MemberName="ClearUndo">
      <MemberSignature Language="C#" Value="public void ClearUndo ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ClearUndo() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.TextBoxBase.ClearUndo" />
      <MemberSignature Language="VB.NET" Value="Public Sub ClearUndo ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ClearUndo();" />
      <MemberSignature Language="F#" Value="member this.ClearUndo : unit -&gt; unit" Usage="textBoxBase.ClearUndo " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>从该文本框的撤消缓冲区中清除关于最近操作的信息。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 基于应用程序的状态，您可以使用此方法阻止重复操作的撤消操作。  
  
   
  
## Examples  
 下面的代码示例使用 <xref:System.Windows.Forms.TextBox> 派生类。 它 <xref:System.Windows.Forms.MenuItem.Click> 为 <xref:System.Windows.Forms.MenuItem> 执行剪切、复制、粘贴和撤消操作的对象提供事件处理程序。 此示例需要 <xref:System.Windows.Forms.TextBox> 创建名为的 `textBox1` 控件。  
  
 [!code-cpp[Classic TextBoxBase.SelectionLength Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic TextBoxBase.SelectionLength Example/CPP/source.cpp#1)]
 [!code-csharp[Classic TextBoxBase.SelectionLength Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic TextBoxBase.SelectionLength Example/CS/source.cs#1)]
 [!code-vb[Classic TextBoxBase.SelectionLength Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic TextBoxBase.SelectionLength Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.TextBoxBase.Cut" />
        <altmember cref="M:System.Windows.Forms.TextBoxBase.Copy" />
        <altmember cref="M:System.Windows.Forms.TextBoxBase.Paste" />
        <altmember cref="P:System.Windows.Forms.TextBoxBase.CanUndo" />
        <altmember cref="M:System.Windows.Forms.TextBoxBase.Clear" />
      </Docs>
    </Member>
    <Member MemberName="Click">
      <MemberSignature Language="C#" Value="public event EventHandler Click;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Click" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.TextBoxBase.Click" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Click As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Click;" />
      <MemberSignature Language="F#" Value="member this.Click : EventHandler " Usage="member this.Click : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.ComponentModel.Browsable(true)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.Browsable(true)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Always)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Always)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName Language="C#">[System.ComponentModel.Browsable(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.Browsable(false)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName Language="C#">[System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在单击文本框时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 有关如何处理事件的详细信息，请参阅 [处理和引发事件](/dotnet/standard/events/)。  
  
   
  
## Examples  
 下面的代码示例演示如何处理 <xref:System.Windows.Forms.TextBoxBase.Click> 事件。 若要运行该示例，请将以下代码粘贴到包含名为 TextBox1 的控件的窗体中 <xref:System.Windows.Forms.TextBox> 。 此示例要求事件处理方法已与 <xref:System.Windows.Forms.TextBoxBase.Click> 事件关联。  
  
 [!code-cpp[System.Windows.Forms.TextBoxBaseScrolling#2](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.TextBoxBaseScrolling/CPP/form1.cpp#2)]
 [!code-csharp[System.Windows.Forms.TextBoxBaseScrolling#2](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.TextBoxBaseScrolling/CS/form1.cs#2)]
 [!code-vb[System.Windows.Forms.TextBoxBaseScrolling#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.TextBoxBaseScrolling/VB/form1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public void Copy ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Copy() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.TextBoxBase.Copy" />
      <MemberSignature Language="VB.NET" Value="Public Sub Copy ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Copy();" />
      <MemberSignature Language="F#" Value="member this.Copy : unit -&gt; unit" Usage="textBoxBase.Copy " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>将文本框中的当前选定内容复制到“剪贴板”****。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 您可以使用此方法，而不是使用 <xref:System.Windows.Forms.Clipboard> 类在文本框中复制文本，并将文本放入 **剪贴板**。  
  
   
  
## Examples  
 下面的代码示例使用 <xref:System.Windows.Forms.TextBox> 派生类。 它 <xref:System.Windows.Forms.MenuItem.Click> 为 <xref:System.Windows.Forms.MenuItem> 执行剪切、复制、粘贴和撤消操作的对象提供事件处理程序。 此示例需要 <xref:System.Windows.Forms.TextBox> 创建名为的 `textBox1` 控件。  
  
 [!code-cpp[Classic TextBoxBase.SelectionLength Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic TextBoxBase.SelectionLength Example/CPP/source.cpp#1)]
 [!code-csharp[Classic TextBoxBase.SelectionLength Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic TextBoxBase.SelectionLength Example/CS/source.cs#1)]
 [!code-vb[Classic TextBoxBase.SelectionLength Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic TextBoxBase.SelectionLength Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.TextBoxBase.Cut" />
        <altmember cref="M:System.Windows.Forms.TextBoxBase.Undo" />
        <altmember cref="M:System.Windows.Forms.TextBoxBase.Paste" />
        <altmember cref="P:System.Windows.Forms.TextBoxBase.CanUndo" />
        <altmember cref="M:System.Windows.Forms.TextBoxBase.Clear" />
      </Docs>
    </Member>
    <Member MemberName="CreateHandle">
      <MemberSignature Language="C#" Value="protected override void CreateHandle ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void CreateHandle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.TextBoxBase.CreateHandle" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub CreateHandle ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void CreateHandle();" />
      <MemberSignature Language="F#" Value="override this.CreateHandle : unit -&gt; unit" Usage="textBoxBase.CreateHandle " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>为该控件创建句柄。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateParams">
      <MemberSignature Language="C#" Value="protected override System.Windows.Forms.CreateParams CreateParams { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.CreateParams CreateParams" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.TextBoxBase.CreateParams" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides ReadOnly Property CreateParams As CreateParams" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property System::Windows::Forms::CreateParams ^ CreateParams { System::Windows::Forms::CreateParams ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CreateParams : System.Windows.Forms.CreateParams" Usage="System.Windows.Forms.TextBoxBase.CreateParams" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.CreateParams</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取创建控件句柄时所需要的创建参数。</summary>
        <value><see cref="T:System.Windows.Forms.CreateParams" />，包含创建控件的句柄时所需的创建参数。</value>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.Windows.Forms.CreateParams" />
        <altmember cref="P:System.Windows.Forms.Control.CreateParams" />
      </Docs>
    </Member>
    <Member MemberName="Cut">
      <MemberSignature Language="C#" Value="public void Cut ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Cut() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.TextBoxBase.Cut" />
      <MemberSignature Language="VB.NET" Value="Public Sub Cut ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Cut();" />
      <MemberSignature Language="F#" Value="member this.Cut : unit -&gt; unit" Usage="textBoxBase.Cut " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>将文本框中的当前选定内容移动到“剪贴板”中****。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果在控件中选择文本，则此方法将仅从文本框中剪切文本。 您可以使用此方法，而不是使用 <xref:System.Windows.Forms.Clipboard> 类在文本框中复制文本，并将文本移动到 **剪贴板**。  
  
   
  
## Examples  
 下面的代码示例使用 <xref:System.Windows.Forms.TextBox> 派生类。 它 <xref:System.Windows.Forms.MenuItem.Click> 为 <xref:System.Windows.Forms.MenuItem> 执行剪切、复制、粘贴和撤消操作的对象提供事件处理程序。 此示例需要 <xref:System.Windows.Forms.TextBox> 创建名为的 `textBox1` 控件。  
  
 [!code-cpp[Classic TextBoxBase.SelectionLength Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic TextBoxBase.SelectionLength Example/CPP/source.cpp#1)]
 [!code-csharp[Classic TextBoxBase.SelectionLength Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic TextBoxBase.SelectionLength Example/CS/source.cs#1)]
 [!code-vb[Classic TextBoxBase.SelectionLength Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic TextBoxBase.SelectionLength Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.TextBoxBase.Undo" />
        <altmember cref="M:System.Windows.Forms.TextBoxBase.Copy" />
        <altmember cref="M:System.Windows.Forms.TextBoxBase.Paste" />
        <altmember cref="P:System.Windows.Forms.TextBoxBase.CanUndo" />
        <altmember cref="M:System.Windows.Forms.TextBoxBase.Clear" />
      </Docs>
    </Member>
    <Member MemberName="DefaultCursor">
      <MemberSignature Language="C#" Value="protected override System.Windows.Forms.Cursor DefaultCursor { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.Cursor DefaultCursor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.TextBoxBase.DefaultCursor" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides ReadOnly Property DefaultCursor As Cursor" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property System::Windows::Forms::Cursor ^ DefaultCursor { System::Windows::Forms::Cursor ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DefaultCursor : System.Windows.Forms.Cursor" Usage="System.Windows.Forms.TextBoxBase.DefaultCursor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Cursor</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置控件的默认光标。</summary>
        <value>一个 <see cref="T:System.Windows.Forms.Cursor" /> 类型的对象，表示当前默认光标。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 重写 <xref:System.Windows.Forms.TextBoxBase.DefaultCursor%2A> 以配置控件的默认光标。 这比在控件的构造函数中设置光标更高效，并为某些与游标相关的设计器函数提供自动支持。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultSize">
      <MemberSignature Language="C#" Value="protected override System.Drawing.Size DefaultSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Size DefaultSize" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.TextBoxBase.DefaultSize" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides ReadOnly Property DefaultSize As Size" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property System::Drawing::Size DefaultSize { System::Drawing::Size get(); };" />
      <MemberSignature Language="F#" Value="member this.DefaultSize : System.Drawing.Size" Usage="System.Windows.Forms.TextBoxBase.DefaultSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Size</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取控件的默认大小。</summary>
        <value>控件的默认 <see cref="T:System.Drawing.Size" />。</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.Forms.Control.DefaultSize" />
      </Docs>
    </Member>
    <Member MemberName="DeselectAll">
      <MemberSignature Language="C#" Value="public void DeselectAll ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DeselectAll() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.TextBoxBase.DeselectAll" />
      <MemberSignature Language="VB.NET" Value="Public Sub DeselectAll ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DeselectAll();" />
      <MemberSignature Language="F#" Value="member this.DeselectAll : unit -&gt; unit" Usage="textBoxBase.DeselectAll " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>将 <see cref="P:System.Windows.Forms.TextBoxBase.SelectionLength" /> 属性的值指定为零，从而不会在控件中选择字符。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DoubleBuffered">
      <MemberSignature Language="C#" Value="protected override bool DoubleBuffered { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DoubleBuffered" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.TextBoxBase.DoubleBuffered" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Property DoubleBuffered As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property bool DoubleBuffered { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.DoubleBuffered : bool with get, set" Usage="System.Windows.Forms.TextBoxBase.DoubleBuffered" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指示是否在显示控件前在缓冲区中完成控件绘制。 此属性与此类无关。</summary>
        <value>若要在控件上实现双缓冲，则为 <see langword="true" />；否则，为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此属性与此类无关。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ForeColor">
      <MemberSignature Language="C#" Value="public override System.Drawing.Color ForeColor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Color ForeColor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.TextBoxBase.ForeColor" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property ForeColor As Color" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Drawing::Color ForeColor { System::Drawing::Color get(); void set(System::Drawing::Color value); };" />
      <MemberSignature Language="F#" Value="member this.ForeColor : System.Drawing.Color with get, set" Usage="System.Windows.Forms.TextBoxBase.ForeColor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.InteropServices.DispId(-513)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.InteropServices.DispId(-513)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Color</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置控件的前景色。</summary>
        <value>一个 <see cref="T:System.Drawing.Color" />，表示控件的前景色。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 您可以使用 <xref:System.Windows.Forms.TextBoxBase.ForeColor%2A> 属性更改控件中的文本颜色，以匹配窗体上其他控件的文本。 您还可以使用此属性突出显示包含无效值的特定文本框。  
  
 若要更改控件的背景色，请使用 <xref:System.Windows.Forms.TextBoxBase.BackColor%2A> 属性。 设置 <xref:System.Windows.Forms.TextBoxBase.ForeColor%2A> 文本控件的属性时，请确保所选颜色不会导致控件文本消失。 例如，如果 <xref:System.Windows.Forms.TextBoxBase.ForeColor%2A> 和属性都 <xref:System.Windows.Forms.TextBoxBase.BackColor%2A> 设置为 `Color.Black` ，则 textbox 控件中的文本将不可见。  
  
 如果将 <xref:System.Windows.Forms.TextBoxBase.ReadOnly%2A> 的属性设置为，则此属性可能会超过替代 <xref:System.Windows.Forms.TextBoxBase> `true` 。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.TextBoxBase.BackColor" />
      </Docs>
    </Member>
    <Member MemberName="GetCharFromPosition">
      <MemberSignature Language="C#" Value="public virtual char GetCharFromPosition (System.Drawing.Point pt);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance char GetCharFromPosition(valuetype System.Drawing.Point pt) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.TextBoxBase.GetCharFromPosition(System.Drawing.Point)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetCharFromPosition (pt As Point) As Char" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual char GetCharFromPosition(System::Drawing::Point pt);" />
      <MemberSignature Language="F#" Value="abstract member GetCharFromPosition : System.Drawing.Point -&gt; char&#xA;override this.GetCharFromPosition : System.Drawing.Point -&gt; char" Usage="textBoxBase.GetCharFromPosition pt" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pt" Type="System.Drawing.Point" Index="0" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="pt">查找距离最近的字符的位置。</param>
        <summary>检索控件内距离指定位置最近的字符。</summary>
        <returns>位于指定位置的字符。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果参数中指定的位置在 `pt` 控件的工作区之外，则返回最接近中指定的点的字符串的第一个字符 `pt` 。 您可以使用此方法来确定哪些字符位于控件中的特定点附近。 然后，可以使用此值对该位置的文本执行操作。  
  
> [!NOTE]
>  如果参数中的指定位置 `pt` 位于控件的工作区右侧，则返回最靠近中指定的点的字符串的最后一个字符 `pt` 。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.TextBoxBase.GetCharIndexFromPosition(System.Drawing.Point)" />
        <altmember cref="M:System.Windows.Forms.TextBoxBase.GetLineFromCharIndex(System.Int32)" />
        <altmember cref="M:System.Windows.Forms.TextBoxBase.GetPositionFromCharIndex(System.Int32)" />
        <altmember cref="M:System.Windows.Forms.TextBoxBase.GetFirstCharIndexFromLine(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetCharIndexFromPosition">
      <MemberSignature Language="C#" Value="public virtual int GetCharIndexFromPosition (System.Drawing.Point pt);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetCharIndexFromPosition(valuetype System.Drawing.Point pt) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.TextBoxBase.GetCharIndexFromPosition(System.Drawing.Point)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetCharIndexFromPosition (pt As Point) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetCharIndexFromPosition(System::Drawing::Point pt);" />
      <MemberSignature Language="F#" Value="abstract member GetCharIndexFromPosition : System.Drawing.Point -&gt; int&#xA;override this.GetCharIndexFromPosition : System.Drawing.Point -&gt; int" Usage="textBoxBase.GetCharIndexFromPosition pt" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pt" Type="System.Drawing.Point" Index="0" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="pt">要搜索的位置。</param>
        <summary>检索距离指定位置最近的字符索引。</summary>
        <returns>位于指定位置的从零开始的字符索引。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法返回与参数中指定的位置最接近的字符索引 `pt` 。 字符索引是控件中的文本的从零开始的索引，其中包括空格。 您可以使用此方法，通过将鼠标坐标传递到此方法来确定用户在文本中的位置。 如果要在用户将鼠标指针悬停在控件文本中的单词上时执行任务，这会很有用。  
  
> [!IMPORTANT]
>  如果指定的位置不在控件的客户端矩形内，或超出了控件中的最后一个字符，则返回值为最后一个字符的索引。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.TextBoxBase.GetCharFromPosition(System.Drawing.Point)" />
        <altmember cref="M:System.Windows.Forms.TextBoxBase.GetLineFromCharIndex(System.Int32)" />
        <altmember cref="M:System.Windows.Forms.TextBoxBase.GetPositionFromCharIndex(System.Int32)" />
        <altmember cref="M:System.Windows.Forms.TextBoxBase.GetFirstCharIndexFromLine(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetFirstCharIndexFromLine">
      <MemberSignature Language="C#" Value="public int GetFirstCharIndexFromLine (int lineNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetFirstCharIndexFromLine(int32 lineNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.TextBoxBase.GetFirstCharIndexFromLine(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetFirstCharIndexFromLine (lineNumber As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetFirstCharIndexFromLine(int lineNumber);" />
      <MemberSignature Language="F#" Value="member this.GetFirstCharIndexFromLine : int -&gt; int" Usage="textBoxBase.GetFirstCharIndexFromLine lineNumber" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="lineNumber" Type="System.Int32" Index="0" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="lineNumber">要获取其第一个字符的索引的行。</param>
        <summary>检索给定行第一个字符的索引。</summary>
        <returns>指定行中第一个字符的从零开始的索引。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 文本框中的行号从零开始。 如果 `lineNumber` 参数大于文本框中的最后一行，则 <xref:System.Windows.Forms.TextBoxBase.GetFirstCharIndexFromLine%2A> 返回-1。  
  
 <xref:System.Windows.Forms.TextBoxBase.GetFirstCharIndexFromLine%2A> 返回物理行的第一个字符索引。 物理行是显示的行，而不是所分配的行。 由于换行，显示的行数可以大于分配的行数。 例如，如果将两个长行分配给一个 <xref:System.Windows.Forms.RichTextBox> 控件并将 <xref:System.Windows.Forms.TextBoxBase.Multiline%2A> 和设置 <xref:System.Windows.Forms.TextBoxBase.WordWrap%2A> 为 `true` ，则两个长时间分配的行将导致四个物理 (或) 显示的行。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="lineNumber" /> 参数的值小于零。</exception>
        <altmember cref="M:System.Windows.Forms.TextBoxBase.GetCharIndexFromPosition(System.Drawing.Point)" />
        <altmember cref="M:System.Windows.Forms.TextBoxBase.GetLineFromCharIndex(System.Int32)" />
        <altmember cref="M:System.Windows.Forms.TextBoxBase.GetPositionFromCharIndex(System.Int32)" />
        <altmember cref="M:System.Windows.Forms.TextBoxBase.GetCharFromPosition(System.Drawing.Point)" />
      </Docs>
    </Member>
    <Member MemberName="GetFirstCharIndexOfCurrentLine">
      <MemberSignature Language="C#" Value="public int GetFirstCharIndexOfCurrentLine ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetFirstCharIndexOfCurrentLine() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.TextBoxBase.GetFirstCharIndexOfCurrentLine" />
      <MemberSignature Language="VB.NET" Value="Public Function GetFirstCharIndexOfCurrentLine () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetFirstCharIndexOfCurrentLine();" />
      <MemberSignature Language="F#" Value="member this.GetFirstCharIndexOfCurrentLine : unit -&gt; int" Usage="textBoxBase.GetFirstCharIndexOfCurrentLine " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>检索当前行的第一个字符的索引。</summary>
        <returns>当前行中从零开始的字符索引。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetLineFromCharIndex">
      <MemberSignature Language="C#" Value="public virtual int GetLineFromCharIndex (int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetLineFromCharIndex(int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.TextBoxBase.GetLineFromCharIndex(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetLineFromCharIndex (index As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetLineFromCharIndex(int index);" />
      <MemberSignature Language="F#" Value="abstract member GetLineFromCharIndex : int -&gt; int&#xA;override this.GetLineFromCharIndex : int -&gt; int" Usage="textBoxBase.GetLineFromCharIndex index" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" Index="0" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="index">要搜索的字符索引位置。</param>
        <summary>从控件文本内的指定字符位置检索行号。</summary>
        <returns>字符索引所在的从零开始的行号。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法使您能够根据在方法的参数中指定的字符索引来确定行号 `index` 。 控件中的第一行文本返回值零。 <xref:System.Windows.Forms.TextBoxBase.GetLineFromCharIndex%2A>方法返回索引字符位于控件内的物理行号。 例如，如果控件中第一个逻辑文本行的一部分被换到下一行，则 <xref:System.Windows.Forms.TextBoxBase.GetLineFromCharIndex%2A> 当指定字符索引处的字符已包装到第二个物理行时，该方法返回1。 如果 <xref:System.Windows.Forms.TextBoxBase.WordWrap%2A> 将设置为 `false` ，则行的任何部分都不会换到下一步，并且方法将为指定的字符索引返回0。 您可以使用此方法来确定特定字符索引所在的行。 例如，在调用 <xref:System.Windows.Forms.RichTextBox.Find%2A> 方法搜索文本后，您可以获取搜索结果所在位置的字符索引。 您可以使用该方法返回的字符索引来调用此方法 <xref:System.Windows.Forms.RichTextBox.Find%2A> ，以确定找到该单词的行。  
  
> [!NOTE]
>  如果参数中指定的字符索引 `index` 超出了控件内包含的可用行数，则返回最后一个行号。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.TextBoxBase.GetCharIndexFromPosition(System.Drawing.Point)" />
        <altmember cref="M:System.Windows.Forms.TextBoxBase.GetCharFromPosition(System.Drawing.Point)" />
        <altmember cref="M:System.Windows.Forms.TextBoxBase.GetPositionFromCharIndex(System.Int32)" />
        <altmember cref="M:System.Windows.Forms.TextBoxBase.GetFirstCharIndexFromLine(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetPositionFromCharIndex">
      <MemberSignature Language="C#" Value="public virtual System.Drawing.Point GetPositionFromCharIndex (int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Drawing.Point GetPositionFromCharIndex(int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.TextBoxBase.GetPositionFromCharIndex(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetPositionFromCharIndex (index As Integer) As Point" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Drawing::Point GetPositionFromCharIndex(int index);" />
      <MemberSignature Language="F#" Value="abstract member GetPositionFromCharIndex : int -&gt; System.Drawing.Point&#xA;override this.GetPositionFromCharIndex : int -&gt; System.Drawing.Point" Usage="textBoxBase.GetPositionFromCharIndex index" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Point</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" Index="0" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="index">要检索其位置的字符索引。</param>
        <summary>检索控件内指定字符索引处的位置。</summary>
        <returns>控件的矩形工作区内指定字符的位置。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法使您能够确定特定字符索引所在的控件中的位置。 对于此类任务，您可以使用此方法来显示快捷菜单项或控件中某个词的帮助信息。 例如，如果想要在用户右键单击控件中的某个单词时向用户显示选项菜单，则可以使用此方法来确定 word 正确显示控件的位置 <xref:System.Windows.Forms.ContextMenu> 。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.TextBoxBase.GetCharIndexFromPosition(System.Drawing.Point)" />
        <altmember cref="M:System.Windows.Forms.TextBoxBase.GetLineFromCharIndex(System.Int32)" />
        <altmember cref="M:System.Windows.Forms.TextBoxBase.GetCharFromPosition(System.Drawing.Point)" />
        <altmember cref="M:System.Windows.Forms.TextBoxBase.GetFirstCharIndexFromLine(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="HideSelection">
      <MemberSignature Language="C#" Value="public bool HideSelection { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HideSelection" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.TextBoxBase.HideSelection" />
      <MemberSignature Language="VB.NET" Value="Public Property HideSelection As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HideSelection { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.HideSelection : bool with get, set" Usage="System.Windows.Forms.TextBoxBase.HideSelection" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.DefaultValue(true)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.DefaultValue(true)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指示当文本框控件没有焦点时，该控件中选定的文本是否保持突出显示。</summary>
        <value>如果当文本框控件没有焦点时，选定文本不突出显示，则为 <see langword="true" />；如果当文本框控件没有焦点时，选定文本保持突出显示，则为 <see langword="false" />。 默认值为 <see langword="true" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 您可以使用此属性使文本在文本框控件中突出显示，同时另一个窗体或对话框具有焦点，如拼写检查器对话框。  
  
   
  
## Examples  
 下面的代码示例演示如何使用 <xref:System.Windows.Forms.TextBoxBase.HideSelection%2A> 属性。 若要运行该示例，请将以下代码粘贴到窗体中。 `InitializeTextBox`在窗体的构造函数或方法中调用方法 `Load` 。  
  
 [!code-cpp[System.Windows.Forms.TextBoxBaseScrolling#3](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.TextBoxBaseScrolling/CPP/form1.cpp#3)]
 [!code-csharp[System.Windows.Forms.TextBoxBaseScrolling#3](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.TextBoxBaseScrolling/CS/form1.cs#3)]
 [!code-vb[System.Windows.Forms.TextBoxBaseScrolling#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.TextBoxBaseScrolling/VB/form1.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HideSelectionChanged">
      <MemberSignature Language="C#" Value="public event EventHandler HideSelectionChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler HideSelectionChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.TextBoxBase.HideSelectionChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event HideSelectionChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ HideSelectionChanged;" />
      <MemberSignature Language="F#" Value="member this.HideSelectionChanged : EventHandler " Usage="member this.HideSelectionChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在 <see cref="P:System.Windows.Forms.TextBoxBase.HideSelection" /> 属性的值更改后发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 有关如何处理事件的详细信息，请参阅 [处理和引发事件](/dotnet/standard/events/)。  
  
   
  
## Examples  
 下面的代码示例演示如何使用此成员。 在此示例中，事件处理程序报告事件的发生 <xref:System.Windows.Forms.TextBoxBase.HideSelectionChanged> 。 此报表可帮助你了解何时发生事件，并可帮助你进行调试。 若要报告多个事件或频繁发生的事件，请考虑 <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> 将消息替换为多行或将其追加到多行 <xref:System.Windows.Forms.TextBox> 。  
  
 若要运行示例代码，请将其粘贴到一个项目中，该项目包含从继承的类型的实例 <xref:System.Windows.Forms.TextBoxBase> ，如 <xref:System.Windows.Forms.TextBox> 或 <xref:System.Windows.Forms.TextBoxBase> 。 然后命名该实例 `TextBoxBase1` ，并确保事件处理程序与事件相关联 <xref:System.Windows.Forms.TextBoxBase.HideSelectionChanged> 。  
  
 [!code-csharp[System.Windows.Forms.EventExamples#245](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#245)]
 [!code-vb[System.Windows.Forms.EventExamples#245](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#245)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.TextBoxBase.HideSelection" />
      </Docs>
    </Member>
    <Member MemberName="ImeModeBase">
      <MemberSignature Language="C#" Value="protected override System.Windows.Forms.ImeMode ImeModeBase { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.ImeMode ImeModeBase" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.TextBoxBase.ImeModeBase" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Property ImeModeBase As ImeMode" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property System::Windows::Forms::ImeMode ImeModeBase { System::Windows::Forms::ImeMode get(); void set(System::Windows::Forms::ImeMode value); };" />
      <MemberSignature Language="F#" Value="member this.ImeModeBase : System.Windows.Forms.ImeMode with get, set" Usage="System.Windows.Forms.TextBoxBase.ImeModeBase" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.ImeMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置控件的输入法编辑器 (IME) 模式。</summary>
        <value>控件的 IME 模式。</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.Forms.Control.ImeMode" />
      </Docs>
    </Member>
    <Member MemberName="IsInputKey">
      <MemberSignature Language="C#" Value="protected override bool IsInputKey (System.Windows.Forms.Keys keyData);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance bool IsInputKey(valuetype System.Windows.Forms.Keys keyData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.TextBoxBase.IsInputKey(System.Windows.Forms.Keys)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function IsInputKey (keyData As Keys) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override bool IsInputKey(System::Windows::Forms::Keys keyData);" />
      <MemberSignature Language="F#" Value="override this.IsInputKey : System.Windows.Forms.Keys -&gt; bool" Usage="textBoxBase.IsInputKey keyData" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keyData" Type="System.Windows.Forms.Keys" />
      </Parameters>
      <Docs>
        <param name="keyData">键值之一。</param>
        <summary>确定指定的键是输入键还是需要预处理的特殊键。</summary>
        <returns>如果指定的键是输入键，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.TextBoxBase.IsInputKey%2A> `true` 当 `keyData` 参数包括 <xref:System.Windows.Forms.Keys.Tab> 值并且 <xref:System.Windows.Forms.TextBoxBase.AcceptsTab%2A> 属性为时，该方法返回 `true` 。 <xref:System.Windows.Forms.TextBoxBase.IsInputKey%2A>`false`如果 `keyData` 包含 <xref:System.Windows.Forms.Keys.Tab> 和，则返回 <xref:System.Windows.Forms.Keys.Control> 。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Lines">
      <MemberSignature Language="C#" Value="public string[] Lines { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string[] Lines" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.TextBoxBase.Lines" />
      <MemberSignature Language="VB.NET" Value="Public Property Lines As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::String ^&gt; ^ Lines { cli::array &lt;System::String ^&gt; ^ get(); void set(cli::array &lt;System::String ^&gt; ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Lines : string[] with get, set" Usage="System.Windows.Forms.TextBoxBase.Lines" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.ComponentModel.Editor("System.Windows.Forms.Design.StringArrayEditor, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", typeof(System.Drawing.Design.UITypeEditor))]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.Editor("System.Windows.Forms.Design.StringArrayEditor, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", typeof(System.Drawing.Design.UITypeEditor))&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.Localizable(true)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.Localizable(true)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.ComponentModel.MergableProperty(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.MergableProperty(false)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName Language="C#">[System.ComponentModel.Editor("System.Windows.Forms.Design.StringArrayEditor, System.Design, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", typeof(System.Drawing.Design.UITypeEditor))]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.Editor("System.Windows.Forms.Design.StringArrayEditor, System.Design, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", typeof(System.Drawing.Design.UITypeEditor))&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName Language="C#">[System.ComponentModel.Editor("System.Windows.Forms.Design.StringArrayEditor, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", typeof(System.Drawing.Design.UITypeEditor))]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.Editor("System.Windows.Forms.Design.StringArrayEditor, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", typeof(System.Drawing.Design.UITypeEditor))&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置文本框控件中的文本行。</summary>
        <value>包含文本框控件中的文本的字符串数组。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 数组中的每个元素都将成为文本框控件中的一行文本。 如果 <xref:System.Windows.Forms.TextBoxBase.Multiline%2A> 文本框控件的属性设置为 `true` ，并且文本中出现换行符，则换行符后面的文本将添加到数组中的新元素并显示在单独的行上。  
  
> [!NOTE]
>  默认情况下，行集合是中的行的只读副本 <xref:System.Windows.Forms.TextBox> 。 若要获取可写行集合，请使用类似于下面的代码： `textBox1.Lines = new string[] { "abcd" };`  
  
   
  
## Examples  
 下面的代码示例使用 <xref:System.Windows.Forms.TextBox> 派生类从多行文本框控件中提取所有文本字符串，并使用方法显示它们 <xref:System.Diagnostics.Debug.WriteLine%2A?displayProperty=nameWithType> 。 此示例要求已创建了一个 <xref:System.Windows.Forms.TextBox> 名为的控件，并且该控件已 `textBox1` 用文本行填充。  
  
 [!code-cpp[Classic TextBoxBase.Lines Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic TextBoxBase.Lines Example/CPP/source.cpp#1)]
 [!code-csharp[Classic TextBoxBase.Lines Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic TextBoxBase.Lines Example/CS/source.cs#1)]
 [!code-vb[Classic TextBoxBase.Lines Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic TextBoxBase.Lines Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.TextBoxBase.Text" />
      </Docs>
    </Member>
    <Member MemberName="MaxLength">
      <MemberSignature Language="C#" Value="public virtual int MaxLength { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MaxLength" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.TextBoxBase.MaxLength" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property MaxLength As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int MaxLength { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.MaxLength : int with get, set" Usage="System.Windows.Forms.TextBoxBase.MaxLength" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.DefaultValue(32767)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.DefaultValue(32767)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.Localizable(true)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.Localizable(true)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置用户可在文本框控件中键入或粘贴的最大字符数。</summary>
        <value>可以在文本框控件中输入的字符数。 默认值为32767。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 您可以使用此属性来限制控件中为邮政编码和电话号码等值输入的文本长度，或限制在数据库中输入数据时输入的文本长度。 您可以将在控件中输入的文本限制为数据库中对应字段的最大长度。  
  
> [!NOTE]
>  在代码中，可以将属性的值设置 <xref:System.Windows.Forms.TextBoxBase.Text%2A> 为长度大于属性指定的值的值 <xref:System.Windows.Forms.TextBoxBase.MaxLength%2A> 。 此属性仅影响运行时输入到控件中的文本。  
  
   
  
## Examples  
 下面的代码示例使用派生类 <xref:System.Windows.Forms.TextBox> 来创建用于接受密码的文本框。 此示例使用 <xref:System.Windows.Forms.TextBox.CharacterCasing%2A> 属性将键入的所有字符更改为大写，并使用 <xref:System.Windows.Forms.TextBoxBase.MaxLength%2A> 属性将密码长度限制为8个字符。 此示例还使用 <xref:System.Windows.Forms.TextBox.TextAlign%2A> 属性使密码在控件中居中 <xref:System.Windows.Forms.TextBox> 。  
  
 [!code-cpp[Classic TextBoxBase.MaxLength Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic TextBoxBase.MaxLength Example/CPP/source.cpp#1)]
 [!code-csharp[Classic TextBoxBase.MaxLength Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic TextBoxBase.MaxLength Example/CS/source.cs#1)]
 [!code-vb[Classic TextBoxBase.MaxLength Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic TextBoxBase.MaxLength Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">分配给属性的值小于零。</exception>
      </Docs>
    </Member>
    <Member MemberName="Modified">
      <MemberSignature Language="C#" Value="public bool Modified { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Modified" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.TextBoxBase.Modified" />
      <MemberSignature Language="VB.NET" Value="Public Property Modified As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Modified { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Modified : bool with get, set" Usage="System.Windows.Forms.TextBoxBase.Modified" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.Browsable(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.Browsable(false)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指示自创建文本框控件或上次设置该控件的内容后，用户修改了该控件。</summary>
        <value>如果控件的内容被修改了，则为 <see langword="true" />，否则为 <see langword="false" />。 默认值为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 您可以使用此属性来确定用户是否修改了文本框控件的内容。 你还可以在代码中设置此属性，以指示应用程序对文本框控件进行了更改。 此属性可由验证和数据保存方法用来确定是否已在文本框控件中进行了更改，以便可以验证或保存更改的内容。  
  
 如果 <xref:System.Windows.Forms.TextBoxBase.Text%2A> 以编程方式更改属性，该 <xref:System.Windows.Forms.TextBoxBase.Modified%2A> 属性将还原为 `false` 。 这不会引发 <xref:System.Windows.Forms.TextBoxBase.ModifiedChanged> 事件。  
  
   
  
## Examples  
 下面的代码示例使用 <xref:System.Windows.Forms.Control.TextChanged> 派生类的事件 <xref:System.Windows.Forms.TextBox> ，以确定控件的内容在 <xref:System.Windows.Forms.TextBox> 使用数据填充后是否发生了更改。 该示例使用字符串来存储控件的原始内容，并将其与的内容进行比较， <xref:System.Windows.Forms.TextBox> 以确定内容是否已更改。 如果内容已更改，则将 <xref:System.Windows.Forms.TextBoxBase.Modified%2A> 属性设置为 `true` 。 否则，它将重置为 `false` 。 此示例需要创建一个 <xref:System.Windows.Forms.TextBox> 名为的控件 `textBox1` ，并且已创建一个名为的 `String` 变量 `originalText` 来存储控件的原始文本 <xref:System.Windows.Forms.TextBox> 。  
  
 [!code-cpp[Classic TextBoxBase.Modified Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic TextBoxBase.Modified Example/CPP/source.cpp#1)]
 [!code-csharp[Classic TextBoxBase.Modified Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic TextBoxBase.Modified Example/CS/source.cs#1)]
 [!code-vb[Classic TextBoxBase.Modified Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic TextBoxBase.Modified Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ModifiedChanged">
      <MemberSignature Language="C#" Value="public event EventHandler ModifiedChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler ModifiedChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.TextBoxBase.ModifiedChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ModifiedChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ ModifiedChanged;" />
      <MemberSignature Language="F#" Value="member this.ModifiedChanged : EventHandler " Usage="member this.ModifiedChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在 <see cref="P:System.Windows.Forms.TextBoxBase.Modified" /> 属性的值更改后发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果 <xref:System.Windows.Forms.TextBoxBase.Text%2A> 以编程方式更改属性，该 <xref:System.Windows.Forms.TextBoxBase.Modified%2A> 属性将还原为 `false` 。 这不会引发 <xref:System.Windows.Forms.TextBoxBase.ModifiedChanged> 事件。  
  
 有关如何处理事件的详细信息，请参阅 [处理和引发事件](/dotnet/standard/events/)。  
  
   
  
## Examples  
 下面的代码示例演示如何使用此成员。 在此示例中，事件处理程序报告事件的发生 <xref:System.Windows.Forms.TextBoxBase.ModifiedChanged> 。 此报表可帮助你了解何时发生事件，并可帮助你进行调试。 若要报告多个事件或频繁发生的事件，请考虑 <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> 将消息替换为多行或将其追加到多行 <xref:System.Windows.Forms.TextBox> 。  
  
 若要运行示例代码，请将其粘贴到一个项目中，该项目包含从继承的类型的实例 <xref:System.Windows.Forms.TextBoxBase> ，如 <xref:System.Windows.Forms.TextBox> 或 <xref:System.Windows.Forms.TextBoxBase> 。 然后命名该实例 `TextBoxBase1` ，并确保事件处理程序与事件相关联 <xref:System.Windows.Forms.TextBoxBase.ModifiedChanged> 。  
  
 [!code-csharp[System.Windows.Forms.EventExamples#246](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#246)]
 [!code-vb[System.Windows.Forms.EventExamples#246](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#246)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.TextBoxBase.Modified" />
      </Docs>
    </Member>
    <Member MemberName="MouseClick">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.MouseEventHandler MouseClick;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.MouseEventHandler MouseClick" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.TextBoxBase.MouseClick" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseClick As MouseEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::MouseEventHandler ^ MouseClick;" />
      <MemberSignature Language="F#" Value="member this.MouseClick : System.Windows.Forms.MouseEventHandler " Usage="member this.MouseClick : System.Windows.Forms.MouseEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.ComponentModel.Browsable(true)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.Browsable(true)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Always)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Always)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.MouseEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>用鼠标单击控件时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.RichTextBox>控件不会引发 <xref:System.Windows.Forms.TextBoxBase.Click> 事件以供右键单击。 <xref:System.Windows.Forms.TextBoxBase.MouseClick>事件提供等效功能。  
  
 有关如何处理事件的详细信息，请参阅 [处理和引发事件](/dotnet/standard/events/)。  
  
   
  
## Examples  
 下面的代码示例演示如何使用此成员。 在此示例中，事件处理程序报告事件的发生 <xref:System.Windows.Forms.TextBoxBase.MouseClick> 。 此报表可帮助你了解何时发生事件，并可帮助你进行调试。 若要报告多个事件或频繁发生的事件，请考虑 <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> 将消息替换为多行或将其追加到多行 <xref:System.Windows.Forms.TextBox> 。  
  
 若要运行示例代码，请将其粘贴到一个项目中，该项目包含从继承的类型的实例 <xref:System.Windows.Forms.TextBoxBase> ，如 <xref:System.Windows.Forms.TextBox> 或 <xref:System.Windows.Forms.TextBoxBase> 。 然后命名该实例 `TextBoxBase1` ，并确保事件处理程序与事件相关联 <xref:System.Windows.Forms.TextBoxBase.MouseClick> 。  
  
 [!code-csharp[System.Windows.Forms.EventExamples#244](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#244)]
 [!code-vb[System.Windows.Forms.EventExamples#244](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#244)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Multiline">
      <MemberSignature Language="C#" Value="public virtual bool Multiline { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Multiline" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.TextBoxBase.Multiline" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property Multiline As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool Multiline { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Multiline : bool with get, set" Usage="System.Windows.Forms.TextBoxBase.Multiline" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.DefaultValue(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.DefaultValue(false)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.Localizable(true)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.Localizable(true)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.RefreshProperties(System.ComponentModel.RefreshProperties.All)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.RefreshProperties(System.ComponentModel.RefreshProperties.All)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指示它是否为多行文本框控件。</summary>
        <value>如果该控件是多行文本框控件，则为 <see langword="true" />；否则为 <see langword="false" />。 默认值为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用多行文本框可以在控件中显示多行文本。 如果将 <xref:System.Windows.Forms.TextBoxBase.WordWrap%2A> 属性设置为，则在 `true` 多行文本框中输入的文本将被包装到控件中的下一行。 如果将 <xref:System.Windows.Forms.TextBoxBase.WordWrap%2A> 属性设置为，则在 `false` 多行文本框控件中输入的文本将显示在同一行上，直到输入换行符。  
  
 可以将以下字符用作换行符：  
  
-   <xref:System.Environment.NewLine%2A?displayProperty=nameWithType>  
  
-   ControlChars  
  
-   仅限 vbCrLf (Visual Basic)   
  
 您可以使用属性向文本框添加滚动条， <xref:System.Windows.Forms.TextBox.ScrollBars%2A> 以显示水平和/或垂直滚动条。 这允许用户滚动浏览超出控件尺寸的文本。  
  
> [!NOTE]
>  由于属性的默认值 <xref:System.Windows.Forms.TextBoxBase.Multiline%2A> 为，因此的 `false` 默认大小 <xref:System.Windows.Forms.TextBox> 将与字体大小一致，即使调整大小 <xref:System.Windows.Forms.TextBox> 。 若要为获取一致的大小 <xref:System.Windows.Forms.TextBox> ，请将其 <xref:System.Windows.Forms.TextBox.Multiline%2A> 属性设置为 `true` 。  
  
> [!NOTE]
>  在日语操作系统上，如果 <xref:System.Windows.Forms.TextBoxBase.Multiline%2A> 属性设置为，则 `true` 设置 <xref:System.Windows.Forms.TextBox.PasswordChar%2A> 属性将显示密码文本，从而影响系统安全性。 因此，在日语操作系统上，如果设置属性，请将 <xref:System.Windows.Forms.TextBoxBase.Multiline%2A> 属性设置为 `false` <xref:System.Windows.Forms.TextBox.PasswordChar%2A> 。  
  
> [!NOTE]
>  `false`默认情况下，对于所有派生类（控件除外），此属性均设置为 <xref:System.Windows.Forms.RichTextBox> 。  
  
 对于 <xref:System.Windows.Forms.RichTextBox> 控件，该 <xref:System.Windows.Forms.RichTextBox.Multiline%2A?displayProperty=nameWithType> 属性会影响控件是否将自动调整大小，如下所示：  
  
-   如果 <xref:System.Windows.Forms.RichTextBox.AutoSize%2A?displayProperty=nameWithType> 设置为 `true` 且 <xref:System.Windows.Forms.RichTextBox.Multiline%2A?displayProperty=nameWithType> 设置为，则 `true` 不会 <xref:System.Windows.Forms.RichTextBox> 自动调整大小。  
  
-   如果 <xref:System.Windows.Forms.RichTextBox.AutoSize%2A?displayProperty=nameWithType> 设置为 `true` 且 <xref:System.Windows.Forms.RichTextBox.Multiline%2A?displayProperty=nameWithType> 设置为，则 `false` <xref:System.Windows.Forms.RichTextBox> 将自动调整大小。  
  
   
  
## Examples  
 下面的代码示例使用 <xref:System.Windows.Forms.TextBox> 派生类创建 <xref:System.Windows.Forms.TextBox> 具有垂直滚动条的多行控件。 此示例还使用 <xref:System.Windows.Forms.TextBoxBase.AcceptsTab%2A> 、 <xref:System.Windows.Forms.TextBox.AcceptsReturn%2A> 和 <xref:System.Windows.Forms.TextBoxBase.WordWrap%2A> 属性使 "多行文本框" 控件对创建文本文档有用。  
  
 [!code-cpp[Classic TextBoxBase.AcceptsTab Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic TextBoxBase.AcceptsTab Example/CPP/source.cpp#1)]
 [!code-csharp[Classic TextBoxBase.AcceptsTab Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic TextBoxBase.AcceptsTab Example/CS/source.cs#1)]
 [!code-vb[Classic TextBoxBase.AcceptsTab Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic TextBoxBase.AcceptsTab Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.TextBoxBase.Lines" />
        <altmember cref="P:System.Windows.Forms.TextBoxBase.WordWrap" />
        <altmember cref="P:System.Windows.Forms.TextBox.ScrollBars" />
      </Docs>
    </Member>
    <Member MemberName="MultilineChanged">
      <MemberSignature Language="C#" Value="public event EventHandler MultilineChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler MultilineChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.TextBoxBase.MultilineChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MultilineChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ MultilineChanged;" />
      <MemberSignature Language="F#" Value="member this.MultilineChanged : EventHandler " Usage="member this.MultilineChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在 <see cref="P:System.Windows.Forms.TextBoxBase.Multiline" /> 属性的值更改后发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 有关如何处理事件的详细信息，请参阅 [处理和引发事件](/dotnet/standard/events/)。  
  
   
  
## Examples  
 下面的代码示例演示如何使用此成员。 在此示例中，事件处理程序报告事件的发生 <xref:System.Windows.Forms.TextBoxBase.MultilineChanged> 。 此报表可帮助你了解何时发生事件，并可帮助你进行调试。 若要报告多个事件或频繁发生的事件，请考虑 <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> 将消息替换为多行或将其追加到多行 <xref:System.Windows.Forms.TextBox> 。  
  
 若要运行示例代码，请将其粘贴到一个项目中，该项目包含从继承的类型的实例 <xref:System.Windows.Forms.TextBoxBase> ，如 <xref:System.Windows.Forms.TextBox> 或 <xref:System.Windows.Forms.TextBoxBase> 。 然后命名该实例 `TextBoxBase1` ，并确保事件处理程序与事件相关联 <xref:System.Windows.Forms.TextBoxBase.MultilineChanged> 。  
  
 [!code-csharp[System.Windows.Forms.EventExamples#247](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#247)]
 [!code-vb[System.Windows.Forms.EventExamples#247](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#247)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.TextBoxBase.Multiline" />
      </Docs>
    </Member>
    <Member MemberName="OnAcceptsTabChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnAcceptsTabChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnAcceptsTabChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.TextBoxBase.OnAcceptsTabChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnAcceptsTabChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnAcceptsTabChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnAcceptsTabChanged : EventArgs -&gt; unit&#xA;override this.OnAcceptsTabChanged : EventArgs -&gt; unit" Usage="textBoxBase.OnAcceptsTabChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.EventArgs" />。</param>
        <summary>引发 <see cref="E:System.Windows.Forms.TextBoxBase.AcceptsTabChanged" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 引发事件时，将通过委托调用事件处理程序。 有关详细信息，请参阅 [处理和引发事件](/dotnet/standard/events/)。  
  
 <xref:System.Windows.Forms.TextBoxBase.OnAcceptsTabChanged%2A> 方法还允许派生类对事件进行处理而不必附加委托。 这是在派生类中处理事件的首选技术。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>在派生类中重写 <see cref="M:System.Windows.Forms.TextBoxBase.OnAcceptsTabChanged(System.EventArgs)" /> 时，一定要调用基类的 <see cref="M:System.Windows.Forms.TextBoxBase.OnAcceptsTabChanged(System.EventArgs)" /> 方法，以便已注册的委托对事件进行接收。</para></block>
        <altmember cref="P:System.Windows.Forms.TextBoxBase.AcceptsTab" />
        <altmember cref="E:System.Windows.Forms.TextBoxBase.AcceptsTabChanged" />
      </Docs>
    </Member>
    <Member MemberName="OnAutoSizeChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnAutoSizeChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnAutoSizeChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.TextBoxBase.OnAutoSizeChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnAutoSizeChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnAutoSizeChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnAutoSizeChanged : EventArgs -&gt; unit&#xA;override this.OnAutoSizeChanged : EventArgs -&gt; unit" Usage="textBoxBase.OnAutoSizeChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" Index="0" FrameworkAlternate="netframework-1.1" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的对象。</param>
        <summary>引发 <see cref="E:System.Windows.Forms.TextBoxBase.AutoSizeChanged" /> 事件。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnBorderStyleChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnBorderStyleChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnBorderStyleChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.TextBoxBase.OnBorderStyleChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnBorderStyleChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnBorderStyleChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnBorderStyleChanged : EventArgs -&gt; unit&#xA;override this.OnBorderStyleChanged : EventArgs -&gt; unit" Usage="textBoxBase.OnBorderStyleChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.EventArgs" />。</param>
        <summary>引发 <see cref="E:System.Windows.Forms.TextBoxBase.BorderStyleChanged" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 引发事件时，将通过委托调用事件处理程序。 有关详细信息，请参阅 [处理和引发事件](/dotnet/standard/events/)。  
  
 <xref:System.Windows.Forms.TextBoxBase.OnBorderStyleChanged%2A> 方法还允许派生类对事件进行处理而不必附加委托。 这是在派生类中处理事件的首选技术。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>在派生类中重写 <see cref="M:System.Windows.Forms.TextBoxBase.OnBorderStyleChanged(System.EventArgs)" /> 时，一定要调用基类的 <see cref="M:System.Windows.Forms.TextBoxBase.OnBorderStyleChanged(System.EventArgs)" /> 方法，以便已注册的委托对事件进行接收。</para></block>
        <altmember cref="P:System.Windows.Forms.TextBoxBase.BorderStyle" />
        <altmember cref="E:System.Windows.Forms.TextBoxBase.BorderStyleChanged" />
      </Docs>
    </Member>
    <Member MemberName="OnFontChanged">
      <MemberSignature Language="C#" Value="protected override void OnFontChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnFontChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.TextBoxBase.OnFontChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnFontChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnFontChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnFontChanged : EventArgs -&gt; unit" Usage="textBoxBase.OnFontChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.EventArgs" />。</param>
        <summary>引发 <see cref="E:System.Windows.Forms.Control.FontChanged" /> 事件。</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnFontChanged(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnHandleCreated">
      <MemberSignature Language="C#" Value="protected override void OnHandleCreated (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnHandleCreated(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.TextBoxBase.OnHandleCreated(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnHandleCreated (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnHandleCreated(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnHandleCreated : EventArgs -&gt; unit" Usage="textBoxBase.OnHandleCreated e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.EventArgs" />。</param>
        <summary>引发 <see cref="E:System.Windows.Forms.Control.HandleCreated" /> 事件。</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnHandleCreated(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnHandleDestroyed">
      <MemberSignature Language="C#" Value="protected override void OnHandleDestroyed (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnHandleDestroyed(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.TextBoxBase.OnHandleDestroyed(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnHandleDestroyed (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnHandleDestroyed(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnHandleDestroyed : EventArgs -&gt; unit" Usage="textBoxBase.OnHandleDestroyed e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.EventArgs" />。</param>
        <summary>引发 <see cref="E:System.Windows.Forms.Control.HandleDestroyed" /> 事件。</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnHandleDestroyed(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnHideSelectionChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnHideSelectionChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnHideSelectionChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.TextBoxBase.OnHideSelectionChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnHideSelectionChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnHideSelectionChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnHideSelectionChanged : EventArgs -&gt; unit&#xA;override this.OnHideSelectionChanged : EventArgs -&gt; unit" Usage="textBoxBase.OnHideSelectionChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.EventArgs" />。</param>
        <summary>引发 <see cref="E:System.Windows.Forms.TextBoxBase.HideSelectionChanged" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 引发事件时，将通过委托调用事件处理程序。 有关详细信息，请参阅 [处理和引发事件](/dotnet/standard/events/)。  
  
 <xref:System.Windows.Forms.TextBoxBase.OnHideSelectionChanged%2A> 方法还允许派生类对事件进行处理而不必附加委托。 这是在派生类中处理事件的首选技术。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>在派生类中重写 <see cref="M:System.Windows.Forms.TextBoxBase.OnHideSelectionChanged(System.EventArgs)" /> 时，一定要调用基类的 <see cref="M:System.Windows.Forms.TextBoxBase.OnHideSelectionChanged(System.EventArgs)" /> 方法，以便已注册的委托对事件进行接收。</para></block>
        <altmember cref="P:System.Windows.Forms.TextBoxBase.HideSelection" />
        <altmember cref="E:System.Windows.Forms.TextBoxBase.HideSelectionChanged" />
      </Docs>
    </Member>
    <Member MemberName="OnModifiedChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnModifiedChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnModifiedChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.TextBoxBase.OnModifiedChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnModifiedChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnModifiedChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnModifiedChanged : EventArgs -&gt; unit&#xA;override this.OnModifiedChanged : EventArgs -&gt; unit" Usage="textBoxBase.OnModifiedChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.EventArgs" />。</param>
        <summary>引发 <see cref="E:System.Windows.Forms.TextBoxBase.ModifiedChanged" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 引发事件时，将通过委托调用事件处理程序。 有关详细信息，请参阅 [处理和引发事件](/dotnet/standard/events/)。  
  
 <xref:System.Windows.Forms.TextBoxBase.OnModifiedChanged%2A> 方法还允许派生类对事件进行处理而不必附加委托。 这是在派生类中处理事件的首选技术。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>在派生类中重写 <see cref="M:System.Windows.Forms.TextBoxBase.OnModifiedChanged(System.EventArgs)" /> 时，一定要调用基类的 <see cref="M:System.Windows.Forms.TextBoxBase.OnModifiedChanged(System.EventArgs)" /> 方法，以便已注册的委托对事件进行接收。</para></block>
        <altmember cref="P:System.Windows.Forms.TextBoxBase.Modified" />
        <altmember cref="E:System.Windows.Forms.TextBoxBase.ModifiedChanged" />
      </Docs>
    </Member>
    <Member MemberName="OnMouseUp">
      <MemberSignature Language="C#" Value="protected override void OnMouseUp (System.Windows.Forms.MouseEventArgs mevent);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnMouseUp(class System.Windows.Forms.MouseEventArgs mevent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.TextBoxBase.OnMouseUp(System.Windows.Forms.MouseEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnMouseUp (mevent As MouseEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnMouseUp(System::Windows::Forms::MouseEventArgs ^ mevent);" />
      <MemberSignature Language="F#" Value="override this.OnMouseUp : System.Windows.Forms.MouseEventArgs -&gt; unit" Usage="textBoxBase.OnMouseUp mevent" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mevent" Type="System.Windows.Forms.MouseEventArgs" Index="0" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="mevent">事件数据。</param>
        <summary>引发 <see cref="E:System.Windows.Forms.Control.MouseUp" /> 事件。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnMultilineChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnMultilineChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnMultilineChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.TextBoxBase.OnMultilineChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnMultilineChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnMultilineChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnMultilineChanged : EventArgs -&gt; unit&#xA;override this.OnMultilineChanged : EventArgs -&gt; unit" Usage="textBoxBase.OnMultilineChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.EventArgs" />。</param>
        <summary>引发 <see cref="E:System.Windows.Forms.TextBoxBase.MultilineChanged" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 引发事件时，将通过委托调用事件处理程序。 有关详细信息，请参阅 [处理和引发事件](/dotnet/standard/events/)。  
  
 <xref:System.Windows.Forms.TextBoxBase.OnMultilineChanged%2A> 方法还允许派生类对事件进行处理而不必附加委托。 这是在派生类中处理事件的首选技术。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>在派生类中重写 <see cref="M:System.Windows.Forms.TextBoxBase.OnMultilineChanged(System.EventArgs)" /> 时，一定要调用基类的 <see cref="M:System.Windows.Forms.TextBoxBase.OnMultilineChanged(System.EventArgs)" /> 方法，以便已注册的委托对事件进行接收。</para></block>
        <altmember cref="P:System.Windows.Forms.TextBoxBase.Multiline" />
        <altmember cref="E:System.Windows.Forms.TextBoxBase.MultilineChanged" />
      </Docs>
    </Member>
    <Member MemberName="OnPaddingChanged">
      <MemberSignature Language="C#" Value="protected override void OnPaddingChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnPaddingChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.TextBoxBase.OnPaddingChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnPaddingChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnPaddingChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnPaddingChanged : EventArgs -&gt; unit" Usage="textBoxBase.OnPaddingChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" Index="0" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.EventArgs" />。</param>
        <summary>此方法与此类无关。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法与此类无关。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnReadOnlyChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnReadOnlyChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnReadOnlyChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.TextBoxBase.OnReadOnlyChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnReadOnlyChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnReadOnlyChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnReadOnlyChanged : EventArgs -&gt; unit&#xA;override this.OnReadOnlyChanged : EventArgs -&gt; unit" Usage="textBoxBase.OnReadOnlyChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.EventArgs" />。</param>
        <summary>引发 <see cref="E:System.Windows.Forms.TextBoxBase.ReadOnlyChanged" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 引发事件时，将通过委托调用事件处理程序。 有关详细信息，请参阅 [处理和引发事件](/dotnet/standard/events/)。  
  
 <xref:System.Windows.Forms.TextBoxBase.OnReadOnlyChanged%2A> 方法还允许派生类对事件进行处理而不必附加委托。 这是在派生类中处理事件的首选技术。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>在派生类中重写 <see cref="M:System.Windows.Forms.TextBoxBase.OnReadOnlyChanged(System.EventArgs)" /> 时，一定要调用基类的 <see cref="M:System.Windows.Forms.TextBoxBase.OnReadOnlyChanged(System.EventArgs)" /> 方法，以便已注册的委托对事件进行接收。</para></block>
        <altmember cref="P:System.Windows.Forms.TextBoxBase.ReadOnly" />
        <altmember cref="E:System.Windows.Forms.TextBoxBase.ReadOnlyChanged" />
      </Docs>
    </Member>
    <Member MemberName="OnTextChanged">
      <MemberSignature Language="C#" Value="protected override void OnTextChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnTextChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.TextBoxBase.OnTextChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnTextChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnTextChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnTextChanged : EventArgs -&gt; unit" Usage="textBoxBase.OnTextChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" Index="0" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.EventArgs" />。</param>
        <summary>引发 <see cref="E:System.Windows.Forms.Control.TextChanged" /> 事件。</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnTextChanged(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="Padding">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.Padding Padding { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.Padding Padding" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.TextBoxBase.Padding" />
      <MemberSignature Language="VB.NET" Value="Public Property Padding As Padding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::Padding Padding { System::Windows::Forms::Padding get(); void set(System::Windows::Forms::Padding value); };" />
      <MemberSignature Language="F#" Value="member this.Padding : System.Windows.Forms.Padding with get, set" Usage="System.Windows.Forms.TextBoxBase.Padding" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.ComponentModel.Browsable(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.Browsable(false)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Padding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>此属性与此类无关。</summary>
        <value>一个 <see cref="T:System.Windows.Forms.Padding" /> 值。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此属性与此类无关。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PaddingChanged">
      <MemberSignature Language="C#" Value="public event EventHandler PaddingChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler PaddingChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.TextBoxBase.PaddingChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PaddingChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ PaddingChanged;" />
      <MemberSignature Language="F#" Value="member this.PaddingChanged : EventHandler " Usage="member this.PaddingChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.ComponentModel.Browsable(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.Browsable(false)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>此事件与此类无关。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此事件与此类无关。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Paint">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.PaintEventHandler Paint;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.PaintEventHandler Paint" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.TextBoxBase.Paint" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Paint As PaintEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::PaintEventHandler ^ Paint;" />
      <MemberSignature Language="F#" Value="member this.Paint : System.Windows.Forms.PaintEventHandler " Usage="member this.Paint : System.Windows.Forms.PaintEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.Browsable(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.Browsable(false)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.PaintEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在重绘控件时发生。 此事件与此类无关。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此事件与此类无关。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Paste">
      <MemberSignature Language="C#" Value="public void Paste ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Paste() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.TextBoxBase.Paste" />
      <MemberSignature Language="VB.NET" Value="Public Sub Paste ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Paste();" />
      <MemberSignature Language="F#" Value="member this.Paste : unit -&gt; unit" Usage="textBoxBase.Paste " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>用 **剪贴板**的内容替换文本框中的当前选定内容。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.TextBoxBase.Paste%2A>只有文本当前存储在**剪贴板**中时，该方法才会将文本粘贴到控件中。  
  
   
  
## Examples  
 下面的代码示例使用 <xref:System.Windows.Forms.TextBox> 派生类。 它 <xref:System.Windows.Forms.MenuItem.Click> 为 <xref:System.Windows.Forms.MenuItem> 执行剪切、复制、粘贴和撤消操作的对象提供事件处理程序。 此示例需要 <xref:System.Windows.Forms.TextBox> 创建名为的 `textBox1` 控件。  
  
 [!code-cpp[Classic TextBoxBase.SelectionLength Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic TextBoxBase.SelectionLength Example/CPP/source.cpp#1)]
 [!code-csharp[Classic TextBoxBase.SelectionLength Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic TextBoxBase.SelectionLength Example/CS/source.cs#1)]
 [!code-vb[Classic TextBoxBase.SelectionLength Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic TextBoxBase.SelectionLength Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreferredHeight">
      <MemberSignature Language="C#" Value="public int PreferredHeight { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 PreferredHeight" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.TextBoxBase.PreferredHeight" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PreferredHeight As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int PreferredHeight { int get(); };" />
      <MemberSignature Language="F#" Value="member this.PreferredHeight : int" Usage="System.Windows.Forms.TextBoxBase.PreferredHeight" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.Browsable(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.Browsable(false)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取文本框的首选高度。</summary>
        <value>文本框的首选高度。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此属性返回的大小基于文本框的字体高度和边框样式。 您可以使用此属性来确定文本框的大小，以确保文本在控件中正确显示。 此属性返回的值以像素为单位。  
  
 的值 <xref:System.Windows.Forms.TextBoxBase.PreferredHeight%2A> 表示文本框必须具有的最小高度，以便在不剪辑顶部或底部的情况下显示单行文本。 无论 <xref:System.Windows.Forms.TextBoxBase.Multiline%2A> 属性是设置为还是，此值都是相同的 `true` `false` 。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.TextBoxBase.AutoSize" />
      </Docs>
    </Member>
    <Member MemberName="ProcessCmdKey">
      <MemberSignature Language="C#" Value="protected override bool ProcessCmdKey (ref System.Windows.Forms.Message msg, System.Windows.Forms.Keys keyData);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance bool ProcessCmdKey(valuetype System.Windows.Forms.Message&amp; msg, valuetype System.Windows.Forms.Keys keyData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.TextBoxBase.ProcessCmdKey(System.Windows.Forms.Message@,System.Windows.Forms.Keys)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function ProcessCmdKey (ByRef msg As Message, keyData As Keys) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override bool ProcessCmdKey(System::Windows::Forms::Message % msg, System::Windows::Forms::Keys keyData);" />
      <MemberSignature Language="F#" Value="override this.ProcessCmdKey : Message * System.Windows.Forms.Keys -&gt; bool" Usage="textBoxBase.ProcessCmdKey (msg, keyData)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="msg" Type="System.Windows.Forms.Message" RefType="ref" Index="0" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="keyData" Type="System.Windows.Forms.Keys" Index="1" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="msg">通过引用传递的 <see cref="T:System.Windows.Forms.Message" />，表示要处理的窗口消息。</param>
        <param name="keyData"><see cref="T:System.Windows.Forms.Keys" /> 值之一，表示要处理的快捷键。</param>
        <summary>处理命令键。</summary>
        <returns>如果命令键已由控件处理，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ProcessDialogKey">
      <MemberSignature Language="C#" Value="protected override bool ProcessDialogKey (System.Windows.Forms.Keys keyData);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance bool ProcessDialogKey(valuetype System.Windows.Forms.Keys keyData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.TextBoxBase.ProcessDialogKey(System.Windows.Forms.Keys)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function ProcessDialogKey (keyData As Keys) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override bool ProcessDialogKey(System::Windows::Forms::Keys keyData);" />
      <MemberSignature Language="F#" Value="override this.ProcessDialogKey : System.Windows.Forms.Keys -&gt; bool" Usage="textBoxBase.ProcessDialogKey keyData" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keyData" Type="System.Windows.Forms.Keys" />
      </Parameters>
      <Docs>
        <param name="keyData"><see cref="T:System.Windows.Forms.Keys" /> 值之一，表示要处理的键。</param>
        <summary>处理对话框键。</summary>
        <returns>如果键已由控件处理，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Forms.Control.ProcessDialogKey(System.Windows.Forms.Keys)" />
      </Docs>
    </Member>
    <Member MemberName="ReadOnly">
      <MemberSignature Language="C#" Value="public bool ReadOnly { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.TextBoxBase.ReadOnly" />
      <MemberSignature Language="VB.NET" Value="Public Property ReadOnly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ReadOnly { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ReadOnly : bool with get, set" Usage="System.Windows.Forms.TextBoxBase.ReadOnly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.DefaultValue(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.DefaultValue(false)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.ComponentModel.RefreshProperties(System.ComponentModel.RefreshProperties.Repaint)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.RefreshProperties(System.ComponentModel.RefreshProperties.Repaint)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指示文本框中的文本是否为只读。</summary>
        <value>如果文本框是只读的，则为 <see langword="true" />，否则为 <see langword="false" />。 默认值为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当此属性设置为时 `true` ，用户不能在运行时更改控件的内容。 将此属性设置为时 `true` ，仍可以 <xref:System.Windows.Forms.TextBoxBase.Text%2A> 在代码中设置属性的值。 您可以使用此功能，而不是使用属性禁用控件， <xref:System.Windows.Forms.Control.Enabled%2A> 以允许复制内容和显示工具提示。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadOnlyChanged">
      <MemberSignature Language="C#" Value="public event EventHandler ReadOnlyChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler ReadOnlyChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.TextBoxBase.ReadOnlyChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ReadOnlyChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ ReadOnlyChanged;" />
      <MemberSignature Language="F#" Value="member this.ReadOnlyChanged : EventHandler " Usage="member this.ReadOnlyChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在 <see cref="P:System.Windows.Forms.TextBoxBase.ReadOnly" /> 属性的值更改后发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 有关如何处理事件的详细信息，请参阅 [处理和引发事件](/dotnet/standard/events/)。  
  
   
  
## Examples  
 下面的代码示例演示如何使用此成员。 在此示例中，事件处理程序报告事件的发生 <xref:System.Windows.Forms.TextBoxBase.ReadOnlyChanged> 。 此报表可帮助你了解何时发生事件，并可帮助你进行调试。 若要报告多个事件或频繁发生的事件，请考虑 <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> 将消息替换为多行或将其追加到多行 <xref:System.Windows.Forms.TextBox> 。  
  
 若要运行示例代码，请将其粘贴到一个项目中，该项目包含从继承的类型的实例 <xref:System.Windows.Forms.TextBoxBase> ，如 <xref:System.Windows.Forms.TextBox> 或 <xref:System.Windows.Forms.TextBoxBase> 。 然后命名该实例 `TextBoxBase1` ，并确保事件处理程序与事件相关联 <xref:System.Windows.Forms.TextBoxBase.ReadOnlyChanged> 。  
  
 [!code-csharp[System.Windows.Forms.EventExamples#248](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#248)]
 [!code-vb[System.Windows.Forms.EventExamples#248](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#248)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.TextBoxBase.ReadOnly" />
      </Docs>
    </Member>
    <Member MemberName="ScrollToCaret">
      <MemberSignature Language="C#" Value="public void ScrollToCaret ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ScrollToCaret() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.TextBoxBase.ScrollToCaret" />
      <MemberSignature Language="VB.NET" Value="Public Sub ScrollToCaret ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ScrollToCaret();" />
      <MemberSignature Language="F#" Value="member this.ScrollToCaret : unit -&gt; unit" Usage="textBoxBase.ScrollToCaret " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>将控件内容滚动到当前插入符号位置。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法可让你滚动控件的内容，直到插入符号位于控件的可见区域内。 如果插入符号位于控件的可见区域下方，则 <xref:System.Windows.Forms.TextBoxBase.ScrollToCaret%2A> 方法将滚动控件的内容，直到在控件的底部显示插入符号。 如果插入符号位于控件的可见区域之上，则此方法将滚动控件的内容，直到在控件顶部显示插入符号。 您可以在多行文本框中使用此方法，以确保当前文本输入点位于控件的可见区域内。  
  
> [!NOTE]
>  如果控件没有焦点，或插入符号已定位在控件的可视区域中，则此方法不起作用。  
  
   
  
## Examples  
 下面的代码示例演示如何使用 <xref:System.Windows.Forms.Keys> 枚举和 <xref:System.Windows.Forms.TextBoxBase.ScrollToCaret%2A> 方法，以确保按下 ENTER 键后，在屏幕上始终可见文本插入点。 若要运行该示例，请将以下代码粘贴到包含名为的 <xref:System.Windows.Forms.TextBox> 控件 `TextBox1` 和 <xref:System.Windows.Forms.RichTextBox> 名为的控件的窗体中 `RichTextBox1` 。 此示例要求事件处理方法已与 <xref:System.Windows.Forms.Control.KeyDown> 事件关联。  
  
 [!code-cpp[System.Windows.Forms.TextBoxBaseScrolling#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.TextBoxBaseScrolling/CPP/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.TextBoxBaseScrolling#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.TextBoxBaseScrolling/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.TextBoxBaseScrolling#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.TextBoxBaseScrolling/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Select">
      <MemberSignature Language="C#" Value="public void Select (int start, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Select(int32 start, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.TextBoxBase.Select(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Select (start As Integer, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Select(int start, int length);" />
      <MemberSignature Language="F#" Value="override this.Select : int * int -&gt; unit" Usage="textBoxBase.Select (start, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="start" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="start">文本框中当前选定文本的第一个字符的位置。</param>
        <param name="length">要选择的字符数。</param>
        <summary>选择文本框中的文本范围。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果要将起始位置设置为控件文本中的第一个字符，请将 `start` 参数设置为0。 您可以使用此方法来选择文本的子字符串，例如搜索控件的文本和替换信息。  
  
> [!NOTE]
>  您可以通过在文本框中将参数设置为要将插入符号移动到的位置来以编程方式移动插入符号 `start` ，并将参数的值设置 `length` 为零 (0) 。 文本框必须具有焦点，才能移动插入符号。  
  
> [!NOTE]
>  如果在没有任何参数的情况下调用此方法，将使用替代方法。 此替代方法从类继承 <xref:System.Windows.Forms.Control> 。 调用时，它会将输入焦点设置到控件，并选择控件的内容。 有关更多信息，请参见 <xref:System.Windows.Forms.Control.Select%2A?displayProperty=nameWithType> 方法。  
  
   
  
## Examples  
 下面的代码示例使用 <xref:System.Windows.Forms.TextBox> 派生类，在控件的内容中搜索单词 "fox" 的实例。 如果找到，则代码使用方法选择控件中的单词 <xref:System.Windows.Forms.TextBoxBase.Select%2A> 。 此示例要求已创建了一个 <xref:System.Windows.Forms.TextBox> 名为的 `textBox1` ，其 <xref:System.Windows.Forms.TextBoxBase.Text%2A> 属性包含一个 "快速棕色 fox 跨延迟 dog" 的句子。  
  
 [!code-cpp[Classic TextBoxBase.Select Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic TextBoxBase.Select Example/CPP/source.cpp#1)]
 [!code-csharp[Classic TextBoxBase.Select Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic TextBoxBase.Select Example/CS/source.cs#1)]
 [!code-vb[Classic TextBoxBase.Select Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic TextBoxBase.Select Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="start" /> 参数的值小于零。</exception>
        <altmember cref="M:System.Windows.Forms.TextBoxBase.SelectAll" />
        <altmember cref="P:System.Windows.Forms.TextBoxBase.SelectionLength" />
        <altmember cref="P:System.Windows.Forms.TextBoxBase.SelectionStart" />
        <altmember cref="P:System.Windows.Forms.TextBoxBase.SelectedText" />
      </Docs>
    </Member>
    <Member MemberName="SelectAll">
      <MemberSignature Language="C#" Value="public void SelectAll ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SelectAll() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.TextBoxBase.SelectAll" />
      <MemberSignature Language="VB.NET" Value="Public Sub SelectAll ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SelectAll();" />
      <MemberSignature Language="F#" Value="member this.SelectAll : unit -&gt; unit" Usage="textBoxBase.SelectAll " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>选定文本框中的所有文本。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法允许您选择控件中的所有文本。 您可以将此方法与方法结合使用 <xref:System.Windows.Forms.TextBoxBase.Cut%2A> ，这需要在控件中选择文本，以剪切控件的全部内容并将其粘贴到 **剪贴板**。  
  
   
  
## Examples  
 下面的代码示例使用 <xref:System.Windows.Forms.TextBox> 派生类来确定是否在控件中选择了任何文本。 如果未选择任何文本，则在将 <xref:System.Windows.Forms.TextBoxBase.SelectAll%2A> 控件的内容复制到 **剪贴板**之前对方法进行调用。 此示例要求创建了 <xref:System.Windows.Forms.TextBox> 名为的 `textBox1` 。  
  
 [!code-cpp[Classic TextBoxBase.SelectAll Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic TextBoxBase.SelectAll Example/CPP/source.cpp#1)]
 [!code-csharp[Classic TextBoxBase.SelectAll Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic TextBoxBase.SelectAll Example/CS/source.cs#1)]
 [!code-vb[Classic TextBoxBase.SelectAll Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic TextBoxBase.SelectAll Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SelectedText">
      <MemberSignature Language="C#" Value="public virtual string SelectedText { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string SelectedText" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.TextBoxBase.SelectedText" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property SelectedText As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ SelectedText { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.SelectedText : string with get, set" Usage="System.Windows.Forms.TextBoxBase.SelectedText" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.Browsable(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.Browsable(false)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指示控件中当前选定的文本。</summary>
        <value>表示文本框中当前选定文本的字符串。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 您可以为此属性分配文本，以更改文本框中当前选定的文本。 如果文本框中当前未选定任何文本，此属性将返回一个长度为零的字符串。  
  
   
  
## Examples  
 下面的代码示例使用 <xref:System.Windows.Forms.TextBox> 派生类。 它 <xref:System.Windows.Forms.MenuItem.Click> 为 <xref:System.Windows.Forms.MenuItem> 执行剪切、复制、粘贴和撤消操作的对象提供事件处理程序。 此示例需要 <xref:System.Windows.Forms.TextBox> 创建名为的 `textBox1` 控件。  
  
 [!code-cpp[Classic TextBoxBase.SelectedText Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic TextBoxBase.SelectedText Example/CPP/source.cpp#1)]
 [!code-csharp[Classic TextBoxBase.SelectedText Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic TextBoxBase.SelectedText Example/CS/source.cs#1)]
 [!code-vb[Classic TextBoxBase.SelectedText Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic TextBoxBase.SelectedText Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.TextBoxBase.SelectionStart" />
        <altmember cref="P:System.Windows.Forms.TextBoxBase.SelectionLength" />
      </Docs>
    </Member>
    <Member MemberName="SelectionLength">
      <MemberSignature Language="C#" Value="public virtual int SelectionLength { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 SelectionLength" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.TextBoxBase.SelectionLength" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property SelectionLength As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int SelectionLength { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.SelectionLength : int with get, set" Usage="System.Windows.Forms.TextBoxBase.SelectionLength" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.Browsable(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.Browsable(false)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置文本框中选定的字符数。</summary>
        <value>文本框中选定的字符数。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在对所选文本执行操作之前，可以使用此属性来确定当前在 "文本框" 控件中是否选择了任何字符。 如果将属性的值 <xref:System.Windows.Forms.TextBoxBase.SelectionLength%2A> 设置为大于控件文本内的字符数的值，则属性的值 <xref:System.Windows.Forms.TextBoxBase.SelectionLength%2A> 将设置为控件中的文本的整个长度减去 (属性的值（ <xref:System.Windows.Forms.TextBoxBase.SelectionStart%2A> 如果为属性) 指定了任何值） <xref:System.Windows.Forms.TextBoxBase.SelectionStart%2A> 。  
  
> [!NOTE]
>  您可以通过在文本框中将插入符号的位置设置为要在 <xref:System.Windows.Forms.TextBoxBase.SelectionStart%2A> 其中移动插入符号的位置，并将该 <xref:System.Windows.Forms.TextBoxBase.SelectionLength%2A> 属性的值设置为零 (0) ，以编程方式在文本框中移动插入符号。 文本框必须具有焦点，才能移动插入符号。  
  
   
  
## Examples  
 下面的代码示例使用 <xref:System.Windows.Forms.TextBox> 派生类。 它 <xref:System.Windows.Forms.MenuItem.Click> 为 <xref:System.Windows.Forms.MenuItem> 执行剪切、复制、粘贴和撤消操作的对象提供事件处理程序。 此示例需要 <xref:System.Windows.Forms.TextBox> 创建名为的 `textBox1` 控件。  
  
 [!code-cpp[Classic TextBoxBase.SelectionLength Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic TextBoxBase.SelectionLength Example/CPP/source.cpp#1)]
 [!code-csharp[Classic TextBoxBase.SelectionLength Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic TextBoxBase.SelectionLength Example/CS/source.cs#1)]
 [!code-vb[Classic TextBoxBase.SelectionLength Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic TextBoxBase.SelectionLength Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">赋给的值小于零。</exception>
        <altmember cref="P:System.Windows.Forms.TextBoxBase.SelectionStart" />
        <altmember cref="P:System.Windows.Forms.TextBoxBase.SelectedText" />
      </Docs>
    </Member>
    <Member MemberName="SelectionStart">
      <MemberSignature Language="C#" Value="public int SelectionStart { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 SelectionStart" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.TextBoxBase.SelectionStart" />
      <MemberSignature Language="VB.NET" Value="Public Property SelectionStart As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int SelectionStart { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.SelectionStart : int with get, set" Usage="System.Windows.Forms.TextBoxBase.SelectionStart" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.Browsable(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.Browsable(false)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置文本框中选定的文本起始点。</summary>
        <value>文本框中选定的文本的起始位置。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果在控件中未选择任何文本，此属性将指示新文本的插入点或插入符号。 如果将此属性设置为超出控件中文本长度的位置，则所选内容的起始位置将被置于最后一个字符之后。 在文本框控件中选择文本时，更改此属性可能会降低属性的值 <xref:System.Windows.Forms.TextBoxBase.SelectionLength%2A> 。 如果控件中由属性指示的位置之后的剩余文本 <xref:System.Windows.Forms.TextBoxBase.SelectionStart%2A> 小于属性的值 <xref:System.Windows.Forms.TextBoxBase.SelectionLength%2A> ，则 <xref:System.Windows.Forms.TextBoxBase.SelectionLength%2A> 自动减小属性的值。 属性的值 <xref:System.Windows.Forms.TextBoxBase.SelectionStart%2A> 从不导致 <xref:System.Windows.Forms.TextBoxBase.SelectionLength%2A> 属性增加。  
  
 您可以通过设置和属性，以编程方式在文本框中移动选择 <xref:System.Windows.Forms.TextBoxBase.SelectionStart%2A> <xref:System.Windows.Forms.TextBoxBase.SelectionLength%2A> 。  
  
 您可以通过在文本框中将插入符号的位置设置为要在 <xref:System.Windows.Forms.TextBoxBase.SelectionStart%2A> 其中移动插入符号的位置，并将该 <xref:System.Windows.Forms.TextBoxBase.SelectionLength%2A> 属性的值设置为零 (0) ，以编程方式在文本框中移动插入符号。  
  
 <xref:System.Windows.Forms.TextBox>若要移动选定内容或插入符号，必须具有焦点。 可以设置的 <xref:System.Windows.Forms.TextBoxBase.SelectionStart%2A> 属性 <xref:System.Windows.Forms.TextBox> ，方法是先将 <xref:System.Windows.Forms.TextBoxBase.ReadOnly%2A> 其赋予 <xref:System.Windows.Forms.Control.Focus%2A> 。  
  
   
  
## Examples  
 **示例 1**  
  
 下面的代码示例使用 <xref:System.Windows.Forms.TextBox> 派生类。 它 <xref:System.Windows.Forms.MenuItem.Click> 为 <xref:System.Windows.Forms.MenuItem> 执行剪切、复制、粘贴和撤消操作的对象提供事件处理程序。 此示例需要 <xref:System.Windows.Forms.TextBox> 创建名为的 `textBox1` 控件。  
  
 [!code-cpp[Classic TextBoxBase.SelectionLength Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic TextBoxBase.SelectionLength Example/CPP/source.cpp#1)]
 [!code-csharp[Classic TextBoxBase.SelectionLength Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic TextBoxBase.SelectionLength Example/CS/source.cs#1)]
 [!code-vb[Classic TextBoxBase.SelectionLength Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic TextBoxBase.SelectionLength Example/VB/source.vb#1)]  
  
 **示例 2**  
  
 下面的示例通过将的属性设置为第一个来设置的 <xref:System.Windows.Forms.TextBoxBase.SelectionStart%2A> 属性 <xref:System.Windows.Forms.TextBox> <xref:System.Windows.Forms.TextBoxBase.ReadOnly%2A> <xref:System.Windows.Forms.Control.Focus%2A> 。  
  
 [!code-csharp[SystemWindowsFormsTextBoxBase#1](~/samples/snippets/csharp/VS_Snippets_Winforms/SystemWindowsFormsTextBoxBase/CS/Form1.cs#1)]
 [!code-vb[SystemWindowsFormsTextBoxBase#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/SystemWindowsFormsTextBoxBase/VB/Form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">赋给的值小于零。</exception>
      </Docs>
    </Member>
    <Member MemberName="SetBoundsCore">
      <MemberSignature Language="C#" Value="protected override void SetBoundsCore (int x, int y, int width, int height, System.Windows.Forms.BoundsSpecified specified);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void SetBoundsCore(int32 x, int32 y, int32 width, int32 height, valuetype System.Windows.Forms.BoundsSpecified specified) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.TextBoxBase.SetBoundsCore(System.Int32,System.Int32,System.Int32,System.Int32,System.Windows.Forms.BoundsSpecified)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub SetBoundsCore (x As Integer, y As Integer, width As Integer, height As Integer, specified As BoundsSpecified)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void SetBoundsCore(int x, int y, int width, int height, System::Windows::Forms::BoundsSpecified specified);" />
      <MemberSignature Language="F#" Value="override this.SetBoundsCore : int * int * int * int * System.Windows.Forms.BoundsSpecified -&gt; unit" Usage="textBoxBase.SetBoundsCore (x, y, width, height, specified)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Int32" />
        <Parameter Name="y" Type="System.Int32" />
        <Parameter Name="width" Type="System.Int32" />
        <Parameter Name="height" Type="System.Int32" />
        <Parameter Name="specified" Type="System.Windows.Forms.BoundsSpecified" />
      </Parameters>
      <Docs>
        <param name="x">控件的新 <see cref="P:System.Windows.Forms.Control.Left" /> 属性值。</param>
        <param name="y">控件的新 <see cref="P:System.Windows.Forms.Control.Top" /> 属性值。</param>
        <param name="width">控件的新 <see cref="P:System.Windows.Forms.Control.Width" /> 属性值。</param>
        <param name="height">未使用。</param>
        <param name="specified"><see cref="T:System.Windows.Forms.BoundsSpecified" /> 值的按位组合。</param>
        <summary>设置 <see cref="T:System.Windows.Forms.TextBoxBase" /> 控件的指定边界。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.TextBoxBase> <xref:System.Windows.Forms.TextBoxBase.PreferredHeight%2A> 如果 <xref:System.Windows.Forms.TextBoxBase.AutoSize%2A> 属性为 `true` 且 <xref:System.Windows.Forms.TextBoxBase.Multiline%2A> 属性为，则控件使用属性来设置边界 `false` 。  
  
 通常，与参数中未包含的界限相对应的参数 `specified` 将与当前值一起传入。 例如， <xref:System.Windows.Forms.Control.Height%2A> <xref:System.Windows.Forms.Control.Width%2A> 可以将属性的、或 <xref:System.Drawing.Point.X%2A> 属性 <xref:System.Drawing.Point.Y%2A> <xref:System.Windows.Forms.Control.Location%2A> 与控件的当前实例的引用一起传入。 但是，传入的所有值都将生效并应用于控件。  
  
 `specified`参数表示 <xref:System.Windows.Forms.Control.Bounds%2A> 由您的应用程序更改的控件的元素。 例如，如果更改 <xref:System.Windows.Forms.Control.Size%2A> 控件的，则 `specified` 参数值为 `Size` 的值 <xref:System.Windows.Forms.BoundsSpecified> 。 但是，如果 <xref:System.Windows.Forms.Control.Size%2A> 在响应所设置的属性时调整 <xref:System.Windows.Forms.Control.Dock%2A> ，则 `specified` 参数值为 `None` 的值 <xref:System.Windows.Forms.BoundsSpecified> 。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>当 <see cref="M:System.Windows.Forms.TextBoxBase.SetBoundsCore(System.Int32,System.Int32,System.Int32,System.Int32,System.Windows.Forms.BoundsSpecified)" /> 在派生类中重写时，请确保调用基类的 <see cref="M:System.Windows.Forms.TextBoxBase.SetBoundsCore(System.Int32,System.Int32,System.Int32,System.Int32,System.Windows.Forms.BoundsSpecified)" /> 方法来强制更改控件边界。 派生类可以向方法添加大小限制 <see cref="M:System.Windows.Forms.TextBoxBase.SetBoundsCore(System.Int32,System.Int32,System.Int32,System.Int32,System.Windows.Forms.BoundsSpecified)" /> 。</para></block>
      </Docs>
    </Member>
    <Member MemberName="ShortcutsEnabled">
      <MemberSignature Language="C#" Value="public virtual bool ShortcutsEnabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ShortcutsEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.TextBoxBase.ShortcutsEnabled" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property ShortcutsEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool ShortcutsEnabled { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ShortcutsEnabled : bool with get, set" Usage="System.Windows.Forms.TextBoxBase.ShortcutsEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.ComponentModel.DefaultValue(true)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.DefaultValue(true)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指示是否启用已定义的快捷方式。</summary>
        <value><see langword="true" /> 则启用快捷方式，否则 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用 <xref:System.Windows.Forms.TextBoxBase.ShortcutsEnabled%2A> 属性可以启用或禁用以下快捷组合键和控件的快捷菜单：  
  
-   CTRL+Z  
  
-   Ctrl+E  
  
-   Ctrl+C  
  
-   Ctrl+Y  
  
-   Ctrl+X  
  
-   Ctrl+Backspace  
  
-   Ctrl+V  
  
-   Ctrl+Delete  
  
-   CTRL + A  
  
-   Shift+Delete  
  
-   Ctrl+L  
  
-   Shift+Insert  
  
-   Ctrl+R  
  
 可以重写此属性以指定其他快捷键。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Text">
      <MemberSignature Language="C#" Value="public override string Text { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Text" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.TextBoxBase.Text" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Text As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Text { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Text : string with get, set" Usage="System.Windows.Forms.TextBoxBase.Text" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.ComponentModel.Editor("System.ComponentModel.Design.MultilineStringEditor, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", typeof(System.Drawing.Design.UITypeEditor))]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.Editor("System.ComponentModel.Design.MultilineStringEditor, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", typeof(System.Drawing.Design.UITypeEditor))&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.Localizable(true)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.Localizable(true)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName Language="C#">[System.ComponentModel.Editor("System.ComponentModel.Design.MultilineStringEditor, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", typeof(System.Drawing.Design.UITypeEditor))]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.Editor("System.ComponentModel.Design.MultilineStringEditor, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", typeof(System.Drawing.Design.UITypeEditor))&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置文本框中的当前文本。</summary>
        <value>在控件中显示的文本。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要在文本框中显示多行文本，请将 <xref:System.Windows.Forms.TextBoxBase.Multiline%2A> 属性设置为 `true` 。 若要读取或设置多行文本框的文本，请使用 <xref:System.Windows.Forms.TextBoxBase.Lines%2A> 属性。 可以在控件中输入的文本量仅受 <xref:System.Windows.Forms.RichTextBox> 可用系统内存限制。  
  
   
  
## Examples  
 下面的代码示例使用 <xref:System.Windows.Forms.TextBox> 派生类创建 <xref:System.Windows.Forms.TextBox> 具有垂直滚动条的多行控件。 此示例还使用 <xref:System.Windows.Forms.TextBoxBase.AcceptsTab%2A> 、 <xref:System.Windows.Forms.TextBox.AcceptsReturn%2A> 和 <xref:System.Windows.Forms.TextBoxBase.WordWrap%2A> 属性使 "多行文本框" 控件对创建文本文档有用。  
  
 [!code-cpp[Classic TextBoxBase.AcceptsTab Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic TextBoxBase.AcceptsTab Example/CPP/source.cpp#1)]
 [!code-csharp[Classic TextBoxBase.AcceptsTab Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic TextBoxBase.AcceptsTab Example/CS/source.cs#1)]
 [!code-vb[Classic TextBoxBase.AcceptsTab Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic TextBoxBase.AcceptsTab Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.TextBoxBase.Lines" />
        <altmember cref="P:System.Windows.Forms.TextBoxBase.Multiline" />
      </Docs>
    </Member>
    <Member MemberName="TextLength">
      <MemberSignature Language="C#" Value="public virtual int TextLength { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 TextLength" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.TextBoxBase.TextLength" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property TextLength As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int TextLength { int get(); };" />
      <MemberSignature Language="F#" Value="member this.TextLength : int" Usage="System.Windows.Forms.TextBoxBase.TextLength" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.Browsable(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.Browsable(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取控件中文本的长度。</summary>
        <value>控件文本中所含的字符数。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 您可以使用此属性来确定字符串中的字符数（如搜索控件文本内的特定文本字符串，其中需要了解字符的总数）。  
  
   
  
## Examples  
 下面的代码示例演示如何使用 <xref:System.Windows.Forms.TextBoxBase.AppendText%2A> 方法和 <xref:System.Windows.Forms.TextBoxBase.TextLength%2A> 属性将文本从一个复制 <xref:System.Windows.Forms.TextBox> 到另一个。 此示例要求 <xref:System.Windows.Forms.TextBox> 在窗体中添加了名为和的两个控件， `textBox1` 并将文本分配给了 `textBox2` `textBox1` 其 <xref:System.Windows.Forms.Control.Text%2A> 属性。  
  
 [!code-cpp[TextBoxBase.AppendText#1](~/samples/snippets/cpp/VS_Snippets_Winforms/TextBoxBase.AppendText/CPP/form1.cpp#1)]
 [!code-csharp[TextBoxBase.AppendText#1](~/samples/snippets/csharp/VS_Snippets_Winforms/TextBoxBase.AppendText/CS/form1.cs#1)]
 [!code-vb[TextBoxBase.AppendText#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/TextBoxBase.AppendText/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.TextBoxBase.Text" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.TextBoxBase.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="textBoxBase.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回表示 <see cref="T:System.Windows.Forms.TextBoxBase" /> 控件的字符串。</summary>
        <returns>表示当前 <see cref="T:System.Windows.Forms.TextBoxBase" /> 的字符串。 该字符串包括该控件的类型和 <see cref="T:System.Windows.Forms.TextBoxBase" /> 属性。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Undo">
      <MemberSignature Language="C#" Value="public void Undo ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Undo() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.TextBoxBase.Undo" />
      <MemberSignature Language="VB.NET" Value="Public Sub Undo ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Undo();" />
      <MemberSignature Language="F#" Value="member this.Undo : unit -&gt; unit" Usage="textBoxBase.Undo " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>撤消文本框中的上一个编辑操作。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果属性返回，则此方法将撤消在文本框控件中执行的最后一个 **剪贴板** 或文本更改操作 <xref:System.Windows.Forms.TextBoxBase.CanUndo%2A> `true` 。  
  
> [!NOTE]
>  <xref:System.Windows.Forms.TextBoxBase.Undo%2A>方法不能与 <xref:System.Windows.Forms.Control.KeyPress> 或事件一起使用 <xref:System.Windows.Forms.Control.TextChanged> 。  
  
   
  
## Examples  
 下面的代码示例使用 <xref:System.Windows.Forms.TextBox> 派生类。 它 <xref:System.Windows.Forms.MenuItem.Click> 为 <xref:System.Windows.Forms.MenuItem> 执行剪切、复制、粘贴和撤消操作的对象提供事件处理程序。 此示例需要 <xref:System.Windows.Forms.TextBox> 创建名为的 `textBox1` 控件。  
  
 [!code-cpp[Classic TextBoxBase.SelectionLength Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic TextBoxBase.SelectionLength Example/CPP/source.cpp#1)]
 [!code-csharp[Classic TextBoxBase.SelectionLength Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic TextBoxBase.SelectionLength Example/CS/source.cs#1)]
 [!code-vb[Classic TextBoxBase.SelectionLength Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic TextBoxBase.SelectionLength Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.TextBoxBase.Cut" />
        <altmember cref="M:System.Windows.Forms.TextBoxBase.Copy" />
        <altmember cref="M:System.Windows.Forms.TextBoxBase.Paste" />
        <altmember cref="P:System.Windows.Forms.TextBoxBase.CanUndo" />
        <altmember cref="M:System.Windows.Forms.TextBoxBase.Clear" />
      </Docs>
    </Member>
    <Member MemberName="WndProc">
      <MemberSignature Language="C#" Value="protected override void WndProc (ref System.Windows.Forms.Message m);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void WndProc(valuetype System.Windows.Forms.Message&amp; m) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.TextBoxBase.WndProc(System.Windows.Forms.Message@)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub WndProc (ByRef m As Message)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void WndProc(System::Windows::Forms::Message % m);" />
      <MemberSignature Language="F#" Value="override this.WndProc : Message -&gt; unit" Usage="textBoxBase.WndProc m" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="m" Type="System.Windows.Forms.Message" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="m">要处理的 Windows <see cref="T:System.Windows.Forms.Message" />。</param>
        <summary>处理 Windows 消息。</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Forms.Control.WndProc(System.Windows.Forms.Message@)" />
      </Docs>
    </Member>
    <Member MemberName="WordWrap">
      <MemberSignature Language="C#" Value="public bool WordWrap { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool WordWrap" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.TextBoxBase.WordWrap" />
      <MemberSignature Language="VB.NET" Value="Public Property WordWrap As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool WordWrap { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.WordWrap : bool with get, set" Usage="System.Windows.Forms.TextBoxBase.WordWrap" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.DefaultValue(true)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.DefaultValue(true)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.Localizable(true)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.Localizable(true)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指示多行文本框控件在必要时是否自动换行到下一行的开始。</summary>
        <value>如果多行文本框控件可换行，则为 <see langword="true" />；如果当用户键入的内容超过了控件的右边缘时，文本框控件自动水平滚动，则为 <see langword="false" />。 默认值为 <see langword="true" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果将此属性设置为 `true` ，则无论属性设置如何，都不会显示水平滚动条 <xref:System.Windows.Forms.TextBox.ScrollBars%2A> 。  
  
> [!NOTE]
>  在派生类中， <xref:System.Windows.Forms.TextBox> 如果属性设置为，则控件中的文本将始终换行，而与此属性的属性设置无关 <xref:System.Windows.Forms.TextBox.TextAlign%2A> `HorizontalAlignment.Left` 。  
  
   
  
## Examples  
 下面的代码示例使用 <xref:System.Windows.Forms.TextBox> 派生类创建 <xref:System.Windows.Forms.TextBox> 具有垂直滚动条的多行控件。 此示例还使用 <xref:System.Windows.Forms.TextBoxBase.AcceptsTab%2A> 、 <xref:System.Windows.Forms.TextBox.AcceptsReturn%2A> 和 <xref:System.Windows.Forms.TextBoxBase.WordWrap%2A> 属性使 "多行文本框" 控件对创建文本文档有用。  
  
 [!code-cpp[Classic TextBoxBase.AcceptsTab Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic TextBoxBase.AcceptsTab Example/CPP/source.cpp#1)]
 [!code-csharp[Classic TextBoxBase.AcceptsTab Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic TextBoxBase.AcceptsTab Example/CS/source.cs#1)]
 [!code-vb[Classic TextBoxBase.AcceptsTab Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic TextBoxBase.AcceptsTab Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
