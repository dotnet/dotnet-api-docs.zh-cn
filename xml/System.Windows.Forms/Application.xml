<Type Name="Application" FullName="System.Windows.Forms.Application">
  <Metadata><Meta Name="ms.openlocfilehash" Value="b54c8ccac9e86cf08f82662bab4f47dc2429f926" /><Meta Name="ms.sourcegitcommit" Value="9f423345753728e8cad38d4a22663a109e69ea91" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-CN" /><Meta Name="ms.lasthandoff" Value="03/04/2021" /><Meta Name="ms.locfileid" Value="102077781" /></Metadata><TypeSignature Language="C#" Value="public sealed class Application" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit Application extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Forms.Application" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class Application" />
  <TypeSignature Language="C++ CLI" Value="public ref class Application sealed" />
  <TypeSignature Language="F#" Value="type Application = class" />
  <AssemblyInfo>
    <AssemblyName>System.Windows.Forms</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>5.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary><span data-ttu-id="6c90a-101">提供 <see langword="static" /> 方法和属性以管理应用程序，例如启动和停止应用程序、处理 Windows 消息的方法和获取应用程序信息的属性。</span><span class="sxs-lookup"><span data-stu-id="6c90a-101">Provides <see langword="static" /> methods and properties to manage an application, such as methods to start and stop an application, to process Windows messages, and properties to get information about an application.</span></span> <span data-ttu-id="6c90a-102">此类不能被继承。</span><span class="sxs-lookup"><span data-stu-id="6c90a-102">This class cannot be inherited.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6c90a-103"><xref:System.Windows.Forms.Application>类具有启动和停止应用程序和线程以及处理 Windows 消息的方法，如下所示：</span><span class="sxs-lookup"><span data-stu-id="6c90a-103">The <xref:System.Windows.Forms.Application> class has methods to start and stop applications and threads, and to process Windows messages, as follows:</span></span>  
  
-   <span data-ttu-id="6c90a-104"><xref:System.Windows.Forms.Application.Run%2A> 在当前线程上启动应用程序消息循环，并根据需要使窗体可见。</span><span class="sxs-lookup"><span data-stu-id="6c90a-104"><xref:System.Windows.Forms.Application.Run%2A> starts an application message loop on the current thread and, optionally, makes a form visible.</span></span>  
  
-   <span data-ttu-id="6c90a-105"><xref:System.Windows.Forms.Application.Exit%2A> 或 <xref:System.Windows.Forms.Application.ExitThread%2A> 停止消息循环。</span><span class="sxs-lookup"><span data-stu-id="6c90a-105"><xref:System.Windows.Forms.Application.Exit%2A> or <xref:System.Windows.Forms.Application.ExitThread%2A> stops a message loop.</span></span>  
  
-   <span data-ttu-id="6c90a-106"><xref:System.Windows.Forms.Application.DoEvents%2A> 当程序处于循环中时处理消息。</span><span class="sxs-lookup"><span data-stu-id="6c90a-106"><xref:System.Windows.Forms.Application.DoEvents%2A> processes messages while your program is in a loop.</span></span>  
  
-   <span data-ttu-id="6c90a-107"><xref:System.Windows.Forms.Application.AddMessageFilter%2A> 将消息筛选器添加到应用程序消息泵以监视 Windows 消息。</span><span class="sxs-lookup"><span data-stu-id="6c90a-107"><xref:System.Windows.Forms.Application.AddMessageFilter%2A> adds a message filter to the application message pump to monitor Windows messages.</span></span>  
  
-   <span data-ttu-id="6c90a-108"><xref:System.Windows.Forms.IMessageFilter> 允许在调用事件处理程序之前停止引发事件或执行特殊操作。</span><span class="sxs-lookup"><span data-stu-id="6c90a-108"><xref:System.Windows.Forms.IMessageFilter> lets you stop an event from being raised or perform special operations before invoking an event handler.</span></span>  
  
 <span data-ttu-id="6c90a-109">此类具有 <xref:System.Windows.Forms.Application.CurrentCulture%2A> 和 <xref:System.Windows.Forms.Application.CurrentInputLanguage%2A> 属性，可获取或设置当前线程的区域性信息。</span><span class="sxs-lookup"><span data-stu-id="6c90a-109">This class has <xref:System.Windows.Forms.Application.CurrentCulture%2A> and <xref:System.Windows.Forms.Application.CurrentInputLanguage%2A> properties to get or set culture information for the current thread.</span></span>  
  
 <span data-ttu-id="6c90a-110">不能创建此类的实例。</span><span class="sxs-lookup"><span data-stu-id="6c90a-110">You cannot create an instance of this class.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="6c90a-111">下面的代码示例在窗体上的列表框中列出了数字。</span><span class="sxs-lookup"><span data-stu-id="6c90a-111">The following code example lists numbers in a list box on a form.</span></span> <span data-ttu-id="6c90a-112">每次单击时 `button1` ，应用程序都会向列表中添加一个编号。</span><span class="sxs-lookup"><span data-stu-id="6c90a-112">Each time you click `button1`, the application adds another number to the list.</span></span>  
  
 <span data-ttu-id="6c90a-113">`Main`方法调用 <xref:System.Windows.Forms.Application.Run%2A> 以启动应用程序，该应用程序将创建窗体 `listBox1` 和 `button1` 。</span><span class="sxs-lookup"><span data-stu-id="6c90a-113">The `Main` method calls <xref:System.Windows.Forms.Application.Run%2A> to start the application, which creates the form, `listBox1` and `button1`.</span></span> <span data-ttu-id="6c90a-114">用户单击时 `button1` ，方法会 `button1_Click` 显示 <xref:System.Windows.Forms.MessageBox> 。</span><span class="sxs-lookup"><span data-stu-id="6c90a-114">When the user clicks `button1`, the `button1_Click` method displays a <xref:System.Windows.Forms.MessageBox>.</span></span> <span data-ttu-id="6c90a-115">如果用户单击 `No` <xref:System.Windows.Forms.MessageBox> ，则该 `button1_Click` 方法将向列表中添加一个数字。</span><span class="sxs-lookup"><span data-stu-id="6c90a-115">If the user clicks `No` on the <xref:System.Windows.Forms.MessageBox>, the `button1_Click` method adds a number to the list.</span></span> <span data-ttu-id="6c90a-116">如果用户单击 `Yes` ，应用程序将调用 <xref:System.Windows.Forms.Application.Exit%2A> 来处理队列中的所有剩余消息，然后退出。</span><span class="sxs-lookup"><span data-stu-id="6c90a-116">If the user clicks `Yes`, the application calls <xref:System.Windows.Forms.Application.Exit%2A> to process all remaining messages in the queue and then to quit.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="6c90a-117"><xref:System.Windows.Forms.Application.Exit%2A>在部分信任环境中对的调用将失败。</span><span class="sxs-lookup"><span data-stu-id="6c90a-117">The call to <xref:System.Windows.Forms.Application.Exit%2A> will fail in partial trust.</span></span>  
  
 [!code-cpp[Classic Application Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application Example/CS/source.cs#1)]
 [!code-vb[Classic Application Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="AddMessageFilter">
      <MemberSignature Language="C#" Value="public static void AddMessageFilter (System.Windows.Forms.IMessageFilter value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddMessageFilter(class System.Windows.Forms.IMessageFilter value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.AddMessageFilter(System.Windows.Forms.IMessageFilter)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub AddMessageFilter (value As IMessageFilter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AddMessageFilter(System::Windows::Forms::IMessageFilter ^ value);" />
      <MemberSignature Language="F#" Value="static member AddMessageFilter : System.Windows.Forms.IMessageFilter -&gt; unit" Usage="System.Windows.Forms.Application.AddMessageFilter value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Windows.Forms.IMessageFilter" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="6c90a-118">要安装的 <see cref="T:System.Windows.Forms.IMessageFilter" /> 接口的实现。</span><span class="sxs-lookup"><span data-stu-id="6c90a-118">The implementation of the <see cref="T:System.Windows.Forms.IMessageFilter" /> interface you want to install.</span></span></param>
        <summary><span data-ttu-id="6c90a-119">添加消息筛选器以便在向目标传送 Windows 消息时监视这些消息。</span><span class="sxs-lookup"><span data-stu-id="6c90a-119">Adds a message filter to monitor Windows messages as they are routed to their destinations.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6c90a-120">使用消息筛选器可防止引发特定事件，或在将事件传递给事件处理程序之前对其执行特殊操作。</span><span class="sxs-lookup"><span data-stu-id="6c90a-120">Use a message filter to prevent specific events from being raised or to perform special operations for an event before it is passed to an event handler.</span></span> <span data-ttu-id="6c90a-121">消息筛选器对于特定线程是唯一的。</span><span class="sxs-lookup"><span data-stu-id="6c90a-121">Message filters are unique to a specific thread.</span></span>  
  
 <span data-ttu-id="6c90a-122">若要防止消息被调度， `value` 传递给此方法的参数实例必须 <xref:System.Windows.Forms.IMessageFilter.PreFilterMessage%2A> 用代码来重写该方法以处理消息。</span><span class="sxs-lookup"><span data-stu-id="6c90a-122">To prevent a message from being dispatched, the `value` parameter instance that you pass to this method must override the <xref:System.Windows.Forms.IMessageFilter.PreFilterMessage%2A> method with the code to handle the message.</span></span> <span data-ttu-id="6c90a-123">该方法必须返回 `false`。</span><span class="sxs-lookup"><span data-stu-id="6c90a-123">The method must return `false`.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="6c90a-124">将消息筛选器添加到应用程序的消息泵会降低性能。</span><span class="sxs-lookup"><span data-stu-id="6c90a-124">Adding message filters to the message pump for an application can degrade performance.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="6c90a-125">下面的代码示例创建一个名为的消息筛选器 `TestMessageFilter` 。</span><span class="sxs-lookup"><span data-stu-id="6c90a-125">The following code example creates a message filter called `TestMessageFilter`.</span></span> <span data-ttu-id="6c90a-126">此筛选器阻止与鼠标左键相关的所有消息。</span><span class="sxs-lookup"><span data-stu-id="6c90a-126">This filter blocks all messages relating to the left mouse button.</span></span> <span data-ttu-id="6c90a-127">使用消息筛选器之前，必须提供接口的实现 <xref:System.Windows.Forms.IMessageFilter> 。</span><span class="sxs-lookup"><span data-stu-id="6c90a-127">Before you can use a message filter, you must provide an implementation for the <xref:System.Windows.Forms.IMessageFilter> interface.</span></span>  
  
 [!code-cpp[Classic Application.RemoveMessageFilter Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.RemoveMessageFilter Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.RemoveMessageFilter Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.RemoveMessageFilter Example/CS/source.cs#1)]
 [!code-vb[Classic Application.RemoveMessageFilter Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.RemoveMessageFilter Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AllowQuit">
      <MemberSignature Language="C#" Value="public static bool AllowQuit { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool AllowQuit" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.AllowQuit" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property AllowQuit As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool AllowQuit { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.AllowQuit : bool" Usage="System.Windows.Forms.Application.AllowQuit" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="6c90a-128">获取指示调用方能否退出该应用程序的值。</span><span class="sxs-lookup"><span data-stu-id="6c90a-128">Gets a value indicating whether the caller can quit this application.</span></span></summary>
        <value><span data-ttu-id="6c90a-129">如果调用方能够退出该应用程序，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="6c90a-129"><see langword="true" /> if the caller can quit this application; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6c90a-130">`false`如果从 <xref:System.Windows.Forms.Control> Web 浏览器中承载的调用，则此属性返回。</span><span class="sxs-lookup"><span data-stu-id="6c90a-130">This property returns `false` if it is called from a <xref:System.Windows.Forms.Control> being hosted within a Web browser.</span></span> <span data-ttu-id="6c90a-131">因此， <xref:System.Windows.Forms.Control> 不能退出 <xref:System.Windows.Forms.Application> 。</span><span class="sxs-lookup"><span data-stu-id="6c90a-131">Thus, the <xref:System.Windows.Forms.Control> cannot quit the <xref:System.Windows.Forms.Application>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ApplicationExit">
      <MemberSignature Language="C#" Value="public static event EventHandler ApplicationExit;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler ApplicationExit" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Application.ApplicationExit" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event ApplicationExit As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler ^ ApplicationExit;" />
      <MemberSignature Language="F#" Value="member this.ApplicationExit : EventHandler " Usage="member this.ApplicationExit : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="6c90a-132">在应用程序即将关闭时发生。</span><span class="sxs-lookup"><span data-stu-id="6c90a-132">Occurs when the application is about to shut down.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6c90a-133">必须将事件处理程序附加到 `ApplicationExit` 事件，才能在应用程序停止运行之前执行未处理的所需任务。</span><span class="sxs-lookup"><span data-stu-id="6c90a-133">You must attach the event handlers to the `ApplicationExit` event to perform unhandled, required tasks before the application stops running.</span></span> <span data-ttu-id="6c90a-134">可以关闭此应用程序打开的文件，也可以释放垃圾回收未回收的对象。</span><span class="sxs-lookup"><span data-stu-id="6c90a-134">You can close files opened by this application, or dispose of objects that garbage collection did not reclaim.</span></span>  
  
 <span data-ttu-id="6c90a-135">由于这是一个静态事件，因此必须将任何附加到此事件的事件处理程序分离到 `ApplicationExit` 事件处理程序中。</span><span class="sxs-lookup"><span data-stu-id="6c90a-135">Because this is a static event, you must detach any event handlers attached to this event in the `ApplicationExit` event handler itself.</span></span> <span data-ttu-id="6c90a-136">如果不分离这些处理程序，它们将保持附加到事件，并继续消耗内存。</span><span class="sxs-lookup"><span data-stu-id="6c90a-136">If you do not detach these handlers, they will remain attached to the event and continue to consume memory.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="6c90a-137">下面的代码示例显示两个窗体并在两个窗体关闭时退出应用程序。</span><span class="sxs-lookup"><span data-stu-id="6c90a-137">The following code example displays two forms and exits the application when both forms are closed.</span></span> <span data-ttu-id="6c90a-138">当应用程序启动和退出时，将记住每个窗体的位置。</span><span class="sxs-lookup"><span data-stu-id="6c90a-138">When the application starts and exits, the position of each form is remembered.</span></span> <span data-ttu-id="6c90a-139">此示例演示如何使用 `ApplicationExit` 事件来了解何时应将窗体位置保存到文件中，以及何时应关闭窗体位置 `FileStream` 。</span><span class="sxs-lookup"><span data-stu-id="6c90a-139">This example demonstrates using the `ApplicationExit` event to know when the form positions should be persisted to the file, and when the `FileStream` should be closed.</span></span>  
  
 <span data-ttu-id="6c90a-140">类 `MyApplicationContext` 从继承， <xref:System.Windows.Forms.ApplicationContext> 并在每个窗体关闭时保持跟踪，并在两个窗体关闭时进行跟踪，并在两个窗体都关闭时</span><span class="sxs-lookup"><span data-stu-id="6c90a-140">The class `MyApplicationContext` inherits from <xref:System.Windows.Forms.ApplicationContext> and keeps track of when each form is closed, and exits the current thread when they both are.</span></span> <span data-ttu-id="6c90a-141">类在每个窗体关闭时记住其位置。</span><span class="sxs-lookup"><span data-stu-id="6c90a-141">The class remembers the position of each form when it is closed.</span></span> <span data-ttu-id="6c90a-142">`ApplicationExit`事件发生时，类会将用户的每个的位置写入文件。</span><span class="sxs-lookup"><span data-stu-id="6c90a-142">When the `ApplicationExit` event occurs, the class writes the positions of each for the user to the file.</span></span> <span data-ttu-id="6c90a-143">窗体位置数据存储在名为的文件中 `appdata.txt` ，该文件在由确定的位置创建 <xref:System.Windows.Forms.Application.UserAppDataPath%2A> 。</span><span class="sxs-lookup"><span data-stu-id="6c90a-143">The form position data is stored in a file titled `appdata.txt` that is created in the location determined by <xref:System.Windows.Forms.Application.UserAppDataPath%2A>.</span></span> <span data-ttu-id="6c90a-144">`Main`方法调用 `Application.Run(context)` 来启动给定的应用程序 <xref:System.Windows.Forms.ApplicationContext> 。</span><span class="sxs-lookup"><span data-stu-id="6c90a-144">The `Main` method calls `Application.Run(context)` to start the application given the <xref:System.Windows.Forms.ApplicationContext>.</span></span>  
  
 <span data-ttu-id="6c90a-145">此代码摘自类概述中所示的示例 <xref:System.Windows.Forms.ApplicationContext> 。</span><span class="sxs-lookup"><span data-stu-id="6c90a-145">This code is an excerpt from the example shown in the <xref:System.Windows.Forms.ApplicationContext> class overview.</span></span> <span data-ttu-id="6c90a-146"><xref:System.Windows.Forms.ApplicationContext>有关完整的代码清单，请参阅。</span><span class="sxs-lookup"><span data-stu-id="6c90a-146">See <xref:System.Windows.Forms.ApplicationContext> for the whole code listing.</span></span>  
  
 [!code-cpp[Application#5](~/samples/snippets/cpp/VS_Snippets_Winforms/Application/CPP/source.cpp#5)]
 [!code-csharp[Application#5](~/samples/snippets/csharp/VS_Snippets_Winforms/Application/CS/source.cs#5)]
 [!code-vb[Application#5](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Application/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Application.Exit" />
      </Docs>
    </Member>
    <Member MemberName="CommonAppDataPath">
      <MemberSignature Language="C#" Value="public static string CommonAppDataPath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string CommonAppDataPath" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.CommonAppDataPath" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CommonAppDataPath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ CommonAppDataPath { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CommonAppDataPath : string" Usage="System.Windows.Forms.Application.CommonAppDataPath" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="6c90a-147">获取所有用户共享的应用程序数据的路径。</span><span class="sxs-lookup"><span data-stu-id="6c90a-147">Gets the path for the application data that is shared among all users.</span></span></summary>
        <value><span data-ttu-id="6c90a-148">所有用户共享的应用程序数据的路径。</span><span class="sxs-lookup"><span data-stu-id="6c90a-148">The path for the application data that is shared among all users.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6c90a-149">如果路径不存在，则将使用以下格式创建一个路径：</span><span class="sxs-lookup"><span data-stu-id="6c90a-149">If a path does not exist, one is created in the following format:</span></span>  
  
 <span data-ttu-id="6c90a-150">*基路径*\\<xref:System.Windows.Forms.Application.CompanyName%2A>\\<xref:System.Windows.Forms.Application.ProductName%2A>\\<xref:System.Windows.Forms.Application.ProductVersion%2A></span><span class="sxs-lookup"><span data-stu-id="6c90a-150">*Base Path*\\<xref:System.Windows.Forms.Application.CompanyName%2A>\\<xref:System.Windows.Forms.Application.ProductName%2A>\\<xref:System.Windows.Forms.Application.ProductVersion%2A></span></span>  
  
 <span data-ttu-id="6c90a-151"><xref:System.Windows.Forms.Application.ProductVersion%2A> 首先查看包含主可执行文件的程序集是否具有 `AssemblyInformationalVersion` 其属性。</span><span class="sxs-lookup"><span data-stu-id="6c90a-151"><xref:System.Windows.Forms.Application.ProductVersion%2A> first looks to see if the assembly containing the main executable has the `AssemblyInformationalVersion` attribute on it.</span></span> <span data-ttu-id="6c90a-152">如果该属性存在，则用于 <xref:System.Windows.Forms.Application.ProductVersion%2A> 和 <xref:System.Windows.Forms.Application.CommonAppDataPath%2A> 。</span><span class="sxs-lookup"><span data-stu-id="6c90a-152">If this attribute exists, it is used for both <xref:System.Windows.Forms.Application.ProductVersion%2A> and <xref:System.Windows.Forms.Application.CommonAppDataPath%2A>.</span></span> <span data-ttu-id="6c90a-153">如果此属性不存在，则这两个属性将改用可执行文件的版本。</span><span class="sxs-lookup"><span data-stu-id="6c90a-153">If this attribute does not exist, both properties use the version of the executable file instead.</span></span>  
  
 <span data-ttu-id="6c90a-154">该路径将有所不同，具体取决于是否使用 ClickOnce 部署 Windows 窗体应用程序。</span><span class="sxs-lookup"><span data-stu-id="6c90a-154">The path will be different depending on whether the Windows Forms application is deployed using ClickOnce.</span></span> <span data-ttu-id="6c90a-155">ClickOnce 应用程序存储在每个用户的应用程序缓存中的 C:\documents and 和设置 \\ *用户名* 目录中。</span><span class="sxs-lookup"><span data-stu-id="6c90a-155">ClickOnce applications are stored in a per-user application cache in the C:\Documents and Settings\\*username* directory.</span></span> <span data-ttu-id="6c90a-156">有关详细信息，请参阅 [在 ClickOnce 应用程序中访问本地数据和远程数据](/visualstudio/deployment/accessing-local-and-remote-data-in-clickonce-applications)。</span><span class="sxs-lookup"><span data-stu-id="6c90a-156">For more information, see [Accessing Local and Remote Data in ClickOnce Applications](/visualstudio/deployment/accessing-local-and-remote-data-in-clickonce-applications).</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Application.CommonAppDataRegistry" />
      </Docs>
    </Member>
    <Member MemberName="CommonAppDataRegistry">
      <MemberSignature Language="C#" Value="public static Microsoft.Win32.RegistryKey CommonAppDataRegistry { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class Microsoft.Win32.RegistryKey CommonAppDataRegistry" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.CommonAppDataRegistry" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CommonAppDataRegistry As RegistryKey" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property Microsoft::Win32::RegistryKey ^ CommonAppDataRegistry { Microsoft::Win32::RegistryKey ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CommonAppDataRegistry : Microsoft.Win32.RegistryKey" Usage="System.Windows.Forms.Application.CommonAppDataRegistry" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="6c90a-157">获取所有用户共享的应用程序数据的注册表项。</span><span class="sxs-lookup"><span data-stu-id="6c90a-157">Gets the registry key for the application data that is shared among all users.</span></span></summary>
        <value><span data-ttu-id="6c90a-158">一个 <see cref="T:Microsoft.Win32.RegistryKey" />，它表示所有用户共享的应用程序数据的注册表项。</span><span class="sxs-lookup"><span data-stu-id="6c90a-158">A <see cref="T:Microsoft.Win32.RegistryKey" /> representing the registry key of the application data that is shared among all users.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6c90a-159">如果该键不存在，则将采用以下格式创建它：</span><span class="sxs-lookup"><span data-stu-id="6c90a-159">If the key does not exist, it is created in the following format:</span></span>  
  
 <span data-ttu-id="6c90a-160">LocalMachine\Software\\<xref:System.Windows.Forms.Application.CompanyName%2A>\\<xref:System.Windows.Forms.Application.ProductName%2A>\\<xref:System.Windows.Forms.Application.ProductVersion%2A></span><span class="sxs-lookup"><span data-stu-id="6c90a-160">LocalMachine\Software\\<xref:System.Windows.Forms.Application.CompanyName%2A>\\<xref:System.Windows.Forms.Application.ProductName%2A>\\<xref:System.Windows.Forms.Application.ProductVersion%2A></span></span>
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CompanyName">
      <MemberSignature Language="C#" Value="public static string CompanyName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string CompanyName" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.CompanyName" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CompanyName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ CompanyName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CompanyName : string" Usage="System.Windows.Forms.Application.CompanyName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="6c90a-161">获取与该应用程序关联的公司名称。</span><span class="sxs-lookup"><span data-stu-id="6c90a-161">Gets the company name associated with the application.</span></span></summary>
        <value><span data-ttu-id="6c90a-162">公司名称。</span><span class="sxs-lookup"><span data-stu-id="6c90a-162">The company name.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="6c90a-163">下面的代码示例获取此属性，并在文本框中显示其值。</span><span class="sxs-lookup"><span data-stu-id="6c90a-163">The following code example gets this property and displays its value in a text box.</span></span> <span data-ttu-id="6c90a-164">该示例要求已 `textBox1` 置于窗体上。</span><span class="sxs-lookup"><span data-stu-id="6c90a-164">The example requires that `textBox1` has been placed on a form.</span></span>  
  
 [!code-cpp[Classic Application.CompanyName Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.CompanyName Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.CompanyName Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.CompanyName Example/CS/source.cs#1)]
 [!code-vb[Classic Application.CompanyName Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.CompanyName Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Application.ProductName" />
        <altmember cref="P:System.Windows.Forms.Application.ProductVersion" />
        <altmember cref="T:System.Reflection.AssemblyCompanyAttribute" />
      </Docs>
    </Member>
    <Member MemberName="CurrentCulture">
      <MemberSignature Language="C#" Value="public static System.Globalization.CultureInfo CurrentCulture { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Globalization.CultureInfo CurrentCulture" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.CurrentCulture" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property CurrentCulture As CultureInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Globalization::CultureInfo ^ CurrentCulture { System::Globalization::CultureInfo ^ get(); void set(System::Globalization::CultureInfo ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CurrentCulture : System.Globalization.CultureInfo with get, set" Usage="System.Windows.Forms.Application.CurrentCulture" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Globalization.CultureInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="6c90a-165">获取或设置当前线程的区域性信息。</span><span class="sxs-lookup"><span data-stu-id="6c90a-165">Gets or sets the culture information for the current thread.</span></span></summary>
        <value><span data-ttu-id="6c90a-166">一个 <see cref="T:System.Globalization.CultureInfo" />，它代表当前线程的区域性信息。</span><span class="sxs-lookup"><span data-stu-id="6c90a-166">A <see cref="T:System.Globalization.CultureInfo" /> representing the culture information for the current thread.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="6c90a-167">下面的代码示例获取此属性，并在文本框中显示其值。</span><span class="sxs-lookup"><span data-stu-id="6c90a-167">The following code example gets this property and displays its value in a text box.</span></span> <span data-ttu-id="6c90a-168">该示例要求已 `textBox1` 置于窗体上。</span><span class="sxs-lookup"><span data-stu-id="6c90a-168">The example requires that `textBox1` has been placed on a form.</span></span>  
  
 [!code-cpp[Classic Application.CurrentCulture Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.CurrentCulture Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.CurrentCulture Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.CurrentCulture Example/CS/source.cs#1)]
 [!code-vb[Classic Application.CurrentCulture Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.CurrentCulture Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.InputLanguage" />
      </Docs>
    </Member>
    <Member MemberName="CurrentInputLanguage">
      <MemberSignature Language="C#" Value="public static System.Windows.Forms.InputLanguage CurrentInputLanguage { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Forms.InputLanguage CurrentInputLanguage" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.CurrentInputLanguage" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property CurrentInputLanguage As InputLanguage" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Forms::InputLanguage ^ CurrentInputLanguage { System::Windows::Forms::InputLanguage ^ get(); void set(System::Windows::Forms::InputLanguage ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CurrentInputLanguage : System.Windows.Forms.InputLanguage with get, set" Usage="System.Windows.Forms.Application.CurrentInputLanguage" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.InputLanguage</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="6c90a-169">获取或设置当前线程的当前输入语言。</span><span class="sxs-lookup"><span data-stu-id="6c90a-169">Gets or sets the current input language for the current thread.</span></span></summary>
        <value><span data-ttu-id="6c90a-170">一个 <see cref="T:System.Windows.Forms.InputLanguage" />，它代表当前线程的当前输入语言。</span><span class="sxs-lookup"><span data-stu-id="6c90a-170">An <see cref="T:System.Windows.Forms.InputLanguage" /> representing the current input language for the current thread.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="6c90a-171">下面的代码示例获取此属性，并在文本框中显示其值。</span><span class="sxs-lookup"><span data-stu-id="6c90a-171">The following code example gets this property and displays its value in a text box.</span></span> <span data-ttu-id="6c90a-172">该示例要求已 `textBox1` 置于窗体上。</span><span class="sxs-lookup"><span data-stu-id="6c90a-172">The example requires that `textBox1` has been placed on a form.</span></span>  
  
 [!code-cpp[Classic Application.CurrentInputLanguage Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.CurrentInputLanguage Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.CurrentInputLanguage Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.CurrentInputLanguage Example/CS/source.cs#1)]
 [!code-vb[Classic Application.CurrentInputLanguage Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.CurrentInputLanguage Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="T:System.Windows.Forms.InputLanguage" />
      </Docs>
    </Member>
    <Member MemberName="DoEvents">
      <MemberSignature Language="C#" Value="public static void DoEvents ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void DoEvents() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.DoEvents" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub DoEvents ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void DoEvents();" />
      <MemberSignature Language="F#" Value="static member DoEvents : unit -&gt; unit" Usage="System.Windows.Forms.Application.DoEvents " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="6c90a-173">处理当前在消息队列中的所有 Windows 消息。</span><span class="sxs-lookup"><span data-stu-id="6c90a-173">Processes all Windows messages currently in the message queue.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6c90a-174">运行 Windows 窗体时，它将创建新的窗体，然后将等待事件处理。</span><span class="sxs-lookup"><span data-stu-id="6c90a-174">When you run a Windows Form, it creates the new form, which then waits for events to handle.</span></span> <span data-ttu-id="6c90a-175">每次窗体处理一个事件时，它都会处理与该事件关联的所有代码。</span><span class="sxs-lookup"><span data-stu-id="6c90a-175">Each time the form handles an event, it processes all the code associated with that event.</span></span> <span data-ttu-id="6c90a-176">所有其他事件都在队列中等待。</span><span class="sxs-lookup"><span data-stu-id="6c90a-176">All other events wait in the queue.</span></span> <span data-ttu-id="6c90a-177">当代码处理事件时，应用程序不会响应。</span><span class="sxs-lookup"><span data-stu-id="6c90a-177">While your code handles the event, your application does not respond.</span></span> <span data-ttu-id="6c90a-178">例如，如果将另一窗口拖到顶部，则窗口不会重新绘制。</span><span class="sxs-lookup"><span data-stu-id="6c90a-178">For example, the window does not repaint if another window is dragged on top.</span></span>  
  
 <span data-ttu-id="6c90a-179">如果 <xref:System.Windows.Forms.Application.DoEvents%2A> 在代码中调用，则应用程序可以处理其他事件。</span><span class="sxs-lookup"><span data-stu-id="6c90a-179">If you call <xref:System.Windows.Forms.Application.DoEvents%2A> in your code, your application can handle the other events.</span></span> <span data-ttu-id="6c90a-180">例如，如果你有一个将数据添加到 <xref:System.Windows.Forms.ListBox> 并添加到你的代码中的窗体，则在将 <xref:System.Windows.Forms.Application.DoEvents%2A> 另一窗口拖到窗体上时，窗体将重新绘制。</span><span class="sxs-lookup"><span data-stu-id="6c90a-180">For example, if you have a form that adds data to a <xref:System.Windows.Forms.ListBox> and add <xref:System.Windows.Forms.Application.DoEvents%2A> to your code, your form repaints when another window is dragged over it.</span></span> <span data-ttu-id="6c90a-181">如果 <xref:System.Windows.Forms.Application.DoEvents%2A> 从代码中删除，则窗体将不会重新绘制，直到按钮的 click 事件处理程序执行完毕。</span><span class="sxs-lookup"><span data-stu-id="6c90a-181">If you remove <xref:System.Windows.Forms.Application.DoEvents%2A> from your code, your form will not repaint until the click event handler of the button is finished executing.</span></span> <span data-ttu-id="6c90a-182">有关消息传递的详细信息，请参阅 [中的用户输入 Windows 窗体](/dotnet/framework/winforms/user-input-in-windows-forms)。</span><span class="sxs-lookup"><span data-stu-id="6c90a-182">For more information on messaging, see [User Input in Windows Forms](/dotnet/framework/winforms/user-input-in-windows-forms).</span></span>  
  
 <span data-ttu-id="6c90a-183">与 Visual Basic 6.0 不同， <xref:System.Windows.Forms.Application.DoEvents%2A> 方法不会调用 <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> 方法。</span><span class="sxs-lookup"><span data-stu-id="6c90a-183">Unlike Visual Basic 6.0, the <xref:System.Windows.Forms.Application.DoEvents%2A> method does not call the <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="6c90a-184">通常，在循环中使用此方法来处理消息。</span><span class="sxs-lookup"><span data-stu-id="6c90a-184">Typically, you use this method in a loop to process messages.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="6c90a-185">调用此方法将导致在处理所有等待窗口消息时暂停当前线程。</span><span class="sxs-lookup"><span data-stu-id="6c90a-185">Calling this method causes the current thread to be suspended while all waiting window messages are processed.</span></span> <span data-ttu-id="6c90a-186">如果消息导致触发事件，则可能会执行应用程序代码的其他区域。</span><span class="sxs-lookup"><span data-stu-id="6c90a-186">If a message causes an event to be triggered, then other areas of your application code may execute.</span></span> <span data-ttu-id="6c90a-187">这可能导致应用程序出现难以调试的意外行为。</span><span class="sxs-lookup"><span data-stu-id="6c90a-187">This can cause your application to exhibit unexpected behaviors that are difficult to debug.</span></span> <span data-ttu-id="6c90a-188">如果执行的操作或计算需要较长时间，则通常更愿意在新线程上执行这些操作。</span><span class="sxs-lookup"><span data-stu-id="6c90a-188">If you perform operations or computations that take a long time, it is often preferable to perform those operations on a new thread.</span></span> <span data-ttu-id="6c90a-189">有关异步编程的详细信息，请参阅 [ (APM) 的异步编程模型 ](/dotnet/standard/asynchronous-programming-patterns/asynchronous-programming-model-apm)。</span><span class="sxs-lookup"><span data-stu-id="6c90a-189">For more information about asynchronous programming, see [Asynchronous Programming Model (APM)](/dotnet/standard/asynchronous-programming-patterns/asynchronous-programming-model-apm).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="6c90a-190">下面的代码示例演示如何使用 <xref:System.Windows.Forms.Application.DoEvents%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="6c90a-190">The following code example demonstrates using the <xref:System.Windows.Forms.Application.DoEvents%2A> method.</span></span> <span data-ttu-id="6c90a-191">当示例运行时，用户可以从中选择图形文件 <xref:System.Windows.Forms.OpenFileDialog> 。</span><span class="sxs-lookup"><span data-stu-id="6c90a-191">When the example runs, a user can select graphics files from an <xref:System.Windows.Forms.OpenFileDialog>.</span></span> <span data-ttu-id="6c90a-192">选择的文件将显示在窗体中。</span><span class="sxs-lookup"><span data-stu-id="6c90a-192">The selected files are displayed in the form.</span></span> <span data-ttu-id="6c90a-193"><xref:System.Windows.Forms.Application.DoEvents%2A>方法为打开的每个图形文件强制重绘窗体。</span><span class="sxs-lookup"><span data-stu-id="6c90a-193">The <xref:System.Windows.Forms.Application.DoEvents%2A> method forces a repaint of the form for each graphics file opened.</span></span> <span data-ttu-id="6c90a-194">若要运行此示例，请将以下代码粘贴到包含名为的、 <xref:System.Windows.Forms.PictureBox> `PictureBox1` 名为的和名为 <xref:System.Windows.Forms.OpenFileDialog> `OpenFileDialog1` 的按钮的窗体中 `fileButton` 。</span><span class="sxs-lookup"><span data-stu-id="6c90a-194">To run this example, paste the following code in a form containing a <xref:System.Windows.Forms.PictureBox> named `PictureBox1`, an <xref:System.Windows.Forms.OpenFileDialog> named `OpenFileDialog1`, and a button named `fileButton`.</span></span> <span data-ttu-id="6c90a-195">`InitializePictureBox` `InitializeOpenFileDialog` 从窗体的构造函数或方法调用和方法 `Load` 。</span><span class="sxs-lookup"><span data-stu-id="6c90a-195">Call the `InitializePictureBox` and `InitializeOpenFileDialog` methods from the form's constructor or `Load` method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="6c90a-196">在 Visual Studio 中，如果您 <xref:System.Windows.Forms.OpenFileDialog> 通过使用拖动操作将添加到您的窗体中，则您必须 `InitializeOpenFileDialog` 通过删除创建的新实例的行来修改以下方法 <xref:System.Windows.Forms.OpenFileDialog> 。</span><span class="sxs-lookup"><span data-stu-id="6c90a-196">In Visual Studio, if you add an <xref:System.Windows.Forms.OpenFileDialog> to your form by using a drag operation, you will have to modify the following `InitializeOpenFileDialog` method by removing the line that creates a new instance of <xref:System.Windows.Forms.OpenFileDialog>.</span></span>  
  
 <span data-ttu-id="6c90a-197">该示例还要求将 <xref:System.Windows.Forms.Control.Click?displayProperty=nameWithType> 控件的事件和的事件 <xref:System.Windows.Forms.Button> <xref:System.Windows.Forms.FileDialog.FileOk> <xref:System.Windows.Forms.OpenFileDialog> 连接到示例中定义的事件处理程序。</span><span class="sxs-lookup"><span data-stu-id="6c90a-197">The example also requires that the <xref:System.Windows.Forms.Control.Click?displayProperty=nameWithType> event of the <xref:System.Windows.Forms.Button> control and the <xref:System.Windows.Forms.FileDialog.FileOk> event of the <xref:System.Windows.Forms.OpenFileDialog> are connected to the event handlers defined in the example.</span></span> <span data-ttu-id="6c90a-198">当示例运行时，单击按钮即可显示该对话框。</span><span class="sxs-lookup"><span data-stu-id="6c90a-198">When the example is running, display the dialog box by clicking the button.</span></span>  
  
 [!code-cpp[System.Windows.Forms.FileDialog#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.FileDialog/CPP/filedialogform.cpp#1)]
 [!code-csharp[System.Windows.Forms.FileDialog#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.FileDialog/CS/filedialogform.cs#1)]
 [!code-vb[System.Windows.Forms.FileDialog#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.FileDialog/VB/filedialogform.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Application.Exit" />
        <altmember cref="M:System.Windows.Forms.Application.ExitThread" />
        <altmember cref="M:System.Windows.Forms.Application.Run" />
      </Docs>
    </Member>
    <Member MemberName="EnableVisualStyles">
      <MemberSignature Language="C#" Value="public static void EnableVisualStyles ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void EnableVisualStyles() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.EnableVisualStyles" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub EnableVisualStyles ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void EnableVisualStyles();" />
      <MemberSignature Language="F#" Value="static member EnableVisualStyles : unit -&gt; unit" Usage="System.Windows.Forms.Application.EnableVisualStyles " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="6c90a-199">启用应用程序的可视样式。</span><span class="sxs-lookup"><span data-stu-id="6c90a-199">Enables visual styles for the application.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6c90a-200">此方法为应用程序启用视觉样式。</span><span class="sxs-lookup"><span data-stu-id="6c90a-200">This method enables visual styles for the application.</span></span> <span data-ttu-id="6c90a-201">视觉样式是指构成操作系统主题的颜色、字体和其他视觉对象。</span><span class="sxs-lookup"><span data-stu-id="6c90a-201">Visual styles are the colors, fonts, and other visual elements that form an operating system theme.</span></span> <span data-ttu-id="6c90a-202">如果控件和操作系统支持视觉样式，控件将用视觉样式绘制。</span><span class="sxs-lookup"><span data-stu-id="6c90a-202">Controls will draw with visual styles if the control and the operating system support it.</span></span> <span data-ttu-id="6c90a-203">若要产生效果， <xref:System.Windows.Forms.Application.EnableVisualStyles> 必须先调用，然后才能在应用程序中创建任何控件; 通常， <xref:System.Windows.Forms.Application.EnableVisualStyles> 是函数中的第一行 `Main` 。</span><span class="sxs-lookup"><span data-stu-id="6c90a-203">To have an effect, <xref:System.Windows.Forms.Application.EnableVisualStyles> must be called before creating any controls in the application; typically, <xref:System.Windows.Forms.Application.EnableVisualStyles> is the first line in the `Main` function.</span></span> <span data-ttu-id="6c90a-204">调用时，不需要单独的清单即可启用视觉样式 <xref:System.Windows.Forms.Application.EnableVisualStyles> 。</span><span class="sxs-lookup"><span data-stu-id="6c90a-204">A separate manifest is not required to enable visual styles when calling <xref:System.Windows.Forms.Application.EnableVisualStyles>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="6c90a-205">在 .NET Framework 2.0 之前， `FlatStyle` 某些控件（如派生自的控件）的属性必须 <xref:System.Windows.Forms.ButtonBase> 设置为，以便 <xref:System.Windows.Forms.FlatStyle.System?displayProperty=nameWithType> 用视觉样式绘制控件。</span><span class="sxs-lookup"><span data-stu-id="6c90a-205">Prior to the .NET Framework 2.0, the `FlatStyle` property of some controls, such as controls that derive from <xref:System.Windows.Forms.ButtonBase>, had to be set to <xref:System.Windows.Forms.FlatStyle.System?displayProperty=nameWithType> in order for the controls to be drawn with visual styles.</span></span> <span data-ttu-id="6c90a-206">在用 .NET Framework 2.0 编写的应用程序中，不再需要此项。</span><span class="sxs-lookup"><span data-stu-id="6c90a-206">In applications written with the .NET Framework 2.0, this is no longer necessary.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="6c90a-207">此方法对 Internet Explorer 中承载的控件不起作用。</span><span class="sxs-lookup"><span data-stu-id="6c90a-207">This method will have no effect for controls hosted in Internet Explorer.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="6c90a-208">下面的代码示例演示如何 <xref:System.Windows.Forms.Application.EnableVisualStyles%2A> 在函数中调用 `Main` ，以便为应用程序启用视觉样式。</span><span class="sxs-lookup"><span data-stu-id="6c90a-208">The following code example demonstrates calling <xref:System.Windows.Forms.Application.EnableVisualStyles%2A> in the `Main` function to enable visual styles for the application.</span></span>  
  
 [!code-cpp[System.Windows.Forms.Application.EnableVisualStyles#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.Application.EnableVisualStyles/CPP/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.Application.EnableVisualStyles#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Application.EnableVisualStyles/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.Application.EnableVisualStyles#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Application.EnableVisualStyles/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Application.RenderWithVisualStyles" />
        <altmember cref="P:System.Windows.Forms.Application.VisualStyleState" />
        <altmember cref="T:System.Windows.Forms.FlatStyle" />
      </Docs>
    </Member>
    <Member MemberName="EnterThreadModal">
      <MemberSignature Language="C#" Value="public static event EventHandler EnterThreadModal;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler EnterThreadModal" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Application.EnterThreadModal" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event EnterThreadModal As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler ^ EnterThreadModal;" />
      <MemberSignature Language="F#" Value="member this.EnterThreadModal : EventHandler " Usage="member this.EnterThreadModal : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="6c90a-209">当应用程序即将进入模式状态时发生。</span><span class="sxs-lookup"><span data-stu-id="6c90a-209">Occurs when the application is about to enter a modal state.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!CAUTION]
>  <span data-ttu-id="6c90a-210">因为这是一个静态事件，所以必须在释放应用程序时分离事件处理程序，否则会导致内存泄漏。</span><span class="sxs-lookup"><span data-stu-id="6c90a-210">Because this is a static event, you must detach your event handlers when your application is disposed, or memory leaks will result.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="6c90a-211">下面的代码示例演示如何使用此成员。</span><span class="sxs-lookup"><span data-stu-id="6c90a-211">The following code example demonstrates the use of this member.</span></span> <span data-ttu-id="6c90a-212">在此示例中，事件处理程序报告事件的发生 <xref:System.Windows.Forms.Application.EnterThreadModal> 。</span><span class="sxs-lookup"><span data-stu-id="6c90a-212">In the example, an event handler reports on the occurrence of the <xref:System.Windows.Forms.Application.EnterThreadModal> event.</span></span> <span data-ttu-id="6c90a-213">此报表可帮助你了解何时发生事件，并可帮助你进行调试。</span><span class="sxs-lookup"><span data-stu-id="6c90a-213">This report helps you to learn when the event occurs and can assist you in debugging.</span></span> <span data-ttu-id="6c90a-214">若要报告多个事件或频繁发生的事件，请考虑 <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> 将消息替换为多行或将其追加到多行 <xref:System.Windows.Forms.TextBox> 。</span><span class="sxs-lookup"><span data-stu-id="6c90a-214">To report on multiple events or on events that occur frequently, consider replacing <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> with <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> or appending the message to a multiline <xref:System.Windows.Forms.TextBox>.</span></span>  
  
 <span data-ttu-id="6c90a-215">若要运行示例代码，请将其粘贴到 Windows 窗体中，并确保事件处理程序与事件相关联 <xref:System.Windows.Forms.Application.EnterThreadModal> 。</span><span class="sxs-lookup"><span data-stu-id="6c90a-215">To run the example code, paste it into a Windows Forms and ensure that the event handler is associated with the <xref:System.Windows.Forms.Application.EnterThreadModal> event.</span></span>  
  
 [!code-csharp[System.Windows.Forms.EventExamples#3](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#3)]
 [!code-vb[System.Windows.Forms.EventExamples#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ExecutablePath">
      <MemberSignature Language="C#" Value="public static string ExecutablePath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string ExecutablePath" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.ExecutablePath" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ExecutablePath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ ExecutablePath { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ExecutablePath : string" Usage="System.Windows.Forms.Application.ExecutablePath" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="6c90a-216">获取启动了应用程序的可执行文件的路径，包括可执行文件的名称。</span><span class="sxs-lookup"><span data-stu-id="6c90a-216">Gets the path for the executable file that started the application, including the executable name.</span></span></summary>
        <value><span data-ttu-id="6c90a-217">启动了应用程序的可执行文件的路径和可执行文件的名称。</span><span class="sxs-lookup"><span data-stu-id="6c90a-217">The path and executable name for the executable file that started the application.</span></span>  
  
<span data-ttu-id="6c90a-218">此路径将有所不同，具体取决于是否使用 ClickOnce 部署 Windows 窗体应用程序。</span><span class="sxs-lookup"><span data-stu-id="6c90a-218">This path will be different depending on whether the Windows Forms application is deployed using ClickOnce.</span></span> <span data-ttu-id="6c90a-219">ClickOnce 应用程序存储在每个用户的应用程序缓存中的 C:\documents and 和设置 \\ *用户名* 目录中。</span><span class="sxs-lookup"><span data-stu-id="6c90a-219">ClickOnce applications are stored in a per-user application cache in the C:\Documents and Settings\\*username* directory.</span></span> <span data-ttu-id="6c90a-220">有关详细信息，请参阅 [在 ClickOnce 应用程序中访问本地数据和远程数据](/visualstudio/deployment/accessing-local-and-remote-data-in-clickonce-applications)。</span><span class="sxs-lookup"><span data-stu-id="6c90a-220">For more information, see [Accessing Local and Remote Data in ClickOnce Applications](/visualstudio/deployment/accessing-local-and-remote-data-in-clickonce-applications).</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Exit">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="6c90a-221">通知所有消息泵必须终止，并且在处理了消息以后关闭所有应用程序窗口。</span><span class="sxs-lookup"><span data-stu-id="6c90a-221">Informs all message pumps that they must terminate, and then closes all application windows after the messages have been processed.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Exit">
      <MemberSignature Language="C#" Value="public static void Exit ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Exit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.Exit" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Exit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Exit();" />
      <MemberSignature Language="F#" Value="static member Exit : unit -&gt; unit" Usage="System.Windows.Forms.Application.Exit " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="6c90a-222">通知所有消息泵必须终止，并且在处理了消息以后关闭所有应用程序窗口。</span><span class="sxs-lookup"><span data-stu-id="6c90a-222">Informs all message pumps that they must terminate, and then closes all application windows after the messages have been processed.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6c90a-223"><xref:System.Windows.Forms.Application.Exit%2A>方法在所有线程上停止所有正在运行的消息循环，并关闭应用程序的所有窗口。</span><span class="sxs-lookup"><span data-stu-id="6c90a-223">The <xref:System.Windows.Forms.Application.Exit%2A> method stops all running message loops on all threads and closes all windows of the application.</span></span> <span data-ttu-id="6c90a-224">此方法并不一定强制退出应用程序。</span><span class="sxs-lookup"><span data-stu-id="6c90a-224">This method does not necessarily force the application to exit.</span></span> <span data-ttu-id="6c90a-225"><xref:System.Windows.Forms.Application.Exit%2A>方法通常从消息循环中调用，并强制 <xref:System.Windows.Forms.Application.Run%2A> 返回。</span><span class="sxs-lookup"><span data-stu-id="6c90a-225">The <xref:System.Windows.Forms.Application.Exit%2A> method is typically called from within a message loop, and forces <xref:System.Windows.Forms.Application.Run%2A> to return.</span></span> <span data-ttu-id="6c90a-226">若要仅退出当前线程的消息循环，请调用 <xref:System.Windows.Forms.Application.ExitThread%2A> 。</span><span class="sxs-lookup"><span data-stu-id="6c90a-226">To exit a message loop for the current thread only, call <xref:System.Windows.Forms.Application.ExitThread%2A>.</span></span>  
  
 <span data-ttu-id="6c90a-227"><xref:System.Windows.Forms.Application.Exit%2A> 引发以下事件并执行关联的条件操作：</span><span class="sxs-lookup"><span data-stu-id="6c90a-227"><xref:System.Windows.Forms.Application.Exit%2A> raises the following events and performs the associated conditional actions:</span></span>  
  
-   <span data-ttu-id="6c90a-228"><xref:System.Windows.Forms.Form.FormClosing>每个由属性表示的窗体都将引发一个事件 <xref:System.Windows.Forms.Application.OpenForms%2A> 。</span><span class="sxs-lookup"><span data-stu-id="6c90a-228">A <xref:System.Windows.Forms.Form.FormClosing> event is raised for every form represented by the <xref:System.Windows.Forms.Application.OpenForms%2A> property.</span></span> <span data-ttu-id="6c90a-229">可以通过将 <xref:System.ComponentModel.CancelEventArgs.Cancel%2A> 其参数的属性设置 <xref:System.Windows.Forms.FormClosingEventArgs> 为来取消此事件 `true` 。</span><span class="sxs-lookup"><span data-stu-id="6c90a-229">This event can be canceled by setting the <xref:System.ComponentModel.CancelEventArgs.Cancel%2A> property of their <xref:System.Windows.Forms.FormClosingEventArgs> parameter to `true`.</span></span>  
  
-   <span data-ttu-id="6c90a-230">如果有一个或多个处理程序取消了该事件，则 <xref:System.Windows.Forms.Application.Exit%2A> 返回而不执行进一步操作。</span><span class="sxs-lookup"><span data-stu-id="6c90a-230">If one of more of the handlers cancels the event, then <xref:System.Windows.Forms.Application.Exit%2A> returns without further action.</span></span> <span data-ttu-id="6c90a-231">否则， <xref:System.Windows.Forms.Form.FormClosed> 会为每个打开的窗体引发事件，并关闭所有正在运行的消息循环和窗体。</span><span class="sxs-lookup"><span data-stu-id="6c90a-231">Otherwise, a <xref:System.Windows.Forms.Form.FormClosed> event is raised for every open form, then all running message loops and forms are closed.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="6c90a-232">此 <xref:System.Windows.Forms.Application.Exit%2A> 方法不会引发 <xref:System.Windows.Forms.Form.Closed> 和 <xref:System.Windows.Forms.Form.Closing> 事件，这些事件在 2.0 .NET Framework。</span><span class="sxs-lookup"><span data-stu-id="6c90a-232">The <xref:System.Windows.Forms.Application.Exit%2A> method does not raise the <xref:System.Windows.Forms.Form.Closed> and <xref:System.Windows.Forms.Form.Closing> events, which are obsolete as of .NET Framework 2.0.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="6c90a-233">下面的代码示例在窗体上的列表框中列出了数字。</span><span class="sxs-lookup"><span data-stu-id="6c90a-233">The following code example lists numbers in a list box on a form.</span></span> <span data-ttu-id="6c90a-234">每次单击时 `button1` ，应用程序都会向列表中添加一个编号。</span><span class="sxs-lookup"><span data-stu-id="6c90a-234">Each time you click `button1`, the application adds another number to the list.</span></span>  
  
 <span data-ttu-id="6c90a-235">`Main`方法调用 <xref:System.Windows.Forms.Application.Run%2A> 以启动应用程序，该应用程序将创建窗体、 `listBox1` 和 `button1` 。</span><span class="sxs-lookup"><span data-stu-id="6c90a-235">The `Main` method calls <xref:System.Windows.Forms.Application.Run%2A> to start the application, which creates the form, `listBox1`, and `button1`.</span></span> <span data-ttu-id="6c90a-236">用户单击时 `button1` ，该方法会向 `button1_Click` 列表框中添加一个到三个数字，并显示 <xref:System.Windows.Forms.MessageBox> 。</span><span class="sxs-lookup"><span data-stu-id="6c90a-236">When the user clicks `button1`, the `button1_Click` method adds numbers one to three to the list box, and displays a <xref:System.Windows.Forms.MessageBox>.</span></span> <span data-ttu-id="6c90a-237">如果用户单击上的 " **否** " <xref:System.Windows.Forms.MessageBox> ，则该 `button1_Click` 方法将向列表中添加另一个数字。</span><span class="sxs-lookup"><span data-stu-id="6c90a-237">If the user clicks **No** on the <xref:System.Windows.Forms.MessageBox>, the `button1_Click` method adds another number to the list.</span></span> <span data-ttu-id="6c90a-238">如果用户单击 **"是"**，应用程序将调用 <xref:System.Windows.Forms.Application.Exit%2A> 来处理队列中所有剩余的消息，然后退出。</span><span class="sxs-lookup"><span data-stu-id="6c90a-238">If the user clicks **Yes**, the application calls <xref:System.Windows.Forms.Application.Exit%2A>, to process all remaining messages in the queue and then to quit.</span></span>  
  
 <span data-ttu-id="6c90a-239">该示例要求 `listBox1` 并已经 `button1` 实例化并将其放置在窗体上。</span><span class="sxs-lookup"><span data-stu-id="6c90a-239">The example requires that `listBox1` and `button1` have been instantiated and placed on a form.</span></span>  
  
 [!code-cpp[Classic Application.Exit Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.Exit Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.Exit Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.Exit Example/CS/source.cs#1)]
 [!code-vb[Classic Application.Exit Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.Exit Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Application.ExitThread" />
        <altmember cref="M:System.Windows.Forms.Application.Run" />
        <altmember cref="P:System.Windows.Forms.Application.OpenForms" />
        <altmember cref="E:System.Windows.Forms.Form.Closed" />
        <altmember cref="E:System.Windows.Forms.Form.Closing" />
      </Docs>
    </Member>
    <Member MemberName="Exit">
      <MemberSignature Language="C#" Value="public static void Exit (System.ComponentModel.CancelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Exit(class System.ComponentModel.CancelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.Exit(System.ComponentModel.CancelEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Exit (e As CancelEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Exit(System::ComponentModel::CancelEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="static member Exit : System.ComponentModel.CancelEventArgs -&gt; unit" Usage="System.Windows.Forms.Application.Exit e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.ComponentModel.CancelEventArgs" Index="0" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="6c90a-240">返回应用程序中的任何 <see cref="T:System.Windows.Forms.Form" /> 是否已取消退出。</span><span class="sxs-lookup"><span data-stu-id="6c90a-240">Returns whether any <see cref="T:System.Windows.Forms.Form" /> within the application cancelled the exit.</span></span></param>
        <summary><span data-ttu-id="6c90a-241">通知所有消息泵必须终止，并且在处理了消息以后关闭所有应用程序窗口。</span><span class="sxs-lookup"><span data-stu-id="6c90a-241">Informs all message pumps that they must terminate, and then closes all application windows after the messages have been processed.</span></span></summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Forms.Application.Exit" />
      </Docs>
    </Member>
    <Member MemberName="ExitThread">
      <MemberSignature Language="C#" Value="public static void ExitThread ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ExitThread() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.ExitThread" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ExitThread ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ExitThread();" />
      <MemberSignature Language="F#" Value="static member ExitThread : unit -&gt; unit" Usage="System.Windows.Forms.Application.ExitThread " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="6c90a-242">退出当前线程上的消息循环，并关闭该线程上的所有窗口。</span><span class="sxs-lookup"><span data-stu-id="6c90a-242">Exits the message loop on the current thread and closes all windows on the thread.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6c90a-243">使用此方法退出当前线程的消息循环。</span><span class="sxs-lookup"><span data-stu-id="6c90a-243">Use this method to exit the message loop of the current thread.</span></span> <span data-ttu-id="6c90a-244">此方法导致调用 <xref:System.Windows.Forms.Application.Run%2A> 当前线程返回。</span><span class="sxs-lookup"><span data-stu-id="6c90a-244">This method causes the call to <xref:System.Windows.Forms.Application.Run%2A> for the current thread to return.</span></span> <span data-ttu-id="6c90a-245">若要退出整个应用程序，请调用 <xref:System.Windows.Forms.Application.Exit%2A> 。</span><span class="sxs-lookup"><span data-stu-id="6c90a-245">To exit the entire application, call <xref:System.Windows.Forms.Application.Exit%2A>.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Application.Exit" />
      </Docs>
    </Member>
    <Member MemberName="FilterMessage">
      <MemberSignature Language="C#" Value="public static bool FilterMessage (ref System.Windows.Forms.Message message);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool FilterMessage(valuetype System.Windows.Forms.Message&amp; message) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.FilterMessage(System.Windows.Forms.Message@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FilterMessage (ByRef message As Message) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool FilterMessage(System::Windows::Forms::Message % message);" />
      <MemberSignature Language="F#" Value="static member FilterMessage : Message -&gt; bool" Usage="System.Windows.Forms.Application.FilterMessage message" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.Windows.Forms.Message" RefType="ref" Index="0" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="message"><span data-ttu-id="6c90a-246">要筛选的 Windows 事件消息。</span><span class="sxs-lookup"><span data-stu-id="6c90a-246">The Windows event message to filter.</span></span></param>
        <summary><span data-ttu-id="6c90a-247">对窗口消息运行任何筛选器，并返回修改后的消息的副本。</span><span class="sxs-lookup"><span data-stu-id="6c90a-247">Runs any filters against a window message, and returns a copy of the modified message.</span></span></summary>
        <returns><span data-ttu-id="6c90a-248">如果已处理筛选，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="6c90a-248"><see langword="true" /> if the filters were processed; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HighDpiMode">
      <MemberSignature Language="C#" Value="public static System.Windows.Forms.HighDpiMode HighDpiMode { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Windows.Forms.HighDpiMode HighDpiMode" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.HighDpiMode" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property HighDpiMode As HighDpiMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Forms::HighDpiMode HighDpiMode { System::Windows::Forms::HighDpiMode get(); };" />
      <MemberSignature Language="F#" Value="member this.HighDpiMode : System.Windows.Forms.HighDpiMode" Usage="System.Windows.Forms.Application.HighDpiMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HighDpiMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="6c90a-249">获取应用程序的当前高 DPI 模式。</span><span class="sxs-lookup"><span data-stu-id="6c90a-249">Gets the current high DPI mode for the application.</span></span></summary>
        <value><span data-ttu-id="6c90a-250">指示高 DPI 模式的枚举值之一。</span><span class="sxs-lookup"><span data-stu-id="6c90a-250">One of the enumeration values that indicates the high DPI mode.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Idle">
      <MemberSignature Language="C#" Value="public static event EventHandler Idle;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Idle" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Application.Idle" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event Idle As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler ^ Idle;" />
      <MemberSignature Language="F#" Value="member this.Idle : EventHandler " Usage="member this.Idle : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="6c90a-251">当应用程序完成处理并即将进入空闲状态时发生。</span><span class="sxs-lookup"><span data-stu-id="6c90a-251">Occurs when the application finishes processing and is about to enter the idle state.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6c90a-252">如果你具有在线程进入空闲状态之前必须执行的任务，请将其附加到此事件。</span><span class="sxs-lookup"><span data-stu-id="6c90a-252">If you have tasks that you must perform before the thread becomes idle, attach them to this event.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="6c90a-253">因为这是一个静态事件，所以必须在释放应用程序时分离事件处理程序，否则会导致内存泄漏。</span><span class="sxs-lookup"><span data-stu-id="6c90a-253">Because this is a static event, you must detach your event handlers when your application is disposed, or memory leaks will result.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="6c90a-254">下面的代码示例演示如何使用此成员。</span><span class="sxs-lookup"><span data-stu-id="6c90a-254">The following code example demonstrates the use of this member.</span></span> <span data-ttu-id="6c90a-255">在此示例中，事件处理程序报告事件的发生 <xref:System.Windows.Forms.Application.Idle> 。</span><span class="sxs-lookup"><span data-stu-id="6c90a-255">In the example, an event handler reports on the occurrence of the <xref:System.Windows.Forms.Application.Idle> event.</span></span> <span data-ttu-id="6c90a-256">此报表可帮助你了解何时发生事件，并可帮助你进行调试。</span><span class="sxs-lookup"><span data-stu-id="6c90a-256">This report helps you to learn when the event occurs and can assist you in debugging.</span></span> <span data-ttu-id="6c90a-257">若要报告多个事件或频繁发生的事件，请考虑 <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> 将消息替换为多行或将其追加到多行 <xref:System.Windows.Forms.TextBox> 。</span><span class="sxs-lookup"><span data-stu-id="6c90a-257">To report on multiple events or on events that occur frequently, consider replacing <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> with <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> or appending the message to a multiline <xref:System.Windows.Forms.TextBox>.</span></span>  
  
 <span data-ttu-id="6c90a-258">若要运行示例代码，请将其粘贴到 Windows 窗体中，并确保事件处理程序与事件相关联 <xref:System.Windows.Forms.Application.Idle> 。</span><span class="sxs-lookup"><span data-stu-id="6c90a-258">To run the example code, paste it into a Windows Form and make sure that the event handler is associated with the <xref:System.Windows.Forms.Application.Idle> event.</span></span>  
  
 [!code-csharp[System.Windows.Forms.EventExamples#2](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#2)]
 [!code-vb[System.Windows.Forms.EventExamples#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LeaveThreadModal">
      <MemberSignature Language="C#" Value="public static event EventHandler LeaveThreadModal;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler LeaveThreadModal" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Application.LeaveThreadModal" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event LeaveThreadModal As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler ^ LeaveThreadModal;" />
      <MemberSignature Language="F#" Value="member this.LeaveThreadModal : EventHandler " Usage="member this.LeaveThreadModal : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="6c90a-259">当应用程序即将退出模式状态时发生。</span><span class="sxs-lookup"><span data-stu-id="6c90a-259">Occurs when the application is about to leave a modal state.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!CAUTION]
>  <span data-ttu-id="6c90a-260">因为这是一个静态事件，所以必须在释放应用程序时分离事件处理程序，否则会导致内存泄漏。</span><span class="sxs-lookup"><span data-stu-id="6c90a-260">Because this is a static event, you must detach your event handlers when your application is disposed, or memory leaks will result.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="6c90a-261">下面的代码示例演示如何使用此成员。</span><span class="sxs-lookup"><span data-stu-id="6c90a-261">The following code example demonstrates the use of this member.</span></span> <span data-ttu-id="6c90a-262">在此示例中，事件处理程序报告事件的发生 <xref:System.Windows.Forms.Application.LeaveThreadModal> 。</span><span class="sxs-lookup"><span data-stu-id="6c90a-262">In the example, an event handler reports on the occurrence of the <xref:System.Windows.Forms.Application.LeaveThreadModal> event.</span></span> <span data-ttu-id="6c90a-263">此报表可帮助你了解何时发生事件，并可帮助你进行调试。</span><span class="sxs-lookup"><span data-stu-id="6c90a-263">This report helps you to learn when the event occurs and can assist you in debugging.</span></span> <span data-ttu-id="6c90a-264">若要报告多个事件或频繁发生的事件，请考虑 <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> 将消息替换为多行或将其追加到多行 <xref:System.Windows.Forms.TextBox> 。</span><span class="sxs-lookup"><span data-stu-id="6c90a-264">To report on multiple events or on events that occur frequently, consider replacing <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> with <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> or appending the message to a multiline <xref:System.Windows.Forms.TextBox>.</span></span>  
  
 <span data-ttu-id="6c90a-265">若要运行示例代码，请将其粘贴到 Windows 窗体中，并确保事件处理程序与事件相关联 <xref:System.Windows.Forms.Application.LeaveThreadModal> 。</span><span class="sxs-lookup"><span data-stu-id="6c90a-265">To run the example code, paste it into a Windows Forms and ensure that the event handler is associated with the <xref:System.Windows.Forms.Application.LeaveThreadModal> event.</span></span>  
  
 [!code-csharp[System.Windows.Forms.EventExamples#4](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#4)]
 [!code-vb[System.Windows.Forms.EventExamples#4](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LocalUserAppDataPath">
      <MemberSignature Language="C#" Value="public static string LocalUserAppDataPath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string LocalUserAppDataPath" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.LocalUserAppDataPath" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property LocalUserAppDataPath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ LocalUserAppDataPath { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.LocalUserAppDataPath : string" Usage="System.Windows.Forms.Application.LocalUserAppDataPath" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="6c90a-266">获取本地、非漫游用户的应用程序数据的路径。</span><span class="sxs-lookup"><span data-stu-id="6c90a-266">Gets the path for the application data of a local, non-roaming user.</span></span></summary>
        <value><span data-ttu-id="6c90a-267">本地、非漫游用户的应用程序数据的路径。</span><span class="sxs-lookup"><span data-stu-id="6c90a-267">The path for the application data of a local, non-roaming user.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6c90a-268">本地用户是其用户配置文件存储在用户登录的系统上的用户。</span><span class="sxs-lookup"><span data-stu-id="6c90a-268">A local user is one whose user profile is stored on the system on which the user logged on.</span></span> <span data-ttu-id="6c90a-269">如果路径不存在，则将使用以下格式创建一个路径：</span><span class="sxs-lookup"><span data-stu-id="6c90a-269">If a path does not exist, one is created in the following format:</span></span>  
  
 <span data-ttu-id="6c90a-270">*基路径*\\<xref:System.Windows.Forms.Application.CompanyName%2A>\\<xref:System.Windows.Forms.Application.ProductName%2A>\\<xref:System.Windows.Forms.Application.ProductVersion%2A></span><span class="sxs-lookup"><span data-stu-id="6c90a-270">*Base Path*\\<xref:System.Windows.Forms.Application.CompanyName%2A>\\<xref:System.Windows.Forms.Application.ProductName%2A>\\<xref:System.Windows.Forms.Application.ProductVersion%2A></span></span>   
  
 <span data-ttu-id="6c90a-271">典型的基路径为 "C:\documents and" 和 "Settings \\ *username*\Local Settings\Application Data"。</span><span class="sxs-lookup"><span data-stu-id="6c90a-271">A typical base path is C:\Documents and Settings\\*username*\Local Settings\Application Data.</span></span> <span data-ttu-id="6c90a-272">但是，如果使用 ClickOnce 部署 Windows 窗体应用程序，则此路径将有所不同。</span><span class="sxs-lookup"><span data-stu-id="6c90a-272">This path will be different, however, if the Windows Forms application is deployed by using ClickOnce.</span></span> <span data-ttu-id="6c90a-273">ClickOnce 创建独立于所有其他应用程序的应用程序数据目录。</span><span class="sxs-lookup"><span data-stu-id="6c90a-273">ClickOnce creates its own application data directory that is isolated from all other applications.</span></span> <span data-ttu-id="6c90a-274">有关详细信息，请参阅 [在 ClickOnce 应用程序中访问本地数据和远程数据](/visualstudio/deployment/accessing-local-and-remote-data-in-clickonce-applications)。</span><span class="sxs-lookup"><span data-stu-id="6c90a-274">For more information, see [Accessing Local and Remote Data in ClickOnce Applications](/visualstudio/deployment/accessing-local-and-remote-data-in-clickonce-applications).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="6c90a-275">下面的代码示例显示两个窗体并在两个窗体关闭时退出应用程序。</span><span class="sxs-lookup"><span data-stu-id="6c90a-275">The following code example displays two forms and exits the application when both forms are closed.</span></span> <span data-ttu-id="6c90a-276">当应用程序启动和退出时，将记住每个窗体的位置。</span><span class="sxs-lookup"><span data-stu-id="6c90a-276">When the application starts and exits, the position of each form is remembered.</span></span> <span data-ttu-id="6c90a-277">尽管此示例演示如何使用 <xref:System.Windows.Forms.Application.UserAppDataPath%2A> 属性来存储用户的应用程序数据，但 <xref:System.Windows.Forms.Application.LocalUserAppDataPath%2A> 可以改为使用。</span><span class="sxs-lookup"><span data-stu-id="6c90a-277">Although this example demonstrates using the <xref:System.Windows.Forms.Application.UserAppDataPath%2A> property to store application data for the user, the <xref:System.Windows.Forms.Application.LocalUserAppDataPath%2A> can be used instead.</span></span>  
  
 <span data-ttu-id="6c90a-278">`MyApplicationContext`类从继承， <xref:System.Windows.Forms.ApplicationContext> 并在每个窗体关闭时保持跟踪，并在两个窗体关闭时保持跟踪，并在两个窗体均</span><span class="sxs-lookup"><span data-stu-id="6c90a-278">The `MyApplicationContext` class inherits from <xref:System.Windows.Forms.ApplicationContext> and keeps track when each form is closed, and exits the current thread when they both are.</span></span> <span data-ttu-id="6c90a-279">类存储用户的每个窗体的位置。</span><span class="sxs-lookup"><span data-stu-id="6c90a-279">The class stores the positions of each form for the user.</span></span> <span data-ttu-id="6c90a-280">窗体位置数据存储在名为的文件中 `Appdata.txt` ，该文件在由确定的位置创建 <xref:System.Windows.Forms.Application.UserAppDataPath%2A> 。</span><span class="sxs-lookup"><span data-stu-id="6c90a-280">The form position data is stored in a file titled `Appdata.txt` that is created in the location determined by <xref:System.Windows.Forms.Application.UserAppDataPath%2A>.</span></span> <span data-ttu-id="6c90a-281">`Main`方法调用 `Application.Run(context)` 来启动给定的应用程序 <xref:System.Windows.Forms.ApplicationContext> 。</span><span class="sxs-lookup"><span data-stu-id="6c90a-281">The `Main` method calls `Application.Run(context)` to start the application given the <xref:System.Windows.Forms.ApplicationContext>.</span></span>  
  
 <span data-ttu-id="6c90a-282">此代码摘自类概述中所示的示例 <xref:System.Windows.Forms.ApplicationContext> 。</span><span class="sxs-lookup"><span data-stu-id="6c90a-282">This code is an excerpt from the example shown in the <xref:System.Windows.Forms.ApplicationContext> class overview.</span></span> <span data-ttu-id="6c90a-283">为了简洁起见，不显示某些代码。</span><span class="sxs-lookup"><span data-stu-id="6c90a-283">Some code is not shown for the purpose of brevity.</span></span> <span data-ttu-id="6c90a-284"><xref:System.Windows.Forms.ApplicationContext>有关完整的代码清单，请参阅。</span><span class="sxs-lookup"><span data-stu-id="6c90a-284">See <xref:System.Windows.Forms.ApplicationContext> for the whole code listing.</span></span>  
  
 [!code-cpp[Application#5](~/samples/snippets/cpp/VS_Snippets_Winforms/Application/CPP/source.cpp#5)]
 [!code-csharp[Application#5](~/samples/snippets/csharp/VS_Snippets_Winforms/Application/CS/source.cs#5)]
 [!code-vb[Application#5](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Application/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MessageLoop">
      <MemberSignature Language="C#" Value="public static bool MessageLoop { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool MessageLoop" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.MessageLoop" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MessageLoop As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool MessageLoop { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.MessageLoop : bool" Usage="System.Windows.Forms.Application.MessageLoop" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="6c90a-285">获取指示该线程上是否存在消息循环的值。</span><span class="sxs-lookup"><span data-stu-id="6c90a-285">Gets a value indicating whether a message loop exists on this thread.</span></span></summary>
        <value><span data-ttu-id="6c90a-286">如果存在消息循环，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="6c90a-286"><see langword="true" /> if a message loop exists; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6c90a-287">在其他环境（例如非托管应用程序）中承载 Windows 窗体时，此属性将始终返回 `false` 。</span><span class="sxs-lookup"><span data-stu-id="6c90a-287">When hosting Windows Forms in other environments, such as unmanaged applications, this property will always return `false`.</span></span> <span data-ttu-id="6c90a-288"><xref:System.Windows.Forms.Application.RegisterMessageLoop%2A>如果宿主环境仍具有活动消息循环，请使用来指示 Windows 窗体。</span><span class="sxs-lookup"><span data-stu-id="6c90a-288">Use <xref:System.Windows.Forms.Application.RegisterMessageLoop%2A> to instruct Windows Forms if the hosting environment still has an active message loop.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OleRequired">
      <MemberSignature Language="C#" Value="public static System.Threading.ApartmentState OleRequired ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.ApartmentState OleRequired() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.OleRequired" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OleRequired () As ApartmentState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::ApartmentState OleRequired();" />
      <MemberSignature Language="F#" Value="static member OleRequired : unit -&gt; System.Threading.ApartmentState" Usage="System.Windows.Forms.Application.OleRequired " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.ApartmentState</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="6c90a-289">初始化当前线程上的 OLE。</span><span class="sxs-lookup"><span data-stu-id="6c90a-289">Initializes OLE on the current thread.</span></span></summary>
        <returns><span data-ttu-id="6c90a-290"><see cref="T:System.Threading.ApartmentState" /> 值之一。</span><span class="sxs-lookup"><span data-stu-id="6c90a-290">One of the <see cref="T:System.Threading.ApartmentState" /> values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6c90a-291">在调用需要 OLE 的任何方法之前调用此方法 `Microsoft.Win32` 。</span><span class="sxs-lookup"><span data-stu-id="6c90a-291">Call this method before calling any `Microsoft.Win32` method that requires OLE.</span></span> <span data-ttu-id="6c90a-292"><xref:System.Windows.Forms.Application.OleRequired%2A> 首先检查是否已在当前线程上初始化 OLE。</span><span class="sxs-lookup"><span data-stu-id="6c90a-292"><xref:System.Windows.Forms.Application.OleRequired%2A> first checks to see if OLE has been initialized on the current thread.</span></span> <span data-ttu-id="6c90a-293">如果不是，则它初始化 OLE 的线程。</span><span class="sxs-lookup"><span data-stu-id="6c90a-293">If not, it initializes the thread for OLE.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="6c90a-294">除非线程直接调用 OLE 方法，否则不需要调用此方法。</span><span class="sxs-lookup"><span data-stu-id="6c90a-294">Unless a thread calls OLE methods directly, you do not need to call this method.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnThreadException">
      <MemberSignature Language="C#" Value="public static void OnThreadException (Exception t);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void OnThreadException(class System.Exception t) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.OnThreadException(System.Exception)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub OnThreadException (t As Exception)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void OnThreadException(Exception ^ t);" />
      <MemberSignature Language="F#" Value="static member OnThreadException : Exception -&gt; unit" Usage="System.Windows.Forms.Application.OnThreadException t" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="t" Type="System.Exception" />
      </Parameters>
      <Docs>
        <param name="t"><span data-ttu-id="6c90a-295">一个 <see cref="T:System.Exception" />，它代表所引发的异常。</span><span class="sxs-lookup"><span data-stu-id="6c90a-295">An <see cref="T:System.Exception" /> that represents the exception that was thrown.</span></span></param>
        <summary><span data-ttu-id="6c90a-296">引发 <see cref="E:System.Windows.Forms.Application.ThreadException" /> 事件。</span><span class="sxs-lookup"><span data-stu-id="6c90a-296">Raises the <see cref="E:System.Windows.Forms.Application.ThreadException" /> event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6c90a-297">调用 <xref:System.Windows.Forms.Application.OnThreadException%2A> 会引发将暂停应用程序处理的异常。</span><span class="sxs-lookup"><span data-stu-id="6c90a-297">Call <xref:System.Windows.Forms.Application.OnThreadException%2A> to raise an exception that will halt processing of the application.</span></span>  
  
 <span data-ttu-id="6c90a-298"><xref:System.Windows.Forms.Application>类有 <xref:System.Windows.Forms.Application.ThreadException> 事件。</span><span class="sxs-lookup"><span data-stu-id="6c90a-298">The <xref:System.Windows.Forms.Application> class has a <xref:System.Windows.Forms.Application.ThreadException> event.</span></span> <span data-ttu-id="6c90a-299">您可以将事件处理程序附加到此事件，以执行未经处理的异常所需的任何自定义处理。</span><span class="sxs-lookup"><span data-stu-id="6c90a-299">You can attach an event handler to this event to do whatever custom processing you need for unhandled exceptions.</span></span> <span data-ttu-id="6c90a-300">如果不附加事件处理程序， <xref:System.Windows.Forms.Application.OnThreadException%2A> 则将执行默认行为，这涉及显示一个对话框，以通知用户出现错误。</span><span class="sxs-lookup"><span data-stu-id="6c90a-300">If you do not attach an event handler, <xref:System.Windows.Forms.Application.OnThreadException%2A> will execute the default behavior, which involves displaying a dialog box to inform the user that there has been an error.</span></span>  
  
 <span data-ttu-id="6c90a-301"><xref:System.Windows.Forms.Application.OnThreadException%2A> 仅为在 Windows 窗体拥有的线程上发生的未经处理的异常实现默认异常行为。</span><span class="sxs-lookup"><span data-stu-id="6c90a-301"><xref:System.Windows.Forms.Application.OnThreadException%2A> only implements default exception behavior for unhandled exceptions that occur on threads owned by Windows Forms.</span></span> <span data-ttu-id="6c90a-302">其他线程上的未处理异常由 <xref:System.AppDomain.UnhandledException> 事件处理。</span><span class="sxs-lookup"><span data-stu-id="6c90a-302">Unhandled exceptions on other threads are handled by the <xref:System.AppDomain.UnhandledException> event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OpenForms">
      <MemberSignature Language="C#" Value="public static System.Windows.Forms.FormCollection OpenForms { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Forms.FormCollection OpenForms" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.OpenForms" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property OpenForms As FormCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Forms::FormCollection ^ OpenForms { System::Windows::Forms::FormCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.OpenForms : System.Windows.Forms.FormCollection" Usage="System.Windows.Forms.Application.OpenForms" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.FormCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="6c90a-303">获取为应用程序所有的已打开窗体的集合。</span><span class="sxs-lookup"><span data-stu-id="6c90a-303">Gets a collection of open forms owned by the application.</span></span></summary>
        <value><span data-ttu-id="6c90a-304">包含属于此应用程序的所有当前打开窗体的 <see cref="T:System.Windows.Forms.FormCollection" />。</span><span class="sxs-lookup"><span data-stu-id="6c90a-304">A <see cref="T:System.Windows.Forms.FormCollection" /> containing all the currently open forms owned by this application.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6c90a-305"><xref:System.Windows.Forms.Application.OpenForms%2A>属性表示应用程序拥有的窗体的只读集合。</span><span class="sxs-lookup"><span data-stu-id="6c90a-305">The <xref:System.Windows.Forms.Application.OpenForms%2A> property represents a read-only collection of forms owned by the application.</span></span> <span data-ttu-id="6c90a-306">可以按索引位置或的来搜索此集合 <xref:System.Windows.Forms.Control.Name%2A> <xref:System.Windows.Forms.Form> 。</span><span class="sxs-lookup"><span data-stu-id="6c90a-306">This collection can be searched by index position or by the <xref:System.Windows.Forms.Control.Name%2A> of the <xref:System.Windows.Forms.Form>.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Application.Exit" />
        <altmember cref="T:System.Windows.Forms.FormCollection" />
      </Docs>
    </Member>
    <Member MemberName="ProductName">
      <MemberSignature Language="C#" Value="public static string ProductName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string ProductName" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.ProductName" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ProductName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ ProductName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ProductName : string" Usage="System.Windows.Forms.Application.ProductName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="6c90a-307">获取与该应用程序关联的产品名称。</span><span class="sxs-lookup"><span data-stu-id="6c90a-307">Gets the product name associated with this application.</span></span></summary>
        <value><span data-ttu-id="6c90a-308">产品名称。</span><span class="sxs-lookup"><span data-stu-id="6c90a-308">The product name.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6c90a-309">`ProductName` 从包含当前应用程序的主窗体的程序集的元数据中获取。</span><span class="sxs-lookup"><span data-stu-id="6c90a-309">`ProductName` is taken from the metadata of the assembly containing the main form of the current application.</span></span> <span data-ttu-id="6c90a-310">您可以通过在 <xref:System.Reflection.AssemblyProductAttribute> 程序集清单中进行设置来设置它。</span><span class="sxs-lookup"><span data-stu-id="6c90a-310">You can set it by setting <xref:System.Reflection.AssemblyProductAttribute> inside of your assembly manifest.</span></span> <span data-ttu-id="6c90a-311">有关详细信息，请参阅 [程序集清单](/dotnet/standard/assembly/manifest)。</span><span class="sxs-lookup"><span data-stu-id="6c90a-311">For more information, see [Assembly Manifest](/dotnet/standard/assembly/manifest).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="6c90a-312">下面的代码示例获取此属性，并在文本框中显示其值。</span><span class="sxs-lookup"><span data-stu-id="6c90a-312">The following code example gets this property and displays its value in a text box.</span></span> <span data-ttu-id="6c90a-313">该示例要求已 `textBox1` 置于窗体上。</span><span class="sxs-lookup"><span data-stu-id="6c90a-313">The example requires that `textBox1` has been placed on a form.</span></span>  
  
 [!code-cpp[Classic Application.ProductName Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.ProductName Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.ProductName Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.ProductName Example/CS/source.cs#1)]
 [!code-vb[Classic Application.ProductName Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.ProductName Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Application.ProductVersion" />
        <altmember cref="P:System.Windows.Forms.Application.CompanyName" />
        <altmember cref="T:System.Reflection.AssemblyProductAttribute" />
      </Docs>
    </Member>
    <Member MemberName="ProductVersion">
      <MemberSignature Language="C#" Value="public static string ProductVersion { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string ProductVersion" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.ProductVersion" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ProductVersion As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ ProductVersion { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ProductVersion : string" Usage="System.Windows.Forms.Application.ProductVersion" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="6c90a-314">获取与该应用程序关联的产品版本。</span><span class="sxs-lookup"><span data-stu-id="6c90a-314">Gets the product version associated with this application.</span></span></summary>
        <value><span data-ttu-id="6c90a-315">产品版本。</span><span class="sxs-lookup"><span data-stu-id="6c90a-315">The product version.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6c90a-316">版本号通常显示为 *主编号*。*次版本号*。*内部版本号*。*专用部件号*。</span><span class="sxs-lookup"><span data-stu-id="6c90a-316">Typically, a version number displays as *major number*.*minor number*.*build number*.*private part number*.</span></span> <span data-ttu-id="6c90a-317">可以通过设置程序集清单中的程序集版本来显式设置它。</span><span class="sxs-lookup"><span data-stu-id="6c90a-317">You can set it explicitly by setting the assembly version within your assembly manifest.</span></span> <span data-ttu-id="6c90a-318">有关详细信息，请参阅 [程序集清单](/dotnet/standard/assembly/manifest)。</span><span class="sxs-lookup"><span data-stu-id="6c90a-318">For more information, see [Assembly Manifest](/dotnet/standard/assembly/manifest).</span></span>  
  
 <span data-ttu-id="6c90a-319"><xref:System.Windows.Forms.Application.ProductVersion%2A> 首先查看包含主可执行文件的程序集是否具有 `AssemblyInformationalVersion` 其属性。</span><span class="sxs-lookup"><span data-stu-id="6c90a-319"><xref:System.Windows.Forms.Application.ProductVersion%2A> first looks to see if the assembly containing the main executable has the `AssemblyInformationalVersion` attribute on it.</span></span> <span data-ttu-id="6c90a-320">如果该属性存在，则用于 <xref:System.Windows.Forms.Application.ProductVersion%2A> 和 <xref:System.Windows.Forms.Application.CommonAppDataPath%2A> 。</span><span class="sxs-lookup"><span data-stu-id="6c90a-320">If this attribute exists, it is used for both <xref:System.Windows.Forms.Application.ProductVersion%2A> and <xref:System.Windows.Forms.Application.CommonAppDataPath%2A>.</span></span> <span data-ttu-id="6c90a-321">如果此属性不存在，则这两个属性将改用可执行文件的版本。</span><span class="sxs-lookup"><span data-stu-id="6c90a-321">If this attribute does not exist, both properties use the version of the executable file instead.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="6c90a-322">下面的代码示例获取此属性，并在文本框中显示其值。</span><span class="sxs-lookup"><span data-stu-id="6c90a-322">The following code example gets this property and displays its value in a text box.</span></span> <span data-ttu-id="6c90a-323">该示例要求已 `textBox1` 置于窗体上。</span><span class="sxs-lookup"><span data-stu-id="6c90a-323">The example requires that `textBox1` has been placed on a form.</span></span>  
  
 [!code-cpp[Classic Application.ProductVersion Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.ProductVersion Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.ProductVersion Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.ProductVersion Example/CS/source.cs#1)]
 [!code-vb[Classic Application.ProductVersion Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.ProductVersion Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Application.ProductName" />
        <altmember cref="P:System.Windows.Forms.Application.CompanyName" />
        <altmember cref="T:System.Reflection.AssemblyVersionAttribute" />
      </Docs>
    </Member>
    <Member MemberName="RaiseIdle">
      <MemberSignature Language="C#" Value="public static void RaiseIdle (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RaiseIdle(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.RaiseIdle(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RaiseIdle (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RaiseIdle(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="static member RaiseIdle : EventArgs -&gt; unit" Usage="System.Windows.Forms.Application.RaiseIdle e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" Index="0" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="6c90a-324">要传递给 <see cref="T:System.EventArgs" /> 事件的 <see cref="E:System.Windows.Forms.Application.Idle" /> 对象。</span><span class="sxs-lookup"><span data-stu-id="6c90a-324">The <see cref="T:System.EventArgs" /> objects to pass to the <see cref="E:System.Windows.Forms.Application.Idle" /> event.</span></span></param>
        <summary><span data-ttu-id="6c90a-325">在宿主方案中引发 <see cref="E:System.Windows.Forms.Application.Idle" /> 事件。</span><span class="sxs-lookup"><span data-stu-id="6c90a-325">Raises the <see cref="E:System.Windows.Forms.Application.Idle" /> event in hosted scenarios.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6c90a-326">在其他环境（例如非托管应用程序）中承载 Windows 窗体时使用此方法。</span><span class="sxs-lookup"><span data-stu-id="6c90a-326">This method is used when hosting Windows Forms in another environment, such as an unmanaged application.</span></span> <span data-ttu-id="6c90a-327"><xref:System.Windows.Forms.Application.RaiseIdle%2A>当宿主应用程序进入空闲状态时，应调用。</span><span class="sxs-lookup"><span data-stu-id="6c90a-327">You should call <xref:System.Windows.Forms.Application.RaiseIdle%2A> when the hosting application enters an idle state.</span></span> <span data-ttu-id="6c90a-328">这样，在用户不与应用程序交互时，某些 Windows 窗体控件和组件就可以执行重要的后台工作。</span><span class="sxs-lookup"><span data-stu-id="6c90a-328">This enables some Windows Forms controls and components to do important background work while the user is not interacting with the application.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Forms.Application.Idle" />
      </Docs>
    </Member>
    <Member MemberName="RegisterMessageLoop">
      <MemberSignature Language="C#" Value="public static void RegisterMessageLoop (System.Windows.Forms.Application.MessageLoopCallback callback);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterMessageLoop(class System.Windows.Forms.Application/MessageLoopCallback callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.RegisterMessageLoop(System.Windows.Forms.Application.MessageLoopCallback)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RegisterMessageLoop (callback As Application.MessageLoopCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RegisterMessageLoop(System::Windows::Forms::Application::MessageLoopCallback ^ callback);" />
      <MemberSignature Language="F#" Value="static member RegisterMessageLoop : System.Windows.Forms.Application.MessageLoopCallback -&gt; unit" Usage="System.Windows.Forms.Application.RegisterMessageLoop callback" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.Windows.Forms.Application+MessageLoopCallback" Index="0" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="callback"><span data-ttu-id="6c90a-329">当 Windows 窗体需要检查宿主环境是否仍在发送消息时，所要调用的方法。</span><span class="sxs-lookup"><span data-stu-id="6c90a-329">The method to call when Windows Forms needs to check if the hosting environment is still sending messages.</span></span></param>
        <summary><span data-ttu-id="6c90a-330">注册一个回调以检查消息循环是否正在宿主环境中运行。</span><span class="sxs-lookup"><span data-stu-id="6c90a-330">Registers a callback for checking whether the message loop is running in hosted environments.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6c90a-331">在其他环境（例如非托管应用程序）中承载 Windows 窗体时使用此方法。</span><span class="sxs-lookup"><span data-stu-id="6c90a-331">This method is used when hosting Windows Forms in another environment, such as an unmanaged application.</span></span> <span data-ttu-id="6c90a-332">在托管环境中， <xref:System.Windows.Forms.Application.MessageLoop%2A> 如果 Windows 窗体不处理消息，则该属性将始终返回 false。</span><span class="sxs-lookup"><span data-stu-id="6c90a-332">In hosted environments, the <xref:System.Windows.Forms.Application.MessageLoop%2A> property will always return false if Windows Forms is not processing messages.</span></span> <span data-ttu-id="6c90a-333">如果宿主环境仍在处理消息，请使用此回调来告知 Windows 窗体。</span><span class="sxs-lookup"><span data-stu-id="6c90a-333">Use this callback to tell Windows Forms if the hosting environment is still processing messages.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.Application.MessageLoopCallback" />
      </Docs>
    </Member>
    <Member MemberName="RemoveMessageFilter">
      <MemberSignature Language="C#" Value="public static void RemoveMessageFilter (System.Windows.Forms.IMessageFilter value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemoveMessageFilter(class System.Windows.Forms.IMessageFilter value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.RemoveMessageFilter(System.Windows.Forms.IMessageFilter)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RemoveMessageFilter (value As IMessageFilter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RemoveMessageFilter(System::Windows::Forms::IMessageFilter ^ value);" />
      <MemberSignature Language="F#" Value="static member RemoveMessageFilter : System.Windows.Forms.IMessageFilter -&gt; unit" Usage="System.Windows.Forms.Application.RemoveMessageFilter value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Windows.Forms.IMessageFilter" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="6c90a-334">要从应用程序移除的 <see cref="T:System.Windows.Forms.IMessageFilter" /> 的实现。</span><span class="sxs-lookup"><span data-stu-id="6c90a-334">The implementation of the <see cref="T:System.Windows.Forms.IMessageFilter" /> to remove from the application.</span></span></param>
        <summary><span data-ttu-id="6c90a-335">从应用程序的消息泵移除一个消息筛选器。</span><span class="sxs-lookup"><span data-stu-id="6c90a-335">Removes a message filter from the message pump of the application.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6c90a-336">当你不再想要在调度 Windows 消息之前捕获它们时，可以删除消息筛选器。</span><span class="sxs-lookup"><span data-stu-id="6c90a-336">You can remove a message filter when you no longer want to capture Windows messages before they are dispatched.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="6c90a-337">使用消息筛选器之前，必须提供接口的实现 <xref:System.Windows.Forms.IMessageFilter> 。</span><span class="sxs-lookup"><span data-stu-id="6c90a-337">Before you can use a message filter, you must provide an implementation for the <xref:System.Windows.Forms.IMessageFilter> interface.</span></span> <span data-ttu-id="6c90a-338">下面的类创建一个名为的消息筛选器 `TestMessageFilter` 。</span><span class="sxs-lookup"><span data-stu-id="6c90a-338">The following class creates a message filter called `TestMessageFilter`.</span></span> <span data-ttu-id="6c90a-339">此筛选器阻止与鼠标左键相关的所有消息。</span><span class="sxs-lookup"><span data-stu-id="6c90a-339">This filter blocks all messages relating to the left mouse button.</span></span>  
  
 [!code-cpp[Classic Application.RemoveMessageFilter Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.RemoveMessageFilter Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.RemoveMessageFilter Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.RemoveMessageFilter Example/CS/source.cs#1)]
 [!code-vb[Classic Application.RemoveMessageFilter Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.RemoveMessageFilter Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Application.AddMessageFilter(System.Windows.Forms.IMessageFilter)" />
      </Docs>
    </Member>
    <Member MemberName="RenderWithVisualStyles">
      <MemberSignature Language="C#" Value="public static bool RenderWithVisualStyles { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool RenderWithVisualStyles" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.RenderWithVisualStyles" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property RenderWithVisualStyles As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool RenderWithVisualStyles { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.RenderWithVisualStyles : bool" Usage="System.Windows.Forms.Application.RenderWithVisualStyles" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="6c90a-340">获取指定当前应用程序是否使用可视样式绘制控件的值。</span><span class="sxs-lookup"><span data-stu-id="6c90a-340">Gets a value specifying whether the current application is drawing controls with visual styles.</span></span></summary>
        <value><span data-ttu-id="6c90a-341">如果在应用程序窗口的工作区为控件启用了可视样式，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="6c90a-341"><see langword="true" /> if visual styles are enabled for controls in the client area of application windows; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6c90a-342">如果要绘制自定义控件，请使用此属性来决定是绘制具有还是不具有视觉样式的控件，使其外观与应用程序中的其他控件保持一致。</span><span class="sxs-lookup"><span data-stu-id="6c90a-342">If you are drawing a custom control, use this property to decide whether to draw the control with or without visual styles, so that its appearance is consistent with other controls in the application.</span></span>  
  
 <span data-ttu-id="6c90a-343">下表显示了返回时必须存在的四个条件 <xref:System.Windows.Forms.Application.RenderWithVisualStyles%2A> `true` 。</span><span class="sxs-lookup"><span data-stu-id="6c90a-343">The following table shows the four conditions that must exist for <xref:System.Windows.Forms.Application.RenderWithVisualStyles%2A> to return `true`.</span></span>  
  
|<span data-ttu-id="6c90a-344">条件</span><span class="sxs-lookup"><span data-stu-id="6c90a-344">Condition</span></span>|<span data-ttu-id="6c90a-345">说明</span><span class="sxs-lookup"><span data-stu-id="6c90a-345">Description</span></span>|  
|---------------|-----------------|  
|<span data-ttu-id="6c90a-346">操作系统支持视觉样式</span><span class="sxs-lookup"><span data-stu-id="6c90a-346">The operating system supports visual styles</span></span>|<span data-ttu-id="6c90a-347">若要单独验证这种情况，请使用 <xref:System.Windows.Forms.VisualStyles.VisualStyleInformation.IsSupportedByOS%2A> 类的 <xref:System.Windows.Forms.VisualStyles.VisualStyleInformation> 属性。</span><span class="sxs-lookup"><span data-stu-id="6c90a-347">To verify this condition separately, use the <xref:System.Windows.Forms.VisualStyles.VisualStyleInformation.IsSupportedByOS%2A> property of the <xref:System.Windows.Forms.VisualStyles.VisualStyleInformation> class.</span></span>|  
|<span data-ttu-id="6c90a-348">用户已在操作系统中启用视觉样式</span><span class="sxs-lookup"><span data-stu-id="6c90a-348">The user has enabled visual styles in the operating system</span></span>|<span data-ttu-id="6c90a-349">若要单独验证这种情况，请使用 <xref:System.Windows.Forms.VisualStyles.VisualStyleInformation.IsEnabledByUser%2A> 类的 <xref:System.Windows.Forms.VisualStyles.VisualStyleInformation> 属性。</span><span class="sxs-lookup"><span data-stu-id="6c90a-349">To verify this condition separately, use the <xref:System.Windows.Forms.VisualStyles.VisualStyleInformation.IsEnabledByUser%2A> property of the <xref:System.Windows.Forms.VisualStyles.VisualStyleInformation> class.</span></span>|  
|<span data-ttu-id="6c90a-350">在应用程序中启用视觉样式</span><span class="sxs-lookup"><span data-stu-id="6c90a-350">Visual styles are enabled in the application</span></span>|<span data-ttu-id="6c90a-351">可以通过调用 <xref:System.Windows.Forms.Application.EnableVisualStyles> 方法或使用指定用 ComCtl32.dll 版本 6 或更高版本绘制控件的应用程序清单来启用应用程序中的视觉样式。</span><span class="sxs-lookup"><span data-stu-id="6c90a-351">Visual styles can be enabled in an application by calling the <xref:System.Windows.Forms.Application.EnableVisualStyles> method or by using an application manifest that specifies that ComCtl32.dll version 6 or later will be used to draw controls.</span></span>|  
|<span data-ttu-id="6c90a-352">正在使用视觉样式来绘制应用程序窗口的工作区</span><span class="sxs-lookup"><span data-stu-id="6c90a-352">Visual styles are being used to draw the client area of application windows</span></span>|<span data-ttu-id="6c90a-353">若要单独验证这种情况，请使用 <xref:System.Windows.Forms.Application.VisualStyleState%2A> 类的 <xref:System.Windows.Forms.Application> 属性，验证它是否具有 <xref:System.Windows.Forms.VisualStyles.VisualStyleState.ClientAreaEnabled?displayProperty=nameWithType> 或 <xref:System.Windows.Forms.VisualStyles.VisualStyleState.ClientAndNonClientAreasEnabled?displayProperty=nameWithType>值。</span><span class="sxs-lookup"><span data-stu-id="6c90a-353">To verify this condition separately, use the <xref:System.Windows.Forms.Application.VisualStyleState%2A> property of the <xref:System.Windows.Forms.Application> class and verify that it has the value <xref:System.Windows.Forms.VisualStyles.VisualStyleState.ClientAreaEnabled?displayProperty=nameWithType> or <xref:System.Windows.Forms.VisualStyles.VisualStyleState.ClientAndNonClientAreasEnabled?displayProperty=nameWithType>.</span></span>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Restart">
      <MemberSignature Language="C#" Value="public static void Restart ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Restart() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.Restart" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Restart ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Restart();" />
      <MemberSignature Language="F#" Value="static member Restart : unit -&gt; unit" Usage="System.Windows.Forms.Application.Restart " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="6c90a-354">关闭应用程序并立即启动一个新实例。</span><span class="sxs-lookup"><span data-stu-id="6c90a-354">Shuts down the application and starts a new instance immediately.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6c90a-355">调用的最常见原因 `Restart` 是，使用或方法启动通过 ClickOnce 下载的新版本的应用程序 `Update` `UpdateAsync` 。</span><span class="sxs-lookup"><span data-stu-id="6c90a-355">The most common reason for calling `Restart` is to start a new version of the application that you have downloaded through ClickOnce using the `Update` or `UpdateAsync` method.</span></span>  
  
 <span data-ttu-id="6c90a-356">应用程序在其最初运行的上下文中重新启动。</span><span class="sxs-lookup"><span data-stu-id="6c90a-356">Applications are restarted in the context in which they were initially run.</span></span> <span data-ttu-id="6c90a-357">如果你的应用程序是使用直接指向应用程序的主要可执行文件的 URL 启动的，则将使用相同的 URL 重新启动该应用程序。</span><span class="sxs-lookup"><span data-stu-id="6c90a-357">If your application was started using a URL pointing directly to the application's main executable file, it will be restarted using the same URL.</span></span> <span data-ttu-id="6c90a-358">如果你的应用程序是 ClickOnce 应用程序，将使用 ClickOnce 重新启动该应用程序。</span><span class="sxs-lookup"><span data-stu-id="6c90a-358">If your application is a ClickOnce application, it will be restarted using ClickOnce.</span></span>  
  
 <span data-ttu-id="6c90a-359">如果你的应用程序最初是在执行时提供的命令行选项， <xref:System.Windows.Forms.Application.Restart%2A> 将再次用相同的选项启动该应用程序。</span><span class="sxs-lookup"><span data-stu-id="6c90a-359">If your application was originally supplied command-line options when it first executed, <xref:System.Windows.Forms.Application.Restart%2A> will launch the application again with the same options.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="6c90a-360">您的代码不是 Windows 窗体应用程序。</span><span class="sxs-lookup"><span data-stu-id="6c90a-360">Your code is not a Windows Forms application.</span></span> <span data-ttu-id="6c90a-361">不能在此上下文中调用此方法。</span><span class="sxs-lookup"><span data-stu-id="6c90a-361">You cannot call this method in this context.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Run">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="6c90a-362">在当前线程上开始运行标准应用程序消息循环。</span><span class="sxs-lookup"><span data-stu-id="6c90a-362">Begins running a standard application message loop on the current thread.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Run">
      <MemberSignature Language="C#" Value="public static void Run ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Run() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.Run" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Run ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Run();" />
      <MemberSignature Language="F#" Value="static member Run : unit -&gt; unit" Usage="System.Windows.Forms.Application.Run " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="6c90a-363">在没有窗体的情况下，在当前线程上开始运行标准应用程序消息循环。</span><span class="sxs-lookup"><span data-stu-id="6c90a-363">Begins running a standard application message loop on the current thread, without a form.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6c90a-364">在基于 Win32 的应用程序或 Windows 窗体的应用程序中，消息循环是处理用户事件（例如鼠标单击和键盘笔划）的代码例程。</span><span class="sxs-lookup"><span data-stu-id="6c90a-364">In a Win32-based or Windows Forms application, a message loop is a routine in code that processes user events, such as mouse clicks and keyboard strokes.</span></span> <span data-ttu-id="6c90a-365">每个正在运行的基于 Windows 的应用程序都需要一个活动消息循环（称为主消息循环）。</span><span class="sxs-lookup"><span data-stu-id="6c90a-365">Every running Windows-based application requires an active message loop, called the main message loop.</span></span> <span data-ttu-id="6c90a-366">关闭主消息循环后，应用程序将退出。</span><span class="sxs-lookup"><span data-stu-id="6c90a-366">When the main message loop is closed, the application exits.</span></span> <span data-ttu-id="6c90a-367">在 Windows 窗体中，当 <xref:System.Windows.Forms.Application.Exit%2A> 调用方法时或在 <xref:System.Windows.Forms.Application.ExitThread%2A> 运行主消息循环的线程上调用方法时，将关闭此循环。</span><span class="sxs-lookup"><span data-stu-id="6c90a-367">In Windows Forms, this loop is closed when the <xref:System.Windows.Forms.Application.Exit%2A> method is called, or when the <xref:System.Windows.Forms.Application.ExitThread%2A> method is called on the thread that is running the main message loop.</span></span>  
  
 <span data-ttu-id="6c90a-368">大多数 Windows 窗体开发人员都不需要使用此版本的方法。</span><span class="sxs-lookup"><span data-stu-id="6c90a-368">Most Windows Forms developers will not need to use this version of the method.</span></span> <span data-ttu-id="6c90a-369">应使用 <xref:System.Windows.Forms.Application.Run%28System.Windows.Forms.Form%29> 重载来启动具有主窗体的应用程序，以便应用程序在主窗体关闭时终止。</span><span class="sxs-lookup"><span data-stu-id="6c90a-369">You should use the <xref:System.Windows.Forms.Application.Run%28System.Windows.Forms.Form%29> overload to start an application with a main form, so that the application terminates when the main form is closed.</span></span> <span data-ttu-id="6c90a-370">对于所有其他情况，请使用 <xref:System.Windows.Forms.Application.Run%28System.Windows.Forms.ApplicationContext%29> 重载，该重载支持提供 <xref:System.Windows.Forms.ApplicationContext> 对象以更好地控制应用程序的生存期。</span><span class="sxs-lookup"><span data-stu-id="6c90a-370">For all other situations, use the <xref:System.Windows.Forms.Application.Run%28System.Windows.Forms.ApplicationContext%29> overload, which supports supplying an <xref:System.Windows.Forms.ApplicationContext> object for better control over the lifetime of the application.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="6c90a-371">主消息循环已在此线程上运行。</span><span class="sxs-lookup"><span data-stu-id="6c90a-371">A main message loop is already running on this thread.</span></span></exception>
        <altmember cref="M:System.Windows.Forms.Application.Exit" />
        <altmember cref="M:System.Windows.Forms.Application.ExitThread" />
        <altmember cref="M:System.Windows.Forms.Application.DoEvents" />
      </Docs>
    </Member>
    <Member MemberName="Run">
      <MemberSignature Language="C#" Value="public static void Run (System.Windows.Forms.ApplicationContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Run(class System.Windows.Forms.ApplicationContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.Run(System.Windows.Forms.ApplicationContext)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Run (context As ApplicationContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Run(System::Windows::Forms::ApplicationContext ^ context);" />
      <MemberSignature Language="F#" Value="static member Run : System.Windows.Forms.ApplicationContext -&gt; unit" Usage="System.Windows.Forms.Application.Run context" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="context" Type="System.Windows.Forms.ApplicationContext" />
      </Parameters>
      <Docs>
        <param name="context"><span data-ttu-id="6c90a-372">一个 <see cref="T:System.Windows.Forms.ApplicationContext" />，应用程序将在其中运行。</span><span class="sxs-lookup"><span data-stu-id="6c90a-372">An <see cref="T:System.Windows.Forms.ApplicationContext" /> in which the application is run.</span></span></param>
        <summary><span data-ttu-id="6c90a-373">在特定的 <see cref="T:System.Windows.Forms.ApplicationContext" /> 中，在当前线程上开始运行标准应用程序消息循环。</span><span class="sxs-lookup"><span data-stu-id="6c90a-373">Begins running a standard application message loop on the current thread, with an <see cref="T:System.Windows.Forms.ApplicationContext" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6c90a-374">消息循环运行到或之前， <xref:System.Windows.Forms.Application.Exit%2A> <xref:System.Windows.Forms.Application.ExitThread%2A> 或者在 <xref:System.Windows.Forms.Application.ThreadExit> 上下文对象上引发了事件。</span><span class="sxs-lookup"><span data-stu-id="6c90a-374">The message loop runs until <xref:System.Windows.Forms.Application.Exit%2A> or <xref:System.Windows.Forms.Application.ExitThread%2A> is called or the <xref:System.Windows.Forms.Application.ThreadExit> event is raised on the context object.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="6c90a-375">该示例显示两个窗体并在两个窗体关闭时退出应用程序。</span><span class="sxs-lookup"><span data-stu-id="6c90a-375">The example displays two forms and exits the application when both forms are closed.</span></span> <span data-ttu-id="6c90a-376">当应用程序启动和退出时，将记住每个窗体的位置。</span><span class="sxs-lookup"><span data-stu-id="6c90a-376">When the application starts and exits, the position of each form is remembered.</span></span> <span data-ttu-id="6c90a-377">此示例演示如何使用和 <xref:System.Windows.Forms.ApplicationContext> `Application.Run(context)` 方法在应用程序启动时显示多个窗体。</span><span class="sxs-lookup"><span data-stu-id="6c90a-377">This example demonstrates how to use an <xref:System.Windows.Forms.ApplicationContext>, along with the `Application.Run(context)` method, to display multiple forms when the application starts.</span></span>  
  
 <span data-ttu-id="6c90a-378">类 `MyApplicationContext` 从继承， <xref:System.Windows.Forms.ApplicationContext> 并在每个窗体关闭时保持跟踪，并在两个窗体关闭时保持跟踪，并在两个窗体均</span><span class="sxs-lookup"><span data-stu-id="6c90a-378">The class `MyApplicationContext` inherits from <xref:System.Windows.Forms.ApplicationContext> and keeps track when each form is closed, and exits the current thread when they both are.</span></span> <span data-ttu-id="6c90a-379">类存储用户的每个窗体的位置。</span><span class="sxs-lookup"><span data-stu-id="6c90a-379">The class stores the positions of each form for the user.</span></span> <span data-ttu-id="6c90a-380">窗体位置数据存储在名为的文件中 `Appdata.txt` ，该文件在由确定的位置创建 <xref:System.Windows.Forms.Application.UserAppDataPath%2A> 。</span><span class="sxs-lookup"><span data-stu-id="6c90a-380">The form position data is stored in a file titled `Appdata.txt` that is created in the location determined by <xref:System.Windows.Forms.Application.UserAppDataPath%2A>.</span></span> <span data-ttu-id="6c90a-381">`Main`方法调用 `Application.Run(context)` 来启动给定的应用程序 <xref:System.Windows.Forms.ApplicationContext> 。</span><span class="sxs-lookup"><span data-stu-id="6c90a-381">The `Main` method calls `Application.Run(context)` to start the application given the <xref:System.Windows.Forms.ApplicationContext>.</span></span>  
  
 <span data-ttu-id="6c90a-382">出于 `AppForm1` 简洁的目的， `AppForm2` 不显示和窗体的代码。</span><span class="sxs-lookup"><span data-stu-id="6c90a-382">The code for the `AppForm1` and `AppForm2` forms is not shown for the purpose of brevity.</span></span> <span data-ttu-id="6c90a-383"><xref:System.Windows.Forms.ApplicationContext>有关完整的代码清单，请参阅类概述。</span><span class="sxs-lookup"><span data-stu-id="6c90a-383">See the <xref:System.Windows.Forms.ApplicationContext> class overview for the whole code listing.</span></span>  
  
 [!code-cpp[Application#2](~/samples/snippets/cpp/VS_Snippets_Winforms/Application/CPP/source.cpp#2)]
 [!code-csharp[Application#2](~/samples/snippets/csharp/VS_Snippets_Winforms/Application/CS/source.cs#2)]
 [!code-vb[Application#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Application/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="6c90a-384">主消息循环已在此线程上运行。</span><span class="sxs-lookup"><span data-stu-id="6c90a-384">A main message loop is already running on this thread.</span></span></exception>
        <altmember cref="M:System.Windows.Forms.Application.Exit" />
        <altmember cref="M:System.Windows.Forms.Application.ExitThread" />
        <altmember cref="M:System.Windows.Forms.Application.DoEvents" />
      </Docs>
    </Member>
    <Member MemberName="Run">
      <MemberSignature Language="C#" Value="public static void Run (System.Windows.Forms.Form mainForm);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Run(class System.Windows.Forms.Form mainForm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.Run(System.Windows.Forms.Form)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Run (mainForm As Form)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Run(System::Windows::Forms::Form ^ mainForm);" />
      <MemberSignature Language="F#" Value="static member Run : System.Windows.Forms.Form -&gt; unit" Usage="System.Windows.Forms.Application.Run mainForm" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mainForm" Type="System.Windows.Forms.Form" />
      </Parameters>
      <Docs>
        <param name="mainForm"><span data-ttu-id="6c90a-385">一个 <see cref="T:System.Windows.Forms.Form" />，它代表要使之可见的窗体。</span><span class="sxs-lookup"><span data-stu-id="6c90a-385">A <see cref="T:System.Windows.Forms.Form" /> that represents the form to make visible.</span></span></param>
        <summary><span data-ttu-id="6c90a-386">在当前线程上开始运行标准应用程序消息循环，并使指定窗体可见。</span><span class="sxs-lookup"><span data-stu-id="6c90a-386">Begins running a standard application message loop on the current thread, and makes the specified form visible.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6c90a-387">通常，应用程序的主要功能调用此方法并向其传递应用程序的主窗口。</span><span class="sxs-lookup"><span data-stu-id="6c90a-387">Typically, the main function of an application calls this method and passes to it the main window of the application.</span></span>  
  
 <span data-ttu-id="6c90a-388">此方法将事件处理程序添加到 `mainForm` 事件的参数 <xref:System.Windows.Forms.Form.Closed> 。</span><span class="sxs-lookup"><span data-stu-id="6c90a-388">This method adds an event handler to the `mainForm` parameter for the <xref:System.Windows.Forms.Form.Closed> event.</span></span> <span data-ttu-id="6c90a-389">事件处理程序调用 <xref:System.Windows.Forms.Application.ExitThread%2A> 来清理应用程序。</span><span class="sxs-lookup"><span data-stu-id="6c90a-389">The event handler calls <xref:System.Windows.Forms.Application.ExitThread%2A> to clean up the application.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="6c90a-390">在 <xref:System.Windows.Forms.Control.Dispose%2A> <xref:System.Windows.Forms.Form> 返回此方法之前，将调用类的方法。</span><span class="sxs-lookup"><span data-stu-id="6c90a-390">The <xref:System.Windows.Forms.Control.Dispose%2A> method of the <xref:System.Windows.Forms.Form> class will be called prior to the return of this method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="6c90a-391">下面的代码示例在窗体上的列表框中列出了数字。</span><span class="sxs-lookup"><span data-stu-id="6c90a-391">The following code example lists numbers in a list box on a form.</span></span> <span data-ttu-id="6c90a-392">每次单击时 `button1` ，应用程序都会向列表中添加一个编号。</span><span class="sxs-lookup"><span data-stu-id="6c90a-392">Each time you click `button1`, the application adds another number to the list.</span></span>  
  
 <span data-ttu-id="6c90a-393">`Main`方法调用 <xref:System.Windows.Forms.Application.Run%2A> 以启动应用程序，该应用程序将创建窗体、 `listBox1` 和 `button1` 。</span><span class="sxs-lookup"><span data-stu-id="6c90a-393">The `Main` method calls <xref:System.Windows.Forms.Application.Run%2A> to start the application, which creates the form, `listBox1`, and `button1`.</span></span> <span data-ttu-id="6c90a-394">用户单击时 `button1` ，该方法会向 `button1_Click` 列表框中添加一个到三个数字，并显示 <xref:System.Windows.Forms.MessageBox> 。</span><span class="sxs-lookup"><span data-stu-id="6c90a-394">When the user clicks `button1`, the `button1_Click` method adds numbers one to three to the list box, and displays a <xref:System.Windows.Forms.MessageBox>.</span></span> <span data-ttu-id="6c90a-395">如果用户单击上的 " **否** " <xref:System.Windows.Forms.MessageBox> ，则该 `button1_Click` 方法将向列表中添加另一个数字。</span><span class="sxs-lookup"><span data-stu-id="6c90a-395">If the user clicks **No** on the <xref:System.Windows.Forms.MessageBox>, the `button1_Click` method adds another number to the list.</span></span> <span data-ttu-id="6c90a-396">如果用户单击 **"是"**，应用程序将调用 <xref:System.Windows.Forms.Application.Exit%2A> 来处理队列中所有剩余的消息，然后退出。</span><span class="sxs-lookup"><span data-stu-id="6c90a-396">If the user clicks **Yes**, the application calls <xref:System.Windows.Forms.Application.Exit%2A> to process all remaining messages in the queue and then to quit.</span></span>  
  
 <span data-ttu-id="6c90a-397">该示例要求 `listBox1` 和已 `button1` 创建并放置在窗体上。</span><span class="sxs-lookup"><span data-stu-id="6c90a-397">The example requires that `listBox1` and `button1` have been created and placed on a form.</span></span>  
  
 [!code-cpp[Classic Application.Exit Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.Exit Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.Exit Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.Exit Example/CS/source.cs#1)]
 [!code-vb[Classic Application.Exit Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.Exit Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="6c90a-398">主消息循环已在当前线程上运行。</span><span class="sxs-lookup"><span data-stu-id="6c90a-398">A main message loop is already running on the current thread.</span></span></exception>
        <altmember cref="M:System.Windows.Forms.Application.Exit" />
        <altmember cref="M:System.Windows.Forms.Application.ExitThread" />
        <altmember cref="M:System.Windows.Forms.Application.DoEvents" />
      </Docs>
    </Member>
    <Member MemberName="SafeTopLevelCaptionFormat">
      <MemberSignature Language="C#" Value="public static string SafeTopLevelCaptionFormat { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property string SafeTopLevelCaptionFormat" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.SafeTopLevelCaptionFormat" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property SafeTopLevelCaptionFormat As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ SafeTopLevelCaptionFormat { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.SafeTopLevelCaptionFormat : string with get, set" Usage="System.Windows.Forms.Application.SafeTopLevelCaptionFormat" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="6c90a-399">获取或设置当顶级窗口标题与版权警告标志一起显示时，要应用于顶级窗口标题的格式字符串。</span><span class="sxs-lookup"><span data-stu-id="6c90a-399">Gets or sets the format string to apply to top-level window captions when they are displayed with a warning banner.</span></span></summary>
        <value><span data-ttu-id="6c90a-400">要应用于顶级窗口标题的格式字符串。</span><span class="sxs-lookup"><span data-stu-id="6c90a-400">The format string to apply to top-level window captions.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetCompatibleTextRenderingDefault">
      <MemberSignature Language="C#" Value="public static void SetCompatibleTextRenderingDefault (bool defaultValue);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetCompatibleTextRenderingDefault(bool defaultValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.SetCompatibleTextRenderingDefault(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetCompatibleTextRenderingDefault (defaultValue As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetCompatibleTextRenderingDefault(bool defaultValue);" />
      <MemberSignature Language="F#" Value="static member SetCompatibleTextRenderingDefault : bool -&gt; unit" Usage="System.Windows.Forms.Application.SetCompatibleTextRenderingDefault defaultValue" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Boolean" Index="0" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="defaultValue"><span data-ttu-id="6c90a-401">用于新控件的默认值。</span><span class="sxs-lookup"><span data-stu-id="6c90a-401">The default value to use for new controls.</span></span> <span data-ttu-id="6c90a-402">如果 <see langword="true" /> 为，则支持 <c>UseCompatibleTextRendering</c> 的新控件使用基于 gdi + 的 <see cref="T:System.Drawing.Graphics" /> 类进行文本呈现; 如果为 <see langword="false" /> ，则新控件使用基于 gdi 的 <see cref="T:System.Windows.Forms.TextRenderer" /> 类。</span><span class="sxs-lookup"><span data-stu-id="6c90a-402">If <see langword="true" />, new controls that support <c>UseCompatibleTextRendering</c> use the GDI+ based <see cref="T:System.Drawing.Graphics" /> class for text rendering; if <see langword="false" />, new controls use the GDI based <see cref="T:System.Windows.Forms.TextRenderer" /> class.</span></span></param>
        <summary><span data-ttu-id="6c90a-403">将某些控件上定义的 <c>UseCompatibleTextRendering</c> 属性设置为应用程序范围内的默认值。</span><span class="sxs-lookup"><span data-stu-id="6c90a-403">Sets the application-wide default for the <c>UseCompatibleTextRendering</c> property defined on certain controls.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6c90a-404">某些 Windows 窗体控件可以使用 <xref:System.Windows.Forms.TextRenderer> 基于 gdi 图形库的类或 <xref:System.Drawing.Graphics> 基于 gdi + 图形库的类呈现其文本。</span><span class="sxs-lookup"><span data-stu-id="6c90a-404">Certain Windows Forms controls can render their text using either the <xref:System.Windows.Forms.TextRenderer> class, which is based on the GDI graphics library, or the <xref:System.Drawing.Graphics> class, which is based on the GDI+ graphics library.</span></span> <span data-ttu-id="6c90a-405">由于 GDI + 的性能和本地化问题，在 .NET Framework 2.0 中进行了此更改。</span><span class="sxs-lookup"><span data-stu-id="6c90a-405">This change was made in the .NET Framework 2.0 because of performance and localization issues with GDI+.</span></span> <span data-ttu-id="6c90a-406">用于 <xref:System.Windows.Forms.Application.SetCompatibleTextRenderingDefault%2A> 为支持控件的控件设置属性的默认值 `UseCompatibleTextRendering` 。</span><span class="sxs-lookup"><span data-stu-id="6c90a-406">Use <xref:System.Windows.Forms.Application.SetCompatibleTextRenderingDefault%2A> to set the default value of the `UseCompatibleTextRendering` property for controls that support it.</span></span>  
  
 <span data-ttu-id="6c90a-407">`UseCompatibleTextRendering`属性旨在提供 Windows 窗体控件之间的视觉兼容性，这些控件使用类呈现文本 <xref:System.Windows.Forms.TextRenderer> ，.NET Framework 1.0 和使用类执行自定义文本呈现的 .NET Framework 1.1 应用程序之间的兼容性 <xref:System.Drawing.Graphics> 。</span><span class="sxs-lookup"><span data-stu-id="6c90a-407">The `UseCompatibleTextRendering` property is intended to provide visual compatibility between Windows Forms controls that render text using the <xref:System.Windows.Forms.TextRenderer> class and .NET Framework 1.0 and .NET Framework 1.1 applications that perform custom text rendering using the <xref:System.Drawing.Graphics> class.</span></span> <span data-ttu-id="6c90a-408">在大多数情况下，如果你的应用程序不是从 .NET Framework 1.0 或 .NET Framework 1.1 升级，则建议你将 `UseCompatibleTextRendering` 设置为的默认值 `false` 。</span><span class="sxs-lookup"><span data-stu-id="6c90a-408">In most cases, if your application is not being upgraded from .NET Framework 1.0 or .NET Framework 1.1, it is recommended that you leave `UseCompatibleTextRendering` set to the default value of `false`.</span></span>  
  
 <span data-ttu-id="6c90a-409"><xref:System.Windows.Forms.TextRenderer>.NET Framework 2.0 中引入了基于 GDI 的类，以提高性能，使文本更好地显示，并改善对国际字体的支持。</span><span class="sxs-lookup"><span data-stu-id="6c90a-409">The GDI based <xref:System.Windows.Forms.TextRenderer> class was introduced in the .NET Framework 2.0 to improve performance, make text look better, and improve support for international fonts.</span></span> <span data-ttu-id="6c90a-410">在 .NET Framework 的早期版本中，使用基于 GDI + 的 <xref:System.Drawing.Graphics> 类来执行所有文本呈现。</span><span class="sxs-lookup"><span data-stu-id="6c90a-410">In earlier versions of the .NET Framework, the GDI+ based <xref:System.Drawing.Graphics> class was used to perform all text rendering.</span></span> <span data-ttu-id="6c90a-411">GDI 用不同于 GDI + 计算字符间距和自动换行。</span><span class="sxs-lookup"><span data-stu-id="6c90a-411">GDI calculates character spacing and word wrapping differently from GDI+.</span></span> <span data-ttu-id="6c90a-412">在使用类呈现文本的 Windows 窗体应用程序中 <xref:System.Drawing.Graphics> ，这可能会导致使用的控件的文本与 <xref:System.Windows.Forms.TextRenderer> 应用程序中的其他文本显示不相同。</span><span class="sxs-lookup"><span data-stu-id="6c90a-412">In a Windows Forms application that uses the <xref:System.Drawing.Graphics> class to render text, this could cause the text for controls that use <xref:System.Windows.Forms.TextRenderer> to appear different from the other text in the application.</span></span> <span data-ttu-id="6c90a-413">若要解决这种不兼容性问题，可将 `UseCompatibleTextRendering` 属性设置为 `true` 。</span><span class="sxs-lookup"><span data-stu-id="6c90a-413">To resolve this incompatibility, you can set the `UseCompatibleTextRendering` property to `true`.</span></span> <span data-ttu-id="6c90a-414">若要 `UseCompatibleTextRendering` `true` 为应用程序中的所有受支持的控件设置，请 <xref:System.Windows.Forms.Application.SetCompatibleTextRenderingDefault%2A> 使用参数调用方法 `true` 。</span><span class="sxs-lookup"><span data-stu-id="6c90a-414">To set `UseCompatibleTextRendering` to `true` for all supported controls in the application, call the <xref:System.Windows.Forms.Application.SetCompatibleTextRenderingDefault%2A> method with a parameter of `true`.</span></span>  
  
 <span data-ttu-id="6c90a-415">如果 Windows 窗体代码承载于其他应用程序（如 Internet Explorer）中，则永远不应调用此方法。</span><span class="sxs-lookup"><span data-stu-id="6c90a-415">You should never call this method if your Windows Forms code is hosted in another application, such as Internet Explorer.</span></span> <span data-ttu-id="6c90a-416">仅在独立 Windows 窗体应用程序中调用此方法。</span><span class="sxs-lookup"><span data-stu-id="6c90a-416">Only call this method in stand-alone Windows Forms applications.</span></span>  
  
   
  
## Examples  
  
> [!IMPORTANT]
>  <span data-ttu-id="6c90a-417">若要 `UseCompatibleTextRendering` 在 Visual Basic 2005 或更高版本中设置的默认值，请参阅 <xref:Microsoft.VisualBasic.ApplicationServices.WindowsFormsApplicationBase.UseCompatibleTextRendering%2A?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="6c90a-417">To set the default value for `UseCompatibleTextRendering` in Visual Basic 2005 or later, see <xref:Microsoft.VisualBasic.ApplicationServices.WindowsFormsApplicationBase.UseCompatibleTextRendering%2A?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="6c90a-418">在 Visual c # 2005 或更高版本中，对的调用 <xref:System.Windows.Forms.Application.SetCompatibleTextRenderingDefault%2A> 是在 Program.cs 文件中自动生成的。</span><span class="sxs-lookup"><span data-stu-id="6c90a-418">In Visual C# 2005 or later, a call to <xref:System.Windows.Forms.Application.SetCompatibleTextRenderingDefault%2A> is automatically generated in the Program.cs file.</span></span> <span data-ttu-id="6c90a-419">若要更改文本呈现默认值，请修改生成的代码。</span><span class="sxs-lookup"><span data-stu-id="6c90a-419">To change the text rendering default, modify the generated code.</span></span>  
  
```csharp  
static class Program  
{  
    /// <summary>  
    /// The main entry point for the application.  
    /// </summary>  
    [STAThread]  
    static void Main()  
    {  
        Application.EnableVisualStyles();  
        Application.SetCompatibleTextRenderingDefault(false);  
        Application.Run(new Form1());  
    }  
}  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="6c90a-420">您只能在 Windows 窗体应用程序创建第一个窗口之前调用此方法。</span><span class="sxs-lookup"><span data-stu-id="6c90a-420">You can only call this method before the first window is created by your Windows Forms application.</span></span></exception>
        <altmember cref="P:System.Windows.Forms.ButtonBase.UseCompatibleTextRendering" />
        <altmember cref="P:System.Windows.Forms.CheckedListBox.UseCompatibleTextRendering" />
        <altmember cref="P:System.Windows.Forms.GroupBox.UseCompatibleTextRendering" />
        <altmember cref="P:System.Windows.Forms.Label.UseCompatibleTextRendering" />
        <altmember cref="P:System.Windows.Forms.LinkLabel.UseCompatibleTextRendering" />
        <altmember cref="P:System.Windows.Forms.PropertyGrid.UseCompatibleTextRendering" />
        <altmember cref="P:Microsoft.VisualBasic.ApplicationServices.WindowsFormsApplicationBase.UseCompatibleTextRendering" />
        <altmember cref="M:System.Drawing.Text.PrivateFontCollection.AddMemoryFont(System.IntPtr,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="SetHighDpiMode">
      <MemberSignature Language="C#" Value="public static bool SetHighDpiMode (System.Windows.Forms.HighDpiMode highDpiMode);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SetHighDpiMode(valuetype System.Windows.Forms.HighDpiMode highDpiMode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.SetHighDpiMode(System.Windows.Forms.HighDpiMode)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SetHighDpiMode (highDpiMode As HighDpiMode) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SetHighDpiMode(System::Windows::Forms::HighDpiMode highDpiMode);" />
      <MemberSignature Language="F#" Value="static member SetHighDpiMode : System.Windows.Forms.HighDpiMode -&gt; bool" Usage="System.Windows.Forms.Application.SetHighDpiMode highDpiMode" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="highDpiMode" Type="System.Windows.Forms.HighDpiMode" Index="0" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="highDpiMode"><span data-ttu-id="6c90a-421">枚举值之一，用于指定要设置的高 DPI 模式。</span><span class="sxs-lookup"><span data-stu-id="6c90a-421">One of the enumeration values that specifies the high DPI mode to set.</span></span></param>
        <summary><span data-ttu-id="6c90a-422">设置进程的高 DPI 模式。</span><span class="sxs-lookup"><span data-stu-id="6c90a-422">Sets the high DPI mode of the process.</span></span></summary>
        <returns><span data-ttu-id="6c90a-423">如果设置了高 DPI 模式，则 <see langword="true" />；否则 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="6c90a-423"><see langword="true" /> if the high DPI mode was set; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

<span data-ttu-id="6c90a-424">如果应用程序具有应用程序清单文件，并且该文件中设置了 DPI 模式，则此方法将无法设置或更改应用程序清单已设置的模式。</span><span class="sxs-lookup"><span data-stu-id="6c90a-424">If an application carries an application manifest file and the DPI mode was set in that file, this method will fail to set or change the mode that was already set by the application manifest.</span></span> <span data-ttu-id="6c90a-425">高 DPI 模式是每个进程设置一次的。</span><span class="sxs-lookup"><span data-stu-id="6c90a-425">The high DPI mode is set once per process.</span></span> <span data-ttu-id="6c90a-426">有关通过应用程序清单文件设置 DPI 模式的详细信息，请参阅 [设置进程的默认 dpi 感知](https://docs.microsoft.com/previous-versions/windows/desktop/legacy/mt846517(v%3Dvs.85))。</span><span class="sxs-lookup"><span data-stu-id="6c90a-426">For more information about setting the DPI mode via the application manifest file, see [Setting the default DPI awareness for a process](https://docs.microsoft.com/previous-versions/windows/desktop/legacy/mt846517(v%3Dvs.85)).</span></span>

  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetSuspendState">
      <MemberSignature Language="C#" Value="public static bool SetSuspendState (System.Windows.Forms.PowerState state, bool force, bool disableWakeEvent);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SetSuspendState(valuetype System.Windows.Forms.PowerState state, bool force, bool disableWakeEvent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.SetSuspendState(System.Windows.Forms.PowerState,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SetSuspendState (state As PowerState, force As Boolean, disableWakeEvent As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SetSuspendState(System::Windows::Forms::PowerState state, bool force, bool disableWakeEvent);" />
      <MemberSignature Language="F#" Value="static member SetSuspendState : System.Windows.Forms.PowerState * bool * bool -&gt; bool" Usage="System.Windows.Forms.Application.SetSuspendState (state, force, disableWakeEvent)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Windows.Forms.PowerState" Index="0" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="force" Type="System.Boolean" Index="1" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="disableWakeEvent" Type="System.Boolean" Index="2" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="state"><span data-ttu-id="6c90a-427">指示要转换到的目标电源活动模式的 <see cref="T:System.Windows.Forms.PowerState" />。</span><span class="sxs-lookup"><span data-stu-id="6c90a-427">A <see cref="T:System.Windows.Forms.PowerState" /> indicating the power activity mode to which to transition.</span></span></param>
        <param name="force"><span data-ttu-id="6c90a-428">若要立即强制挂起模式，则为 <see langword="true" />；若要使 Windows 向每个应用程序发送挂起请求，则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="6c90a-428"><see langword="true" /> to force the suspended mode immediately; <see langword="false" /> to cause Windows to send a suspend request to every application.</span></span></param>
        <param name="disableWakeEvent"><span data-ttu-id="6c90a-429">值为 <see langword="true" /> 时可在发生唤醒事件时禁止将系统的电源状态恢复为活动状态；值为 <see langword="false" /> 时可在发生唤醒事件时允许将系统的电源状态恢复为活动状态。</span><span class="sxs-lookup"><span data-stu-id="6c90a-429"><see langword="true" /> to disable restoring the system's power status to active on a wake event, <see langword="false" /> to enable restoring the system's power status to active on a wake event.</span></span></param>
        <summary><span data-ttu-id="6c90a-430">挂起系统或使系统休眠，或者请求系统挂起或休眠。</span><span class="sxs-lookup"><span data-stu-id="6c90a-430">Suspends or hibernates the system, or requests that the system be suspended or hibernated.</span></span></summary>
        <returns><span data-ttu-id="6c90a-431">如果正在挂起该系统，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="6c90a-431"><see langword="true" /> if the system is being suspended, otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6c90a-432">如果应用程序在20秒内未响应挂起请求，则 Windows 会确定它处于非响应状态，并且可以将应用程序置于睡眠状态或终止状态。</span><span class="sxs-lookup"><span data-stu-id="6c90a-432">If an application does not respond to a suspend request within 20 seconds, Windows determines that it is in a non-responsive state, and that the application can either be put to sleep or terminated.</span></span> <span data-ttu-id="6c90a-433">但是，应用程序响应挂起请求后，它可能需要清理资源并关闭活动进程所需的任何时间。</span><span class="sxs-lookup"><span data-stu-id="6c90a-433">Once an application responds to a suspend request, however, it can take whatever time it needs to clean up resources and shut down active processes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.PowerState" />
      </Docs>
    </Member>
    <MemberGroup MemberName="SetUnhandledExceptionMode">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="6c90a-434">指示应用程序如何响应未经处理的异常。</span><span class="sxs-lookup"><span data-stu-id="6c90a-434">Instructs the application how to respond to unhandled exceptions.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="6c90a-435">下面的代码示例为在 Windows 窗体线程上发生的异常和其他线程上发生的异常设置事件处理程序。</span><span class="sxs-lookup"><span data-stu-id="6c90a-435">The following code example sets event handlers for exceptions that occur on Windows Forms threads and exceptions that occur on other threads.</span></span> <span data-ttu-id="6c90a-436">此设置 <xref:System.Windows.Forms.Application.SetUnhandledExceptionMode%2A> 使所有异常都由应用程序处理，而不考虑应用程序的用户配置文件中的设置。</span><span class="sxs-lookup"><span data-stu-id="6c90a-436">It sets <xref:System.Windows.Forms.Application.SetUnhandledExceptionMode%2A> so that all exceptions are handled by the application, regardless of the settings in the application's user configuration file.</span></span> <span data-ttu-id="6c90a-437">它使用 <xref:System.Windows.Forms.Application.ThreadException> 事件来处理 UI 线程异常，并使用 <xref:System.AppDomain.UnhandledException> 事件来处理非 ui 线程异常。</span><span class="sxs-lookup"><span data-stu-id="6c90a-437">It uses the <xref:System.Windows.Forms.Application.ThreadException> event to handle UI thread exceptions, and the <xref:System.AppDomain.UnhandledException> event to handle non-UI thread exceptions.</span></span> <span data-ttu-id="6c90a-438">由于 <xref:System.AppDomain.UnhandledException> 无法阻止应用程序终止，因此该示例只是在终止之前将错误记录在应用程序事件日志中。</span><span class="sxs-lookup"><span data-stu-id="6c90a-438">Since <xref:System.AppDomain.UnhandledException> cannot prevent an application from terminating, the example simply logs the error in the application event log before termination.</span></span>  
  
 <span data-ttu-id="6c90a-439">此示例假设你已在类上定义了两个 <xref:System.Windows.Forms.Button> 控件： `button1` 和 `button2` <xref:System.Windows.Forms.Form> 。</span><span class="sxs-lookup"><span data-stu-id="6c90a-439">This example assumes that you have defined two <xref:System.Windows.Forms.Button> controls, `button1` and `button2`, on your <xref:System.Windows.Forms.Form> class.</span></span>  
  
 [!code-cpp[Classic Application.ThreadException Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.ThreadException Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.ThreadException Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.ThreadException Example/CS/source.cs#1)]
 [!code-vb[Classic Application.ThreadException Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.ThreadException Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetUnhandledExceptionMode">
      <MemberSignature Language="C#" Value="public static void SetUnhandledExceptionMode (System.Windows.Forms.UnhandledExceptionMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetUnhandledExceptionMode(valuetype System.Windows.Forms.UnhandledExceptionMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.SetUnhandledExceptionMode(System.Windows.Forms.UnhandledExceptionMode)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetUnhandledExceptionMode (mode As UnhandledExceptionMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetUnhandledExceptionMode(System::Windows::Forms::UnhandledExceptionMode mode);" />
      <MemberSignature Language="F#" Value="static member SetUnhandledExceptionMode : System.Windows.Forms.UnhandledExceptionMode -&gt; unit" Usage="System.Windows.Forms.Application.SetUnhandledExceptionMode mode" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mode" Type="System.Windows.Forms.UnhandledExceptionMode" Index="0" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="mode"><span data-ttu-id="6c90a-440">一个 <see cref="T:System.Windows.Forms.UnhandledExceptionMode" /> 值，描述在引发未捕获的异常时应用程序的行为方式。</span><span class="sxs-lookup"><span data-stu-id="6c90a-440">An <see cref="T:System.Windows.Forms.UnhandledExceptionMode" /> value describing how the application should behave if an exception is thrown without being caught.</span></span></param>
        <summary><span data-ttu-id="6c90a-441">指示应用程序如何响应未经处理的异常。</span><span class="sxs-lookup"><span data-stu-id="6c90a-441">Instructs the application how to respond to unhandled exceptions.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6c90a-442">捕获 Windows 窗体引发的所有异常通常是不切实际的。</span><span class="sxs-lookup"><span data-stu-id="6c90a-442">It is often not feasible to catch all of the exceptions thrown by Windows Forms.</span></span> <span data-ttu-id="6c90a-443">使用此方法，你可以指示应用程序是应该捕获由 Windows 窗体组件引发的所有未处理异常并继续运行，还是应将它们公开给用户并暂停执行。</span><span class="sxs-lookup"><span data-stu-id="6c90a-443">Using this method, you can instruct your application whether it should catch all unhandled exceptions thrown by Windows Forms components and continue operating, or whether it should expose them to the user and halt execution.</span></span>  
  
 <span data-ttu-id="6c90a-444"><xref:System.Windows.Forms.Application.SetUnhandledExceptionMode%2A>使用方法实例化应用程序的主窗体之前，请调用 <xref:System.Windows.Forms.Application.Run%2A> 。</span><span class="sxs-lookup"><span data-stu-id="6c90a-444">Call <xref:System.Windows.Forms.Application.SetUnhandledExceptionMode%2A> before you instantiate the main form of your application using the <xref:System.Windows.Forms.Application.Run%2A> method.</span></span>  
  
 <span data-ttu-id="6c90a-445">若要捕获不是由 Windows 窗体创建并拥有的线程中发生的异常，请使用 <xref:System.AppDomain.UnhandledException> 事件处理程序。</span><span class="sxs-lookup"><span data-stu-id="6c90a-445">To catch exceptions that occur in threads not created and owned by Windows Forms, use the <xref:System.AppDomain.UnhandledException> event handler.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="6c90a-446">下面的代码示例为在 Windows 窗体线程上发生的异常和其他线程上发生的异常设置事件处理程序。</span><span class="sxs-lookup"><span data-stu-id="6c90a-446">The following code example sets event handlers for exceptions that occur on Windows Forms threads and exceptions that occur on other threads.</span></span> <span data-ttu-id="6c90a-447">此设置 <xref:System.Windows.Forms.Application.SetUnhandledExceptionMode%2A> 使所有异常都由应用程序处理，而不考虑应用程序的用户配置文件中的设置。</span><span class="sxs-lookup"><span data-stu-id="6c90a-447">It sets <xref:System.Windows.Forms.Application.SetUnhandledExceptionMode%2A> so that all exceptions are handled by the application, regardless of the settings in the application's user configuration file.</span></span> <span data-ttu-id="6c90a-448">它使用 <xref:System.Windows.Forms.Application.ThreadException> 事件来处理 UI 线程异常，并使用 <xref:System.AppDomain.UnhandledException> 事件来处理非 ui 线程异常。</span><span class="sxs-lookup"><span data-stu-id="6c90a-448">It uses the <xref:System.Windows.Forms.Application.ThreadException> event to handle UI thread exceptions, and the <xref:System.AppDomain.UnhandledException> event to handle non-UI thread exceptions.</span></span> <span data-ttu-id="6c90a-449">由于 <xref:System.AppDomain.UnhandledException> 无法阻止应用程序终止，因此该示例只是在终止之前将错误记录在应用程序事件日志中。</span><span class="sxs-lookup"><span data-stu-id="6c90a-449">Since <xref:System.AppDomain.UnhandledException> cannot prevent an application from terminating, the example simply logs the error in the application event log before termination.</span></span>  
  
 <span data-ttu-id="6c90a-450">此示例假设你已在类上定义了两个 <xref:System.Windows.Forms.Button> 控件： `button1` 和 `button2` <xref:System.Windows.Forms.Form> 。</span><span class="sxs-lookup"><span data-stu-id="6c90a-450">This example assumes that you have defined two <xref:System.Windows.Forms.Button> controls, `button1` and `button2`, on your <xref:System.Windows.Forms.Form> class.</span></span>  
  
 [!code-cpp[Classic Application.ThreadException Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.ThreadException Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.ThreadException Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.ThreadException Example/CS/source.cs#1)]
 [!code-vb[Classic Application.ThreadException Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.ThreadException Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="6c90a-451">在应用程序创建其第一个窗口后，您将无法设置异常模式。</span><span class="sxs-lookup"><span data-stu-id="6c90a-451">You cannot set the exception mode after the application has created its first window.</span></span></exception>
        <altmember cref="T:System.Windows.Forms.UnhandledExceptionMode" />
      </Docs>
    </Member>
    <Member MemberName="SetUnhandledExceptionMode">
      <MemberSignature Language="C#" Value="public static void SetUnhandledExceptionMode (System.Windows.Forms.UnhandledExceptionMode mode, bool threadScope);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetUnhandledExceptionMode(valuetype System.Windows.Forms.UnhandledExceptionMode mode, bool threadScope) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.SetUnhandledExceptionMode(System.Windows.Forms.UnhandledExceptionMode,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetUnhandledExceptionMode (mode As UnhandledExceptionMode, threadScope As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetUnhandledExceptionMode(System::Windows::Forms::UnhandledExceptionMode mode, bool threadScope);" />
      <MemberSignature Language="F#" Value="static member SetUnhandledExceptionMode : System.Windows.Forms.UnhandledExceptionMode * bool -&gt; unit" Usage="System.Windows.Forms.Application.SetUnhandledExceptionMode (mode, threadScope)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mode" Type="System.Windows.Forms.UnhandledExceptionMode" Index="0" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="threadScope" Type="System.Boolean" Index="1" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="mode"><span data-ttu-id="6c90a-452">一个 <see cref="T:System.Windows.Forms.UnhandledExceptionMode" /> 值，描述在引发未捕获的异常时应用程序的行为方式。</span><span class="sxs-lookup"><span data-stu-id="6c90a-452">An <see cref="T:System.Windows.Forms.UnhandledExceptionMode" /> value describing how the application should behave if an exception is thrown without being caught.</span></span></param>
        <param name="threadScope"><span data-ttu-id="6c90a-453">如果设置线程异常模式，为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="6c90a-453"><see langword="true" /> to set the thread exception mode; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="6c90a-454">指示应用程序如何响应未经处理的异常，同时可选择应用特定于线程的行为。</span><span class="sxs-lookup"><span data-stu-id="6c90a-454">Instructs the application how to respond to unhandled exceptions, optionally applying thread-specific behavior.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6c90a-455">捕获 Windows 窗体引发的所有异常通常是不切实际的。</span><span class="sxs-lookup"><span data-stu-id="6c90a-455">It is often not feasible to catch all of the exceptions thrown by Windows Forms.</span></span> <span data-ttu-id="6c90a-456">使用此方法，你可以指示应用程序是应该捕获由 Windows 窗体组件引发的所有未处理异常并继续运行，还是应将它们公开给用户并暂停执行。</span><span class="sxs-lookup"><span data-stu-id="6c90a-456">Using this method, you can instruct your application whether it should catch all unhandled exceptions thrown by Windows Forms components and continue operating, or whether it should expose them to the user and halt execution.</span></span>  
  
 <span data-ttu-id="6c90a-457"><xref:System.Windows.Forms.Application.SetUnhandledExceptionMode%2A>使用方法实例化应用程序的主窗体之前，请调用 <xref:System.Windows.Forms.Application.Run%2A> 。</span><span class="sxs-lookup"><span data-stu-id="6c90a-457">Call <xref:System.Windows.Forms.Application.SetUnhandledExceptionMode%2A> before you instantiate the main form of your application using the <xref:System.Windows.Forms.Application.Run%2A> method.</span></span>  
  
 <span data-ttu-id="6c90a-458">当 `threadScope` 为时 `true` ，将设置线程异常模式。</span><span class="sxs-lookup"><span data-stu-id="6c90a-458">When `threadScope` is `true`, the thread exception mode is set.</span></span> <span data-ttu-id="6c90a-459">如果未设置为，则线程异常模式将重写应用程序异常模式 `mode` <xref:System.Windows.Forms.UnhandledExceptionMode.Automatic> 。</span><span class="sxs-lookup"><span data-stu-id="6c90a-459">The thread exception mode overrides the application exception mode if `mode` is not set to <xref:System.Windows.Forms.UnhandledExceptionMode.Automatic>.</span></span>  
  
 <span data-ttu-id="6c90a-460">当 `threadScope` 为时 `false` ，将设置应用程序异常模式。</span><span class="sxs-lookup"><span data-stu-id="6c90a-460">When `threadScope` is `false`, the application exception mode is set.</span></span> <span data-ttu-id="6c90a-461">应用程序异常模式用于具有模式的所有线程 <xref:System.Windows.Forms.UnhandledExceptionMode.Automatic> 。</span><span class="sxs-lookup"><span data-stu-id="6c90a-461">The application exception mode is used for all threads that have the <xref:System.Windows.Forms.UnhandledExceptionMode.Automatic> mode.</span></span> <span data-ttu-id="6c90a-462">设置应用程序异常模式不会影响当前线程的设置。</span><span class="sxs-lookup"><span data-stu-id="6c90a-462">Setting the application exception mode does not affect the setting of the current thread.</span></span>  
  
 <span data-ttu-id="6c90a-463">若要捕获不是由 Windows 窗体创建并拥有的线程中发生的异常，请使用 <xref:System.AppDomain.UnhandledException> 事件处理程序。</span><span class="sxs-lookup"><span data-stu-id="6c90a-463">To catch exceptions that occur in threads not created and owned by Windows Forms, use the <xref:System.AppDomain.UnhandledException> event handler.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="6c90a-464">下面的代码示例为在 Windows 窗体线程上发生的异常和其他线程上发生的异常设置事件处理程序。</span><span class="sxs-lookup"><span data-stu-id="6c90a-464">The following code example sets event handlers for exceptions that occur on Windows Forms threads and exceptions that occur on other threads.</span></span> <span data-ttu-id="6c90a-465">此设置 <xref:System.Windows.Forms.Application.SetUnhandledExceptionMode%2A> 使所有异常都由应用程序处理，而不考虑应用程序的用户配置文件中的设置。</span><span class="sxs-lookup"><span data-stu-id="6c90a-465">It sets <xref:System.Windows.Forms.Application.SetUnhandledExceptionMode%2A> so that all exceptions are handled by the application, regardless of the settings in the application's user configuration file.</span></span> <span data-ttu-id="6c90a-466">它使用 <xref:System.Windows.Forms.Application.ThreadException> 事件来处理 UI 线程异常，并使用 <xref:System.AppDomain.UnhandledException> 事件来处理非 ui 线程异常。</span><span class="sxs-lookup"><span data-stu-id="6c90a-466">It uses the <xref:System.Windows.Forms.Application.ThreadException> event to handle UI thread exceptions, and the <xref:System.AppDomain.UnhandledException> event to handle non-UI thread exceptions.</span></span> <span data-ttu-id="6c90a-467">由于 <xref:System.AppDomain.UnhandledException> 无法阻止应用程序终止，因此该示例只是在终止之前将错误记录在应用程序事件日志中。</span><span class="sxs-lookup"><span data-stu-id="6c90a-467">Since <xref:System.AppDomain.UnhandledException> cannot prevent an application from terminating, the example simply logs the error in the application event log before termination.</span></span>  
  
 <span data-ttu-id="6c90a-468">此示例假设你已在类上定义了两个 <xref:System.Windows.Forms.Button> 控件： `button1` 和 `button2` <xref:System.Windows.Forms.Form> 。</span><span class="sxs-lookup"><span data-stu-id="6c90a-468">This example assumes that you have defined two <xref:System.Windows.Forms.Button> controls, `button1` and `button2`, on your <xref:System.Windows.Forms.Form> class.</span></span>  
  
 [!code-cpp[Classic Application.ThreadException Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.ThreadException Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.ThreadException Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.ThreadException Example/CS/source.cs#1)]
 [!code-vb[Classic Application.ThreadException Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.ThreadException Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="6c90a-469">在应用程序创建其第一个窗口后，您将无法设置异常模式。</span><span class="sxs-lookup"><span data-stu-id="6c90a-469">You cannot set the exception mode after the application has created its first window.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="StartupPath">
      <MemberSignature Language="C#" Value="public static string StartupPath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string StartupPath" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.StartupPath" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property StartupPath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ StartupPath { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.StartupPath : string" Usage="System.Windows.Forms.Application.StartupPath" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="6c90a-470">获取启动了应用程序的可执行文件的路径，不包括可执行文件的名称。</span><span class="sxs-lookup"><span data-stu-id="6c90a-470">Gets the path for the executable file that started the application, not including the executable name.</span></span></summary>
        <value><span data-ttu-id="6c90a-471">启动了应用程序的可执行文件的路径。</span><span class="sxs-lookup"><span data-stu-id="6c90a-471">The path for the executable file that started the application.</span></span>  
  
<span data-ttu-id="6c90a-472">此路径将有所不同，具体取决于是否使用 ClickOnce 部署 Windows 窗体应用程序。</span><span class="sxs-lookup"><span data-stu-id="6c90a-472">This path will be different depending on whether the Windows Forms application is deployed using ClickOnce.</span></span> <span data-ttu-id="6c90a-473">ClickOnce 应用程序存储在每个用户的应用程序缓存中的 C:\documents and 和设置 \\ *用户名* 目录中。</span><span class="sxs-lookup"><span data-stu-id="6c90a-473">ClickOnce applications are stored in a per-user application cache in the C:\Documents and Settings\\*username* directory.</span></span> <span data-ttu-id="6c90a-474">有关详细信息，请参阅 [在 ClickOnce 应用程序中访问本地数据和远程数据](/visualstudio/deployment/accessing-local-and-remote-data-in-clickonce-applications)。</span><span class="sxs-lookup"><span data-stu-id="6c90a-474">For more information, see [Accessing Local and Remote Data in ClickOnce Applications](/visualstudio/deployment/accessing-local-and-remote-data-in-clickonce-applications).</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="6c90a-475">下面的代码示例获取此属性，并在文本框中显示其值。</span><span class="sxs-lookup"><span data-stu-id="6c90a-475">The following code example gets this property and displays its value in a text box.</span></span> <span data-ttu-id="6c90a-476">该示例要求已 `textBox1` 置于窗体上。</span><span class="sxs-lookup"><span data-stu-id="6c90a-476">The example requires that `textBox1` has been placed on a form.</span></span>  
  
 [!code-cpp[Classic Application.StartupPath Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.StartupPath Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.StartupPath Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.StartupPath Example/CS/source.cs#1)]
 [!code-vb[Classic Application.StartupPath Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.StartupPath Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ThreadException">
      <MemberSignature Language="C#" Value="public static event System.Threading.ThreadExceptionEventHandler ThreadException;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Threading.ThreadExceptionEventHandler ThreadException" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Application.ThreadException" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event ThreadException As ThreadExceptionEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event System::Threading::ThreadExceptionEventHandler ^ ThreadException;" />
      <MemberSignature Language="F#" Value="member this.ThreadException : System.Threading.ThreadExceptionEventHandler " Usage="member this.ThreadException : System.Threading.ThreadExceptionEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.ThreadExceptionEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="6c90a-477">在发生未捕获线程异常时发生。</span><span class="sxs-lookup"><span data-stu-id="6c90a-477">Occurs when an untrapped thread exception is thrown.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6c90a-478">此事件允许 Windows 窗体应用程序处理 Windows 窗体线程中发生的未经处理的异常。</span><span class="sxs-lookup"><span data-stu-id="6c90a-478">This event allows your Windows Forms application to handle otherwise unhandled exceptions that occur in Windows Forms threads.</span></span> <span data-ttu-id="6c90a-479">将事件处理程序附加到 <xref:System.Windows.Forms.Application.ThreadException> 事件来处理这些异常，这些异常会使应用程序处于未知状态。</span><span class="sxs-lookup"><span data-stu-id="6c90a-479">Attach your event handler to the <xref:System.Windows.Forms.Application.ThreadException> event to deal with these exceptions, which will leave your application in an unknown state.</span></span> <span data-ttu-id="6c90a-480">如果可能，应通过结构化异常处理块处理异常。</span><span class="sxs-lookup"><span data-stu-id="6c90a-480">Where possible, exceptions should be handled by a structured exception handling block.</span></span>  
  
 <span data-ttu-id="6c90a-481">通过设置，可以更改此回调是否用于未处理的 Windows 窗体线程异常 <xref:System.Windows.Forms.Application.SetUnhandledExceptionMode%2A> 。</span><span class="sxs-lookup"><span data-stu-id="6c90a-481">You can change whether this callback is used for unhandled Windows Forms thread exceptions by setting <xref:System.Windows.Forms.Application.SetUnhandledExceptionMode%2A>.</span></span> <span data-ttu-id="6c90a-482">若要捕获不是由 Windows 窗体创建并拥有的线程中发生的异常，请使用 <xref:System.AppDomain.UnhandledException> 事件处理程序。</span><span class="sxs-lookup"><span data-stu-id="6c90a-482">To catch exceptions that occur in threads not created and owned by Windows Forms, use the <xref:System.AppDomain.UnhandledException> event handler.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="6c90a-483">若要确保不会错过此事件的激活，则必须在调用之前附加处理程序 <xref:System.Windows.Application.Run%2A?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="6c90a-483">To guarantee that no activations of this event are missed, you must attach a handler before you call <xref:System.Windows.Application.Run%2A?displayProperty=nameWithType>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="6c90a-484">只能将一个处理程序附加到此事件。</span><span class="sxs-lookup"><span data-stu-id="6c90a-484">Only one handler can be attached to this event.</span></span> <span data-ttu-id="6c90a-485">如果添加多个处理程序，则将仅对未经处理的异常调用最近添加的处理程序。</span><span class="sxs-lookup"><span data-stu-id="6c90a-485">If multiple handlers are added, only the most recently added handler will be called on an unhandled exception.</span></span>
  
> [!CAUTION]
>  <span data-ttu-id="6c90a-486">因为这是一个静态事件，所以必须在释放应用程序时分离事件处理程序，否则会导致内存泄漏。</span><span class="sxs-lookup"><span data-stu-id="6c90a-486">Because this is a static event, you must detach your event handlers when your application is disposed, or memory leaks will result.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="6c90a-487">下面的代码示例为在 Windows 窗体线程上发生的异常和其他线程上发生的异常设置事件处理程序。</span><span class="sxs-lookup"><span data-stu-id="6c90a-487">The following code example sets event handlers for exceptions that occur on Windows Forms threads and exceptions that occur on other threads.</span></span> <span data-ttu-id="6c90a-488">此设置 <xref:System.Windows.Forms.Application.SetUnhandledExceptionMode%2A> 使所有异常都由应用程序处理，而不考虑应用程序的用户配置文件中的设置。</span><span class="sxs-lookup"><span data-stu-id="6c90a-488">It sets <xref:System.Windows.Forms.Application.SetUnhandledExceptionMode%2A> so that all exceptions are handled by the application, regardless of the settings in the application's user configuration file.</span></span> <span data-ttu-id="6c90a-489">它使用 <xref:System.Windows.Forms.Application.ThreadException> 事件来处理 UI 线程异常，并使用 <xref:System.AppDomain.UnhandledException> 事件来处理非 ui 线程异常。</span><span class="sxs-lookup"><span data-stu-id="6c90a-489">It uses the <xref:System.Windows.Forms.Application.ThreadException> event to handle UI thread exceptions, and the <xref:System.AppDomain.UnhandledException> event to handle non-UI thread exceptions.</span></span> <span data-ttu-id="6c90a-490">由于 <xref:System.AppDomain.UnhandledException> 无法阻止应用程序终止，因此该示例只是在终止之前将错误记录在应用程序事件日志中。</span><span class="sxs-lookup"><span data-stu-id="6c90a-490">Since <xref:System.AppDomain.UnhandledException> cannot prevent an application from terminating, the example simply logs the error in the application event log before termination.</span></span>  
  
 <span data-ttu-id="6c90a-491">此示例假设你已在类上定义了两个 <xref:System.Windows.Forms.Button> 控件： `button1` 和 `button2` <xref:System.Windows.Forms.Form> 。</span><span class="sxs-lookup"><span data-stu-id="6c90a-491">This example assumes that you have defined two <xref:System.Windows.Forms.Button> controls, `button1` and `button2`, on your <xref:System.Windows.Forms.Form> class.</span></span>  
  
 [!code-cpp[Classic Application.ThreadException Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.ThreadException Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.ThreadException Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.ThreadException Example/CS/source.cs#1)]
 [!code-vb[Classic Application.ThreadException Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.ThreadException Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ThreadExit">
      <MemberSignature Language="C#" Value="public static event EventHandler ThreadExit;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler ThreadExit" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Application.ThreadExit" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event ThreadExit As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler ^ ThreadExit;" />
      <MemberSignature Language="F#" Value="member this.ThreadExit : EventHandler " Usage="member this.ThreadExit : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="6c90a-492">在某线程即将关闭时发生。</span><span class="sxs-lookup"><span data-stu-id="6c90a-492">Occurs when a thread is about to shut down.</span></span> <span data-ttu-id="6c90a-493">当应用程序的主线程即将关闭时，首先引发该事件，随后是 <see cref="E:System.Windows.Forms.Application.ApplicationExit" /> 事件。</span><span class="sxs-lookup"><span data-stu-id="6c90a-493">When the main thread for an application is about to be shut down, this event is raised first, followed by an <see cref="E:System.Windows.Forms.Application.ApplicationExit" /> event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6c90a-494">您必须将事件处理程序附加到 <xref:System.Windows.Forms.Application.ThreadExit> 事件，以在线程停止运行之前执行任何未处理的、必需的任务。</span><span class="sxs-lookup"><span data-stu-id="6c90a-494">You must attach the event handlers to the <xref:System.Windows.Forms.Application.ThreadExit> event to perform any unhandled, required tasks before the thread stops running.</span></span> <span data-ttu-id="6c90a-495">关闭此线程打开的文件，或释放垃圾回收器未回收的对象。</span><span class="sxs-lookup"><span data-stu-id="6c90a-495">Close files opened by this thread, or dispose of objects that the garbage collector did not reclaim.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="6c90a-496">因为这是一个静态事件，所以必须在释放应用程序时分离事件处理程序，否则会导致内存泄漏。</span><span class="sxs-lookup"><span data-stu-id="6c90a-496">Because this is a static event, you must detach your event handlers when your application is disposed, or memory leaks will result.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="6c90a-497">下面的代码示例演示如何使用此成员。</span><span class="sxs-lookup"><span data-stu-id="6c90a-497">The following code example demonstrates the use of this member.</span></span> <span data-ttu-id="6c90a-498">在此示例中，事件处理程序报告事件的发生 <xref:System.Windows.Forms.Application.ThreadExit> 。</span><span class="sxs-lookup"><span data-stu-id="6c90a-498">In the example, an event handler reports on the occurrence of the <xref:System.Windows.Forms.Application.ThreadExit> event.</span></span> <span data-ttu-id="6c90a-499">此报表可帮助你了解何时发生事件，并可帮助你进行调试。</span><span class="sxs-lookup"><span data-stu-id="6c90a-499">This report helps you to learn when the event occurs and can assist you in debugging.</span></span> <span data-ttu-id="6c90a-500">若要报告多个事件或频繁发生的事件，请考虑 <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> 将消息替换为多行或将其追加到多行 <xref:System.Windows.Forms.TextBox> 。</span><span class="sxs-lookup"><span data-stu-id="6c90a-500">To report on multiple events or on events that occur frequently, consider replacing <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> with <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> or appending the message to a multiline <xref:System.Windows.Forms.TextBox>.</span></span>  
  
 <span data-ttu-id="6c90a-501">若要运行示例代码，请将其粘贴到 Windows 窗体中，并确保事件处理程序与事件相关联 <xref:System.Windows.Forms.Application.ThreadExit> 。</span><span class="sxs-lookup"><span data-stu-id="6c90a-501">To run the example code, paste it into a Windows Forms and ensure that the event handler is associated with the <xref:System.Windows.Forms.Application.ThreadExit> event.</span></span>  
  
 [!code-csharp[System.Windows.Forms.EventExamples#6](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#6)]
 [!code-vb[System.Windows.Forms.EventExamples#6](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#6)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Application.ExitThread" />
      </Docs>
    </Member>
    <Member MemberName="UnregisterMessageLoop">
      <MemberSignature Language="C#" Value="public static void UnregisterMessageLoop ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void UnregisterMessageLoop() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.UnregisterMessageLoop" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub UnregisterMessageLoop ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void UnregisterMessageLoop();" />
      <MemberSignature Language="F#" Value="static member UnregisterMessageLoop : unit -&gt; unit" Usage="System.Windows.Forms.Application.UnregisterMessageLoop " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="6c90a-502">注销使用 <see cref="M:System.Windows.Forms.Application.RegisterMessageLoop(System.Windows.Forms.Application.MessageLoopCallback)" /> 发出的消息循环回调。</span><span class="sxs-lookup"><span data-stu-id="6c90a-502">Unregisters the message loop callback made with <see cref="M:System.Windows.Forms.Application.RegisterMessageLoop(System.Windows.Forms.Application.MessageLoopCallback)" />.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UserAppDataPath">
      <MemberSignature Language="C#" Value="public static string UserAppDataPath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string UserAppDataPath" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.UserAppDataPath" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property UserAppDataPath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ UserAppDataPath { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UserAppDataPath : string" Usage="System.Windows.Forms.Application.UserAppDataPath" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="6c90a-503">获取用户的应用程序数据的路径。</span><span class="sxs-lookup"><span data-stu-id="6c90a-503">Gets the path for the application data of a user.</span></span></summary>
        <value><span data-ttu-id="6c90a-504">用户的应用程序数据的路径。</span><span class="sxs-lookup"><span data-stu-id="6c90a-504">The path for the application data of a user.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6c90a-505">如果路径不存在，则将使用以下格式创建一个路径：</span><span class="sxs-lookup"><span data-stu-id="6c90a-505">If a path does not exist, one is created in the following format:</span></span>  
  
 <span data-ttu-id="6c90a-506">*基路径*\\<xref:System.Windows.Forms.Application.CompanyName%2A>\\<xref:System.Windows.Forms.Application.ProductName%2A>\\<xref:System.Windows.Forms.Application.ProductVersion%2A></span><span class="sxs-lookup"><span data-stu-id="6c90a-506">*Base Path*\\<xref:System.Windows.Forms.Application.CompanyName%2A>\\<xref:System.Windows.Forms.Application.ProductName%2A>\\<xref:System.Windows.Forms.Application.ProductVersion%2A></span></span>  
  
 <span data-ttu-id="6c90a-507">存储在此路径中的数据是为漫游启用的用户配置文件的一部分。</span><span class="sxs-lookup"><span data-stu-id="6c90a-507">Data stored in this path is part of user profile that is enabled for roaming.</span></span> <span data-ttu-id="6c90a-508">漫游用户在网络中的多台计算机上工作。</span><span class="sxs-lookup"><span data-stu-id="6c90a-508">A roaming user works on more than one computer in a network.</span></span> <span data-ttu-id="6c90a-509">漫游用户的用户配置文件保存在网络上的服务器上，并在用户登录时加载到系统上。</span><span class="sxs-lookup"><span data-stu-id="6c90a-509">The user profile for a roaming user is kept on a server on the network and is loaded onto a system when the user logs on.</span></span> <span data-ttu-id="6c90a-510">对于要被视为漫游的用户配置文件，操作系统必须支持漫游配置文件，并且必须启用该配置文件。</span><span class="sxs-lookup"><span data-stu-id="6c90a-510">For a user profile to be considered for roaming, the operating system must support roaming profiles and it must be enabled.</span></span>  
  
 <span data-ttu-id="6c90a-511">典型的基路径为 "C:\documents and" 和 "Settings \\ *Username*\Application Data"。</span><span class="sxs-lookup"><span data-stu-id="6c90a-511">A typical base path is C:\Documents and Settings\\*username*\Application Data.</span></span> <span data-ttu-id="6c90a-512">但是，如果使用 ClickOnce 部署 Windows 窗体应用程序，则此路径将有所不同。</span><span class="sxs-lookup"><span data-stu-id="6c90a-512">This path will be different, however, if the Windows Forms application is deployed by using ClickOnce.</span></span> <span data-ttu-id="6c90a-513">ClickOnce 创建独立于所有其他应用程序的应用程序数据目录。</span><span class="sxs-lookup"><span data-stu-id="6c90a-513">ClickOnce creates its own application data directory that is isolated from all other applications.</span></span> <span data-ttu-id="6c90a-514">有关详细信息，请参阅 [在 ClickOnce 应用程序中访问本地数据和远程数据](/visualstudio/deployment/accessing-local-and-remote-data-in-clickonce-applications)。</span><span class="sxs-lookup"><span data-stu-id="6c90a-514">For more information, see [Accessing Local and Remote Data in ClickOnce Applications](/visualstudio/deployment/accessing-local-and-remote-data-in-clickonce-applications).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="6c90a-515">下面的代码示例显示两个窗体并在两个窗体关闭时退出应用程序。</span><span class="sxs-lookup"><span data-stu-id="6c90a-515">The following code example displays two forms and exits the application when both forms are closed.</span></span> <span data-ttu-id="6c90a-516">当应用程序启动和退出时，将记住每个窗体的位置。</span><span class="sxs-lookup"><span data-stu-id="6c90a-516">When the application starts and exits, the position of each form is remembered.</span></span> <span data-ttu-id="6c90a-517">此示例演示如何使用 <xref:System.Windows.Forms.Application.UserAppDataPath%2A> 属性存储用户的应用程序数据。</span><span class="sxs-lookup"><span data-stu-id="6c90a-517">This example demonstrates using the <xref:System.Windows.Forms.Application.UserAppDataPath%2A> property to store application data for the user.</span></span>  
  
 <span data-ttu-id="6c90a-518">类 `MyApplicationContext` 从继承， <xref:System.Windows.Forms.ApplicationContext> 并在每个窗体关闭时保持跟踪，并在两个窗体关闭时保持跟踪，并在两个窗体均</span><span class="sxs-lookup"><span data-stu-id="6c90a-518">The class `MyApplicationContext` inherits from <xref:System.Windows.Forms.ApplicationContext> and keeps track when each form is closed, and exits the current thread when they both are.</span></span> <span data-ttu-id="6c90a-519">类存储用户的每个窗体的位置。</span><span class="sxs-lookup"><span data-stu-id="6c90a-519">The class stores the positions of each form for the user.</span></span> <span data-ttu-id="6c90a-520">窗体位置数据存储在名为的文件中 `Appdata.txt` ，该文件在由确定的位置创建 <xref:System.Windows.Forms.Application.UserAppDataPath%2A> 。</span><span class="sxs-lookup"><span data-stu-id="6c90a-520">The form position data is stored in a file titled `Appdata.txt` that is created in the location determined by <xref:System.Windows.Forms.Application.UserAppDataPath%2A>.</span></span> <span data-ttu-id="6c90a-521">`Main`方法调用 `Application.Run(context)` 来启动给定的应用程序 <xref:System.Windows.Forms.ApplicationContext> 。</span><span class="sxs-lookup"><span data-stu-id="6c90a-521">The `Main` method calls `Application.Run(context)` to start the application given the <xref:System.Windows.Forms.ApplicationContext>.</span></span>  
  
 <span data-ttu-id="6c90a-522">此代码摘自类概述中所示的示例 <xref:System.Windows.Forms.ApplicationContext> 。</span><span class="sxs-lookup"><span data-stu-id="6c90a-522">This code is an excerpt from the example shown in the <xref:System.Windows.Forms.ApplicationContext> class overview.</span></span> <span data-ttu-id="6c90a-523">为了简洁起见，不显示某些代码。</span><span class="sxs-lookup"><span data-stu-id="6c90a-523">Some code is not shown for the purpose of brevity.</span></span> <span data-ttu-id="6c90a-524"><xref:System.Windows.Forms.ApplicationContext>有关完整的代码清单，请参阅。</span><span class="sxs-lookup"><span data-stu-id="6c90a-524">See <xref:System.Windows.Forms.ApplicationContext> for the whole code listing.</span></span>  
  
 [!code-cpp[Application#5](~/samples/snippets/cpp/VS_Snippets_Winforms/Application/CPP/source.cpp#5)]
 [!code-csharp[Application#5](~/samples/snippets/csharp/VS_Snippets_Winforms/Application/CS/source.cs#5)]
 [!code-vb[Application#5](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Application/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Application.UserAppDataRegistry" />
      </Docs>
    </Member>
    <Member MemberName="UserAppDataRegistry">
      <MemberSignature Language="C#" Value="public static Microsoft.Win32.RegistryKey UserAppDataRegistry { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class Microsoft.Win32.RegistryKey UserAppDataRegistry" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.UserAppDataRegistry" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property UserAppDataRegistry As RegistryKey" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property Microsoft::Win32::RegistryKey ^ UserAppDataRegistry { Microsoft::Win32::RegistryKey ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UserAppDataRegistry : Microsoft.Win32.RegistryKey" Usage="System.Windows.Forms.Application.UserAppDataRegistry" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="6c90a-525">获取用户的应用程序数据的注册表项。</span><span class="sxs-lookup"><span data-stu-id="6c90a-525">Gets the registry key for the application data of a user.</span></span></summary>
        <value><span data-ttu-id="6c90a-526">一个 <see cref="T:Microsoft.Win32.RegistryKey" />，它表示特定于用户的应用程序数据的注册表项。</span><span class="sxs-lookup"><span data-stu-id="6c90a-526">A <see cref="T:Microsoft.Win32.RegistryKey" /> representing the registry key for the application data specific to the user.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6c90a-527">如果该键不存在，则将采用以下格式创建它：</span><span class="sxs-lookup"><span data-stu-id="6c90a-527">If the key does not exist, it is created in the following format:</span></span>  
  
 <span data-ttu-id="6c90a-528">CurrentUser\Software\\<xref:System.Windows.Forms.Application.CompanyName%2A>\\<xref:System.Windows.Forms.Application.ProductName%2A>\\<xref:System.Windows.Forms.Application.ProductVersion%2A></span><span class="sxs-lookup"><span data-stu-id="6c90a-528">CurrentUser\Software\\<xref:System.Windows.Forms.Application.CompanyName%2A>\\<xref:System.Windows.Forms.Application.ProductName%2A>\\<xref:System.Windows.Forms.Application.ProductVersion%2A></span></span>   
  
 <span data-ttu-id="6c90a-529">此注册表项中存储的数据是为漫游启用的用户配置文件的一部分。</span><span class="sxs-lookup"><span data-stu-id="6c90a-529">Data stored in this key is part of user profile that is enabled for roaming.</span></span> <span data-ttu-id="6c90a-530">漫游用户在网络中的多台计算机上工作。</span><span class="sxs-lookup"><span data-stu-id="6c90a-530">A roaming user works on more than one computer in a network.</span></span> <span data-ttu-id="6c90a-531">漫游用户的用户配置文件保存在网络上的服务器上，并在用户登录时加载到系统上。</span><span class="sxs-lookup"><span data-stu-id="6c90a-531">The user profile for a roaming user is kept on a server on the network and is loaded onto a system when the user logs on.</span></span> <span data-ttu-id="6c90a-532">对于要被视为漫游的用户配置文件，操作系统必须支持漫游配置文件，并且必须启用该配置文件。</span><span class="sxs-lookup"><span data-stu-id="6c90a-532">For a user profile to be considered for roaming, the operating system must support roaming profiles and it must be enabled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.SystemInformation" />
      </Docs>
    </Member>
    <Member MemberName="UseVisualStyles">
      <MemberSignature Language="C#" Value="public static bool UseVisualStyles { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool UseVisualStyles" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.UseVisualStyles" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property UseVisualStyles As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool UseVisualStyles { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.UseVisualStyles : bool" Usage="System.Windows.Forms.Application.UseVisualStyles" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="6c90a-533">获取一个值，该值指示是否为应用程序启用视觉样式。</span><span class="sxs-lookup"><span data-stu-id="6c90a-533">Gets a value that indicates whether visual styles are enabled for the application.</span></span></summary>
        <value><span data-ttu-id="6c90a-534"><see langword="true" /> 如果启用了视觉样式，则为;否则为 <see langword="false" /> 。</span><span class="sxs-lookup"><span data-stu-id="6c90a-534"><see langword="true" /> if visual styles are enabled; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="6c90a-535">可以通过调用来启用视觉样式 <xref:System.Windows.Forms.Application.EnableVisualStyles> 。</span><span class="sxs-lookup"><span data-stu-id="6c90a-535">The visual styles can be enabled by calling <xref:System.Windows.Forms.Application.EnableVisualStyles>.</span></span>

<span data-ttu-id="6c90a-536">如果操作系统不支持视觉样式，或在操作系统级别禁用了主题，则不会启用视觉样式。</span><span class="sxs-lookup"><span data-stu-id="6c90a-536">The visual styles will not be enabled if the OS does not support them, or theming is disabled at the OS level.</span></span>

           ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UseWaitCursor">
      <MemberSignature Language="C#" Value="public static bool UseWaitCursor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property bool UseWaitCursor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.UseWaitCursor" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property UseWaitCursor As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool UseWaitCursor { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UseWaitCursor : bool with get, set" Usage="System.Windows.Forms.Application.UseWaitCursor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="6c90a-537">获取或设置是否对应用程序的所有打开窗体使用等待光标。</span><span class="sxs-lookup"><span data-stu-id="6c90a-537">Gets or sets whether the wait cursor is used for all open forms of the application.</span></span></summary>
        <value><span data-ttu-id="6c90a-538">如果等待光标用于所有打开的窗体，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="6c90a-538"><see langword="true" /> is the wait cursor is used for all open forms; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6c90a-539">如果将此属性设置为 `true` ，则 <xref:System.Windows.Forms.Control.UseWaitCursor%2A> 应用程序中所有打开的窗体的属性都将设置为 `true` 。</span><span class="sxs-lookup"><span data-stu-id="6c90a-539">When this property is set to `true`, the <xref:System.Windows.Forms.Control.UseWaitCursor%2A> property of all open forms in the application will be set to `true`.</span></span> <span data-ttu-id="6c90a-540">在对所有窗体设置此属性之前，此调用将不会返回。</span><span class="sxs-lookup"><span data-stu-id="6c90a-540">This call will not return until this property has been set on all forms.</span></span> <span data-ttu-id="6c90a-541">如果有长时间运行的操作，并且希望在所有应用程序窗体中指示该操作仍在进行处理，请使用此属性。</span><span class="sxs-lookup"><span data-stu-id="6c90a-541">Use this property when you have a long-running operation, and want to indicate in all application forms that the operation is still processing.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VisualStyleState">
      <MemberSignature Language="C#" Value="public static System.Windows.Forms.VisualStyles.VisualStyleState VisualStyleState { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Windows.Forms.VisualStyles.VisualStyleState VisualStyleState" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.VisualStyleState" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property VisualStyleState As VisualStyleState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Forms::VisualStyles::VisualStyleState VisualStyleState { System::Windows::Forms::VisualStyles::VisualStyleState get(); void set(System::Windows::Forms::VisualStyles::VisualStyleState value); };" />
      <MemberSignature Language="F#" Value="member this.VisualStyleState : System.Windows.Forms.VisualStyles.VisualStyleState with get, set" Usage="System.Windows.Forms.Application.VisualStyleState" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.VisualStyles.VisualStyleState</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="6c90a-542">获取指定可视样式如何应用于应用程序窗口的值。</span><span class="sxs-lookup"><span data-stu-id="6c90a-542">Gets a value that specifies how visual styles are applied to application windows.</span></span></summary>
        <value><span data-ttu-id="6c90a-543"><see cref="T:System.Windows.Forms.VisualStyles.VisualStyleState" /> 值的按位组合。</span><span class="sxs-lookup"><span data-stu-id="6c90a-543">A bitwise combination of the <see cref="T:System.Windows.Forms.VisualStyles.VisualStyleState" /> values.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6c90a-544">此 <xref:System.Windows.Forms.Application.VisualStyleState%2A> 属性确定在应用程序窗口的客户端区域或非工作区中是否启用视觉样式。</span><span class="sxs-lookup"><span data-stu-id="6c90a-544">This <xref:System.Windows.Forms.Application.VisualStyleState%2A> property determines whether visual styles are enabled in client areas or nonclient areas of application windows.</span></span> <span data-ttu-id="6c90a-545">通常，应在主窗体的构造函数或事件处理程序中设置此属性 <xref:System.Windows.Forms.Form.Load> 。</span><span class="sxs-lookup"><span data-stu-id="6c90a-545">Generally, this property should be set within the main form's constructor or <xref:System.Windows.Forms.Form.Load> event handler.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="6c90a-546">下面的代码示例将 <xref:System.Windows.Forms.Application.VisualStyleState%2A> 属性设置为 <xref:System.Windows.Forms.VisualStyles.VisualStyleState?displayProperty=nameWithType> 控件的 <xref:System.Windows.Forms.Control.Click> 事件处理程序中的值之一 <xref:System.Windows.Forms.Button> 。</span><span class="sxs-lookup"><span data-stu-id="6c90a-546">The following code example sets the <xref:System.Windows.Forms.Application.VisualStyleState%2A> property to one of the <xref:System.Windows.Forms.VisualStyles.VisualStyleState?displayProperty=nameWithType> values within the <xref:System.Windows.Forms.Control.Click> event handler for a <xref:System.Windows.Forms.Button> control.</span></span> <span data-ttu-id="6c90a-547">此代码示例是为枚举提供的更大示例的一部分 <xref:System.Windows.Forms.VisualStyles.VisualStyleState?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="6c90a-547">This code example is part of a larger example provided for the <xref:System.Windows.Forms.VisualStyles.VisualStyleState?displayProperty=nameWithType> enumeration.</span></span>  
  
 [!code-cpp[System.Windows.Forms.VisualStyles.VisualStyleState#10](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.VisualStyles.VisualStyleState/cpp/visualstylestate.cpp#10)]
 [!code-csharp[System.Windows.Forms.VisualStyles.VisualStyleState#10](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.VisualStyles.VisualStyleState/CS/visualstylestate.cs#10)]
 [!code-vb[System.Windows.Forms.VisualStyles.VisualStyleState#10](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.VisualStyles.VisualStyleState/VB/visualstylestate.vb#10)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
