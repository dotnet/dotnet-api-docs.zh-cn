<Type Name="HtmlDocument" FullName="System.Windows.Forms.HtmlDocument">
  <Metadata><Meta Name="ms.openlocfilehash" Value="b9d07d9e0d27c2aad3809b1fb968030670cb0d64" /><Meta Name="ms.sourcegitcommit" Value="c982ad9e10a242d90f1e631b5981570f9e5d9f34" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-CN" /><Meta Name="ms.lasthandoff" Value="09/10/2020" /><Meta Name="ms.locfileid" Value="89755081" /></Metadata><TypeSignature Language="C#" Value="public sealed class HtmlDocument" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit HtmlDocument extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Forms.HtmlDocument" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class HtmlDocument" />
  <TypeSignature Language="C++ CLI" Value="public ref class HtmlDocument sealed" />
  <TypeSignature Language="F#" Value="type HtmlDocument = class" />
  <AssemblyInfo>
    <AssemblyName>System.Windows.Forms</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>5.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>提供对 <see cref="T:System.Windows.Forms.WebBrowser" /> 控件承载的 HTML 文档的顶级编程访问。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.HtmlDocument> 提供围绕 Internet Explorer 文档对象（也称为 HTML 文档对象模型 (DOM) ）的托管包装。 您可以 <xref:System.Windows.Forms.HtmlDocument> 通过控件的属性获取的实例 <xref:System.Windows.Forms.WebBrowser.Document%2A> <xref:System.Windows.Forms.WebBrowser> 。  
  
 HTML 文档中的 HTML 标记可以相互嵌套。 <xref:System.Windows.Forms.HtmlDocument> 因此表示文档树，其子级是类的实例 <xref:System.Windows.Forms.HtmlElement> 。 下面的代码示例演示一个简单的 HTML 文件。  
  
```  
<HTML>  
    <BODY>  
        <DIV name="Span1">Simple HTML Form</DIV>  
        <FORM>  
            <SPAN name="TextLabel">Enter Your Name:</SPAN>  
            <INPUT type="text" size="20" name="Text1">  
        </FORM>  
    </BODY>  
</HTML>  
```  
  
 在此示例中， <xref:System.Windows.Forms.HtmlDocument> 表示标记中的整个文档 `HTML` 。 `BODY`、 `DIV` `FORM` 和标记由 `SPAN` 单个 <xref:System.Windows.Forms.HtmlElement> 对象表示。  
  
 可以通过多种方式访问此树中的元素。 使用 <xref:System.Windows.Forms.HtmlDocument.Body%2A> 属性可以访问 `BODY` 标记及其所有子级。 <xref:System.Windows.Forms.HtmlDocument.ActiveElement%2A>属性为您提供了 <xref:System.Windows.Forms.HtmlElement> HTML 页面上具有用户输入焦点的元素的。 HTML 页面中的所有元素都可以具有名称; <xref:System.Windows.Forms.HtmlDocument.All%2A> 集合 <xref:System.Windows.Forms.HtmlElement> 使用其名称作为索引来提供对每个的访问。 <xref:System.Windows.Forms.HtmlDocument.GetElementsByTagName%2A> 将返回 <xref:System.Windows.Forms.HtmlElementCollection> <xref:System.Windows.Forms.HtmlElement> 具有给定 HTML 标记名称的所有对象的，如 `DIV` 或 `TABLE` 。 <xref:System.Windows.Forms.HtmlDocument.GetElementById%2A> 将返回 <xref:System.Windows.Forms.HtmlElement> 对应于你提供的唯一 ID 的单个。 <xref:System.Windows.Forms.HtmlDocument.GetElementFromPoint%2A> 将返回 <xref:System.Windows.Forms.HtmlElement> 可在屏幕上提供的鼠标指针坐标处找到的。  
  
 你还可以使用 <xref:System.Windows.Forms.HtmlDocument.Forms%2A> 和 <xref:System.Windows.Forms.HtmlDocument.Images%2A> 集合分别循环访问表示用户输入窗体和图形的元素。  
  
 <xref:System.Windows.Forms.HtmlDocument> 基于 Internet Explorer 的 DHTML DOM 实现的非托管接口： `IHTMLDocument` 、 `IHTMLDocument2` 、 `IHTMLDocument3` 和 `IHTMLDocument4` 。 只公开了这些非托管接口上最常用的属性和方法 <xref:System.Windows.Forms.HtmlDocument> 。 您可以使用属性直接访问所有其他属性和方法 <xref:System.Windows.Forms.HtmlDocument.DomDocument%2A> ，您可以将其强制转换为所需的非托管接口指针。  
  
 HTML 文档可以包含框架，这些框架是控件内部的不同窗口 <xref:System.Windows.Forms.WebBrowser> 。 每个帧都显示其自己的 HTML 页面。 <xref:System.Windows.Forms.HtmlWindow.Frames%2A>集合可通过 <xref:System.Windows.Forms.HtmlDocument.Window%2A> 属性获得。 你还可以使用 <xref:System.Windows.Forms.HtmlDocument.Window%2A> 属性来调整所显示页面的大小，滚动文档，或向用户显示警报和提示。  
  
 <xref:System.Windows.Forms.HtmlDocument> 公开托管 HTML 页面时应处理的最常见事件。 对于不是由接口直接公开的事件，可以使用为事件添加处理程序 <xref:System.Windows.Forms.HtmlDocument.AttachEventHandler%2A> 。  
  
 HTML 文件可能包含 `SCRIPT` 标记，这些标记封装用一种活动脚本语言（如 JScript 或 VBScript）编写的代码。 <xref:System.Windows.Forms.HtmlDocument.InvokeScript%2A>方法提供了在标记中定义的属性和方法的执行 `SCRIPT` 。  
  
> [!NOTE]
>  虽然上的大多数属性、方法和事件都与其 <xref:System.Windows.Forms.HtmlDocument> 在非托管 DOM 上具有相同的名称，但某些属性、方法和事件与的一致性已经更改 [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] 。  
  
   
  
## Examples  
 下面的代码示例使用 Northwind 数据库中的数据 `HTML TABLE` 通过动态创建 <xref:System.Windows.Forms.HtmlDocument.CreateElement%2A> 。 <xref:System.Windows.Forms.HtmlElement.AppendChild%2A>此外，还使用方法将单元 (`TD` 元素添加) 到行 (`TR` 元素) ，然后将行添加到表中，最后将表追加到当前文档的末尾。 此代码示例要求你的应用程序具有一个 <xref:System.Windows.Forms.WebBrowser> 名为的控件 `WebBrowser1` 。 加载文档后应调用该代码。  
  
 [!code-csharp[System.Windows.Forms.HtmlDocument#10](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlDocument/CS/Form1.cs#10)]
 [!code-vb[System.Windows.Forms.HtmlDocument#10](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlDocument/VB/Form1.vb#10)]  
  
 ]]></format>
    </remarks>
    <related type="ExternalDocumentation" href="https://developer.mozilla.org/docs/Web/API/Document">文档-Web Api</related>
    <related type="Article" href="https://docs.microsoft.com/previous-versions/windows/internet-explorer/ie-developer/platform-apis/aa752574(v=vs.85)">IHTMLDocument2 接口</related>
  </Docs>
  <Members>
    <Member MemberName="ActiveElement">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.HtmlElement ActiveElement { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.HtmlElement ActiveElement" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlDocument.ActiveElement" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ActiveElement As HtmlElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::HtmlElement ^ ActiveElement { System::Windows::Forms::HtmlElement ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ActiveElement : System.Windows.Forms.HtmlElement" Usage="System.Windows.Forms.HtmlDocument.ActiveElement" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElement</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>提供当前具有用户输入焦点的 <see cref="T:System.Windows.Forms.HtmlElement" />。</summary>
        <value>当前具有用户输入焦点的 <see cref="T:System.Windows.Forms.HtmlElement" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果文档具有焦点，但没有为文档提供焦点，则 <xref:System.Windows.Forms.HtmlDocument.ActiveElement%2A> 返回对应于标记的元素 `<BODY>` 。  
  
 如果该文档不具有焦点，则 <xref:System.Windows.Forms.HtmlDocument.ActiveElement%2A> 返回 `null` 。  
  
 如果具有输入焦点的当前元素是 `TD` HTML 标记中) 的单元 (`TABLE` ， <xref:System.Windows.Forms.HtmlDocument.ActiveElement%2A> 将返回包含该元素的元素 `TABLE` 。  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/windows/internet-explorer/ie-developer/platform-apis/aa752581(v=vs.85)">activeElement 属性</related>
      </Docs>
    </Member>
    <Member MemberName="ActiveLinkColor">
      <MemberSignature Language="C#" Value="public System.Drawing.Color ActiveLinkColor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Color ActiveLinkColor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlDocument.ActiveLinkColor" />
      <MemberSignature Language="VB.NET" Value="Public Property ActiveLinkColor As Color" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Color ActiveLinkColor { System::Drawing::Color get(); void set(System::Drawing::Color value); };" />
      <MemberSignature Language="F#" Value="member this.ActiveLinkColor : System.Drawing.Color with get, set" Usage="System.Windows.Forms.HtmlDocument.ActiveLinkColor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Color</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置超链接被用户单击后的 <see cref="T:System.Drawing.Color" />。</summary>
        <value>活动链接的 <see cref="T:System.Drawing.Color" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当用户单击链接时，该链接将处于活动状态。 更改此属性以在导航之前更改链接的颜色。  
  
 <xref:System.Drawing.Color>中的类型 [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] 支持 `Alpha` 值，但 HTML DOM 不支持。 因此， `Alpha` 分配给此属性时将不起作用。  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/aa752564.aspx">alinkColor 属性</related>
      </Docs>
    </Member>
    <Member MemberName="All">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.HtmlElementCollection All { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.HtmlElementCollection All" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlDocument.All" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property All As HtmlElementCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::HtmlElementCollection ^ All { System::Windows::Forms::HtmlElementCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.All : System.Windows.Forms.HtmlElementCollection" Usage="System.Windows.Forms.HtmlDocument.All" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取 <see cref="T:System.Windows.Forms.HtmlElementCollection" /> 的实例，该实例存储文档的所有 <see cref="T:System.Windows.Forms.HtmlElement" /> 对象。</summary>
        <value>文档中所有元素的 <see cref="T:System.Windows.Forms.HtmlElementCollection" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.HtmlDocument.All%2A>集合提供对 HTML 文档中的任何元素的随机访问，而不考虑其在文档树中的位置。 使用它按名称、ID 或索引访问 HTML 文档中的任何元素。 您还可以循环访问文档中的所有元素。  
  
 某些元素（如 `HEAD` 和 `TITLE` ）将永远不会有与其关联的名称。 所有其他元素仅在 HTML 文件的作者分配了名称时才具有名称。 可以通过 ID 或索引访问元素，而无需名称。  
  
 不能将元素直接添加到 <xref:System.Windows.Forms.HtmlDocument.All%2A> 集合中，因为标记之外的 HTML 文件中的所有元素都 `HTML` 必须具有父元素。 使用 <xref:System.Windows.Forms.HtmlElement.AppendChild%2A> 方法或上的 <xref:System.Windows.Forms.HtmlElement.InnerHtml%2A> 属性 <xref:System.Windows.Forms.HtmlElement> 将新元素添加到树中。  
  
   
  
## Examples  
 下面的代码示例将循环访问文档中的所有元素并对其进行设置 `Enabled=True` ，并启用默认情况下已禁用的任何元素，以防止用户在加载文档时进行输入。 此代码示例要求你的应用程序包含一个 <xref:System.Windows.Forms.WebBrowser> 名为的控件 `WebBrowser1` 。  
  
 [!code-csharp[System.Windows.Forms.HtmlDocument#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlDocument/CS/Form1.cs#1)]
 [!code-vb[System.Windows.Forms.HtmlDocument#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlDocument/VB/Form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/aa752582.aspx">all 属性</related>
      </Docs>
    </Member>
    <Member MemberName="AttachEventHandler">
      <MemberSignature Language="C#" Value="public void AttachEventHandler (string eventName, EventHandler eventHandler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AttachEventHandler(string eventName, class System.EventHandler eventHandler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlDocument.AttachEventHandler(System.String,System.EventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AttachEventHandler (eventName As String, eventHandler As EventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AttachEventHandler(System::String ^ eventName, EventHandler ^ eventHandler);" />
      <MemberSignature Language="F#" Value="member this.AttachEventHandler : string * EventHandler -&gt; unit" Usage="htmlDocument.AttachEventHandler (eventName, eventHandler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="eventName" Type="System.String" />
        <Parameter Name="eventHandler" Type="System.EventHandler" />
      </Parameters>
      <Docs>
        <param name="eventName">要处理的事件的名称。</param>
        <param name="eventHandler">用于处理事件的托管代码。</param>
        <summary>为已命名的 HTML DOM 事件添加事件处理程序。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在文档完成加载之前，不应将事件附加到文档或其对象之一。 应最早调用此方法的是在 <xref:System.Windows.Forms.WebBrowser.DocumentCompleted> 控件的事件中 <xref:System.Windows.Forms.WebBrowser> 。  
  
 此方法允许您将处理程序附加到未由公开的非托管 DOM 事件 <xref:System.Windows.Forms.HtmlDocument> 。 有关可用的非托管 DOM 事件的详细信息，请参阅 [访问托管 HTML 文档对象模型](/dotnet/framework/winforms/controls/accessing-unexposed-members-on-the-managed-html-document-object-model) 和 IHTMLDocument 接口上的未公开成员： [IHTMLDocument](https://go.microsoft.com/fwlink/?LinkId=104882)、 [IHTMLDocument2](https://go.microsoft.com/fwlink/?LinkId=104884)、 [IHTMLDocument3](https://go.microsoft.com/fwlink/?LinkId=104886)、 [IHTMLDocument4](https://go.microsoft.com/fwlink/?LinkId=104887)、 [IHTMLDocument5](https://go.microsoft.com/fwlink/?LinkId=104888)。  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/aa752535.aspx">Onpropertychange 方法</related>
      </Docs>
    </Member>
    <Member MemberName="BackColor">
      <MemberSignature Language="C#" Value="public System.Drawing.Color BackColor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Color BackColor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlDocument.BackColor" />
      <MemberSignature Language="VB.NET" Value="Public Property BackColor As Color" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Color BackColor { System::Drawing::Color get(); void set(System::Drawing::Color value); };" />
      <MemberSignature Language="F#" Value="member this.BackColor : System.Drawing.Color with get, set" Usage="System.Windows.Forms.HtmlDocument.BackColor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Color</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置 HTML 文档的背景色。</summary>
        <value>文档背景的 <see cref="T:System.Drawing.Color" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.HtmlDocument.BackColor%2A> 当没有其他元素占据屏幕的该区域时，将显示。  
  
 <xref:System.Drawing.Color>中的类型 [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] 支持 `Alpha` 值，但 HTML DOM 不支持。 因此， `Alpha` 分配给此属性时将不起作用。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.HtmlDocument.ForeColor" />
        <altmember cref="P:System.Windows.Forms.HtmlDocument.LinkColor" />
        <altmember cref="P:System.Windows.Forms.HtmlDocument.VisitedLinkColor" />
        <related type="Article" href="https://msdn.microsoft.com/library/aa752565.aspx">背景属性</related>
      </Docs>
    </Member>
    <Member MemberName="Body">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.HtmlElement Body { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.HtmlElement Body" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlDocument.Body" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Body As HtmlElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::HtmlElement ^ Body { System::Windows::Forms::HtmlElement ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Body : System.Windows.Forms.HtmlElement" Usage="System.Windows.Forms.HtmlDocument.Body" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElement</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取 <c>BODY</c> 标记的 <see cref="T:System.Windows.Forms.HtmlElement" />。</summary>
        <value><see cref="T:System.Windows.Forms.HtmlElement" /><c>正文</c>标记的对象。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 HTML 文档分为两个主要部分：  
  
-   `HEAD`，其中包含文档的标题、任何文档元数据和 `SCRIPT` 元素。  
  
-   `BODY`，其中包含文档的屏幕外观所涉及的所有元素。  
  
 上没有等效的 `Head` 属性 <xref:System.Windows.Forms.HtmlDocument> 。 若要获取 `HEAD` 元素，请使用 <xref:System.Windows.Forms.HtmlDocument.GetElementsByTagName%2A> 。  
  
   
  
## Examples  
 下面的代码示例创建一个新的 `DIV` 元素，并使用方法将其追加到文档的底部 <xref:System.Windows.Forms.HtmlElement.AppendChild%2A> 。  
  
 [!code-csharp[System.Windows.Forms.HtmlDocument#13](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlDocument/CS/Form1.cs#13)]
 [!code-vb[System.Windows.Forms.HtmlDocument#13](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlDocument/VB/Form1.vb#13)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/aa752585.aspx">body 属性</related>
      </Docs>
    </Member>
    <Member MemberName="Click">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.HtmlElementEventHandler Click;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.HtmlElementEventHandler Click" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.HtmlDocument.Click" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Click As HtmlElementEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::HtmlElementEventHandler ^ Click;" />
      <MemberSignature Language="F#" Value="member this.Click : System.Windows.Forms.HtmlElementEventHandler " Usage="member this.Click : System.Windows.Forms.HtmlElementEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当用户单击文档上的任何位置时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 有关处理事件的详细信息，请参阅 [处理和引发事件](/dotnet/standard/events/)。  
  
   
  
## Examples  
 下面的代码示例检测到文档上的单击，查找元素，并使用 <xref:System.Windows.Forms.HtmlElement.ScrollIntoView%2A> 将元素与网页的顶部对齐。  
  
 [!code-csharp[System.Windows.Forms.HtmlDocument#7](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlDocument/CS/Form1.cs#7)]
 [!code-vb[System.Windows.Forms.HtmlDocument#7](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlDocument/VB/Form1.vb#7)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/aa752611.aspx">onclick 事件</related>
      </Docs>
    </Member>
    <Member MemberName="ContextMenuShowing">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.HtmlElementEventHandler ContextMenuShowing;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.HtmlElementEventHandler ContextMenuShowing" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.HtmlDocument.ContextMenuShowing" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ContextMenuShowing As HtmlElementEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::HtmlElementEventHandler ^ ContextMenuShowing;" />
      <MemberSignature Language="F#" Value="member this.ContextMenuShowing : System.Windows.Forms.HtmlElementEventHandler " Usage="member this.ContextMenuShowing : System.Windows.Forms.HtmlElementEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当用户请求显示文档的上下文菜单时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 默认情况下，如果您在文档或文档中的某个元素上右键单击鼠标，将显示特定于该元素的默认上下文菜单。 使用此事件可取消显示上下文菜单，并显示您自己的菜单。  
  
   
  
## Examples  
 下面的代码示例捕获 <xref:System.Windows.Forms.HtmlDocument.ContextMenuShowing> 事件并使用它来显示 <xref:System.Windows.Forms.ContextMenuStrip> 。  
  
 [!code-csharp[System.Windows.Forms.HtmlDocument#15](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlDocument/CS/Form1.cs#15)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://developer.mozilla.org/en-us/docs/web/api/element/contextmenu_event">oncontextmenu 事件</related>
      </Docs>
    </Member>
    <Member MemberName="Cookie">
      <MemberSignature Language="C#" Value="public string Cookie { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Cookie" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlDocument.Cookie" />
      <MemberSignature Language="VB.NET" Value="Public Property Cookie As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Cookie { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Cookie : string with get, set" Usage="System.Windows.Forms.HtmlDocument.Cookie" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置与此文档关联的 HTTP Cookie。</summary>
        <value>一个包含 Cookie 列表的 <see cref="T:System.String" />，其中的各个 Cookie 之间由分号隔开。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 的 <xref:System.Windows.Forms.HtmlDocument.Cookie%2A> 属性 <xref:System.Windows.Forms.HtmlDocument> 公开为网页设置的所有 cookie。  
  
 *Cookie*是与给定网页相关联的任意名称/值对。 Web 开发人员使用 cookie 跟踪用户何时访问或返回到网站。 Cookie 由多个部件组成，称为 cookie crumb，用于确定以下各项：  
  
-   Cookie 应用于的文档集;其域和路径。  
  
-   Cookie 的名称和值。  
  
-   Cookie 的到期日期。  
  
-   是否只能使用安全连接发送 cookie。  
  
 <xref:System.Windows.Forms.HtmlDocument.Cookie%2A>属性可能包含多个 cookie。  
  
 <xref:System.Windows.Forms.HtmlDocument.Cookie%2A>一次只能使用属性设置一个 cookie。  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/aa752569.aspx">cookie 属性</related>
      </Docs>
    </Member>
    <Member MemberName="CreateElement">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.HtmlElement CreateElement (string elementTag);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Forms.HtmlElement CreateElement(string elementTag) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlDocument.CreateElement(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateElement (elementTag As String) As HtmlElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Forms::HtmlElement ^ CreateElement(System::String ^ elementTag);" />
      <MemberSignature Language="F#" Value="member this.CreateElement : string -&gt; System.Windows.Forms.HtmlElement" Usage="htmlDocument.CreateElement elementTag" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElement</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elementTag" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="elementTag">要创建的 HTML 元素的名称。</param>
        <summary>新建一个指定 HTML 标记类型的 <see langword="HtmlElement" />。</summary>
        <returns>指定标记类型的新元素。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `elementTag` 可以是 Internet Explorer 中任何受支持的 HTML 标记之一，但或除外 `FRAME` `IFRAME` 。  
  
 <xref:System.Windows.Forms.HtmlDocument.CreateElement%2A> 返回一个未附加到当前文档树的元素。 若要将元素添加到文档中，请使用 <xref:System.Windows.Forms.HtmlElement.InsertAdjacentElement%2A> 或 <xref:System.Windows.Forms.HtmlElement.AppendChild%2A> 方法。  
  
 当你使用 <xref:System.Windows.Forms.WebBrowser> 控件的 **视图源** 上下文菜单命令或 <xref:System.Windows.Forms.WebBrowser.DocumentText%2A> 控件的和属性时，此方法不会影响现有文档的源代码的状态 <xref:System.Windows.Forms.WebBrowser.DocumentStream%2A> <xref:System.Windows.Forms.WebBrowser> 。  
  
 当你创建的新元素时 <xref:System.Windows.Forms.HtmlDocument.CreateElement%2A> ，将无法设置某些属性，如 `Name` 。 在需要设置名称属性的情况下，请将这些属性以 HTML 格式分配给 <xref:System.Windows.Forms.HtmlElement.InnerHtml%2A> 文档中的其他对象的属性。  
  
   
  
## Examples  
 下面的代码示例使用 Northwind 数据库中的数据创建使用的 HTML 表 <xref:System.Windows.Forms.HtmlDocument.CreateElement%2A> 。 <xref:System.Windows.Forms.HtmlElement.AppendChild%2A>此外，还使用方法将单元 (`TD` 元素添加) 到行 (`TR` 元素) ，然后将行添加到表中，最后将表追加到当前文档的末尾。 此代码示例要求你的应用程序具有一个名为的 <xref:System.Windows.Forms.WebBrowser> 控件 `WebBrowser1` 。  
  
 [!code-csharp[System.Windows.Forms.HtmlDocument#10](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlDocument/CS/Form1.cs#10)]
 [!code-vb[System.Windows.Forms.HtmlDocument#10](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlDocument/VB/Form1.vb#10)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/aa752570.aspx">createElement 方法</related>
      </Docs>
    </Member>
    <Member MemberName="DefaultEncoding">
      <MemberSignature Language="C#" Value="public string DefaultEncoding { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string DefaultEncoding" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlDocument.DefaultEncoding" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DefaultEncoding As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ DefaultEncoding { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DefaultEncoding : string" Usage="System.Windows.Forms.HtmlDocument.DefaultEncoding" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取默认情况下为当前文档使用的编码。</summary>
        <value><see cref="T:System.String" />，表示首次显示页面时浏览器使用的编码。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 默认编码是在初始加载页面时，对托管 HTML 文档对象模型 (DOM) 将尝试使用的编码。 此编码从 Internet Explorer 的 **编码** 设置派生，或从 `META` 页面嵌入的标记派生。  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://developer.mozilla.org/en-us/docs/web/api/document">defaultCharset 属性</related>
      </Docs>
    </Member>
    <Member MemberName="DetachEventHandler">
      <MemberSignature Language="C#" Value="public void DetachEventHandler (string eventName, EventHandler eventHandler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DetachEventHandler(string eventName, class System.EventHandler eventHandler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlDocument.DetachEventHandler(System.String,System.EventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DetachEventHandler (eventName As String, eventHandler As EventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DetachEventHandler(System::String ^ eventName, EventHandler ^ eventHandler);" />
      <MemberSignature Language="F#" Value="member this.DetachEventHandler : string * EventHandler -&gt; unit" Usage="htmlDocument.DetachEventHandler (eventName, eventHandler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="eventName" Type="System.String" />
        <Parameter Name="eventHandler" Type="System.EventHandler" />
      </Parameters>
      <Docs>
        <param name="eventName">要停止处理的事件的名称。</param>
        <param name="eventHandler">用于处理事件的托管代码。</param>
        <summary>从 HTML DOM 上的命名事件中移除事件处理程序。</summary>
        <remarks>To be added.</remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/aa752539.aspx">detachEvent 方法</related>
      </Docs>
    </Member>
    <Member MemberName="Domain">
      <MemberSignature Language="C#" Value="public string Domain { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Domain" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlDocument.Domain" />
      <MemberSignature Language="VB.NET" Value="Public Property Domain As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Domain { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Domain : string with get, set" Usage="System.Windows.Forms.HtmlDocument.Domain" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置字符串，描述用于安全目的的此文档的域。</summary>
        <value>有效域。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 默认情况下，不同框架中的两个网页将无法使用脚本访问彼此的内容; `www.microsoft.com` `docs.microsoft.com` 在此实例中，甚至是，它们被视为不同的域。 若要为同一顶级域中的页面启用跨框架脚本，可以为属性分配一个新值 <xref:System.Windows.Forms.HtmlDocument.Domain%2A> 。 在上一个 URL 示例中，将设置 <xref:System.Windows.Forms.HtmlDocument.Domain%2A> 为 microsoft.com 将允许两个页面彼此通信。  
  
 分配给属性的字符串 <xref:System.Windows.Forms.HtmlDocument.Domain%2A> 必须是有效的顶级域。 在上一个 URL 示例中，可以将设置 <xref:System.Windows.Forms.HtmlDocument.Domain%2A> 为 microsoft.com，但不能设置为 .com，这会使 Internet 上的任何页面都可以为页面内容编写脚本。  
  
 不能使用 <xref:System.Windows.Forms.HtmlDocument.Domain%2A> 属性来启用跨框架脚本，以便使用两个不同的协议访问的页面。 如果页面中的一帧来自 Web 服务器 (http://协议) ，而另一帧来自文件系统 (file://) 协议，则无论属性的值如何，它们都不能彼此通信 <xref:System.Windows.Forms.HtmlDocument.Domain%2A> 。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><c>Domain</c> 属性的参数必须是遵循域名系统 (DNS) 约定的有效域名。</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/windows/internet-explorer/ie-developer/platform-apis/aa752575(v=vs.85)">域属性</related>
        <related type="Article" href="https://developer.mozilla.org/en-us/docs/web/html/element/frame">frame 对象</related>
      </Docs>
    </Member>
    <Member MemberName="DomDocument">
      <MemberSignature Language="C#" Value="public object DomDocument { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object DomDocument" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlDocument.DomDocument" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DomDocument As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ DomDocument { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DomDocument : obj" Usage="System.Windows.Forms.HtmlDocument.DomDocument" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取此 <see cref="T:System.Windows.Forms.HtmlDocument" /> 的非托管接口指针。</summary>
        <value><see cref="T:System.Object" />，它表示指向非托管文档的<c>IDispatch</c>指针。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.HtmlDocument> 是 Internet Explorer 的包装器文档对象模型 (DOM) ，它是使用 COM 编写的。 如果需要访问基础 COM 接口上的未公开的属性或方法（例如 `IHTMLDocument2` ），则可以使用此对象来查询它们。  
  
 要使用非托管接口，请将 MSHTML 库 ( # A0) 导入应用程序。 但是，您还可以使用方法执行未公开的属性和方法 `IDispatch::Invoke` 。  
  
   
  
## Examples  
 下面的代码示例将强制转换 <xref:System.Windows.Forms.HtmlDocument.DomDocument%2A> 为 `IHTMLDocument2` 指针，并显示属性的值 `lastModified` ，该属性指示文档所有者最后更新其内容的时间。 此代码示例要求你的 <xref:System.Windows.Forms.Button> 窗体上有一个名为的 `Button6` 。  
  
 [!code-csharp[System.Windows.Forms.HtmlDocument#3](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlDocument/CS/Form1.cs#3)]
 [!code-vb[System.Windows.Forms.HtmlDocument#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlDocument/VB/Form1.vb#3)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/windows/internet-explorer/ie-developer/platform-apis/aa752574(v=vs.85)">IHTMLDocument2 接口</related>
        <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkId=128638">MSHTML 引用</related>
      </Docs>
    </Member>
    <Member MemberName="Encoding">
      <MemberSignature Language="C#" Value="public string Encoding { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Encoding" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlDocument.Encoding" />
      <MemberSignature Language="VB.NET" Value="Public Property Encoding As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Encoding { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Encoding : string with get, set" Usage="System.Windows.Forms.HtmlDocument.Encoding" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置此文档的字符编码。</summary>
        <value>表示当前字符编码的 <see cref="T:System.String" />。</value>
        <remarks>To be added.</remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/ms537500.aspx">字符集识别</related>
        <related type="Article" href="https://msdn.microsoft.com/library/aa752566.aspx">字符集属性</related>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlDocument.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="htmlDocument.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">要测试的对象。</param>
        <summary>测试对象是否与当前对象相等。</summary>
        <returns>如果对象相同，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ExecCommand">
      <MemberSignature Language="C#" Value="public void ExecCommand (string command, bool showUI, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ExecCommand(string command, bool showUI, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlDocument.ExecCommand(System.String,System.Boolean,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ExecCommand (command As String, showUI As Boolean, value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ExecCommand(System::String ^ command, bool showUI, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="member this.ExecCommand : string * bool * obj -&gt; unit" Usage="htmlDocument.ExecCommand (command, showUI, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="command" Type="System.String" />
        <Parameter Name="showUI" Type="System.Boolean" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="command">要执行的命令的名称。</param>
        <param name="showUI">是否向用户显示命令特定的对话框或消息框。</param>
        <param name="value">要使用该命令分配的值。 并非适用于所有命令。</param>
        <summary>对文档执行指定的命令。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.HtmlDocument.ExecCommand%2A> 公开一大数组的命令，这些命令没有公开的方法 <xref:System.Windows.Forms.HtmlDocument> 。 使用 <xref:System.Windows.Forms.HtmlDocument.ExecCommand%2A> 可以插入新的 HTML 元素、选择文本并设置文本格式，以及清除任何缓存的身份验证凭据。 有关完整的命令列表，请参阅 [命令标识符](https://go.microsoft.com/fwlink/?LinkId=198814)。  
  
> [!NOTE]
>  某些命令（如 copy）具有返回值。 在的当前实现中 <xref:System.Windows.Forms.HtmlDocument.ExecCommand%2A> ，无法从调用中获取返回值。 若要检索返回值，请改用引用的对应非托管方法 <xref:System.Windows.Forms.HtmlDocument.DomDocument%2A> 。  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/ms536419.aspx">execCommand 方法</related>
        <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkId=198814">命令标识符</related>
      </Docs>
    </Member>
    <Member MemberName="Focus">
      <MemberSignature Language="C#" Value="public void Focus ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Focus() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlDocument.Focus" />
      <MemberSignature Language="VB.NET" Value="Public Sub Focus ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Focus();" />
      <MemberSignature Language="F#" Value="member this.Focus : unit -&gt; unit" Usage="htmlDocument.Focus " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>在当前文档上设置用户输入焦点。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.HtmlDocument.Focus%2A>如果控件当前没有焦点，则调用会将焦点设置到 <xref:System.Windows.Forms.WebBrowser> 控件上。 如果文档承载于中 `FRAME` ，则此方法会将焦点放在 `FRAME` 中 `FRAMESET` 。  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/aa752527.aspx">focus 方法</related>
      </Docs>
    </Member>
    <Member MemberName="Focused">
      <MemberSignature Language="C#" Value="public bool Focused { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Focused" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlDocument.Focused" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Focused As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Focused { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.Focused : bool" Usage="System.Windows.Forms.HtmlDocument.Focused" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示文档是否具有用户输入焦点。</summary>
        <value>如果该文档具有焦点，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Forms.HtmlDocument.Focus" />
        <altmember cref="E:System.Windows.Forms.HtmlDocument.Focusing" />
        <altmember cref="E:System.Windows.Forms.HtmlDocument.LosingFocus" />
      </Docs>
    </Member>
    <Member MemberName="Focusing">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.HtmlElementEventHandler Focusing;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.HtmlElementEventHandler Focusing" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.HtmlDocument.Focusing" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Focusing As HtmlElementEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::HtmlElementEventHandler ^ Focusing;" />
      <MemberSignature Language="F#" Value="member this.Focusing : System.Windows.Forms.HtmlElementEventHandler " Usage="member this.Focusing : System.Windows.Forms.HtmlElementEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在将焦点提供给文档之前发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 有关处理事件的详细信息，请参阅 [处理和引发事件](/dotnet/standard/events/)。  
  
   
  
## Examples  
 下面的代码示例演示如何使用此成员。 在此示例中，事件处理程序报告事件的发生 <xref:System.Windows.Forms.HtmlDocument.Focusing> 。 此报表可帮助你了解何时发生事件，并可帮助你进行调试。  
  
 若要运行示例代码，请将其粘贴到包含名为的类型的实例的项目中 <xref:System.Windows.Forms.HtmlDocument> `HtmlDocument1` 。 然后，确保事件处理程序与事件相关联 <xref:System.Windows.Forms.HtmlDocument.Focusing> 。  
  
 [!code-csharp[System.Windows.Forms.EventExamples#424](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#424)]
 [!code-vb[System.Windows.Forms.EventExamples#424](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#424)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/aa752520.aspx">onfocusin 事件</related>
      </Docs>
    </Member>
    <Member MemberName="ForeColor">
      <MemberSignature Language="C#" Value="public System.Drawing.Color ForeColor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Color ForeColor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlDocument.ForeColor" />
      <MemberSignature Language="VB.NET" Value="Public Property ForeColor As Color" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Color ForeColor { System::Drawing::Color get(); void set(System::Drawing::Color value); };" />
      <MemberSignature Language="F#" Value="member this.ForeColor : System.Drawing.Color with get, set" Usage="System.Windows.Forms.HtmlDocument.ForeColor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Color</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置文档的文本颜色。</summary>
        <value>文档中文本的颜色。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Drawing.Color> <xref:System.Drawing.Color> 中的类型 [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] 支持 `Alpha` 值，但 HTML DOM 不支持。 因此， `Alpha` 分配给此属性时将不起作用。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.HtmlDocument.BackColor" />
        <altmember cref="P:System.Windows.Forms.HtmlDocument.LinkColor" />
        <altmember cref="P:System.Windows.Forms.HtmlDocument.VisitedLinkColor" />
        <related type="Article" href="https://msdn.microsoft.com/library/aa752580.aspx">fgColor 属性</related>
      </Docs>
    </Member>
    <Member MemberName="Forms">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.HtmlElementCollection Forms { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.HtmlElementCollection Forms" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlDocument.Forms" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Forms As HtmlElementCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::HtmlElementCollection ^ Forms { System::Windows::Forms::HtmlElementCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Forms : System.Windows.Forms.HtmlElementCollection" Usage="System.Windows.Forms.HtmlDocument.Forms" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取文档中所有<c> &lt; 窗体 &gt; </c>元素的集合。</summary>
        <value><see cref="T:System.Windows.Forms.HtmlElementCollection" />文档中<c> &lt; 窗体 &gt; </c>元素的。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 HTML 文档可能有一个或多个 `FORM` 元素，其中包含用于将数据提交回服务器的输入字段。  
  
 您可以 `FORM` 通过 <xref:System.Windows.Forms.HtmlElement> 使用方法来获取和调用其方法，以编程方式提交 `Submit` <xref:System.Windows.Forms.HtmlElement.InvokeMember%2A> 。  
  
 若要向文档中添加新的 `FORM` 标记，可以创建一个新 `FORM` 标记作为字符串，并将其分配给 <xref:System.Windows.Forms.HtmlElement.InnerHtml%2A> 以前添加到 HTML DOM 的元素的属性; 也可以使用 <xref:System.Windows.Forms.HtmlDocument.CreateElement%2A> 方法，使用设置其属性 <xref:System.Windows.Forms.HtmlElement.SetAttribute%2A> ，并使用将其添加为现有元素的子元素 <xref:System.Windows.Forms.HtmlElement.AppendChild%2A> 。  
  
   
  
## Examples  
 下面的代码示例将循环访问 `Form` 网页上的所有元素，并清除所有用户输入，并将窗体重新设置为其默认值。  
  
 [!code-csharp[System.Windows.Forms.HtmlDocument#4](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlDocument/CS/Form1.cs#4)]
 [!code-vb[System.Windows.Forms.HtmlDocument#4](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlDocument/VB/Form1.vb#4)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/aa752591.aspx">forms 属性</related>
        <related type="Article" href="https://msdn.microsoft.com/library/aa752432.aspx">IHTMLFormElement 接口</related>
      </Docs>
    </Member>
    <Member MemberName="GetElementById">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.HtmlElement GetElementById (string id);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Forms.HtmlElement GetElementById(string id) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlDocument.GetElementById(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetElementById (id As String) As HtmlElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Forms::HtmlElement ^ GetElementById(System::String ^ id);" />
      <MemberSignature Language="F#" Value="member this.GetElementById : string -&gt; System.Windows.Forms.HtmlElement" Usage="htmlDocument.GetElementById id" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElement</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="id">要检索的元素的 ID 特性。</param>
        <summary>将元素的 <c>ID</c> 特性用作搜索键来检索单个 <see cref="T:System.Windows.Forms.HtmlElement" />。</summary>
        <returns>返回第一个与指定的值具有相同 <c>ID</c> 特性的对象；如果找不到 <paramref name="id" />，则返回 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果文档中有多个具有相同 ID 值的元素，则 <xref:System.Windows.Forms.HtmlDocument.GetElementById%2A> 将返回找到的第一个元素。  
  
   
  
## Examples  
 下面的代码示例从文档中检索名为的 `TABLE` ，并计算行数，并在网页中显示结果。 此代码示例要求你 <xref:System.Windows.Forms.WebBrowser> 在项目中有一个名为的控件 `WebBrowser1` ，并且已加载了一个 `TABLE` 其 `ID` 特性为 `Table1` 的网页。  
  
 [!code-csharp[System.Windows.Forms.HtmlDocument#5](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlDocument/CS/Form1.cs#5)]
 [!code-vb[System.Windows.Forms.HtmlDocument#5](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlDocument/VB/Form1.vb#5)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/aa752543.aspx">Document.getelementbyid 方法</related>
      </Docs>
    </Member>
    <Member MemberName="GetElementFromPoint">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.HtmlElement GetElementFromPoint (System.Drawing.Point point);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Forms.HtmlElement GetElementFromPoint(valuetype System.Drawing.Point point) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlDocument.GetElementFromPoint(System.Drawing.Point)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetElementFromPoint (point As Point) As HtmlElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Forms::HtmlElement ^ GetElementFromPoint(System::Drawing::Point point);" />
      <MemberSignature Language="F#" Value="member this.GetElementFromPoint : System.Drawing.Point -&gt; System.Windows.Forms.HtmlElement" Usage="htmlDocument.GetElementFromPoint point" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElement</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="point" Type="System.Drawing.Point" />
      </Parameters>
      <Docs>
        <param name="point">屏幕上的元素的 x,y 位置，该位置相对于文档的左上角。</param>
        <summary>检索位于指定工作区坐标位置的 HTML 元素。</summary>
        <returns>文档中位于指定屏幕位置的 <see cref="T:System.Windows.Forms.HtmlElement" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.HtmlDocument.GetElementFromPoint%2A> 使用工作区坐标，在这种情况下，文档的左上角将值 (0，0) 。 可以使用属性来获取游标当前位置的工作区坐标 <xref:System.Windows.Forms.HtmlWindow.Position%2A> 。  
  
   
  
## Examples  
 下面的代码示例检测到文档上的单击，查找元素，并使用 <xref:System.Windows.Forms.HtmlElement.ScrollIntoView%2A> 将元素与网页的顶部对齐。  
  
 [!code-csharp[System.Windows.Forms.HtmlDocument#7](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlDocument/CS/Form1.cs#7)]
 [!code-vb[System.Windows.Forms.HtmlDocument#7](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlDocument/VB/Form1.vb#7)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/aa752576.aspx">elementFromPoint 方法</related>
      </Docs>
    </Member>
    <Member MemberName="GetElementsByTagName">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.HtmlElementCollection GetElementsByTagName (string tagName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Forms.HtmlElementCollection GetElementsByTagName(string tagName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlDocument.GetElementsByTagName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetElementsByTagName (tagName As String) As HtmlElementCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Forms::HtmlElementCollection ^ GetElementsByTagName(System::String ^ tagName);" />
      <MemberSignature Language="F#" Value="member this.GetElementsByTagName : string -&gt; System.Windows.Forms.HtmlElementCollection" Usage="htmlDocument.GetElementsByTagName tagName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tagName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="tagName">要检索的 <see cref="T:System.Windows.Forms.HtmlElement" /> 对象的 HTML 标记名。</param>
        <summary>检索具有指定 HTML 标记的元素集合。</summary>
        <returns>标记名等于 <paramref name="tagName" /> 参数的元素集合。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 HTML 页面通常使用 `META` 标记来嵌入有关文档的任意信息。 以下 HTML 代码示例检索 `META` HTML 文档中的所有标记，查找名称为的 `META` 标记 `Description` ，并将其显示给用户。 此代码示例要求你的应用程序具有一个 <xref:System.Windows.Forms.WebBrowser> 名为的控件 `WebBrowser1` 。  
  
 [!code-csharp[System.Windows.Forms.HtmlDocument#6](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlDocument/CS/Form1.cs#6)]
 [!code-vb[System.Windows.Forms.HtmlDocument#6](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlDocument/VB/Form1.vb#6)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/aa752545.aspx">getElementsByTagName 方法</related>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlDocument.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="htmlDocument.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>检索此对象的哈希代码。</summary>
        <returns>一个 <see cref="T:System.Int32" />，表示此对象在内存中的哈希。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Images">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.HtmlElementCollection Images { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.HtmlElementCollection Images" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlDocument.Images" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Images As HtmlElementCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::HtmlElementCollection ^ Images { System::Windows::Forms::HtmlElementCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Images : System.Windows.Forms.HtmlElementCollection" Usage="System.Windows.Forms.HtmlDocument.Images" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取文档中所有图像标记的集合。</summary>
        <value><see cref="T:System.Windows.Forms.HtmlElement" /> 对象的集合，每个对象对应于文档中的一个 IMG 标记。 元素按源顺序从集合中返回。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.HtmlDocument.Images%2A> 返回对象的集合 <xref:System.Windows.Forms.HtmlElement> 。 若要访问 `ALT` `SRC` 不是由直接公开的属性（如和） <xref:System.Windows.Forms.HtmlElement> ，请使用 <xref:System.Windows.Forms.HtmlElement.GetAttribute%2A> 方法。  
  
 若要将新图像添加到文档中，请将新 `IMG` 标记创建为字符串，并将其分配给 <xref:System.Windows.Forms.HtmlElement.InnerHtml%2A> 以前添加到 HTML DOM 的元素的属性; 或者使用 <xref:System.Windows.Forms.HtmlDocument.CreateElement%2A> 方法，使用设置其属性 <xref:System.Windows.Forms.HtmlElement.SetAttribute%2A> ，并使用将其添加为现有元素的子元素 <xref:System.Windows.Forms.HtmlElement.AppendChild%2A> 。  
  
   
  
## Examples  
 下面的代码示例检查 `ALT` 文档中所有图像的属性， `ALT` 如果尚未设置值，则设置默认属性。  
  
 [!code-csharp[System.Windows.Forms.HtmlDocument#8](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlDocument/CS/Form1.cs#8)]
 [!code-vb[System.Windows.Forms.HtmlDocument#8](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlDocument/VB/Form1.vb#8)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/aa752593.aspx">images 属性</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="InvokeScript">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>执行在 HTML 页面中定义的活动脚本函数。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下面的代码示例执行网页中的脚本的内容。 此代码示例要求你已加载以下网页。  
  
```  
<HTML>  
<SCRIPT>  
function test(name, address) {  
window.alert("Name is " + name + "; address is " + address);  
}  
</SCRIPT>  
  
<BODY>  
</BODY>  
</HTML>  
  
```  
  
 [!code-csharp[System.Windows.Forms.HtmlDocument#9](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlDocument/CS/Form1.cs#9)]
 [!code-vb[System.Windows.Forms.HtmlDocument#9](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlDocument/VB/Form1.vb#9)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="InvokeScript">
      <MemberSignature Language="C#" Value="public object InvokeScript (string scriptName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object InvokeScript(string scriptName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlDocument.InvokeScript(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function InvokeScript (scriptName As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ InvokeScript(System::String ^ scriptName);" />
      <MemberSignature Language="F#" Value="member this.InvokeScript : string -&gt; obj" Usage="htmlDocument.InvokeScript scriptName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="scriptName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="scriptName">要调用的脚本方法的名称。</param>
        <summary>执行在 HTML 页面中定义的活动脚本函数。</summary>
        <returns>活动脚本调用所返回的对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 返回的对象的基础类型 <xref:System.Windows.Forms.HtmlDocument.InvokeScript%2A> 将有所不同。 如果调用的活动脚本函数返回标量数据（如字符串或整数），则它将作为字符串返回。 如果它返回基于脚本的对象（如使用 JScript 或 VBScript 运算符创建的对象）， `new` 则它将为类型 `Object` 。  (你可以通过调用并使用来对此类对象进行调用 <xref:System.Object.GetType%2A> <xref:System.Type.InvokeMember%2A> ) 。如果它返回一个 HTML DOM 元素（如 `DIV` 或 `TABLE` ），则它将为类型 `Object` ; 如果已将项目引用添加到 MSHTML.DLL，则它将强制转换为其特定的非托管 DOM 类型。  
  
 您可以调用在用户计算机上安装的任何活动脚本语言（包括 JScript 和 VBScript）编写的任何函数。  
  
 <xref:System.Windows.Forms.HtmlDocument.InvokeScript%2A>如果用户已在 Internet Explorer 中显式关闭脚本执行，或者如果网页的当前安全配置不允许，则不会执行任何操作。  
  
   
  
## Examples  
 下面的代码示例执行网页中的脚本的内容。 此代码示例要求你的 <xref:System.Windows.Forms.WebBrowser> 应用程序中有一个名为的 `WebBrowser1` ，并且已加载以下网页。  
  
```  
<HTML>  
  
    <HEAD>  
        <TITLE>Invoke Script Sample</TITLE>  
  
        <SCRIPT>  
            function MyObject() {  
                this.Data = "Data for my private object.";  
            }  
            // Return a string.  
            function test() {  
                return("This is a test.");  
            }  
            // Return a JScript object.  
            function testJScriptObject() {  
                return(new(MyObject));  
            }  
            // Return a DOM element.  
            function testElement() {  
                return(div1);  
            }  
        </SCRIPT>  
    </HEAD>  
  
    <BODY>  
  
        <DIV id="div1">  
        </DIV>  
  
    </BODY>  
  
</HTML>  
  
```  
  
 [!code-csharp[System.Windows.Forms.HtmlDocument#12](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlDocument/CS/Form1.cs#12)]
 [!code-vb[System.Windows.Forms.HtmlDocument#12](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlDocument/VB/Form1.vb#12)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InvokeScript">
      <MemberSignature Language="C#" Value="public object InvokeScript (string scriptName, object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object InvokeScript(string scriptName, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlDocument.InvokeScript(System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function InvokeScript (scriptName As String, args As Object()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ InvokeScript(System::String ^ scriptName, cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="member this.InvokeScript : string * obj[] -&gt; obj" Usage="htmlDocument.InvokeScript (scriptName, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="scriptName" Type="System.String" />
        <Parameter Name="args" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="scriptName">要调用的脚本方法的名称。</param>
        <param name="args">要传递给脚本方法的自变量。</param>
        <summary>执行在 HTML 页面中定义的活动脚本函数。</summary>
        <returns>活动脚本调用所返回的对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 返回的对象的基础类型 <xref:System.Windows.Forms.HtmlDocument.InvokeScript%2A> 将有所不同。 如果调用的活动脚本函数返回标量数据（如字符串或整数），则它将作为字符串返回。 如果它返回基于脚本的对象（如使用 JScript 或 VBScript 运算符创建的对象）， `new` 则它将为类型 `Object` 。  (你可以通过调用并使用来对此类对象进行调用 <xref:System.Object.GetType%2A> <xref:System.Type.InvokeMember%2A> ) 。如果它返回一个 HTML DOM 元素（如 `DIV` 或 `TABLE` ），则它将为类型 `Object` ; 如果已将项目引用添加到 MSHTML.DLL，则它将强制转换为其特定的非托管 DOM 类型。  
  
 您可以调用在用户计算机上安装的任何活动脚本语言（包括 JScript 和 VBScript）编写的任何函数。  
  
 如果用户已在 Internet Explorer 中显式关闭脚本执行，或者如果网页的当前安全配置不允许，则此方法不会执行任何操作。  
  
   
  
## Examples  
 下面的代码示例执行网页中的脚本的内容。 此代码示例要求你的 <xref:System.Windows.Forms.WebBrowser> 应用程序中有一个名为的 `WebBrowser1` ，并且已加载以下网页。  
  
```  
<HTML>  
    <SCRIPT>  
        function test(name, address) {  
            window.alert("Name is " + name + "; address is " + address);  
        }  
    </SCRIPT>  
  
    <BODY>  
    </BODY>  
</HTML>  
  
```  
  
 [!code-csharp[System.Windows.Forms.HtmlDocument#9](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlDocument/CS/Form1.cs#9)]
 [!code-vb[System.Windows.Forms.HtmlDocument#9](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlDocument/VB/Form1.vb#9)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LinkColor">
      <MemberSignature Language="C#" Value="public System.Drawing.Color LinkColor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Color LinkColor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlDocument.LinkColor" />
      <MemberSignature Language="VB.NET" Value="Public Property LinkColor As Color" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Color LinkColor { System::Drawing::Color get(); void set(System::Drawing::Color value); };" />
      <MemberSignature Language="F#" Value="member this.LinkColor : System.Drawing.Color with get, set" Usage="System.Windows.Forms.HtmlDocument.LinkColor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Color</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置超链接的颜色。</summary>
        <value>当前文档中超链接的颜色。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Drawing.Color>中的类型 [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] 支持 `Alpha` 值，但 HTML DOM 不支持。 因此， `Alpha` 分配给此属性时将不起作用。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.HtmlDocument.ForeColor" />
        <altmember cref="P:System.Windows.Forms.HtmlDocument.BackColor" />
        <altmember cref="P:System.Windows.Forms.HtmlDocument.VisitedLinkColor" />
        <related type="Article" href="https://msdn.microsoft.com/library/aa752608.aspx">linkColor 属性</related>
      </Docs>
    </Member>
    <Member MemberName="Links">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.HtmlElementCollection Links { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.HtmlElementCollection Links" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlDocument.Links" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Links As HtmlElementCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::HtmlElementCollection ^ Links { System::Windows::Forms::HtmlElementCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Links : System.Windows.Forms.HtmlElementCollection" Usage="System.Windows.Forms.HtmlDocument.Links" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取此 HTML 文档中所有超链接的列表。</summary>
        <value><see cref="T:System.Windows.Forms.HtmlElementCollection" /> 对象的 <see cref="T:System.Windows.Forms.HtmlElement" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此集合将包含 `A` `LINK` 在 HTML 中使用、和标记创建的所有链接 `AREA` 。  
  
 <xref:System.Windows.Forms.HtmlElement>此集合中包含的对象封装了非托管 `IHTMLLinkElement` 接口。 若要安全地访问基础接口的属性，请使用 <xref:System.Windows.Forms.HtmlElement.GetAttribute%2A> 方法。  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/aa752595.aspx">links 属性</related>
      </Docs>
    </Member>
    <Member MemberName="LosingFocus">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.HtmlElementEventHandler LosingFocus;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.HtmlElementEventHandler LosingFocus" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.HtmlDocument.LosingFocus" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event LosingFocus As HtmlElementEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::HtmlElementEventHandler ^ LosingFocus;" />
      <MemberSignature Language="F#" Value="member this.LosingFocus : System.Windows.Forms.HtmlElementEventHandler " Usage="member this.LosingFocus : System.Windows.Forms.HtmlElementEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在焦点离开控件时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 有关处理事件的详细信息，请参阅 [处理和引发事件](/dotnet/standard/events/)。  
  
   
  
## Examples  
 下面的代码示例演示如何使用此成员。 在此示例中，事件处理程序报告事件的发生 <xref:System.Windows.Forms.HtmlDocument.LosingFocus> 。 此报表可帮助你了解何时发生事件，并可帮助你进行调试。  
  
 若要运行示例代码，请将其粘贴到包含名为的类型的实例的项目中 <xref:System.Windows.Forms.HtmlDocument> `HtmlDocument1` 。 然后，确保事件处理程序与事件相关联 <xref:System.Windows.Forms.HtmlDocument.LosingFocus> 。  
  
 [!code-csharp[System.Windows.Forms.EventExamples#425](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#425)]
 [!code-vb[System.Windows.Forms.EventExamples#425](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#425)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/aa752521.aspx">onfocusout 事件</related>
      </Docs>
    </Member>
    <Member MemberName="MouseDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.HtmlElementEventHandler MouseDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.HtmlElementEventHandler MouseDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.HtmlDocument.MouseDown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseDown As HtmlElementEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::HtmlElementEventHandler ^ MouseDown;" />
      <MemberSignature Language="F#" Value="member this.MouseDown : System.Windows.Forms.HtmlElementEventHandler " Usage="member this.MouseDown : System.Windows.Forms.HtmlElementEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当用户单击鼠标左键时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.HtmlDocument.MouseDown>事件发生在事件之前 <xref:System.Windows.Forms.HtmlDocument.Click> 。  
  
 有关处理事件的详细信息，请参阅 [处理和引发事件](/dotnet/standard/events/)。  
  
   
  
## Examples  
 下面的代码示例演示如何使用此成员。 在此示例中，事件处理程序报告事件的发生 <xref:System.Windows.Forms.HtmlDocument.MouseDown> 。 此报表可帮助你了解何时发生事件，并可帮助你进行调试。 若要报告多个事件或频繁发生的事件，请考虑 <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> 将消息替换为多行或将其追加到多行 <xref:System.Windows.Forms.TextBox> 。  
  
 若要运行示例代码，请将其粘贴到包含名为的类型的实例的项目中 <xref:System.Windows.Forms.HtmlDocument> `HtmlDocument1` 。 然后，确保事件处理程序与事件相关联 <xref:System.Windows.Forms.HtmlDocument.MouseDown> 。  
  
 [!code-csharp[System.Windows.Forms.EventExamples#426](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#426)]
 [!code-vb[System.Windows.Forms.EventExamples#426](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#426)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/aa752619.aspx">onmousedown 事件</related>
      </Docs>
    </Member>
    <Member MemberName="MouseLeave">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.HtmlElementEventHandler MouseLeave;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.HtmlElementEventHandler MouseLeave" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.HtmlDocument.MouseLeave" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseLeave As HtmlElementEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::HtmlElementEventHandler ^ MouseLeave;" />
      <MemberSignature Language="F#" Value="member this.MouseLeave : System.Windows.Forms.HtmlElementEventHandler " Usage="member this.MouseLeave : System.Windows.Forms.HtmlElementEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当鼠标不再悬停于文档上时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 有关处理事件的详细信息，请参阅 [处理和引发事件](/dotnet/standard/events/)。  
  
   
  
## Examples  
 下面的代码示例演示如何使用此成员。 在此示例中，事件处理程序报告事件的发生 <xref:System.Windows.Forms.HtmlDocument.MouseLeave> 。 此报表可帮助你了解何时发生事件，并可帮助你进行调试。 若要报告多个事件或频繁发生的事件，请考虑 <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> 将消息替换为多行或将其追加到多行 <xref:System.Windows.Forms.TextBox> 。  
  
 若要运行示例代码，请将其粘贴到包含名为的类型的实例的项目中 <xref:System.Windows.Forms.HtmlDocument> `HtmlDocument1` 。 然后，确保事件处理程序与事件相关联 <xref:System.Windows.Forms.HtmlDocument.MouseLeave> 。  
  
 [!code-csharp[System.Windows.Forms.EventExamples#427](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#427)]
 [!code-vb[System.Windows.Forms.EventExamples#427](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#427)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://developer.mozilla.org/en-us/docs/web/api/element/mouseout_event">onmouseout 事件</related>
      </Docs>
    </Member>
    <Member MemberName="MouseMove">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.HtmlElementEventHandler MouseMove;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.HtmlElementEventHandler MouseMove" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.HtmlDocument.MouseMove" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseMove As HtmlElementEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::HtmlElementEventHandler ^ MouseMove;" />
      <MemberSignature Language="F#" Value="member this.MouseMove : System.Windows.Forms.HtmlElementEventHandler " Usage="member this.MouseMove : System.Windows.Forms.HtmlElementEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当鼠标移到文档上时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 有关处理事件的详细信息，请参阅 [处理和引发事件](/dotnet/standard/events/)。  
  
   
  
## Examples  
 下面的代码示例演示如何使用此成员。 在此示例中，事件处理程序报告事件的发生 <xref:System.Windows.Forms.HtmlDocument.MouseMove> 。 此报表可帮助你了解何时发生事件，并可帮助你进行调试。 若要报告多个事件或频繁发生的事件，请考虑 <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> 将消息替换为多行或将其追加到多行 <xref:System.Windows.Forms.TextBox> 。  
  
 若要运行示例代码，请将其粘贴到包含名为的类型的实例的项目中 <xref:System.Windows.Forms.HtmlDocument> `HtmlDocument1` 。 然后，确保事件处理程序与事件相关联 <xref:System.Windows.Forms.HtmlDocument.MouseMove> 。  
  
 [!code-csharp[System.Windows.Forms.EventExamples#428](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#428)]
 [!code-vb[System.Windows.Forms.EventExamples#428](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#428)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/aa752620.aspx">onmousemove 事件</related>
      </Docs>
    </Member>
    <Member MemberName="MouseOver">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.HtmlElementEventHandler MouseOver;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.HtmlElementEventHandler MouseOver" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.HtmlDocument.MouseOver" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseOver As HtmlElementEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::HtmlElementEventHandler ^ MouseOver;" />
      <MemberSignature Language="F#" Value="member this.MouseOver : System.Windows.Forms.HtmlElementEventHandler " Usage="member this.MouseOver : System.Windows.Forms.HtmlElementEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当鼠标移到文档上时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 有关处理事件、 [处理和引发事件](/dotnet/standard/events/)的详细信息。  
  
   
  
## Examples  
 下面的代码示例演示如何使用此成员。 在此示例中，事件处理程序报告事件的发生 <xref:System.Windows.Forms.HtmlDocument.MouseOver> 。 此报表可帮助你了解何时发生事件，并可帮助你进行调试。 若要报告多个事件或频繁发生的事件，请考虑 <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> 将消息替换为多行或将其追加到多行 <xref:System.Windows.Forms.TextBox> 。  
  
 若要运行示例代码，请将其粘贴到包含名为的类型的实例的项目中 <xref:System.Windows.Forms.HtmlDocument> `HtmlDocument1` 。 然后，确保事件处理程序与事件相关联 <xref:System.Windows.Forms.HtmlDocument.MouseOver> 。  
  
 [!code-csharp[System.Windows.Forms.EventExamples#429](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#429)]
 [!code-vb[System.Windows.Forms.EventExamples#429](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#429)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/aa752622.aspx">onmouseover 事件</related>
      </Docs>
    </Member>
    <Member MemberName="MouseUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.HtmlElementEventHandler MouseUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.HtmlElementEventHandler MouseUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.HtmlDocument.MouseUp" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseUp As HtmlElementEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::HtmlElementEventHandler ^ MouseUp;" />
      <MemberSignature Language="F#" Value="member this.MouseUp : System.Windows.Forms.HtmlElementEventHandler " Usage="member this.MouseUp : System.Windows.Forms.HtmlElementEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当用户释放鼠标左键时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 有关处理事件的详细信息，请参阅 [处理和引发事件](/dotnet/standard/events/)。  
  
   
  
## Examples  
 下面的代码示例演示如何使用此成员。 在此示例中，事件处理程序报告事件的发生 <xref:System.Windows.Forms.HtmlDocument.MouseUp> 。 此报表可帮助你了解何时发生事件，并可帮助你进行调试。 若要报告多个事件或频繁发生的事件，请考虑 <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> 将消息替换为多行或将其追加到多行 <xref:System.Windows.Forms.TextBox> 。  
  
 若要运行示例代码，请将其粘贴到包含名为的类型的实例的项目中 <xref:System.Windows.Forms.HtmlDocument> `HtmlDocument1` 。 然后，确保事件处理程序与事件相关联 <xref:System.Windows.Forms.HtmlDocument.MouseUp> 。  
  
 [!code-csharp[System.Windows.Forms.EventExamples#430](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#430)]
 [!code-vb[System.Windows.Forms.EventExamples#430](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#430)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/aa752623.aspx">onmouseup 事件</related>
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (System.Windows.Forms.HtmlDocument left, System.Windows.Forms.HtmlDocument right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(class System.Windows.Forms.HtmlDocument left, class System.Windows.Forms.HtmlDocument right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlDocument.op_Equality(System.Windows.Forms.HtmlDocument,System.Windows.Forms.HtmlDocument)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As HtmlDocument, right As HtmlDocument) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::Windows::Forms::HtmlDocument ^ left, System::Windows::Forms::HtmlDocument ^ right);" />
      <MemberSignature Language="F#" Value="static member ( = ) : System.Windows.Forms.HtmlDocument * System.Windows.Forms.HtmlDocument -&gt; bool" Usage="left = right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Windows.Forms.HtmlDocument" />
        <Parameter Name="right" Type="System.Windows.Forms.HtmlDocument" />
      </Parameters>
      <Docs>
        <param name="left">要比较的第一个实例。</param>
        <param name="right">要比较的第二个实例。</param>
        <summary>返回一个值，该值指示指定的 <see cref="T:System.Windows.Forms.HtmlDocument" /> 实例是否表示同一个值。</summary>
        <returns>若指定实例相等，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[此运算符的等效方法是 <xref:System.Windows.Forms.HtmlDocument.Equals%28System.Object%29?displayProperty=nameWithType>]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (System.Windows.Forms.HtmlDocument left, System.Windows.Forms.HtmlDocument right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(class System.Windows.Forms.HtmlDocument left, class System.Windows.Forms.HtmlDocument right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlDocument.op_Inequality(System.Windows.Forms.HtmlDocument,System.Windows.Forms.HtmlDocument)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As HtmlDocument, right As HtmlDocument) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::Windows::Forms::HtmlDocument ^ left, System::Windows::Forms::HtmlDocument ^ right);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : System.Windows.Forms.HtmlDocument * System.Windows.Forms.HtmlDocument -&gt; bool" Usage="System.Windows.Forms.HtmlDocument.op_Inequality (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Windows.Forms.HtmlDocument" />
        <Parameter Name="right" Type="System.Windows.Forms.HtmlDocument" />
      </Parameters>
      <Docs>
        <param name="left">要比较的第一个实例。</param>
        <param name="right">要比较的第二个实例。</param>
        <summary>返回一个值，该值指示指定的 <see cref="T:System.Windows.Forms.HtmlDocument" /> 实例是否不表示同一个值。</summary>
        <returns>如果指定的实例不相等，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OpenNew">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.HtmlDocument OpenNew (bool replaceInHistory);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Forms.HtmlDocument OpenNew(bool replaceInHistory) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlDocument.OpenNew(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function OpenNew (replaceInHistory As Boolean) As HtmlDocument" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Forms::HtmlDocument ^ OpenNew(bool replaceInHistory);" />
      <MemberSignature Language="F#" Value="member this.OpenNew : bool -&gt; System.Windows.Forms.HtmlDocument" Usage="htmlDocument.OpenNew replaceInHistory" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlDocument</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="replaceInHistory" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="replaceInHistory">新窗口的导航是否应替换 DOM 的导航历史记录中的上一个元素。</param>
        <summary>获取一个新的 <see cref="T:System.Windows.Forms.HtmlDocument" />，以便与 <see cref="M:System.Windows.Forms.HtmlDocument.Write(System.String)" /> 方法一起使用。</summary>
        <returns>要编写的新文档。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.HtmlDocument.OpenNew%2A> 将清除以前加载的文档，包括任何关联的状态，如变量。 它不会导致引发中的导航事件 <xref:System.Windows.Forms.WebBrowser> 。  
  
 <xref:System.Windows.Forms.HtmlDocument.OpenNew%2A> 始终在当前窗口中创建新文档。 若要在新窗口中打开文档，请使用 <xref:System.Windows.Forms.HtmlWindow.Open%2A> 类的方法 <xref:System.Windows.Forms.HtmlWindow> 。  
  
   
  
## Examples  
 下面的代码示例准备 DOM 以便使用方法编写和写入新文档 <xref:System.Windows.Forms.HtmlDocument.Write%2A> 。  
  
 [!code-csharp[System.Windows.Forms.HtmlDocument#11](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlDocument/CS/Form1.cs#11)]
 [!code-vb[System.Windows.Forms.HtmlDocument#11](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlDocument/VB/Form1.vb#11)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/aa752628.aspx">open 方法</related>
      </Docs>
    </Member>
    <Member MemberName="RightToLeft">
      <MemberSignature Language="C#" Value="public bool RightToLeft { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool RightToLeft" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlDocument.RightToLeft" />
      <MemberSignature Language="VB.NET" Value="Public Property RightToLeft As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool RightToLeft { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.RightToLeft : bool with get, set" Usage="System.Windows.Forms.HtmlDocument.RightToLeft" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置当前文档中文本的方向。</summary>
        <value>如果文本从右向左呈现，为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.HtmlDocument.RightToLeft%2A> 将不具有任何值，除非已显式设置为代码或 HTML 格式。  
  
 与 <xref:System.Windows.Forms.HtmlDocument.RightToLeft%2A> Windows 窗体控件上的属性不同， <xref:System.Windows.Forms.HtmlDocument.RightToLeft%2A> 托管 HTML DOM 上的属性不会影响拉丁文本的方向。  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/aa752540.aspx">dir 属性</related>
      </Docs>
    </Member>
    <Member MemberName="Stop">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.HtmlElementEventHandler Stop;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.HtmlElementEventHandler Stop" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.HtmlDocument.Stop" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Stop As HtmlElementEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::HtmlElementEventHandler ^ Stop;" />
      <MemberSignature Language="F#" Value="member this.Stop : System.Windows.Forms.HtmlElementEventHandler " Usage="member this.Stop : System.Windows.Forms.HtmlElementEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当向其他网页的导航被中断时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果程序代码调用控件的方法，则网页的加载将暂停 <xref:System.Windows.Forms.WebBrowser.Stop%2A> <xref:System.Windows.Forms.WebBrowser> 。 由于网络中断或网站故障而导致的导航失败不会导致 <xref:System.Windows.Forms.HtmlDocument.Stop> 发生。  
  
 有关处理事件的详细信息，请参阅 [处理和引发事件](/dotnet/standard/events/)。  
  
   
  
## Examples  
 下面的代码示例在事件发生时重置 Windows 窗体应用程序上的状态栏 `Stop` 。 此代码示例要求在 <xref:System.Windows.Forms.StatusBar> 应用程序中有一个名为的控件 `StatusBar1` 。  
  
 [!code-csharp[System.Windows.Forms.HtmlDocument#15](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlDocument/CS/Form1.cs#15)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/aa752561.aspx">onstop 事件</related>
      </Docs>
    </Member>
    <Member MemberName="Title">
      <MemberSignature Language="C#" Value="public string Title { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Title" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlDocument.Title" />
      <MemberSignature Language="VB.NET" Value="Public Property Title As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Title { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Title : string with get, set" Usage="System.Windows.Forms.HtmlDocument.Title" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置当前 HTML 文档中<c> &lt; 标题 &gt; </c>标记的文本值。</summary>
        <value>当前文档的标题。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用 <xref:System.Windows.Forms.HtmlDocument.Title%2A> 属性通过用户可读的名称来标识文档。  
  
 对此属性所做的更改也将在控件的属性中反映出来 <xref:System.Windows.Forms.WebBrowser.DocumentTitle%2A> <xref:System.Windows.Forms.WebBrowser> 。  
  
   
  
## Examples  
 下面的代码示例使用文档的 URL 作为链接的位置和文档的标题，创建指向当前文档的 HTML 超链接。 此代码示例要求你的应用程序具有一个 <xref:System.Windows.Forms.WebBrowser> 名为的控件 `WebBrowser1` 。  
  
 [!code-csharp[System.Windows.Forms.HtmlDocument#14](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlDocument/CS/Form1.cs#14)]
 [!code-vb[System.Windows.Forms.HtmlDocument#14](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlDocument/VB/Form1.vb#14)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.WebBrowser.DocumentTitle" />
        <altmember cref="T:System.Windows.Forms.WebBrowser" />
      </Docs>
    </Member>
    <Member MemberName="Url">
      <MemberSignature Language="C#" Value="public Uri Url { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Uri Url" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlDocument.Url" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Url As Uri" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Uri ^ Url { Uri ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Url : Uri" Usage="System.Windows.Forms.HtmlDocument.Url" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Uri</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取描述此文档位置的 URL。</summary>
        <value>表示此文档的 URL 的 <see cref="T:System.Uri" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此属性为只读。 若要导航到新文档，请使用 <xref:System.Windows.Forms.WebBrowser.Url%2A> 控件上的属性 <xref:System.Windows.Forms.WebBrowser> 。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VisitedLinkColor">
      <MemberSignature Language="C#" Value="public System.Drawing.Color VisitedLinkColor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Color VisitedLinkColor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlDocument.VisitedLinkColor" />
      <MemberSignature Language="VB.NET" Value="Public Property VisitedLinkColor As Color" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Color VisitedLinkColor { System::Drawing::Color get(); void set(System::Drawing::Color value); };" />
      <MemberSignature Language="F#" Value="member this.VisitedLinkColor : System.Drawing.Color with get, set" Usage="System.Windows.Forms.HtmlDocument.VisitedLinkColor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Color</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置用户已经访问的链接（指向 HTML 页）的颜色。</summary>
        <value>已访问的链接的颜色。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Color`中的类型 [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] 支持 `Alpha` 值，但 HTML DOM 不支持。 因此， `Alpha` 分配给此属性时将不起作用。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.HtmlDocument.BackColor" />
        <altmember cref="P:System.Windows.Forms.HtmlDocument.ForeColor" />
        <altmember cref="P:System.Windows.Forms.HtmlDocument.LinkColor" />
        <related type="Article" href="https://msdn.microsoft.com/library/aa752638.aspx">vlinkColor 属性</related>
      </Docs>
    </Member>
    <Member MemberName="Window">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.HtmlWindow Window { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.HtmlWindow Window" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlDocument.Window" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Window As HtmlWindow" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::HtmlWindow ^ Window { System::Windows::Forms::HtmlWindow ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Window : System.Windows.Forms.HtmlWindow" Usage="System.Windows.Forms.HtmlDocument.Window" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlWindow</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取与此文档关联的 <see cref="T:System.Windows.Forms.HtmlWindow" />。</summary>
        <value>此文档的窗口。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 所有 HTML 文档都有一个名为 "窗口" 的 HTML DOM 对象，该对象可用于操作文档的屏幕大小和打开新窗口，以及访问其他重要对象，例如 <xref:System.Windows.Forms.HtmlHistory> 。  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/aa752599.aspx">parentWindow 属性</related>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public void Write (string text);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Write(string text) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlDocument.Write(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Write (text As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Write(System::String ^ text);" />
      <MemberSignature Language="F#" Value="member this.Write : string -&gt; unit" Usage="htmlDocument.Write text" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="text" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="text">要写入文档的 HTML 文本。</param>
        <summary>编写一个新的 HTML 页。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 对的所有调用都 <xref:System.Windows.Forms.HtmlDocument.Write%2A> 应在之前调用 <xref:System.Windows.Forms.HtmlDocument.OpenNew%2A> ，这将清除当前文档及其所有变量。 你对的调用 <xref:System.Windows.Forms.HtmlDocument.Write%2A> 将在其位置创建一个新的 HTML 文档。 若要仅更改文档的特定部分，请获取相应的 <xref:System.Windows.Forms.HtmlElement> ，并设置其 <xref:System.Windows.Forms.HtmlElement.InnerHtml%2A> 属性。  
  
 建议使用 <xref:System.Windows.Forms.HtmlDocument.Write%2A> 方法（包括和标记）编写整个有效的 HTML 文档 `HTML` `BODY` 。 但是，如果只编写 HTML 元素，则文档对象模型 (DOM) 会为你提供这些元素。  
  
   
  
## Examples  
 下面的代码示例 <xref:System.Windows.Forms.HtmlDocument> 在新的 HTML 文件中打开新的和写入的。  
  
 [!code-csharp[System.Windows.Forms.HtmlDocument#11](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlDocument/CS/Form1.cs#11)]
 [!code-vb[System.Windows.Forms.HtmlDocument#11](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlDocument/VB/Form1.vb#11)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.HtmlDocument.OpenNew(System.Boolean)" />
      </Docs>
    </Member>
  </Members>
</Type>
