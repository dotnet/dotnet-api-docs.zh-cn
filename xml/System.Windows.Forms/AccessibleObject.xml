<Type Name="AccessibleObject" FullName="System.Windows.Forms.AccessibleObject">
  <Metadata><Meta Name="ms.openlocfilehash" Value="a5077f2e45a81c67b65d2556d5a621ad61c77bc6" /><Meta Name="ms.sourcegitcommit" Value="c982ad9e10a242d90f1e631b5981570f9e5d9f34" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-CN" /><Meta Name="ms.lasthandoff" Value="09/10/2020" /><Meta Name="ms.locfileid" Value="89904329" /></Metadata><TypeSignature Language="C#" Value="public class AccessibleObject : System.Runtime.InteropServices.StandardOleMarshalObject, Accessibility.IAccessible, System.Reflection.IReflect" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit AccessibleObject extends System.Runtime.InteropServices.StandardOleMarshalObject implements class Accessibility.IAccessible, class System.Reflection.IReflect" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Forms.AccessibleObject" />
  <TypeSignature Language="VB.NET" Value="Public Class AccessibleObject&#xA;Inherits StandardOleMarshalObject&#xA;Implements IAccessible, IReflect" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
  <TypeSignature Language="C++ CLI" Value="public ref class AccessibleObject : System::Runtime::InteropServices::StandardOleMarshalObject, Accessibility::IAccessible, System::Reflection::IReflect" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
  <TypeSignature Language="F#" Value="type AccessibleObject = class&#xA;    inherit StandardOleMarshalObject&#xA;    interface IReflect&#xA;    interface IAccessible&#xA;    interface Interop.UiaCore.IAccessibleEx&#xA;    interface Interop.Ole32.IServiceProvider&#xA;    interface Interop.UiaCore.IRawElementProviderSimple&#xA;    interface Interop.UiaCore.IRawElementProviderFragment&#xA;    interface Interop.UiaCore.IRawElementProviderFragmentRoot&#xA;    interface Interop.UiaCore.IInvokeProvider&#xA;    interface Interop.UiaCore.IValueProvider&#xA;    interface Interop.UiaCore.IRangeValueProvider&#xA;    interface Interop.UiaCore.IExpandCollapseProvider&#xA;    interface Interop.UiaCore.IToggleProvider&#xA;    interface Interop.UiaCore.ITableProvider&#xA;    interface Interop.UiaCore.ITableItemProvider&#xA;    interface Interop.UiaCore.IGridProvider&#xA;    interface Interop.UiaCore.IGridItemProvider&#xA;    interface Interop.OleAut32.IEnumVariant&#xA;    interface Interop.Ole32.IOleWindow&#xA;    interface Interop.UiaCore.ILegacyIAccessibleProvider&#xA;    interface Interop.UiaCore.ISelectionProvider&#xA;    interface Interop.UiaCore.ISelectionItemProvider&#xA;    interface Interop.UiaCore.IRawElementProviderHwndOverride&#xA;    interface Interop.UiaCore.IScrollItemProvider" FrameworkAlternate="net-5.0" />
  <TypeSignature Language="F#" Value="type AccessibleObject = class&#xA;    inherit StandardOleMarshalObject&#xA;    interface IReflect&#xA;    interface IAccessible&#xA;    interface UnsafeNativeMethods.IAccessibleEx&#xA;    interface UnsafeNativeMethods.IServiceProvider&#xA;    interface UnsafeNativeMethods.IRawElementProviderSimple&#xA;    interface UnsafeNativeMethods.IRawElementProviderFragment&#xA;    interface UnsafeNativeMethods.IRawElementProviderFragmentRoot&#xA;    interface UnsafeNativeMethods.IInvokeProvider&#xA;    interface UnsafeNativeMethods.IValueProvider&#xA;    interface UnsafeNativeMethods.IRangeValueProvider&#xA;    interface UnsafeNativeMethods.IExpandCollapseProvider&#xA;    interface UnsafeNativeMethods.IToggleProvider&#xA;    interface UnsafeNativeMethods.ITableProvider&#xA;    interface UnsafeNativeMethods.ITableItemProvider&#xA;    interface UnsafeNativeMethods.IGridProvider&#xA;    interface UnsafeNativeMethods.IGridItemProvider&#xA;    interface UnsafeNativeMethods.IEnumVariant&#xA;    interface UnsafeNativeMethods.IOleWindow&#xA;    interface UnsafeNativeMethods.ILegacyIAccessibleProvider&#xA;    interface UnsafeNativeMethods.ISelectionProvider&#xA;    interface UnsafeNativeMethods.ISelectionItemProvider&#xA;    interface UnsafeNativeMethods.IRawElementProviderHwndOverride&#xA;    interface UnsafeNativeMethods.IScrollItemProvider" FrameworkAlternate="netcore-3.0;netcore-3.1" />
  <TypeSignature Language="C#" Value="public class AccessibleObject : MarshalByRefObject, Accessibility.IAccessible, System.Reflection.IReflect" FrameworkAlternate="netframework-1.1" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit AccessibleObject extends System.MarshalByRefObject implements class Accessibility.IAccessible, class System.Reflection.IReflect" FrameworkAlternate="netframework-1.1" />
  <TypeSignature Language="VB.NET" Value="Public Class AccessibleObject&#xA;Inherits MarshalByRefObject&#xA;Implements IAccessible, IReflect" FrameworkAlternate="netframework-1.1" />
  <TypeSignature Language="C++ CLI" Value="public ref class AccessibleObject : MarshalByRefObject, Accessibility::IAccessible, System::Reflection::IReflect" FrameworkAlternate="netframework-1.1" />
  <TypeSignature Language="F#" Value="type AccessibleObject = class&#xA;    inherit MarshalByRefObject&#xA;    interface IReflect&#xA;    interface IAccessible&#xA;    interface UnsafeNativeMethods.IEnumVariant&#xA;    interface UnsafeNativeMethods.IMarshal" FrameworkAlternate="netframework-1.1" />
  <TypeSignature Language="F#" Value="type AccessibleObject = class&#xA;    inherit StandardOleMarshalObject&#xA;    interface IReflect&#xA;    interface IAccessible&#xA;    interface UnsafeNativeMethods.IEnumVariant&#xA;    interface UnsafeNativeMethods.IOleWindow" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5" />
  <TypeSignature Language="F#" Value="type AccessibleObject = class&#xA;    inherit StandardOleMarshalObject&#xA;    interface IReflect&#xA;    interface IAccessible" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
  <AssemblyInfo>
    <AssemblyName>System.Windows.Forms</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>5.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Runtime.InteropServices.StandardOleMarshalObject</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-1.1">System.MarshalByRefObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>Accessibility.IAccessible</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Reflection.IReflect</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName Language="C#">[System.Runtime.InteropServices.ComVisible(true)]</AttributeName>
      <AttributeName Language="F#">[&lt;System.Runtime.InteropServices.ComVisible(true)&gt;]</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>提供辅助功能应用程序用于为残障用户调整应用程序的用户界面 (UI) 的信息。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 辅助功能应用程序可以调整应用程序的功能，以提高残障用户的可用性。  
  
 对于视觉障碍的用户，你可以调整软件和操作系统功能以符合其需求。 例如，你可以放大文本和图像，并以对比度进行呈现。 此外，您还可以通过适当的颜色使用来适应色盲。 对于严重受到影响的用户，可以通过屏幕查看辅助工具访问计算机，将屏幕上的文本转换为语音或动态、可刷新的盲文显示。  
  
 对于有困难的用户，您可以设计使用视觉提示的程序，例如闪烁的工具栏;或者，您可以将口述消息显示为文本。 例如，当启用时，"控制面板" 中的 " `SoundSentry` 辅助功能" 选项会在系统发出警报声时提供视觉警告。  
  
 对于具有运动障碍的用户，您可以设计用于优化或消除键盘和鼠标使用的控件，从而提高计算机的可访问性。 控制面板提供协助。 例如，一种替代方法是使用数字键盘而不是鼠标来进行导航。 名为的另一种方法 `StickyKeys` 使不能同时按住两个或多个键的用户 (如 CTRL + P) ，通过每次键入一个键即可获得相同的结果。  
  
 对于具有认知和语言障碍的用户，您可以设计软件程序，以便更好地满足其需求。 例如，使用有序或 cued 的序列化时，将会出现简单的显示、更少的单词，并以基本学校标准为目标的阅读级别可使这些用户受益。  
  
 对于具有强制可能的用户，可以设计软件程序以消除捕获造成模式。  
  
 有关辅助功能的详细信息，包括有关辅助功能应用程序的信息，请参阅 MSDN library 或 Microsoft 网站上的 Microsoft 辅助功能的文档。  
  
> [!NOTE]
>  若要使用 <xref:System.Windows.Forms.AccessibleObject> ，你必须添加对 `Accessibility` 随安装的程序集的引用 [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] 。 Windows 窗体仅支持 Active Accessibility 2.0。  
  
   
  
## Examples  
 下面的代码示例演示如何创建可访问感知的图表控件， <xref:System.Windows.Forms.AccessibleObject> 并使用和 <xref:System.Windows.Forms.Control.ControlAccessibleObject> 类公开可访问的信息。 控件将两条曲线与图例一起绘制。 `ChartControlAccessibleObject`从派生的类 `ControlAccessibleObject` 在方法中用于为 <xref:System.Windows.Forms.Control.CreateAccessibilityInstance%2A> 图表控件提供自定义的可访问信息。 由于图表图例不是实际的 <xref:System.Windows.Forms.Control> 控件，而是由图表控件绘制，因此它没有任何内置的可访问信息。 因此， `ChartControlAccessibleObject` 类会重写 <xref:System.Windows.Forms.AccessibleObject.GetChild%2A> 方法以返回，该方法 `CurveLegendAccessibleObject` 表示图例的每个部分的可访问信息。 当可访问感知的应用程序使用此控件时，控件可以提供必需的可访问信息。  
  
 [!code-cpp[System.Windows.Forms.AccessibleObject#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.AccessibleObject/CPP/chartcontrol.cpp#1)]
 [!code-csharp[System.Windows.Forms.AccessibleObject#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.AccessibleObject/CS/chartcontrol.cs#1)]
 [!code-vb[System.Windows.Forms.AccessibleObject#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.AccessibleObject/VB/chartcontrol.vb#1)]  
  
 ]]></format>
    </remarks>
    <block subset="none" type="overrides"><para>从此类继承时，可以重写所有成员。</para></block>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public AccessibleObject ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.AccessibleObject.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; AccessibleObject();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>初始化 <see cref="T:System.Windows.Forms.AccessibleObject" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 通常，当你使用此方法创建可访问对象时，你将提供类的属性和方法的实现以提供特定于你的应用程序的功能。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Accessibility.IAccessible.accChildCount">
      <MemberSignature Language="C#" Value="int Accessibility.IAccessible.accChildCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Accessibility.IAccessible.accChildCount" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.AccessibleObject.Accessibility#IAccessible#accChildCount" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property accChildCount As Integer Implements IAccessible.accChildCount" />
      <MemberSignature Language="C++ CLI" Value="property int Accessibility::IAccessible::accChildCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Accessibility.IAccessible.accChildCount : int" Usage="Accessibility.IAccessible.accChildCount" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Accessibility.IAccessible.accChildCount</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取属于该对象的子接口的数量。 有关此成员的说明，请参见 <see cref="P:Accessibility.IAccessible.accChildCount" />。</summary>
        <value>属于该对象的子辅助性对象的数量。 如果该对象无子对象，则此值为 0。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此成员是显式接口成员的实现。 它只能在 <xref:System.Windows.Forms.AccessibleObject> 实例被强制转换为 <xref:Accessibility.IAccessible> 接口时使用。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Accessibility.IAccessible.accDoDefaultAction">
      <MemberSignature Language="C#" Value="void IAccessible.accDoDefaultAction (object childID);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void Accessibility.IAccessible.accDoDefaultAction(object childID) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.AccessibleObject.Accessibility#IAccessible#accDoDefaultAction(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Sub accDoDefaultAction (childID As Object) Implements IAccessible.accDoDefaultAction" />
      <MemberSignature Language="C++ CLI" Value=" virtual void Accessibility.IAccessible.accDoDefaultAction(System::Object ^ childID) = Accessibility::IAccessible::accDoDefaultAction;" />
      <MemberSignature Language="F#" Value="abstract member Accessibility.IAccessible.accDoDefaultAction : obj -&gt; unit&#xA;override this.Accessibility.IAccessible.accDoDefaultAction : obj -&gt; unit" Usage="accessibleObject.Accessibility.IAccessible.accDoDefaultAction childID" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Accessibility.IAccessible.accDoDefaultAction(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="childID" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="childID"><see cref="T:Accessibility.IAccessible" /> 接口/子级 ID 对中表示辅助性对象的子级 ID。</param>
        <summary>执行指定对象的默认操作。 并非所有对象都有默认操作。 有关此成员的说明，请参见 <see cref="M:Accessibility.IAccessible.accDoDefaultAction(System.Object)" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此成员是显式接口成员的实现。 它只能在 <xref:System.Windows.Forms.AccessibleObject> 实例被强制转换为 <xref:Accessibility.IAccessible> 接口时使用。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Accessibility.IAccessible.accFocus">
      <MemberSignature Language="C#" Value="object Accessibility.IAccessible.accFocus { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Accessibility.IAccessible.accFocus" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.AccessibleObject.Accessibility#IAccessible#accFocus" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property accFocus As Object Implements IAccessible.accFocus" />
      <MemberSignature Language="C++ CLI" Value="property System::Object ^ Accessibility::IAccessible::accFocus { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Accessibility.IAccessible.accFocus : obj" Usage="Accessibility.IAccessible.accFocus" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Accessibility.IAccessible.accFocus</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取具有键盘焦点的对象。 有关此成员的说明，请参见 <see cref="P:Accessibility.IAccessible.accFocus" />。</summary>
        <value>具有键盘焦点的对象。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 属性的返回值类型 <xref:System.Windows.Forms.AccessibleObject.Accessibility%23IAccessible%23accFocus%2A> 取决于具有键盘焦点的对象。 下表介绍属性返回的对象类型 <xref:System.Windows.Forms.AccessibleObject.Accessibility%23IAccessible%23accFocus%2A> 。  
  
|类型|说明|  
|----------|-----------------|  
|`null`|此对象本身不具有键盘焦点，并且不包含具有键盘焦点的子对象。|  
|整型|如果当前对象具有键盘焦点，则为 0;否则，具有键盘焦点的子辅助性对象的子 ID。|  
|<xref:Accessibility.IAccessible>|具有键盘焦点的子级辅助性对象。|  
  
 此成员是显式接口成员的实现。 它只能在 <xref:System.Windows.Forms.AccessibleObject> 实例被强制转换为 <xref:Accessibility.IAccessible> 接口时使用。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Accessibility.IAccessible.accHitTest">
      <MemberSignature Language="C#" Value="object IAccessible.accHitTest (int xLeft, int yTop);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance object Accessibility.IAccessible.accHitTest(int32 xLeft, int32 yTop) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.AccessibleObject.Accessibility#IAccessible#accHitTest(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Function accHitTest (xLeft As Integer, yTop As Integer) As Object Implements IAccessible.accHitTest" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Object ^ Accessibility.IAccessible.accHitTest(int xLeft, int yTop) = Accessibility::IAccessible::accHitTest;" />
      <MemberSignature Language="F#" Value="abstract member Accessibility.IAccessible.accHitTest : int * int -&gt; obj&#xA;override this.Accessibility.IAccessible.accHitTest : int * int -&gt; obj" Usage="accessibleObject.Accessibility.IAccessible.accHitTest (xLeft, yTop)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Accessibility.IAccessible.accHitTest(System.Int32,System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="xLeft" Type="System.Int32" />
        <Parameter Name="yTop" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="xLeft">水平坐标。</param>
        <param name="yTop">垂直坐标。</param>
        <summary>在指定的屏幕坐标位置获取子对象。 有关此成员的说明，请参见 <see cref="M:Accessibility.IAccessible.accHitTest(System.Int32,System.Int32)" />。</summary>
        <returns>位于由 <paramref name="xLeft" /> 和 <paramref name="yTop" /> 指定的点位置的辅助性对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表介绍方法可以返回的对象类型 <xref:System.Windows.Forms.AccessibleObject.Accessibility%23IAccessible%23accHitTest%2A> 。  
  
|类型|说明|  
|----------|-----------------|  
|<xref:Accessibility.IAccessible>|指定方向上的辅助性对象。|  
|整型|如果指定的点为当前对象或超出对象的边界，则为 0; 否则为0。否则为按指定方向标识辅助性对象的子 ID。|  
  
 此成员是显式接口成员的实现。 它只能在 <xref:System.Windows.Forms.AccessibleObject> 实例被强制转换为 <xref:Accessibility.IAccessible> 接口时使用。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Accessibility.IAccessible.accLocation">
      <MemberSignature Language="C#" Value="void IAccessible.accLocation (out int pxLeft, out int pyTop, out int pcxWidth, out int pcyHeight, object childID);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void Accessibility.IAccessible.accLocation([out] int32&amp; pxLeft, [out] int32&amp; pyTop, [out] int32&amp; pcxWidth, [out] int32&amp; pcyHeight, object childID) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.AccessibleObject.Accessibility#IAccessible#accLocation(System.Int32@,System.Int32@,System.Int32@,System.Int32@,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Sub accLocation (ByRef pxLeft As Integer, ByRef pyTop As Integer, ByRef pcxWidth As Integer, ByRef pcyHeight As Integer, childID As Object) Implements IAccessible.accLocation" />
      <MemberSignature Language="C++ CLI" Value=" virtual void Accessibility.IAccessible.accLocation([Runtime::InteropServices::Out] int % pxLeft, [Runtime::InteropServices::Out] int % pyTop, [Runtime::InteropServices::Out] int % pcxWidth, [Runtime::InteropServices::Out] int % pcyHeight, System::Object ^ childID) = Accessibility::IAccessible::accLocation;" />
      <MemberSignature Language="F#" Value="abstract member Accessibility.IAccessible.accLocation : int * int * int * int * obj -&gt; unit&#xA;override this.Accessibility.IAccessible.accLocation : int * int * int * int * obj -&gt; unit" Usage="accessibleObject.Accessibility.IAccessible.accLocation (pxLeft, pyTop, pcxWidth, pcyHeight, childID)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Accessibility.IAccessible.accLocation(System.Int32@,System.Int32@,System.Int32@,System.Int32@,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pxLeft" Type="System.Int32" RefType="out" />
        <Parameter Name="pyTop" Type="System.Int32" RefType="out" />
        <Parameter Name="pcxWidth" Type="System.Int32" RefType="out" />
        <Parameter Name="pcyHeight" Type="System.Int32" RefType="out" />
        <Parameter Name="childID" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="pxLeft">该方法返回时，包含对象左边缘的 x 坐标。 此参数未经初始化即被传递。</param>
        <param name="pyTop">该方法返回时，包含对象上边缘的 y 坐标。 此参数未经初始化即被传递。</param>
        <param name="pcxWidth">该方法返回时，包含对象的宽度。 此参数未经初始化即被传递。</param>
        <param name="pcyHeight">该方法返回时，包含对象的高度。 此参数未经初始化即被传递。</param>
        <param name="childID">辅助性对象的 ID 号。 该参数为 0，则获取对象的位置；或者，如果该参数为子级 ID，则获取对象的一个子对象的位置。</param>
        <summary>获取对象的当前屏幕位置。 有关此成员的说明，请参见 <see cref="M:Accessibility.IAccessible.accLocation(System.Int32@,System.Int32@,System.Int32@,System.Int32@,System.Object)" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此成员是显式接口成员的实现。 它只能在 <xref:System.Windows.Forms.AccessibleObject> 实例被强制转换为 <xref:Accessibility.IAccessible> 接口时使用。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Accessibility.IAccessible.accNavigate">
      <MemberSignature Language="C#" Value="object IAccessible.accNavigate (int navDir, object childID);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance object Accessibility.IAccessible.accNavigate(int32 navDir, object childID) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.AccessibleObject.Accessibility#IAccessible#accNavigate(System.Int32,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function accNavigate (navDir As Integer, childID As Object) As Object Implements IAccessible.accNavigate" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Object ^ Accessibility.IAccessible.accNavigate(int navDir, System::Object ^ childID) = Accessibility::IAccessible::accNavigate;" />
      <MemberSignature Language="F#" Value="abstract member Accessibility.IAccessible.accNavigate : int * obj -&gt; obj&#xA;override this.Accessibility.IAccessible.accNavigate : int * obj -&gt; obj" Usage="accessibleObject.Accessibility.IAccessible.accNavigate (navDir, childID)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Accessibility.IAccessible.accNavigate(System.Int32,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="navDir" Type="System.Int32" />
        <Parameter Name="childID" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="navDir"><see cref="T:System.Windows.Forms.AccessibleNavigation" /> 枚举之一，它指定要定位的方向。</param>
        <param name="childID">辅助性对象的 ID 号。 该参数为 0，则以该对象为起始位置；或者，如果该参数为子级 ID，则以该对象的一个子对象为起始位置。</param>
        <summary>相对于当前对象定位到一个辅助性对象。 有关此成员的说明，请参见 <see cref="M:Accessibility.IAccessible.accNavigate(System.Int32,System.Object)" />。</summary>
        <returns>位于由 <paramref name="navDir" /> 值指定的位置的辅助性对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表介绍方法可以返回的对象类型 <xref:System.Windows.Forms.AccessibleObject.Accessibility%23IAccessible%23accNavigate%2A> 。  
  
|类型|说明|  
|----------|-----------------|  
|`null`|指定的方向没有可访问的对象。|  
|<xref:Accessibility.IAccessible>|指定方向上的辅助性对象。|  
|整型|在指定方向标识辅助性对象的子级 ID。 使用父级 <xref:Accessibility.IAccessible> 和子级 ID 访问辅助性对象。|  
  
 此成员是显式接口成员的实现。 它只能在 <xref:System.Windows.Forms.AccessibleObject> 实例被强制转换为 <xref:Accessibility.IAccessible> 接口时使用。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Accessibility.IAccessible.accParent">
      <MemberSignature Language="C#" Value="object Accessibility.IAccessible.accParent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Accessibility.IAccessible.accParent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.AccessibleObject.Accessibility#IAccessible#accParent" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property accParent As Object Implements IAccessible.accParent" />
      <MemberSignature Language="C++ CLI" Value="property System::Object ^ Accessibility::IAccessible::accParent { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Accessibility.IAccessible.accParent : obj" Usage="Accessibility.IAccessible.accParent" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Accessibility.IAccessible.accParent</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取该对象的父辅助性对象。 有关此成员的说明，请参见 <see cref="P:Accessibility.IAccessible.accParent" />。</summary>
        <value>表示辅助性对象的父对象的 <see cref="T:Accessibility.IAccessible" />；或者，如果没有父对象，则为 <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此成员是显式接口成员的实现。 它只能在 <xref:System.Windows.Forms.AccessibleObject> 实例被强制转换为 <xref:Accessibility.IAccessible> 接口时使用。 
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Accessibility.IAccessible.accSelect">
      <MemberSignature Language="C#" Value="void IAccessible.accSelect (int flagsSelect, object childID);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void Accessibility.IAccessible.accSelect(int32 flagsSelect, object childID) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.AccessibleObject.Accessibility#IAccessible#accSelect(System.Int32,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Sub accSelect (flagsSelect As Integer, childID As Object) Implements IAccessible.accSelect" />
      <MemberSignature Language="C++ CLI" Value=" virtual void Accessibility.IAccessible.accSelect(int flagsSelect, System::Object ^ childID) = Accessibility::IAccessible::accSelect;" />
      <MemberSignature Language="F#" Value="abstract member Accessibility.IAccessible.accSelect : int * obj -&gt; unit&#xA;override this.Accessibility.IAccessible.accSelect : int * obj -&gt; unit" Usage="accessibleObject.Accessibility.IAccessible.accSelect (flagsSelect, childID)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Accessibility.IAccessible.accSelect(System.Int32,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="flagsSelect" Type="System.Int32" />
        <Parameter Name="childID" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="flagsSelect"><see cref="T:System.Windows.Forms.AccessibleSelection" /> 值的按位组合。</param>
        <param name="childID">要对其更改选择操作的辅助性对象的 ID 号。 该参数为 0，则选择该对象；或者，如果该参数为子级 ID，则选择该对象的一个子对象。</param>
        <summary>修改选择内容或移动辅助性对象的键盘焦点。 有关此成员的说明，请参见 <see cref="M:Accessibility.IAccessible.accSelect(System.Int32,System.Object)" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下面介绍 <xref:System.Windows.Forms.AccessibleSelection> 在调用 `Select` 以执行复杂选择操作时要指定哪些值。  
  
|Operation|标志组合|  
|---------------|----------------------|  
|模拟单击|<xref:System.Windows.Forms.AccessibleSelection.TakeFocus> 或 <xref:System.Windows.Forms.AccessibleSelection.TakeSelection>|  
|通过模拟 CTRL + 单击来选择目标项|<xref:System.Windows.Forms.AccessibleSelection.TakeFocus> 或 <xref:System.Windows.Forms.AccessibleSelection.AddSelection>|  
|通过模拟 CTRL + 单击取消选择目标项|<xref:System.Windows.Forms.AccessibleSelection.TakeFocus> 或 <xref:System.Windows.Forms.AccessibleSelection.RemoveSelection>|  
|模拟 SHIFT + 单击|<xref:System.Windows.Forms.AccessibleSelection.TakeFocus> 或 <xref:System.Windows.Forms.AccessibleSelection.ExtendSelection>|  
|选择对象范围并将焦点放在最后一个对象上|<xref:System.Windows.Forms.AccessibleSelection.TakeFocus>在起始对象上指定以设置选择定位点。 然后再次调用 Select，并 <xref:System.Windows.Forms.AccessibleSelection.TakeFocus> <xref:System.Windows.Forms.AccessibleSelection.ExtendSelection> 在最后一个对象上指定或。|  
|取消选择所有对象|<xref:System.Windows.Forms.AccessibleSelection.TakeSelection>对任何对象指定。 此标志取消选择除了刚选择的对象之外的所有选择的对象。 然后再次调用 Select，并 <xref:System.Windows.Forms.AccessibleSelection.RemoveSelection> 对同一对象指定。|  
  
 此成员是显式接口成员的实现。 它只能在 <xref:System.Windows.Forms.AccessibleObject> 实例被强制转换为 <xref:Accessibility.IAccessible> 接口时使用。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Accessibility.IAccessible.accSelection">
      <MemberSignature Language="C#" Value="object Accessibility.IAccessible.accSelection { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Accessibility.IAccessible.accSelection" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.AccessibleObject.Accessibility#IAccessible#accSelection" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property accSelection As Object Implements IAccessible.accSelection" />
      <MemberSignature Language="C++ CLI" Value="property System::Object ^ Accessibility::IAccessible::accSelection { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Accessibility.IAccessible.accSelection : obj" Usage="Accessibility.IAccessible.accSelection" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Accessibility.IAccessible.accSelection</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取辅助性对象的选定子对象。 有关此成员的说明，请参见 <see cref="P:Accessibility.IAccessible.accSelection" />。</summary>
        <value>辅助性对象的选定子对象。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表描述了属性返回的对象类型 <xref:System.Windows.Forms.AccessibleObject.Accessibility%23IAccessible%23accSelection%2A>  
  
|类型|说明|  
|----------|-----------------|  
|`null`|未选择任何子对象。|  
|<xref:Accessibility.IAccessible>|选定的子级辅助性对象。|  
|整型|标识所选辅助性对象的子 ID。 使用父级 <xref:Accessibility.IAccessible> 和子级 ID 访问辅助性对象。|  
|`IEnumVARIANT`|选择的子对象的列表。|  
  
 此成员是显式接口成员的实现。 它只能在 <xref:System.Windows.Forms.AccessibleObject> 实例被强制转换为 <xref:Accessibility.IAccessible> 接口时使用。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Accessibility.IAccessible.get_accChild">
      <MemberSignature Language="C#" Value="object IAccessible.get_accChild (object childID);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance object Accessibility.IAccessible.get_accChild(object childID) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.AccessibleObject.Accessibility#IAccessible#get_accChild(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function get_accChild (childID As Object) As Object Implements IAccessible.get_accChild" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Object ^ Accessibility.IAccessible.get_accChild(System::Object ^ childID) = Accessibility::IAccessible::get_accChild;" />
      <MemberSignature Language="F#" Value="abstract member Accessibility.IAccessible.get_accChild : obj -&gt; obj&#xA;override this.Accessibility.IAccessible.get_accChild : obj -&gt; obj" Usage="accessibleObject.Accessibility.IAccessible.get_accChild childID" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Accessibility.IAccessible.get_accChild(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="childID" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="childID">要检索的子对象的 ID 号。</param>
        <summary>检索指定的子对象。</summary>
        <returns>如果存在，则为指定的子对象，如果不存在，则为 <see langword="null" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Accessibility.IAccessible.get_accDefaultAction">
      <MemberSignature Language="C#" Value="string IAccessible.get_accDefaultAction (object childID);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance string Accessibility.IAccessible.get_accDefaultAction(object childID) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.AccessibleObject.Accessibility#IAccessible#get_accDefaultAction(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function get_accDefaultAction (childID As Object) As String Implements IAccessible.get_accDefaultAction" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::String ^ Accessibility.IAccessible.get_accDefaultAction(System::Object ^ childID) = Accessibility::IAccessible::get_accDefaultAction;" />
      <MemberSignature Language="F#" Value="abstract member Accessibility.IAccessible.get_accDefaultAction : obj -&gt; string&#xA;override this.Accessibility.IAccessible.get_accDefaultAction : obj -&gt; string" Usage="accessibleObject.Accessibility.IAccessible.get_accDefaultAction childID" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Accessibility.IAccessible.get_accDefaultAction(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="childID" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="childID">要为其获取默认操作的辅助性对象的 ID 号。 该参数为 0，则选择该对象；或者，如果该参数为子级 ID，则选择该对象的一个子对象。</param>
        <summary>返回指示指定对象的默认操作的字符串。</summary>
        <returns>字符串指示 <paramref name="childID" /> 的默认操作，或者，如果 <paramref name="childID" /> 没有默认操作，则指示 <see langword="name" /> 的默认操作。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Accessibility.IAccessible.get_accDescription">
      <MemberSignature Language="C#" Value="string IAccessible.get_accDescription (object childID);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance string Accessibility.IAccessible.get_accDescription(object childID) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.AccessibleObject.Accessibility#IAccessible#get_accDescription(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function get_accDescription (childID As Object) As String Implements IAccessible.get_accDescription" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::String ^ Accessibility.IAccessible.get_accDescription(System::Object ^ childID) = Accessibility::IAccessible::get_accDescription;" />
      <MemberSignature Language="F#" Value="abstract member Accessibility.IAccessible.get_accDescription : obj -&gt; string&#xA;override this.Accessibility.IAccessible.get_accDescription : obj -&gt; string" Usage="accessibleObject.Accessibility.IAccessible.get_accDescription childID" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Accessibility.IAccessible.get_accDescription(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="childID" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="childID">要为其获取描述的辅助性对象的 ID 号。 该参数为 0，则选择该对象；或者，如果该参数为子级 ID，则选择该对象的一个子对象。</param>
        <summary>返回描述指定辅助性对象的可视外观的字符串。</summary>
        <returns>描述指定辅助性对象的本地化字符串。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Accessibility.IAccessible.get_accHelp">
      <MemberSignature Language="C#" Value="string IAccessible.get_accHelp (object childID);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance string Accessibility.IAccessible.get_accHelp(object childID) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.AccessibleObject.Accessibility#IAccessible#get_accHelp(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function get_accHelp (childID As Object) As String Implements IAccessible.get_accHelp" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::String ^ Accessibility.IAccessible.get_accHelp(System::Object ^ childID) = Accessibility::IAccessible::get_accHelp;" />
      <MemberSignature Language="F#" Value="abstract member Accessibility.IAccessible.get_accHelp : obj -&gt; string&#xA;override this.Accessibility.IAccessible.get_accHelp : obj -&gt; string" Usage="accessibleObject.Accessibility.IAccessible.get_accHelp childID" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Accessibility.IAccessible.get_accHelp(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="childID" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="childID">要为其获取帮助信息的辅助性对象的 ID 号。 该参数为 0，则选择该对象；或者，如果该参数为子级 ID，则选择该对象的一个子对象。</param>
        <summary>检索与指定辅助性对象相关联的 WinHelp 文件的完整路径。</summary>
        <returns>与 <paramref name="childID" /> 相关联的 WinHelp 文件的完整路径。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Accessibility.IAccessible.get_accHelpTopic">
      <MemberSignature Language="C#" Value="int IAccessible.get_accHelpTopic (out string pszHelpFile, object childID);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 Accessibility.IAccessible.get_accHelpTopic([out] string&amp; pszHelpFile, object childID) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.AccessibleObject.Accessibility#IAccessible#get_accHelpTopic(System.String@,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function get_accHelpTopic (ByRef pszHelpFile As String, childID As Object) As Integer Implements IAccessible.get_accHelpTopic" />
      <MemberSignature Language="C++ CLI" Value=" virtual int Accessibility.IAccessible.get_accHelpTopic([Runtime::InteropServices::Out] System::String ^ % pszHelpFile, System::Object ^ childID) = Accessibility::IAccessible::get_accHelpTopic;" />
      <MemberSignature Language="F#" Value="abstract member Accessibility.IAccessible.get_accHelpTopic : string * obj -&gt; int&#xA;override this.Accessibility.IAccessible.get_accHelpTopic : string * obj -&gt; int" Usage="accessibleObject.Accessibility.IAccessible.get_accHelpTopic (pszHelpFile, childID)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Accessibility.IAccessible.get_accHelpTopic(System.String@,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pszHelpFile" Type="System.String" RefType="out" />
        <Parameter Name="childID" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="pszHelpFile">方法返回时，WinHelp 文件的完整路径与指定对象相关联。</param>
        <param name="childID">要为其检索帮助主题的辅助性对象的 ID 号。 该参数为 0，则选择该对象；或者，如果该参数为子级 ID，则选择该对象的一个子对象。</param>
        <summary>检索与指定对象相关联的 WinHelp 文件的完整路径以及该文件中指定主题的标识符。</summary>
        <returns><paramref name="pszHelpFile" /> 中指定主题的标识符。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Accessibility.IAccessible.get_accKeyboardShortcut">
      <MemberSignature Language="C#" Value="string IAccessible.get_accKeyboardShortcut (object childID);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance string Accessibility.IAccessible.get_accKeyboardShortcut(object childID) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.AccessibleObject.Accessibility#IAccessible#get_accKeyboardShortcut(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function get_accKeyboardShortcut (childID As Object) As String Implements IAccessible.get_accKeyboardShortcut" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::String ^ Accessibility.IAccessible.get_accKeyboardShortcut(System::Object ^ childID) = Accessibility::IAccessible::get_accKeyboardShortcut;" />
      <MemberSignature Language="F#" Value="abstract member Accessibility.IAccessible.get_accKeyboardShortcut : obj -&gt; string&#xA;override this.Accessibility.IAccessible.get_accKeyboardShortcut : obj -&gt; string" Usage="accessibleObject.Accessibility.IAccessible.get_accKeyboardShortcut childID" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Accessibility.IAccessible.get_accKeyboardShortcut(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="childID" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="childID">要为其获取键盘快捷方式的辅助性对象的 ID 号。 该参数为 0，则选择该对象；或者，如果该参数为子级 ID，则选择该对象的一个子对象。</param>
        <summary>检索指定对象的键盘快捷方式或访问密钥。</summary>
        <returns>本地化字符串标识键盘快捷方式或 <see langword="null" />（如果键盘快捷方式与指定对象相关联）。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Accessibility.IAccessible.get_accName">
      <MemberSignature Language="C#" Value="string IAccessible.get_accName (object childID);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance string Accessibility.IAccessible.get_accName(object childID) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.AccessibleObject.Accessibility#IAccessible#get_accName(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function get_accName (childID As Object) As String Implements IAccessible.get_accName" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::String ^ Accessibility.IAccessible.get_accName(System::Object ^ childID) = Accessibility::IAccessible::get_accName;" />
      <MemberSignature Language="F#" Value="abstract member Accessibility.IAccessible.get_accName : obj -&gt; string&#xA;override this.Accessibility.IAccessible.get_accName : obj -&gt; string" Usage="accessibleObject.Accessibility.IAccessible.get_accName childID" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Accessibility.IAccessible.get_accName(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="childID" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="childID">要检索其名称的辅助性对象的 ID 号。 该参数为 0，则选择该对象；或者，如果该参数为子级 ID，则选择该对象的一个子对象。</param>
        <summary>检索指定对象的名称。</summary>
        <returns>指定对象的名称。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Accessibility.IAccessible.get_accRole">
      <MemberSignature Language="C#" Value="object IAccessible.get_accRole (object childID);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance object Accessibility.IAccessible.get_accRole(object childID) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.AccessibleObject.Accessibility#IAccessible#get_accRole(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function get_accRole (childID As Object) As Object Implements IAccessible.get_accRole" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Object ^ Accessibility.IAccessible.get_accRole(System::Object ^ childID) = Accessibility::IAccessible::get_accRole;" />
      <MemberSignature Language="F#" Value="abstract member Accessibility.IAccessible.get_accRole : obj -&gt; obj&#xA;override this.Accessibility.IAccessible.get_accRole : obj -&gt; obj" Usage="accessibleObject.Accessibility.IAccessible.get_accRole childID" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Accessibility.IAccessible.get_accRole(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="childID" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="childID">要为其获取角色信息的辅助性对象的 ID 号。 该参数为 0，则选择该对象；或者，如果该参数为子级 ID，则选择该对象的一个子对象。</param>
        <summary>检索描述指定对象的角色的信息。</summary>
        <returns>提供有关指定辅助性对象的角色信息的对象。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Accessibility.IAccessible.get_accState">
      <MemberSignature Language="C#" Value="object IAccessible.get_accState (object childID);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance object Accessibility.IAccessible.get_accState(object childID) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.AccessibleObject.Accessibility#IAccessible#get_accState(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function get_accState (childID As Object) As Object Implements IAccessible.get_accState" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Object ^ Accessibility.IAccessible.get_accState(System::Object ^ childID) = Accessibility::IAccessible::get_accState;" />
      <MemberSignature Language="F#" Value="abstract member Accessibility.IAccessible.get_accState : obj -&gt; obj&#xA;override this.Accessibility.IAccessible.get_accState : obj -&gt; obj" Usage="accessibleObject.Accessibility.IAccessible.get_accState childID" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Accessibility.IAccessible.get_accState(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="childID" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="childID">要为其获取状态信息的辅助性对象的 ID 号。 该参数为 0，则选择该对象；或者，如果该参数为子级 ID，则选择该对象的一个子对象。</param>
        <summary>检索指定辅助性对象的当前状态。</summary>
        <returns>描述指定辅助性对象的当前状态的对象。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Accessibility.IAccessible.get_accValue">
      <MemberSignature Language="C#" Value="string IAccessible.get_accValue (object childID);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance string Accessibility.IAccessible.get_accValue(object childID) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.AccessibleObject.Accessibility#IAccessible#get_accValue(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function get_accValue (childID As Object) As String Implements IAccessible.get_accValue" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::String ^ Accessibility.IAccessible.get_accValue(System::Object ^ childID) = Accessibility::IAccessible::get_accValue;" />
      <MemberSignature Language="F#" Value="abstract member Accessibility.IAccessible.get_accValue : obj -&gt; string&#xA;override this.Accessibility.IAccessible.get_accValue : obj -&gt; string" Usage="accessibleObject.Accessibility.IAccessible.get_accValue childID" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Accessibility.IAccessible.get_accValue(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="childID" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="childID">要检索其值的辅助性对象的 ID 号。 该参数为 0，则选择该对象；或者，如果该参数为子级 ID，则选择该对象的一个子对象。</param>
        <summary>检索指定辅助性对象的值。 并非所有对象都有值。</summary>
        <returns>如果对象没有值，则为 <see langword="null" /> 值，否则，为 <paramref name="childID" /> 值。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Accessibility.IAccessible.set_accName">
      <MemberSignature Language="C#" Value="void IAccessible.set_accName (object childID, string newName);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void Accessibility.IAccessible.set_accName(object childID, string newName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.AccessibleObject.Accessibility#IAccessible#set_accName(System.Object,System.String)" />
      <MemberSignature Language="VB.NET" Value="Sub set_accName (childID As Object, newName As String) Implements IAccessible.set_accName" />
      <MemberSignature Language="C++ CLI" Value=" virtual void Accessibility.IAccessible.set_accName(System::Object ^ childID, System::String ^ newName) = Accessibility::IAccessible::set_accName;" />
      <MemberSignature Language="F#" Value="abstract member Accessibility.IAccessible.set_accName : obj * string -&gt; unit&#xA;override this.Accessibility.IAccessible.set_accName : obj * string -&gt; unit" Usage="accessibleObject.Accessibility.IAccessible.set_accName (childID, newName)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Accessibility.IAccessible.set_accName(System.Object,System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="childID" Type="System.Object" />
        <Parameter Name="newName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="childID">要向其分配新名称的辅助性对象的 ID 号。 该参数为 0，则选择该对象；或者，如果该参数为子级 ID，则选择该对象的一个子对象。</param>
        <param name="newName">分配给 <paramref name="childID" /> 的新名称。</param>
        <summary>将新的可访问名称分配给指定的元素。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Accessibility.IAccessible.set_accValue">
      <MemberSignature Language="C#" Value="void IAccessible.set_accValue (object childID, string newValue);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void Accessibility.IAccessible.set_accValue(object childID, string newValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.AccessibleObject.Accessibility#IAccessible#set_accValue(System.Object,System.String)" />
      <MemberSignature Language="VB.NET" Value="Sub set_accValue (childID As Object, newValue As String) Implements IAccessible.set_accValue" />
      <MemberSignature Language="C++ CLI" Value=" virtual void Accessibility.IAccessible.set_accValue(System::Object ^ childID, System::String ^ newValue) = Accessibility::IAccessible::set_accValue;" />
      <MemberSignature Language="F#" Value="abstract member Accessibility.IAccessible.set_accValue : obj * string -&gt; unit&#xA;override this.Accessibility.IAccessible.set_accValue : obj * string -&gt; unit" Usage="accessibleObject.Accessibility.IAccessible.set_accValue (childID, newValue)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Accessibility.IAccessible.set_accValue(System.Object,System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="childID" Type="System.Object" />
        <Parameter Name="newValue" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="childID">要向其分配新值的辅助性对象的 ID 号。 该参数为 0，则选择该对象；或者，如果该参数为子级 ID，则选择该对象的一个子对象。</param>
        <param name="newValue">分配给指定辅助性对象的新值。</param>
        <summary>将新的值分配给指定的元素。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Bounds">
      <MemberSignature Language="C#" Value="public virtual System.Drawing.Rectangle Bounds { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Rectangle Bounds" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.AccessibleObject.Bounds" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Bounds As Rectangle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Drawing::Rectangle Bounds { System::Drawing::Rectangle get(); };" />
      <MemberSignature Language="F#" Value="member this.Bounds : System.Drawing.Rectangle" Usage="System.Windows.Forms.AccessibleObject.Bounds" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Rectangle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取辅助性对象的位置和大小。</summary>
        <value>表示辅助性对象的边界的 <see cref="T:System.Drawing.Rectangle" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.AccessibleObject.Bounds%2A>属性在屏幕坐标中检索对象的边框。 如果对象具有非矩形形状，则此属性表示完全包围整个对象区域的最小矩形。 因此，对于列表视图项之类的非矩形对象，对象的边框的坐标可能会失败（如果已通过调用方法进行测试）， <xref:System.Windows.Forms.AccessibleObject.HitTest%2A> 因为 <xref:System.Windows.Forms.AccessibleObject.HitTest%2A> 在每个像素的基础上确定对象的边界。  
  
   
  
## Examples  
 下面的示例演示如何创建一个可访问感知的图表控件，并使用 <xref:System.Windows.Forms.AccessibleObject> 和 <xref:System.Windows.Forms.Control.ControlAccessibleObject> 类公开辅助性信息。 控件将两条曲线与图例一起绘制。 `ChartControlAccessibleObject`从派生的类 `ControlAccessibleObject` 在方法中用于为 <xref:System.Windows.Forms.Control.CreateAccessibilityInstance%2A> 图表控件提供自定义的可访问信息。 由于图表图例不是实际的 <xref:System.Windows.Forms.Control> 控件，而是由图表控件绘制，因此它没有任何内置的可访问信息。 因此， `ChartControlAccessibleObject` 类会重写 <xref:System.Windows.Forms.AccessibleObject.GetChild%2A> 方法以返回，该方法 `CurveLegendAccessibleObject` 表示图例的每个部分的可访问信息。 当可访问感知的应用程序使用此控件时，控件可以提供必需的可访问信息。  
  
 此代码摘录演示了如何重写 <xref:System.Windows.Forms.AccessibleObject.Bounds%2A> 属性。 <xref:System.Windows.Forms.AccessibleObject>有关完整的代码示例，请参阅类概述。  
  
 [!code-cpp[System.Windows.Forms.AccessibleObject#6](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.AccessibleObject/CPP/chartcontrol.cpp#6)]
 [!code-csharp[System.Windows.Forms.AccessibleObject#6](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.AccessibleObject/CS/chartcontrol.cs#6)]
 [!code-vb[System.Windows.Forms.AccessibleObject#6](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.AccessibleObject/VB/chartcontrol.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Runtime.InteropServices.COMException">无法检索控件的界限。</exception>
        <block subset="none" type="overrides"><para>如果对象包装系统控件，则默认实现将返回可访问对象的边框;否则，它将返回 <see cref="F:System.Drawing.Rectangle.Empty" /> 。 所有可见的可访问对象都必须支持此方法。 声音对象不支持此方法。</para></block>
        <altmember cref="P:System.Windows.Forms.AccessibleObject.DefaultAction" />
        <altmember cref="P:System.Windows.Forms.AccessibleObject.Description" />
        <altmember cref="P:System.Windows.Forms.AccessibleObject.Help" />
        <altmember cref="P:System.Windows.Forms.AccessibleObject.KeyboardShortcut" />
        <altmember cref="P:System.Windows.Forms.AccessibleObject.Name" />
        <altmember cref="P:System.Windows.Forms.AccessibleObject.Parent" />
        <altmember cref="P:System.Windows.Forms.AccessibleObject.Role" />
        <altmember cref="P:System.Windows.Forms.AccessibleObject.State" />
        <altmember cref="P:System.Windows.Forms.AccessibleObject.Value" />
      </Docs>
    </Member>
    <Member MemberName="DefaultAction">
      <MemberSignature Language="C#" Value="public virtual string DefaultAction { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string DefaultAction" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.AccessibleObject.DefaultAction" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property DefaultAction As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ DefaultAction { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DefaultAction : string" Usage="System.Windows.Forms.AccessibleObject.DefaultAction" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取描述对象默认操作的字符串。 并非所有对象都有默认操作。</summary>
        <value>对对象默认操作的描述；如果此对象没有默认操作，则为 <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 该字符串描述对对象执行的操作，而不是对象执行的操作。 也就是说，打印文档的工具栏按钮的默认操作是 "按"，而不是 "打印当前文档"。 不要将对象的默认操作与它的值混淆。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Runtime.InteropServices.COMException">无法检索控件的默认操作。</exception>
        <block subset="none" type="overrides"><para>如果对象包装具有默认操作的系统控件，则默认实现将返回可访问对象的默认操作;否则，它将返回 <see langword="null" /> 。 只有执行操作的控件才应支持此方法。 并非所有对象都有默认操作，并且某些对象可能具有与其属性相关的默认操作 <see cref="P:System.Windows.Forms.AccessibleObject.Value" /> ，如以下示例中所示：选中的复选框的默认操作为 "取消选中" 且值为 "已选中"。 清除的复选框的默认操作为 "检查"，值为 "未选中"。 标记为 "Print" 的按钮的默认操作是 "按"，没有任何值。 显示 "Printer" 的静态文本控件或编辑控件没有默认操作，但其值为 "Printer"。 对象的 <see cref="P:System.Windows.Forms.AccessibleObject.DefaultAction" /> 属性应为谓词或短动词短语。</para></block>
        <altmember cref="P:System.Windows.Forms.AccessibleObject.Bounds" />
        <altmember cref="P:System.Windows.Forms.AccessibleObject.Description" />
        <altmember cref="P:System.Windows.Forms.AccessibleObject.Help" />
        <altmember cref="P:System.Windows.Forms.AccessibleObject.KeyboardShortcut" />
        <altmember cref="P:System.Windows.Forms.AccessibleObject.Name" />
        <altmember cref="P:System.Windows.Forms.AccessibleObject.Parent" />
        <altmember cref="P:System.Windows.Forms.AccessibleObject.Role" />
        <altmember cref="P:System.Windows.Forms.AccessibleObject.State" />
        <altmember cref="P:System.Windows.Forms.AccessibleObject.Value" />
      </Docs>
    </Member>
    <Member MemberName="Description">
      <MemberSignature Language="C#" Value="public virtual string Description { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Description" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.AccessibleObject.Description" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Description As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Description { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Description : string" Usage="System.Windows.Forms.AccessibleObject.Description" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取说明指定对象可视外观的字符串。 并非所有对象都有说明。</summary>
        <value>用户可看到的对象外观的说明，或者，如果该对象没有说明，则是 <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此属性为用户描述对象的视觉外观。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Runtime.InteropServices.COMException">无法检索控件的说明。</exception>
        <block subset="none" type="overrides"><para>如果对象包装系统控件，则默认实现将返回可访问对象的说明;否则，它将返回 <see langword="null" /> 。 描述通常用于为弱视用户或盲人用户提供更大的上下文。 它还可以用于上下文搜索或其他应用程序。 <see cref="P:System.Windows.Forms.AccessibleObject.Description" />如果说明不明显，或基于对象的 <see cref="P:System.Windows.Forms.AccessibleObject.Name" /> 、 <see cref="P:System.Windows.Forms.AccessibleObject.Role" /> 、 <see cref="P:System.Windows.Forms.AccessibleObject.State" /> 和 <see cref="P:System.Windows.Forms.AccessibleObject.Value" /> 属性，则服务器需要支持属性。 例如，具有 "确定" 的按钮不需要其他信息，但显示仙人掌图片的按钮会。 <see cref="P:System.Windows.Forms.AccessibleObject.Name" />仙人掌按钮的 "、 <see cref="P:System.Windows.Forms.AccessibleObject.Role" /> " 和 "可能" <see cref="P:System.Windows.Forms.AccessibleObject.Help" /> 属性说明了其用途，但 <see cref="P:System.Windows.Forms.AccessibleObject.Description" /> 属性传达的信息不太明确，如 "按钮显示仙人掌类照片"。</para></block>
        <altmember cref="P:System.Windows.Forms.AccessibleObject.Bounds" />
        <altmember cref="P:System.Windows.Forms.AccessibleObject.DefaultAction" />
        <altmember cref="P:System.Windows.Forms.AccessibleObject.Help" />
        <altmember cref="P:System.Windows.Forms.AccessibleObject.KeyboardShortcut" />
        <altmember cref="P:System.Windows.Forms.AccessibleObject.Name" />
        <altmember cref="P:System.Windows.Forms.AccessibleObject.Parent" />
        <altmember cref="P:System.Windows.Forms.AccessibleObject.Role" />
        <altmember cref="P:System.Windows.Forms.AccessibleObject.State" />
        <altmember cref="P:System.Windows.Forms.AccessibleObject.Value" />
      </Docs>
    </Member>
    <Member MemberName="DoDefaultAction">
      <MemberSignature Language="C#" Value="public virtual void DoDefaultAction ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void DoDefaultAction() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.AccessibleObject.DoDefaultAction" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub DoDefaultAction ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void DoDefaultAction();" />
      <MemberSignature Language="F#" Value="abstract member DoDefaultAction : unit -&gt; unit&#xA;override this.DoDefaultAction : unit -&gt; unit" Usage="accessibleObject.DoDefaultAction " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>执行与该辅助性对象相关的默认操作。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 客户端可以通过检查对象的属性来检索对象的默认操作 <xref:System.Windows.Forms.AccessibleObject.DefaultAction%2A> 。 如果支持) （而不是） <xref:System.Windows.Forms.AccessibleObject.DoDefaultAction%2A> 执行对象的默认操作，则客户端可以使用自动化 (。 但是， <xref:System.Windows.Forms.AccessibleObject.DoDefaultAction%2A> 提供了一种简单的方法来执行对象的最常用操作。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Runtime.InteropServices.COMException">无法执行该控件的默认操作。</exception>
        <block subset="none" type="overrides"><para>系统提供的用户界面元素所执行的默认操作取决于键盘状态。 也就是说，如果修改键（如 SHIFT、ALT 或 CTRL）关闭 (通过用户操作或在调用时以编程方式) <see cref="M:System.Windows.Forms.AccessibleObject.DoDefaultAction" /> ，则默认操作可能不同于这些键未关闭的情况。 并非所有对象都有默认操作。</para></block>
      </Docs>
    </Member>
    <Member MemberName="GetChild">
      <MemberSignature Language="C#" Value="public virtual System.Windows.Forms.AccessibleObject GetChild (int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Windows.Forms.AccessibleObject GetChild(int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.AccessibleObject.GetChild(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetChild (index As Integer) As AccessibleObject" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Windows::Forms::AccessibleObject ^ GetChild(int index);" />
      <MemberSignature Language="F#" Value="abstract member GetChild : int -&gt; System.Windows.Forms.AccessibleObject&#xA;override this.GetChild : int -&gt; System.Windows.Forms.AccessibleObject" Usage="accessibleObject.GetChild index" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.AccessibleObject</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">可访问子级的从零开始的索引。</param>
        <summary>检索与指定索引对应的可访问子级。</summary>
        <returns>一个 <see cref="T:System.Windows.Forms.AccessibleObject" />，表示与指定索引对应的辅助性子级。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下面的示例演示如何创建一个可访问感知的图表控件，并使用 <xref:System.Windows.Forms.AccessibleObject> 和 <xref:System.Windows.Forms.Control.ControlAccessibleObject> 类公开辅助性信息。 控件将两条曲线与图例一起绘制。 `ChartControlAccessibleObject`从派生的类 `ControlAccessibleObject` 在方法中用于为 <xref:System.Windows.Forms.Control.CreateAccessibilityInstance%2A> 图表控件提供自定义的可访问信息。 由于图表图例不是实际的 <xref:System.Windows.Forms.Control> 控件，而是由图表控件绘制，因此它没有任何内置的可访问信息。 因此， `ChartControlAccessibleObject` 类会重写 <xref:System.Windows.Forms.AccessibleObject.GetChild%2A> 方法以返回，该方法 `CurveLegendAccessibleObject` 表示图例的每个部分的可访问信息。 当可访问感知的应用程序使用此控件时，控件可以提供必需的可访问信息。  
  
 此代码摘录演示了如何重写 <xref:System.Windows.Forms.AccessibleObject.GetChild%2A> 方法。 <xref:System.Windows.Forms.AccessibleObject>有关完整的代码示例，请参阅类概述。  
  
 [!code-cpp[System.Windows.Forms.AccessibleObject#4](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.AccessibleObject/CPP/chartcontrol.cpp#4)]
 [!code-csharp[System.Windows.Forms.AccessibleObject#4](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.AccessibleObject/CS/chartcontrol.cs#4)]
 [!code-vb[System.Windows.Forms.AccessibleObject#4](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.AccessibleObject/VB/chartcontrol.vb#4)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>所有可访问对象都必须支持此属性。 如果未重写此方法，则返回 <see langword="null" /> 。 当可访问对象需要提供自定义可访问子级时，重写此方法。 如果索引无效，则此方法应返回 <see langword="null" /> 。 重写此方法时，还必须重写 <see cref="M:System.Windows.Forms.AccessibleObject.GetChildCount" /> 。</para></block>
      </Docs>
    </Member>
    <Member MemberName="GetChildCount">
      <MemberSignature Language="C#" Value="public virtual int GetChildCount ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetChildCount() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.AccessibleObject.GetChildCount" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetChildCount () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetChildCount();" />
      <MemberSignature Language="F#" Value="abstract member GetChildCount : unit -&gt; int&#xA;override this.GetChildCount : unit -&gt; int" Usage="accessibleObject.GetChildCount " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>检索属于可访问对象的子级的个数。</summary>
        <returns>属于可访问对象的子级的个数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下面的示例演示如何创建一个可访问感知的图表控件，并使用 <xref:System.Windows.Forms.AccessibleObject> 和 <xref:System.Windows.Forms.Control.ControlAccessibleObject> 类公开辅助性信息。 控件将两条曲线与图例一起绘制。 `ChartControlAccessibleObject`从派生的类 `ControlAccessibleObject` 在方法中用于为 <xref:System.Windows.Forms.Control.CreateAccessibilityInstance%2A> 图表控件提供自定义的可访问信息。 由于图表图例不是实际的 <xref:System.Windows.Forms.Control> 控件，而是由图表控件绘制，因此它没有任何内置的可访问信息。 因此， `ChartControlAccessibleObject` 类会重写 <xref:System.Windows.Forms.AccessibleObject.GetChild%2A> 方法以返回，该方法 `CurveLegendAccessibleObject` 表示图例的每个部分的可访问信息。 当可访问感知的应用程序使用此控件时，控件可以提供必需的可访问信息。  
  
 此代码演示如何重写 <xref:System.Windows.Forms.AccessibleObject.GetChildCount%2A> 方法。 <xref:System.Windows.Forms.AccessibleObject>有关完整的代码示例，请参阅类概述。  
  
 [!code-cpp[System.Windows.Forms.AccessibleObject#4](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.AccessibleObject/CPP/chartcontrol.cpp#4)]
 [!code-csharp[System.Windows.Forms.AccessibleObject#4](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.AccessibleObject/CS/chartcontrol.cs#4)]
 [!code-vb[System.Windows.Forms.AccessibleObject#4](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.AccessibleObject/VB/chartcontrol.vb#4)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>所有对象都必须支持此属性。 默认实现将返回 -1。 当可访问对象需要提供自定义可访问子级时，重写此方法。 重写此方法时，还必须重写 <see cref="M:System.Windows.Forms.AccessibleObject.GetChild(System.Int32)" /> 。</para></block>
      </Docs>
    </Member>
    <Member MemberName="GetFocused">
      <MemberSignature Language="C#" Value="public virtual System.Windows.Forms.AccessibleObject GetFocused ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Windows.Forms.AccessibleObject GetFocused() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.AccessibleObject.GetFocused" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetFocused () As AccessibleObject" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Windows::Forms::AccessibleObject ^ GetFocused();" />
      <MemberSignature Language="F#" Value="abstract member GetFocused : unit -&gt; System.Windows.Forms.AccessibleObject&#xA;override this.GetFocused : unit -&gt; System.Windows.Forms.AccessibleObject" Usage="accessibleObject.GetFocused " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.AccessibleObject</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>检索具有键盘焦点的对象。</summary>
        <returns><see cref="T:System.Windows.Forms.AccessibleObject" />，指定当前已设定焦点的子级。 如果对象本身设定了焦点，此方法返回调用对象。 如果没有对象具有焦点，则返回 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 键盘焦点的概念与活动窗口的概念相关。 活动窗口是用户在其中工作的前台窗口。 具有键盘焦点的对象是活动窗口或活动窗口的子对象。  
  
 容器中只有一个对象或项可以在任何一次获得焦点。 具有键盘焦点的对象不一定是所选对象。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Runtime.InteropServices.COMException">无法检索控件。</exception>
        <block subset="none" type="overrides"><para>所有可以接收键盘焦点的对象都必须支持此属性。</para></block>
        <altmember cref="M:System.Windows.Forms.AccessibleObject.GetChild(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetHelpTopic">
      <MemberSignature Language="C#" Value="public virtual int GetHelpTopic (out string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetHelpTopic([out] string&amp; fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.AccessibleObject.GetHelpTopic(System.String@)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetHelpTopic (ByRef fileName As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetHelpTopic([Runtime::InteropServices::Out] System::String ^ % fileName);" />
      <MemberSignature Language="F#" Value="abstract member GetHelpTopic : string -&gt; int&#xA;override this.GetHelpTopic : string -&gt; int" Usage="accessibleObject.GetHelpTopic fileName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" RefType="out" />
      </Parameters>
      <Docs>
        <param name="fileName">返回时，该属性包含与辅助性对象关联的帮助文件的路径。</param>
        <summary>获取帮助主题标识符及与该辅助性对象相关的帮助文件的路径。</summary>
        <returns>帮助主题的标识符，或者，如果没有帮助主题，则为 -1。 返回时，<paramref name="fileName" /> 参数包含与该辅助性对象相关的帮助文件的路径。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要 <xref:System.Windows.Forms.AccessibleObject> 使用 Windows 帮助系统显示的帮助，可以将文件名和主题 ID 传递到的适当 <xref:System.Windows.Forms.Help.ShowHelp%2A?displayProperty=nameWithType> 方法 <xref:System.Windows.Forms.Help> 。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Runtime.InteropServices.COMException">无法检索控件的帮助主题。</exception>
        <block subset="none" type="overrides"><para>并非所有对象都需要支持该属性。</para></block>
        <altmember cref="T:System.Windows.Forms.Help" />
        <altmember cref="P:System.Windows.Forms.AccessibleObject.Help" />
      </Docs>
    </Member>
    <Member MemberName="GetSelected">
      <MemberSignature Language="C#" Value="public virtual System.Windows.Forms.AccessibleObject GetSelected ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Windows.Forms.AccessibleObject GetSelected() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.AccessibleObject.GetSelected" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetSelected () As AccessibleObject" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Windows::Forms::AccessibleObject ^ GetSelected();" />
      <MemberSignature Language="F#" Value="abstract member GetSelected : unit -&gt; System.Windows.Forms.AccessibleObject&#xA;override this.GetSelected : unit -&gt; System.Windows.Forms.AccessibleObject" Usage="accessibleObject.GetSelected " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.AccessibleObject</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>检索当前选定的子级。</summary>
        <returns>表示当前选定子级的 <see cref="T:System.Windows.Forms.AccessibleObject" />。 如果选定了对象本身，则此方法返回调用对象。 如果当前没有选定子级且对象本身没有焦点，则返回 <see langword="null" />。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Runtime.InteropServices.COMException">无法检索选定的子级。</exception>
        <block subset="none" type="overrides"><para>可以选择的所有对象都应支持此属性。</para></block>
      </Docs>
    </Member>
    <Member MemberName="Help">
      <MemberSignature Language="C#" Value="public virtual string Help { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Help" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.AccessibleObject.Help" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Help As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Help { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Help : string" Usage="System.Windows.Forms.AccessibleObject.Help" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取对象用途或如何使用对象的说明。</summary>
        <value><see cref="T:System.String" />，包含对象用途或如何使用对象的说明。 如果没有定义帮助，则返回 <see langword="null" />。</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Runtime.InteropServices.COMException">无法检索控件的帮助字符串。</exception>
        <block subset="none" type="overrides"><para>并非所有对象都需要支持该属性。 通常，此属性包含用于描述对象的用途或用法的工具提示样式信息。 例如， <see cref="P:System.Windows.Forms.AccessibleObject.Help" /> 显示打印机的工具栏按钮的属性可能是 "打印当前文档"。 属性的文本在 <see cref="P:System.Windows.Forms.AccessibleObject.Help" /> 用户界面中不必是唯一的。 <see cref="P:System.Windows.Forms.AccessibleObject.Help" />如果其他属性提供了与对象的用途有关的信息以及该对象可能执行的操作，则服务器不需要支持属性。</para></block>
        <altmember cref="P:System.Windows.Forms.AccessibleObject.Bounds" />
        <altmember cref="P:System.Windows.Forms.AccessibleObject.DefaultAction" />
        <altmember cref="P:System.Windows.Forms.AccessibleObject.Description" />
        <altmember cref="P:System.Windows.Forms.AccessibleObject.KeyboardShortcut" />
        <altmember cref="P:System.Windows.Forms.AccessibleObject.Name" />
        <altmember cref="P:System.Windows.Forms.AccessibleObject.Parent" />
        <altmember cref="P:System.Windows.Forms.AccessibleObject.Role" />
        <altmember cref="P:System.Windows.Forms.AccessibleObject.State" />
        <altmember cref="P:System.Windows.Forms.AccessibleObject.Value" />
      </Docs>
    </Member>
    <Member MemberName="HitTest">
      <MemberSignature Language="C#" Value="public virtual System.Windows.Forms.AccessibleObject HitTest (int x, int y);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Windows.Forms.AccessibleObject HitTest(int32 x, int32 y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.AccessibleObject.HitTest(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function HitTest (x As Integer, y As Integer) As AccessibleObject" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Windows::Forms::AccessibleObject ^ HitTest(int x, int y);" />
      <MemberSignature Language="F#" Value="abstract member HitTest : int * int -&gt; System.Windows.Forms.AccessibleObject&#xA;override this.HitTest : int * int -&gt; System.Windows.Forms.AccessibleObject" Usage="accessibleObject.HitTest (x, y)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.AccessibleObject</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Int32" />
        <Parameter Name="y" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="x">水平屏幕坐标。</param>
        <param name="y">垂直屏幕坐标。</param>
        <summary>检索位于指定屏幕坐标的子对象。</summary>
        <returns>一个 <see cref="T:System.Windows.Forms.AccessibleObject" />，表示位于给定屏幕坐标位置的子对象。 如果对象本身位于指定位置，则此方法返回调用对象。 如果测试位置没有对象，则返回 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 对于不包含列表视图项的非矩形对象，如果使用进行了测试，则检索到的对象的边框的坐标 <xref:System.Windows.Forms.AccessibleObject.Bounds%2A> 可能会失败 <xref:System.Windows.Forms.AccessibleObject.HitTest%2A> ，因为 <xref:System.Windows.Forms.AccessibleObject.HitTest%2A> 在每个像素的基础上确定对象的边界。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Runtime.InteropServices.COMException">无法对控件进行点击检测。</exception>
        <block subset="none" type="overrides"><para>所有视觉对象都必须支持此方法;声音对象不支持此操作。</para></block>
      </Docs>
    </Member>
    <Member MemberName="KeyboardShortcut">
      <MemberSignature Language="C#" Value="public virtual string KeyboardShortcut { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string KeyboardShortcut" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.AccessibleObject.KeyboardShortcut" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property KeyboardShortcut As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ KeyboardShortcut { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.KeyboardShortcut : string" Usage="System.Windows.Forms.AccessibleObject.KeyboardShortcut" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取辅助性对象的快捷键或访问键。</summary>
        <value>辅助性对象的快捷键或访问键，或者，如果没有与此对象相关联的快捷键，则是 <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 访问键（也称为助记键）是菜单、菜单项、按钮标签或其他控件的文本中带下划线的字符。 例如，用户可以按 ALT 键显示菜单，同时按指示的带下划线键（如 ALT + F）打开 `File` 菜单。 若要使用菜单项的访问键，包含该项的菜单必须处于活动状态。 控件（如工具栏按钮和菜单项）通常具有关联的快捷键。 菜单项可以具有访问键和与其关联的快捷键。 如果该属性的值 <xref:System.Windows.Forms.AccessibleObject.KeyboardShortcut%2A> 是单个字符，则可以假定它是一个访问键。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Runtime.InteropServices.COMException">无法检索控件的快捷方式。</exception>
        <block subset="none" type="overrides"><para>具有快捷键或访问键的所有对象都应支持此属性。</para></block>
        <altmember cref="P:System.Windows.Forms.AccessibleObject.Bounds" />
        <altmember cref="P:System.Windows.Forms.AccessibleObject.DefaultAction" />
        <altmember cref="P:System.Windows.Forms.AccessibleObject.Description" />
        <altmember cref="P:System.Windows.Forms.AccessibleObject.Help" />
        <altmember cref="P:System.Windows.Forms.AccessibleObject.Name" />
        <altmember cref="P:System.Windows.Forms.AccessibleObject.Parent" />
        <altmember cref="P:System.Windows.Forms.AccessibleObject.Role" />
        <altmember cref="P:System.Windows.Forms.AccessibleObject.State" />
        <altmember cref="P:System.Windows.Forms.AccessibleObject.Value" />
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public virtual string Name { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.AccessibleObject.Name" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Name { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Name : string with get, set" Usage="System.Windows.Forms.AccessibleObject.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置对象名。</summary>
        <value>对象名，或者，如果尚未设置属性，则是 <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.AccessibleObject.Name%2A>属性是一个字符串，客户端使用它来标识、查找或公布用户的对象。 若要访问子对象的名称，必须首先 <xref:System.Windows.Forms.AccessibleObject.GetChild%2A> 使用要检索其名称的子级的索引调用。  
  
   
  
## Examples  
 下面的示例演示如何创建一个可访问感知的图表控件，并使用 <xref:System.Windows.Forms.AccessibleObject> 和 <xref:System.Windows.Forms.Control.ControlAccessibleObject> 类公开辅助性信息。 控件将两条曲线与图例一起绘制。 `ChartControlAccessibleObject`从派生的类 `ControlAccessibleObject` 在方法中用于为 <xref:System.Windows.Forms.Control.CreateAccessibilityInstance%2A> 图表控件提供自定义的可访问信息。 由于图表图例不是实际的 <xref:System.Windows.Forms.Control> 控件，而是由图表控件绘制，因此它没有任何内置的可访问信息。 因此， `ChartControlAccessibleObject` 类会重写 <xref:System.Windows.Forms.AccessibleObject.GetChild%2A> 方法以返回，该方法 `CurveLegendAccessibleObject` 表示图例的每个部分的可访问信息。 当可访问感知的应用程序使用此控件时，控件可以提供必需的可访问信息。  
  
 此代码摘录演示了如何重写 <xref:System.Windows.Forms.AccessibleObject.Name%2A> 属性。 <xref:System.Windows.Forms.AccessibleObject>有关完整的代码示例，请参阅类概述。  
  
 [!code-cpp[System.Windows.Forms.AccessibleObject#6](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.AccessibleObject/CPP/chartcontrol.cpp#6)]
 [!code-csharp[System.Windows.Forms.AccessibleObject#6](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.AccessibleObject/CS/chartcontrol.cs#6)]
 [!code-vb[System.Windows.Forms.AccessibleObject#6](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.AccessibleObject/VB/chartcontrol.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Runtime.InteropServices.COMException">无法检索或设置控件名。</exception>
        <block subset="none" type="overrides"><para>所有对象都应支持此属性。 对象的名称应是直观的，以便用户了解对象的含义或用途。 此外，请确保 <see langword="Name" /> 属性相对于父对象中的任何同级对象是唯一的。 在表中导航为某些用户带来了特别困难的问题。 因此，服务器开发人员应将表的单元名称设置为描述性名称。 例如，您可以通过将它所占据的行和列的名称（如 "A1"）来创建单元名称。 但是，使用更具描述性的名称（例如 "Karin，二月"）通常更好。 许多对象（如图标、菜单、复选框、组合框和其他控件）都具有向用户显示的标签。 向用户显示的任何标签都应该用于对象的 <see cref="P:System.Windows.Forms.AccessibleObject.Name" /> 属性。 有关详细信息，请参阅 <see cref="P:System.Windows.Forms.AccessibleObject.Name" /> 属性。  
  
如果使用的是属性的 "菜单" 或 "按钮文本" <see cref="P:System.Windows.Forms.AccessibleObject.Name" /> ，请去掉 &amp; 标记键盘访问密钥的 "与" 符号 () 。</para></block>
        <altmember cref="P:System.Windows.Forms.AccessibleObject.Bounds" />
        <altmember cref="P:System.Windows.Forms.AccessibleObject.DefaultAction" />
        <altmember cref="P:System.Windows.Forms.AccessibleObject.Description" />
        <altmember cref="P:System.Windows.Forms.AccessibleObject.Help" />
        <altmember cref="P:System.Windows.Forms.AccessibleObject.KeyboardShortcut" />
        <altmember cref="P:System.Windows.Forms.AccessibleObject.Parent" />
        <altmember cref="P:System.Windows.Forms.AccessibleObject.Role" />
        <altmember cref="P:System.Windows.Forms.AccessibleObject.State" />
        <altmember cref="P:System.Windows.Forms.AccessibleObject.Value" />
      </Docs>
    </Member>
    <Member MemberName="Navigate">
      <MemberSignature Language="C#" Value="public virtual System.Windows.Forms.AccessibleObject Navigate (System.Windows.Forms.AccessibleNavigation navdir);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Windows.Forms.AccessibleObject Navigate(valuetype System.Windows.Forms.AccessibleNavigation navdir) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.AccessibleObject.Navigate(System.Windows.Forms.AccessibleNavigation)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Navigate (navdir As AccessibleNavigation) As AccessibleObject" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Windows::Forms::AccessibleObject ^ Navigate(System::Windows::Forms::AccessibleNavigation navdir);" />
      <MemberSignature Language="F#" Value="abstract member Navigate : System.Windows.Forms.AccessibleNavigation -&gt; System.Windows.Forms.AccessibleObject&#xA;override this.Navigate : System.Windows.Forms.AccessibleNavigation -&gt; System.Windows.Forms.AccessibleObject" Usage="accessibleObject.Navigate navdir" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.AccessibleObject</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="navdir" Type="System.Windows.Forms.AccessibleNavigation" />
      </Parameters>
      <Docs>
        <param name="navdir"><see cref="T:System.Windows.Forms.AccessibleNavigation" /> 值之一。</param>
        <summary>定位到另一个辅助性对象。</summary>
        <returns>表示 <see cref="T:System.Windows.Forms.AccessibleObject" /> 值之一的 <see cref="T:System.Windows.Forms.AccessibleNavigation" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 导航（空间和逻辑）始终限制为容器中的用户界面元素。 使用空间导航，客户端只能导航到起始对象的同级。 根据用于逻辑导航的导航标志，客户端可以导航到子对象的子对象或同级对象。 此方法不更改所选内容或焦点。 若要更改焦点或选择对象，请使用 <xref:System.Windows.Forms.AccessibleObject.Select%2A> 。 <xref:System.Windows.Forms.AccessibleObject.Navigate%2A>方法只检索具有定义的屏幕位置的用户界面元素。  
  
   
  
## Examples  
 下面的示例演示如何创建一个可访问感知的图表控件，并使用 <xref:System.Windows.Forms.AccessibleObject> 和 <xref:System.Windows.Forms.Control.ControlAccessibleObject> 类公开辅助性信息。 控件将两条曲线与图例一起绘制。 `ChartControlAccessibleObject`从派生的类 `ControlAccessibleObject` 在方法中用于为 <xref:System.Windows.Forms.Control.CreateAccessibilityInstance%2A> 图表控件提供自定义的可访问信息。 由于图表图例不是实际的 <xref:System.Windows.Forms.Control> 控件，而是由图表控件绘制，因此它没有任何内置的可访问信息。 因此， `ChartControlAccessibleObject` 类会重写 <xref:System.Windows.Forms.AccessibleObject.GetChild%2A> 方法以返回，该方法 `CurveLegendAccessibleObject` 表示图例的每个部分的可访问信息。 当可访问感知的应用程序使用此控件时，控件可以提供必需的可访问信息。  
  
 此代码演示如何重写 <xref:System.Windows.Forms.AccessibleObject.Navigate%2A> 方法。 <xref:System.Windows.Forms.AccessibleObject>有关完整的代码示例，请参阅类概述。  
  
 [!code-cpp[System.Windows.Forms.AccessibleObject#6](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.AccessibleObject/CPP/chartcontrol.cpp#6)]
 [!code-csharp[System.Windows.Forms.AccessibleObject#6](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.AccessibleObject/CS/chartcontrol.cs#6)]
 [!code-vb[System.Windows.Forms.AccessibleObject#6](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.AccessibleObject/VB/chartcontrol.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Runtime.InteropServices.COMException">导航尝试失败。</exception>
        <block subset="none" type="overrides"><para>所有视觉对象都必须支持此方法。 如果对象具有状态，则 <see cref="F:System.Windows.Forms.AccessibleStates.Invisible" /> 导航到此隐藏对象可能会失败。 某些系统定义的界面元素（如菜单、菜单项和弹出菜单）允许导航到不可见的对象。 但是，其他系统定义的用户界面元素不支持此操作。 如果可能，服务器应该支持导航到不可见的对象，但不需要此支持，客户端不应期待。</para></block>
      </Docs>
    </Member>
    <Member MemberName="Parent">
      <MemberSignature Language="C#" Value="public virtual System.Windows.Forms.AccessibleObject Parent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.AccessibleObject Parent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.AccessibleObject.Parent" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Parent As AccessibleObject" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Windows::Forms::AccessibleObject ^ Parent { System::Windows::Forms::AccessibleObject ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Parent : System.Windows.Forms.AccessibleObject" Usage="System.Windows.Forms.AccessibleObject.Parent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.AccessibleObject</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取辅助性对象的父级。</summary>
        <value>表示可访问对象父级的 <see cref="T:System.Windows.Forms.AccessibleObject" />，如果没有父对象，则是 <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下面的示例演示如何创建一个可访问感知的图表控件，并使用 <xref:System.Windows.Forms.AccessibleObject> 和 <xref:System.Windows.Forms.Control.ControlAccessibleObject> 类公开辅助性信息。 控件将两条曲线与图例一起绘制。 `ChartControlAccessibleObject`从派生的类 `ControlAccessibleObject` 在方法中用于为 <xref:System.Windows.Forms.Control.CreateAccessibilityInstance%2A> 图表控件提供自定义的可访问信息。 由于图表图例不是实际的 <xref:System.Windows.Forms.Control> 控件，而是由图表控件绘制，因此它没有任何内置的可访问信息。 因此， `ChartControlAccessibleObject` 类会重写 <xref:System.Windows.Forms.AccessibleObject.GetChild%2A> 方法以返回，该方法 `CurveLegendAccessibleObject` 表示图例的每个部分的可访问信息。 当可访问感知的应用程序使用此控件时，控件可以提供必需的可访问信息。  
  
 此代码摘录演示了如何重写 <xref:System.Windows.Forms.AccessibleObject.Parent%2A> 属性。 <xref:System.Windows.Forms.AccessibleObject>有关完整的代码示例，请参阅类概述。  
  
 [!code-cpp[System.Windows.Forms.AccessibleObject#6](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.AccessibleObject/CPP/chartcontrol.cpp#6)]
 [!code-csharp[System.Windows.Forms.AccessibleObject#6](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.AccessibleObject/CS/chartcontrol.cs#6)]
 [!code-vb[System.Windows.Forms.AccessibleObject#6](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.AccessibleObject/VB/chartcontrol.vb#6)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>所有对象都应支持此属性。</para></block>
        <altmember cref="P:System.Windows.Forms.AccessibleObject.Bounds" />
        <altmember cref="P:System.Windows.Forms.AccessibleObject.DefaultAction" />
        <altmember cref="P:System.Windows.Forms.AccessibleObject.Description" />
        <altmember cref="P:System.Windows.Forms.AccessibleObject.Help" />
        <altmember cref="P:System.Windows.Forms.AccessibleObject.KeyboardShortcut" />
        <altmember cref="P:System.Windows.Forms.AccessibleObject.Name" />
        <altmember cref="P:System.Windows.Forms.AccessibleObject.Role" />
        <altmember cref="P:System.Windows.Forms.AccessibleObject.State" />
        <altmember cref="P:System.Windows.Forms.AccessibleObject.Value" />
      </Docs>
    </Member>
    <Member MemberName="RaiseAutomationNotification">
      <MemberSignature Language="C#" Value="public bool RaiseAutomationNotification (System.Windows.Forms.Automation.AutomationNotificationKind notificationKind, System.Windows.Forms.Automation.AutomationNotificationProcessing notificationProcessing, string notificationText);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool RaiseAutomationNotification(valuetype System.Windows.Forms.Automation.AutomationNotificationKind notificationKind, valuetype System.Windows.Forms.Automation.AutomationNotificationProcessing notificationProcessing, string notificationText) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.AccessibleObject.RaiseAutomationNotification(System.Windows.Forms.Automation.AutomationNotificationKind,System.Windows.Forms.Automation.AutomationNotificationProcessing,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function RaiseAutomationNotification (notificationKind As AutomationNotificationKind, notificationProcessing As AutomationNotificationProcessing, notificationText As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool RaiseAutomationNotification(System::Windows::Forms::Automation::AutomationNotificationKind notificationKind, System::Windows::Forms::Automation::AutomationNotificationProcessing notificationProcessing, System::String ^ notificationText);" />
      <MemberSignature Language="F#" Value="member this.RaiseAutomationNotification : System.Windows.Forms.Automation.AutomationNotificationKind * System.Windows.Forms.Automation.AutomationNotificationProcessing * string -&gt; bool" Usage="accessibleObject.RaiseAutomationNotification (notificationKind, notificationProcessing, notificationText)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="notificationKind" Type="System.Windows.Forms.Automation.AutomationNotificationKind" Index="0" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-4.8" />
        <Parameter Name="notificationProcessing" Type="System.Windows.Forms.Automation.AutomationNotificationProcessing" Index="1" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-4.8" />
        <Parameter Name="notificationText" Type="System.String" Index="2" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="notificationKind">通知的类型。</param>
        <param name="notificationProcessing">如何处理通知的指示器。</param>
        <param name="notificationText">通知的文本。</param>
        <summary>引发 UI 自动化通知事件。</summary>
        <returns>如果操作成功，则为 <see langword="true" />；如果基础的 Windows 基础结构不可用或操作失败，则为 <see langword="false" />。 调用 <see cref="M:System.Runtime.InteropServices.Marshal.GetLastWin32Error" /> 以获取详细信息。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks

此事件可从 Windows 10 版本1709开始。
  
       ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RaiseLiveRegionChanged">
      <MemberSignature Language="C#" Value="public virtual bool RaiseLiveRegionChanged ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool RaiseLiveRegionChanged() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.AccessibleObject.RaiseLiveRegionChanged" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function RaiseLiveRegionChanged () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool RaiseLiveRegionChanged();" />
      <MemberSignature Language="F#" Value="abstract member RaiseLiveRegionChanged : unit -&gt; bool&#xA;override this.RaiseLiveRegionChanged : unit -&gt; bool" Usage="accessibleObject.RaiseLiveRegionChanged " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>引发 LiveRegionChanged UI 自动化事件。</summary>
        <returns>如果操作成功，则为 <see langword="true" />；否则为 <see langword="False" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks

必须在支持 UI 自动化实时区域功能的派生类中重写此方法。
  
     ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">不支持可访问性对象活动区域。</exception>
      </Docs>
    </Member>
    <Member MemberName="Role">
      <MemberSignature Language="C#" Value="public virtual System.Windows.Forms.AccessibleRole Role { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.AccessibleRole Role" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.AccessibleObject.Role" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Role As AccessibleRole" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Windows::Forms::AccessibleRole Role { System::Windows::Forms::AccessibleRole get(); };" />
      <MemberSignature Language="F#" Value="member this.Role : System.Windows.Forms.AccessibleRole" Usage="System.Windows.Forms.AccessibleObject.Role" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.AccessibleRole</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取此辅助性对象的角色。</summary>
        <value><see cref="T:System.Windows.Forms.AccessibleRole" /> 值之一；如果尚未指定角色，则为 <see cref="F:System.Windows.Forms.AccessibleRole.None" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 对象的角色有助于描述对象的功能。  
  
   
  
## Examples  
 下面的示例演示如何创建一个可访问感知的图表控件，并使用 <xref:System.Windows.Forms.AccessibleObject> 和 <xref:System.Windows.Forms.Control.ControlAccessibleObject> 类公开辅助性信息。 控件将两条曲线与图例一起绘制。 `ChartControlAccessibleObject`从派生的类 `ControlAccessibleObject` 在方法中用于为 <xref:System.Windows.Forms.Control.CreateAccessibilityInstance%2A> 图表控件提供自定义的可访问信息。 由于图表图例不是实际的 <xref:System.Windows.Forms.Control> 控件，而是由图表控件绘制，因此它没有任何内置的可访问信息。 因此， `ChartControlAccessibleObject` 类会重写 <xref:System.Windows.Forms.AccessibleObject.GetChild%2A> 方法以返回，该方法 `CurveLegendAccessibleObject` 表示图例的每个部分的可访问信息。 当可访问感知的应用程序使用此控件时，控件可以提供必需的可访问信息。  
  
 此代码摘录演示了如何重写 <xref:System.Windows.Forms.AccessibleObject.Role%2A> 属性。 <xref:System.Windows.Forms.AccessibleObject>有关完整的代码示例，请参阅类概述。  
  
 [!code-cpp[System.Windows.Forms.AccessibleObject#4](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.AccessibleObject/CPP/chartcontrol.cpp#4)]
 [!code-csharp[System.Windows.Forms.AccessibleObject#4](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.AccessibleObject/CS/chartcontrol.cs#4)]
 [!code-vb[System.Windows.Forms.AccessibleObject#4](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.AccessibleObject/VB/chartcontrol.vb#4)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>所有对象都应支持此属性。</para></block>
        <altmember cref="P:System.Windows.Forms.AccessibleObject.Bounds" />
        <altmember cref="P:System.Windows.Forms.AccessibleObject.DefaultAction" />
        <altmember cref="P:System.Windows.Forms.AccessibleObject.Description" />
        <altmember cref="P:System.Windows.Forms.AccessibleObject.Help" />
        <altmember cref="P:System.Windows.Forms.AccessibleObject.KeyboardShortcut" />
        <altmember cref="P:System.Windows.Forms.AccessibleObject.Name" />
        <altmember cref="P:System.Windows.Forms.AccessibleObject.Parent" />
        <altmember cref="P:System.Windows.Forms.AccessibleObject.State" />
        <altmember cref="P:System.Windows.Forms.AccessibleObject.Value" />
      </Docs>
    </Member>
    <Member MemberName="Select">
      <MemberSignature Language="C#" Value="public virtual void Select (System.Windows.Forms.AccessibleSelection flags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Select(valuetype System.Windows.Forms.AccessibleSelection flags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.AccessibleObject.Select(System.Windows.Forms.AccessibleSelection)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Select (flags As AccessibleSelection)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Select(System::Windows::Forms::AccessibleSelection flags);" />
      <MemberSignature Language="F#" Value="abstract member Select : System.Windows.Forms.AccessibleSelection -&gt; unit&#xA;override this.Select : System.Windows.Forms.AccessibleSelection -&gt; unit" Usage="accessibleObject.Select flags" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="flags" Type="System.Windows.Forms.AccessibleSelection" />
      </Parameters>
      <Docs>
        <param name="flags"><see cref="T:System.Windows.Forms.AccessibleSelection" /> 值之一。</param>
        <summary>修改选择内容或移动辅助性对象的键盘焦点。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 应用程序可以使用此方法执行复杂的选择操作。  
  
 下面介绍 <xref:System.Windows.Forms.AccessibleSelection> 在调用 <xref:System.Windows.Forms.AccessibleObject.Select%2A> 以执行复杂选择操作时要指定哪些值。  
  
|Operation|标志组合|  
|---------------|----------------------|  
|模拟单击|<xref:System.Windows.Forms.AccessibleSelection.TakeFocus?displayProperty=nameWithType>`OR` <xref:System.Windows.Forms.AccessibleSelection.TakeSelection?displayProperty=nameWithType> **注意：** 如果从你自己的应用程序中调用，此组合不会选择所需的控件。 不过，如果从外部应用程序调用，它将具有所需的效果。|  
|通过模拟 CTRL + 单击来选择目标项|<xref:System.Windows.Forms.AccessibleSelection.TakeFocus?displayProperty=nameWithType> `OR` <xref:System.Windows.Forms.AccessibleSelection.AddSelection?displayProperty=nameWithType>|  
|通过模拟 CTRL + 单击取消选择目标项|<xref:System.Windows.Forms.AccessibleSelection.TakeFocus?displayProperty=nameWithType> `OR` <xref:System.Windows.Forms.AccessibleSelection.RemoveSelection?displayProperty=nameWithType>|  
|模拟 SHIFT + 单击|<xref:System.Windows.Forms.AccessibleSelection.TakeFocus?displayProperty=nameWithType> `OR` <xref:System.Windows.Forms.AccessibleSelection.ExtendSelection?displayProperty=nameWithType>|  
|选择对象范围并将焦点放在最后一个对象上|<xref:System.Windows.Forms.AccessibleSelection.TakeFocus?displayProperty=nameWithType>在起始对象上指定以设置选择定位点。 然后 <xref:System.Windows.Forms.AccessibleObject.Select%2A> 再次调用，并 <xref:System.Windows.Forms.AccessibleSelection.TakeFocus?displayProperty=nameWithType> `OR` <xref:System.Windows.Forms.AccessibleSelection.ExtendSelection?displayProperty=nameWithType> 在最后一个对象上指定。|  
|取消选择所有对象|<xref:System.Windows.Forms.AccessibleSelection.TakeSelection?displayProperty=nameWithType>对任何对象指定。 此标志取消选择除了刚选择的对象之外的所有选择的对象。 然后 <xref:System.Windows.Forms.AccessibleObject.Select%2A> 再次调用并 <xref:System.Windows.Forms.AccessibleSelection.RemoveSelection?displayProperty=nameWithType> 对同一对象指定。|  
  
   
  
## Examples  
 下面的示例演示如何创建一个可访问感知的图表控件，并使用 <xref:System.Windows.Forms.AccessibleObject> 和 <xref:System.Windows.Forms.Control.ControlAccessibleObject> 类公开辅助性信息。 控件将两条曲线与图例一起绘制。 `ChartControlAccessibleObject`从派生的类 `ControlAccessibleObject` 在方法中用于为 <xref:System.Windows.Forms.Control.CreateAccessibilityInstance%2A> 图表控件提供自定义的可访问信息。 由于图表图例不是实际的 <xref:System.Windows.Forms.Control> 控件，而是由图表控件绘制，因此它没有任何内置的可访问信息。 因此， `ChartControlAccessibleObject` 类会重写 <xref:System.Windows.Forms.AccessibleObject.GetChild%2A> 方法以返回，该方法 `CurveLegendAccessibleObject` 表示图例的每个部分的可访问信息。 当可访问感知的应用程序使用此控件时，控件可以提供必需的可访问信息。  
  
 此代码演示如何重写 <xref:System.Windows.Forms.AccessibleObject.Select%2A> 方法。 <xref:System.Windows.Forms.AccessibleObject>有关完整的代码示例，请参阅类概述。  
  
 [!code-cpp[System.Windows.Forms.AccessibleObject#6](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.AccessibleObject/CPP/chartcontrol.cpp#6)]
 [!code-csharp[System.Windows.Forms.AccessibleObject#6](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.AccessibleObject/CS/chartcontrol.cs#6)]
 [!code-vb[System.Windows.Forms.AccessibleObject#6](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.AccessibleObject/VB/chartcontrol.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Runtime.InteropServices.COMException">无法执行选择。</exception>
        <block subset="none" type="overrides"><para>所有可以选择或接收键盘焦点的对象都必须支持此方法。</para></block>
      </Docs>
    </Member>
    <Member MemberName="State">
      <MemberSignature Language="C#" Value="public virtual System.Windows.Forms.AccessibleStates State { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.AccessibleStates State" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.AccessibleObject.State" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property State As AccessibleStates" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Windows::Forms::AccessibleStates State { System::Windows::Forms::AccessibleStates get(); };" />
      <MemberSignature Language="F#" Value="member this.State : System.Windows.Forms.AccessibleStates" Usage="System.Windows.Forms.AccessibleObject.State" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.AccessibleStates</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取此辅助性对象的状态。</summary>
        <value><see cref="T:System.Windows.Forms.AccessibleStates" /> 值之一，或者，如果没有设置状态，则是 <see cref="F:System.Windows.Forms.AccessibleStates.None" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下面的示例演示如何创建一个可访问感知的图表控件，并使用 <xref:System.Windows.Forms.AccessibleObject> 和 <xref:System.Windows.Forms.Control.ControlAccessibleObject> 类公开辅助性信息。 控件将两条曲线与图例一起绘制。 `ChartControlAccessibleObject`从派生的类 `ControlAccessibleObject` 在方法中用于为 <xref:System.Windows.Forms.Control.CreateAccessibilityInstance%2A> 图表控件提供自定义的可访问信息。 由于图表图例不是实际的 <xref:System.Windows.Forms.Control> 控件，而是由图表控件绘制，因此它没有任何内置的可访问信息。 因此， `ChartControlAccessibleObject` 类会重写 <xref:System.Windows.Forms.AccessibleObject.GetChild%2A> 方法以返回，该方法 `CurveLegendAccessibleObject` 表示图例的每个部分的可访问信息。 当可访问感知的应用程序使用此控件时，控件可以提供必需的可访问信息。  
  
 此代码摘录演示了如何重写 <xref:System.Windows.Forms.AccessibleObject.State%2A> 属性。 <xref:System.Windows.Forms.AccessibleObject>有关完整的代码示例，请参阅类概述。  
  
 [!code-cpp[System.Windows.Forms.AccessibleObject#4](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.AccessibleObject/CPP/chartcontrol.cpp#4)]
 [!code-csharp[System.Windows.Forms.AccessibleObject#4](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.AccessibleObject/CS/chartcontrol.cs#4)]
 [!code-vb[System.Windows.Forms.AccessibleObject#4](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.AccessibleObject/VB/chartcontrol.vb#4)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>所有对象都应支持此属性。</para></block>
        <altmember cref="P:System.Windows.Forms.AccessibleObject.Bounds" />
        <altmember cref="P:System.Windows.Forms.AccessibleObject.DefaultAction" />
        <altmember cref="P:System.Windows.Forms.AccessibleObject.Description" />
        <altmember cref="P:System.Windows.Forms.AccessibleObject.Help" />
        <altmember cref="P:System.Windows.Forms.AccessibleObject.KeyboardShortcut" />
        <altmember cref="P:System.Windows.Forms.AccessibleObject.Name" />
        <altmember cref="P:System.Windows.Forms.AccessibleObject.Parent" />
        <altmember cref="P:System.Windows.Forms.AccessibleObject.Role" />
        <altmember cref="P:System.Windows.Forms.AccessibleObject.Value" />
      </Docs>
    </Member>
    <Member MemberName="System.Reflection.IReflect.GetField">
      <MemberSignature Language="C#" Value="System.Reflection.FieldInfo IReflect.GetField (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Reflection.FieldInfo System.Reflection.IReflect.GetField(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.AccessibleObject.System#Reflection#IReflect#GetField(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Function GetField (name As String, bindingAttr As BindingFlags) As FieldInfo Implements IReflect.GetField" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Reflection::FieldInfo ^ System.Reflection.IReflect.GetField(System::String ^ name, System::Reflection::BindingFlags bindingAttr) = System::Reflection::IReflect::GetField;" />
      <MemberSignature Language="F#" Value="abstract member System.Reflection.IReflect.GetField : string * System.Reflection.BindingFlags -&gt; System.Reflection.FieldInfo&#xA;override this.System.Reflection.IReflect.GetField : string * System.Reflection.BindingFlags -&gt; System.Reflection.FieldInfo" Usage="accessibleObject.System.Reflection.IReflect.GetField (name, bindingAttr)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Reflection.IReflect.GetField(System.String,System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name">要查找的字段的名称。</param>
        <param name="bindingAttr">用于控制搜索的绑定属性。</param>
        <summary>获取与指定字段和绑定标志对应的 <see cref="T:System.Reflection.FieldInfo" /> 对象。 有关此成员的说明，请参见 <see cref="M:System.Reflection.IReflect.GetField(System.String,System.Reflection.BindingFlags)" />。</summary>
        <returns><see cref="T:System.Reflection.FieldInfo" /> 对象，包含命名对象的符合 <paramref name="bindingAttr" /> 中指定的搜索约束的字段信息。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此成员是显式接口成员的实现。 它只能在 <xref:System.Windows.Forms.AccessibleObject> 实例被强制转换为 <xref:System.Reflection.IReflect> 接口时使用。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">该对象实现同名的多个字段。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Reflection.IReflect.GetFields">
      <MemberSignature Language="C#" Value="System.Reflection.FieldInfo[] IReflect.GetFields (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Reflection.FieldInfo[] System.Reflection.IReflect.GetFields(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.AccessibleObject.System#Reflection#IReflect#GetFields(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Function GetFields (bindingAttr As BindingFlags) As FieldInfo() Implements IReflect.GetFields" />
      <MemberSignature Language="C++ CLI" Value=" virtual cli::array &lt;System::Reflection::FieldInfo ^&gt; ^ System.Reflection.IReflect.GetFields(System::Reflection::BindingFlags bindingAttr) = System::Reflection::IReflect::GetFields;" />
      <MemberSignature Language="F#" Value="abstract member System.Reflection.IReflect.GetFields : System.Reflection.BindingFlags -&gt; System.Reflection.FieldInfo[]&#xA;override this.System.Reflection.IReflect.GetFields : System.Reflection.BindingFlags -&gt; System.Reflection.FieldInfo[]" Usage="accessibleObject.System.Reflection.IReflect.GetFields bindingAttr" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Reflection.IReflect.GetFields(System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">用于控制搜索的绑定属性。</param>
        <summary>获取与当前类的所有字段对应的 <see cref="T:System.Reflection.FieldInfo" /> 对象的数组。 有关此成员的说明，请参见 <see cref="M:System.Reflection.IReflect.GetFields(System.Reflection.BindingFlags)" />。</summary>
        <returns><see cref="T:System.Reflection.FieldInfo" /> 对象的数组，包含此反射对象的符合 <paramref name="bindingAttr" /> 中指定的搜索约束的所有字段信息。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 每个字段都必须具有唯一的名称。 <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType>标志指定包含在搜索中的非公共字段。 <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType>标志指定在搜索中包含公共字段。  
  
 此成员是显式接口成员的实现。 它只能在 <xref:System.Windows.Forms.AccessibleObject> 实例被强制转换为 <xref:System.Reflection.IReflect> 接口时使用。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Reflection.IReflect.GetMember">
      <MemberSignature Language="C#" Value="System.Reflection.MemberInfo[] IReflect.GetMember (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Reflection.MemberInfo[] System.Reflection.IReflect.GetMember(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.AccessibleObject.System#Reflection#IReflect#GetMember(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Function GetMember (name As String, bindingAttr As BindingFlags) As MemberInfo() Implements IReflect.GetMember" />
      <MemberSignature Language="C++ CLI" Value=" virtual cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ System.Reflection.IReflect.GetMember(System::String ^ name, System::Reflection::BindingFlags bindingAttr) = System::Reflection::IReflect::GetMember;" />
      <MemberSignature Language="F#" Value="abstract member System.Reflection.IReflect.GetMember : string * System.Reflection.BindingFlags -&gt; System.Reflection.MemberInfo[]&#xA;override this.System.Reflection.IReflect.GetMember : string * System.Reflection.BindingFlags -&gt; System.Reflection.MemberInfo[]" Usage="accessibleObject.System.Reflection.IReflect.GetMember (name, bindingAttr)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Reflection.IReflect.GetMember(System.String,System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name">要查找的成员的名称。</param>
        <param name="bindingAttr">用于控制搜索的绑定属性。</param>
        <summary>获取 <see cref="T:System.Reflection.MemberInfo" /> 对象数组，这些对象对应于所有公共成员或与指定的名称匹配的所有成员。 有关此成员的说明，请参见 <see cref="M:System.Reflection.IReflect.GetMember(System.String,System.Reflection.BindingFlags)" />。</summary>
        <returns>与 name 参数匹配的 <see cref="T:System.Reflection.MemberInfo" /> 对象的数组。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此成员是显式接口成员的实现。 它只能在 <xref:System.Windows.Forms.AccessibleObject> 实例被强制转换为 <xref:System.Reflection.IReflect> 接口时使用。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Reflection.IReflect.GetMembers">
      <MemberSignature Language="C#" Value="System.Reflection.MemberInfo[] IReflect.GetMembers (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Reflection.MemberInfo[] System.Reflection.IReflect.GetMembers(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.AccessibleObject.System#Reflection#IReflect#GetMembers(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Function GetMembers (bindingAttr As BindingFlags) As MemberInfo() Implements IReflect.GetMembers" />
      <MemberSignature Language="C++ CLI" Value=" virtual cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ System.Reflection.IReflect.GetMembers(System::Reflection::BindingFlags bindingAttr) = System::Reflection::IReflect::GetMembers;" />
      <MemberSignature Language="F#" Value="abstract member System.Reflection.IReflect.GetMembers : System.Reflection.BindingFlags -&gt; System.Reflection.MemberInfo[]&#xA;override this.System.Reflection.IReflect.GetMembers : System.Reflection.BindingFlags -&gt; System.Reflection.MemberInfo[]" Usage="accessibleObject.System.Reflection.IReflect.GetMembers bindingAttr" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Reflection.IReflect.GetMembers(System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">用于控制搜索的绑定属性。</param>
        <summary>获取 <see cref="T:System.Reflection.MemberInfo" /> 对象数组，这些对象对应于所有公共成员或者当前类的所有成员。 有关此成员的说明，请参见 <see cref="M:System.Reflection.IReflect.GetMembers(System.Reflection.BindingFlags)" />。</summary>
        <returns>包含此反射对象的所有成员信息的 <see cref="T:System.Reflection.MemberInfo" /> 对象数组。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此成员是显式接口成员的实现。 它只能在 <xref:System.Windows.Forms.AccessibleObject> 实例被强制转换为 <xref:System.Reflection.IReflect> 接口时使用。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Reflection.IReflect.GetMethod">
      <MemberSignature Language="C#" Value="System.Reflection.MethodInfo IReflect.GetMethod (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Reflection.MethodInfo System.Reflection.IReflect.GetMethod(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.AccessibleObject.System#Reflection#IReflect#GetMethod(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Function GetMethod (name As String, bindingAttr As BindingFlags) As MethodInfo Implements IReflect.GetMethod" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Reflection::MethodInfo ^ System.Reflection.IReflect.GetMethod(System::String ^ name, System::Reflection::BindingFlags bindingAttr) = System::Reflection::IReflect::GetMethod;" />
      <MemberSignature Language="F#" Value="abstract member System.Reflection.IReflect.GetMethod : string * System.Reflection.BindingFlags -&gt; System.Reflection.MethodInfo&#xA;override this.System.Reflection.IReflect.GetMethod : string * System.Reflection.BindingFlags -&gt; System.Reflection.MethodInfo" Usage="accessibleObject.System.Reflection.IReflect.GetMethod (name, bindingAttr)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Reflection.IReflect.GetMethod(System.String,System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name">要查找的成员的名称。</param>
        <param name="bindingAttr">用于控制搜索的绑定属性。</param>
        <summary>在指定的搜索约束下获取与指定方法对应的 <see cref="T:System.Reflection.MethodInfo" /> 对象。 有关此成员的说明，请参见 <see cref="M:System.Reflection.IReflect.GetMethod(System.String,System.Reflection.BindingFlags)" />。</summary>
        <returns>包含方法信息的 <see cref="T:System.Reflection.MethodInfo" /> 对象，匹配基于方法名和 <paramref name="bindingAttr" /> 中指定的搜索约束。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此成员是显式接口成员的实现。 它只能在 <xref:System.Windows.Forms.AccessibleObject> 实例被强制转换为 <xref:System.Reflection.IReflect> 接口时使用。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">该对象实现同名的多个方法。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Reflection.IReflect.GetMethod">
      <MemberSignature Language="C#" Value="System.Reflection.MethodInfo IReflect.GetMethod (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Reflection.MethodInfo System.Reflection.IReflect.GetMethod(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.AccessibleObject.System#Reflection#IReflect#GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="VB.NET" Value="Function GetMethod (name As String, bindingAttr As BindingFlags, binder As Binder, types As Type(), modifiers As ParameterModifier()) As MethodInfo Implements IReflect.GetMethod" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Reflection::MethodInfo ^ System.Reflection.IReflect.GetMethod(System::String ^ name, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers) = System::Reflection::IReflect::GetMethod;" />
      <MemberSignature Language="F#" Value="abstract member System.Reflection.IReflect.GetMethod : string * System.Reflection.BindingFlags * System.Reflection.Binder * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo&#xA;override this.System.Reflection.IReflect.GetMethod : string * System.Reflection.BindingFlags * System.Reflection.Binder * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo" Usage="accessibleObject.System.Reflection.IReflect.GetMethod (name, bindingAttr, binder, types, modifiers)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Reflection.IReflect.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">要查找的成员的名称。</param>
        <param name="bindingAttr">用于控制搜索的绑定属性。</param>
        <param name="binder">一个实现 <see cref="T:System.Reflection.Binder" /> 的对象，包含与此方法相关的属性。</param>
        <param name="types">用于从重载方法中进行选择的数组。</param>
        <param name="modifiers">参数修饰符的数组，用于使绑定可与在其中修改了类型的参数签名一起使用。</param>
        <summary>获取与指定方法对应的 <see cref="T:System.Reflection.MethodInfo" /> 对象（使用类型数组从重载方法中进行选择）。 有关此成员的说明，请参见 <see cref="M:System.Reflection.IReflect.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])" />。</summary>
        <returns>匹配所有指定参数的请求的方法。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 返回值是一个匹配项，它基于方法名称、 <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> 枚举、参数指定的类型转换类型 `binder` 、重载以及 <xref:System.Reflection.ParameterInfo?displayProperty=nameWithType> 描述方法签名的。  
  
 此成员是显式接口成员的实现。 它只能在 <xref:System.Windows.Forms.AccessibleObject> 实例被强制转换为 <xref:System.Reflection.IReflect> 接口时使用。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">该对象实现同名的多个方法。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Reflection.IReflect.GetMethods">
      <MemberSignature Language="C#" Value="System.Reflection.MethodInfo[] IReflect.GetMethods (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Reflection.MethodInfo[] System.Reflection.IReflect.GetMethods(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.AccessibleObject.System#Reflection#IReflect#GetMethods(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Function GetMethods (bindingAttr As BindingFlags) As MethodInfo() Implements IReflect.GetMethods" />
      <MemberSignature Language="C++ CLI" Value=" virtual cli::array &lt;System::Reflection::MethodInfo ^&gt; ^ System.Reflection.IReflect.GetMethods(System::Reflection::BindingFlags bindingAttr) = System::Reflection::IReflect::GetMethods;" />
      <MemberSignature Language="F#" Value="abstract member System.Reflection.IReflect.GetMethods : System.Reflection.BindingFlags -&gt; System.Reflection.MethodInfo[]&#xA;override this.System.Reflection.IReflect.GetMethods : System.Reflection.BindingFlags -&gt; System.Reflection.MethodInfo[]" Usage="accessibleObject.System.Reflection.IReflect.GetMethods bindingAttr" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Reflection.IReflect.GetMethods(System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">用于控制搜索的绑定属性。</param>
        <summary>获取 <see cref="T:System.Reflection.MethodInfo" /> 对象的数组，其中包含了所有公共方法或当前类的所有方法。 有关此成员的说明，请参见 <see cref="M:System.Reflection.IReflect.GetMethods(System.Reflection.BindingFlags)" />。</summary>
        <returns><see cref="T:System.Reflection.MethodInfo" /> 对象的数组，包含为此反射对象定义的符合 <see langword="bindingAttr" /> 中指定的搜索约束的所有方法。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此成员是显式接口成员的实现。 它只能在 <xref:System.Windows.Forms.AccessibleObject> 实例被强制转换为 <xref:System.Reflection.IReflect> 接口时使用。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Reflection.IReflect.GetProperties">
      <MemberSignature Language="C#" Value="System.Reflection.PropertyInfo[] IReflect.GetProperties (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Reflection.PropertyInfo[] System.Reflection.IReflect.GetProperties(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.AccessibleObject.System#Reflection#IReflect#GetProperties(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Function GetProperties (bindingAttr As BindingFlags) As PropertyInfo() Implements IReflect.GetProperties" />
      <MemberSignature Language="C++ CLI" Value=" virtual cli::array &lt;System::Reflection::PropertyInfo ^&gt; ^ System.Reflection.IReflect.GetProperties(System::Reflection::BindingFlags bindingAttr) = System::Reflection::IReflect::GetProperties;" />
      <MemberSignature Language="F#" Value="abstract member System.Reflection.IReflect.GetProperties : System.Reflection.BindingFlags -&gt; System.Reflection.PropertyInfo[]&#xA;override this.System.Reflection.IReflect.GetProperties : System.Reflection.BindingFlags -&gt; System.Reflection.PropertyInfo[]" Usage="accessibleObject.System.Reflection.IReflect.GetProperties bindingAttr" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Reflection.IReflect.GetProperties(System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">用于控制搜索的绑定属性。</param>
        <summary>获取 <see cref="T:System.Reflection.PropertyInfo" /> 对象数组，这些对象对应于所有公共属性或当前类的所有属性。 有关此成员的说明，请参见 <see cref="M:System.Reflection.IReflect.GetProperties(System.Reflection.BindingFlags)" />。</summary>
        <returns>在反射对象上定义的所有属性的 <see cref="T:System.Reflection.PropertyInfo" /> 对象数组。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此成员是显式接口成员的实现。 它只能在 <xref:System.Windows.Forms.AccessibleObject> 实例被强制转换为 <xref:System.Reflection.IReflect> 接口时使用。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Reflection.IReflect.GetProperty">
      <MemberSignature Language="C#" Value="System.Reflection.PropertyInfo IReflect.GetProperty (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Reflection.PropertyInfo System.Reflection.IReflect.GetProperty(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.AccessibleObject.System#Reflection#IReflect#GetProperty(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Function GetProperty (name As String, bindingAttr As BindingFlags) As PropertyInfo Implements IReflect.GetProperty" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Reflection::PropertyInfo ^ System.Reflection.IReflect.GetProperty(System::String ^ name, System::Reflection::BindingFlags bindingAttr) = System::Reflection::IReflect::GetProperty;" />
      <MemberSignature Language="F#" Value="abstract member System.Reflection.IReflect.GetProperty : string * System.Reflection.BindingFlags -&gt; System.Reflection.PropertyInfo&#xA;override this.System.Reflection.IReflect.GetProperty : string * System.Reflection.BindingFlags -&gt; System.Reflection.PropertyInfo" Usage="accessibleObject.System.Reflection.IReflect.GetProperty (name, bindingAttr)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Reflection.IReflect.GetProperty(System.String,System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name">要查找的属性的名称。</param>
        <param name="bindingAttr">用于控制搜索的绑定属性。</param>
        <summary>在指定的搜索约束下获取与指定属性对应的 <see cref="T:System.Reflection.PropertyInfo" /> 对象。 有关此成员的说明，请参见 <see cref="M:System.Reflection.IReflect.GetProperty(System.String,System.Reflection.BindingFlags)" />。</summary>
        <returns>找到的与 <paramref name="bindingAttr" /> 中指定的搜索约束相符的属性的 <see cref="T:System.Reflection.PropertyInfo" /> 对象；如果没有找到此属性，则为 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此成员是显式接口成员的实现。 它只能在 <xref:System.Windows.Forms.AccessibleObject> 实例被强制转换为 <xref:System.Reflection.IReflect> 接口时使用。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">该对象实现同名的多个方法。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Reflection.IReflect.GetProperty">
      <MemberSignature Language="C#" Value="System.Reflection.PropertyInfo IReflect.GetProperty (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, Type returnType, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Reflection.PropertyInfo System.Reflection.IReflect.GetProperty(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, class System.Type returnType, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.AccessibleObject.System#Reflection#IReflect#GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="VB.NET" Value="Function GetProperty (name As String, bindingAttr As BindingFlags, binder As Binder, returnType As Type, types As Type(), modifiers As ParameterModifier()) As PropertyInfo Implements IReflect.GetProperty" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Reflection::PropertyInfo ^ System.Reflection.IReflect.GetProperty(System::String ^ name, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, Type ^ returnType, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers) = System::Reflection::IReflect::GetProperty;" />
      <MemberSignature Language="F#" Value="abstract member System.Reflection.IReflect.GetProperty : string * System.Reflection.BindingFlags * System.Reflection.Binder * Type * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.PropertyInfo&#xA;override this.System.Reflection.IReflect.GetProperty : string * System.Reflection.BindingFlags * System.Reflection.Binder * Type * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.PropertyInfo" Usage="accessibleObject.System.Reflection.IReflect.GetProperty (name, bindingAttr, binder, returnType, types, modifiers)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Reflection.IReflect.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">要查找的成员的名称。</param>
        <param name="bindingAttr">用于控制搜索的绑定属性。</param>
        <param name="binder">实现 Binder 的对象，它包含与此方法相关的属性。</param>
        <param name="returnType">用于从重载方法中进行选择的数组。</param>
        <param name="types">参数修饰符的数组，用于使绑定可与在其中修改了类型的参数签名一起使用。</param>
        <param name="modifiers">用于选择参数修饰符的数组。</param>
        <summary>在指定的搜索约束下获取与指定属性对应的 <see cref="T:System.Reflection.PropertyInfo" /> 对象。 有关此成员的说明，请参见 <see cref="M:System.Reflection.IReflect.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />。</summary>
        <returns>如果在此反射对象中找到了具有指定名称的属性，则为所找到的属性的 <see cref="T:System.Reflection.PropertyInfo" /> 对象；如果没有找到此属性，则为 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此成员是显式接口成员的实现。 它只能在 <xref:System.Windows.Forms.AccessibleObject> 实例被强制转换为 <xref:System.Reflection.IReflect> 接口时使用。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Reflection.IReflect.InvokeMember">
      <MemberSignature Language="C#" Value="object IReflect.InvokeMember (string name, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object target, object[] args, System.Reflection.ParameterModifier[] modifiers, System.Globalization.CultureInfo culture, string[] namedParameters);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance object System.Reflection.IReflect.InvokeMember(string name, valuetype System.Reflection.BindingFlags invokeAttr, class System.Reflection.Binder binder, object target, object[] args, valuetype System.Reflection.ParameterModifier[] modifiers, class System.Globalization.CultureInfo culture, string[] namedParameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.AccessibleObject.System#Reflection#IReflect#InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Function InvokeMember (name As String, invokeAttr As BindingFlags, binder As Binder, target As Object, args As Object(), modifiers As ParameterModifier(), culture As CultureInfo, namedParameters As String()) As Object Implements IReflect.InvokeMember" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Object ^ System.Reflection.IReflect.InvokeMember(System::String ^ name, System::Reflection::BindingFlags invokeAttr, System::Reflection::Binder ^ binder, System::Object ^ target, cli::array &lt;System::Object ^&gt; ^ args, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::String ^&gt; ^ namedParameters) = System::Reflection::IReflect::InvokeMember;" />
      <MemberSignature Language="F#" Value="abstract member System.Reflection.IReflect.InvokeMember : string * System.Reflection.BindingFlags * System.Reflection.Binder * obj * obj[] * System.Reflection.ParameterModifier[] * System.Globalization.CultureInfo * string[] -&gt; obj&#xA;override this.System.Reflection.IReflect.InvokeMember : string * System.Reflection.BindingFlags * System.Reflection.Binder * obj * obj[] * System.Reflection.ParameterModifier[] * System.Globalization.CultureInfo * string[] -&gt; obj" Usage="accessibleObject.System.Reflection.IReflect.InvokeMember (name, invokeAttr, binder, target, args, modifiers, culture, namedParameters)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Reflection.IReflect.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="invokeAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="target" Type="System.Object" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="namedParameters" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="name">要查找的成员的名称。</param>
        <param name="invokeAttr"><see cref="T:System.Reflection.BindingFlags" /> 调用特性之一。</param>
        <param name="binder"><see cref="T:System.Reflection.BindingFlags" /> 位标志之一。 实现 Binder，它包含与此方法相关的属性。</param>
        <param name="target">对其调用指定成员的对象。 对于静态成员，此参数被忽略。</param>
        <param name="args">包含要调用的成员的参数数目、顺序和类型的对象数组。 如果没有参数，则这是一个空数组。</param>
        <param name="modifiers">一个 <see cref="T:System.Reflection.ParameterModifier" /> 对象数组。</param>
        <param name="culture">用于控制类型强制的 <see cref="T:System.Globalization.CultureInfo" /> 的实例。</param>
        <param name="namedParameters">参数的字符串数组。</param>
        <summary>调用指定的成员。 有关此成员的说明，请参见 <see cref="M:System.Reflection.IReflect.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />。</summary>
        <returns>指定的成员。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `invokeAttr` 参数可以是构造函数、方法、属性或字段。 必须指定合适的调用属性。 通过将空字符串 ("") 作为成员的名称传递来调用类的默认成员。  
  
 `modifiers`参数与参数的长度相同，后者 `args` 表示元数据中被调用成员的参数特性。 参数可以具有以下属性： pdIn、pdOut、pdRetval、pdOptional 和 pdHasDefault。 这些属性分别表示 [In]、[Out]、[retval]、[optional] 和默认参数。  
  
 此成员是显式接口成员的实现。 它只能在 <xref:System.Windows.Forms.AccessibleObject> 实例被强制转换为 <xref:System.Reflection.IReflect> 接口时使用。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="invokeAttr" /> 是 <see cref="F:System.Reflection.BindingFlags.CreateInstance" /> 并且还设置了另一个位标志。

-或- <paramref name="invokeAttr" /> 不是 <see cref="F:System.Reflection.BindingFlags.CreateInstance" />，且 name 为 <see langword="null" />。

- 或 -

<paramref name="invokeAttr" /> 不是来自 <see cref="T:System.Reflection.BindingFlags" /> 的调用属性。

- 或 -

<paramref name="invokeAttr" /> 为属性或字段同时指定 get 和 set。

- 或 -

<paramref name="invokeAttr" /> 同时指定字段集和 Invoke 方法。提供 <paramref name="args" /> 用于字段 get 操作。

- 或 -

为字段 set 操作指定了多个参数。</exception>
        <exception cref="T:System.MissingFieldException">找不到此字段或属性。</exception>
        <exception cref="T:System.MissingMethodException">找不到此方法。</exception>
        <exception cref="T:System.Security.SecurityException">在没有所需 <see cref="T:System.Security.Permissions.ReflectionPermission" /> 的情况下调用私有成员。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Reflection.IReflect.UnderlyingSystemType">
      <MemberSignature Language="C#" Value="Type System.Reflection.IReflect.UnderlyingSystemType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type System.Reflection.IReflect.UnderlyingSystemType" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.AccessibleObject.System#Reflection#IReflect#UnderlyingSystemType" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property UnderlyingSystemType As Type Implements IReflect.UnderlyingSystemType" />
      <MemberSignature Language="C++ CLI" Value="property Type ^ System::Reflection::IReflect::UnderlyingSystemType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.System.Reflection.IReflect.UnderlyingSystemType : Type" Usage="System.Reflection.IReflect.UnderlyingSystemType" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Reflection.IReflect.UnderlyingSystemType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取表示 <see cref="T:System.Reflection.IReflect" /> 对象的基础类型。 有关此成员的说明，请参见 <see cref="P:System.Reflection.IReflect.UnderlyingSystemType" />。</summary>
        <value>表示 <see cref="T:System.Reflection.IReflect" /> 对象的基础类型。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此成员是显式接口成员的实现。 它只能在 <xref:System.Windows.Forms.AccessibleObject> 实例被强制转换为 <xref:System.Reflection.IReflect> 接口时使用。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="UseStdAccessibleObjects">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>将对象与 <see cref="T:System.Windows.Forms.AccessibleObject" /> 的一个实例关联起来。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="UseStdAccessibleObjects">
      <MemberSignature Language="C#" Value="protected void UseStdAccessibleObjects (IntPtr handle);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void UseStdAccessibleObjects(native int handle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.AccessibleObject.UseStdAccessibleObjects(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub UseStdAccessibleObjects (handle As IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void UseStdAccessibleObjects(IntPtr handle);" />
      <MemberSignature Language="F#" Value="member this.UseStdAccessibleObjects : nativeint -&gt; unit" Usage="accessibleObject.UseStdAccessibleObjects handle" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="handle" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="handle"><see cref="T:System.IntPtr" />，它包含对象的句柄。</param>
        <summary>根据对象的句柄，将一个对象与 <see cref="T:System.Windows.Forms.AccessibleObject" /> 的一个实例关联起来。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 服务器应用程序在包含类似于系统提供的对象的自定义 UI 对象时，可以调用此函数。 服务器应用程序 `CreateStdAccessibleObject` 根据需要调用并重写 <xref:Accessibility.IAccessible> 方法和属性以匹配其自定义对象。 此方法将服务器开发人员保存为完全实现所有 <xref:Accessibility.IAccessible> 属性和方法的工作。 此函数与类似 `CreateStdAccessibleProxy` ，不同之处在于 `CreateStdAccessibleProxy` 允许您将类名称指定为参数，而 `CreateStdAccessibleObject` 使用与关联的类名称 `hwnd` 。  
  
 调用此版本的与 `UseStdAccessible` 调用 objid 的客户端的两个参数版本相同。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UseStdAccessibleObjects">
      <MemberSignature Language="C#" Value="protected void UseStdAccessibleObjects (IntPtr handle, int objid);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void UseStdAccessibleObjects(native int handle, int32 objid) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.AccessibleObject.UseStdAccessibleObjects(System.IntPtr,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub UseStdAccessibleObjects (handle As IntPtr, objid As Integer)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void UseStdAccessibleObjects(IntPtr handle, int objid);" />
      <MemberSignature Language="F#" Value="member this.UseStdAccessibleObjects : nativeint * int -&gt; unit" Usage="accessibleObject.UseStdAccessibleObjects (handle, objid)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="handle" Type="System.IntPtr" />
        <Parameter Name="objid" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="handle"><see cref="T:System.IntPtr" />，它包含对象的句柄。</param>
        <param name="objid">一个整数，它定义 <paramref name="handle" /> 参数引用的对象的类型。</param>
        <summary>根据对象的句柄和对象 ID，将一个对象与 <see cref="T:System.Windows.Forms.AccessibleObject" /> 的一个实例关联起来。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用系统提供的用户界面元素的指定类型的方法和属性创建一个辅助性对象。  
  
 服务器应用程序在包含类似于系统提供的对象的自定义 UI 对象时，可以调用此函数。 服务器应用程序 `CreateStdAccessibleObject` 根据需要调用并重写 <xref:Accessibility.IAccessible> 方法和属性以匹配其自定义对象。 此方法将服务器开发人员保存为完全实现所有 <xref:Accessibility.IAccessible> 属性和方法的工作。  
  
 有效值 `objid` 。  
  
|对象|Value|说明|  
|------------|-----------|-----------------|  
|ALERT|0xFFFFFFF6|引用与窗口或应用程序关联的消息。|  
|字|0xFFFFFFF8|引用窗口中 (插入符号) 的文本插入条。|  
|客户端|0xFFFFFFFC|引用窗口的工作区。 在大多数情况下，操作系统会控制框架元素，而客户端对象则包含应用程序控制的所有元素。|  
|CURSOR|0xFFFFFFF7|指鼠标指针。 系统中只有一个鼠标指针，并且它不是窗口的子级。|  
|HSCROLL|0xFFFFFFFA|引用窗口的水平滚动条。|  
|MENU|0xFFFFFFFD|引用窗口的菜单栏。|  
|SIZEGRIP|0xFFFFFFF9|指窗口的大小手柄，它是位于窗口框架右下角的一个可选框架组件。|  
|段|0xFFFFFFF5|引用 sound 对象。 Sound 对象没有屏幕位置或子对象，但具有名称和状态属性。 它们是播放声音的应用程序的子项。|  
|SYSMENU|0xFFFFFFFF|引用窗口的系统菜单。|  
|标题栏|0xFFFFFFFE|引用窗口的标题栏。|  
|VSCROLL|0xFFFFFFFB|引用窗口的垂直滚动条。|  
|WINDOW|0x00000000|指的是窗口本身而不是子对象。|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Value">
      <MemberSignature Language="C#" Value="public virtual string Value { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Value" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.AccessibleObject.Value" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property Value As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Value { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Value : string with get, set" Usage="System.Windows.Forms.AccessibleObject.Value" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置辅助性对象的值。</summary>
        <value>可访问对象的值，或如果该对象未设值，则为 <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 通常， <xref:System.Windows.Forms.AccessibleObject.Value%2A> 属性表示对象包含的视觉信息。 并非所有对象都支持 <xref:System.Windows.Forms.AccessibleObject.Value%2A> 属性。  
  
 在大多数情况下， <xref:System.Windows.Forms.AccessibleObject.Value%2A> 属性用于告诉客户端对象所包含的视觉对象信息。 例如，编辑控件的值是它包含的文本，但菜单项没有值。  
  
 <xref:System.Windows.Forms.AccessibleObject.Value%2A>属性可在诸如树视图控件等情况下提供分层信息。 尽管树视图控件中的父对象不提供属性中的信息 <xref:System.Windows.Forms.AccessibleObject.Value%2A> ，但控件中的每一项都有一个从零开始的值，它表示其在层次结构中的级别。 顶级项的值为零，第二级项的值为1，依此类推。  
  
> [!NOTE]
>  从滚动条和跟踪条可访问对象返回的值指示百分比，因此它们是0到100（含）之间的整数。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Runtime.InteropServices.COMException">无法设置或检索值。</exception>
        <altmember cref="P:System.Windows.Forms.AccessibleObject.Bounds" />
        <altmember cref="P:System.Windows.Forms.AccessibleObject.DefaultAction" />
        <altmember cref="P:System.Windows.Forms.AccessibleObject.Description" />
        <altmember cref="P:System.Windows.Forms.AccessibleObject.Help" />
        <altmember cref="P:System.Windows.Forms.AccessibleObject.KeyboardShortcut" />
        <altmember cref="P:System.Windows.Forms.AccessibleObject.Name" />
        <altmember cref="P:System.Windows.Forms.AccessibleObject.Parent" />
        <altmember cref="P:System.Windows.Forms.AccessibleObject.Role" />
        <altmember cref="P:System.Windows.Forms.AccessibleObject.State" />
      </Docs>
    </Member>
  </Members>
</Type>
