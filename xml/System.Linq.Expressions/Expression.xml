<Type Name="Expression" FullName="System.Linq.Expressions.Expression">
  <Metadata><Meta Name="ms.openlocfilehash" Value="25dd46f7add80a41b61c50f202b96d1353303725" /><Meta Name="ms.sourcegitcommit" Value="8ae9a18b248625c8e1851e607c00346a64849587" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-CN" /><Meta Name="ms.lasthandoff" Value="12/17/2019" /><Meta Name="ms.locfileid" Value="75131368" /></Metadata><TypeSignature Language="C#" Value="public abstract class Expression" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit Expression extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Linq.Expressions.Expression" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Expression" />
  <TypeSignature Language="C++ CLI" Value="public ref class Expression abstract" />
  <TypeSignature Language="F#" Value="type Expression = class" />
  <AssemblyInfo>
    <AssemblyName>System.Linq.Expressions</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
    <AssemblyVersion>4.2.2.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Core</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>3.5.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary><span data-ttu-id="7593b-101">提供一种基类，表示表达式树节点的类派生自该基类。</span><span class="sxs-lookup"><span data-stu-id="7593b-101">Provides the base class from which the classes that represent expression tree nodes are derived.</span></span> <span data-ttu-id="7593b-102">它还包含用来创建各种节点类型的 <see langword="static" />（在 Visual Basic 中为 <see langword="Shared" />）工厂方法。</span><span class="sxs-lookup"><span data-stu-id="7593b-102">It also contains <see langword="static" /> (<see langword="Shared" /> in Visual Basic) factory methods to create the various node types.</span></span> <span data-ttu-id="7593b-103">这是一个 <see langword="abstract" /> 类。</span><span class="sxs-lookup"><span data-stu-id="7593b-103">This is an <see langword="abstract" /> class.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="7593b-104">下面的代码示例演示如何创建块表达式。</span><span class="sxs-lookup"><span data-stu-id="7593b-104">The following code example shows how to create a block expression.</span></span> <span data-ttu-id="7593b-105">块表达式包含两个 <xref:System.Linq.Expressions.MethodCallExpression> 对象和一个 <xref:System.Linq.Expressions.ConstantExpression> 对象。</span><span class="sxs-lookup"><span data-stu-id="7593b-105">The block expression consists of two <xref:System.Linq.Expressions.MethodCallExpression> objects and one <xref:System.Linq.Expressions.ConstantExpression> object.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#13)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#13)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="7593b-106">构造 <see cref="T:System.Linq.Expressions.Expression" /> 的新实例。</span><span class="sxs-lookup"><span data-stu-id="7593b-106">Constructs a new instance of <see cref="T:System.Linq.Expressions.Expression" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Expression ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Expression();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="7593b-107">构造 <see cref="T:System.Linq.Expressions.Expression" /> 的新实例。</span><span class="sxs-lookup"><span data-stu-id="7593b-107">Constructs a new instance of <see cref="T:System.Linq.Expressions.Expression" />.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Expression (System.Linq.Expressions.ExpressionType nodeType, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(valuetype System.Linq.Expressions.ExpressionType nodeType, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.#ctor(System.Linq.Expressions.ExpressionType,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Expression(System::Linq::Expressions::ExpressionType nodeType, Type ^ type);" />
      <MemberSignature Language="F#" Value="new System.Linq.Expressions.Expression : System.Linq.Expressions.ExpressionType * Type -&gt; System.Linq.Expressions.Expression" Usage="new System.Linq.Expressions.Expression (nodeType, type)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1">
          <AttributeName>System.Obsolete("use a different constructor that does not take ExpressionType. Then override NodeType and Type properties to provide the values that would be specified to this constructor.")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="nodeType" Type="System.Linq.Expressions.ExpressionType" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="type" Type="System.Type" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="nodeType"><span data-ttu-id="7593b-108"><see cref="T:System.Linq.Expressions.ExpressionType" /> 设置为节点类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-108">The <see cref="T:System.Linq.Expressions.ExpressionType" /> to set as the node type.</span></span></param>
        <param name="type"><span data-ttu-id="7593b-109">此 <see cref="P:System.Linq.Expressions.Expression.Type" /> 的 <see cref="T:System.Linq.Expressions.Expression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-109">The <see cref="P:System.Linq.Expressions.Expression.Type" /> of this <see cref="T:System.Linq.Expressions.Expression" />.</span></span></param>
        <summary><span data-ttu-id="7593b-110">初始化 <see cref="T:System.Linq.Expressions.Expression" /> 类的新实例。</span><span class="sxs-lookup"><span data-stu-id="7593b-110">Initializes a new instance of the <see cref="T:System.Linq.Expressions.Expression" /> class.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7593b-111">从派生类中的构造函数调用此构造函数。</span><span class="sxs-lookup"><span data-stu-id="7593b-111">This constructor is called from constructors in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Accept">
      <MemberSignature Language="C#" Value="protected internal virtual System.Linq.Expressions.Expression Accept (System.Linq.Expressions.ExpressionVisitor visitor);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance class System.Linq.Expressions.Expression Accept(class System.Linq.Expressions.ExpressionVisitor visitor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Accept(System.Linq.Expressions.ExpressionVisitor)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Function Accept (visitor As ExpressionVisitor) As Expression" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual System::Linq::Expressions::Expression ^ Accept(System::Linq::Expressions::ExpressionVisitor ^ visitor);" />
      <MemberSignature Language="F#" Value="abstract member Accept : System.Linq.Expressions.ExpressionVisitor -&gt; System.Linq.Expressions.Expression&#xA;override this.Accept : System.Linq.Expressions.ExpressionVisitor -&gt; System.Linq.Expressions.Expression" Usage="expression.Accept visitor" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.Expression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="visitor" Type="System.Linq.Expressions.ExpressionVisitor" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="visitor"><span data-ttu-id="7593b-112">对此节点进行访问的访问者。</span><span class="sxs-lookup"><span data-stu-id="7593b-112">The visitor to visit this node with.</span></span></param>
        <summary><span data-ttu-id="7593b-113">调度到此节点类型的特定 Visit 方法。</span><span class="sxs-lookup"><span data-stu-id="7593b-113">Dispatches to the specific visit method for this node type.</span></span> <span data-ttu-id="7593b-114">例如，<see cref="T:System.Linq.Expressions.MethodCallExpression" /> 调用 <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-114">For example, <see cref="T:System.Linq.Expressions.MethodCallExpression" /> calls the <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" />.</span></span></summary>
        <returns><span data-ttu-id="7593b-115">对此节点访问的结果。</span><span class="sxs-lookup"><span data-stu-id="7593b-115">The result of visiting this node.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7593b-116"><xref:System.Linq.Expressions.ExpressionType.Extension> 节点的此默认实现将调用 <xref:System.Linq.Expressions.ExpressionVisitor.VisitExtension%2A>。</span><span class="sxs-lookup"><span data-stu-id="7593b-116">This default implementation for <xref:System.Linq.Expressions.ExpressionType.Extension> nodes calls <xref:System.Linq.Expressions.ExpressionVisitor.VisitExtension%2A>.</span></span> <span data-ttu-id="7593b-117">重写此方法以调入 <xref:System.Linq.Expressions.ExpressionVisitor> 类的派生访问者类的更具体的方法。</span><span class="sxs-lookup"><span data-stu-id="7593b-117">Override this method to call into a more specific method on a derived visitor class of the <xref:System.Linq.Expressions.ExpressionVisitor> class.</span></span> <span data-ttu-id="7593b-118">但是，它仍然应该通过调用 <xref:System.Linq.Expressions.ExpressionVisitor.VisitExtension%2A>来支持未知的访问者。</span><span class="sxs-lookup"><span data-stu-id="7593b-118">However, it should still support unknown visitors by calling <xref:System.Linq.Expressions.ExpressionVisitor.VisitExtension%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Add">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="7593b-119">创建一个表示不进行溢出检查的算术加法运算的 <see cref="T:System.Linq.Expressions.BinaryExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-119">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an arithmetic addition operation that does not have overflow checking.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Add (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Add(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Add(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Add (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Add(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member Add : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.Add (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="7593b-120">要将 <see cref="T:System.Linq.Expressions.Expression" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-120">A <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="7593b-121">要将 <see cref="T:System.Linq.Expressions.Expression" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-121">A <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="7593b-122">创建一个表示不进行溢出检查的算术加法运算的 <see cref="T:System.Linq.Expressions.BinaryExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-122">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an arithmetic addition operation that does not have overflow checking.</span></span></summary>
        <returns><span data-ttu-id="7593b-123">一个 <see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 属性等于 <see cref="F:System.Linq.Expressions.ExpressionType.Add" />，并且其 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 属性设置为指定值。</span><span class="sxs-lookup"><span data-stu-id="7593b-123">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Add" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7593b-124">生成的 <xref:System.Linq.Expressions.BinaryExpression> 具有设置为实现方法的 <xref:System.Linq.Expressions.BinaryExpression.Method%2A> 属性。</span><span class="sxs-lookup"><span data-stu-id="7593b-124">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="7593b-125"><xref:System.Linq.Expressions.Expression.Type%2A> 属性设置为节点的类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-125">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="7593b-126">如果节点已提升，则 <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> 和 <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> 属性均 `true`。</span><span class="sxs-lookup"><span data-stu-id="7593b-126">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="7593b-127">否则，它们 `false`。</span><span class="sxs-lookup"><span data-stu-id="7593b-127">Otherwise, they are `false`.</span></span> <span data-ttu-id="7593b-128"><xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> 属性为 `null`。</span><span class="sxs-lookup"><span data-stu-id="7593b-128">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="7593b-129">以下信息描述了实现方法、节点类型以及节点是否已提升。</span><span class="sxs-lookup"><span data-stu-id="7593b-129">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="7593b-130">实现方法</span><span class="sxs-lookup"><span data-stu-id="7593b-130">Implementing Method</span></span>  
 <span data-ttu-id="7593b-131">以下规则确定为操作选定的实现方法：</span><span class="sxs-lookup"><span data-stu-id="7593b-131">The following rules determine the selected implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="7593b-132">如果 `left` 或 `right` 的 <xref:System.Linq.Expressions.Expression.Type%2A> 属性表示重载加法运算符的用户定义类型，则表示该方法的 <xref:System.Reflection.MethodInfo> 是实现方法。</span><span class="sxs-lookup"><span data-stu-id="7593b-132">If the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the addition operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="7593b-133">否则，如果 `left`。键入并 `right`。类型为数值类型，则实现方法为 `null`。</span><span class="sxs-lookup"><span data-stu-id="7593b-133">Otherwise, if `left`.Type and `right`.Type are numeric types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="7593b-134">节点类型和提升和非提升</span><span class="sxs-lookup"><span data-stu-id="7593b-134">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="7593b-135">如果不 `null`实现方法：</span><span class="sxs-lookup"><span data-stu-id="7593b-135">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="7593b-136">如果 `left`。键入并 `right`。类型可分配给实现方法的相应参数类型，不提升节点。</span><span class="sxs-lookup"><span data-stu-id="7593b-136">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="7593b-137">节点的类型是实现方法的返回类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-137">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="7593b-138">如果满足以下两个条件，则会提升节点，并且该节点的类型为与实现方法的返回类型对应的可以为 null 的类型：</span><span class="sxs-lookup"><span data-stu-id="7593b-138">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="7593b-139">`left`。键入并 `right`。类型既是值类型，其中至少有一个可为 null，并且相应的不可为 null 的类型等于实现方法的相应参数类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-139">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="7593b-140">实现方法的返回类型是不可为 null 的值类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-140">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="7593b-141">如果实现方法为 `null`：</span><span class="sxs-lookup"><span data-stu-id="7593b-141">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="7593b-142">如果 `left`。键入并 `right`。类型不可以为 null，则不提升节点。</span><span class="sxs-lookup"><span data-stu-id="7593b-142">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="7593b-143">节点的类型是预定义的加法运算符的结果类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-143">The type of the node is the result type of the predefined addition operator.</span></span>  
  
-   <span data-ttu-id="7593b-144">如果 `left`。键入并 `right`。类型均可为 null，则提升节点。</span><span class="sxs-lookup"><span data-stu-id="7593b-144">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="7593b-145">节点的类型是与预定义的加法运算符的结果类型对应的可以为 null 的类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-145">The type of the node is the nullable type that corresponds to the result type of the predefined addition operator.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="7593b-146">下面的代码示例演示如何创建一个表达式来添加两个整数。</span><span class="sxs-lookup"><span data-stu-id="7593b-146">The following code example shows how to create an expression that adds two integers.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#1)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="7593b-147"><paramref name="left" /> 或 <paramref name="right" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-147"><paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="7593b-148">没有为 <paramref name="left" />.Type 和 <paramref name="right" />.Type 定义加法运算符。</span><span class="sxs-lookup"><span data-stu-id="7593b-148">The addition operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Add (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Add(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Add(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Add (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Add(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member Add : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.Add (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="7593b-149">要将 <see cref="T:System.Linq.Expressions.Expression" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-149">A <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="7593b-150">要将 <see cref="T:System.Linq.Expressions.Expression" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-150">A <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <param name="method"><span data-ttu-id="7593b-151">要将 <see cref="T:System.Reflection.MethodInfo" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-151">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="7593b-152">创建一个表示不进行溢出检查的算术加法运算的 <see cref="T:System.Linq.Expressions.BinaryExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-152">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an arithmetic addition operation that does not have overflow checking.</span></span> <span data-ttu-id="7593b-153">可指定实现方法。</span><span class="sxs-lookup"><span data-stu-id="7593b-153">The implementing method can be specified.</span></span></summary>
        <returns><span data-ttu-id="7593b-154">一个 <see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 属性等于 <see cref="F:System.Linq.Expressions.ExpressionType.Add" />，并且其 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />、<see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> 属性设置为指定值。</span><span class="sxs-lookup"><span data-stu-id="7593b-154">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Add" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7593b-155">生成的 <xref:System.Linq.Expressions.BinaryExpression> 具有设置为实现方法的 <xref:System.Linq.Expressions.BinaryExpression.Method%2A> 属性。</span><span class="sxs-lookup"><span data-stu-id="7593b-155">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="7593b-156"><xref:System.Linq.Expressions.Expression.Type%2A> 属性设置为节点的类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-156">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="7593b-157">如果节点已提升，则 <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> 和 <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> 属性均 `true`。</span><span class="sxs-lookup"><span data-stu-id="7593b-157">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="7593b-158">否则，它们 `false`。</span><span class="sxs-lookup"><span data-stu-id="7593b-158">Otherwise, they are `false`.</span></span> <span data-ttu-id="7593b-159"><xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> 属性为 `null`。</span><span class="sxs-lookup"><span data-stu-id="7593b-159">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="7593b-160">以下信息描述了实现方法、节点类型以及节点是否已提升。</span><span class="sxs-lookup"><span data-stu-id="7593b-160">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="7593b-161">实现方法</span><span class="sxs-lookup"><span data-stu-id="7593b-161">Implementing Method</span></span>  
 <span data-ttu-id="7593b-162">以下规则确定操作的实现方法：</span><span class="sxs-lookup"><span data-stu-id="7593b-162">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="7593b-163">如果 `method` 未 `null` 并且它表示采用两个自变量的非 void、`static``Shared` （Visual Basic）方法，则它是节点的实现方法。</span><span class="sxs-lookup"><span data-stu-id="7593b-163">If `method` is not `null` and it represents a non-void, `static` (`Shared` in Visual Basic) method that takes two arguments, it is the implementing method for the node.</span></span>  
  
-   <span data-ttu-id="7593b-164">否则，如果 `left` 或 `right` 的 <xref:System.Linq.Expressions.Expression.Type%2A> 属性表示重载加法运算符的用户定义类型，则表示该方法的 <xref:System.Reflection.MethodInfo> 是实现方法。</span><span class="sxs-lookup"><span data-stu-id="7593b-164">Otherwise, if the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the addition operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="7593b-165">否则，如果 `left`。键入并 `right`。类型为数值类型，则实现方法为 `null`。</span><span class="sxs-lookup"><span data-stu-id="7593b-165">Otherwise, if `left`.Type and `right`.Type are numeric types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="7593b-166">节点类型和提升和非提升</span><span class="sxs-lookup"><span data-stu-id="7593b-166">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="7593b-167">如果不 `null`实现方法：</span><span class="sxs-lookup"><span data-stu-id="7593b-167">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="7593b-168">如果 `left`。键入并 `right`。类型可分配给实现方法的相应参数类型，不提升节点。</span><span class="sxs-lookup"><span data-stu-id="7593b-168">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="7593b-169">节点的类型是实现方法的返回类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-169">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="7593b-170">如果满足以下两个条件，则会提升节点，并且该节点的类型为与实现方法的返回类型对应的可以为 null 的类型：</span><span class="sxs-lookup"><span data-stu-id="7593b-170">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="7593b-171">`left`。键入并 `right`。类型既是值类型，其中至少有一个可为 null，并且相应的不可为 null 的类型等于实现方法的相应参数类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-171">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="7593b-172">实现方法的返回类型是不可为 null 的值类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-172">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="7593b-173">如果实现方法为 `null`：</span><span class="sxs-lookup"><span data-stu-id="7593b-173">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="7593b-174">如果 `left`。键入并 `right`。类型不可以为 null，则不提升节点。</span><span class="sxs-lookup"><span data-stu-id="7593b-174">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="7593b-175">节点的类型是预定义的加法运算符的结果类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-175">The type of the node is the result type of the predefined addition operator.</span></span>  
  
-   <span data-ttu-id="7593b-176">如果 `left`。键入并 `right`。类型均可为 null，则提升节点。</span><span class="sxs-lookup"><span data-stu-id="7593b-176">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="7593b-177">节点的类型是与预定义的加法运算符的结果类型对应的可以为 null 的类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-177">The type of the node is the nullable type that corresponds to the result type of the predefined addition operator.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="7593b-178"><paramref name="left" /> 或 <paramref name="right" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-178"><paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="7593b-179"><paramref name="method" /> 不是 <see langword="null" />，它所表示的方法返回 <see langword="void" />，而不是 <see langword="static" />（Visual Basic 中为 <see langword="Shared" />），或者并非采用两个参数。</span><span class="sxs-lookup"><span data-stu-id="7593b-179"><paramref name="method" /> is not <see langword="null" /> and the method it represents returns <see langword="void" />, is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic), or does not take exactly two arguments.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="7593b-180"><paramref name="method" /> 是 <see langword="null" />，且没有为 <paramref name="left" />.Type 和 <paramref name="right" />.Type 定义加法运算符。</span><span class="sxs-lookup"><span data-stu-id="7593b-180"><paramref name="method" /> is <see langword="null" /> and the addition operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="AddAssign">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="7593b-181">创建一个表示不进行溢出检查的加法赋值运算的 <see cref="T:System.Linq.Expressions.BinaryExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-181">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an addition assignment operation that does not have overflow checking.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression AddAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression AddAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.AddAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AddAssign (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ AddAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member AddAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.AddAssign (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="7593b-182">要将 <see cref="T:System.Linq.Expressions.Expression" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-182">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="7593b-183">要将 <see cref="T:System.Linq.Expressions.Expression" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-183">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="7593b-184">创建一个表示不进行溢出检查的加法赋值运算的 <see cref="T:System.Linq.Expressions.BinaryExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-184">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an addition assignment operation that does not have overflow checking.</span></span></summary>
        <returns><span data-ttu-id="7593b-185">一个 <see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 属性等于 <see cref="F:System.Linq.Expressions.ExpressionType.AddAssign" />，并且其 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 属性设置为指定值。</span><span class="sxs-lookup"><span data-stu-id="7593b-185">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.AddAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="7593b-186">下面的代码示例演示如何创建一个表达式，该表达式将一个值添加到整数变量中，然后将该操作的结果赋给该变量。</span><span class="sxs-lookup"><span data-stu-id="7593b-186">The following code example shows how to create an expression that adds a value to an integer variable and then assigns the result of the operation to the variable.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#18](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#18)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#18)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression AddAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression AddAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.AddAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AddAssign (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ AddAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member AddAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.AddAssign (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="7593b-187">要将 <see cref="T:System.Linq.Expressions.Expression" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-187">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="7593b-188">要将 <see cref="T:System.Linq.Expressions.Expression" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-188">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <param name="method"><span data-ttu-id="7593b-189">要将 <see cref="T:System.Reflection.MethodInfo" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-189">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="7593b-190">创建一个表示不进行溢出检查的加法赋值运算的 <see cref="T:System.Linq.Expressions.BinaryExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-190">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an addition assignment operation that does not have overflow checking.</span></span></summary>
        <returns><span data-ttu-id="7593b-191">一个 <see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 属性等于 <see cref="F:System.Linq.Expressions.ExpressionType.AddAssign" />，并且其 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />、<see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> 属性设置为指定值。</span><span class="sxs-lookup"><span data-stu-id="7593b-191">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.AddAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression AddAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method, System.Linq.Expressions.LambdaExpression conversion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression AddAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method, class System.Linq.Expressions.LambdaExpression conversion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.AddAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AddAssign (left As Expression, right As Expression, method As MethodInfo, conversion As LambdaExpression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ AddAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method, System::Linq::Expressions::LambdaExpression ^ conversion);" />
      <MemberSignature Language="F#" Value="static member AddAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo * System.Linq.Expressions.LambdaExpression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.AddAssign (left, right, method, conversion)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="conversion" Type="System.Linq.Expressions.LambdaExpression" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="7593b-192">要将 <see cref="T:System.Linq.Expressions.Expression" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-192">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="7593b-193">要将 <see cref="T:System.Linq.Expressions.Expression" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-193">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <param name="method"><span data-ttu-id="7593b-194">要将 <see cref="T:System.Reflection.MethodInfo" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-194">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span></span></param>
        <param name="conversion"><span data-ttu-id="7593b-195">要将 <see cref="T:System.Linq.Expressions.LambdaExpression" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-195">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="7593b-196">创建一个表示不进行溢出检查的加法赋值运算的 <see cref="T:System.Linq.Expressions.BinaryExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-196">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an addition assignment operation that does not have overflow checking.</span></span></summary>
        <returns><span data-ttu-id="7593b-197">一个 <see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 属性等于 <see cref="F:System.Linq.Expressions.ExpressionType.AddAssign" />，并且其 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />、<see cref="P:System.Linq.Expressions.BinaryExpression.Right" />、<see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> 属性设置为指定值。</span><span class="sxs-lookup"><span data-stu-id="7593b-197">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.AddAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AddAssignChecked">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="7593b-198">创建一个表示进行溢出检查的加法赋值运算的 <see cref="T:System.Linq.Expressions.BinaryExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-198">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an addition assignment operation that has overflow checking.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddAssignChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression AddAssignChecked (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression AddAssignChecked(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.AddAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AddAssignChecked (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ AddAssignChecked(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member AddAssignChecked : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.AddAssignChecked (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="7593b-199">要将 <see cref="T:System.Linq.Expressions.Expression" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-199">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="7593b-200">要将 <see cref="T:System.Linq.Expressions.Expression" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-200">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="7593b-201">创建一个表示进行溢出检查的加法赋值运算的 <see cref="T:System.Linq.Expressions.BinaryExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-201">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an addition assignment operation that has overflow checking.</span></span></summary>
        <returns><span data-ttu-id="7593b-202">一个 <see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 属性等于 <see cref="F:System.Linq.Expressions.ExpressionType.AddAssignChecked" />，并且其 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 属性设置为指定值。</span><span class="sxs-lookup"><span data-stu-id="7593b-202">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.AddAssignChecked" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddAssignChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression AddAssignChecked (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression AddAssignChecked(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.AddAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AddAssignChecked (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ AddAssignChecked(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member AddAssignChecked : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.AddAssignChecked (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="7593b-203">要将 <see cref="T:System.Linq.Expressions.Expression" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-203">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="7593b-204">要将 <see cref="T:System.Linq.Expressions.Expression" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-204">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <param name="method"><span data-ttu-id="7593b-205">要将 <see cref="T:System.Reflection.MethodInfo" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-205">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="7593b-206">创建一个表示进行溢出检查的加法赋值运算的 <see cref="T:System.Linq.Expressions.BinaryExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-206">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an addition assignment operation that has overflow checking.</span></span></summary>
        <returns><span data-ttu-id="7593b-207">一个 <see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 属性等于 <see cref="F:System.Linq.Expressions.ExpressionType.AddAssignChecked" />，并且其 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />、<see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> 属性设置为指定值。</span><span class="sxs-lookup"><span data-stu-id="7593b-207">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.AddAssignChecked" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddAssignChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression AddAssignChecked (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method, System.Linq.Expressions.LambdaExpression conversion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression AddAssignChecked(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method, class System.Linq.Expressions.LambdaExpression conversion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.AddAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AddAssignChecked (left As Expression, right As Expression, method As MethodInfo, conversion As LambdaExpression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ AddAssignChecked(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method, System::Linq::Expressions::LambdaExpression ^ conversion);" />
      <MemberSignature Language="F#" Value="static member AddAssignChecked : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo * System.Linq.Expressions.LambdaExpression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.AddAssignChecked (left, right, method, conversion)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="conversion" Type="System.Linq.Expressions.LambdaExpression" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="7593b-208">要将 <see cref="T:System.Linq.Expressions.Expression" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-208">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="7593b-209">要将 <see cref="T:System.Linq.Expressions.Expression" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-209">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <param name="method"><span data-ttu-id="7593b-210">要将 <see cref="T:System.Reflection.MethodInfo" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-210">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span></span></param>
        <param name="conversion"><span data-ttu-id="7593b-211">要将 <see cref="T:System.Linq.Expressions.LambdaExpression" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-211">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="7593b-212">创建一个表示进行溢出检查的加法赋值运算的 <see cref="T:System.Linq.Expressions.BinaryExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-212">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an addition assignment operation that has overflow checking.</span></span></summary>
        <returns><span data-ttu-id="7593b-213">一个 <see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 属性等于 <see cref="F:System.Linq.Expressions.ExpressionType.AddAssignChecked" />，并且其 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />、<see cref="P:System.Linq.Expressions.BinaryExpression.Right" />、<see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> 属性设置为指定值。</span><span class="sxs-lookup"><span data-stu-id="7593b-213">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.AddAssignChecked" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AddChecked">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="7593b-214">创建一个表示进行溢出检查的算术加法运算的 <see cref="T:System.Linq.Expressions.BinaryExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-214">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an arithmetic addition operation that has overflow checking.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression AddChecked (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression AddChecked(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.AddChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AddChecked (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ AddChecked(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member AddChecked : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.AddChecked (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="7593b-215">要将 <see cref="T:System.Linq.Expressions.Expression" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-215">A <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="7593b-216">要将 <see cref="T:System.Linq.Expressions.Expression" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-216">A <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="7593b-217">创建一个表示进行溢出检查的算术加法运算的 <see cref="T:System.Linq.Expressions.BinaryExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-217">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an arithmetic addition operation that has overflow checking.</span></span></summary>
        <returns><span data-ttu-id="7593b-218">一个 <see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 属性等于 <see cref="F:System.Linq.Expressions.ExpressionType.AddChecked" />，并且其 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 属性设置为指定值。</span><span class="sxs-lookup"><span data-stu-id="7593b-218">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.AddChecked" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7593b-219">生成的 <xref:System.Linq.Expressions.BinaryExpression> 具有设置为实现方法的 <xref:System.Linq.Expressions.BinaryExpression.Method%2A> 属性。</span><span class="sxs-lookup"><span data-stu-id="7593b-219">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="7593b-220"><xref:System.Linq.Expressions.Expression.Type%2A> 属性设置为节点的类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-220">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="7593b-221">如果节点已提升，则 <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> 和 <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> 属性均 `true`。</span><span class="sxs-lookup"><span data-stu-id="7593b-221">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="7593b-222">否则，它们 `false`。</span><span class="sxs-lookup"><span data-stu-id="7593b-222">Otherwise, they are `false`.</span></span> <span data-ttu-id="7593b-223"><xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> 属性为 `null`。</span><span class="sxs-lookup"><span data-stu-id="7593b-223">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="7593b-224">以下信息描述了实现方法、节点类型以及节点是否已提升。</span><span class="sxs-lookup"><span data-stu-id="7593b-224">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="7593b-225">实现方法</span><span class="sxs-lookup"><span data-stu-id="7593b-225">Implementing Method</span></span>  
 <span data-ttu-id="7593b-226">以下规则确定操作的实现方法：</span><span class="sxs-lookup"><span data-stu-id="7593b-226">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="7593b-227">如果 `left` 或 `right` 的 <xref:System.Linq.Expressions.Expression.Type%2A> 属性表示重载加法运算符的用户定义类型，则表示该方法的 <xref:System.Reflection.MethodInfo> 是实现方法。</span><span class="sxs-lookup"><span data-stu-id="7593b-227">If the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the addition operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="7593b-228">否则，如果 `left`。键入并 `right`。类型为数值类型，则实现方法为 `null`。</span><span class="sxs-lookup"><span data-stu-id="7593b-228">Otherwise, if `left`.Type and `right`.Type are numeric types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="7593b-229">节点类型和提升和非提升</span><span class="sxs-lookup"><span data-stu-id="7593b-229">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="7593b-230">如果不 `null`实现方法：</span><span class="sxs-lookup"><span data-stu-id="7593b-230">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="7593b-231">如果 `left`。键入并 `right`。类型可分配给实现方法的相应参数类型，不提升节点。</span><span class="sxs-lookup"><span data-stu-id="7593b-231">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="7593b-232">节点的类型是实现方法的返回类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-232">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="7593b-233">如果满足以下两个条件，则会提升节点，并且该节点的类型为与实现方法的返回类型对应的可以为 null 的类型：</span><span class="sxs-lookup"><span data-stu-id="7593b-233">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="7593b-234">`left`。键入并 `right`。类型既是值类型，其中至少有一个可为 null，并且相应的不可为 null 的类型等于实现方法的相应参数类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-234">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="7593b-235">实现方法的返回类型是不可为 null 的值类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-235">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="7593b-236">如果实现方法为 `null`：</span><span class="sxs-lookup"><span data-stu-id="7593b-236">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="7593b-237">如果 `left`。键入并 `right`。类型不可以为 null，则不提升节点。</span><span class="sxs-lookup"><span data-stu-id="7593b-237">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="7593b-238">节点的类型是预定义的加法运算符的结果类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-238">The type of the node is the result type of the predefined addition operator.</span></span>  
  
-   <span data-ttu-id="7593b-239">如果 `left`。键入并 `right`。类型均可为 null，则提升节点。</span><span class="sxs-lookup"><span data-stu-id="7593b-239">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="7593b-240">节点的类型是与预定义的加法运算符的结果类型对应的可以为 null 的类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-240">The type of the node is the nullable type that corresponds to the result type of the predefined addition operator.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="7593b-241"><paramref name="left" /> 或 <paramref name="right" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-241"><paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="7593b-242">没有为 <paramref name="left" />.Type 和 <paramref name="right" />.Type 定义加法运算符。</span><span class="sxs-lookup"><span data-stu-id="7593b-242">The addition operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="AddChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression AddChecked (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression AddChecked(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.AddChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AddChecked (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ AddChecked(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member AddChecked : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.AddChecked (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="7593b-243">要将 <see cref="T:System.Linq.Expressions.Expression" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-243">A <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="7593b-244">要将 <see cref="T:System.Linq.Expressions.Expression" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-244">A <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <param name="method"><span data-ttu-id="7593b-245">要将 <see cref="T:System.Reflection.MethodInfo" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-245">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="7593b-246">创建一个表示进行溢出检查的算术加法运算的 <see cref="T:System.Linq.Expressions.BinaryExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-246">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an arithmetic addition operation that has overflow checking.</span></span> <span data-ttu-id="7593b-247">可指定实现方法。</span><span class="sxs-lookup"><span data-stu-id="7593b-247">The implementing method can be specified.</span></span></summary>
        <returns><span data-ttu-id="7593b-248">一个 <see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 属性等于 <see cref="F:System.Linq.Expressions.ExpressionType.AddChecked" />，并且其 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />、<see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> 属性设置为指定值。</span><span class="sxs-lookup"><span data-stu-id="7593b-248">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.AddChecked" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7593b-249">生成的 <xref:System.Linq.Expressions.BinaryExpression> 具有设置为实现方法的 <xref:System.Linq.Expressions.BinaryExpression.Method%2A> 属性。</span><span class="sxs-lookup"><span data-stu-id="7593b-249">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="7593b-250"><xref:System.Linq.Expressions.Expression.Type%2A> 属性设置为节点的类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-250">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="7593b-251">如果节点已提升，则 <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> 和 <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> 属性均 `true`。</span><span class="sxs-lookup"><span data-stu-id="7593b-251">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="7593b-252">否则，它们 `false`。</span><span class="sxs-lookup"><span data-stu-id="7593b-252">Otherwise, they are `false`.</span></span> <span data-ttu-id="7593b-253"><xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> 属性为 `null`。</span><span class="sxs-lookup"><span data-stu-id="7593b-253">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="7593b-254">以下信息描述了实现方法、节点类型以及节点是否已提升。</span><span class="sxs-lookup"><span data-stu-id="7593b-254">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="7593b-255">实现方法</span><span class="sxs-lookup"><span data-stu-id="7593b-255">Implementing Method</span></span>  
 <span data-ttu-id="7593b-256">根据以下规则选择操作的实现方法：</span><span class="sxs-lookup"><span data-stu-id="7593b-256">The implementing method for the operation is chosen based on the following rules:</span></span>  
  
-   <span data-ttu-id="7593b-257">如果 `method` 未 `null` 并且它表示采用两个自变量的非 void、`static``Shared` （Visual Basic）方法，则它是节点的实现方法。</span><span class="sxs-lookup"><span data-stu-id="7593b-257">If `method` is not `null` and it represents a non-void, `static` (`Shared` in Visual Basic) method that takes two arguments, it is the implementing method for the node.</span></span>  
  
-   <span data-ttu-id="7593b-258">否则，如果 `left` 或 `right` 的 <xref:System.Linq.Expressions.Expression.Type%2A> 属性表示重载加法运算符的用户定义类型，则表示该方法的 <xref:System.Reflection.MethodInfo> 是实现方法。</span><span class="sxs-lookup"><span data-stu-id="7593b-258">Otherwise, if the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the addition operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="7593b-259">否则，如果 `left`。键入并 `right`。类型为数值类型，则实现方法为 `null`。</span><span class="sxs-lookup"><span data-stu-id="7593b-259">Otherwise, if `left`.Type and `right`.Type are numeric types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="7593b-260">节点类型和提升和非提升</span><span class="sxs-lookup"><span data-stu-id="7593b-260">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="7593b-261">如果不 `null`实现方法：</span><span class="sxs-lookup"><span data-stu-id="7593b-261">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="7593b-262">如果 `left`。键入并 `right`。类型可分配给实现方法的相应参数类型，不提升节点。</span><span class="sxs-lookup"><span data-stu-id="7593b-262">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="7593b-263">节点的类型是实现方法的返回类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-263">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="7593b-264">如果满足以下两个条件，则会提升节点，并且该节点的类型为与实现方法的返回类型对应的可以为 null 的类型：</span><span class="sxs-lookup"><span data-stu-id="7593b-264">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="7593b-265">`left`。键入并 `right`。类型既是值类型，其中至少有一个可为 null，并且相应的不可为 null 的类型等于实现方法的相应参数类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-265">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="7593b-266">实现方法的返回类型是不可为 null 的值类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-266">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="7593b-267">如果实现方法为 `null`：</span><span class="sxs-lookup"><span data-stu-id="7593b-267">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="7593b-268">如果 `left`。键入并 `right`。类型不可以为 null，则不提升节点。</span><span class="sxs-lookup"><span data-stu-id="7593b-268">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="7593b-269">节点的类型是预定义的加法运算符的结果类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-269">The type of the node is the result type of the predefined addition operator.</span></span>  
  
-   <span data-ttu-id="7593b-270">如果 `left`。键入并 `right`。类型均可为 null，则提升节点。</span><span class="sxs-lookup"><span data-stu-id="7593b-270">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="7593b-271">节点的类型是与预定义的加法运算符的结果类型对应的可以为 null 的类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-271">The type of the node is the nullable type that corresponds to the result type of the predefined addition operator.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="7593b-272"><paramref name="left" /> 或 <paramref name="right" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-272"><paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="7593b-273"><paramref name="method" /> 不是 <see langword="null" />，它所表示的方法返回 <see langword="void" />，而不是 <see langword="static" />（Visual Basic 中为 <see langword="Shared" />），或者并非采用两个参数。</span><span class="sxs-lookup"><span data-stu-id="7593b-273"><paramref name="method" /> is not <see langword="null" /> and the method it represents returns <see langword="void" />, is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic), or does not take exactly two arguments.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="7593b-274"><paramref name="method" /> 是 <see langword="null" />，且没有为 <paramref name="left" />.Type 和 <paramref name="right" />.Type 定义加法运算符。</span><span class="sxs-lookup"><span data-stu-id="7593b-274"><paramref name="method" /> is <see langword="null" /> and the addition operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="And">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="7593b-275">创建一个表示按位 <see cref="T:System.Linq.Expressions.BinaryExpression" /> 运算的 <see langword="AND" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-275">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise <see langword="AND" /> operation.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="And">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression And (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression And(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.And(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function And (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ And(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member And : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.And (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="7593b-276">要将 <see cref="T:System.Linq.Expressions.Expression" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-276">A <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="7593b-277">要将 <see cref="T:System.Linq.Expressions.Expression" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-277">A <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="7593b-278">创建一个表示按位 <see cref="T:System.Linq.Expressions.BinaryExpression" /> 运算的 <see langword="AND" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-278">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise <see langword="AND" /> operation.</span></span></summary>
        <returns><span data-ttu-id="7593b-279">一个 <see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 属性等于 <see cref="F:System.Linq.Expressions.ExpressionType.And" />，并且其 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 属性设置为指定值。</span><span class="sxs-lookup"><span data-stu-id="7593b-279">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.And" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7593b-280">生成的 <xref:System.Linq.Expressions.BinaryExpression> 具有设置为实现方法的 <xref:System.Linq.Expressions.BinaryExpression.Method%2A> 属性。</span><span class="sxs-lookup"><span data-stu-id="7593b-280">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="7593b-281"><xref:System.Linq.Expressions.Expression.Type%2A> 属性设置为节点的类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-281">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="7593b-282">如果节点已提升，则 <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> 和 <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> 属性均 `true`。</span><span class="sxs-lookup"><span data-stu-id="7593b-282">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="7593b-283">否则，它们 `false`。</span><span class="sxs-lookup"><span data-stu-id="7593b-283">Otherwise, they are `false`.</span></span> <span data-ttu-id="7593b-284"><xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> 属性为 `null`。</span><span class="sxs-lookup"><span data-stu-id="7593b-284">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="7593b-285">以下信息描述了实现方法、节点类型以及节点是否已提升。</span><span class="sxs-lookup"><span data-stu-id="7593b-285">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="7593b-286">实现方法</span><span class="sxs-lookup"><span data-stu-id="7593b-286">Implementing Method</span></span>  
 <span data-ttu-id="7593b-287">以下规则确定操作的实现方法：</span><span class="sxs-lookup"><span data-stu-id="7593b-287">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="7593b-288">如果 `left` 或 `right` 的 <xref:System.Linq.Expressions.Expression.Type%2A> 属性表示重载按位 `AND` 运算符的用户定义类型，则表示该方法的 <xref:System.Reflection.MethodInfo> 是实现方法。</span><span class="sxs-lookup"><span data-stu-id="7593b-288">If the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the bitwise `AND` operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="7593b-289">否则，如果 `left`。键入并 `right`。类型为整型或布尔类型，则实现方法为 `null`。</span><span class="sxs-lookup"><span data-stu-id="7593b-289">Otherwise, if `left`.Type and `right`.Type are integral or Boolean types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="7593b-290">节点类型和提升和非提升</span><span class="sxs-lookup"><span data-stu-id="7593b-290">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="7593b-291">如果不 `null`实现方法：</span><span class="sxs-lookup"><span data-stu-id="7593b-291">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="7593b-292">如果 `left`。键入并 `right`。类型可分配给实现方法的相应参数类型，不提升节点。</span><span class="sxs-lookup"><span data-stu-id="7593b-292">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="7593b-293">节点的类型是实现方法的返回类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-293">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="7593b-294">如果满足以下两个条件，则会提升节点，并且该节点的类型为与实现方法的返回类型对应的可以为 null 的类型：</span><span class="sxs-lookup"><span data-stu-id="7593b-294">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="7593b-295">`left`。键入并 `right`。类型既是值类型，其中至少有一个可为 null，并且相应的不可为 null 的类型等于实现方法的相应参数类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-295">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="7593b-296">实现方法的返回类型是不可为 null 的值类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-296">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="7593b-297">如果实现方法为 `null`：</span><span class="sxs-lookup"><span data-stu-id="7593b-297">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="7593b-298">如果 `left`。键入并 `right`。类型不可以为 null，则不提升节点。</span><span class="sxs-lookup"><span data-stu-id="7593b-298">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="7593b-299">节点的类型为预定义的按位 `AND` 运算符的结果类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-299">The type of the node is the result type of the predefined bitwise `AND` operator.</span></span>  
  
-   <span data-ttu-id="7593b-300">如果 `left`。键入并 `right`。类型均可为 null，则提升节点。</span><span class="sxs-lookup"><span data-stu-id="7593b-300">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="7593b-301">节点的类型是与预定义的按位 `AND` 运算符的结果类型对应的可以为 null 的类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-301">The type of the node is the nullable type that corresponds to the result type of the predefined bitwise `AND` operator.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="7593b-302">下面的代码示例演示如何创建一个表达式，该表达式表示对两个布尔值的逻辑 AND 运算。</span><span class="sxs-lookup"><span data-stu-id="7593b-302">The following code example shows how to create an expression that represents a logical AND operation on two Boolean values.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#2)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="7593b-303"><paramref name="left" /> 或 <paramref name="right" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-303"><paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="7593b-304">没有为 <see langword="AND" />.Type 和 <paramref name="left" />.Type 定义按位 <paramref name="right" /> 运算符。</span><span class="sxs-lookup"><span data-stu-id="7593b-304">The bitwise <see langword="AND" /> operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="And">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression And (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression And(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.And(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function And (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ And(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member And : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.And (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="7593b-305">要将 <see cref="T:System.Linq.Expressions.Expression" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-305">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="7593b-306">要将 <see cref="T:System.Linq.Expressions.Expression" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-306">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <param name="method"><span data-ttu-id="7593b-307">要将 <see cref="T:System.Reflection.MethodInfo" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-307">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="7593b-308">创建一个表示按位 <see cref="T:System.Linq.Expressions.BinaryExpression" /> 运算的 <see langword="AND" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-308">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise <see langword="AND" /> operation.</span></span> <span data-ttu-id="7593b-309">可指定实现方法。</span><span class="sxs-lookup"><span data-stu-id="7593b-309">The implementing method can be specified.</span></span></summary>
        <returns><span data-ttu-id="7593b-310">一个 <see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 属性等于 <see cref="F:System.Linq.Expressions.ExpressionType.And" />，并且其 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />、<see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> 属性设置为指定值。</span><span class="sxs-lookup"><span data-stu-id="7593b-310">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.And" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7593b-311">生成的 <xref:System.Linq.Expressions.BinaryExpression> 具有设置为实现方法的 <xref:System.Linq.Expressions.BinaryExpression.Method%2A> 属性。</span><span class="sxs-lookup"><span data-stu-id="7593b-311">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="7593b-312"><xref:System.Linq.Expressions.Expression.Type%2A> 属性设置为节点的类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-312">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="7593b-313">如果节点已提升，则 <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> 和 <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> 属性均 `true`。</span><span class="sxs-lookup"><span data-stu-id="7593b-313">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="7593b-314">否则，它们 `false`。</span><span class="sxs-lookup"><span data-stu-id="7593b-314">Otherwise, they are `false`.</span></span> <span data-ttu-id="7593b-315"><xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> 属性为 `null`。</span><span class="sxs-lookup"><span data-stu-id="7593b-315">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="7593b-316">以下信息描述了实现方法、节点类型以及节点是否已提升。</span><span class="sxs-lookup"><span data-stu-id="7593b-316">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="7593b-317">实现方法</span><span class="sxs-lookup"><span data-stu-id="7593b-317">Implementing Method</span></span>  
 <span data-ttu-id="7593b-318">根据以下规则选择操作的实现方法：</span><span class="sxs-lookup"><span data-stu-id="7593b-318">The implementing method for the operation is chosen based on the following rules:</span></span>  
  
-   <span data-ttu-id="7593b-319">如果 `method` 未 `null` 并且它表示采用两个自变量的非 void、`static``Shared` （Visual Basic）方法，则它是节点的实现方法。</span><span class="sxs-lookup"><span data-stu-id="7593b-319">If `method` is not `null` and it represents a non-void, `static` (`Shared` in Visual Basic) method that takes two arguments, it is the implementing method for the node.</span></span>  
  
-   <span data-ttu-id="7593b-320">否则，如果 `left` 或 `right` 的 <xref:System.Linq.Expressions.Expression.Type%2A> 属性表示重载按位 `AND` 运算符的用户定义类型，则表示该方法的 <xref:System.Reflection.MethodInfo> 是实现方法。</span><span class="sxs-lookup"><span data-stu-id="7593b-320">Otherwise, if the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the bitwise `AND` operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="7593b-321">否则，如果 `left`。键入并 `right`。类型为整型或布尔类型，则实现方法为 `null`。</span><span class="sxs-lookup"><span data-stu-id="7593b-321">Otherwise, if `left`.Type and `right`.Type are integral or Boolean types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="7593b-322">节点类型和提升和非提升</span><span class="sxs-lookup"><span data-stu-id="7593b-322">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="7593b-323">如果不 `null`实现方法：</span><span class="sxs-lookup"><span data-stu-id="7593b-323">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="7593b-324">如果 `left`。键入并 `right`。类型可分配给实现方法的相应参数类型，不提升节点。</span><span class="sxs-lookup"><span data-stu-id="7593b-324">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="7593b-325">节点的类型是实现方法的返回类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-325">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="7593b-326">如果满足以下两个条件，则会提升节点，并且该节点的类型为与实现方法的返回类型对应的可以为 null 的类型：</span><span class="sxs-lookup"><span data-stu-id="7593b-326">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="7593b-327">`left`。键入并 `right`。类型既是值类型，其中至少有一个可为 null，并且相应的不可为 null 的类型等于实现方法的相应参数类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-327">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="7593b-328">实现方法的返回类型是不可为 null 的值类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-328">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="7593b-329">如果实现方法为 `null`：</span><span class="sxs-lookup"><span data-stu-id="7593b-329">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="7593b-330">如果 `left`。键入并 `right`。类型不可以为 null，则不提升节点。</span><span class="sxs-lookup"><span data-stu-id="7593b-330">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="7593b-331">节点的类型为预定义的按位 `AND` 运算符的结果类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-331">The type of the node is the result type of the predefined bitwise `AND` operator.</span></span>  
  
-   <span data-ttu-id="7593b-332">如果 `left`。键入并 `right`。类型均可为 null，则提升节点。</span><span class="sxs-lookup"><span data-stu-id="7593b-332">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="7593b-333">节点的类型是与预定义的按位 `AND` 运算符的结果类型对应的可以为 null 的类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-333">The type of the node is the nullable type that corresponds to the result type of the predefined bitwise `AND` operator.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="7593b-334"><paramref name="left" /> 或 <paramref name="right" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-334"><paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="7593b-335"><paramref name="method" /> 不是 <see langword="null" />，它所表示的方法返回 <see langword="void" />，而不是 <see langword="static" />（Visual Basic 中为 <see langword="Shared" />），或者并非采用两个参数。</span><span class="sxs-lookup"><span data-stu-id="7593b-335"><paramref name="method" /> is not <see langword="null" /> and the method it represents returns <see langword="void" />, is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic), or does not take exactly two arguments.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="7593b-336"><paramref name="method" /> 是 <see langword="null" />，且没有为 <see langword="AND" />.Type 和 <paramref name="left" />.Type 定义按位 <paramref name="right" /> 运算符。</span><span class="sxs-lookup"><span data-stu-id="7593b-336"><paramref name="method" /> is <see langword="null" /> and the bitwise <see langword="AND" /> operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="AndAlso">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="7593b-337">创建一个 <see cref="T:System.Linq.Expressions.BinaryExpression" />，它表示仅在第一个操作数的计算结果为 <see langword="AND" /> 时才计算第二个操作数的条件 <see langword="true" /> 运算。</span><span class="sxs-lookup"><span data-stu-id="7593b-337">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a conditional <see langword="AND" /> operation that evaluates the second operand only if the first operand evaluates to <see langword="true" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AndAlso">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression AndAlso (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression AndAlso(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.AndAlso(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AndAlso (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ AndAlso(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member AndAlso : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.AndAlso (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="7593b-338">要将 <see cref="T:System.Linq.Expressions.Expression" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-338">A <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="7593b-339">要将 <see cref="T:System.Linq.Expressions.Expression" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-339">A <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="7593b-340">创建一个 <see cref="T:System.Linq.Expressions.BinaryExpression" />，它表示仅在第一个操作数的计算结果为 <see langword="AND" /> 时才计算第二个操作数的条件 <see langword="true" /> 运算。</span><span class="sxs-lookup"><span data-stu-id="7593b-340">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a conditional <see langword="AND" /> operation that evaluates the second operand only if the first operand evaluates to <see langword="true" />.</span></span></summary>
        <returns><span data-ttu-id="7593b-341">一个 <see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 属性等于 <see cref="F:System.Linq.Expressions.ExpressionType.AndAlso" />，并且其 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 属性设置为指定值。</span><span class="sxs-lookup"><span data-stu-id="7593b-341">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.AndAlso" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7593b-342">生成的 <xref:System.Linq.Expressions.BinaryExpression> 具有设置为实现方法的 <xref:System.Linq.Expressions.BinaryExpression.Method%2A> 属性。</span><span class="sxs-lookup"><span data-stu-id="7593b-342">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="7593b-343"><xref:System.Linq.Expressions.Expression.Type%2A> 属性设置为节点的类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-343">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="7593b-344">如果节点已提升，则 <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> 和 <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> 属性均 `true`。</span><span class="sxs-lookup"><span data-stu-id="7593b-344">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="7593b-345">否则，它们 `false`。</span><span class="sxs-lookup"><span data-stu-id="7593b-345">Otherwise, they are `false`.</span></span> <span data-ttu-id="7593b-346"><xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> 属性为 `null`。</span><span class="sxs-lookup"><span data-stu-id="7593b-346">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="7593b-347">以下信息描述了实现方法、节点类型以及节点是否已提升。</span><span class="sxs-lookup"><span data-stu-id="7593b-347">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="7593b-348">实现方法</span><span class="sxs-lookup"><span data-stu-id="7593b-348">Implementing Method</span></span>  
 <span data-ttu-id="7593b-349">以下规则确定操作的实现方法：</span><span class="sxs-lookup"><span data-stu-id="7593b-349">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="7593b-350">如果 `left` 或 `right` 的 <xref:System.Linq.Expressions.Expression.Type%2A> 属性表示重载按位 `AND` 运算符的用户定义类型，则表示该方法的 <xref:System.Reflection.MethodInfo> 是实现方法。</span><span class="sxs-lookup"><span data-stu-id="7593b-350">If the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the bitwise `AND` operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="7593b-351">不能在或 Visual Basic 中C#重载条件 `AND` 运算符。</span><span class="sxs-lookup"><span data-stu-id="7593b-351">The conditional `AND` operator cannot be overloaded in C# or Visual Basic.</span></span> <span data-ttu-id="7593b-352">不过，条件 `AND` 运算符使用按位 `AND` 运算符进行计算。</span><span class="sxs-lookup"><span data-stu-id="7593b-352">However, the conditional `AND` operator is evaluated by using the bitwise `AND` operator.</span></span> <span data-ttu-id="7593b-353">因此，按位 `AND` 运算符的用户定义的重载可以是此节点类型的实现方法。</span><span class="sxs-lookup"><span data-stu-id="7593b-353">Thus, a user-defined overload of the bitwise `AND` operator can be the implementing method for this node type.</span></span>  
  
-   <span data-ttu-id="7593b-354">否则，如果 `left`。键入并 `right`。类型是布尔类型，则实现方法为 `null`。</span><span class="sxs-lookup"><span data-stu-id="7593b-354">Otherwise, if `left`.Type and `right`.Type are Boolean types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="7593b-355">节点类型和提升和非提升</span><span class="sxs-lookup"><span data-stu-id="7593b-355">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="7593b-356">如果不 `null`实现方法：</span><span class="sxs-lookup"><span data-stu-id="7593b-356">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="7593b-357">如果 `left`。键入并 `right`。类型可分配给实现方法的相应参数类型，不提升节点。</span><span class="sxs-lookup"><span data-stu-id="7593b-357">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="7593b-358">节点的类型是实现方法的返回类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-358">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="7593b-359">如果满足以下两个条件，则会提升节点，并且该节点的类型为与实现方法的返回类型对应的可以为 null 的类型：</span><span class="sxs-lookup"><span data-stu-id="7593b-359">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="7593b-360">`left`。键入并 `right`。类型既是值类型，其中至少有一个可为 null，并且相应的不可为 null 的类型等于实现方法的相应参数类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-360">`left`.Type and `right`.Type are both value types of which at least one is nullable, and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="7593b-361">实现方法的返回类型是不可为 null 的值类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-361">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="7593b-362">如果实现方法为 `null`：</span><span class="sxs-lookup"><span data-stu-id="7593b-362">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="7593b-363">`left`。键入并 `right`。类型是相同的布尔类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-363">`left`.Type and `right`.Type are the same Boolean type.</span></span>  
  
-   <span data-ttu-id="7593b-364">如果 `left`。键入并 `right`。类型不可为 null，则不提升节点。</span><span class="sxs-lookup"><span data-stu-id="7593b-364">If `left`.Type and `right`.Type are non-nullable, the node is not lifted.</span></span> <span data-ttu-id="7593b-365">节点的类型是预定义的条件 `AND` 运算符的结果类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-365">The type of the node is the result type of the predefined conditional `AND` operator.</span></span>  
  
-   <span data-ttu-id="7593b-366">如果 `left`。键入并 `right`。类型可以为 null，则提升节点。</span><span class="sxs-lookup"><span data-stu-id="7593b-366">If `left`.Type and `right`.Type are nullable, the node is lifted.</span></span> <span data-ttu-id="7593b-367">节点的类型是与预定义条件 `AND` 运算符的结果类型对应的可以为 null 的类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-367">The type of the node is the nullable type that corresponds to the result type of the predefined conditional `AND` operator.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="7593b-368">下面的代码示例演示如何创建一个表达式，该表达式仅在第一个操作数的计算结果为 `true`时才对其两个操作数执行逻辑 AND 运算。</span><span class="sxs-lookup"><span data-stu-id="7593b-368">The following code example shows how to create an expression that performs a logical AND operation on its two operands only if the first operand evaluates to `true`.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#19](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#19)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#19](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#19)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="7593b-369"><paramref name="left" /> 或 <paramref name="right" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-369"><paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="7593b-370">没有为 <see langword="AND" />.Type 和 <paramref name="left" />.Type 定义按位 <paramref name="right" /> 运算符。</span><span class="sxs-lookup"><span data-stu-id="7593b-370">The bitwise <see langword="AND" /> operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span></span>  
  
<span data-ttu-id="7593b-371">- 或 -</span><span class="sxs-lookup"><span data-stu-id="7593b-371">-or-</span></span> 
 <span data-ttu-id="7593b-372"><paramref name="left" />.Type 和 <paramref name="right" />.Type 不是同一布尔值类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-372"><paramref name="left" />.Type and <paramref name="right" />.Type are not the same Boolean type.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="AndAlso">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression AndAlso (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression AndAlso(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.AndAlso(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AndAlso (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ AndAlso(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member AndAlso : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.AndAlso (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="7593b-373">要将 <see cref="T:System.Linq.Expressions.Expression" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-373">A <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="7593b-374">要将 <see cref="T:System.Linq.Expressions.Expression" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-374">A <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <param name="method"><span data-ttu-id="7593b-375">要将 <see cref="T:System.Reflection.MethodInfo" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-375">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="7593b-376">创建一个 <see cref="T:System.Linq.Expressions.BinaryExpression" />，它表示仅在第一个操作数解析为 true 时，才计算第二个操作数的条件 <see langword="AND" /> 运算。</span><span class="sxs-lookup"><span data-stu-id="7593b-376">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a conditional <see langword="AND" /> operation that evaluates the second operand only if the first operand is resolved to true.</span></span> <span data-ttu-id="7593b-377">可指定实现方法。</span><span class="sxs-lookup"><span data-stu-id="7593b-377">The implementing method can be specified.</span></span></summary>
        <returns><span data-ttu-id="7593b-378">一个 <see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 属性等于 <see cref="F:System.Linq.Expressions.ExpressionType.AndAlso" />，并且其 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />、<see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> 属性设置为指定值。</span><span class="sxs-lookup"><span data-stu-id="7593b-378">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.AndAlso" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7593b-379">生成的 <xref:System.Linq.Expressions.BinaryExpression> 具有设置为实现方法的 <xref:System.Linq.Expressions.BinaryExpression.Method%2A> 属性。</span><span class="sxs-lookup"><span data-stu-id="7593b-379">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="7593b-380"><xref:System.Linq.Expressions.Expression.Type%2A> 属性设置为节点的类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-380">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="7593b-381">如果节点已提升，则 <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> 和 <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> 属性均 `true`。</span><span class="sxs-lookup"><span data-stu-id="7593b-381">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="7593b-382">否则，它们 `false`。</span><span class="sxs-lookup"><span data-stu-id="7593b-382">Otherwise, they are `false`.</span></span> <span data-ttu-id="7593b-383"><xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> 属性为 `null`。</span><span class="sxs-lookup"><span data-stu-id="7593b-383">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="7593b-384">以下信息描述了实现方法、节点类型以及节点是否已提升。</span><span class="sxs-lookup"><span data-stu-id="7593b-384">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="7593b-385">实现方法</span><span class="sxs-lookup"><span data-stu-id="7593b-385">Implementing Method</span></span>  
 <span data-ttu-id="7593b-386">根据以下规则选择操作的实现方法：</span><span class="sxs-lookup"><span data-stu-id="7593b-386">The implementing method for the operation is chosen based on the following rules:</span></span>  
  
-   <span data-ttu-id="7593b-387">如果 `method` 未 `null` 并且它表示采用两个自变量的非 void、`static``Shared` （Visual Basic）方法，则它是节点的实现方法。</span><span class="sxs-lookup"><span data-stu-id="7593b-387">If `method` is not `null` and it represents a non-void, `static` (`Shared` in Visual Basic) method that takes two arguments, it is the implementing method for the node.</span></span>  
  
-   <span data-ttu-id="7593b-388">否则，如果 `left` 或 `right` 的 <xref:System.Linq.Expressions.Expression.Type%2A> 属性表示重载按位 `AND` 运算符的用户定义类型，则表示该方法的 <xref:System.Reflection.MethodInfo> 是实现方法。</span><span class="sxs-lookup"><span data-stu-id="7593b-388">Otherwise, if the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the bitwise `AND` operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="7593b-389">不能在或 Visual Basic 中C#重载条件 `AND` 运算符。</span><span class="sxs-lookup"><span data-stu-id="7593b-389">The conditional `AND` operator cannot be overloaded in C# or Visual Basic.</span></span> <span data-ttu-id="7593b-390">不过，条件 `AND` 运算符使用按位 `AND` 运算符进行计算。</span><span class="sxs-lookup"><span data-stu-id="7593b-390">However, the conditional `AND` operator is evaluated by using the bitwise `AND` operator.</span></span> <span data-ttu-id="7593b-391">因此，按位 `AND` 运算符的用户定义的重载可以是此节点类型的实现方法。</span><span class="sxs-lookup"><span data-stu-id="7593b-391">Thus, a user-defined overload of the bitwise `AND` operator can be the implementing method for this node type.</span></span>  
  
-   <span data-ttu-id="7593b-392">否则，如果 `left`。键入并 `right`。类型是布尔类型，则实现方法为 `null`。</span><span class="sxs-lookup"><span data-stu-id="7593b-392">Otherwise, if `left`.Type and `right`.Type are Boolean types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="7593b-393">节点类型和提升和非提升</span><span class="sxs-lookup"><span data-stu-id="7593b-393">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="7593b-394">如果不 `null`实现方法：</span><span class="sxs-lookup"><span data-stu-id="7593b-394">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="7593b-395">如果 `left`。键入并 `right`。类型可分配给实现方法的相应参数类型，不提升节点。</span><span class="sxs-lookup"><span data-stu-id="7593b-395">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="7593b-396">节点的类型是实现方法的返回类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-396">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="7593b-397">如果满足以下两个条件，则会提升节点，并且该节点的类型为与实现方法的返回类型对应的可以为 null 的类型：</span><span class="sxs-lookup"><span data-stu-id="7593b-397">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="7593b-398">`left`。键入并 `right`。类型既是值类型，其中至少有一个可为 null，并且相应的不可为 null 的类型等于实现方法的相应参数类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-398">`left`.Type and `right`.Type are both value types of which at least one is nullable, and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="7593b-399">实现方法的返回类型是不可为 null 的值类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-399">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="7593b-400">如果实现方法为 `null`：</span><span class="sxs-lookup"><span data-stu-id="7593b-400">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="7593b-401">`left`。键入并 `right`。类型是相同的布尔类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-401">`left`.Type and `right`.Type are the same Boolean type.</span></span>  
  
-   <span data-ttu-id="7593b-402">如果 `left`。键入并 `right`。类型不可为 null，则不提升节点。</span><span class="sxs-lookup"><span data-stu-id="7593b-402">If `left`.Type and `right`.Type are non-nullable, the node is not lifted.</span></span> <span data-ttu-id="7593b-403">节点的类型是预定义的条件 `AND` 运算符的结果类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-403">The type of the node is the result type of the predefined conditional `AND` operator.</span></span>  
  
-   <span data-ttu-id="7593b-404">如果 `left`。键入并 `right`。类型可以为 null，则提升节点。</span><span class="sxs-lookup"><span data-stu-id="7593b-404">If `left`.Type and `right`.Type are nullable, the node is lifted.</span></span> <span data-ttu-id="7593b-405">节点的类型是与预定义条件 `AND` 运算符的结果类型对应的可以为 null 的类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-405">The type of the node is the nullable type that corresponds to the result type of the predefined conditional `AND` operator.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="7593b-406"><paramref name="left" /> 或 <paramref name="right" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-406"><paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="7593b-407"><paramref name="method" /> 不是 <see langword="null" />，它所表示的方法返回 <see langword="void" />，而不是 <see langword="static" />（Visual Basic 中为 <see langword="Shared" />），或者并非采用两个参数。</span><span class="sxs-lookup"><span data-stu-id="7593b-407"><paramref name="method" /> is not <see langword="null" /> and the method it represents returns <see langword="void" />, is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic), or does not take exactly two arguments.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="7593b-408"><paramref name="method" /> 是 <see langword="null" />，且没有为 <see langword="AND" />.Type 和 <paramref name="left" />.Type 定义按位 <paramref name="right" /> 运算符。</span><span class="sxs-lookup"><span data-stu-id="7593b-408"><paramref name="method" /> is <see langword="null" /> and the bitwise <see langword="AND" /> operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span></span>  
  
<span data-ttu-id="7593b-409">- 或 -</span><span class="sxs-lookup"><span data-stu-id="7593b-409">-or-</span></span> 
 <span data-ttu-id="7593b-410"><paramref name="method" /> 为 <see langword="null" /> 并且 <paramref name="left" />.Type 和 <paramref name="right" />.Type 不是同一布尔值类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-410"><paramref name="method" /> is <see langword="null" /> and <paramref name="left" />.Type and <paramref name="right" />.Type are not the same Boolean type.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="AndAssign">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="7593b-411">创建一个表示按位 AND 赋值运算的 <see cref="T:System.Linq.Expressions.BinaryExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-411">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise AND assignment operation.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AndAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression AndAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression AndAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.AndAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AndAssign (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ AndAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member AndAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.AndAssign (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="7593b-412">要将 <see cref="T:System.Linq.Expressions.Expression" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-412">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="7593b-413">要将 <see cref="T:System.Linq.Expressions.Expression" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-413">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="7593b-414">创建一个表示按位 AND 赋值运算的 <see cref="T:System.Linq.Expressions.BinaryExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-414">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise AND assignment operation.</span></span></summary>
        <returns><span data-ttu-id="7593b-415">一个 <see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 属性等于 <see cref="F:System.Linq.Expressions.ExpressionType.AndAssign" />，并且其 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 属性设置为指定值。</span><span class="sxs-lookup"><span data-stu-id="7593b-415">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.AndAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AndAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression AndAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression AndAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.AndAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AndAssign (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ AndAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member AndAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.AndAssign (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="7593b-416">要将 <see cref="T:System.Linq.Expressions.Expression" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-416">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="7593b-417">要将 <see cref="T:System.Linq.Expressions.Expression" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-417">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <param name="method"><span data-ttu-id="7593b-418">要将 <see cref="T:System.Reflection.MethodInfo" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-418">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="7593b-419">创建一个表示按位 AND 赋值运算的 <see cref="T:System.Linq.Expressions.BinaryExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-419">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise AND assignment operation.</span></span></summary>
        <returns><span data-ttu-id="7593b-420">一个 <see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 属性等于 <see cref="F:System.Linq.Expressions.ExpressionType.AndAssign" />，并且其 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />、<see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> 属性设置为指定值。</span><span class="sxs-lookup"><span data-stu-id="7593b-420">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.AndAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AndAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression AndAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method, System.Linq.Expressions.LambdaExpression conversion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression AndAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method, class System.Linq.Expressions.LambdaExpression conversion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.AndAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AndAssign (left As Expression, right As Expression, method As MethodInfo, conversion As LambdaExpression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ AndAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method, System::Linq::Expressions::LambdaExpression ^ conversion);" />
      <MemberSignature Language="F#" Value="static member AndAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo * System.Linq.Expressions.LambdaExpression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.AndAssign (left, right, method, conversion)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="conversion" Type="System.Linq.Expressions.LambdaExpression" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="7593b-421">要将 <see cref="T:System.Linq.Expressions.Expression" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-421">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="7593b-422">要将 <see cref="T:System.Linq.Expressions.Expression" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-422">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <param name="method"><span data-ttu-id="7593b-423">要将 <see cref="T:System.Reflection.MethodInfo" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-423">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span></span></param>
        <param name="conversion"><span data-ttu-id="7593b-424">要将 <see cref="T:System.Linq.Expressions.LambdaExpression" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-424">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="7593b-425">创建一个表示按位 AND 赋值运算的 <see cref="T:System.Linq.Expressions.BinaryExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-425">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise AND assignment operation.</span></span></summary>
        <returns><span data-ttu-id="7593b-426">一个 <see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 属性等于 <see cref="F:System.Linq.Expressions.ExpressionType.AndAssign" />，并且其 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />、<see cref="P:System.Linq.Expressions.BinaryExpression.Right" />、<see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> 属性设置为指定值。</span><span class="sxs-lookup"><span data-stu-id="7593b-426">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.AndAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ArrayAccess">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="7593b-427">创建一个用于访问数组的 <see cref="T:System.Linq.Expressions.IndexExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-427">Creates an <see cref="T:System.Linq.Expressions.IndexExpression" /> to access an array.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ArrayAccess">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.IndexExpression ArrayAccess (System.Linq.Expressions.Expression array, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; indexes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.IndexExpression ArrayAccess(class System.Linq.Expressions.Expression array, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; indexes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ArrayAccess(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ArrayAccess (array As Expression, indexes As IEnumerable(Of Expression)) As IndexExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::IndexExpression ^ ArrayAccess(System::Linq::Expressions::Expression ^ array, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ indexes);" />
      <MemberSignature Language="F#" Value="static member ArrayAccess : System.Linq.Expressions.Expression * seq&lt;System.Linq.Expressions.Expression&gt; -&gt; System.Linq.Expressions.IndexExpression" Usage="System.Linq.Expressions.Expression.ArrayAccess (array, indexes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.IndexExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Linq.Expressions.Expression" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="indexes" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="array"><span data-ttu-id="7593b-428">一个表示多维数组的表达式。</span><span class="sxs-lookup"><span data-stu-id="7593b-428">An expression that represents the multidimensional array.</span></span></param>
        <param name="indexes"><span data-ttu-id="7593b-429">一个 <see cref="T:System.Collections.Generic.IEnumerable`1" />，其中包含用于为数组编制索引的表达式。</span><span class="sxs-lookup"><span data-stu-id="7593b-429">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> containing expressions used to index the array.</span></span></param>
        <summary><span data-ttu-id="7593b-430">创建一个用于访问多维数组的 <see cref="T:System.Linq.Expressions.IndexExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-430">Creates an <see cref="T:System.Linq.Expressions.IndexExpression" /> to access a multidimensional array.</span></span></summary>
        <returns><span data-ttu-id="7593b-431">创建的 <see cref="T:System.Linq.Expressions.IndexExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-431">The created <see cref="T:System.Linq.Expressions.IndexExpression" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7593b-432">可以通过使用 <xref:System.Linq.Expressions.Expression.MakeMemberAccess%2A> 方法或 <xref:System.Linq.Expressions.Expression.NewArrayBounds%2A> 或 <xref:System.Linq.Expressions.Expression.NewArrayInit%2A>获取表示数组的表达式。</span><span class="sxs-lookup"><span data-stu-id="7593b-432">The expression that represents the array can be obtained by using the <xref:System.Linq.Expressions.Expression.MakeMemberAccess%2A> method, or through <xref:System.Linq.Expressions.Expression.NewArrayBounds%2A> or <xref:System.Linq.Expressions.Expression.NewArrayInit%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="7593b-433">下面的代码示例演示如何使用 `ArrayAccess` 方法更改多维数组中元素的值。</span><span class="sxs-lookup"><span data-stu-id="7593b-433">The following code example shows how to change the value of an element in a multidimensional array by using the `ArrayAccess` method.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#21)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#21)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ArrayAccess">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.IndexExpression ArrayAccess (System.Linq.Expressions.Expression array, params System.Linq.Expressions.Expression[] indexes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.IndexExpression ArrayAccess(class System.Linq.Expressions.Expression array, class System.Linq.Expressions.Expression[] indexes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ArrayAccess(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ArrayAccess (array As Expression, ParamArray indexes As Expression()) As IndexExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::IndexExpression ^ ArrayAccess(System::Linq::Expressions::Expression ^ array, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ indexes);" />
      <MemberSignature Language="F#" Value="static member ArrayAccess : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression[] -&gt; System.Linq.Expressions.IndexExpression" Usage="System.Linq.Expressions.Expression.ArrayAccess (array, indexes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.IndexExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Linq.Expressions.Expression" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="indexes" Type="System.Linq.Expressions.Expression[]" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="array"><span data-ttu-id="7593b-434">一个表示要编制索引的数组的表达式。</span><span class="sxs-lookup"><span data-stu-id="7593b-434">An expression representing the array to index.</span></span></param>
        <param name="indexes"><span data-ttu-id="7593b-435">一个数组，其中包含用于为数组编制索引的表达式。</span><span class="sxs-lookup"><span data-stu-id="7593b-435">An array that contains expressions used to index the array.</span></span></param>
        <summary><span data-ttu-id="7593b-436">创建一个用于访问数组的 <see cref="T:System.Linq.Expressions.IndexExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-436">Creates an <see cref="T:System.Linq.Expressions.IndexExpression" /> to access an array.</span></span></summary>
        <returns><span data-ttu-id="7593b-437">创建的 <see cref="T:System.Linq.Expressions.IndexExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-437">The created <see cref="T:System.Linq.Expressions.IndexExpression" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7593b-438">可以通过使用 <xref:System.Linq.Expressions.Expression.MakeMemberAccess%2A> 方法或 <xref:System.Linq.Expressions.Expression.NewArrayBounds%2A> 或 <xref:System.Linq.Expressions.Expression.NewArrayInit%2A>获取表示数组的表达式。</span><span class="sxs-lookup"><span data-stu-id="7593b-438">The expression that represents the array can be obtained by using the <xref:System.Linq.Expressions.Expression.MakeMemberAccess%2A> method, or through <xref:System.Linq.Expressions.Expression.NewArrayBounds%2A> or <xref:System.Linq.Expressions.Expression.NewArrayInit%2A>.</span></span>  
  
 <span data-ttu-id="7593b-439">对于多维数组，请使用 <xref:System.Linq.Expressions.Expression.ArrayAccess%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="7593b-439">For multidimensional arrays, use the <xref:System.Linq.Expressions.Expression.ArrayAccess%2A> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="7593b-440">下面的代码示例演示如何使用 `ArrayAccess` 方法更改数组元素的值。</span><span class="sxs-lookup"><span data-stu-id="7593b-440">The following code example shows how to change a value of an array element by using the `ArrayAccess` method.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#20](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#20)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#20](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#20)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ArrayIndex">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="7593b-441">创建一个表示应用数组索引运算符的 <see cref="T:System.Linq.Expressions.Expression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-441">Creates an <see cref="T:System.Linq.Expressions.Expression" /> that represents applying an array index operator.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ArrayIndex">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MethodCallExpression ArrayIndex (System.Linq.Expressions.Expression array, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; indexes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MethodCallExpression ArrayIndex(class System.Linq.Expressions.Expression array, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; indexes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ArrayIndex(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ArrayIndex (array As Expression, indexes As IEnumerable(Of Expression)) As MethodCallExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MethodCallExpression ^ ArrayIndex(System::Linq::Expressions::Expression ^ array, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ indexes);" />
      <MemberSignature Language="F#" Value="static member ArrayIndex : System.Linq.Expressions.Expression * seq&lt;System.Linq.Expressions.Expression&gt; -&gt; System.Linq.Expressions.MethodCallExpression" Usage="System.Linq.Expressions.Expression.ArrayIndex (array, indexes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MethodCallExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="indexes" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="array"><span data-ttu-id="7593b-442">要将 <see cref="T:System.Linq.Expressions.Expression" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-442">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> property equal to.</span></span></param>
        <param name="indexes"><span data-ttu-id="7593b-443">一个 <see cref="T:System.Collections.Generic.IEnumerable`1" />，包含用来填充 <see cref="T:System.Linq.Expressions.Expression" /> 集合的 <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> 对象。</span><span class="sxs-lookup"><span data-stu-id="7593b-443">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.Expression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> collection.</span></span></param>
        <summary><span data-ttu-id="7593b-444">创建一个 <see cref="T:System.Linq.Expressions.MethodCallExpression" />，它表示将数组索引运算符应用到多个级别的数组中。</span><span class="sxs-lookup"><span data-stu-id="7593b-444">Creates a <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that represents applying an array index operator to an array of rank more than one.</span></span></summary>
        <returns><span data-ttu-id="7593b-445">一个 <see cref="T:System.Linq.Expressions.MethodCallExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 属性等于 <see cref="F:System.Linq.Expressions.ExpressionType.Call" />，并且其 <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> 和 <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> 属性设置为指定值。</span><span class="sxs-lookup"><span data-stu-id="7593b-445">A <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> and the <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> and <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7593b-446">`indexes` 的每个元素必须具有等于 <xref:System.Int32>的 <xref:System.Linq.Expressions.Expression.Type%2A>。</span><span class="sxs-lookup"><span data-stu-id="7593b-446">Each element of `indexes` must have <xref:System.Linq.Expressions.Expression.Type%2A> equal to <xref:System.Int32>.</span></span> <span data-ttu-id="7593b-447">`array` 的 <xref:System.Linq.Expressions.Expression.Type%2A> 属性必须表示其秩与 `indexes`中的元素数相匹配的数组类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-447">The <xref:System.Linq.Expressions.Expression.Type%2A> property of `array` must represent an array type whose rank matches the number of elements in `indexes`.</span></span>  
  
 <span data-ttu-id="7593b-448">如果 `array`的排名。类型为1，则此方法返回 <xref:System.Linq.Expressions.BinaryExpression>。</span><span class="sxs-lookup"><span data-stu-id="7593b-448">If the rank of `array`.Type is 1, this method returns a <xref:System.Linq.Expressions.BinaryExpression>.</span></span> <span data-ttu-id="7593b-449"><xref:System.Linq.Expressions.BinaryExpression.Left%2A> 属性设置为 `array`，<xref:System.Linq.Expressions.BinaryExpression.Right%2A> 属性设置为 `indexes`的单个元素。</span><span class="sxs-lookup"><span data-stu-id="7593b-449">The <xref:System.Linq.Expressions.BinaryExpression.Left%2A> property is set to `array` and the <xref:System.Linq.Expressions.BinaryExpression.Right%2A> property is set to the single element of `indexes`.</span></span> <span data-ttu-id="7593b-450"><xref:System.Linq.Expressions.BinaryExpression> 的 <xref:System.Linq.Expressions.Expression.Type%2A> 属性表示 `array`的元素类型。类别.</span><span class="sxs-lookup"><span data-stu-id="7593b-450">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the <xref:System.Linq.Expressions.BinaryExpression> represents the element type of `array`.Type.</span></span>  
  
 <span data-ttu-id="7593b-451">如果 `array`的排名。类型不止一个，则此方法返回 <xref:System.Linq.Expressions.MethodCallExpression>。</span><span class="sxs-lookup"><span data-stu-id="7593b-451">If the rank of `array`.Type is more than one, this method returns a <xref:System.Linq.Expressions.MethodCallExpression>.</span></span> <span data-ttu-id="7593b-452"><xref:System.Linq.Expressions.MethodCallExpression.Method%2A> 属性设置为 <xref:System.Reflection.MethodInfo>，用于描述 `array`的 <xref:System.Linq.Expressions.Expression.Type%2A> 属性所表示的类型上的公共实例方法 `Get`。</span><span class="sxs-lookup"><span data-stu-id="7593b-452">The <xref:System.Linq.Expressions.MethodCallExpression.Method%2A> property is set to the <xref:System.Reflection.MethodInfo> that describes the public instance method `Get` on the type represented by the <xref:System.Linq.Expressions.Expression.Type%2A> property of `array`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="7593b-453">下面的示例演示如何使用 <xref:System.Linq.Expressions.Expression.ArrayIndex%28System.Linq.Expressions.Expression%2CSystem.Linq.Expressions.Expression%5B%5D%29> 方法来创建表示索引为二维数组的 <xref:System.Linq.Expressions.MethodCallExpression>。</span><span class="sxs-lookup"><span data-stu-id="7593b-453">The following example demonstrates how to use the <xref:System.Linq.Expressions.Expression.ArrayIndex%28System.Linq.Expressions.Expression%2CSystem.Linq.Expressions.Expression%5B%5D%29> method to create a <xref:System.Linq.Expressions.MethodCallExpression> that represents indexing into a two-dimensional array.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.Expression#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#3)]
 [!code-vb[System.Linq.Expressions.Expression#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="7593b-454"><paramref name="array" /> 或 <paramref name="indexes" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-454"><paramref name="array" /> or <paramref name="indexes" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="7593b-455"><paramref name="array" />.Type 不表示数组类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-455"><paramref name="array" />.Type does not represent an array type.</span></span>  
  
<span data-ttu-id="7593b-456">- 或 -</span><span class="sxs-lookup"><span data-stu-id="7593b-456">-or-</span></span> 
<span data-ttu-id="7593b-457"><paramref name="array" />.Type 的秩与 <paramref name="indexes" /> 中的元素数量不匹配。</span><span class="sxs-lookup"><span data-stu-id="7593b-457">The rank of <paramref name="array" />.Type does not match the number of elements in <paramref name="indexes" />.</span></span>  
  
<span data-ttu-id="7593b-458">- 或 -</span><span class="sxs-lookup"><span data-stu-id="7593b-458">-or-</span></span> 
<span data-ttu-id="7593b-459"><see cref="P:System.Linq.Expressions.Expression.Type" /> 的一个或多个元素的 <paramref name="indexes" /> 属性不表示 <see cref="T:System.Int32" /> 类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-459">The <see cref="P:System.Linq.Expressions.Expression.Type" /> property of one or more elements of <paramref name="indexes" /> does not represent the <see cref="T:System.Int32" /> type.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ArrayIndex">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression ArrayIndex (System.Linq.Expressions.Expression array, System.Linq.Expressions.Expression index);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression ArrayIndex(class System.Linq.Expressions.Expression array, class System.Linq.Expressions.Expression index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ArrayIndex(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ArrayIndex (array As Expression, index As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ ArrayIndex(System::Linq::Expressions::Expression ^ array, System::Linq::Expressions::Expression ^ index);" />
      <MemberSignature Language="F#" Value="static member ArrayIndex : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.ArrayIndex (array, index)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="index" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="array"><span data-ttu-id="7593b-460">要将 <see cref="T:System.Linq.Expressions.Expression" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-460">A <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="index"><span data-ttu-id="7593b-461">要将 <see cref="T:System.Linq.Expressions.Expression" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-461">A <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="7593b-462">创建一个 <see cref="T:System.Linq.Expressions.BinaryExpression" />，它表示将数组索引运算符应用到级别一的数组中。</span><span class="sxs-lookup"><span data-stu-id="7593b-462">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents applying an array index operator to an array of rank one.</span></span></summary>
        <returns><span data-ttu-id="7593b-463">一个 <see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 属性等于 <see cref="F:System.Linq.Expressions.ExpressionType.ArrayIndex" />，并且其 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 属性设置为指定值。</span><span class="sxs-lookup"><span data-stu-id="7593b-463">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.ArrayIndex" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7593b-464">`index` 必须表示 <xref:System.Int32>类型的索引。</span><span class="sxs-lookup"><span data-stu-id="7593b-464">`index` must represent an index of type <xref:System.Int32>.</span></span>  
  
 <span data-ttu-id="7593b-465">生成的 <xref:System.Linq.Expressions.BinaryExpression> 的 <xref:System.Linq.Expressions.BinaryExpression.Method%2A> 属性是 `null`，并且 <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> 和 <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> 都设置为 `false`。</span><span class="sxs-lookup"><span data-stu-id="7593b-465">The <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property of the resulting <xref:System.Linq.Expressions.BinaryExpression> is `null`, and both <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> are set to `false`.</span></span> <span data-ttu-id="7593b-466"><xref:System.Linq.Expressions.Expression.Type%2A> 属性等于 `array`的元素类型。类别.</span><span class="sxs-lookup"><span data-stu-id="7593b-466">The <xref:System.Linq.Expressions.Expression.Type%2A> property is equal to the element type of `array`.Type.</span></span> <span data-ttu-id="7593b-467"><xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> 属性为 `null`。</span><span class="sxs-lookup"><span data-stu-id="7593b-467">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="7593b-468"><paramref name="array" /> 或 <paramref name="index" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-468"><paramref name="array" /> or <paramref name="index" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="7593b-469"><paramref name="array" />.Type 不表示数组类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-469"><paramref name="array" />.Type does not represent an array type.</span></span>  
  
<span data-ttu-id="7593b-470">- 或 -</span><span class="sxs-lookup"><span data-stu-id="7593b-470">-or-</span></span> 
 <span data-ttu-id="7593b-471"><paramref name="array" />.Type 表示秩不为 1 的数组类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-471"><paramref name="array" />.Type represents an array type whose rank is not 1.</span></span>  
  
<span data-ttu-id="7593b-472">- 或 -</span><span class="sxs-lookup"><span data-stu-id="7593b-472">-or-</span></span> 
 <span data-ttu-id="7593b-473"><paramref name="index" />.Type 不表示 <see cref="T:System.Int32" /> 类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-473"><paramref name="index" />.Type does not represent the <see cref="T:System.Int32" /> type.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ArrayIndex">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MethodCallExpression ArrayIndex (System.Linq.Expressions.Expression array, params System.Linq.Expressions.Expression[] indexes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MethodCallExpression ArrayIndex(class System.Linq.Expressions.Expression array, class System.Linq.Expressions.Expression[] indexes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ArrayIndex(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ArrayIndex (array As Expression, ParamArray indexes As Expression()) As MethodCallExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MethodCallExpression ^ ArrayIndex(System::Linq::Expressions::Expression ^ array, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ indexes);" />
      <MemberSignature Language="F#" Value="static member ArrayIndex : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression[] -&gt; System.Linq.Expressions.MethodCallExpression" Usage="System.Linq.Expressions.Expression.ArrayIndex (array, indexes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MethodCallExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="indexes" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="array"><span data-ttu-id="7593b-474"><see cref="T:System.Linq.Expressions.Expression" /> 实例的数组 - 数组索引操作的索引。</span><span class="sxs-lookup"><span data-stu-id="7593b-474">An array of <see cref="T:System.Linq.Expressions.Expression" /> instances - indexes for the array index operation.</span></span></param>
        <param name="indexes"><span data-ttu-id="7593b-475">用于填充 <see cref="T:System.Linq.Expressions.Expression" /> 集合的 <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> 对象的数组。</span><span class="sxs-lookup"><span data-stu-id="7593b-475">An array of <see cref="T:System.Linq.Expressions.Expression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> collection.</span></span></param>
        <summary><span data-ttu-id="7593b-476">创建一个 <see cref="T:System.Linq.Expressions.MethodCallExpression" />，它表示将数组索引运算符应用到多维数组中。</span><span class="sxs-lookup"><span data-stu-id="7593b-476">Creates a <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that represents applying an array index operator to a multidimensional array.</span></span></summary>
        <returns><span data-ttu-id="7593b-477">一个 <see cref="T:System.Linq.Expressions.MethodCallExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 属性等于 <see cref="F:System.Linq.Expressions.ExpressionType.Call" />，并且其 <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> 和 <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> 属性设置为指定值。</span><span class="sxs-lookup"><span data-stu-id="7593b-477">A <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> and the <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> and <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7593b-478">`indexes` 的每个元素必须具有等于 <xref:System.Int32>的 <xref:System.Linq.Expressions.Expression.Type%2A>。</span><span class="sxs-lookup"><span data-stu-id="7593b-478">Each element of `indexes` must have <xref:System.Linq.Expressions.Expression.Type%2A> equal to <xref:System.Int32>.</span></span> <span data-ttu-id="7593b-479">`array` 的 <xref:System.Linq.Expressions.Expression.Type%2A> 属性必须表示其秩与 `indexes`中的元素数相匹配的数组类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-479">The <xref:System.Linq.Expressions.Expression.Type%2A> property of `array` must represent an array type whose rank matches the number of elements in `indexes`.</span></span>  
  
 <span data-ttu-id="7593b-480">如果 `array`的排名。类型为1，则此方法返回 <xref:System.Linq.Expressions.BinaryExpression>。</span><span class="sxs-lookup"><span data-stu-id="7593b-480">If the rank of `array`.Type is 1, this method returns a <xref:System.Linq.Expressions.BinaryExpression>.</span></span> <span data-ttu-id="7593b-481"><xref:System.Linq.Expressions.BinaryExpression.Left%2A> 属性设置为 `array`，<xref:System.Linq.Expressions.BinaryExpression.Right%2A> 属性设置为 `indexes`的单个元素。</span><span class="sxs-lookup"><span data-stu-id="7593b-481">The <xref:System.Linq.Expressions.BinaryExpression.Left%2A> property is set to `array` and the <xref:System.Linq.Expressions.BinaryExpression.Right%2A> property is set to the single element of `indexes`.</span></span> <span data-ttu-id="7593b-482"><xref:System.Linq.Expressions.BinaryExpression> 的 <xref:System.Linq.Expressions.Expression.Type%2A> 属性表示 `array`的元素类型。类别.</span><span class="sxs-lookup"><span data-stu-id="7593b-482">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the <xref:System.Linq.Expressions.BinaryExpression> represents the element type of `array`.Type.</span></span>  
  
 <span data-ttu-id="7593b-483">如果 `array`的排名。类型不止一个，则此方法返回 <xref:System.Linq.Expressions.MethodCallExpression>。</span><span class="sxs-lookup"><span data-stu-id="7593b-483">If the rank of `array`.Type is more than one, this method returns a <xref:System.Linq.Expressions.MethodCallExpression>.</span></span> <span data-ttu-id="7593b-484"><xref:System.Linq.Expressions.MethodCallExpression.Method%2A> 属性设置为 <xref:System.Reflection.MethodInfo>，用于描述 `array`的 <xref:System.Linq.Expressions.Expression.Type%2A> 属性所表示的类型上的公共实例方法 `Get`。</span><span class="sxs-lookup"><span data-stu-id="7593b-484">The <xref:System.Linq.Expressions.MethodCallExpression.Method%2A> property is set to the <xref:System.Reflection.MethodInfo> that describes the public instance method `Get` on the type represented by the <xref:System.Linq.Expressions.Expression.Type%2A> property of `array`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="7593b-485">下面的示例演示如何使用 <xref:System.Linq.Expressions.Expression.ArrayIndex%28System.Linq.Expressions.Expression%2CSystem.Linq.Expressions.Expression%5B%5D%29> 方法来创建表示索引为二维数组的 <xref:System.Linq.Expressions.MethodCallExpression>。</span><span class="sxs-lookup"><span data-stu-id="7593b-485">The following example demonstrates how to use the <xref:System.Linq.Expressions.Expression.ArrayIndex%28System.Linq.Expressions.Expression%2CSystem.Linq.Expressions.Expression%5B%5D%29> method to create a <xref:System.Linq.Expressions.MethodCallExpression> that represents indexing into a two-dimensional array.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.Expression#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#3)]
 [!code-vb[System.Linq.Expressions.Expression#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="7593b-486"><paramref name="array" /> 或 <paramref name="indexes" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-486"><paramref name="array" /> or <paramref name="indexes" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="7593b-487"><paramref name="array" />.Type 不表示数组类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-487"><paramref name="array" />.Type does not represent an array type.</span></span>  
  
<span data-ttu-id="7593b-488">- 或 -</span><span class="sxs-lookup"><span data-stu-id="7593b-488">-or-</span></span> 
<span data-ttu-id="7593b-489"><paramref name="array" />.Type 的秩与 <paramref name="indexes" /> 中的元素数量不匹配。</span><span class="sxs-lookup"><span data-stu-id="7593b-489">The rank of <paramref name="array" />.Type does not match the number of elements in <paramref name="indexes" />.</span></span>  
  
<span data-ttu-id="7593b-490">- 或 -</span><span class="sxs-lookup"><span data-stu-id="7593b-490">-or-</span></span> 
<span data-ttu-id="7593b-491"><see cref="P:System.Linq.Expressions.Expression.Type" /> 的一个或多个元素的 <paramref name="indexes" /> 属性不表示 <see cref="T:System.Int32" /> 类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-491">The <see cref="P:System.Linq.Expressions.Expression.Type" /> property of one or more elements of <paramref name="indexes" /> does not represent the <see cref="T:System.Int32" /> type.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ArrayLength">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression ArrayLength (System.Linq.Expressions.Expression array);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression ArrayLength(class System.Linq.Expressions.Expression array) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ArrayLength(System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ArrayLength (array As Expression) As UnaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ ArrayLength(System::Linq::Expressions::Expression ^ array);" />
      <MemberSignature Language="F#" Value="static member ArrayLength : System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.ArrayLength array" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="array"><span data-ttu-id="7593b-492">要将 <see cref="T:System.Linq.Expressions.Expression" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-492">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="7593b-493">创建一个 <see cref="T:System.Linq.Expressions.UnaryExpression" />，它表示获取一维数组的长度的表达式。</span><span class="sxs-lookup"><span data-stu-id="7593b-493">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents an expression for obtaining the length of a one-dimensional array.</span></span></summary>
        <returns><span data-ttu-id="7593b-494"><see cref="T:System.Linq.Expressions.UnaryExpression" /> 的 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 属性等于 <see cref="F:System.Linq.Expressions.ExpressionType.ArrayLength" />，<see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> 属性等于 <paramref name="array" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-494">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.ArrayLength" /> and the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> property equal to <paramref name="array" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7593b-495">`array` 的 <xref:System.Linq.Expressions.Expression.Type%2A> 属性必须表示数组类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-495">The <xref:System.Linq.Expressions.Expression.Type%2A> property of `array` must represent an array type.</span></span>  
  
 <span data-ttu-id="7593b-496">生成的 <xref:System.Linq.Expressions.UnaryExpression> 的 <xref:System.Linq.Expressions.Expression.Type%2A> 属性等于 <xref:System.Int32>。</span><span class="sxs-lookup"><span data-stu-id="7593b-496">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.UnaryExpression> is equal to <xref:System.Int32>.</span></span> <span data-ttu-id="7593b-497">将 `null`<xref:System.Linq.Expressions.UnaryExpression.Method%2A> 属性，同时 <xref:System.Linq.Expressions.UnaryExpression.IsLifted%2A> 和 <xref:System.Linq.Expressions.UnaryExpression.IsLiftedToNull%2A> 均设置为 `false`。</span><span class="sxs-lookup"><span data-stu-id="7593b-497">The <xref:System.Linq.Expressions.UnaryExpression.Method%2A> property is `null`, and both <xref:System.Linq.Expressions.UnaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.UnaryExpression.IsLiftedToNull%2A> are set to `false`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="7593b-498"><paramref name="array" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-498"><paramref name="array" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="7593b-499"><paramref name="array" />.Type 不表示数组类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-499"><paramref name="array" />.Type does not represent an array type.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Assign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Assign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Assign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Assign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Assign (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Assign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member Assign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.Assign (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="7593b-500">要将 <see cref="T:System.Linq.Expressions.Expression" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-500">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="7593b-501">要将 <see cref="T:System.Linq.Expressions.Expression" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-501">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="7593b-502">创建一个表示赋值运算的 <see cref="T:System.Linq.Expressions.BinaryExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-502">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an assignment operation.</span></span></summary>
        <returns><span data-ttu-id="7593b-503">一个 <see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 属性等于 <see cref="F:System.Linq.Expressions.ExpressionType.Assign" />，并且其 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 属性设置为指定值。</span><span class="sxs-lookup"><span data-stu-id="7593b-503">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Assign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7593b-504">`Assign` 表达式复制值类型的值，并复制引用类型的引用。</span><span class="sxs-lookup"><span data-stu-id="7593b-504">The `Assign` expression copies a value for value types, and it copies a reference for reference types.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="7593b-505">下面的代码示例演示如何创建一个表示赋值运算的表达式。</span><span class="sxs-lookup"><span data-stu-id="7593b-505">The following code example shows how to create an expression that represents an assignment operation.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#12)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#12)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Bind">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="7593b-506">创建一个表示成员初始化的 <see cref="T:System.Linq.Expressions.MemberAssignment" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-506">Creates a <see cref="T:System.Linq.Expressions.MemberAssignment" /> that represents the initialization of a member.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Bind">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberAssignment Bind (System.Reflection.MemberInfo member, System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberAssignment Bind(class System.Reflection.MemberInfo member, class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Bind(System.Reflection.MemberInfo,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberAssignment ^ Bind(System::Reflection::MemberInfo ^ member, System::Linq::Expressions::Expression ^ expression);" />
      <MemberSignature Language="F#" Value="static member Bind : System.Reflection.MemberInfo * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.MemberAssignment" Usage="System.Linq.Expressions.Expression.Bind (member, expression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberAssignment</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="member" Type="System.Reflection.MemberInfo" />
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="member"><span data-ttu-id="7593b-507">要将 <see cref="T:System.Reflection.MemberInfo" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.MemberBinding.Member" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-507">A <see cref="T:System.Reflection.MemberInfo" /> to set the <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> property equal to.</span></span></param>
        <param name="expression"><span data-ttu-id="7593b-508">要将 <see cref="T:System.Linq.Expressions.Expression" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.MemberAssignment.Expression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-508">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.MemberAssignment.Expression" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="7593b-509">创建一个 <see cref="T:System.Linq.Expressions.MemberAssignment" />，它表示字段或属性的初始化。</span><span class="sxs-lookup"><span data-stu-id="7593b-509">Creates a <see cref="T:System.Linq.Expressions.MemberAssignment" /> that represents the initialization of a field or property.</span></span></summary>
        <returns><span data-ttu-id="7593b-510"><see cref="T:System.Linq.Expressions.MemberAssignment" /> 的 <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> 等于 <see cref="F:System.Linq.Expressions.MemberBindingType.Assignment" /> 且 <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> 和 <see cref="P:System.Linq.Expressions.MemberAssignment.Expression" /> 属性设置为指定值。</span><span class="sxs-lookup"><span data-stu-id="7593b-510">A <see cref="T:System.Linq.Expressions.MemberAssignment" /> that has <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> equal to <see cref="F:System.Linq.Expressions.MemberBindingType.Assignment" /> and the <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> and <see cref="P:System.Linq.Expressions.MemberAssignment.Expression" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7593b-511">`expression` 的 <xref:System.Linq.Expressions.Expression.Type%2A> 属性必须可分配给 `member`的 <xref:System.Reflection.FieldInfo.FieldType%2A> 或 <xref:System.Reflection.PropertyInfo.PropertyType%2A> 属性所表示的类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-511">The <xref:System.Linq.Expressions.Expression.Type%2A> property of `expression` must be assignable to the type represented by the <xref:System.Reflection.FieldInfo.FieldType%2A> or <xref:System.Reflection.PropertyInfo.PropertyType%2A> property of `member`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="7593b-512"><paramref name="member" /> 或 <paramref name="expression" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-512"><paramref name="member" /> or <paramref name="expression" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="7593b-513"><paramref name="member" /> 不表示字段或属性。</span><span class="sxs-lookup"><span data-stu-id="7593b-513"><paramref name="member" /> does not represent a field or property.</span></span>  
  
<span data-ttu-id="7593b-514">- 或 -</span><span class="sxs-lookup"><span data-stu-id="7593b-514">-or-</span></span> 
<span data-ttu-id="7593b-515"><paramref name="member" /> 所表示的属性没有 <see langword="set" /> 访问器。</span><span class="sxs-lookup"><span data-stu-id="7593b-515">The property represented by <paramref name="member" /> does not have a <see langword="set" /> accessor.</span></span>  
  
<span data-ttu-id="7593b-516">- 或 -</span><span class="sxs-lookup"><span data-stu-id="7593b-516">-or-</span></span> 
 <span data-ttu-id="7593b-517">不能将 <paramref name="expression" />.Type 分配给 <paramref name="member" /> 所表示的字段或属性的类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-517"><paramref name="expression" />.Type is not assignable to the type of the field or property that <paramref name="member" /> represents.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Bind">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberAssignment Bind (System.Reflection.MethodInfo propertyAccessor, System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberAssignment Bind(class System.Reflection.MethodInfo propertyAccessor, class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Bind(System.Reflection.MethodInfo,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberAssignment ^ Bind(System::Reflection::MethodInfo ^ propertyAccessor, System::Linq::Expressions::Expression ^ expression);" />
      <MemberSignature Language="F#" Value="static member Bind : System.Reflection.MethodInfo * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.MemberAssignment" Usage="System.Linq.Expressions.Expression.Bind (propertyAccessor, expression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberAssignment</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyAccessor" Type="System.Reflection.MethodInfo" />
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="propertyAccessor"><span data-ttu-id="7593b-518">一个表示属性访问器方法的 <see cref="T:System.Reflection.MethodInfo" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-518">A <see cref="T:System.Reflection.MethodInfo" /> that represents a property accessor method.</span></span></param>
        <param name="expression"><span data-ttu-id="7593b-519">要将 <see cref="T:System.Linq.Expressions.Expression" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.MemberAssignment.Expression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-519">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.MemberAssignment.Expression" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="7593b-520">使用属性访问器方法，创建一个表示成员初始化的 <see cref="T:System.Linq.Expressions.MemberAssignment" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-520">Creates a <see cref="T:System.Linq.Expressions.MemberAssignment" /> that represents the initialization of a member by using a property accessor method.</span></span></summary>
        <returns><span data-ttu-id="7593b-521"><see cref="T:System.Linq.Expressions.MemberAssignment" /> 的 <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> 属性等于 <see cref="F:System.Linq.Expressions.MemberBindingType.Assignment" />，<see cref="P:System.Linq.Expressions.MemberBinding.Member" /> 属性设置为 <see cref="T:System.Reflection.PropertyInfo" />（表示 <paramref name="propertyAccessor" /> 中访问的属性），<see cref="P:System.Linq.Expressions.MemberAssignment.Expression" /> 属性设置为 <paramref name="expression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-521">A <see cref="T:System.Linq.Expressions.MemberAssignment" /> that has the <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> property equal to <see cref="F:System.Linq.Expressions.MemberBindingType.Assignment" />, the <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> property set to the <see cref="T:System.Reflection.PropertyInfo" /> that represents the property accessed in <paramref name="propertyAccessor" />, and the <see cref="P:System.Linq.Expressions.MemberAssignment.Expression" /> property set to <paramref name="expression" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7593b-522">`expression` 的 <xref:System.Linq.Expressions.Expression.Type%2A> 属性必须可分配给在 `propertyAccessor`中访问的属性的 <xref:System.Reflection.PropertyInfo.PropertyType%2A> 属性所表示的类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-522">The <xref:System.Linq.Expressions.Expression.Type%2A> property of `expression` must be assignable to the type represented by the <xref:System.Reflection.PropertyInfo.PropertyType%2A> property of the property accessed in `propertyAccessor`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="7593b-523"><paramref name="propertyAccessor" /> 或 <paramref name="expression" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-523"><paramref name="propertyAccessor" /> or <paramref name="expression" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="7593b-524"><paramref name="propertyAccessor" /> 不表示属性访问器方法。</span><span class="sxs-lookup"><span data-stu-id="7593b-524"><paramref name="propertyAccessor" /> does not represent a property accessor method.</span></span>  
  
<span data-ttu-id="7593b-525">- 或 -</span><span class="sxs-lookup"><span data-stu-id="7593b-525">-or-</span></span> 
<span data-ttu-id="7593b-526"><paramref name="propertyAccessor" /> 访问的属性没有 <see langword="set" /> 访问器。</span><span class="sxs-lookup"><span data-stu-id="7593b-526">The property accessed by <paramref name="propertyAccessor" /> does not have a <see langword="set" /> accessor.</span></span>  
  
<span data-ttu-id="7593b-527">- 或 -</span><span class="sxs-lookup"><span data-stu-id="7593b-527">-or-</span></span> 
 <span data-ttu-id="7593b-528">不能将 <paramref name="expression" />.Type 分配给 <paramref name="member" /> 所表示的字段或属性的类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-528"><paramref name="expression" />.Type is not assignable to the type of the field or property that <paramref name="member" /> represents.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Block">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="7593b-529">创建一个 <see cref="T:System.Linq.Expressions.BlockExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-529">Creates a <see cref="T:System.Linq.Expressions.BlockExpression" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Block">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BlockExpression Block (System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; expressions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BlockExpression Block(class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; expressions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Block(System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Block (expressions As IEnumerable(Of Expression)) As BlockExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BlockExpression ^ Block(System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ expressions);" />
      <MemberSignature Language="F#" Value="static member Block : seq&lt;System.Linq.Expressions.Expression&gt; -&gt; System.Linq.Expressions.BlockExpression" Usage="System.Linq.Expressions.Expression.Block expressions" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BlockExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expressions" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="expressions"><span data-ttu-id="7593b-530">块中的表达式。</span><span class="sxs-lookup"><span data-stu-id="7593b-530">The expressions in the block.</span></span></param>
        <summary><span data-ttu-id="7593b-531">创建一个 <see cref="T:System.Linq.Expressions.BlockExpression" />，其中包含给定表达式，但不包含任何变量。</span><span class="sxs-lookup"><span data-stu-id="7593b-531">Creates a <see cref="T:System.Linq.Expressions.BlockExpression" /> that contains the given expressions and has no variables.</span></span></summary>
        <returns><span data-ttu-id="7593b-532">创建的 <see cref="T:System.Linq.Expressions.BlockExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-532">The created <see cref="T:System.Linq.Expressions.BlockExpression" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7593b-533">当执行块表达式时，它将返回块中最后一个表达式的值。</span><span class="sxs-lookup"><span data-stu-id="7593b-533">When the block expression is executed, it returns the value of the last expression in the block.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Block">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BlockExpression Block (params System.Linq.Expressions.Expression[] expressions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BlockExpression Block(class System.Linq.Expressions.Expression[] expressions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Block(System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Block (ParamArray expressions As Expression()) As BlockExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BlockExpression ^ Block(... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ expressions);" />
      <MemberSignature Language="F#" Value="static member Block : System.Linq.Expressions.Expression[] -&gt; System.Linq.Expressions.BlockExpression" Usage="System.Linq.Expressions.Expression.Block expressions" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BlockExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expressions" Type="System.Linq.Expressions.Expression[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="expressions"><span data-ttu-id="7593b-534">块中的表达式。</span><span class="sxs-lookup"><span data-stu-id="7593b-534">The expressions in the block.</span></span></param>
        <summary><span data-ttu-id="7593b-535">创建一个 <see cref="T:System.Linq.Expressions.BlockExpression" />，其中包含给定表达式，但不包含任何变量。</span><span class="sxs-lookup"><span data-stu-id="7593b-535">Creates a <see cref="T:System.Linq.Expressions.BlockExpression" /> that contains the given expressions and has no variables.</span></span></summary>
        <returns><span data-ttu-id="7593b-536">创建的 <see cref="T:System.Linq.Expressions.BlockExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-536">The created <see cref="T:System.Linq.Expressions.BlockExpression" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7593b-537">当执行块表达式时，它将返回块中最后一个表达式的值。</span><span class="sxs-lookup"><span data-stu-id="7593b-537">When the block expression is executed, it returns the value of the last expression in the block.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="7593b-538">下面的代码示例演示如何创建块表达式。</span><span class="sxs-lookup"><span data-stu-id="7593b-538">The following code example shows how to create a block expression.</span></span> <span data-ttu-id="7593b-539">块表达式包含两个 <xref:System.Linq.Expressions.MethodCallExpression> 对象和一个 <xref:System.Linq.Expressions.ConstantExpression> 对象。</span><span class="sxs-lookup"><span data-stu-id="7593b-539">The block expression consists of two <xref:System.Linq.Expressions.MethodCallExpression> objects and one <xref:System.Linq.Expressions.ConstantExpression> object.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#13)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#13)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Block">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BlockExpression Block (System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; variables, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; expressions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BlockExpression Block(class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; variables, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; expressions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Block(System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression},System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Block (variables As IEnumerable(Of ParameterExpression), expressions As IEnumerable(Of Expression)) As BlockExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BlockExpression ^ Block(System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ variables, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ expressions);" />
      <MemberSignature Language="F#" Value="static member Block : seq&lt;System.Linq.Expressions.ParameterExpression&gt; * seq&lt;System.Linq.Expressions.Expression&gt; -&gt; System.Linq.Expressions.BlockExpression" Usage="System.Linq.Expressions.Expression.Block (variables, expressions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BlockExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="variables" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="expressions" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="variables"><span data-ttu-id="7593b-540">块中的变量。</span><span class="sxs-lookup"><span data-stu-id="7593b-540">The variables in the block.</span></span></param>
        <param name="expressions"><span data-ttu-id="7593b-541">块中的表达式。</span><span class="sxs-lookup"><span data-stu-id="7593b-541">The expressions in the block.</span></span></param>
        <summary><span data-ttu-id="7593b-542">创建一个 <see cref="T:System.Linq.Expressions.BlockExpression" />，其中包含给定的变量和表达式。</span><span class="sxs-lookup"><span data-stu-id="7593b-542">Creates a <see cref="T:System.Linq.Expressions.BlockExpression" /> that contains the given variables and expressions.</span></span></summary>
        <returns><span data-ttu-id="7593b-543">创建的 <see cref="T:System.Linq.Expressions.BlockExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-543">The created <see cref="T:System.Linq.Expressions.BlockExpression" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7593b-544">当执行块表达式时，它将返回块中最后一个表达式的值。</span><span class="sxs-lookup"><span data-stu-id="7593b-544">When the block expression is executed, it returns the value of the last expression in the block.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="7593b-545">下面的代码示例演示如何将参数传递给块表达式并在块中处理此参数。</span><span class="sxs-lookup"><span data-stu-id="7593b-545">The following code example shows how to pass a parameter to a block expression and process this parameter within a block.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#14)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#14)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Block">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BlockExpression Block (System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; variables, params System.Linq.Expressions.Expression[] expressions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BlockExpression Block(class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; variables, class System.Linq.Expressions.Expression[] expressions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Block(System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression},System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Block (variables As IEnumerable(Of ParameterExpression), ParamArray expressions As Expression()) As BlockExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BlockExpression ^ Block(System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ variables, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ expressions);" />
      <MemberSignature Language="F#" Value="static member Block : seq&lt;System.Linq.Expressions.ParameterExpression&gt; * System.Linq.Expressions.Expression[] -&gt; System.Linq.Expressions.BlockExpression" Usage="System.Linq.Expressions.Expression.Block (variables, expressions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BlockExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="variables" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="expressions" Type="System.Linq.Expressions.Expression[]" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="variables"><span data-ttu-id="7593b-546">块中的变量。</span><span class="sxs-lookup"><span data-stu-id="7593b-546">The variables in the block.</span></span></param>
        <param name="expressions"><span data-ttu-id="7593b-547">块中的表达式。</span><span class="sxs-lookup"><span data-stu-id="7593b-547">The expressions in the block.</span></span></param>
        <summary><span data-ttu-id="7593b-548">创建一个 <see cref="T:System.Linq.Expressions.BlockExpression" />，其中包含给定的变量和表达式。</span><span class="sxs-lookup"><span data-stu-id="7593b-548">Creates a <see cref="T:System.Linq.Expressions.BlockExpression" /> that contains the given variables and expressions.</span></span></summary>
        <returns><span data-ttu-id="7593b-549">创建的 <see cref="T:System.Linq.Expressions.BlockExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-549">The created <see cref="T:System.Linq.Expressions.BlockExpression" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7593b-550">当执行块表达式时，它将返回块中最后一个表达式的值。</span><span class="sxs-lookup"><span data-stu-id="7593b-550">When the block expression is executed, it returns the value of the last expression in the block.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Block">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BlockExpression Block (System.Linq.Expressions.Expression arg0, System.Linq.Expressions.Expression arg1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BlockExpression Block(class System.Linq.Expressions.Expression arg0, class System.Linq.Expressions.Expression arg1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Block(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Block (arg0 As Expression, arg1 As Expression) As BlockExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BlockExpression ^ Block(System::Linq::Expressions::Expression ^ arg0, System::Linq::Expressions::Expression ^ arg1);" />
      <MemberSignature Language="F#" Value="static member Block : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BlockExpression" Usage="System.Linq.Expressions.Expression.Block (arg0, arg1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BlockExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg1" Type="System.Linq.Expressions.Expression" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="arg0"><span data-ttu-id="7593b-551">块中的第一个表达式。</span><span class="sxs-lookup"><span data-stu-id="7593b-551">The first expression in the block.</span></span></param>
        <param name="arg1"><span data-ttu-id="7593b-552">块中的第二个表达式。</span><span class="sxs-lookup"><span data-stu-id="7593b-552">The second expression in the block.</span></span></param>
        <summary><span data-ttu-id="7593b-553">创建一个 <see cref="T:System.Linq.Expressions.BlockExpression" />，其中包含两个表达式，但不包含任何变量。</span><span class="sxs-lookup"><span data-stu-id="7593b-553">Creates a <see cref="T:System.Linq.Expressions.BlockExpression" /> that contains two expressions and has no variables.</span></span></summary>
        <returns><span data-ttu-id="7593b-554">创建的 <see cref="T:System.Linq.Expressions.BlockExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-554">The created <see cref="T:System.Linq.Expressions.BlockExpression" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7593b-555">当执行块表达式时，它将返回块中最后一个表达式的值。</span><span class="sxs-lookup"><span data-stu-id="7593b-555">When the block expression is executed, it returns the value of the last expression in the block.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Block">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BlockExpression Block (Type type, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; expressions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BlockExpression Block(class System.Type type, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; expressions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Block(System.Type,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BlockExpression ^ Block(Type ^ type, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ expressions);" />
      <MemberSignature Language="F#" Value="static member Block : Type * seq&lt;System.Linq.Expressions.Expression&gt; -&gt; System.Linq.Expressions.BlockExpression" Usage="System.Linq.Expressions.Expression.Block (type, expressions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BlockExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="expressions" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="type"><span data-ttu-id="7593b-556">块的结果类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-556">The result type of the block.</span></span></param>
        <param name="expressions"><span data-ttu-id="7593b-557">块中的表达式。</span><span class="sxs-lookup"><span data-stu-id="7593b-557">The expressions in the block.</span></span></param>
        <summary><span data-ttu-id="7593b-558">创建一个 <see cref="T:System.Linq.Expressions.BlockExpression" />，其中包含给定表达式和特定结果类型，但不包含任何变量。</span><span class="sxs-lookup"><span data-stu-id="7593b-558">Creates a <see cref="T:System.Linq.Expressions.BlockExpression" /> that contains the given expressions, has no variables and has specific result type.</span></span></summary>
        <returns><span data-ttu-id="7593b-559">创建的 <see cref="T:System.Linq.Expressions.BlockExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-559">The created <see cref="T:System.Linq.Expressions.BlockExpression" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Block">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BlockExpression Block (Type type, params System.Linq.Expressions.Expression[] expressions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BlockExpression Block(class System.Type type, class System.Linq.Expressions.Expression[] expressions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Block(System.Type,System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BlockExpression ^ Block(Type ^ type, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ expressions);" />
      <MemberSignature Language="F#" Value="static member Block : Type * System.Linq.Expressions.Expression[] -&gt; System.Linq.Expressions.BlockExpression" Usage="System.Linq.Expressions.Expression.Block (type, expressions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BlockExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="expressions" Type="System.Linq.Expressions.Expression[]" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="type"><span data-ttu-id="7593b-560">块的结果类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-560">The result type of the block.</span></span></param>
        <param name="expressions"><span data-ttu-id="7593b-561">块中的表达式。</span><span class="sxs-lookup"><span data-stu-id="7593b-561">The expressions in the block.</span></span></param>
        <summary><span data-ttu-id="7593b-562">创建一个 <see cref="T:System.Linq.Expressions.BlockExpression" />，其中包含给定表达式和特定结果类型，但不包含任何变量。</span><span class="sxs-lookup"><span data-stu-id="7593b-562">Creates a <see cref="T:System.Linq.Expressions.BlockExpression" /> that contains the given expressions, has no variables and has specific result type.</span></span></summary>
        <returns><span data-ttu-id="7593b-563">创建的 <see cref="T:System.Linq.Expressions.BlockExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-563">The created <see cref="T:System.Linq.Expressions.BlockExpression" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Block">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BlockExpression Block (System.Linq.Expressions.Expression arg0, System.Linq.Expressions.Expression arg1, System.Linq.Expressions.Expression arg2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BlockExpression Block(class System.Linq.Expressions.Expression arg0, class System.Linq.Expressions.Expression arg1, class System.Linq.Expressions.Expression arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Block(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Block (arg0 As Expression, arg1 As Expression, arg2 As Expression) As BlockExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BlockExpression ^ Block(System::Linq::Expressions::Expression ^ arg0, System::Linq::Expressions::Expression ^ arg1, System::Linq::Expressions::Expression ^ arg2);" />
      <MemberSignature Language="F#" Value="static member Block : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BlockExpression" Usage="System.Linq.Expressions.Expression.Block (arg0, arg1, arg2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BlockExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg1" Type="System.Linq.Expressions.Expression" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg2" Type="System.Linq.Expressions.Expression" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="arg0"><span data-ttu-id="7593b-564">块中的第一个表达式。</span><span class="sxs-lookup"><span data-stu-id="7593b-564">The first expression in the block.</span></span></param>
        <param name="arg1"><span data-ttu-id="7593b-565">块中的第二个表达式。</span><span class="sxs-lookup"><span data-stu-id="7593b-565">The second expression in the block.</span></span></param>
        <param name="arg2"><span data-ttu-id="7593b-566">块中的第三个表达式。</span><span class="sxs-lookup"><span data-stu-id="7593b-566">The third expression in the block.</span></span></param>
        <summary><span data-ttu-id="7593b-567">创建一个 <see cref="T:System.Linq.Expressions.BlockExpression" />，其中包含三个表达式，但不包含任何变量。</span><span class="sxs-lookup"><span data-stu-id="7593b-567">Creates a <see cref="T:System.Linq.Expressions.BlockExpression" /> that contains three expressions and has no variables.</span></span></summary>
        <returns><span data-ttu-id="7593b-568">创建的 <see cref="T:System.Linq.Expressions.BlockExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-568">The created <see cref="T:System.Linq.Expressions.BlockExpression" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7593b-569">当执行块表达式时，它将返回块中最后一个表达式的值。</span><span class="sxs-lookup"><span data-stu-id="7593b-569">When the block expression is executed, it returns the value of the last expression in the block.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Block">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BlockExpression Block (Type type, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; variables, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; expressions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BlockExpression Block(class System.Type type, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; variables, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; expressions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Block(System.Type,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression},System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BlockExpression ^ Block(Type ^ type, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ variables, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ expressions);" />
      <MemberSignature Language="F#" Value="static member Block : Type * seq&lt;System.Linq.Expressions.ParameterExpression&gt; * seq&lt;System.Linq.Expressions.Expression&gt; -&gt; System.Linq.Expressions.BlockExpression" Usage="System.Linq.Expressions.Expression.Block (type, variables, expressions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BlockExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="variables" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="expressions" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="type"><span data-ttu-id="7593b-570">块的结果类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-570">The result type of the block.</span></span></param>
        <param name="variables"><span data-ttu-id="7593b-571">块中的变量。</span><span class="sxs-lookup"><span data-stu-id="7593b-571">The variables in the block.</span></span></param>
        <param name="expressions"><span data-ttu-id="7593b-572">块中的表达式。</span><span class="sxs-lookup"><span data-stu-id="7593b-572">The expressions in the block.</span></span></param>
        <summary><span data-ttu-id="7593b-573">创建一个 <see cref="T:System.Linq.Expressions.BlockExpression" />，其中包含给定的变量和表达式。</span><span class="sxs-lookup"><span data-stu-id="7593b-573">Creates a <see cref="T:System.Linq.Expressions.BlockExpression" /> that contains the given variables and expressions.</span></span></summary>
        <returns><span data-ttu-id="7593b-574">创建的 <see cref="T:System.Linq.Expressions.BlockExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-574">The created <see cref="T:System.Linq.Expressions.BlockExpression" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Block">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BlockExpression Block (Type type, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; variables, params System.Linq.Expressions.Expression[] expressions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BlockExpression Block(class System.Type type, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; variables, class System.Linq.Expressions.Expression[] expressions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Block(System.Type,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression},System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BlockExpression ^ Block(Type ^ type, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ variables, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ expressions);" />
      <MemberSignature Language="F#" Value="static member Block : Type * seq&lt;System.Linq.Expressions.ParameterExpression&gt; * System.Linq.Expressions.Expression[] -&gt; System.Linq.Expressions.BlockExpression" Usage="System.Linq.Expressions.Expression.Block (type, variables, expressions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BlockExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="variables" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="expressions" Type="System.Linq.Expressions.Expression[]" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="type"><span data-ttu-id="7593b-575">块的结果类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-575">The result type of the block.</span></span></param>
        <param name="variables"><span data-ttu-id="7593b-576">块中的变量。</span><span class="sxs-lookup"><span data-stu-id="7593b-576">The variables in the block.</span></span></param>
        <param name="expressions"><span data-ttu-id="7593b-577">块中的表达式。</span><span class="sxs-lookup"><span data-stu-id="7593b-577">The expressions in the block.</span></span></param>
        <summary><span data-ttu-id="7593b-578">创建一个 <see cref="T:System.Linq.Expressions.BlockExpression" />，其中包含给定的变量和表达式。</span><span class="sxs-lookup"><span data-stu-id="7593b-578">Creates a <see cref="T:System.Linq.Expressions.BlockExpression" /> that contains the given variables and expressions.</span></span></summary>
        <returns><span data-ttu-id="7593b-579">创建的 <see cref="T:System.Linq.Expressions.BlockExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-579">The created <see cref="T:System.Linq.Expressions.BlockExpression" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Block">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BlockExpression Block (System.Linq.Expressions.Expression arg0, System.Linq.Expressions.Expression arg1, System.Linq.Expressions.Expression arg2, System.Linq.Expressions.Expression arg3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BlockExpression Block(class System.Linq.Expressions.Expression arg0, class System.Linq.Expressions.Expression arg1, class System.Linq.Expressions.Expression arg2, class System.Linq.Expressions.Expression arg3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Block(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Block (arg0 As Expression, arg1 As Expression, arg2 As Expression, arg3 As Expression) As BlockExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BlockExpression ^ Block(System::Linq::Expressions::Expression ^ arg0, System::Linq::Expressions::Expression ^ arg1, System::Linq::Expressions::Expression ^ arg2, System::Linq::Expressions::Expression ^ arg3);" />
      <MemberSignature Language="F#" Value="static member Block : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BlockExpression" Usage="System.Linq.Expressions.Expression.Block (arg0, arg1, arg2, arg3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BlockExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg1" Type="System.Linq.Expressions.Expression" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg2" Type="System.Linq.Expressions.Expression" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg3" Type="System.Linq.Expressions.Expression" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="arg0"><span data-ttu-id="7593b-580">块中的第一个表达式。</span><span class="sxs-lookup"><span data-stu-id="7593b-580">The first expression in the block.</span></span></param>
        <param name="arg1"><span data-ttu-id="7593b-581">块中的第二个表达式。</span><span class="sxs-lookup"><span data-stu-id="7593b-581">The second expression in the block.</span></span></param>
        <param name="arg2"><span data-ttu-id="7593b-582">块中的第三个表达式。</span><span class="sxs-lookup"><span data-stu-id="7593b-582">The third expression in the block.</span></span></param>
        <param name="arg3"><span data-ttu-id="7593b-583">块中的第四个表达式。</span><span class="sxs-lookup"><span data-stu-id="7593b-583">The fourth expression in the block.</span></span></param>
        <summary><span data-ttu-id="7593b-584">创建一个 <see cref="T:System.Linq.Expressions.BlockExpression" />，其中包含四个表达式，但不包含任何变量。</span><span class="sxs-lookup"><span data-stu-id="7593b-584">Creates a <see cref="T:System.Linq.Expressions.BlockExpression" /> that contains four expressions and has no variables.</span></span></summary>
        <returns><span data-ttu-id="7593b-585">创建的 <see cref="T:System.Linq.Expressions.BlockExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-585">The created <see cref="T:System.Linq.Expressions.BlockExpression" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7593b-586">当执行块表达式时，它将返回块中最后一个表达式的值。</span><span class="sxs-lookup"><span data-stu-id="7593b-586">When the block expression is executed, it returns the value of the last expression in the block.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Block">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BlockExpression Block (System.Linq.Expressions.Expression arg0, System.Linq.Expressions.Expression arg1, System.Linq.Expressions.Expression arg2, System.Linq.Expressions.Expression arg3, System.Linq.Expressions.Expression arg4);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BlockExpression Block(class System.Linq.Expressions.Expression arg0, class System.Linq.Expressions.Expression arg1, class System.Linq.Expressions.Expression arg2, class System.Linq.Expressions.Expression arg3, class System.Linq.Expressions.Expression arg4) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Block(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Block (arg0 As Expression, arg1 As Expression, arg2 As Expression, arg3 As Expression, arg4 As Expression) As BlockExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BlockExpression ^ Block(System::Linq::Expressions::Expression ^ arg0, System::Linq::Expressions::Expression ^ arg1, System::Linq::Expressions::Expression ^ arg2, System::Linq::Expressions::Expression ^ arg3, System::Linq::Expressions::Expression ^ arg4);" />
      <MemberSignature Language="F#" Value="static member Block : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BlockExpression" Usage="System.Linq.Expressions.Expression.Block (arg0, arg1, arg2, arg3, arg4)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BlockExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg1" Type="System.Linq.Expressions.Expression" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg2" Type="System.Linq.Expressions.Expression" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg3" Type="System.Linq.Expressions.Expression" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg4" Type="System.Linq.Expressions.Expression" Index="4" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="arg0"><span data-ttu-id="7593b-587">块中的第一个表达式。</span><span class="sxs-lookup"><span data-stu-id="7593b-587">The first expression in the block.</span></span></param>
        <param name="arg1"><span data-ttu-id="7593b-588">块中的第二个表达式。</span><span class="sxs-lookup"><span data-stu-id="7593b-588">The second expression in the block.</span></span></param>
        <param name="arg2"><span data-ttu-id="7593b-589">块中的第三个表达式。</span><span class="sxs-lookup"><span data-stu-id="7593b-589">The third expression in the block.</span></span></param>
        <param name="arg3"><span data-ttu-id="7593b-590">块中的第四个表达式。</span><span class="sxs-lookup"><span data-stu-id="7593b-590">The fourth expression in the block.</span></span></param>
        <param name="arg4"><span data-ttu-id="7593b-591">块中的第五个表达式。</span><span class="sxs-lookup"><span data-stu-id="7593b-591">The fifth expression in the block.</span></span></param>
        <summary><span data-ttu-id="7593b-592">创建一个 <see cref="T:System.Linq.Expressions.BlockExpression" />，其中包含五个表达式，但不包含任何变量。</span><span class="sxs-lookup"><span data-stu-id="7593b-592">Creates a <see cref="T:System.Linq.Expressions.BlockExpression" /> that contains five expressions and has no variables.</span></span></summary>
        <returns><span data-ttu-id="7593b-593">创建的 <see cref="T:System.Linq.Expressions.BlockExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-593">The created <see cref="T:System.Linq.Expressions.BlockExpression" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7593b-594">当执行块表达式时，它将返回块中最后一个表达式的值。</span><span class="sxs-lookup"><span data-stu-id="7593b-594">When the block expression is executed, it returns the value of the last expression in the block.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Break">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="7593b-595">创建一个表示 break 语句的 <see cref="T:System.Linq.Expressions.GotoExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-595">Creates a <see cref="T:System.Linq.Expressions.GotoExpression" /> representing a break statement.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Break">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.GotoExpression Break (System.Linq.Expressions.LabelTarget target);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.GotoExpression Break(class System.Linq.Expressions.LabelTarget target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Break(System.Linq.Expressions.LabelTarget)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Break (target As LabelTarget) As GotoExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::GotoExpression ^ Break(System::Linq::Expressions::LabelTarget ^ target);" />
      <MemberSignature Language="F#" Value="static member Break : System.Linq.Expressions.LabelTarget -&gt; System.Linq.Expressions.GotoExpression" Usage="System.Linq.Expressions.Expression.Break target" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.GotoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="target"><span data-ttu-id="7593b-596"><see cref="T:System.Linq.Expressions.LabelTarget" /> 将跳至的 <see cref="T:System.Linq.Expressions.GotoExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-596">The <see cref="T:System.Linq.Expressions.LabelTarget" /> that the <see cref="T:System.Linq.Expressions.GotoExpression" /> will jump to.</span></span></param>
        <summary><span data-ttu-id="7593b-597">创建一个表示 break 语句的 <see cref="T:System.Linq.Expressions.GotoExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-597">Creates a <see cref="T:System.Linq.Expressions.GotoExpression" /> representing a break statement.</span></span></summary>
        <returns><span data-ttu-id="7593b-598">一个 <see cref="T:System.Linq.Expressions.GotoExpression" />，其 <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> 等于 Break，其 <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> 属性设置为 <paramref name="target" />，此外还有一个在跳转时将传递给目标标签的 null 值。</span><span class="sxs-lookup"><span data-stu-id="7593b-598">A <see cref="T:System.Linq.Expressions.GotoExpression" /> with <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> equal to Break, the <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> property set to <paramref name="target" />, and a null value to be passed to the target label upon jumping.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="7593b-599">下面的示例演示如何创建一个表达式，该表达式包含使用 <xref:System.Linq.Expressions.Expression.Break%2A> 方法的 <xref:System.Linq.Expressions.LoopExpression> 对象。</span><span class="sxs-lookup"><span data-stu-id="7593b-599">The following example demonstrates how to create an expression that contains a <xref:System.Linq.Expressions.LoopExpression> object that uses the <xref:System.Linq.Expressions.Expression.Break%2A> method.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#44](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#44)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#44](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#44)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Break">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.GotoExpression Break (System.Linq.Expressions.LabelTarget target, System.Linq.Expressions.Expression value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.GotoExpression Break(class System.Linq.Expressions.LabelTarget target, class System.Linq.Expressions.Expression value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Break(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Break (target As LabelTarget, value As Expression) As GotoExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::GotoExpression ^ Break(System::Linq::Expressions::LabelTarget ^ target, System::Linq::Expressions::Expression ^ value);" />
      <MemberSignature Language="F#" Value="static member Break : System.Linq.Expressions.LabelTarget * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.GotoExpression" Usage="System.Linq.Expressions.Expression.Break (target, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.GotoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="value" Type="System.Linq.Expressions.Expression" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="target"><span data-ttu-id="7593b-600"><see cref="T:System.Linq.Expressions.LabelTarget" /> 将跳至的 <see cref="T:System.Linq.Expressions.GotoExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-600">The <see cref="T:System.Linq.Expressions.LabelTarget" /> that the <see cref="T:System.Linq.Expressions.GotoExpression" /> will jump to.</span></span></param>
        <param name="value"><span data-ttu-id="7593b-601">将在跳转时传递给关联标签的值。</span><span class="sxs-lookup"><span data-stu-id="7593b-601">The value that will be passed to the associated label upon jumping.</span></span></param>
        <summary><span data-ttu-id="7593b-602">创建一个表示 break 语句的 <see cref="T:System.Linq.Expressions.GotoExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-602">Creates a <see cref="T:System.Linq.Expressions.GotoExpression" /> representing a break statement.</span></span> <span data-ttu-id="7593b-603">可以指定在跳转时传递给标签的值。</span><span class="sxs-lookup"><span data-stu-id="7593b-603">The value passed to the label upon jumping can be specified.</span></span></summary>
        <returns><span data-ttu-id="7593b-604">一个 <see cref="T:System.Linq.Expressions.GotoExpression" />，其 <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> 等于 Break，其 <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> 属性设置为 <paramref name="target" />，此外还有将在跳转时传递给目标标签的 <paramref name="value" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-604">A <see cref="T:System.Linq.Expressions.GotoExpression" /> with <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> equal to Break, the <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> property set to <paramref name="target" />, and <paramref name="value" /> to be passed to the target label upon jumping.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Break">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.GotoExpression Break (System.Linq.Expressions.LabelTarget target, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.GotoExpression Break(class System.Linq.Expressions.LabelTarget target, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Break(System.Linq.Expressions.LabelTarget,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::GotoExpression ^ Break(System::Linq::Expressions::LabelTarget ^ target, Type ^ type);" />
      <MemberSignature Language="F#" Value="static member Break : System.Linq.Expressions.LabelTarget * Type -&gt; System.Linq.Expressions.GotoExpression" Usage="System.Linq.Expressions.Expression.Break (target, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.GotoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="type" Type="System.Type" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="target"><span data-ttu-id="7593b-605"><see cref="T:System.Linq.Expressions.LabelTarget" /> 将跳至的 <see cref="T:System.Linq.Expressions.GotoExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-605">The <see cref="T:System.Linq.Expressions.LabelTarget" /> that the <see cref="T:System.Linq.Expressions.GotoExpression" /> will jump to.</span></span></param>
        <param name="type"><span data-ttu-id="7593b-606">要将 <see cref="T:System.Type" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.Expression.Type" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-606">An <see cref="T:System.Type" /> to set the <see cref="P:System.Linq.Expressions.Expression.Type" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="7593b-607">创建一个表示具有指定类型的 break 语句的 <see cref="T:System.Linq.Expressions.GotoExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-607">Creates a <see cref="T:System.Linq.Expressions.GotoExpression" /> representing a break statement with the specified type.</span></span></summary>
        <returns><span data-ttu-id="7593b-608">一个 <see cref="T:System.Linq.Expressions.GotoExpression" />，其 <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> 等于 Break，其 <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> 属性设置为 <paramref name="target" />，并且其 <see cref="P:System.Linq.Expressions.Expression.Type" /> 属性设置为 <paramref name="type" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-608">A <see cref="T:System.Linq.Expressions.GotoExpression" /> with <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> equal to Break, the <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> property set to <paramref name="target" />, and the <see cref="P:System.Linq.Expressions.Expression.Type" /> property set to <paramref name="type" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Break">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.GotoExpression Break (System.Linq.Expressions.LabelTarget target, System.Linq.Expressions.Expression value, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.GotoExpression Break(class System.Linq.Expressions.LabelTarget target, class System.Linq.Expressions.Expression value, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Break(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::GotoExpression ^ Break(System::Linq::Expressions::LabelTarget ^ target, System::Linq::Expressions::Expression ^ value, Type ^ type);" />
      <MemberSignature Language="F#" Value="static member Break : System.Linq.Expressions.LabelTarget * System.Linq.Expressions.Expression * Type -&gt; System.Linq.Expressions.GotoExpression" Usage="System.Linq.Expressions.Expression.Break (target, value, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.GotoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="value" Type="System.Linq.Expressions.Expression" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="type" Type="System.Type" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="target"><span data-ttu-id="7593b-609"><see cref="T:System.Linq.Expressions.LabelTarget" /> 将跳至的 <see cref="T:System.Linq.Expressions.GotoExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-609">The <see cref="T:System.Linq.Expressions.LabelTarget" /> that the <see cref="T:System.Linq.Expressions.GotoExpression" /> will jump to.</span></span></param>
        <param name="value"><span data-ttu-id="7593b-610">将在跳转时传递给关联标签的值。</span><span class="sxs-lookup"><span data-stu-id="7593b-610">The value that will be passed to the associated label upon jumping.</span></span></param>
        <param name="type"><span data-ttu-id="7593b-611">要将 <see cref="T:System.Type" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.Expression.Type" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-611">An <see cref="T:System.Type" /> to set the <see cref="P:System.Linq.Expressions.Expression.Type" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="7593b-612">创建一个表示具有指定类型的 break 语句的 <see cref="T:System.Linq.Expressions.GotoExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-612">Creates a <see cref="T:System.Linq.Expressions.GotoExpression" /> representing a break statement with the specified type.</span></span> <span data-ttu-id="7593b-613">可以指定在跳转时传递给标签的值。</span><span class="sxs-lookup"><span data-stu-id="7593b-613">The value passed to the label upon jumping can be specified.</span></span></summary>
        <returns><span data-ttu-id="7593b-614">一个 <see cref="T:System.Linq.Expressions.GotoExpression" />，其 <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> 等于 Break，其 <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> 属性设置为 <paramref name="target" />，并且其 <see cref="P:System.Linq.Expressions.Expression.Type" /> 属性设置为 <paramref name="type" />，此外还有一个在跳转时将传递给目标标签的 <paramref name="value" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-614">A <see cref="T:System.Linq.Expressions.GotoExpression" /> with <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> equal to Break, the <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> property set to <paramref name="target" />, the <see cref="P:System.Linq.Expressions.Expression.Type" /> property set to <paramref name="type" />, and <paramref name="value" /> to be passed to the target label upon jumping.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Call">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="7593b-615">创建一个 <see cref="T:System.Linq.Expressions.MethodCallExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-615">Creates a <see cref="T:System.Linq.Expressions.MethodCallExpression" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MethodCallExpression Call (System.Linq.Expressions.Expression instance, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MethodCallExpression Call(class System.Linq.Expressions.Expression instance, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Call(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Call (instance As Expression, method As MethodInfo) As MethodCallExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MethodCallExpression ^ Call(System::Linq::Expressions::Expression ^ instance, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member Call : System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.MethodCallExpression" Usage="System.Linq.Expressions.Expression.Call (instance, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MethodCallExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="instance"><span data-ttu-id="7593b-616">一个 <see cref="T:System.Linq.Expressions.Expression" />，它指定一个实例方法调用，对于 <see langword="null" /> 方法（在 Visual Basic 中为 <see langword="static" /> 方法）应传递 <see langword="Shared" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-616">An <see cref="T:System.Linq.Expressions.Expression" /> that specifies the instance for an instance method call (pass <see langword="null" /> for a <see langword="static" /> (<see langword="Shared" /> in Visual Basic) method).</span></span></param>
        <param name="method"><span data-ttu-id="7593b-617">要将 <see cref="T:System.Reflection.MethodInfo" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-617">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="7593b-618">创建一个 <see cref="T:System.Linq.Expressions.MethodCallExpression" />，它表示调用不带参数的方法。</span><span class="sxs-lookup"><span data-stu-id="7593b-618">Creates a <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that represents a call to a method that takes no arguments.</span></span></summary>
        <returns><span data-ttu-id="7593b-619">一个 <see cref="T:System.Linq.Expressions.MethodCallExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 属性等于 <see cref="F:System.Linq.Expressions.ExpressionType.Call" />，并且其 <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> 和 <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> 属性设置为指定值。</span><span class="sxs-lookup"><span data-stu-id="7593b-619">A <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> and the <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> and <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7593b-620">若要表示对 `static` （`Shared` Visual Basic）方法的调用，请在调用此方法时传入 `instance` 参数的 `null`。</span><span class="sxs-lookup"><span data-stu-id="7593b-620">To represent a call to a `static` (`Shared` in Visual Basic) method, pass in `null` for the `instance` parameter when you call this method.</span></span>  
  
 <span data-ttu-id="7593b-621">如果 `method` 表示实例方法，则 `instance` 的 <xref:System.Linq.Expressions.Expression.Type%2A> 属性必须分配给 `method`所表示的方法的声明类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-621">If `method` represents an instance method, the <xref:System.Linq.Expressions.Expression.Type%2A> property of `instance` must be assignable to the declaring type of the method represented by `method`.</span></span>  
  
 <span data-ttu-id="7593b-622">生成的 <xref:System.Linq.Expressions.MethodCallExpression> 的 <xref:System.Linq.Expressions.MethodCallExpression.Arguments%2A> 属性为空。</span><span class="sxs-lookup"><span data-stu-id="7593b-622">The <xref:System.Linq.Expressions.MethodCallExpression.Arguments%2A> property of the resulting <xref:System.Linq.Expressions.MethodCallExpression> is empty.</span></span> <span data-ttu-id="7593b-623"><xref:System.Linq.Expressions.Expression.Type%2A> 属性等于 `method`所表示的方法的返回类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-623">The <xref:System.Linq.Expressions.Expression.Type%2A> property is equal to the return type of the method represented by `method`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="7593b-624">下面的代码示例演示如何创建一个表达式，该表达式调用不带参数的方法。</span><span class="sxs-lookup"><span data-stu-id="7593b-624">The following code example shows how to create an expression that calls a method without arguments.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#15)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#15)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="7593b-625"><paramref name="method" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-625"><paramref name="method" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="7593b-626">- 或 -</span><span class="sxs-lookup"><span data-stu-id="7593b-626">-or-</span></span> 
 <span data-ttu-id="7593b-627"><paramref name="instance" /> 是 <see langword="null" />，且 <paramref name="method" /> 表示一种实例方法。</span><span class="sxs-lookup"><span data-stu-id="7593b-627"><paramref name="instance" /> is <see langword="null" /> and <paramref name="method" /> represents an instance method.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="7593b-628"><paramref name="instance" />.Type 不可分配给由 <paramref name="method" /> 表示的方法声明类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-628"><paramref name="instance" />.Type is not assignable to the declaring type of the method represented by <paramref name="method" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MethodCallExpression Call (System.Reflection.MethodInfo method, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MethodCallExpression Call(class System.Reflection.MethodInfo method, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Call(System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Call (method As MethodInfo, arguments As IEnumerable(Of Expression)) As MethodCallExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MethodCallExpression ^ Call(System::Reflection::MethodInfo ^ method, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberSignature Language="F#" Value="static member Call : System.Reflection.MethodInfo * seq&lt;System.Linq.Expressions.Expression&gt; -&gt; System.Linq.Expressions.MethodCallExpression" Usage="System.Linq.Expressions.Expression.Call (method, arguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MethodCallExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Reflection.MethodInfo" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arguments" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="method"><span data-ttu-id="7593b-629">表示目标方法的 <see cref="T:System.Reflection.MethodInfo" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-629">The <see cref="T:System.Reflection.MethodInfo" /> that represents the target method.</span></span></param>
        <param name="arguments"><span data-ttu-id="7593b-630">表示调用参数的 <see cref="T:System.Linq.Expressions.Expression" /> 的集合。</span><span class="sxs-lookup"><span data-stu-id="7593b-630">A collection of <see cref="T:System.Linq.Expressions.Expression" /> that represents the call arguments.</span></span></param>
        <summary><span data-ttu-id="7593b-631">创建一个 <see cref="T:System.Linq.Expressions.MethodCallExpression" />，它表示对 static 方法（在 Visual Basic 中为 Shared 方法）的调用。</span><span class="sxs-lookup"><span data-stu-id="7593b-631">Creates a <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that represents a call to a static (Shared in Visual Basic) method.</span></span></summary>
        <returns><span data-ttu-id="7593b-632">一个 <see cref="T:System.Linq.Expressions.MethodCallExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 属性等于 <see cref="F:System.Linq.Expressions.ExpressionType.Call" />，并且其 <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> 和 <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> 属性设置为指定值。</span><span class="sxs-lookup"><span data-stu-id="7593b-632">A <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> and the <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> and <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MethodCallExpression Call (System.Reflection.MethodInfo method, System.Linq.Expressions.Expression arg0);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MethodCallExpression Call(class System.Reflection.MethodInfo method, class System.Linq.Expressions.Expression arg0) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Call(System.Reflection.MethodInfo,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Call (method As MethodInfo, arg0 As Expression) As MethodCallExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MethodCallExpression ^ Call(System::Reflection::MethodInfo ^ method, System::Linq::Expressions::Expression ^ arg0);" />
      <MemberSignature Language="F#" Value="static member Call : System.Reflection.MethodInfo * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.MethodCallExpression" Usage="System.Linq.Expressions.Expression.Call (method, arg0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MethodCallExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Reflection.MethodInfo" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="method"><span data-ttu-id="7593b-633">要将 <see cref="T:System.Reflection.MethodInfo" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-633">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> property equal to.</span></span></param>
        <param name="arg0"><span data-ttu-id="7593b-634">用于表示第一个参数的 <see cref="T:System.Linq.Expressions.Expression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-634">The <see cref="T:System.Linq.Expressions.Expression" /> that represents the first argument.</span></span></param>
        <summary><span data-ttu-id="7593b-635">创建一个 <see cref="T:System.Linq.Expressions.MethodCallExpression" />，它表示对使用一个参数的 <see langword="static" /> 方法（在 Visual Basic 中为 <see langword="Shared" /> 方法）的调用。</span><span class="sxs-lookup"><span data-stu-id="7593b-635">Creates a <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that represents a call to a <see langword="static" /> (<see langword="Shared" /> in Visual Basic) method that takes one argument.</span></span></summary>
        <returns><span data-ttu-id="7593b-636">一个 <see cref="T:System.Linq.Expressions.MethodCallExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 属性等于 <see cref="F:System.Linq.Expressions.ExpressionType.Call" />，并且其 <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> 和 <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> 属性设置为指定值。</span><span class="sxs-lookup"><span data-stu-id="7593b-636">A <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> and the <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> and <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="7593b-637">下面的示例演示如何创建一个表达式，该表达式调用采用一个自变量的 `static` （`Shared` 在 Visual Basic）方法。</span><span class="sxs-lookup"><span data-stu-id="7593b-637">The following example demonstrates how to create an expression that calls a `static` (`Shared` in Visual Basic) method that takes one argument.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#16)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#16)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="7593b-638"><paramref name="method" /> 为 null。</span><span class="sxs-lookup"><span data-stu-id="7593b-638"><paramref name="method" /> is null.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MethodCallExpression Call (System.Reflection.MethodInfo method, params System.Linq.Expressions.Expression[] arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MethodCallExpression Call(class System.Reflection.MethodInfo method, class System.Linq.Expressions.Expression[] arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Call(System.Reflection.MethodInfo,System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Call (method As MethodInfo, ParamArray arguments As Expression()) As MethodCallExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MethodCallExpression ^ Call(System::Reflection::MethodInfo ^ method, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberSignature Language="F#" Value="static member Call : System.Reflection.MethodInfo * System.Linq.Expressions.Expression[] -&gt; System.Linq.Expressions.MethodCallExpression" Usage="System.Linq.Expressions.Expression.Call (method, arguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MethodCallExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="arguments" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="method"><span data-ttu-id="7593b-639"><see cref="T:System.Reflection.MethodInfo" /> 表示 <see langword="static" />（在 Visual Basic 中为 <see langword="Shared" />）方法，以将 <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> 属性设置为与其相等。</span><span class="sxs-lookup"><span data-stu-id="7593b-639">A <see cref="T:System.Reflection.MethodInfo" /> that represents a <see langword="static" /> (<see langword="Shared" /> in Visual Basic) method to set the <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> property equal to.</span></span></param>
        <param name="arguments"><span data-ttu-id="7593b-640">用于填充 <see cref="T:System.Linq.Expressions.Expression" /> 集合的 <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> 对象的数组。</span><span class="sxs-lookup"><span data-stu-id="7593b-640">An array of <see cref="T:System.Linq.Expressions.Expression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> collection.</span></span></param>
        <summary><span data-ttu-id="7593b-641">创建一个 <see cref="T:System.Linq.Expressions.MethodCallExpression" />，它表示调用有参数的 <see langword="static" />（在 Visual Basic 中为 <see langword="Shared" />）方法。</span><span class="sxs-lookup"><span data-stu-id="7593b-641">Creates a <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that represents a call to a <see langword="static" /> (<see langword="Shared" /> in Visual Basic) method that has arguments.</span></span></summary>
        <returns><span data-ttu-id="7593b-642">一个 <see cref="T:System.Linq.Expressions.MethodCallExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 属性等于 <see cref="F:System.Linq.Expressions.ExpressionType.Call" />，并且其 <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> 和 <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> 属性设置为指定值。</span><span class="sxs-lookup"><span data-stu-id="7593b-642">A <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> and the <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> and <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7593b-643">如果未 `null``arguments`，则它必须具有与 `method`所表示的方法的参数数目相同的元素数目。</span><span class="sxs-lookup"><span data-stu-id="7593b-643">If `arguments` is not `null`, it must have the same number of elements as the number of parameters for the method represented by `method`.</span></span> <span data-ttu-id="7593b-644">`arguments` 中的每个元素都不能 `null` 并且必须可分配给 `method`的相应参数，可能在加*引号*后。</span><span class="sxs-lookup"><span data-stu-id="7593b-644">Each element in `arguments` must not be `null` and must be assignable to the corresponding parameter of `method`, possibly after *quoting*.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="7593b-645">仅当对应的方法参数为类型 <xref:System.Linq.Expressions.Expression>时，才会将元素括起来。</span><span class="sxs-lookup"><span data-stu-id="7593b-645">An element will be quoted only if the corresponding method parameter is of type <xref:System.Linq.Expressions.Expression>.</span></span> <span data-ttu-id="7593b-646">引号表示元素包装在 <xref:System.Linq.Expressions.ExpressionType.Quote> 节点中。</span><span class="sxs-lookup"><span data-stu-id="7593b-646">Quoting means the element is wrapped in a <xref:System.Linq.Expressions.ExpressionType.Quote> node.</span></span> <span data-ttu-id="7593b-647">生成的节点是一个 <xref:System.Linq.Expressions.UnaryExpression>，其 <xref:System.Linq.Expressions.UnaryExpression.Operand%2A> 属性是 `arguments`的元素。</span><span class="sxs-lookup"><span data-stu-id="7593b-647">The resulting node is a <xref:System.Linq.Expressions.UnaryExpression> whose <xref:System.Linq.Expressions.UnaryExpression.Operand%2A> property is the element of `arguments`.</span></span>  
  
 <span data-ttu-id="7593b-648">如果 `null``arguments`，则生成的 <xref:System.Linq.Expressions.MethodCallExpression> 的 <xref:System.Linq.Expressions.MethodCallExpression.Arguments%2A> 属性为空。</span><span class="sxs-lookup"><span data-stu-id="7593b-648">The <xref:System.Linq.Expressions.MethodCallExpression.Arguments%2A> property of the resulting <xref:System.Linq.Expressions.MethodCallExpression> is empty if `arguments` is `null`.</span></span> <span data-ttu-id="7593b-649">否则，它包含与 `arguments`相同的元素，其中的某些元素可能括在引号中。</span><span class="sxs-lookup"><span data-stu-id="7593b-649">Otherwise, it contains the same elements as `arguments`, some of which may be quoted.</span></span>  
  
 <span data-ttu-id="7593b-650">生成的 <xref:System.Linq.Expressions.MethodCallExpression> 的 <xref:System.Linq.Expressions.Expression.Type%2A> 属性等于 `method`所表示的方法的返回类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-650">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.MethodCallExpression> is equal to the return type of the method represented by `method`.</span></span> <span data-ttu-id="7593b-651"><xref:System.Linq.Expressions.MethodCallExpression.Object%2A> 属性为 `null`。</span><span class="sxs-lookup"><span data-stu-id="7593b-651">The <xref:System.Linq.Expressions.MethodCallExpression.Object%2A> property is `null`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="7593b-652"><paramref name="method" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-652"><paramref name="method" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="7593b-653"><paramref name="arguments" /> 中的元素数量与 <paramref name="method" /> 表示的方法的参数数量不相等。</span><span class="sxs-lookup"><span data-stu-id="7593b-653">The number of elements in <paramref name="arguments" /> does not equal the number of parameters for the method represented by <paramref name="method" />.</span></span>  
  
<span data-ttu-id="7593b-654">- 或 -</span><span class="sxs-lookup"><span data-stu-id="7593b-654">-or-</span></span> 
<span data-ttu-id="7593b-655">无法将 <paramref name="arguments" /> 的一个或多个元素分配给由 <paramref name="method" /> 表示的方法的相应参数。</span><span class="sxs-lookup"><span data-stu-id="7593b-655">One or more of the elements of <paramref name="arguments" /> is not assignable to the corresponding parameter for the method represented by <paramref name="method" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MethodCallExpression Call (System.Linq.Expressions.Expression instance, System.Reflection.MethodInfo method, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MethodCallExpression Call(class System.Linq.Expressions.Expression instance, class System.Reflection.MethodInfo method, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Call(System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Call (instance As Expression, method As MethodInfo, arguments As IEnumerable(Of Expression)) As MethodCallExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MethodCallExpression ^ Call(System::Linq::Expressions::Expression ^ instance, System::Reflection::MethodInfo ^ method, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberSignature Language="F#" Value="static member Call : System.Linq.Expressions.Expression * System.Reflection.MethodInfo * seq&lt;System.Linq.Expressions.Expression&gt; -&gt; System.Linq.Expressions.MethodCallExpression" Usage="System.Linq.Expressions.Expression.Call (instance, method, arguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MethodCallExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="arguments" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="instance"><span data-ttu-id="7593b-656">要将 <see cref="T:System.Linq.Expressions.Expression" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" />，它为 <see langword="null" />（在 Visual Basic 中则为<see langword="static" />）方法传递 <see langword="Shared" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-656">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> property equal to (pass <see langword="null" /> for a <see langword="static" /> (<see langword="Shared" /> in Visual Basic) method).</span></span></param>
        <param name="method"><span data-ttu-id="7593b-657">要将 <see cref="T:System.Reflection.MethodInfo" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-657">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> property equal to.</span></span></param>
        <param name="arguments"><span data-ttu-id="7593b-658">一个 <see cref="T:System.Collections.Generic.IEnumerable`1" />，包含用来填充 <see cref="T:System.Linq.Expressions.Expression" /> 集合的 <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> 对象。</span><span class="sxs-lookup"><span data-stu-id="7593b-658">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.Expression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> collection.</span></span></param>
        <summary><span data-ttu-id="7593b-659">创建一个表示调用带参数的方法的 <see cref="T:System.Linq.Expressions.MethodCallExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-659">Creates a <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that represents a call to a method that takes arguments.</span></span></summary>
        <returns><span data-ttu-id="7593b-660">一个 <see cref="T:System.Linq.Expressions.MethodCallExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 属性等于 <see cref="F:System.Linq.Expressions.ExpressionType.Call" />，并且其 <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" />、<see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> 和 <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> 属性设置为指定值。</span><span class="sxs-lookup"><span data-stu-id="7593b-660">A <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> and the <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" />, <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" />, and <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7593b-661">若要表示对 `static` （`Shared` Visual Basic）方法的调用，请在调用此方法时传入 `instance` 参数的 `null`，或改为调用 <xref:System.Linq.Expressions.Expression.Call%2A>。</span><span class="sxs-lookup"><span data-stu-id="7593b-661">To represent a call to a `static` (`Shared` in Visual Basic) method, pass in `null` for the `instance` parameter when you call this method, or call <xref:System.Linq.Expressions.Expression.Call%2A> instead.</span></span>  
  
 <span data-ttu-id="7593b-662">如果 `method` 表示实例方法，则 `instance` 的 <xref:System.Linq.Expressions.Expression.Type%2A> 属性必须分配给 `method`所表示的方法的声明类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-662">If `method` represents an instance method, the <xref:System.Linq.Expressions.Expression.Type%2A> property of `instance` must be assignable to the declaring type of the method represented by `method`.</span></span>  
  
 <span data-ttu-id="7593b-663">如果未 `null``arguments`，则它必须具有与 `method`所表示的方法的参数数目相同的元素数目。</span><span class="sxs-lookup"><span data-stu-id="7593b-663">If `arguments` is not `null`, it must have the same number of elements as the number of parameters for the method represented by `method`.</span></span> <span data-ttu-id="7593b-664">`arguments` 中的每个元素都不能 `null` 并且必须可分配给 `method`的相应参数，可能在加*引号*后。</span><span class="sxs-lookup"><span data-stu-id="7593b-664">Each element in `arguments` must not be `null` and must be assignable to the corresponding parameter of `method`, possibly after *quoting*.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="7593b-665">仅当对应的方法参数为类型 <xref:System.Linq.Expressions.Expression>时，才会将元素括起来。</span><span class="sxs-lookup"><span data-stu-id="7593b-665">An element will be quoted only if the corresponding method parameter is of type <xref:System.Linq.Expressions.Expression>.</span></span> <span data-ttu-id="7593b-666">引号表示元素包装在 <xref:System.Linq.Expressions.ExpressionType.Quote> 节点中。</span><span class="sxs-lookup"><span data-stu-id="7593b-666">Quoting means the element is wrapped in a <xref:System.Linq.Expressions.ExpressionType.Quote> node.</span></span> <span data-ttu-id="7593b-667">生成的节点是一个 <xref:System.Linq.Expressions.UnaryExpression>，其 <xref:System.Linq.Expressions.UnaryExpression.Operand%2A> 属性是 `arguments`的元素。</span><span class="sxs-lookup"><span data-stu-id="7593b-667">The resulting node is a <xref:System.Linq.Expressions.UnaryExpression> whose <xref:System.Linq.Expressions.UnaryExpression.Operand%2A> property is the element of `arguments`.</span></span>  
  
 <span data-ttu-id="7593b-668">如果 `null``arguments`，则生成的 <xref:System.Linq.Expressions.MethodCallExpression> 的 <xref:System.Linq.Expressions.MethodCallExpression.Arguments%2A> 属性为空。</span><span class="sxs-lookup"><span data-stu-id="7593b-668">The <xref:System.Linq.Expressions.MethodCallExpression.Arguments%2A> property of the resulting <xref:System.Linq.Expressions.MethodCallExpression> is empty if `arguments` is `null`.</span></span> <span data-ttu-id="7593b-669">否则，它包含与 `arguments`相同的元素，其中的某些元素可能括在引号中。</span><span class="sxs-lookup"><span data-stu-id="7593b-669">Otherwise, it contains the same elements as `arguments`, some of which may be quoted.</span></span>  
  
 <span data-ttu-id="7593b-670">生成的 <xref:System.Linq.Expressions.MethodCallExpression> 的 <xref:System.Linq.Expressions.Expression.Type%2A> 属性等于 `method`所表示的方法的返回类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-670">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.MethodCallExpression> is equal to the return type of the method represented by `method`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="7593b-671"><paramref name="method" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-671"><paramref name="method" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="7593b-672">- 或 -</span><span class="sxs-lookup"><span data-stu-id="7593b-672">-or-</span></span> 
 <span data-ttu-id="7593b-673"><paramref name="instance" /> 是 <see langword="null" />，且 <paramref name="method" /> 表示一种实例方法。</span><span class="sxs-lookup"><span data-stu-id="7593b-673"><paramref name="instance" /> is <see langword="null" /> and <paramref name="method" /> represents an instance method.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="7593b-674"><paramref name="instance" />.Type 不可分配给由 <paramref name="method" /> 表示的方法声明类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-674"><paramref name="instance" />.Type is not assignable to the declaring type of the method represented by <paramref name="method" />.</span></span>  
  
<span data-ttu-id="7593b-675">- 或 -</span><span class="sxs-lookup"><span data-stu-id="7593b-675">-or-</span></span> 
<span data-ttu-id="7593b-676"><paramref name="arguments" /> 中的元素数量与 <paramref name="method" /> 表示的方法的参数数量不相等。</span><span class="sxs-lookup"><span data-stu-id="7593b-676">The number of elements in <paramref name="arguments" /> does not equal the number of parameters for the method represented by <paramref name="method" />.</span></span>  
  
<span data-ttu-id="7593b-677">- 或 -</span><span class="sxs-lookup"><span data-stu-id="7593b-677">-or-</span></span> 
<span data-ttu-id="7593b-678">无法将 <paramref name="arguments" /> 的一个或多个元素分配给由 <paramref name="method" /> 表示的方法的相应参数。</span><span class="sxs-lookup"><span data-stu-id="7593b-678">One or more of the elements of <paramref name="arguments" /> is not assignable to the corresponding parameter for the method represented by <paramref name="method" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MethodCallExpression Call (System.Linq.Expressions.Expression instance, System.Reflection.MethodInfo method, params System.Linq.Expressions.Expression[] arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MethodCallExpression Call(class System.Linq.Expressions.Expression instance, class System.Reflection.MethodInfo method, class System.Linq.Expressions.Expression[] arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Call(System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Call (instance As Expression, method As MethodInfo, ParamArray arguments As Expression()) As MethodCallExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MethodCallExpression ^ Call(System::Linq::Expressions::Expression ^ instance, System::Reflection::MethodInfo ^ method, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberSignature Language="F#" Value="static member Call : System.Linq.Expressions.Expression * System.Reflection.MethodInfo * System.Linq.Expressions.Expression[] -&gt; System.Linq.Expressions.MethodCallExpression" Usage="System.Linq.Expressions.Expression.Call (instance, method, arguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MethodCallExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="arguments" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="instance"><span data-ttu-id="7593b-679">一个 <see cref="T:System.Linq.Expressions.Expression" />，它指定一个实例方法调用，对于 <see langword="null" /> 方法（在 Visual Basic 中为 <see langword="static" /> 方法）应传递 <see langword="Shared" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-679">An <see cref="T:System.Linq.Expressions.Expression" /> that specifies the instance for an instance method call (pass <see langword="null" /> for a <see langword="static" /> (<see langword="Shared" /> in Visual Basic) method).</span></span></param>
        <param name="method"><span data-ttu-id="7593b-680">要将 <see cref="T:System.Reflection.MethodInfo" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-680">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> property equal to.</span></span></param>
        <param name="arguments"><span data-ttu-id="7593b-681">用于填充 <see cref="T:System.Linq.Expressions.Expression" /> 集合的 <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> 对象的数组。</span><span class="sxs-lookup"><span data-stu-id="7593b-681">An array of <see cref="T:System.Linq.Expressions.Expression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> collection.</span></span></param>
        <summary><span data-ttu-id="7593b-682">创建一个表示调用带参数的方法的 <see cref="T:System.Linq.Expressions.MethodCallExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-682">Creates a <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that represents a call to a method that takes arguments.</span></span></summary>
        <returns><span data-ttu-id="7593b-683">一个 <see cref="T:System.Linq.Expressions.MethodCallExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 属性等于 <see cref="F:System.Linq.Expressions.ExpressionType.Call" />，并且其 <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" />、<see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> 和 <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> 属性设置为指定值。</span><span class="sxs-lookup"><span data-stu-id="7593b-683">A <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> and the <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" />, <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" />, and <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7593b-684">若要表示对 `static` （`Shared` Visual Basic）方法的调用，请在调用此方法时传入 `instance` 参数的 `null`，或改为调用 <xref:System.Linq.Expressions.Expression.Call%2A>。</span><span class="sxs-lookup"><span data-stu-id="7593b-684">To represent a call to a `static` (`Shared` in Visual Basic) method, pass in `null` for the `instance` parameter when you call this method, or call <xref:System.Linq.Expressions.Expression.Call%2A> instead.</span></span>  
  
 <span data-ttu-id="7593b-685">如果 `method` 表示实例方法，则 `instance` 的 <xref:System.Linq.Expressions.Expression.Type%2A> 属性必须分配给 `method`所表示的方法的声明类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-685">If `method` represents an instance method, the <xref:System.Linq.Expressions.Expression.Type%2A> property of `instance` must be assignable to the declaring type of the method represented by `method`.</span></span>  
  
 <span data-ttu-id="7593b-686">如果未 `null``arguments`，则它必须具有与 `method`所表示的方法的参数数目相同的元素数目。</span><span class="sxs-lookup"><span data-stu-id="7593b-686">If `arguments` is not `null`, it must have the same number of elements as the number of parameters for the method represented by `method`.</span></span> <span data-ttu-id="7593b-687">`arguments` 中的每个元素都不能 `null` 并且必须可分配给 `method`的相应参数，可能在加*引号*后。</span><span class="sxs-lookup"><span data-stu-id="7593b-687">Each element in `arguments` must not be `null` and must be assignable to the corresponding parameter of `method`, possibly after *quoting*.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="7593b-688">仅当对应的方法参数为类型 <xref:System.Linq.Expressions.Expression>时，才会将元素括起来。</span><span class="sxs-lookup"><span data-stu-id="7593b-688">An element will be quoted only if the corresponding method parameter is of type <xref:System.Linq.Expressions.Expression>.</span></span> <span data-ttu-id="7593b-689">引号表示元素包装在 <xref:System.Linq.Expressions.ExpressionType.Quote> 节点中。</span><span class="sxs-lookup"><span data-stu-id="7593b-689">Quoting means the element is wrapped in a <xref:System.Linq.Expressions.ExpressionType.Quote> node.</span></span> <span data-ttu-id="7593b-690">生成的节点是一个 <xref:System.Linq.Expressions.UnaryExpression>，其 <xref:System.Linq.Expressions.UnaryExpression.Operand%2A> 属性是 `arguments`的元素。</span><span class="sxs-lookup"><span data-stu-id="7593b-690">The resulting node is a <xref:System.Linq.Expressions.UnaryExpression> whose <xref:System.Linq.Expressions.UnaryExpression.Operand%2A> property is the element of `arguments`.</span></span>  
  
 <span data-ttu-id="7593b-691">如果 `null``arguments`，则生成的 <xref:System.Linq.Expressions.MethodCallExpression> 的 <xref:System.Linq.Expressions.MethodCallExpression.Arguments%2A> 属性为空。</span><span class="sxs-lookup"><span data-stu-id="7593b-691">The <xref:System.Linq.Expressions.MethodCallExpression.Arguments%2A> property of the resulting <xref:System.Linq.Expressions.MethodCallExpression> is empty if `arguments` is `null`.</span></span> <span data-ttu-id="7593b-692">否则，它包含与 `arguments`相同的元素，其中的某些元素可能括在引号中。</span><span class="sxs-lookup"><span data-stu-id="7593b-692">Otherwise, it contains the same elements as `arguments`, some of which may be quoted.</span></span>  
  
 <span data-ttu-id="7593b-693">生成的 <xref:System.Linq.Expressions.MethodCallExpression> 的 <xref:System.Linq.Expressions.Expression.Type%2A> 属性等于 `method`所表示的方法的返回类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-693">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.MethodCallExpression> is equal to the return type of the method represented by `method`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="7593b-694"><paramref name="method" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-694"><paramref name="method" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="7593b-695">- 或 -</span><span class="sxs-lookup"><span data-stu-id="7593b-695">-or-</span></span> 
 <span data-ttu-id="7593b-696"><paramref name="instance" /> 是 <see langword="null" />，且 <paramref name="method" /> 表示一种实例方法。</span><span class="sxs-lookup"><span data-stu-id="7593b-696"><paramref name="instance" /> is <see langword="null" /> and <paramref name="method" /> represents an instance method.</span></span>  
  
<span data-ttu-id="7593b-697">- 或 -</span><span class="sxs-lookup"><span data-stu-id="7593b-697">-or-</span></span> 
 <span data-ttu-id="7593b-698"><paramref name="arguments" /> 不是 <see langword="null" />，其中一个或多个元素是 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-698"><paramref name="arguments" /> is not <see langword="null" /> and one or more of its elements is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="7593b-699"><paramref name="instance" />.Type 不可分配给由 <paramref name="method" /> 表示的方法声明类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-699"><paramref name="instance" />.Type is not assignable to the declaring type of the method represented by <paramref name="method" />.</span></span>  
  
<span data-ttu-id="7593b-700">- 或 -</span><span class="sxs-lookup"><span data-stu-id="7593b-700">-or-</span></span> 
<span data-ttu-id="7593b-701"><paramref name="arguments" /> 中的元素数量与 <paramref name="method" /> 表示的方法的参数数量不相等。</span><span class="sxs-lookup"><span data-stu-id="7593b-701">The number of elements in <paramref name="arguments" /> does not equal the number of parameters for the method represented by <paramref name="method" />.</span></span>  
  
<span data-ttu-id="7593b-702">- 或 -</span><span class="sxs-lookup"><span data-stu-id="7593b-702">-or-</span></span> 
<span data-ttu-id="7593b-703">无法将 <paramref name="arguments" /> 的一个或多个元素分配给由 <paramref name="method" /> 表示的方法的相应参数。</span><span class="sxs-lookup"><span data-stu-id="7593b-703">One or more of the elements of <paramref name="arguments" /> is not assignable to the corresponding parameter for the method represented by <paramref name="method" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MethodCallExpression Call (System.Reflection.MethodInfo method, System.Linq.Expressions.Expression arg0, System.Linq.Expressions.Expression arg1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MethodCallExpression Call(class System.Reflection.MethodInfo method, class System.Linq.Expressions.Expression arg0, class System.Linq.Expressions.Expression arg1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Call(System.Reflection.MethodInfo,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Call (method As MethodInfo, arg0 As Expression, arg1 As Expression) As MethodCallExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MethodCallExpression ^ Call(System::Reflection::MethodInfo ^ method, System::Linq::Expressions::Expression ^ arg0, System::Linq::Expressions::Expression ^ arg1);" />
      <MemberSignature Language="F#" Value="static member Call : System.Reflection.MethodInfo * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.MethodCallExpression" Usage="System.Linq.Expressions.Expression.Call (method, arg0, arg1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MethodCallExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Reflection.MethodInfo" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg1" Type="System.Linq.Expressions.Expression" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="method"><span data-ttu-id="7593b-704">要将 <see cref="T:System.Reflection.MethodInfo" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-704">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> property equal to.</span></span></param>
        <param name="arg0"><span data-ttu-id="7593b-705">用于表示第一个参数的 <see cref="T:System.Linq.Expressions.Expression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-705">The <see cref="T:System.Linq.Expressions.Expression" /> that represents the first argument.</span></span></param>
        <param name="arg1"><span data-ttu-id="7593b-706">用于表示第二个参数的 <see cref="T:System.Linq.Expressions.Expression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-706">The <see cref="T:System.Linq.Expressions.Expression" /> that represents the second argument.</span></span></param>
        <summary><span data-ttu-id="7593b-707">创建一个 <see cref="T:System.Linq.Expressions.MethodCallExpression" />，它表示对使用两个参数的静态方法的调用。</span><span class="sxs-lookup"><span data-stu-id="7593b-707">Creates a <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that represents a call to a static method that takes two arguments.</span></span></summary>
        <returns><span data-ttu-id="7593b-708">一个 <see cref="T:System.Linq.Expressions.MethodCallExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 属性等于 <see cref="F:System.Linq.Expressions.ExpressionType.Call" />，并且其 <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> 和 <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> 属性设置为指定值。</span><span class="sxs-lookup"><span data-stu-id="7593b-708">A <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> and the <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> and <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="7593b-709"><paramref name="method" /> 为 null。</span><span class="sxs-lookup"><span data-stu-id="7593b-709"><paramref name="method" /> is null.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MethodCallExpression Call (System.Linq.Expressions.Expression instance, System.Reflection.MethodInfo method, System.Linq.Expressions.Expression arg0, System.Linq.Expressions.Expression arg1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MethodCallExpression Call(class System.Linq.Expressions.Expression instance, class System.Reflection.MethodInfo method, class System.Linq.Expressions.Expression arg0, class System.Linq.Expressions.Expression arg1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Call(System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Call (instance As Expression, method As MethodInfo, arg0 As Expression, arg1 As Expression) As MethodCallExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MethodCallExpression ^ Call(System::Linq::Expressions::Expression ^ instance, System::Reflection::MethodInfo ^ method, System::Linq::Expressions::Expression ^ arg0, System::Linq::Expressions::Expression ^ arg1);" />
      <MemberSignature Language="F#" Value="static member Call : System.Linq.Expressions.Expression * System.Reflection.MethodInfo * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.MethodCallExpression" Usage="System.Linq.Expressions.Expression.Call (instance, method, arg0, arg1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MethodCallExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Linq.Expressions.Expression" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg1" Type="System.Linq.Expressions.Expression" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="instance"><span data-ttu-id="7593b-710">指定一个实例调用的实例的 <see cref="T:System.Linq.Expressions.Expression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-710">An <see cref="T:System.Linq.Expressions.Expression" /> that specifies the instance for an instance call.</span></span> <span data-ttu-id="7593b-711">（对于 static 方法（在 Visual Basic 中为 Shared 方法）应传递 null）。</span><span class="sxs-lookup"><span data-stu-id="7593b-711">(pass null for a static (Shared in Visual Basic) method).</span></span></param>
        <param name="method"><span data-ttu-id="7593b-712">表示目标方法的 <see cref="T:System.Reflection.MethodInfo" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-712">The <see cref="T:System.Reflection.MethodInfo" /> that represents the target method.</span></span></param>
        <param name="arg0"><span data-ttu-id="7593b-713">用于表示第一个参数的 <see cref="T:System.Linq.Expressions.Expression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-713">The <see cref="T:System.Linq.Expressions.Expression" /> that represents the first argument.</span></span></param>
        <param name="arg1"><span data-ttu-id="7593b-714">用于表示第二个参数的 <see cref="T:System.Linq.Expressions.Expression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-714">The <see cref="T:System.Linq.Expressions.Expression" /> that represents the second argument.</span></span></param>
        <summary><span data-ttu-id="7593b-715">创建一个 <see cref="T:System.Linq.Expressions.MethodCallExpression" />，它表示对采用两个参数的方法的调用。</span><span class="sxs-lookup"><span data-stu-id="7593b-715">Creates a <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that represents a call to a method that takes two arguments.</span></span></summary>
        <returns><span data-ttu-id="7593b-716">一个 <see cref="T:System.Linq.Expressions.MethodCallExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 属性等于 <see cref="F:System.Linq.Expressions.ExpressionType.Call" />，并且其 <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> 和 <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> 属性设置为指定值。</span><span class="sxs-lookup"><span data-stu-id="7593b-716">A <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> and the <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> and <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="7593b-717">下面的代码示例演示如何创建一个表达式，该表达式调用具有两个参数的实例方法。</span><span class="sxs-lookup"><span data-stu-id="7593b-717">The following code example shows how to create an expression that calls an instance method that has two arguments.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#17](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#17)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#17](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#17)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MethodCallExpression Call (System.Linq.Expressions.Expression instance, string methodName, Type[] typeArguments, params System.Linq.Expressions.Expression[] arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MethodCallExpression Call(class System.Linq.Expressions.Expression instance, string methodName, class System.Type[] typeArguments, class System.Linq.Expressions.Expression[] arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Call(System.Linq.Expressions.Expression,System.String,System.Type[],System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Call (instance As Expression, methodName As String, typeArguments As Type(), ParamArray arguments As Expression()) As MethodCallExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MethodCallExpression ^ Call(System::Linq::Expressions::Expression ^ instance, System::String ^ methodName, cli::array &lt;Type ^&gt; ^ typeArguments, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberSignature Language="F#" Value="static member Call : System.Linq.Expressions.Expression * string * Type[] * System.Linq.Expressions.Expression[] -&gt; System.Linq.Expressions.MethodCallExpression" Usage="System.Linq.Expressions.Expression.Call (instance, methodName, typeArguments, arguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MethodCallExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="methodName" Type="System.String" />
        <Parameter Name="typeArguments" Type="System.Type[]" />
        <Parameter Name="arguments" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="instance"><span data-ttu-id="7593b-718">将搜索 <see cref="T:System.Linq.Expressions.Expression" /> 的 <see cref="P:System.Linq.Expressions.Expression.Type" /> 属性值，查看其是否有特定方法。</span><span class="sxs-lookup"><span data-stu-id="7593b-718">An <see cref="T:System.Linq.Expressions.Expression" /> whose <see cref="P:System.Linq.Expressions.Expression.Type" /> property value will be searched for a specific method.</span></span></param>
        <param name="methodName"><span data-ttu-id="7593b-719">方法的名称。</span><span class="sxs-lookup"><span data-stu-id="7593b-719">The name of the method.</span></span></param>
        <param name="typeArguments"><span data-ttu-id="7593b-720">指定泛型方法的类型参数的 <see cref="T:System.Type" /> 对象的数组。</span><span class="sxs-lookup"><span data-stu-id="7593b-720">An array of <see cref="T:System.Type" /> objects that specify the type parameters of the generic method.</span></span> <span data-ttu-id="7593b-721">当 methodName 指定非泛型方法时，此参数应为 null。</span><span class="sxs-lookup"><span data-stu-id="7593b-721">This argument should be null when methodName specifies a non-generic method.</span></span></param>
        <param name="arguments"><span data-ttu-id="7593b-722"><see cref="T:System.Linq.Expressions.Expression" /> 对象的数组，表示方法的自变量。</span><span class="sxs-lookup"><span data-stu-id="7593b-722">An array of <see cref="T:System.Linq.Expressions.Expression" /> objects that represents the arguments to the method.</span></span></param>
        <summary><span data-ttu-id="7593b-723">通过调用合适的工厂方法，创建一个 <see cref="T:System.Linq.Expressions.MethodCallExpression" />，它表示方法调用。</span><span class="sxs-lookup"><span data-stu-id="7593b-723">Creates a <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that represents a call to a method by calling the appropriate factory method.</span></span></summary>
        <returns><span data-ttu-id="7593b-724"><see cref="T:System.Linq.Expressions.MethodCallExpression" /> 的 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 属性等于 <see cref="F:System.Linq.Expressions.ExpressionType.Call" />，<see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> 属性等于 <paramref name="instance" />，<see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> 设置为表示指定实例方法的 <see cref="T:System.Reflection.MethodInfo" /> 且 <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> 设置为指定自变量。</span><span class="sxs-lookup"><span data-stu-id="7593b-724">A <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Call" />, the <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> property equal to <paramref name="instance" />, <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> set to the <see cref="T:System.Reflection.MethodInfo" /> that represents the specified instance method, and <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> set to the specified arguments.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7593b-725">生成的 <xref:System.Linq.Expressions.MethodCallExpression> 的 <xref:System.Linq.Expressions.Expression.Type%2A> 属性等于 `methodName`所表示的方法的返回类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-725">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.MethodCallExpression> is equal to the return type of the method denoted by `methodName`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="7593b-726"><paramref name="instance" /> 或 <paramref name="methodName" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-726"><paramref name="instance" /> or <paramref name="methodName" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="7593b-727">在 <paramref name="methodName" />.Type 或其基类型中找不到这样的方法：名称为 <paramref name="typeArguments" />、类型参数与 <paramref name="arguments" /> 相匹配，且参数类型与 <paramref name="instance" /> 相匹配。</span><span class="sxs-lookup"><span data-stu-id="7593b-727">No method whose name is <paramref name="methodName" />, whose type parameters match <paramref name="typeArguments" />, and whose parameter types match <paramref name="arguments" /> is found in <paramref name="instance" />.Type or its base types.</span></span>  
  
<span data-ttu-id="7593b-728">- 或 -</span><span class="sxs-lookup"><span data-stu-id="7593b-728">-or-</span></span> 
<span data-ttu-id="7593b-729">在 <paramref name="methodName" />.Type 或其基类型中找到多个这样的方法：名称为 <paramref name="typeArguments" />，类型参数与 <paramref name="arguments" /> 相匹配，参数类型与 <paramref name="instance" /> 相匹配。</span><span class="sxs-lookup"><span data-stu-id="7593b-729">More than one method whose name is <paramref name="methodName" />, whose type parameters match <paramref name="typeArguments" />, and whose parameter types match <paramref name="arguments" /> is found in <paramref name="instance" />.Type or its base types.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MethodCallExpression Call (System.Reflection.MethodInfo method, System.Linq.Expressions.Expression arg0, System.Linq.Expressions.Expression arg1, System.Linq.Expressions.Expression arg2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MethodCallExpression Call(class System.Reflection.MethodInfo method, class System.Linq.Expressions.Expression arg0, class System.Linq.Expressions.Expression arg1, class System.Linq.Expressions.Expression arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Call(System.Reflection.MethodInfo,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Call (method As MethodInfo, arg0 As Expression, arg1 As Expression, arg2 As Expression) As MethodCallExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MethodCallExpression ^ Call(System::Reflection::MethodInfo ^ method, System::Linq::Expressions::Expression ^ arg0, System::Linq::Expressions::Expression ^ arg1, System::Linq::Expressions::Expression ^ arg2);" />
      <MemberSignature Language="F#" Value="static member Call : System.Reflection.MethodInfo * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.MethodCallExpression" Usage="System.Linq.Expressions.Expression.Call (method, arg0, arg1, arg2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MethodCallExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Reflection.MethodInfo" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg1" Type="System.Linq.Expressions.Expression" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg2" Type="System.Linq.Expressions.Expression" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="method"><span data-ttu-id="7593b-730">要将 <see cref="T:System.Reflection.MethodInfo" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-730">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> property equal to.</span></span></param>
        <param name="arg0"><span data-ttu-id="7593b-731">用于表示第一个参数的 <see cref="T:System.Linq.Expressions.Expression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-731">The <see cref="T:System.Linq.Expressions.Expression" /> that represents the first argument.</span></span></param>
        <param name="arg1"><span data-ttu-id="7593b-732">用于表示第二个参数的 <see cref="T:System.Linq.Expressions.Expression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-732">The <see cref="T:System.Linq.Expressions.Expression" /> that represents the second argument.</span></span></param>
        <param name="arg2"><span data-ttu-id="7593b-733">用于表示第三个参数的 <see cref="T:System.Linq.Expressions.Expression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-733">The <see cref="T:System.Linq.Expressions.Expression" /> that represents the third argument.</span></span></param>
        <summary><span data-ttu-id="7593b-734">创建一个 <see cref="T:System.Linq.Expressions.MethodCallExpression" />，它表示对使用三个参数的静态方法的调用。</span><span class="sxs-lookup"><span data-stu-id="7593b-734">Creates a <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that represents a call to a static method that takes three arguments.</span></span></summary>
        <returns><span data-ttu-id="7593b-735">一个 <see cref="T:System.Linq.Expressions.MethodCallExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 属性等于 <see cref="F:System.Linq.Expressions.ExpressionType.Call" />，并且其 <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> 和 <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> 属性设置为指定值。</span><span class="sxs-lookup"><span data-stu-id="7593b-735">A <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> and the <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> and <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="7593b-736"><paramref name="method" /> 为 null。</span><span class="sxs-lookup"><span data-stu-id="7593b-736"><paramref name="method" /> is null.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MethodCallExpression Call (Type type, string methodName, Type[] typeArguments, params System.Linq.Expressions.Expression[] arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MethodCallExpression Call(class System.Type type, string methodName, class System.Type[] typeArguments, class System.Linq.Expressions.Expression[] arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Call(System.Type,System.String,System.Type[],System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MethodCallExpression ^ Call(Type ^ type, System::String ^ methodName, cli::array &lt;Type ^&gt; ^ typeArguments, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberSignature Language="F#" Value="static member Call : Type * string * Type[] * System.Linq.Expressions.Expression[] -&gt; System.Linq.Expressions.MethodCallExpression" Usage="System.Linq.Expressions.Expression.Call (type, methodName, typeArguments, arguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MethodCallExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="methodName" Type="System.String" />
        <Parameter Name="typeArguments" Type="System.Type[]" />
        <Parameter Name="arguments" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="type"><span data-ttu-id="7593b-737">包含指定的 <see langword="static" />（在 Visual Basic 中为 <see langword="Shared" />）方法的类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-737">The type that contains the specified <see langword="static" /> (<see langword="Shared" /> in Visual Basic) method.</span></span></param>
        <param name="methodName"><span data-ttu-id="7593b-738">方法的名称。</span><span class="sxs-lookup"><span data-stu-id="7593b-738">The name of the method.</span></span></param>
        <param name="typeArguments"><span data-ttu-id="7593b-739">指定泛型方法的类型参数的 <see cref="T:System.Type" /> 对象的数组。</span><span class="sxs-lookup"><span data-stu-id="7593b-739">An array of <see cref="T:System.Type" /> objects that specify the type parameters of the generic method.</span></span> <span data-ttu-id="7593b-740">当 methodName 指定非泛型方法时，此参数应为 null。</span><span class="sxs-lookup"><span data-stu-id="7593b-740">This argument should be null when methodName specifies a non-generic method.</span></span></param>
        <param name="arguments"><span data-ttu-id="7593b-741"><see cref="T:System.Linq.Expressions.Expression" /> 对象的数组，表示方法的自变量。</span><span class="sxs-lookup"><span data-stu-id="7593b-741">An array of <see cref="T:System.Linq.Expressions.Expression" /> objects that represent the arguments to the method.</span></span></param>
        <summary><span data-ttu-id="7593b-742">通过调用合适的工厂方法，创建一个 <see cref="T:System.Linq.Expressions.MethodCallExpression" />，它表示对 <see langword="static" />（在 Visual Basic 中为 <see langword="Shared" />）方法的调用。</span><span class="sxs-lookup"><span data-stu-id="7593b-742">Creates a <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that represents a call to a <see langword="static" /> (<see langword="Shared" /> in Visual Basic) method by calling the appropriate factory method.</span></span></summary>
        <returns><span data-ttu-id="7593b-743"><see cref="T:System.Linq.Expressions.MethodCallExpression" /> 的 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 属性等于 <see cref="F:System.Linq.Expressions.ExpressionType.Call" />，<see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> 属性设置为表示指定的 <see cref="T:System.Reflection.MethodInfo" />（在 Visual Basic 中为 <see langword="static" />）方法的 <see langword="Shared" />，并且 <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> 属性设置为指定自变量。</span><span class="sxs-lookup"><span data-stu-id="7593b-743">A <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Call" />, the <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> property set to the <see cref="T:System.Reflection.MethodInfo" /> that represents the specified <see langword="static" /> (<see langword="Shared" /> in Visual Basic) method, and the <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> property set to the specified arguments.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7593b-744">生成的 <xref:System.Linq.Expressions.MethodCallExpression> 的 <xref:System.Linq.Expressions.Expression.Type%2A> 属性等于 `methodName`所表示的方法的返回类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-744">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.MethodCallExpression> is equal to the return type of the method denoted by `methodName`.</span></span> <span data-ttu-id="7593b-745"><xref:System.Linq.Expressions.MethodCallExpression.Object%2A> 属性为 `null`。</span><span class="sxs-lookup"><span data-stu-id="7593b-745">The <xref:System.Linq.Expressions.MethodCallExpression.Object%2A> property is `null`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="7593b-746"><paramref name="type" /> 或 <paramref name="methodName" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-746"><paramref name="type" /> or <paramref name="methodName" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="7593b-747">在 <paramref name="methodName" /> 或其基类型中找不到这样的方法：名称为 <paramref name="typeArguments" />、类型参数与 <paramref name="arguments" /> 相匹配，且参数类型与 <paramref name="type" /> 相匹配。</span><span class="sxs-lookup"><span data-stu-id="7593b-747">No method whose name is <paramref name="methodName" />, whose type parameters match <paramref name="typeArguments" />, and whose parameter types match <paramref name="arguments" /> is found in <paramref name="type" /> or its base types.</span></span>  
  
<span data-ttu-id="7593b-748">- 或 -</span><span class="sxs-lookup"><span data-stu-id="7593b-748">-or-</span></span> 
<span data-ttu-id="7593b-749">在 <paramref name="methodName" /> 或其基类型中找到多个这样的方法：名称为 <paramref name="typeArguments" />，类型参数与 <paramref name="arguments" /> 相匹配，参数类型与 <paramref name="type" /> 相匹配。</span><span class="sxs-lookup"><span data-stu-id="7593b-749">More than one method whose name is <paramref name="methodName" />, whose type parameters match <paramref name="typeArguments" />, and whose parameter types match <paramref name="arguments" /> is found in <paramref name="type" /> or its base types.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MethodCallExpression Call (System.Linq.Expressions.Expression instance, System.Reflection.MethodInfo method, System.Linq.Expressions.Expression arg0, System.Linq.Expressions.Expression arg1, System.Linq.Expressions.Expression arg2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MethodCallExpression Call(class System.Linq.Expressions.Expression instance, class System.Reflection.MethodInfo method, class System.Linq.Expressions.Expression arg0, class System.Linq.Expressions.Expression arg1, class System.Linq.Expressions.Expression arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Call(System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Call (instance As Expression, method As MethodInfo, arg0 As Expression, arg1 As Expression, arg2 As Expression) As MethodCallExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MethodCallExpression ^ Call(System::Linq::Expressions::Expression ^ instance, System::Reflection::MethodInfo ^ method, System::Linq::Expressions::Expression ^ arg0, System::Linq::Expressions::Expression ^ arg1, System::Linq::Expressions::Expression ^ arg2);" />
      <MemberSignature Language="F#" Value="static member Call : System.Linq.Expressions.Expression * System.Reflection.MethodInfo * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.MethodCallExpression" Usage="System.Linq.Expressions.Expression.Call (instance, method, arg0, arg1, arg2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MethodCallExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Linq.Expressions.Expression" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg1" Type="System.Linq.Expressions.Expression" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg2" Type="System.Linq.Expressions.Expression" Index="4" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="instance"><span data-ttu-id="7593b-750">指定一个实例调用的实例的 <see cref="T:System.Linq.Expressions.Expression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-750">An <see cref="T:System.Linq.Expressions.Expression" /> that specifies the instance for an instance call.</span></span> <span data-ttu-id="7593b-751">（对于 static 方法（在 Visual Basic 中为 Shared 方法）应传递 null）。</span><span class="sxs-lookup"><span data-stu-id="7593b-751">(pass null for a static (Shared in Visual Basic) method).</span></span></param>
        <param name="method"><span data-ttu-id="7593b-752">表示目标方法的 <see cref="T:System.Reflection.MethodInfo" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-752">The <see cref="T:System.Reflection.MethodInfo" /> that represents the target method.</span></span></param>
        <param name="arg0"><span data-ttu-id="7593b-753">用于表示第一个参数的 <see cref="T:System.Linq.Expressions.Expression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-753">The <see cref="T:System.Linq.Expressions.Expression" /> that represents the first argument.</span></span></param>
        <param name="arg1"><span data-ttu-id="7593b-754">用于表示第二个参数的 <see cref="T:System.Linq.Expressions.Expression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-754">The <see cref="T:System.Linq.Expressions.Expression" /> that represents the second argument.</span></span></param>
        <param name="arg2"><span data-ttu-id="7593b-755">用于表示第三个参数的 <see cref="T:System.Linq.Expressions.Expression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-755">The <see cref="T:System.Linq.Expressions.Expression" /> that represents the third argument.</span></span></param>
        <summary><span data-ttu-id="7593b-756">创建一个 <see cref="T:System.Linq.Expressions.MethodCallExpression" />，它表示对使用三个参数的方法的调用。</span><span class="sxs-lookup"><span data-stu-id="7593b-756">Creates a <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that represents a call to a method that takes three arguments.</span></span></summary>
        <returns><span data-ttu-id="7593b-757">一个 <see cref="T:System.Linq.Expressions.MethodCallExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 属性等于 <see cref="F:System.Linq.Expressions.ExpressionType.Call" />，并且其 <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> 和 <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> 属性设置为指定值。</span><span class="sxs-lookup"><span data-stu-id="7593b-757">A <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> and the <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> and <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MethodCallExpression Call (System.Reflection.MethodInfo method, System.Linq.Expressions.Expression arg0, System.Linq.Expressions.Expression arg1, System.Linq.Expressions.Expression arg2, System.Linq.Expressions.Expression arg3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MethodCallExpression Call(class System.Reflection.MethodInfo method, class System.Linq.Expressions.Expression arg0, class System.Linq.Expressions.Expression arg1, class System.Linq.Expressions.Expression arg2, class System.Linq.Expressions.Expression arg3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Call(System.Reflection.MethodInfo,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Call (method As MethodInfo, arg0 As Expression, arg1 As Expression, arg2 As Expression, arg3 As Expression) As MethodCallExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MethodCallExpression ^ Call(System::Reflection::MethodInfo ^ method, System::Linq::Expressions::Expression ^ arg0, System::Linq::Expressions::Expression ^ arg1, System::Linq::Expressions::Expression ^ arg2, System::Linq::Expressions::Expression ^ arg3);" />
      <MemberSignature Language="F#" Value="static member Call : System.Reflection.MethodInfo * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.MethodCallExpression" Usage="System.Linq.Expressions.Expression.Call (method, arg0, arg1, arg2, arg3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MethodCallExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Reflection.MethodInfo" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg1" Type="System.Linq.Expressions.Expression" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg2" Type="System.Linq.Expressions.Expression" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg3" Type="System.Linq.Expressions.Expression" Index="4" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="method"><span data-ttu-id="7593b-758">要将 <see cref="T:System.Reflection.MethodInfo" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-758">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> property equal to.</span></span></param>
        <param name="arg0"><span data-ttu-id="7593b-759">用于表示第一个参数的 <see cref="T:System.Linq.Expressions.Expression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-759">The <see cref="T:System.Linq.Expressions.Expression" /> that represents the first argument.</span></span></param>
        <param name="arg1"><span data-ttu-id="7593b-760">用于表示第二个参数的 <see cref="T:System.Linq.Expressions.Expression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-760">The <see cref="T:System.Linq.Expressions.Expression" /> that represents the second argument.</span></span></param>
        <param name="arg2"><span data-ttu-id="7593b-761">用于表示第三个参数的 <see cref="T:System.Linq.Expressions.Expression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-761">The <see cref="T:System.Linq.Expressions.Expression" /> that represents the third argument.</span></span></param>
        <param name="arg3"><span data-ttu-id="7593b-762">用于表示第四个参数的 <see cref="T:System.Linq.Expressions.Expression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-762">The <see cref="T:System.Linq.Expressions.Expression" /> that represents the fourth argument.</span></span></param>
        <summary><span data-ttu-id="7593b-763">创建一个 <see cref="T:System.Linq.Expressions.MethodCallExpression" />，它表示对使用四个参数的静态方法的调用。</span><span class="sxs-lookup"><span data-stu-id="7593b-763">Creates a <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that represents a call to a static method that takes four arguments.</span></span></summary>
        <returns><span data-ttu-id="7593b-764">一个 <see cref="T:System.Linq.Expressions.MethodCallExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 属性等于 <see cref="F:System.Linq.Expressions.ExpressionType.Call" />，并且其 <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> 和 <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> 属性设置为指定值。</span><span class="sxs-lookup"><span data-stu-id="7593b-764">A <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> and the <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> and <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="7593b-765"><paramref name="method" /> 为 null。</span><span class="sxs-lookup"><span data-stu-id="7593b-765"><paramref name="method" /> is null.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MethodCallExpression Call (System.Reflection.MethodInfo method, System.Linq.Expressions.Expression arg0, System.Linq.Expressions.Expression arg1, System.Linq.Expressions.Expression arg2, System.Linq.Expressions.Expression arg3, System.Linq.Expressions.Expression arg4);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MethodCallExpression Call(class System.Reflection.MethodInfo method, class System.Linq.Expressions.Expression arg0, class System.Linq.Expressions.Expression arg1, class System.Linq.Expressions.Expression arg2, class System.Linq.Expressions.Expression arg3, class System.Linq.Expressions.Expression arg4) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Call(System.Reflection.MethodInfo,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Call (method As MethodInfo, arg0 As Expression, arg1 As Expression, arg2 As Expression, arg3 As Expression, arg4 As Expression) As MethodCallExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MethodCallExpression ^ Call(System::Reflection::MethodInfo ^ method, System::Linq::Expressions::Expression ^ arg0, System::Linq::Expressions::Expression ^ arg1, System::Linq::Expressions::Expression ^ arg2, System::Linq::Expressions::Expression ^ arg3, System::Linq::Expressions::Expression ^ arg4);" />
      <MemberSignature Language="F#" Value="static member Call : System.Reflection.MethodInfo * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.MethodCallExpression" Usage="System.Linq.Expressions.Expression.Call (method, arg0, arg1, arg2, arg3, arg4)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MethodCallExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Reflection.MethodInfo" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg1" Type="System.Linq.Expressions.Expression" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg2" Type="System.Linq.Expressions.Expression" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg3" Type="System.Linq.Expressions.Expression" Index="4" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg4" Type="System.Linq.Expressions.Expression" Index="5" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="method"><span data-ttu-id="7593b-766">要将 <see cref="T:System.Reflection.MethodInfo" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-766">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> property equal to.</span></span></param>
        <param name="arg0"><span data-ttu-id="7593b-767">用于表示第一个参数的 <see cref="T:System.Linq.Expressions.Expression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-767">The <see cref="T:System.Linq.Expressions.Expression" /> that represents the first argument.</span></span></param>
        <param name="arg1"><span data-ttu-id="7593b-768">用于表示第二个参数的 <see cref="T:System.Linq.Expressions.Expression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-768">The <see cref="T:System.Linq.Expressions.Expression" /> that represents the second argument.</span></span></param>
        <param name="arg2"><span data-ttu-id="7593b-769">用于表示第三个参数的 <see cref="T:System.Linq.Expressions.Expression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-769">The <see cref="T:System.Linq.Expressions.Expression" /> that represents the third argument.</span></span></param>
        <param name="arg3"><span data-ttu-id="7593b-770">用于表示第四个参数的 <see cref="T:System.Linq.Expressions.Expression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-770">The <see cref="T:System.Linq.Expressions.Expression" /> that represents the fourth argument.</span></span></param>
        <param name="arg4"><span data-ttu-id="7593b-771">用于表示第五个参数的 <see cref="T:System.Linq.Expressions.Expression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-771">The <see cref="T:System.Linq.Expressions.Expression" /> that represents the fifth argument.</span></span></param>
        <summary><span data-ttu-id="7593b-772">创建一个 <see cref="T:System.Linq.Expressions.MethodCallExpression" />，它表示对使用五个参数的静态方法的调用。</span><span class="sxs-lookup"><span data-stu-id="7593b-772">Creates a <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that represents a call to a static method that takes five arguments.</span></span></summary>
        <returns><span data-ttu-id="7593b-773">一个 <see cref="T:System.Linq.Expressions.MethodCallExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 属性等于 <see cref="F:System.Linq.Expressions.ExpressionType.Call" />，并且其 <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> 和 <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> 属性设置为指定值。</span><span class="sxs-lookup"><span data-stu-id="7593b-773">A <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> and the <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> and <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="7593b-774"><paramref name="method" /> 为 null。</span><span class="sxs-lookup"><span data-stu-id="7593b-774"><paramref name="method" /> is null.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="CanReduce">
      <MemberSignature Language="C#" Value="public virtual bool CanReduce { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanReduce" />
      <MemberSignature Language="DocId" Value="P:System.Linq.Expressions.Expression.CanReduce" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property CanReduce As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanReduce { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanReduce : bool" Usage="System.Linq.Expressions.Expression.CanReduce" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="7593b-775">指示可将节点简化为更简单的节点。</span><span class="sxs-lookup"><span data-stu-id="7593b-775">Indicates that the node can be reduced to a simpler node.</span></span> <span data-ttu-id="7593b-776">如果返回 true，则可以调用 Reduce() 以生成简化形式。</span><span class="sxs-lookup"><span data-stu-id="7593b-776">If this returns true, Reduce() can be called to produce the reduced form.</span></span></summary>
        <value><span data-ttu-id="7593b-777">如果可以减少节点，则 <see langword="true" />;否则，<see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-777"><see langword="true" /> if the node can be reduced; otherwise, <see langword="false" />.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Catch">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="7593b-778">创建一个表示 catch 语句的 <see cref="T:System.Linq.Expressions.CatchBlock" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-778">Creates a <see cref="T:System.Linq.Expressions.CatchBlock" /> representing a catch statement.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Catch">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.CatchBlock Catch (System.Linq.Expressions.ParameterExpression variable, System.Linq.Expressions.Expression body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.CatchBlock Catch(class System.Linq.Expressions.ParameterExpression variable, class System.Linq.Expressions.Expression body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Catch(System.Linq.Expressions.ParameterExpression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Catch (variable As ParameterExpression, body As Expression) As CatchBlock" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::CatchBlock ^ Catch(System::Linq::Expressions::ParameterExpression ^ variable, System::Linq::Expressions::Expression ^ body);" />
      <MemberSignature Language="F#" Value="static member Catch : System.Linq.Expressions.ParameterExpression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.CatchBlock" Usage="System.Linq.Expressions.Expression.Catch (variable, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.CatchBlock</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="variable" Type="System.Linq.Expressions.ParameterExpression" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="variable"><span data-ttu-id="7593b-779">一个 <see cref="T:System.Linq.Expressions.ParameterExpression" />，它表示对此处理程序捕获的 <see cref="T:System.Exception" /> 对象的引用。</span><span class="sxs-lookup"><span data-stu-id="7593b-779">A <see cref="T:System.Linq.Expressions.ParameterExpression" /> representing a reference to the <see cref="T:System.Exception" /> object caught by this handler.</span></span></param>
        <param name="body"><span data-ttu-id="7593b-780">catch 语句的主体。</span><span class="sxs-lookup"><span data-stu-id="7593b-780">The body of the catch statement.</span></span></param>
        <summary><span data-ttu-id="7593b-781">创建一个表示 catch 语句的 <see cref="T:System.Linq.Expressions.CatchBlock" />，其中具有对已捕获的 <see cref="T:System.Exception" /> 对象的引用以便在处理程序主体中使用。</span><span class="sxs-lookup"><span data-stu-id="7593b-781">Creates a <see cref="T:System.Linq.Expressions.CatchBlock" /> representing a catch statement with a reference to the caught <see cref="T:System.Exception" /> object for use in the handler body.</span></span></summary>
        <returns><span data-ttu-id="7593b-782">创建的 <see cref="T:System.Linq.Expressions.CatchBlock" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-782">The created <see cref="T:System.Linq.Expressions.CatchBlock" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Catch">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.CatchBlock Catch (Type type, System.Linq.Expressions.Expression body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.CatchBlock Catch(class System.Type type, class System.Linq.Expressions.Expression body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Catch(System.Type,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::CatchBlock ^ Catch(Type ^ type, System::Linq::Expressions::Expression ^ body);" />
      <MemberSignature Language="F#" Value="static member Catch : Type * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.CatchBlock" Usage="System.Linq.Expressions.Expression.Catch (type, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.CatchBlock</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="type"><span data-ttu-id="7593b-783">此 <see cref="P:System.Linq.Expressions.Expression.Type" /> 将处理的 <see cref="T:System.Exception" /> 的 <see cref="T:System.Linq.Expressions.CatchBlock" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-783">The <see cref="P:System.Linq.Expressions.Expression.Type" /> of <see cref="T:System.Exception" /> this <see cref="T:System.Linq.Expressions.CatchBlock" /> will handle.</span></span></param>
        <param name="body"><span data-ttu-id="7593b-784">catch 语句的主体。</span><span class="sxs-lookup"><span data-stu-id="7593b-784">The body of the catch statement.</span></span></param>
        <summary><span data-ttu-id="7593b-785">创建一个表示 catch 语句的 <see cref="T:System.Linq.Expressions.CatchBlock" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-785">Creates a <see cref="T:System.Linq.Expressions.CatchBlock" /> representing a catch statement.</span></span></summary>
        <returns><span data-ttu-id="7593b-786">创建的 <see cref="T:System.Linq.Expressions.CatchBlock" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-786">The created <see cref="T:System.Linq.Expressions.CatchBlock" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7593b-787">可以指定要捕获的 <xref:System.Exception> 的 <xref:System.Linq.Expressions.Expression.Type%2A>，但不能在 <xref:System.Linq.Expressions.CatchBlock>中使用对 <xref:System.Exception> 对象的引用。</span><span class="sxs-lookup"><span data-stu-id="7593b-787">The <xref:System.Linq.Expressions.Expression.Type%2A> of <xref:System.Exception> to be caught can be specified but no reference to the <xref:System.Exception> object will be available for use in the <xref:System.Linq.Expressions.CatchBlock>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Catch">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.CatchBlock Catch (System.Linq.Expressions.ParameterExpression variable, System.Linq.Expressions.Expression body, System.Linq.Expressions.Expression filter);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.CatchBlock Catch(class System.Linq.Expressions.ParameterExpression variable, class System.Linq.Expressions.Expression body, class System.Linq.Expressions.Expression filter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Catch(System.Linq.Expressions.ParameterExpression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Catch (variable As ParameterExpression, body As Expression, filter As Expression) As CatchBlock" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::CatchBlock ^ Catch(System::Linq::Expressions::ParameterExpression ^ variable, System::Linq::Expressions::Expression ^ body, System::Linq::Expressions::Expression ^ filter);" />
      <MemberSignature Language="F#" Value="static member Catch : System.Linq.Expressions.ParameterExpression * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.CatchBlock" Usage="System.Linq.Expressions.Expression.Catch (variable, body, filter)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.CatchBlock</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="variable" Type="System.Linq.Expressions.ParameterExpression" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="filter" Type="System.Linq.Expressions.Expression" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="variable"><span data-ttu-id="7593b-788">一个 <see cref="T:System.Linq.Expressions.ParameterExpression" />，它表示对此处理程序捕获的 <see cref="T:System.Exception" /> 对象的引用。</span><span class="sxs-lookup"><span data-stu-id="7593b-788">A <see cref="T:System.Linq.Expressions.ParameterExpression" /> representing a reference to the <see cref="T:System.Exception" /> object caught by this handler.</span></span></param>
        <param name="body"><span data-ttu-id="7593b-789">catch 语句的主体。</span><span class="sxs-lookup"><span data-stu-id="7593b-789">The body of the catch statement.</span></span></param>
        <param name="filter"><span data-ttu-id="7593b-790"><see cref="T:System.Exception" /> 筛选器的主体。</span><span class="sxs-lookup"><span data-stu-id="7593b-790">The body of the <see cref="T:System.Exception" /> filter.</span></span></param>
        <summary><span data-ttu-id="7593b-791">创建一个表示 catch 语句的 <see cref="T:System.Linq.Expressions.CatchBlock" />，其中具有 <see cref="T:System.Exception" /> 筛选器和对已捕获的 <see cref="T:System.Exception" /> 对象的引用。</span><span class="sxs-lookup"><span data-stu-id="7593b-791">Creates a <see cref="T:System.Linq.Expressions.CatchBlock" /> representing a catch statement with an <see cref="T:System.Exception" /> filter and a reference to the caught <see cref="T:System.Exception" /> object.</span></span></summary>
        <returns><span data-ttu-id="7593b-792">创建的 <see cref="T:System.Linq.Expressions.CatchBlock" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-792">The created <see cref="T:System.Linq.Expressions.CatchBlock" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Catch">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.CatchBlock Catch (Type type, System.Linq.Expressions.Expression body, System.Linq.Expressions.Expression filter);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.CatchBlock Catch(class System.Type type, class System.Linq.Expressions.Expression body, class System.Linq.Expressions.Expression filter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Catch(System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::CatchBlock ^ Catch(Type ^ type, System::Linq::Expressions::Expression ^ body, System::Linq::Expressions::Expression ^ filter);" />
      <MemberSignature Language="F#" Value="static member Catch : Type * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.CatchBlock" Usage="System.Linq.Expressions.Expression.Catch (type, body, filter)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.CatchBlock</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="filter" Type="System.Linq.Expressions.Expression" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="type"><span data-ttu-id="7593b-793">此 <see cref="P:System.Linq.Expressions.Expression.Type" /> 将处理的 <see cref="T:System.Exception" /> 的 <see cref="T:System.Linq.Expressions.CatchBlock" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-793">The <see cref="P:System.Linq.Expressions.Expression.Type" /> of <see cref="T:System.Exception" /> this <see cref="T:System.Linq.Expressions.CatchBlock" /> will handle.</span></span></param>
        <param name="body"><span data-ttu-id="7593b-794">catch 语句的主体。</span><span class="sxs-lookup"><span data-stu-id="7593b-794">The body of the catch statement.</span></span></param>
        <param name="filter"><span data-ttu-id="7593b-795"><see cref="T:System.Exception" /> 筛选器的主体。</span><span class="sxs-lookup"><span data-stu-id="7593b-795">The body of the <see cref="T:System.Exception" /> filter.</span></span></param>
        <summary><span data-ttu-id="7593b-796">创建一个表示 catch 语句的 <see cref="T:System.Linq.Expressions.CatchBlock" />，其中具有 <see cref="T:System.Exception" /> 筛选器，但没有对已捕获的 <see cref="T:System.Exception" /> 对象的引用。</span><span class="sxs-lookup"><span data-stu-id="7593b-796">Creates a <see cref="T:System.Linq.Expressions.CatchBlock" /> representing a catch statement with an <see cref="T:System.Exception" /> filter but no reference to the caught <see cref="T:System.Exception" /> object.</span></span></summary>
        <returns><span data-ttu-id="7593b-797">创建的 <see cref="T:System.Linq.Expressions.CatchBlock" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-797">The created <see cref="T:System.Linq.Expressions.CatchBlock" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ClearDebugInfo">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.DebugInfoExpression ClearDebugInfo (System.Linq.Expressions.SymbolDocumentInfo document);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.DebugInfoExpression ClearDebugInfo(class System.Linq.Expressions.SymbolDocumentInfo document) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ClearDebugInfo(System.Linq.Expressions.SymbolDocumentInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ClearDebugInfo (document As SymbolDocumentInfo) As DebugInfoExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::DebugInfoExpression ^ ClearDebugInfo(System::Linq::Expressions::SymbolDocumentInfo ^ document);" />
      <MemberSignature Language="F#" Value="static member ClearDebugInfo : System.Linq.Expressions.SymbolDocumentInfo -&gt; System.Linq.Expressions.DebugInfoExpression" Usage="System.Linq.Expressions.Expression.ClearDebugInfo document" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.DebugInfoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="document" Type="System.Linq.Expressions.SymbolDocumentInfo" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="document"><span data-ttu-id="7593b-798">表示源文件的 <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-798">The <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> that represents the source file.</span></span></param>
        <summary><span data-ttu-id="7593b-799">创建一个用于清除序列点的 <see cref="T:System.Linq.Expressions.DebugInfoExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-799">Creates a <see cref="T:System.Linq.Expressions.DebugInfoExpression" /> for clearing a sequence point.</span></span></summary>
        <returns><span data-ttu-id="7593b-800">用于清除序列点的 <see cref="T:System.Linq.Expressions.DebugInfoExpression" /> 的实例。</span><span class="sxs-lookup"><span data-stu-id="7593b-800">An instance of <see cref="T:System.Linq.Expressions.DebugInfoExpression" /> for clearing a sequence point.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Coalesce">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="7593b-801">创建一个表示合并运算的 <see cref="T:System.Linq.Expressions.BinaryExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-801">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a coalescing operation.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Coalesce">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Coalesce (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Coalesce(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Coalesce(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Coalesce (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Coalesce(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member Coalesce : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.Coalesce (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="7593b-802">要将 <see cref="T:System.Linq.Expressions.Expression" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-802">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="7593b-803">要将 <see cref="T:System.Linq.Expressions.Expression" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-803">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="7593b-804">创建一个表示合并运算的 <see cref="T:System.Linq.Expressions.BinaryExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-804">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a coalescing operation.</span></span></summary>
        <returns><span data-ttu-id="7593b-805">一个 <see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 属性等于 <see cref="F:System.Linq.Expressions.ExpressionType.Coalesce" />，并且其 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 属性设置为指定值。</span><span class="sxs-lookup"><span data-stu-id="7593b-805">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Coalesce" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7593b-806">生成的 <xref:System.Linq.Expressions.BinaryExpression> 的 <xref:System.Linq.Expressions.BinaryExpression.Method%2A> 属性是 `null`，并且 <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> 和 <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> 都设置为 `false`。</span><span class="sxs-lookup"><span data-stu-id="7593b-806">The <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property of the resulting <xref:System.Linq.Expressions.BinaryExpression> is `null` and both <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> are set to `false`.</span></span> <span data-ttu-id="7593b-807"><xref:System.Linq.Expressions.Expression.Type%2A> 属性等于合并运算的结果类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-807">The <xref:System.Linq.Expressions.Expression.Type%2A> property is equal to the result type of the coalescing operation.</span></span> <span data-ttu-id="7593b-808"><xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> 属性为 `null`。</span><span class="sxs-lookup"><span data-stu-id="7593b-808">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
#### <a name="result-type"></a><span data-ttu-id="7593b-809">结果类型</span><span class="sxs-lookup"><span data-stu-id="7593b-809">Result Type</span></span>  
 <span data-ttu-id="7593b-810">以下规则确定结果类型：</span><span class="sxs-lookup"><span data-stu-id="7593b-810">The following rules determine the result type:</span></span>  
  
-   <span data-ttu-id="7593b-811">如果 `left`。类型表示可以为 null 的类型，并 `right`。类型可隐式转换为相应的不可为 null 的类型，结果类型是 `left`的不可为 null 的等效项。类别.</span><span class="sxs-lookup"><span data-stu-id="7593b-811">If `left`.Type represents a nullable type and `right`.Type is implicitly convertible to the corresponding non-nullable type, the result type is the non-nullable equivalent of `left`.Type.</span></span>  
  
-   <span data-ttu-id="7593b-812">否则，如果 `right`。类型可隐式转换为 `left`。类型，则结果类型为 `left`。类别.</span><span class="sxs-lookup"><span data-stu-id="7593b-812">Otherwise, if `right`.Type is implicitly convertible to `left`.Type, the result type is `left`.Type.</span></span>  
  
-   <span data-ttu-id="7593b-813">如果 `left`，则为; 否则为。类型可隐式转换为 `right`。类型，则结果类型为 `right`。类别.</span><span class="sxs-lookup"><span data-stu-id="7593b-813">Otherwise, if the non-nullable equivalent of `left`.Type is implicitly convertible to `right`.Type, the result type is `right`.Type.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="7593b-814"><paramref name="left" /> 或 <paramref name="right" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-814"><paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="7593b-815"><see cref="P:System.Linq.Expressions.Expression.Type" /> 的 <paramref name="left" /> 属性不表示引用类型或可以为 null 的值类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-815">The <see cref="P:System.Linq.Expressions.Expression.Type" /> property of <paramref name="left" /> does not represent a reference type or a nullable value type.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="7593b-816"><paramref name="left" />.Type 和 <paramref name="right" />.Type 不可相互转换。</span><span class="sxs-lookup"><span data-stu-id="7593b-816"><paramref name="left" />.Type and <paramref name="right" />.Type are not convertible to each other.</span></span></exception>
        <related type="Article" href="https://msdn.microsoft.com/library/088b1f0d-c1af-4fe1-b4b8-196fd5ea9132"><span data-ttu-id="7593b-817">??</span><span class="sxs-lookup"><span data-stu-id="7593b-817">??</span></span> <span data-ttu-id="7593b-818">运算符（C# 参考）</span><span class="sxs-lookup"><span data-stu-id="7593b-818">Operator (C# Reference)</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Coalesce">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Coalesce (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Linq.Expressions.LambdaExpression conversion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Coalesce(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Linq.Expressions.LambdaExpression conversion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Coalesce(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.LambdaExpression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Coalesce (left As Expression, right As Expression, conversion As LambdaExpression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Coalesce(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Linq::Expressions::LambdaExpression ^ conversion);" />
      <MemberSignature Language="F#" Value="static member Coalesce : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Linq.Expressions.LambdaExpression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.Coalesce (left, right, conversion)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="conversion" Type="System.Linq.Expressions.LambdaExpression" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="7593b-819">要将 <see cref="T:System.Linq.Expressions.Expression" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-819">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="7593b-820">要将 <see cref="T:System.Linq.Expressions.Expression" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-820">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <param name="conversion"><span data-ttu-id="7593b-821">要将 <see cref="T:System.Linq.Expressions.LambdaExpression" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-821">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="7593b-822">在给定转换函数的情况下，创建一个表示合并运算的 <see cref="T:System.Linq.Expressions.BinaryExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-822">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a coalescing operation, given a conversion function.</span></span></summary>
        <returns><span data-ttu-id="7593b-823">一个 <see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 属性等于 <see cref="F:System.Linq.Expressions.ExpressionType.Coalesce" />，并且其 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />、<see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> 属性设置为指定值。</span><span class="sxs-lookup"><span data-stu-id="7593b-823">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Coalesce" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7593b-824">生成的 <xref:System.Linq.Expressions.BinaryExpression> 的 <xref:System.Linq.Expressions.BinaryExpression.Method%2A> 属性是 `null`，并且 <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> 和 <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> 都设置为 `false`。</span><span class="sxs-lookup"><span data-stu-id="7593b-824">The <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property of the resulting <xref:System.Linq.Expressions.BinaryExpression> is `null` and both <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> are set to `false`.</span></span>  
  
 <span data-ttu-id="7593b-825">生成的 <xref:System.Linq.Expressions.BinaryExpression> 的 <xref:System.Linq.Expressions.Expression.Type%2A> 属性等于合并运算的结果类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-825">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.BinaryExpression> is equal to the result type of the coalescing operation.</span></span>  
  
 <span data-ttu-id="7593b-826">以下规则确定结果类型：</span><span class="sxs-lookup"><span data-stu-id="7593b-826">The following rules determine the result type:</span></span>  
  
-   <span data-ttu-id="7593b-827">如果 `left`。类型表示可以为 null 的类型，并 `right`。类型可隐式转换为相应的不可为 null 的类型，结果类型是 `left`的不可为 null 的等效项。类别.</span><span class="sxs-lookup"><span data-stu-id="7593b-827">If `left`.Type represents a nullable type and `right`.Type is implicitly convertible to the corresponding non-nullable type, the result type is the non-nullable equivalent of `left`.Type.</span></span>  
  
-   <span data-ttu-id="7593b-828">否则，如果 `right`。类型可隐式转换为 `left`。类型，则结果类型为 `left`。类别.</span><span class="sxs-lookup"><span data-stu-id="7593b-828">Otherwise, if `right`.Type is implicitly convertible to `left`.Type, the result type is `left`.Type.</span></span>  
  
-   <span data-ttu-id="7593b-829">如果 `left`，则为; 否则为。类型可隐式转换为 `right`。类型，则结果类型为 `right`。类别.</span><span class="sxs-lookup"><span data-stu-id="7593b-829">Otherwise, if the non-nullable equivalent of `left`.Type is implicitly convertible to `right`.Type, the result type is `right`.Type.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="7593b-830"><paramref name="left" /> 或 <paramref name="right" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-830"><paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="7593b-831"><paramref name="left" />.Type 和 <paramref name="right" />.Type 不可相互转换。</span><span class="sxs-lookup"><span data-stu-id="7593b-831"><paramref name="left" />.Type and <paramref name="right" />.Type are not convertible to each other.</span></span>  
  
<span data-ttu-id="7593b-832">- 或 -</span><span class="sxs-lookup"><span data-stu-id="7593b-832">-or-</span></span> 
 <span data-ttu-id="7593b-833"><paramref name="conversion" /> 不为 <see langword="null" />，并且 <paramref name="conversion" />.Type 为不是正好带一个参数的委托类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-833"><paramref name="conversion" /> is not <see langword="null" /> and <paramref name="conversion" />.Type is a delegate type that does not take exactly one argument.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="7593b-834"><see cref="P:System.Linq.Expressions.Expression.Type" /> 的 <paramref name="left" /> 属性不表示引用类型或可以为 null 的值类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-834">The <see cref="P:System.Linq.Expressions.Expression.Type" /> property of <paramref name="left" /> does not represent a reference type or a nullable value type.</span></span>  
  
<span data-ttu-id="7593b-835">- 或 -</span><span class="sxs-lookup"><span data-stu-id="7593b-835">-or-</span></span> 
<span data-ttu-id="7593b-836"><see cref="P:System.Linq.Expressions.Expression.Type" /> 的 <paramref name="left" /> 属性表示一个类型，该类型不能赋给委托类型 <paramref name="conversion" />.Type 的参数类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-836">The <see cref="P:System.Linq.Expressions.Expression.Type" /> property of <paramref name="left" /> represents a type that is not assignable to the parameter type of the delegate type <paramref name="conversion" />.Type.</span></span>  
  
<span data-ttu-id="7593b-837">- 或 -</span><span class="sxs-lookup"><span data-stu-id="7593b-837">-or-</span></span> 
<span data-ttu-id="7593b-838"><see cref="P:System.Linq.Expressions.Expression.Type" /> 的 <paramref name="right" /> 属性不等于委托类型 <paramref name="conversion" />.Type 的返回类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-838">The <see cref="P:System.Linq.Expressions.Expression.Type" /> property of <paramref name="right" /> is not equal to the return type of the delegate type <paramref name="conversion" />.Type.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Condition">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="7593b-839">创建一个表示条件语句的 <see cref="T:System.Linq.Expressions.ConditionalExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-839">Creates a <see cref="T:System.Linq.Expressions.ConditionalExpression" /> that represents a conditional statement.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Condition">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ConditionalExpression Condition (System.Linq.Expressions.Expression test, System.Linq.Expressions.Expression ifTrue, System.Linq.Expressions.Expression ifFalse);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ConditionalExpression Condition(class System.Linq.Expressions.Expression test, class System.Linq.Expressions.Expression ifTrue, class System.Linq.Expressions.Expression ifFalse) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Condition(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Condition (test As Expression, ifTrue As Expression, ifFalse As Expression) As ConditionalExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::ConditionalExpression ^ Condition(System::Linq::Expressions::Expression ^ test, System::Linq::Expressions::Expression ^ ifTrue, System::Linq::Expressions::Expression ^ ifFalse);" />
      <MemberSignature Language="F#" Value="static member Condition : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.ConditionalExpression" Usage="System.Linq.Expressions.Expression.Condition (test, ifTrue, ifFalse)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ConditionalExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="test" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="ifTrue" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="ifFalse" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="test"><span data-ttu-id="7593b-840">要将 <see cref="T:System.Linq.Expressions.Expression" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-840">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" /> property equal to.</span></span></param>
        <param name="ifTrue"><span data-ttu-id="7593b-841">要将 <see cref="T:System.Linq.Expressions.Expression" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-841">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" /> property equal to.</span></span></param>
        <param name="ifFalse"><span data-ttu-id="7593b-842">要将 <see cref="T:System.Linq.Expressions.Expression" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-842">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="7593b-843">创建一个表示条件语句的 <see cref="T:System.Linq.Expressions.ConditionalExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-843">Creates a <see cref="T:System.Linq.Expressions.ConditionalExpression" /> that represents a conditional statement.</span></span></summary>
        <returns><span data-ttu-id="7593b-844">一个 <see cref="T:System.Linq.Expressions.ConditionalExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 属性等于 <see cref="F:System.Linq.Expressions.ExpressionType.Conditional" />，并且其 <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" />、<see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" /> 和 <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> 属性设置为指定值。</span><span class="sxs-lookup"><span data-stu-id="7593b-844">A <see cref="T:System.Linq.Expressions.ConditionalExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Conditional" /> and the <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" />, <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" />, and <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7593b-845">生成的 <xref:System.Linq.Expressions.ConditionalExpression> 的 <xref:System.Linq.Expressions.Expression.Type%2A> 属性等于 `ifTrue`的 <xref:System.Linq.Expressions.Expression.Type%2A> 属性。</span><span class="sxs-lookup"><span data-stu-id="7593b-845">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.ConditionalExpression> is equal to the <xref:System.Linq.Expressions.Expression.Type%2A> property of `ifTrue`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="7593b-846">下面的代码示例演示如何创建一个表示条件语句的表达式。</span><span class="sxs-lookup"><span data-stu-id="7593b-846">The following code example shows how to create an expression that represents a conditional statement.</span></span> <span data-ttu-id="7593b-847">如果第一个参数的计算结果为 `true`，则执行第二个参数;否则，将执行第三个参数。</span><span class="sxs-lookup"><span data-stu-id="7593b-847">If the first argument evaluates to `true`, the second argument is executed; otherwise, the third argument is executed.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#3)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="7593b-848"><paramref name="test" />、<paramref name="ifTrue" /> 或 <paramref name="ifFalse" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-848"><paramref name="test" /> or <paramref name="ifTrue" /> or <paramref name="ifFalse" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="7593b-849"><paramref name="test" />.Type 不为 <see cref="T:System.Boolean" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-849"><paramref name="test" />.Type is not <see cref="T:System.Boolean" />.</span></span>  
  
<span data-ttu-id="7593b-850">- 或 -</span><span class="sxs-lookup"><span data-stu-id="7593b-850">-or-</span></span> 
 <span data-ttu-id="7593b-851"><paramref name="ifTrue" />.Type 不等于 <paramref name="ifFalse" />.Type。</span><span class="sxs-lookup"><span data-stu-id="7593b-851"><paramref name="ifTrue" />.Type is not equal to <paramref name="ifFalse" />.Type.</span></span></exception>
        <altmember cref="M:System.Linq.Expressions.Expression.IfThen(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
        <altmember cref="M:System.Linq.Expressions.Expression.IfThenElse(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      </Docs>
    </Member>
    <Member MemberName="Condition">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ConditionalExpression Condition (System.Linq.Expressions.Expression test, System.Linq.Expressions.Expression ifTrue, System.Linq.Expressions.Expression ifFalse, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ConditionalExpression Condition(class System.Linq.Expressions.Expression test, class System.Linq.Expressions.Expression ifTrue, class System.Linq.Expressions.Expression ifFalse, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Condition(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::ConditionalExpression ^ Condition(System::Linq::Expressions::Expression ^ test, System::Linq::Expressions::Expression ^ ifTrue, System::Linq::Expressions::Expression ^ ifFalse, Type ^ type);" />
      <MemberSignature Language="F#" Value="static member Condition : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * Type -&gt; System.Linq.Expressions.ConditionalExpression" Usage="System.Linq.Expressions.Expression.Condition (test, ifTrue, ifFalse, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ConditionalExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="test" Type="System.Linq.Expressions.Expression" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="ifTrue" Type="System.Linq.Expressions.Expression" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="ifFalse" Type="System.Linq.Expressions.Expression" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="type" Type="System.Type" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="test"><span data-ttu-id="7593b-852">要将 <see cref="T:System.Linq.Expressions.Expression" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-852">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" /> property equal to.</span></span></param>
        <param name="ifTrue"><span data-ttu-id="7593b-853">要将 <see cref="T:System.Linq.Expressions.Expression" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-853">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" /> property equal to.</span></span></param>
        <param name="ifFalse"><span data-ttu-id="7593b-854">要将 <see cref="T:System.Linq.Expressions.Expression" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-854">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> property equal to.</span></span></param>
        <param name="type"><span data-ttu-id="7593b-855">要将 <see cref="P:System.Linq.Expressions.Expression.Type" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.Expression.Type" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-855">A <see cref="P:System.Linq.Expressions.Expression.Type" /> to set the <see cref="P:System.Linq.Expressions.Expression.Type" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="7593b-856">创建一个表示条件语句的 <see cref="T:System.Linq.Expressions.ConditionalExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-856">Creates a <see cref="T:System.Linq.Expressions.ConditionalExpression" /> that represents a conditional statement.</span></span></summary>
        <returns><span data-ttu-id="7593b-857">一个 <see cref="T:System.Linq.Expressions.ConditionalExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 属性等于 <see cref="F:System.Linq.Expressions.ExpressionType.Conditional" />，并且其 <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" />、<see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" /> 和 <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> 属性设置为指定值。</span><span class="sxs-lookup"><span data-stu-id="7593b-857">A <see cref="T:System.Linq.Expressions.ConditionalExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Conditional" /> and the <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" />, <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" />, and <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7593b-858">此方法允许在 `ifTrue` 和 `ifFalse` 表达式的类型不相等的情况下显式统一统一条件表达式的结果类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-858">This method allows explicitly unifying the result type of the conditional expression in cases where the types of `ifTrue` and `ifFalse` expressions are not equal.</span></span> <span data-ttu-id="7593b-859">`ifTrue` 和 `ifFalse` 的类型必须是可分配给结果类型的隐式引用。</span><span class="sxs-lookup"><span data-stu-id="7593b-859">Types of both `ifTrue` and `ifFalse` must be implicitly reference assignable to the result type.</span></span> <span data-ttu-id="7593b-860">允许 <xref:System.Void>`type`。</span><span class="sxs-lookup"><span data-stu-id="7593b-860">The `type` is allowed to be <xref:System.Void>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Constant">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="7593b-861">创建一个 <see cref="T:System.Linq.Expressions.ConstantExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-861">Creates a <see cref="T:System.Linq.Expressions.ConstantExpression" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Constant">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ConstantExpression Constant (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ConstantExpression Constant(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Constant(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Constant (value As Object) As ConstantExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::ConstantExpression ^ Constant(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="static member Constant : obj -&gt; System.Linq.Expressions.ConstantExpression" Usage="System.Linq.Expressions.Expression.Constant value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ConstantExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="7593b-862">要将 <see cref="T:System.Object" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.ConstantExpression.Value" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-862">An <see cref="T:System.Object" /> to set the <see cref="P:System.Linq.Expressions.ConstantExpression.Value" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="7593b-863">创建一个 <see cref="T:System.Linq.Expressions.ConstantExpression" />，它把 <see cref="P:System.Linq.Expressions.ConstantExpression.Value" /> 属性设置为指定值。</span><span class="sxs-lookup"><span data-stu-id="7593b-863">Creates a <see cref="T:System.Linq.Expressions.ConstantExpression" /> that has the <see cref="P:System.Linq.Expressions.ConstantExpression.Value" /> property set to the specified value.</span></span></summary>
        <returns><span data-ttu-id="7593b-864">一个 <see cref="T:System.Linq.Expressions.ConstantExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 属性等于 <see cref="F:System.Linq.Expressions.ExpressionType.Constant" />，并且其 <see cref="P:System.Linq.Expressions.ConstantExpression.Value" /> 属性设置为指定值。</span><span class="sxs-lookup"><span data-stu-id="7593b-864">A <see cref="T:System.Linq.Expressions.ConstantExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Constant" /> and the <see cref="P:System.Linq.Expressions.ConstantExpression.Value" /> property set to the specified value.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7593b-865">生成的 <xref:System.Linq.Expressions.ConstantExpression> 的 <xref:System.Linq.Expressions.Expression.Type%2A> 属性等于 `value`类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-865">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.ConstantExpression> is equal to the type of `value`.</span></span> <span data-ttu-id="7593b-866">如果 `null``value`，<xref:System.Linq.Expressions.Expression.Type%2A> 等于 <xref:System.Object>。</span><span class="sxs-lookup"><span data-stu-id="7593b-866">If `value` is `null`, <xref:System.Linq.Expressions.Expression.Type%2A> is equal to <xref:System.Object>.</span></span>  
  
 <span data-ttu-id="7593b-867">若要表示 `null`，还可以使用 <xref:System.Linq.Expressions.Expression.Constant%28System.Object%2CSystem.Type%29> 方法，通过该方法可以显式指定类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-867">To represent `null`, you can also use the <xref:System.Linq.Expressions.Expression.Constant%28System.Object%2CSystem.Type%29> method, with which you can explicitly specify the type.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="7593b-868">下面的代码示例演示如何创建表示常数值的表达式。</span><span class="sxs-lookup"><span data-stu-id="7593b-868">The following code example shows how to create an expression that represents a constant value.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#4)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Constant">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ConstantExpression Constant (object value, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ConstantExpression Constant(object value, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Constant(System.Object,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::ConstantExpression ^ Constant(System::Object ^ value, Type ^ type);" />
      <MemberSignature Language="F#" Value="static member Constant : obj * Type -&gt; System.Linq.Expressions.ConstantExpression" Usage="System.Linq.Expressions.Expression.Constant (value, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ConstantExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="7593b-869">要将 <see cref="T:System.Object" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.ConstantExpression.Value" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-869">An <see cref="T:System.Object" /> to set the <see cref="P:System.Linq.Expressions.ConstantExpression.Value" /> property equal to.</span></span></param>
        <param name="type"><span data-ttu-id="7593b-870">要将 <see cref="T:System.Type" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.Expression.Type" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-870">A <see cref="T:System.Type" /> to set the <see cref="P:System.Linq.Expressions.Expression.Type" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="7593b-871">创建一个 <see cref="T:System.Linq.Expressions.ConstantExpression" />，它把 <see cref="P:System.Linq.Expressions.ConstantExpression.Value" /> 和 <see cref="P:System.Linq.Expressions.Expression.Type" /> 属性设置为指定值。</span><span class="sxs-lookup"><span data-stu-id="7593b-871">Creates a <see cref="T:System.Linq.Expressions.ConstantExpression" /> that has the <see cref="P:System.Linq.Expressions.ConstantExpression.Value" /> and <see cref="P:System.Linq.Expressions.Expression.Type" /> properties set to the specified values.</span></span></summary>
        <returns><span data-ttu-id="7593b-872">一个 <see cref="T:System.Linq.Expressions.ConstantExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 属性等于 <see cref="F:System.Linq.Expressions.ExpressionType.Constant" />，并且其 <see cref="P:System.Linq.Expressions.ConstantExpression.Value" /> 和 <see cref="P:System.Linq.Expressions.Expression.Type" /> 属性设置为指定值。</span><span class="sxs-lookup"><span data-stu-id="7593b-872">A <see cref="T:System.Linq.Expressions.ConstantExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Constant" /> and the <see cref="P:System.Linq.Expressions.ConstantExpression.Value" /> and <see cref="P:System.Linq.Expressions.Expression.Type" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7593b-873">此方法可用于表示可以为 null 的类型的值。</span><span class="sxs-lookup"><span data-stu-id="7593b-873">This method can be useful for representing values of nullable types.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="7593b-874">下面的代码示例演示如何创建一个表达式，该表达式表示可以为 null 的类型的常量，并将其值设置为 `null`。</span><span class="sxs-lookup"><span data-stu-id="7593b-874">The following code example shows how to create an expression that represents a constant of the nullable type and set its value to `null`.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#22](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#22)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#22)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="7593b-875"><paramref name="type" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-875"><paramref name="type" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="7593b-876"><paramref name="value" /> 不为 <see langword="null" /> 并且 <paramref name="type" /> 不可从 <paramref name="value" /> 的动态类型赋值。</span><span class="sxs-lookup"><span data-stu-id="7593b-876"><paramref name="value" /> is not <see langword="null" /> and <paramref name="type" /> is not assignable from the dynamic type of <paramref name="value" />.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Continue">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="7593b-877">创建一个表示 continue 语句的 <see cref="T:System.Linq.Expressions.GotoExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-877">Creates a <see cref="T:System.Linq.Expressions.GotoExpression" /> representing a continue statement.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Continue">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.GotoExpression Continue (System.Linq.Expressions.LabelTarget target);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.GotoExpression Continue(class System.Linq.Expressions.LabelTarget target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Continue(System.Linq.Expressions.LabelTarget)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Continue (target As LabelTarget) As GotoExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::GotoExpression ^ Continue(System::Linq::Expressions::LabelTarget ^ target);" />
      <MemberSignature Language="F#" Value="static member Continue : System.Linq.Expressions.LabelTarget -&gt; System.Linq.Expressions.GotoExpression" Usage="System.Linq.Expressions.Expression.Continue target" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.GotoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="target"><span data-ttu-id="7593b-878"><see cref="T:System.Linq.Expressions.LabelTarget" /> 将跳至的 <see cref="T:System.Linq.Expressions.GotoExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-878">The <see cref="T:System.Linq.Expressions.LabelTarget" /> that the <see cref="T:System.Linq.Expressions.GotoExpression" /> will jump to.</span></span></param>
        <summary><span data-ttu-id="7593b-879">创建一个表示 continue 语句的 <see cref="T:System.Linq.Expressions.GotoExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-879">Creates a <see cref="T:System.Linq.Expressions.GotoExpression" /> representing a continue statement.</span></span></summary>
        <returns><span data-ttu-id="7593b-880">一个 <see cref="T:System.Linq.Expressions.GotoExpression" />，其 <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> 等于 Continue，其 <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> 属性设置为 <paramref name="target" />，此外还有一个在跳转时将传递给目标标签的 null 值。</span><span class="sxs-lookup"><span data-stu-id="7593b-880">A <see cref="T:System.Linq.Expressions.GotoExpression" /> with <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> equal to Continue, the <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> property set to <paramref name="target" />, and a null value to be passed to the target label upon jumping.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="7593b-881">下面的示例演示如何创建使用 <xref:System.Linq.Expressions.Expression.Continue%2A> 方法的循环表达式。</span><span class="sxs-lookup"><span data-stu-id="7593b-881">The following example demonstrates how to create a loop expression that uses the <xref:System.Linq.Expressions.Expression.Continue%2A> method.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#46](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#46)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#46](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#46)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Continue">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.GotoExpression Continue (System.Linq.Expressions.LabelTarget target, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.GotoExpression Continue(class System.Linq.Expressions.LabelTarget target, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Continue(System.Linq.Expressions.LabelTarget,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::GotoExpression ^ Continue(System::Linq::Expressions::LabelTarget ^ target, Type ^ type);" />
      <MemberSignature Language="F#" Value="static member Continue : System.Linq.Expressions.LabelTarget * Type -&gt; System.Linq.Expressions.GotoExpression" Usage="System.Linq.Expressions.Expression.Continue (target, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.GotoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="type" Type="System.Type" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="target"><span data-ttu-id="7593b-882"><see cref="T:System.Linq.Expressions.LabelTarget" /> 将跳至的 <see cref="T:System.Linq.Expressions.GotoExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-882">The <see cref="T:System.Linq.Expressions.LabelTarget" /> that the <see cref="T:System.Linq.Expressions.GotoExpression" /> will jump to.</span></span></param>
        <param name="type"><span data-ttu-id="7593b-883">要将 <see cref="T:System.Type" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.Expression.Type" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-883">An <see cref="T:System.Type" /> to set the <see cref="P:System.Linq.Expressions.Expression.Type" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="7593b-884">创建一个表示具有指定类型的 continue 语句的 <see cref="T:System.Linq.Expressions.GotoExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-884">Creates a <see cref="T:System.Linq.Expressions.GotoExpression" /> representing a continue statement with the specified type.</span></span></summary>
        <returns><span data-ttu-id="7593b-885">一个 <see cref="T:System.Linq.Expressions.GotoExpression" />，其 <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> 等于 Continue，其 <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> 属性设置为 <paramref name="target" />，并且其 <see cref="P:System.Linq.Expressions.Expression.Type" /> 属性设置为 <paramref name="type" />，此外还有一个在跳转时将传递给目标标签的 null 值。</span><span class="sxs-lookup"><span data-stu-id="7593b-885">A <see cref="T:System.Linq.Expressions.GotoExpression" /> with <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> equal to Continue, the <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> property set to <paramref name="target" />, the <see cref="P:System.Linq.Expressions.Expression.Type" /> property set to <paramref name="type" />, and a null value to be passed to the target label upon jumping.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Convert">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="7593b-886">创建一个表示类型转换运算的 <see cref="T:System.Linq.Expressions.UnaryExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-886">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents a type conversion operation.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Convert">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression Convert (System.Linq.Expressions.Expression expression, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression Convert(class System.Linq.Expressions.Expression expression, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Convert(System.Linq.Expressions.Expression,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ Convert(System::Linq::Expressions::Expression ^ expression, Type ^ type);" />
      <MemberSignature Language="F#" Value="static member Convert : System.Linq.Expressions.Expression * Type -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.Convert (expression, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="expression"><span data-ttu-id="7593b-887">要将 <see cref="T:System.Linq.Expressions.Expression" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-887">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> property equal to.</span></span></param>
        <param name="type"><span data-ttu-id="7593b-888">要将 <see cref="T:System.Type" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.Expression.Type" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-888">A <see cref="T:System.Type" /> to set the <see cref="P:System.Linq.Expressions.Expression.Type" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="7593b-889">创建一个表示类型转换运算的 <see cref="T:System.Linq.Expressions.UnaryExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-889">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents a type conversion operation.</span></span></summary>
        <returns><span data-ttu-id="7593b-890">一个 <see cref="T:System.Linq.Expressions.UnaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 属性等于 <see cref="F:System.Linq.Expressions.ExpressionType.Convert" />，并且其 <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> 和 <see cref="P:System.Linq.Expressions.Expression.Type" /> 属性设置为指定值。</span><span class="sxs-lookup"><span data-stu-id="7593b-890">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Convert" /> and the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> and <see cref="P:System.Linq.Expressions.Expression.Type" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7593b-891">生成的 <xref:System.Linq.Expressions.UnaryExpression> 的 <xref:System.Linq.Expressions.UnaryExpression.Method%2A> 属性被设置为实现方法。</span><span class="sxs-lookup"><span data-stu-id="7593b-891">The <xref:System.Linq.Expressions.UnaryExpression.Method%2A> property of the resulting <xref:System.Linq.Expressions.UnaryExpression> is set to the implementing method.</span></span> <span data-ttu-id="7593b-892"><xref:System.Linq.Expressions.UnaryExpression.IsLiftedToNull%2A> 属性为 `false`。</span><span class="sxs-lookup"><span data-stu-id="7593b-892">The <xref:System.Linq.Expressions.UnaryExpression.IsLiftedToNull%2A> property is `false`.</span></span> <span data-ttu-id="7593b-893">如果节点已提升，则 <xref:System.Linq.Expressions.UnaryExpression.IsLifted%2A> `true`。</span><span class="sxs-lookup"><span data-stu-id="7593b-893">If the node is lifted, <xref:System.Linq.Expressions.UnaryExpression.IsLifted%2A> is `true`.</span></span> <span data-ttu-id="7593b-894">否则，它是 `false`。</span><span class="sxs-lookup"><span data-stu-id="7593b-894">Otherwise, it is `false`.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="7593b-895">实现方法</span><span class="sxs-lookup"><span data-stu-id="7593b-895">Implementing Method</span></span>  
 <span data-ttu-id="7593b-896">以下规则确定操作的实现方法：</span><span class="sxs-lookup"><span data-stu-id="7593b-896">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="7593b-897">如果 `expression`，则为。Type 或 `type` 是定义隐式转换或显式转换运算符的用户定义类型，表示该运算符的 <xref:System.Reflection.MethodInfo> 是实现方法。</span><span class="sxs-lookup"><span data-stu-id="7593b-897">If either `expression`.Type or `type` is a user-defined type that defines an implicit or explicit conversion operator, the <xref:System.Reflection.MethodInfo> that represents that operator is the implementing method.</span></span>  
  
-   <span data-ttu-id="7593b-898">否则：</span><span class="sxs-lookup"><span data-stu-id="7593b-898">Otherwise:</span></span>  
  
    -   <span data-ttu-id="7593b-899">如果 `expression`，则为。类型和 `type` 表示数字或布尔类型，或可为 null 或不可为 null 的枚举类型，实现方法是 `null`的。</span><span class="sxs-lookup"><span data-stu-id="7593b-899">If both `expression`.Type and `type` represent numeric or Boolean types, or nullable or non-nullable enumeration types, the implementing method is `null`.</span></span>  
  
    -   <span data-ttu-id="7593b-900">如果 `expression`，则为。类型或 `type` 是引用类型，并且存在来自 `expression`的显式装箱、取消装箱或引用转换。键入到 `type`，则实现方法为 `null`。</span><span class="sxs-lookup"><span data-stu-id="7593b-900">If either `expression`.Type or `type` is a reference type and an explicit boxing, unboxing, or reference conversion exists from `expression`.Type to `type`, the implementing method is `null`.</span></span>  
  
#### <a name="lifted-versus-non-lifted"></a><span data-ttu-id="7593b-901">提升和非提升</span><span class="sxs-lookup"><span data-stu-id="7593b-901">Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="7593b-902">如果不 `null`实现方法：</span><span class="sxs-lookup"><span data-stu-id="7593b-902">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="7593b-903">如果 `expression`。Type 可分配给实现方法的参数类型，实现方法的返回类型可分配给 `type`，不会提升节点。</span><span class="sxs-lookup"><span data-stu-id="7593b-903">If `expression`.Type is assignable to the argument type of the implementing method and the return type of the implementing method is assignable to `type`, the node is not lifted.</span></span>  
  
-   <span data-ttu-id="7593b-904">如果 `expression`中的一个或两个。Type 或 `type` 是可以为 null 的值类型，并且相应的不可以为 null 的值类型分别等于实现方法的参数类型和返回类型，则会提升节点。</span><span class="sxs-lookup"><span data-stu-id="7593b-904">If one or both of `expression`.Type or `type` is a nullable value type and the corresponding non-nullable value types are equal to the argument type and the return type of the implementing method respectively, the node is lifted.</span></span>  
  
 <span data-ttu-id="7593b-905">如果实现方法为 `null`：</span><span class="sxs-lookup"><span data-stu-id="7593b-905">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="7593b-906">如果 `expression`，则为。类型和 `type` 不可为 null，则不提升节点。</span><span class="sxs-lookup"><span data-stu-id="7593b-906">If both `expression`.Type and `type` are non-nullable, the node is not lifted.</span></span>  
  
-   <span data-ttu-id="7593b-907">否则，节点将被提升。</span><span class="sxs-lookup"><span data-stu-id="7593b-907">Otherwise the node is lifted.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="7593b-908">下面的代码示例演示如何创建表示类型转换运算的表达式。</span><span class="sxs-lookup"><span data-stu-id="7593b-908">The following code example shows how to create an expression that represents a type conversion operation.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#23](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#23)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#23](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#23)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="7593b-909"><paramref name="expression" /> 或 <paramref name="type" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-909"><paramref name="expression" /> or <paramref name="type" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="7593b-910">未定义 <paramref name="expression" />.Type 和 <paramref name="type" /> 之间的转换运算符。</span><span class="sxs-lookup"><span data-stu-id="7593b-910">No conversion operator is defined between <paramref name="expression" />.Type and <paramref name="type" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Convert">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression Convert (System.Linq.Expressions.Expression expression, Type type, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression Convert(class System.Linq.Expressions.Expression expression, class System.Type type, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Convert(System.Linq.Expressions.Expression,System.Type,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ Convert(System::Linq::Expressions::Expression ^ expression, Type ^ type, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member Convert : System.Linq.Expressions.Expression * Type * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.Convert (expression, type, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="expression"><span data-ttu-id="7593b-911">要将 <see cref="T:System.Linq.Expressions.Expression" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-911">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> property equal to.</span></span></param>
        <param name="type"><span data-ttu-id="7593b-912">要将 <see cref="T:System.Type" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.Expression.Type" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-912">A <see cref="T:System.Type" /> to set the <see cref="P:System.Linq.Expressions.Expression.Type" /> property equal to.</span></span></param>
        <param name="method"><span data-ttu-id="7593b-913">要将 <see cref="T:System.Reflection.MethodInfo" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.UnaryExpression.Method" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-913">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="7593b-914">创建一个 <see cref="T:System.Linq.Expressions.UnaryExpression" />，它表示为其指定实现方法的转换运算。</span><span class="sxs-lookup"><span data-stu-id="7593b-914">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents a conversion operation for which the implementing method is specified.</span></span></summary>
        <returns><span data-ttu-id="7593b-915">一个 <see cref="T:System.Linq.Expressions.UnaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 属性等于 <see cref="F:System.Linq.Expressions.ExpressionType.Convert" />，并且其 <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />、<see cref="P:System.Linq.Expressions.Expression.Type" /> 和 <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> 属性设置为指定值。</span><span class="sxs-lookup"><span data-stu-id="7593b-915">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Convert" /> and the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />, <see cref="P:System.Linq.Expressions.Expression.Type" />, and <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7593b-916">生成的 <xref:System.Linq.Expressions.UnaryExpression> 的 <xref:System.Linq.Expressions.UnaryExpression.Method%2A> 属性被设置为实现方法。</span><span class="sxs-lookup"><span data-stu-id="7593b-916">The <xref:System.Linq.Expressions.UnaryExpression.Method%2A> property of the resulting <xref:System.Linq.Expressions.UnaryExpression> is set to the implementing method.</span></span> <span data-ttu-id="7593b-917"><xref:System.Linq.Expressions.UnaryExpression.IsLiftedToNull%2A> 属性为 `false`。</span><span class="sxs-lookup"><span data-stu-id="7593b-917">The <xref:System.Linq.Expressions.UnaryExpression.IsLiftedToNull%2A> property is `false`.</span></span> <span data-ttu-id="7593b-918">如果节点已提升，则 <xref:System.Linq.Expressions.UnaryExpression.IsLifted%2A> `true`。</span><span class="sxs-lookup"><span data-stu-id="7593b-918">If the node is lifted, <xref:System.Linq.Expressions.UnaryExpression.IsLifted%2A> is `true`.</span></span> <span data-ttu-id="7593b-919">否则，它是 `false`。</span><span class="sxs-lookup"><span data-stu-id="7593b-919">Otherwise, it is `false`.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="7593b-920">实现方法</span><span class="sxs-lookup"><span data-stu-id="7593b-920">Implementing Method</span></span>  
 <span data-ttu-id="7593b-921">以下规则确定操作的实现方法：</span><span class="sxs-lookup"><span data-stu-id="7593b-921">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="7593b-922">如果未 `null`方法，则它是实现方法。</span><span class="sxs-lookup"><span data-stu-id="7593b-922">If method is not `null`, it is the implementing method.</span></span> <span data-ttu-id="7593b-923">它必须表示一个采用一个自变量的非 void `static``Shared` （Visual Basic）方法。</span><span class="sxs-lookup"><span data-stu-id="7593b-923">It must represent a non-void, `static` (`Shared` in Visual Basic) method that takes one argument.</span></span>  
  
-   <span data-ttu-id="7593b-924">如果 `expression`，则为; 否则为。Type 或 `type` 是定义隐式转换或显式转换运算符的用户定义类型，表示该运算符的 <xref:System.Reflection.MethodInfo> 是实现方法。</span><span class="sxs-lookup"><span data-stu-id="7593b-924">Otherwise, if either `expression`.Type or `type` is a user-defined type that defines an implicit or explicit conversion operator, the <xref:System.Reflection.MethodInfo> that represents that operator is the implementing method.</span></span>  
  
-   <span data-ttu-id="7593b-925">否则：</span><span class="sxs-lookup"><span data-stu-id="7593b-925">Otherwise:</span></span>  
  
    -   <span data-ttu-id="7593b-926">如果 `expression`，则为。类型和 `type` 表示数字或布尔类型，或可为 null 或不可为 null 的枚举类型，实现方法是 `null`的。</span><span class="sxs-lookup"><span data-stu-id="7593b-926">If both `expression`.Type and `type` represent numeric or Boolean types, or nullable or non-nullable enumeration types, the implementing method is `null`.</span></span>  
  
    -   <span data-ttu-id="7593b-927">如果 `expression`，则为。类型或 `type` 是引用类型，并且存在来自 `expression`的显式装箱、取消装箱或引用转换。键入到 `type`，则实现方法为 `null`。</span><span class="sxs-lookup"><span data-stu-id="7593b-927">If either `expression`.Type or `type` is a reference type and an explicit boxing, unboxing, or reference conversion exists from `expression`.Type to `type`, the implementing method is `null`.</span></span>  
  
#### <a name="lifted-versus-non-lifted"></a><span data-ttu-id="7593b-928">提升和非提升</span><span class="sxs-lookup"><span data-stu-id="7593b-928">Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="7593b-929">如果不 `null`实现方法：</span><span class="sxs-lookup"><span data-stu-id="7593b-929">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="7593b-930">如果 `expression`。Type 可分配给实现方法的参数类型，实现方法的返回类型可分配给 `type`，不会提升节点。</span><span class="sxs-lookup"><span data-stu-id="7593b-930">If `expression`.Type is assignable to the argument type of the implementing method and the return type of the implementing method is assignable to `type`, the node is not lifted.</span></span>  
  
-   <span data-ttu-id="7593b-931">如果 `expression`中的一个或两个。类型或 `type` 是可以为 null 的值类型，并且相应的不可为 null 的值类型分别等于实现方法的参数类型和返回类型，节点将被提升。</span><span class="sxs-lookup"><span data-stu-id="7593b-931">If either or both of `expression`.Type or `type` are a nullable value type and the corresponding non-nullable value types are equal to the argument type and the return type of the implementing method respectively, the node is lifted.</span></span>  
  
 <span data-ttu-id="7593b-932">如果实现方法为 `null`：</span><span class="sxs-lookup"><span data-stu-id="7593b-932">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="7593b-933">如果 `expression`，则为。类型和 `type` 不可为 null，则不提升节点。</span><span class="sxs-lookup"><span data-stu-id="7593b-933">If both `expression`.Type and `type` are non-nullable, the node is not lifted.</span></span>  
  
-   <span data-ttu-id="7593b-934">否则，节点将被提升。</span><span class="sxs-lookup"><span data-stu-id="7593b-934">Otherwise the node is lifted.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="7593b-935"><paramref name="expression" /> 或 <paramref name="type" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-935"><paramref name="expression" /> or <paramref name="type" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="7593b-936"><paramref name="method" /> 不为 <see langword="null" /> 且其表示的方法返回 <see langword="void" />；不为 <see langword="static" />（在 Visual Basic 中不为 <see langword="Shared" />）；或者不是正好带一个参数。</span><span class="sxs-lookup"><span data-stu-id="7593b-936"><paramref name="method" /> is not <see langword="null" /> and the method it represents returns <see langword="void" />, is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic), or does not take exactly one argument.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="7593b-937">未定义 <paramref name="expression" />.Type 和 <paramref name="type" /> 之间的转换运算符。</span><span class="sxs-lookup"><span data-stu-id="7593b-937">No conversion operator is defined between <paramref name="expression" />.Type and <paramref name="type" />.</span></span>  
  
<span data-ttu-id="7593b-938">- 或 -</span><span class="sxs-lookup"><span data-stu-id="7593b-938">-or-</span></span> 
 <span data-ttu-id="7593b-939"><paramref name="expression" />.Type 不能赋给 <paramref name="method" /> 所表示的方法的参数类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-939"><paramref name="expression" />.Type is not assignable to the argument type of the method represented by <paramref name="method" />.</span></span>  
  
<span data-ttu-id="7593b-940">- 或 -</span><span class="sxs-lookup"><span data-stu-id="7593b-940">-or-</span></span> 
<span data-ttu-id="7593b-941"><paramref name="method" /> 所表示的方法的返回类型不能赋给 <paramref name="type" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-941">The return type of the method represented by <paramref name="method" /> is not assignable to <paramref name="type" />.</span></span>  
  
<span data-ttu-id="7593b-942">- 或 -</span><span class="sxs-lookup"><span data-stu-id="7593b-942">-or-</span></span> 
 <span data-ttu-id="7593b-943"><paramref name="expression" />.Type 或 <paramref name="type" /> 为可以为 null 的值类型，并且相应的不可以为 null 的值类型不分别等于 <paramref name="method" /> 所表示的方法的参数类型或返回类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-943"><paramref name="expression" />.Type or <paramref name="type" /> is a nullable value type and the corresponding non-nullable value type does not equal the argument type or the return type, respectively, of the method represented by <paramref name="method" />.</span></span></exception>
        <exception cref="T:System.Reflection.AmbiguousMatchException"><span data-ttu-id="7593b-944">找到多个与 <paramref name="method" /> 说明相匹配的方法。</span><span class="sxs-lookup"><span data-stu-id="7593b-944">More than one method that matches the <paramref name="method" /> description was found.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ConvertChecked">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="7593b-945">创建一个 <see cref="T:System.Linq.Expressions.UnaryExpression" />，它表示在目标类型发生溢出时引发异常的转换运算。</span><span class="sxs-lookup"><span data-stu-id="7593b-945">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents a conversion operation that throws an exception if the target type is overflowed.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ConvertChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression ConvertChecked (System.Linq.Expressions.Expression expression, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression ConvertChecked(class System.Linq.Expressions.Expression expression, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ConvertChecked(System.Linq.Expressions.Expression,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ ConvertChecked(System::Linq::Expressions::Expression ^ expression, Type ^ type);" />
      <MemberSignature Language="F#" Value="static member ConvertChecked : System.Linq.Expressions.Expression * Type -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.ConvertChecked (expression, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="expression"><span data-ttu-id="7593b-946">要将 <see cref="T:System.Linq.Expressions.Expression" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-946">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> property equal to.</span></span></param>
        <param name="type"><span data-ttu-id="7593b-947">要将 <see cref="T:System.Type" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.Expression.Type" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-947">A <see cref="T:System.Type" /> to set the <see cref="P:System.Linq.Expressions.Expression.Type" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="7593b-948">创建一个 <see cref="T:System.Linq.Expressions.UnaryExpression" />，它表示在目标类型发生溢出时引发异常的转换运算。</span><span class="sxs-lookup"><span data-stu-id="7593b-948">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents a conversion operation that throws an exception if the target type is overflowed.</span></span></summary>
        <returns><span data-ttu-id="7593b-949">一个 <see cref="T:System.Linq.Expressions.UnaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 属性等于 <see cref="F:System.Linq.Expressions.ExpressionType.ConvertChecked" />，并且其 <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> 和 <see cref="P:System.Linq.Expressions.Expression.Type" /> 属性设置为指定值。</span><span class="sxs-lookup"><span data-stu-id="7593b-949">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.ConvertChecked" /> and the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> and <see cref="P:System.Linq.Expressions.Expression.Type" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7593b-950">生成的 <xref:System.Linq.Expressions.UnaryExpression> 的 <xref:System.Linq.Expressions.UnaryExpression.Method%2A> 属性被设置为实现方法。</span><span class="sxs-lookup"><span data-stu-id="7593b-950">The <xref:System.Linq.Expressions.UnaryExpression.Method%2A> property of the resulting <xref:System.Linq.Expressions.UnaryExpression> is set to the implementing method.</span></span> <span data-ttu-id="7593b-951"><xref:System.Linq.Expressions.UnaryExpression.IsLiftedToNull%2A> 属性为 `false`。</span><span class="sxs-lookup"><span data-stu-id="7593b-951">The <xref:System.Linq.Expressions.UnaryExpression.IsLiftedToNull%2A> property is `false`.</span></span> <span data-ttu-id="7593b-952">如果节点已提升，则 <xref:System.Linq.Expressions.UnaryExpression.IsLifted%2A> `true`。</span><span class="sxs-lookup"><span data-stu-id="7593b-952">If the node is lifted, <xref:System.Linq.Expressions.UnaryExpression.IsLifted%2A> is `true`.</span></span> <span data-ttu-id="7593b-953">否则，它是 `false`。</span><span class="sxs-lookup"><span data-stu-id="7593b-953">Otherwise, it is `false`.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="7593b-954">实现方法</span><span class="sxs-lookup"><span data-stu-id="7593b-954">Implementing Method</span></span>  
 <span data-ttu-id="7593b-955">以下规则确定操作的实现方法：</span><span class="sxs-lookup"><span data-stu-id="7593b-955">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="7593b-956">如果 `expression`，则为。Type 或 `type` 是定义隐式转换或显式转换运算符的用户定义类型，表示该运算符的 <xref:System.Reflection.MethodInfo> 是实现方法。</span><span class="sxs-lookup"><span data-stu-id="7593b-956">If either `expression`.Type or `type` is a user-defined type that defines an implicit or explicit conversion operator, the <xref:System.Reflection.MethodInfo> that represents that operator is the implementing method.</span></span>  
  
-   <span data-ttu-id="7593b-957">否则：</span><span class="sxs-lookup"><span data-stu-id="7593b-957">Otherwise:</span></span>  
  
    -   <span data-ttu-id="7593b-958">如果 `expression`，则为。类型和 `type` 表示数字或布尔类型，或可为 null 或不可为 null 的枚举类型，实现方法是 `null`的。</span><span class="sxs-lookup"><span data-stu-id="7593b-958">If both `expression`.Type and `type` represent numeric or Boolean types, or nullable or non-nullable enumeration types, the implementing method is `null`.</span></span>  
  
    -   <span data-ttu-id="7593b-959">如果 `expression`，则为。类型或 `type` 是引用类型，并且存在来自 `expression`的显式装箱、取消装箱或引用转换。键入到 `type`，则实现方法为 `null`。</span><span class="sxs-lookup"><span data-stu-id="7593b-959">If either `expression`.Type or `type` is a reference type and an explicit boxing, unboxing, or reference conversion exists from `expression`.Type to `type`, the implementing method is `null`.</span></span>  
  
#### <a name="lifted-versus-non-lifted"></a><span data-ttu-id="7593b-960">提升和非提升</span><span class="sxs-lookup"><span data-stu-id="7593b-960">Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="7593b-961">如果不 `null`实现方法：</span><span class="sxs-lookup"><span data-stu-id="7593b-961">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="7593b-962">如果 `expression`。Type 可分配给实现方法的参数类型，实现方法的返回类型可分配给 `type`，不会提升节点。</span><span class="sxs-lookup"><span data-stu-id="7593b-962">If `expression`.Type is assignable to the argument type of the implementing method and the return type of the implementing method is assignable to `type`, the node is not lifted.</span></span>  
  
-   <span data-ttu-id="7593b-963">如果 `expression`中的一个或两个。类型或 `type` 是可以为 null 的值类型，并且相应的不可为 null 的值类型分别等于实现方法的参数类型和返回类型，节点将被提升。</span><span class="sxs-lookup"><span data-stu-id="7593b-963">If either or both of `expression`.Type or `type` are a nullable value type and the corresponding non-nullable value types are equal to the argument type and the return type of the implementing method respectively, the node is lifted.</span></span>  
  
 <span data-ttu-id="7593b-964">如果实现方法为 `null`：</span><span class="sxs-lookup"><span data-stu-id="7593b-964">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="7593b-965">如果 `expression`，则为。类型和 `type` 不可为 null，则不提升节点。</span><span class="sxs-lookup"><span data-stu-id="7593b-965">If both `expression`.Type and `type` are non-nullable, the node is not lifted.</span></span>  
  
-   <span data-ttu-id="7593b-966">否则，节点将被提升。</span><span class="sxs-lookup"><span data-stu-id="7593b-966">Otherwise the node is lifted.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="7593b-967"><paramref name="expression" /> 或 <paramref name="type" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-967"><paramref name="expression" /> or <paramref name="type" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="7593b-968">未定义 <paramref name="expression" />.Type 和 <paramref name="type" /> 之间的转换运算符。</span><span class="sxs-lookup"><span data-stu-id="7593b-968">No conversion operator is defined between <paramref name="expression" />.Type and <paramref name="type" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ConvertChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression ConvertChecked (System.Linq.Expressions.Expression expression, Type type, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression ConvertChecked(class System.Linq.Expressions.Expression expression, class System.Type type, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ConvertChecked(System.Linq.Expressions.Expression,System.Type,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ ConvertChecked(System::Linq::Expressions::Expression ^ expression, Type ^ type, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member ConvertChecked : System.Linq.Expressions.Expression * Type * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.ConvertChecked (expression, type, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="expression"><span data-ttu-id="7593b-969">要将 <see cref="T:System.Linq.Expressions.Expression" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-969">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> property equal to.</span></span></param>
        <param name="type"><span data-ttu-id="7593b-970">要将 <see cref="T:System.Type" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.Expression.Type" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-970">A <see cref="T:System.Type" /> to set the <see cref="P:System.Linq.Expressions.Expression.Type" /> property equal to.</span></span></param>
        <param name="method"><span data-ttu-id="7593b-971">要将 <see cref="T:System.Reflection.MethodInfo" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.UnaryExpression.Method" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-971">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="7593b-972">创建一个 <see cref="T:System.Linq.Expressions.UnaryExpression" />，它表示在目标类型发生溢出时引发异常且为其指定实现方法的转换运算。</span><span class="sxs-lookup"><span data-stu-id="7593b-972">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents a conversion operation that throws an exception if the target type is overflowed and for which the implementing method is specified.</span></span></summary>
        <returns><span data-ttu-id="7593b-973">一个 <see cref="T:System.Linq.Expressions.UnaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 属性等于 <see cref="F:System.Linq.Expressions.ExpressionType.ConvertChecked" />，并且其 <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />、<see cref="P:System.Linq.Expressions.Expression.Type" /> 和 <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> 属性设置为指定值。</span><span class="sxs-lookup"><span data-stu-id="7593b-973">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.ConvertChecked" /> and the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />, <see cref="P:System.Linq.Expressions.Expression.Type" />, and <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7593b-974">生成的 <xref:System.Linq.Expressions.UnaryExpression> 的 <xref:System.Linq.Expressions.UnaryExpression.Method%2A> 属性被设置为实现方法。</span><span class="sxs-lookup"><span data-stu-id="7593b-974">The <xref:System.Linq.Expressions.UnaryExpression.Method%2A> property of the resulting <xref:System.Linq.Expressions.UnaryExpression> is set to the implementing method.</span></span> <span data-ttu-id="7593b-975"><xref:System.Linq.Expressions.UnaryExpression.IsLiftedToNull%2A> 属性为 `false`。</span><span class="sxs-lookup"><span data-stu-id="7593b-975">The <xref:System.Linq.Expressions.UnaryExpression.IsLiftedToNull%2A> property is `false`.</span></span> <span data-ttu-id="7593b-976">如果节点已提升，则 <xref:System.Linq.Expressions.UnaryExpression.IsLifted%2A> `true`。</span><span class="sxs-lookup"><span data-stu-id="7593b-976">If the node is lifted, <xref:System.Linq.Expressions.UnaryExpression.IsLifted%2A> is `true`.</span></span> <span data-ttu-id="7593b-977">否则，它是 `false`。</span><span class="sxs-lookup"><span data-stu-id="7593b-977">Otherwise, it is `false`.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="7593b-978">实现方法</span><span class="sxs-lookup"><span data-stu-id="7593b-978">Implementing Method</span></span>  
 <span data-ttu-id="7593b-979">以下规则确定操作的实现方法：</span><span class="sxs-lookup"><span data-stu-id="7593b-979">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="7593b-980">如果未 `null`方法，则它是实现方法。</span><span class="sxs-lookup"><span data-stu-id="7593b-980">If method is not `null`, it is the implementing method.</span></span> <span data-ttu-id="7593b-981">它必须表示一个采用一个自变量的非 void `static``Shared` （Visual Basic）方法。</span><span class="sxs-lookup"><span data-stu-id="7593b-981">It must represent a non-void, `static` (`Shared` in Visual Basic) method that takes one argument.</span></span>  
  
-   <span data-ttu-id="7593b-982">如果 `expression`，则为; 否则为。Type 或 `type` 是定义隐式转换或显式转换运算符的用户定义类型，表示该运算符的 <xref:System.Reflection.MethodInfo> 是实现方法。</span><span class="sxs-lookup"><span data-stu-id="7593b-982">Otherwise, if either `expression`.Type or `type` is a user-defined type that defines an implicit or explicit conversion operator, the <xref:System.Reflection.MethodInfo> that represents that operator is the implementing method.</span></span>  
  
-   <span data-ttu-id="7593b-983">否则：</span><span class="sxs-lookup"><span data-stu-id="7593b-983">Otherwise:</span></span>  
  
    -   <span data-ttu-id="7593b-984">如果 `expression`，则为。类型和 `type` 表示数字或布尔类型，或可为 null 或不可为 null 的枚举类型，实现方法是 `null`的。</span><span class="sxs-lookup"><span data-stu-id="7593b-984">If both `expression`.Type and `type` represent numeric or Boolean types, or nullable or non-nullable enumeration types, the implementing method is `null`.</span></span>  
  
    -   <span data-ttu-id="7593b-985">如果 `expression`，则为。类型或 `type` 是引用类型，并且存在来自 `expression`的显式装箱、取消装箱或引用转换。键入到 `type`，则实现方法为 `null`。</span><span class="sxs-lookup"><span data-stu-id="7593b-985">If either `expression`.Type or `type` is a reference type and an explicit boxing, unboxing, or reference conversion exists from `expression`.Type to `type`, the implementing method is `null`.</span></span>  
  
#### <a name="lifted-versus-non-lifted"></a><span data-ttu-id="7593b-986">提升和非提升</span><span class="sxs-lookup"><span data-stu-id="7593b-986">Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="7593b-987">如果不 `null`实现方法：</span><span class="sxs-lookup"><span data-stu-id="7593b-987">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="7593b-988">如果 `expression`。Type 可分配给实现方法的参数类型，实现方法的返回类型可分配给 `type`，不会提升节点。</span><span class="sxs-lookup"><span data-stu-id="7593b-988">If `expression`.Type is assignable to the argument type of the implementing method and the return type of the implementing method is assignable to `type`, the node is not lifted.</span></span>  
  
-   <span data-ttu-id="7593b-989">如果 `expression`中的一个或两个。类型或 `type` 是可以为 null 的值类型，并且相应的不可为 null 的值类型分别等于实现方法的参数类型和返回类型，节点将被提升。</span><span class="sxs-lookup"><span data-stu-id="7593b-989">If either or both of `expression`.Type or `type` are a nullable value type and the corresponding non-nullable value types are equal to the argument type and the return type of the implementing method respectively, the node is lifted.</span></span>  
  
 <span data-ttu-id="7593b-990">如果实现方法为 `null`：</span><span class="sxs-lookup"><span data-stu-id="7593b-990">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="7593b-991">如果 `expression`，则为。类型和 `type` 不可为 null，则不提升节点。</span><span class="sxs-lookup"><span data-stu-id="7593b-991">If both `expression`.Type and `type` are non-nullable, the node is not lifted.</span></span>  
  
-   <span data-ttu-id="7593b-992">否则，节点将被提升。</span><span class="sxs-lookup"><span data-stu-id="7593b-992">Otherwise the node is lifted.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="7593b-993"><paramref name="expression" /> 或 <paramref name="type" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-993"><paramref name="expression" /> or <paramref name="type" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="7593b-994"><paramref name="method" /> 不为 <see langword="null" /> 且其表示的方法返回 <see langword="void" />；不为 <see langword="static" />（在 Visual Basic 中不为 <see langword="Shared" />）；或者不是正好带一个参数。</span><span class="sxs-lookup"><span data-stu-id="7593b-994"><paramref name="method" /> is not <see langword="null" /> and the method it represents returns <see langword="void" />, is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic), or does not take exactly one argument.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="7593b-995">未定义 <paramref name="expression" />.Type 和 <paramref name="type" /> 之间的转换运算符。</span><span class="sxs-lookup"><span data-stu-id="7593b-995">No conversion operator is defined between <paramref name="expression" />.Type and <paramref name="type" />.</span></span>  
  
<span data-ttu-id="7593b-996">- 或 -</span><span class="sxs-lookup"><span data-stu-id="7593b-996">-or-</span></span> 
 <span data-ttu-id="7593b-997"><paramref name="expression" />.Type 不能赋给 <paramref name="method" /> 所表示的方法的参数类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-997"><paramref name="expression" />.Type is not assignable to the argument type of the method represented by <paramref name="method" />.</span></span>  
  
<span data-ttu-id="7593b-998">- 或 -</span><span class="sxs-lookup"><span data-stu-id="7593b-998">-or-</span></span> 
<span data-ttu-id="7593b-999"><paramref name="method" /> 所表示的方法的返回类型不能赋给 <paramref name="type" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-999">The return type of the method represented by <paramref name="method" /> is not assignable to <paramref name="type" />.</span></span>  
  
<span data-ttu-id="7593b-1000">- 或 -</span><span class="sxs-lookup"><span data-stu-id="7593b-1000">-or-</span></span> 
 <span data-ttu-id="7593b-1001"><paramref name="expression" />.Type 或 <paramref name="type" /> 为可以为 null 的值类型，并且相应的不可以为 null 的值类型不分别等于 <paramref name="method" /> 所表示的方法的参数类型或返回类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-1001"><paramref name="expression" />.Type or <paramref name="type" /> is a nullable value type and the corresponding non-nullable value type does not equal the argument type or the return type, respectively, of the method represented by <paramref name="method" />.</span></span></exception>
        <exception cref="T:System.Reflection.AmbiguousMatchException"><span data-ttu-id="7593b-1002">找到多个与 <paramref name="method" /> 说明相匹配的方法。</span><span class="sxs-lookup"><span data-stu-id="7593b-1002">More than one method that matches the <paramref name="method" /> description was found.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="DebugInfo">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.DebugInfoExpression DebugInfo (System.Linq.Expressions.SymbolDocumentInfo document, int startLine, int startColumn, int endLine, int endColumn);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.DebugInfoExpression DebugInfo(class System.Linq.Expressions.SymbolDocumentInfo document, int32 startLine, int32 startColumn, int32 endLine, int32 endColumn) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.DebugInfo(System.Linq.Expressions.SymbolDocumentInfo,System.Int32,System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function DebugInfo (document As SymbolDocumentInfo, startLine As Integer, startColumn As Integer, endLine As Integer, endColumn As Integer) As DebugInfoExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::DebugInfoExpression ^ DebugInfo(System::Linq::Expressions::SymbolDocumentInfo ^ document, int startLine, int startColumn, int endLine, int endColumn);" />
      <MemberSignature Language="F#" Value="static member DebugInfo : System.Linq.Expressions.SymbolDocumentInfo * int * int * int * int -&gt; System.Linq.Expressions.DebugInfoExpression" Usage="System.Linq.Expressions.Expression.DebugInfo (document, startLine, startColumn, endLine, endColumn)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.DebugInfoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="document" Type="System.Linq.Expressions.SymbolDocumentInfo" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="startLine" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="startColumn" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="endLine" Type="System.Int32" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="endColumn" Type="System.Int32" Index="4" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="document"><span data-ttu-id="7593b-1003">表示源文件的 <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-1003">The <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> that represents the source file.</span></span></param>
        <param name="startLine"><span data-ttu-id="7593b-1004">此 <see cref="T:System.Linq.Expressions.DebugInfoExpression" /> 的起始行。</span><span class="sxs-lookup"><span data-stu-id="7593b-1004">The start line of this <see cref="T:System.Linq.Expressions.DebugInfoExpression" />.</span></span> <span data-ttu-id="7593b-1005">必须大于 0。</span><span class="sxs-lookup"><span data-stu-id="7593b-1005">Must be greater than 0.</span></span></param>
        <param name="startColumn"><span data-ttu-id="7593b-1006">此 <see cref="T:System.Linq.Expressions.DebugInfoExpression" /> 的起始列。</span><span class="sxs-lookup"><span data-stu-id="7593b-1006">The start column of this <see cref="T:System.Linq.Expressions.DebugInfoExpression" />.</span></span> <span data-ttu-id="7593b-1007">必须大于 0。</span><span class="sxs-lookup"><span data-stu-id="7593b-1007">Must be greater than 0.</span></span></param>
        <param name="endLine"><span data-ttu-id="7593b-1008">此 <see cref="T:System.Linq.Expressions.DebugInfoExpression" /> 的结束行。</span><span class="sxs-lookup"><span data-stu-id="7593b-1008">The end line of this <see cref="T:System.Linq.Expressions.DebugInfoExpression" />.</span></span> <span data-ttu-id="7593b-1009">必须大于或等于起始行。</span><span class="sxs-lookup"><span data-stu-id="7593b-1009">Must be greater or equal than the start line.</span></span></param>
        <param name="endColumn"><span data-ttu-id="7593b-1010">此 <see cref="T:System.Linq.Expressions.DebugInfoExpression" /> 的结束列。</span><span class="sxs-lookup"><span data-stu-id="7593b-1010">The end column of this <see cref="T:System.Linq.Expressions.DebugInfoExpression" />.</span></span> <span data-ttu-id="7593b-1011">如果结束行与起始行相同，则它必须大于或等于起始列。</span><span class="sxs-lookup"><span data-stu-id="7593b-1011">If the end line is the same as the start line, it must be greater or equal than the start column.</span></span> <span data-ttu-id="7593b-1012">任何情况下都必须大于 0。</span><span class="sxs-lookup"><span data-stu-id="7593b-1012">In any case, must be greater than 0.</span></span></param>
        <summary><span data-ttu-id="7593b-1013">创建一个具有指定跨度的 <see cref="T:System.Linq.Expressions.DebugInfoExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-1013">Creates a <see cref="T:System.Linq.Expressions.DebugInfoExpression" /> with the specified span.</span></span></summary>
        <returns><span data-ttu-id="7593b-1014"><see cref="T:System.Linq.Expressions.DebugInfoExpression" /> 的实例。</span><span class="sxs-lookup"><span data-stu-id="7593b-1014">An instance of <see cref="T:System.Linq.Expressions.DebugInfoExpression" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Decrement">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="7593b-1015">创建一个 <see cref="T:System.Linq.Expressions.UnaryExpression" />，它表示按 1 递减表达式值。</span><span class="sxs-lookup"><span data-stu-id="7593b-1015">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents the decrementing of the expression by 1.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Decrement">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression Decrement (System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression Decrement(class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Decrement(System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ Decrement(System::Linq::Expressions::Expression ^ expression);" />
      <MemberSignature Language="F#" Value="static member Decrement : System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.Decrement expression" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="expression"><span data-ttu-id="7593b-1016">要递减的 <see cref="T:System.Linq.Expressions.Expression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-1016">An <see cref="T:System.Linq.Expressions.Expression" /> to decrement.</span></span></param>
        <summary><span data-ttu-id="7593b-1017">创建一个 <see cref="T:System.Linq.Expressions.UnaryExpression" />，它表示按 1 递减表达式值。</span><span class="sxs-lookup"><span data-stu-id="7593b-1017">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents the decrementing of the expression by 1.</span></span></summary>
        <returns><span data-ttu-id="7593b-1018">一个表示已递减的表达式的 <see cref="T:System.Linq.Expressions.UnaryExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-1018">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents the decremented expression.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7593b-1019">此表达式是有效的，并且不会更改传递给它的对象的值。</span><span class="sxs-lookup"><span data-stu-id="7593b-1019">This expression is functional and does not change the value of the object passed to it.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="7593b-1020">下面的代码示例演示如何创建从给定的值中减去1的表达式。</span><span class="sxs-lookup"><span data-stu-id="7593b-1020">The following code example shows how to create an expression that subtracts 1 from a given value.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#5)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Decrement">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression Decrement (System.Linq.Expressions.Expression expression, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression Decrement(class System.Linq.Expressions.Expression expression, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Decrement(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ Decrement(System::Linq::Expressions::Expression ^ expression, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member Decrement : System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.Decrement (expression, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="expression"><span data-ttu-id="7593b-1021">要递减的 <see cref="T:System.Linq.Expressions.Expression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-1021">An <see cref="T:System.Linq.Expressions.Expression" /> to decrement.</span></span></param>
        <param name="method"><span data-ttu-id="7593b-1022">表示实现方法的 <see cref="T:System.Reflection.MethodInfo" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-1022">A <see cref="T:System.Reflection.MethodInfo" /> that represents the implementing method.</span></span></param>
        <summary><span data-ttu-id="7593b-1023">创建一个 <see cref="T:System.Linq.Expressions.UnaryExpression" />，它表示按 1 递减表达式值。</span><span class="sxs-lookup"><span data-stu-id="7593b-1023">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents the decrementing of the expression by 1.</span></span></summary>
        <returns><span data-ttu-id="7593b-1024">一个表示已递减的表达式的 <see cref="T:System.Linq.Expressions.UnaryExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-1024">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents the decremented expression.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7593b-1025">此表达式是有效的，并且不会更改传递给它的对象的值。</span><span class="sxs-lookup"><span data-stu-id="7593b-1025">This expression is functional and does not change the value of the object passed to it.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Default">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.DefaultExpression Default (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.DefaultExpression Default(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Default(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::DefaultExpression ^ Default(Type ^ type);" />
      <MemberSignature Language="F#" Value="static member Default : Type -&gt; System.Linq.Expressions.DefaultExpression" Usage="System.Linq.Expressions.Expression.Default type" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.DefaultExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="type"><span data-ttu-id="7593b-1026">要将 <see cref="T:System.Type" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.Expression.Type" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-1026">A <see cref="T:System.Type" /> to set the <see cref="P:System.Linq.Expressions.Expression.Type" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="7593b-1027">创建一个 <see cref="T:System.Linq.Expressions.DefaultExpression" />，<see cref="P:System.Linq.Expressions.Expression.Type" /> 属性设置为指定类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-1027">Creates a <see cref="T:System.Linq.Expressions.DefaultExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.Type" /> property set to the specified type.</span></span></summary>
        <returns><span data-ttu-id="7593b-1028">一个 <see cref="T:System.Linq.Expressions.DefaultExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 属性等于 <see cref="F:System.Linq.Expressions.ExpressionType.Default" />，并且其 <see cref="P:System.Linq.Expressions.Expression.Type" /> 属性设置为指定类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-1028">A <see cref="T:System.Linq.Expressions.DefaultExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Default" /> and the <see cref="P:System.Linq.Expressions.Expression.Type" /> property set to the specified type.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="7593b-1029">下面的代码示例演示如何创建一个表达式，该表达式表示给定类型的默认值。</span><span class="sxs-lookup"><span data-stu-id="7593b-1029">The following code example shows how to create an expression that represents a default value for a given type.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#6)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#6)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Divide">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="7593b-1030">创建一个表示算术除法运算的 <see cref="T:System.Linq.Expressions.BinaryExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-1030">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an arithmetic division operation.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Divide">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Divide (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Divide(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Divide(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Divide (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Divide(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member Divide : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.Divide (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="7593b-1031">要将 <see cref="T:System.Linq.Expressions.Expression" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-1031">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property to.</span></span></param>
        <param name="right"><span data-ttu-id="7593b-1032">要将 <see cref="T:System.Linq.Expressions.Expression" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-1032">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property to.</span></span></param>
        <summary><span data-ttu-id="7593b-1033">创建一个表示算术除法运算的 <see cref="T:System.Linq.Expressions.BinaryExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-1033">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an arithmetic division operation.</span></span></summary>
        <returns><span data-ttu-id="7593b-1034">一个 <see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 属性等于 <see cref="F:System.Linq.Expressions.ExpressionType.Divide" />，并且其 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 属性设置为指定值。</span><span class="sxs-lookup"><span data-stu-id="7593b-1034">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Divide" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7593b-1035">生成的 <xref:System.Linq.Expressions.BinaryExpression> 具有设置为实现方法的 <xref:System.Linq.Expressions.BinaryExpression.Method%2A> 属性。</span><span class="sxs-lookup"><span data-stu-id="7593b-1035">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="7593b-1036"><xref:System.Linq.Expressions.Expression.Type%2A> 属性设置为节点的类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-1036">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="7593b-1037">如果节点已提升，则 <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> 和 <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> 属性均 `true`。</span><span class="sxs-lookup"><span data-stu-id="7593b-1037">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="7593b-1038">否则，它们 `false`。</span><span class="sxs-lookup"><span data-stu-id="7593b-1038">Otherwise, they are `false`.</span></span> <span data-ttu-id="7593b-1039"><xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> 属性为 `null`。</span><span class="sxs-lookup"><span data-stu-id="7593b-1039">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="7593b-1040">以下信息描述了实现方法、节点类型以及节点是否已提升。</span><span class="sxs-lookup"><span data-stu-id="7593b-1040">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="7593b-1041">实现方法</span><span class="sxs-lookup"><span data-stu-id="7593b-1041">Implementing Method</span></span>  
 <span data-ttu-id="7593b-1042">以下规则确定操作的实现方法：</span><span class="sxs-lookup"><span data-stu-id="7593b-1042">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="7593b-1043">如果 `left` 或 `right` 的 <xref:System.Linq.Expressions.Expression.Type%2A> 属性表示重载除法运算符的用户定义类型，则表示该方法的 <xref:System.Reflection.MethodInfo> 是实现方法。</span><span class="sxs-lookup"><span data-stu-id="7593b-1043">If the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the division operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="7593b-1044">否则，如果 `left`。键入并 `right`。类型为数值类型，则实现方法为 `null`。</span><span class="sxs-lookup"><span data-stu-id="7593b-1044">Otherwise, if `left`.Type and `right`.Type are numeric types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="7593b-1045">节点类型和提升和非提升</span><span class="sxs-lookup"><span data-stu-id="7593b-1045">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="7593b-1046">如果不 `null`实现方法：</span><span class="sxs-lookup"><span data-stu-id="7593b-1046">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="7593b-1047">如果 `left`。键入并 `right`。类型可分配给实现方法的相应参数类型，不提升节点。</span><span class="sxs-lookup"><span data-stu-id="7593b-1047">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="7593b-1048">节点的类型是实现方法的返回类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-1048">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="7593b-1049">如果满足以下两个条件，则会提升节点，并且该节点的类型为与实现方法的返回类型对应的可以为 null 的类型：</span><span class="sxs-lookup"><span data-stu-id="7593b-1049">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="7593b-1050">`left`。键入并 `right`。类型既是值类型，其中至少有一个可为 null，并且相应的不可为 null 的类型等于实现方法的相应参数类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-1050">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="7593b-1051">实现方法的返回类型是不可为 null 的值类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-1051">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="7593b-1052">如果实现方法为 `null`：</span><span class="sxs-lookup"><span data-stu-id="7593b-1052">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="7593b-1053">如果 `left`。键入并 `right`。类型不可以为 null，则不提升节点。</span><span class="sxs-lookup"><span data-stu-id="7593b-1053">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="7593b-1054">节点的类型为预定义除法运算符的结果类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-1054">The type of the node is the result type of the predefined division operator.</span></span>  
  
-   <span data-ttu-id="7593b-1055">如果 `left`。键入并 `right`。类型均可为 null，则提升节点。</span><span class="sxs-lookup"><span data-stu-id="7593b-1055">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="7593b-1056">节点的类型是与预定义除法运算符的结果类型对应的可以为 null 的类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-1056">The type of the node is the nullable type that corresponds to the result type of the predefined division operator.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="7593b-1057">下面的代码示例演示如何创建一个表达式，该表达式将其第一个自变量除以其第二个自变量。</span><span class="sxs-lookup"><span data-stu-id="7593b-1057">The following code example shows how to create an expression that divides its first argument by its second argument.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#7)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="7593b-1058"><paramref name="left" /> 或 <paramref name="right" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-1058"><paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="7593b-1059">没有为 <paramref name="left" />.Type 和 <paramref name="right" />.Type 定义除法运算符。</span><span class="sxs-lookup"><span data-stu-id="7593b-1059">The division operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Divide">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Divide (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Divide(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Divide(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Divide (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Divide(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member Divide : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.Divide (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="7593b-1060">要将 <see cref="T:System.Linq.Expressions.Expression" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-1060">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="7593b-1061">要将 <see cref="T:System.Linq.Expressions.Expression" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-1061">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <param name="method"><span data-ttu-id="7593b-1062">要将 <see cref="T:System.Reflection.MethodInfo" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-1062">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="7593b-1063">创建一个表示算术除法运算的 <see cref="T:System.Linq.Expressions.BinaryExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-1063">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an arithmetic division operation.</span></span> <span data-ttu-id="7593b-1064">可指定实现方法。</span><span class="sxs-lookup"><span data-stu-id="7593b-1064">The implementing method can be specified.</span></span></summary>
        <returns><span data-ttu-id="7593b-1065">一个 <see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 属性等于 <see cref="F:System.Linq.Expressions.ExpressionType.Divide" />，并且其 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />、<see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> 属性设置为指定值。</span><span class="sxs-lookup"><span data-stu-id="7593b-1065">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Divide" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7593b-1066">生成的 <xref:System.Linq.Expressions.BinaryExpression> 具有设置为实现方法的 <xref:System.Linq.Expressions.BinaryExpression.Method%2A> 属性。</span><span class="sxs-lookup"><span data-stu-id="7593b-1066">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="7593b-1067"><xref:System.Linq.Expressions.Expression.Type%2A> 属性设置为节点的类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-1067">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="7593b-1068">如果节点已提升，则 <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> 和 <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> 属性均 `true`。</span><span class="sxs-lookup"><span data-stu-id="7593b-1068">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="7593b-1069">否则，它们 `false`。</span><span class="sxs-lookup"><span data-stu-id="7593b-1069">Otherwise, they are `false`.</span></span> <span data-ttu-id="7593b-1070"><xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> 属性为 `null`。</span><span class="sxs-lookup"><span data-stu-id="7593b-1070">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="7593b-1071">以下信息描述了实现方法、节点类型以及节点是否已提升。</span><span class="sxs-lookup"><span data-stu-id="7593b-1071">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="7593b-1072">实现方法</span><span class="sxs-lookup"><span data-stu-id="7593b-1072">Implementing Method</span></span>  
 <span data-ttu-id="7593b-1073">以下规则确定操作的实现方法：</span><span class="sxs-lookup"><span data-stu-id="7593b-1073">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="7593b-1074">如果 `method` 未 `null` 并且它表示采用两个自变量的非 void、`static``Shared` （Visual Basic）方法，则它是节点的实现方法。</span><span class="sxs-lookup"><span data-stu-id="7593b-1074">If `method` is not `null` and it represents a non-void, `static` (`Shared` in Visual Basic) method that takes two arguments, it is the implementing method for the node.</span></span>  
  
-   <span data-ttu-id="7593b-1075">否则，如果 `left` 或 `right` 的 <xref:System.Linq.Expressions.Expression.Type%2A> 属性表示重载除法运算符的用户定义类型，则表示该方法的 <xref:System.Reflection.MethodInfo> 是实现方法。</span><span class="sxs-lookup"><span data-stu-id="7593b-1075">Otherwise, if the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the division operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="7593b-1076">否则，如果 `left`。键入并 `right`。类型为数值类型，则实现方法为 `null`。</span><span class="sxs-lookup"><span data-stu-id="7593b-1076">Otherwise, if `left`.Type and `right`.Type are numeric types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="7593b-1077">节点类型和提升和非提升</span><span class="sxs-lookup"><span data-stu-id="7593b-1077">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="7593b-1078">如果不 `null`实现方法：</span><span class="sxs-lookup"><span data-stu-id="7593b-1078">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="7593b-1079">如果 `left`。键入并 `right`。类型可分配给实现方法的相应参数类型，不提升节点。</span><span class="sxs-lookup"><span data-stu-id="7593b-1079">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="7593b-1080">节点的类型是实现方法的返回类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-1080">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="7593b-1081">如果满足以下两个条件，则会提升节点，并且该节点的类型为与实现方法的返回类型对应的可以为 null 的类型：</span><span class="sxs-lookup"><span data-stu-id="7593b-1081">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="7593b-1082">`left`。键入并 `right`。类型既是值类型，其中至少有一个可为 null，并且相应的不可为 null 的类型等于实现方法的相应参数类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-1082">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="7593b-1083">实现方法的返回类型是不可为 null 的值类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-1083">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="7593b-1084">如果实现方法为 `null`：</span><span class="sxs-lookup"><span data-stu-id="7593b-1084">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="7593b-1085">如果 `left`。键入并 `right`。类型不可以为 null，则不提升节点。</span><span class="sxs-lookup"><span data-stu-id="7593b-1085">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="7593b-1086">节点的类型为预定义除法运算符的结果类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-1086">The type of the node is the result type of the predefined division operator.</span></span>  
  
-   <span data-ttu-id="7593b-1087">如果 `left`。键入并 `right`。类型均可为 null，则提升节点。</span><span class="sxs-lookup"><span data-stu-id="7593b-1087">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="7593b-1088">节点的类型是与预定义除法运算符的结果类型对应的可以为 null 的类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-1088">The type of the node is the nullable type that corresponds to the result type of the predefined division operator.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="7593b-1089"><paramref name="left" /> 或 <paramref name="right" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-1089"><paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="7593b-1090"><paramref name="method" /> 不是 <see langword="null" />，它所表示的方法返回 <see langword="void" />，而不是 <see langword="static" />（Visual Basic 中为 <see langword="Shared" />），或者并非采用两个参数。</span><span class="sxs-lookup"><span data-stu-id="7593b-1090"><paramref name="method" /> is not <see langword="null" /> and the method it represents returns <see langword="void" />, is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic), or does not take exactly two arguments.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="7593b-1091"><paramref name="method" /> 是 <see langword="null" />，且没有为 <paramref name="left" />.Type 和 <paramref name="right" />.Type 定义除法运算符。</span><span class="sxs-lookup"><span data-stu-id="7593b-1091"><paramref name="method" /> is <see langword="null" /> and the division operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="DivideAssign">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="7593b-1092">创建一个表示不进行溢出检查的除法赋值运算的 <see cref="T:System.Linq.Expressions.BinaryExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-1092">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a division assignment operation that does not have overflow checking.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DivideAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression DivideAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression DivideAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.DivideAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function DivideAssign (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ DivideAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member DivideAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.DivideAssign (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="7593b-1093">要将 <see cref="T:System.Linq.Expressions.Expression" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-1093">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="7593b-1094">要将 <see cref="T:System.Linq.Expressions.Expression" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-1094">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="7593b-1095">创建一个表示不进行溢出检查的除法赋值运算的 <see cref="T:System.Linq.Expressions.BinaryExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-1095">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a division assignment operation that does not have overflow checking.</span></span></summary>
        <returns><span data-ttu-id="7593b-1096">一个 <see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 属性等于 <see cref="F:System.Linq.Expressions.ExpressionType.DivideAssign" />，并且其 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 属性设置为指定值。</span><span class="sxs-lookup"><span data-stu-id="7593b-1096">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.DivideAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DivideAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression DivideAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression DivideAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.DivideAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function DivideAssign (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ DivideAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member DivideAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.DivideAssign (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="7593b-1097">要将 <see cref="T:System.Linq.Expressions.Expression" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-1097">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="7593b-1098">要将 <see cref="T:System.Linq.Expressions.Expression" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-1098">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <param name="method"><span data-ttu-id="7593b-1099">要将 <see cref="T:System.Reflection.MethodInfo" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-1099">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="7593b-1100">创建一个表示不进行溢出检查的除法赋值运算的 <see cref="T:System.Linq.Expressions.BinaryExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-1100">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a division assignment operation that does not have overflow checking.</span></span></summary>
        <returns><span data-ttu-id="7593b-1101">一个 <see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 属性等于 <see cref="F:System.Linq.Expressions.ExpressionType.DivideAssign" />，并且其 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />、<see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> 属性设置为指定值。</span><span class="sxs-lookup"><span data-stu-id="7593b-1101">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.DivideAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DivideAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression DivideAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method, System.Linq.Expressions.LambdaExpression conversion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression DivideAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method, class System.Linq.Expressions.LambdaExpression conversion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.DivideAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function DivideAssign (left As Expression, right As Expression, method As MethodInfo, conversion As LambdaExpression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ DivideAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method, System::Linq::Expressions::LambdaExpression ^ conversion);" />
      <MemberSignature Language="F#" Value="static member DivideAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo * System.Linq.Expressions.LambdaExpression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.DivideAssign (left, right, method, conversion)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="conversion" Type="System.Linq.Expressions.LambdaExpression" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="7593b-1102">要将 <see cref="T:System.Linq.Expressions.Expression" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-1102">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="7593b-1103">要将 <see cref="T:System.Linq.Expressions.Expression" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-1103">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <param name="method"><span data-ttu-id="7593b-1104">要将 <see cref="T:System.Reflection.MethodInfo" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-1104">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span></span></param>
        <param name="conversion"><span data-ttu-id="7593b-1105">要将 <see cref="T:System.Linq.Expressions.LambdaExpression" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-1105">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="7593b-1106">创建一个表示不进行溢出检查的除法赋值运算的 <see cref="T:System.Linq.Expressions.BinaryExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-1106">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a division assignment operation that does not have overflow checking.</span></span></summary>
        <returns><span data-ttu-id="7593b-1107">一个 <see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 属性等于 <see cref="F:System.Linq.Expressions.ExpressionType.DivideAssign" />，并且其 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />、<see cref="P:System.Linq.Expressions.BinaryExpression.Right" />、<see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> 属性设置为指定值。</span><span class="sxs-lookup"><span data-stu-id="7593b-1107">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.DivideAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Dynamic">
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="7593b-1108">创建一个表示动态操作的 <see cref="T:System.Linq.Expressions.DynamicExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-1108">Creates a <see cref="T:System.Linq.Expressions.DynamicExpression" /> that represents a dynamic operation.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dynamic">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.DynamicExpression Dynamic (System.Runtime.CompilerServices.CallSiteBinder binder, Type returnType, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.DynamicExpression Dynamic(class System.Runtime.CompilerServices.CallSiteBinder binder, class System.Type returnType, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Dynamic(System.Runtime.CompilerServices.CallSiteBinder,System.Type,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Dynamic (binder As CallSiteBinder, returnType As Type, arguments As IEnumerable(Of Expression)) As DynamicExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::DynamicExpression ^ Dynamic(System::Runtime::CompilerServices::CallSiteBinder ^ binder, Type ^ returnType, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberSignature Language="F#" Value="static member Dynamic : System.Runtime.CompilerServices.CallSiteBinder * Type * seq&lt;System.Linq.Expressions.Expression&gt; -&gt; System.Linq.Expressions.DynamicExpression" Usage="System.Linq.Expressions.Expression.Dynamic (binder, returnType, arguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.DynamicExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Runtime.CompilerServices.CallSiteBinder" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="returnType" Type="System.Type" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="arguments" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="binder"><span data-ttu-id="7593b-1109">动态操作的运行时联编程序。</span><span class="sxs-lookup"><span data-stu-id="7593b-1109">The runtime binder for the dynamic operation.</span></span></param>
        <param name="returnType"><span data-ttu-id="7593b-1110">动态表达式的结果类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-1110">The result type of the dynamic expression.</span></span></param>
        <param name="arguments"><span data-ttu-id="7593b-1111">动态操作的自变量。</span><span class="sxs-lookup"><span data-stu-id="7593b-1111">The arguments to the dynamic operation.</span></span></param>
        <summary><span data-ttu-id="7593b-1112">创建一个 <see cref="T:System.Linq.Expressions.DynamicExpression" />，它表示由提供的 <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> 绑定的动态操作。</span><span class="sxs-lookup"><span data-stu-id="7593b-1112">Creates a <see cref="T:System.Linq.Expressions.DynamicExpression" /> that represents a dynamic operation bound by the provided <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" />.</span></span></summary>
        <returns><span data-ttu-id="7593b-1113">一个 <see cref="T:System.Linq.Expressions.DynamicExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 等于 <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" />，并且其 <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> 和 <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> 均设置为指定的值。</span><span class="sxs-lookup"><span data-stu-id="7593b-1113">A <see cref="T:System.Linq.Expressions.DynamicExpression" /> that has <see cref="P:System.Linq.Expressions.Expression.NodeType" /> equal to <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> and has the <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> and <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7593b-1114">将从参数的类型和指定的返回类型推断结果的 <xref:System.Linq.Expressions.DynamicExpression.DelegateType%2A> 属性。</span><span class="sxs-lookup"><span data-stu-id="7593b-1114">The <xref:System.Linq.Expressions.DynamicExpression.DelegateType%2A> property of the result will be inferred from the types of the arguments and the specified return type.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dynamic">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.DynamicExpression Dynamic (System.Runtime.CompilerServices.CallSiteBinder binder, Type returnType, System.Linq.Expressions.Expression arg0);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.DynamicExpression Dynamic(class System.Runtime.CompilerServices.CallSiteBinder binder, class System.Type returnType, class System.Linq.Expressions.Expression arg0) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Dynamic(System.Runtime.CompilerServices.CallSiteBinder,System.Type,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Dynamic (binder As CallSiteBinder, returnType As Type, arg0 As Expression) As DynamicExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::DynamicExpression ^ Dynamic(System::Runtime::CompilerServices::CallSiteBinder ^ binder, Type ^ returnType, System::Linq::Expressions::Expression ^ arg0);" />
      <MemberSignature Language="F#" Value="static member Dynamic : System.Runtime.CompilerServices.CallSiteBinder * Type * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.DynamicExpression" Usage="System.Linq.Expressions.Expression.Dynamic (binder, returnType, arg0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.DynamicExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Runtime.CompilerServices.CallSiteBinder" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="returnType" Type="System.Type" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="binder"><span data-ttu-id="7593b-1115">动态操作的运行时联编程序。</span><span class="sxs-lookup"><span data-stu-id="7593b-1115">The runtime binder for the dynamic operation.</span></span></param>
        <param name="returnType"><span data-ttu-id="7593b-1116">动态表达式的结果类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-1116">The result type of the dynamic expression.</span></span></param>
        <param name="arg0"><span data-ttu-id="7593b-1117">动态操作的第一个参数。</span><span class="sxs-lookup"><span data-stu-id="7593b-1117">The first argument to the dynamic operation.</span></span></param>
        <summary><span data-ttu-id="7593b-1118">创建一个 <see cref="T:System.Linq.Expressions.DynamicExpression" />，它表示由提供的 <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> 绑定的动态操作。</span><span class="sxs-lookup"><span data-stu-id="7593b-1118">Creates a <see cref="T:System.Linq.Expressions.DynamicExpression" /> that represents a dynamic operation bound by the provided <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" />.</span></span></summary>
        <returns><span data-ttu-id="7593b-1119">一个 <see cref="T:System.Linq.Expressions.DynamicExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 等于 <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" />，并且其 <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> 和 <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> 均设置为指定的值。</span><span class="sxs-lookup"><span data-stu-id="7593b-1119">A <see cref="T:System.Linq.Expressions.DynamicExpression" /> that has <see cref="P:System.Linq.Expressions.Expression.NodeType" /> equal to <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> and has the <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> and <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7593b-1120">将从参数的类型和指定的返回类型推断结果的 <xref:System.Linq.Expressions.DynamicExpression.DelegateType%2A> 属性。</span><span class="sxs-lookup"><span data-stu-id="7593b-1120">The <xref:System.Linq.Expressions.DynamicExpression.DelegateType%2A> property of the result will be inferred from the types of the arguments and the specified return type.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dynamic">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.DynamicExpression Dynamic (System.Runtime.CompilerServices.CallSiteBinder binder, Type returnType, params System.Linq.Expressions.Expression[] arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.DynamicExpression Dynamic(class System.Runtime.CompilerServices.CallSiteBinder binder, class System.Type returnType, class System.Linq.Expressions.Expression[] arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Dynamic(System.Runtime.CompilerServices.CallSiteBinder,System.Type,System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Dynamic (binder As CallSiteBinder, returnType As Type, ParamArray arguments As Expression()) As DynamicExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::DynamicExpression ^ Dynamic(System::Runtime::CompilerServices::CallSiteBinder ^ binder, Type ^ returnType, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberSignature Language="F#" Value="static member Dynamic : System.Runtime.CompilerServices.CallSiteBinder * Type * System.Linq.Expressions.Expression[] -&gt; System.Linq.Expressions.DynamicExpression" Usage="System.Linq.Expressions.Expression.Dynamic (binder, returnType, arguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.DynamicExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Runtime.CompilerServices.CallSiteBinder" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="returnType" Type="System.Type" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="arguments" Type="System.Linq.Expressions.Expression[]" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="binder"><span data-ttu-id="7593b-1121">动态操作的运行时联编程序。</span><span class="sxs-lookup"><span data-stu-id="7593b-1121">The runtime binder for the dynamic operation.</span></span></param>
        <param name="returnType"><span data-ttu-id="7593b-1122">动态表达式的结果类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-1122">The result type of the dynamic expression.</span></span></param>
        <param name="arguments"><span data-ttu-id="7593b-1123">动态操作的自变量。</span><span class="sxs-lookup"><span data-stu-id="7593b-1123">The arguments to the dynamic operation.</span></span></param>
        <summary><span data-ttu-id="7593b-1124">创建一个 <see cref="T:System.Linq.Expressions.DynamicExpression" />，它表示由提供的 <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> 绑定的动态操作。</span><span class="sxs-lookup"><span data-stu-id="7593b-1124">Creates a <see cref="T:System.Linq.Expressions.DynamicExpression" /> that represents a dynamic operation bound by the provided <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" />.</span></span></summary>
        <returns><span data-ttu-id="7593b-1125">一个 <see cref="T:System.Linq.Expressions.DynamicExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 等于 <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" />，并且其 <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> 和 <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> 均设置为指定的值。</span><span class="sxs-lookup"><span data-stu-id="7593b-1125">A <see cref="T:System.Linq.Expressions.DynamicExpression" /> that has <see cref="P:System.Linq.Expressions.Expression.NodeType" /> equal to <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> and has the <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> and <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7593b-1126">将从参数的类型和指定的返回类型推断结果的 <xref:System.Linq.Expressions.DynamicExpression.DelegateType%2A> 属性。</span><span class="sxs-lookup"><span data-stu-id="7593b-1126">The <xref:System.Linq.Expressions.DynamicExpression.DelegateType%2A> property of the result will be inferred from the types of the arguments and the specified return type.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dynamic">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.DynamicExpression Dynamic (System.Runtime.CompilerServices.CallSiteBinder binder, Type returnType, System.Linq.Expressions.Expression arg0, System.Linq.Expressions.Expression arg1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.DynamicExpression Dynamic(class System.Runtime.CompilerServices.CallSiteBinder binder, class System.Type returnType, class System.Linq.Expressions.Expression arg0, class System.Linq.Expressions.Expression arg1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Dynamic(System.Runtime.CompilerServices.CallSiteBinder,System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Dynamic (binder As CallSiteBinder, returnType As Type, arg0 As Expression, arg1 As Expression) As DynamicExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::DynamicExpression ^ Dynamic(System::Runtime::CompilerServices::CallSiteBinder ^ binder, Type ^ returnType, System::Linq::Expressions::Expression ^ arg0, System::Linq::Expressions::Expression ^ arg1);" />
      <MemberSignature Language="F#" Value="static member Dynamic : System.Runtime.CompilerServices.CallSiteBinder * Type * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.DynamicExpression" Usage="System.Linq.Expressions.Expression.Dynamic (binder, returnType, arg0, arg1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.DynamicExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Runtime.CompilerServices.CallSiteBinder" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="returnType" Type="System.Type" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="arg1" Type="System.Linq.Expressions.Expression" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="binder"><span data-ttu-id="7593b-1127">动态操作的运行时联编程序。</span><span class="sxs-lookup"><span data-stu-id="7593b-1127">The runtime binder for the dynamic operation.</span></span></param>
        <param name="returnType"><span data-ttu-id="7593b-1128">动态表达式的结果类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-1128">The result type of the dynamic expression.</span></span></param>
        <param name="arg0"><span data-ttu-id="7593b-1129">动态操作的第一个参数。</span><span class="sxs-lookup"><span data-stu-id="7593b-1129">The first argument to the dynamic operation.</span></span></param>
        <param name="arg1"><span data-ttu-id="7593b-1130">动态操作的第二个自变量。</span><span class="sxs-lookup"><span data-stu-id="7593b-1130">The second argument to the dynamic operation.</span></span></param>
        <summary><span data-ttu-id="7593b-1131">创建一个 <see cref="T:System.Linq.Expressions.DynamicExpression" />，它表示由提供的 <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> 绑定的动态操作。</span><span class="sxs-lookup"><span data-stu-id="7593b-1131">Creates a <see cref="T:System.Linq.Expressions.DynamicExpression" /> that represents a dynamic operation bound by the provided <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" />.</span></span></summary>
        <returns><span data-ttu-id="7593b-1132">一个 <see cref="T:System.Linq.Expressions.DynamicExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 等于 <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" />，并且其 <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> 和 <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> 均设置为指定的值。</span><span class="sxs-lookup"><span data-stu-id="7593b-1132">A <see cref="T:System.Linq.Expressions.DynamicExpression" /> that has <see cref="P:System.Linq.Expressions.Expression.NodeType" /> equal to <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> and has the <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> and <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7593b-1133">将从参数的类型和指定的返回类型推断结果的 <xref:System.Linq.Expressions.DynamicExpression.DelegateType%2A> 属性。</span><span class="sxs-lookup"><span data-stu-id="7593b-1133">The <xref:System.Linq.Expressions.DynamicExpression.DelegateType%2A> property of the result will be inferred from the types of the arguments and the specified return type.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dynamic">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.DynamicExpression Dynamic (System.Runtime.CompilerServices.CallSiteBinder binder, Type returnType, System.Linq.Expressions.Expression arg0, System.Linq.Expressions.Expression arg1, System.Linq.Expressions.Expression arg2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.DynamicExpression Dynamic(class System.Runtime.CompilerServices.CallSiteBinder binder, class System.Type returnType, class System.Linq.Expressions.Expression arg0, class System.Linq.Expressions.Expression arg1, class System.Linq.Expressions.Expression arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Dynamic(System.Runtime.CompilerServices.CallSiteBinder,System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Dynamic (binder As CallSiteBinder, returnType As Type, arg0 As Expression, arg1 As Expression, arg2 As Expression) As DynamicExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::DynamicExpression ^ Dynamic(System::Runtime::CompilerServices::CallSiteBinder ^ binder, Type ^ returnType, System::Linq::Expressions::Expression ^ arg0, System::Linq::Expressions::Expression ^ arg1, System::Linq::Expressions::Expression ^ arg2);" />
      <MemberSignature Language="F#" Value="static member Dynamic : System.Runtime.CompilerServices.CallSiteBinder * Type * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.DynamicExpression" Usage="System.Linq.Expressions.Expression.Dynamic (binder, returnType, arg0, arg1, arg2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.DynamicExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Runtime.CompilerServices.CallSiteBinder" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="returnType" Type="System.Type" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="arg1" Type="System.Linq.Expressions.Expression" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="arg2" Type="System.Linq.Expressions.Expression" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="binder"><span data-ttu-id="7593b-1134">动态操作的运行时联编程序。</span><span class="sxs-lookup"><span data-stu-id="7593b-1134">The runtime binder for the dynamic operation.</span></span></param>
        <param name="returnType"><span data-ttu-id="7593b-1135">动态表达式的结果类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-1135">The result type of the dynamic expression.</span></span></param>
        <param name="arg0"><span data-ttu-id="7593b-1136">动态操作的第一个参数。</span><span class="sxs-lookup"><span data-stu-id="7593b-1136">The first argument to the dynamic operation.</span></span></param>
        <param name="arg1"><span data-ttu-id="7593b-1137">动态操作的第二个自变量。</span><span class="sxs-lookup"><span data-stu-id="7593b-1137">The second argument to the dynamic operation.</span></span></param>
        <param name="arg2"><span data-ttu-id="7593b-1138">动态操作的第三个自变量。</span><span class="sxs-lookup"><span data-stu-id="7593b-1138">The third argument to the dynamic operation.</span></span></param>
        <summary><span data-ttu-id="7593b-1139">创建一个 <see cref="T:System.Linq.Expressions.DynamicExpression" />，它表示由提供的 <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> 绑定的动态操作。</span><span class="sxs-lookup"><span data-stu-id="7593b-1139">Creates a <see cref="T:System.Linq.Expressions.DynamicExpression" /> that represents a dynamic operation bound by the provided <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" />.</span></span></summary>
        <returns><span data-ttu-id="7593b-1140">一个 <see cref="T:System.Linq.Expressions.DynamicExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 等于 <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" />，并且其 <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> 和 <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> 均设置为指定的值。</span><span class="sxs-lookup"><span data-stu-id="7593b-1140">A <see cref="T:System.Linq.Expressions.DynamicExpression" /> that has <see cref="P:System.Linq.Expressions.Expression.NodeType" /> equal to <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> and has the <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> and <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7593b-1141">将从参数的类型和指定的返回类型推断结果的 <xref:System.Linq.Expressions.DynamicExpression.DelegateType%2A> 属性。</span><span class="sxs-lookup"><span data-stu-id="7593b-1141">The <xref:System.Linq.Expressions.DynamicExpression.DelegateType%2A> property of the result will be inferred from the types of the arguments and the specified return type.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dynamic">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.DynamicExpression Dynamic (System.Runtime.CompilerServices.CallSiteBinder binder, Type returnType, System.Linq.Expressions.Expression arg0, System.Linq.Expressions.Expression arg1, System.Linq.Expressions.Expression arg2, System.Linq.Expressions.Expression arg3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.DynamicExpression Dynamic(class System.Runtime.CompilerServices.CallSiteBinder binder, class System.Type returnType, class System.Linq.Expressions.Expression arg0, class System.Linq.Expressions.Expression arg1, class System.Linq.Expressions.Expression arg2, class System.Linq.Expressions.Expression arg3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Dynamic(System.Runtime.CompilerServices.CallSiteBinder,System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Dynamic (binder As CallSiteBinder, returnType As Type, arg0 As Expression, arg1 As Expression, arg2 As Expression, arg3 As Expression) As DynamicExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::DynamicExpression ^ Dynamic(System::Runtime::CompilerServices::CallSiteBinder ^ binder, Type ^ returnType, System::Linq::Expressions::Expression ^ arg0, System::Linq::Expressions::Expression ^ arg1, System::Linq::Expressions::Expression ^ arg2, System::Linq::Expressions::Expression ^ arg3);" />
      <MemberSignature Language="F#" Value="static member Dynamic : System.Runtime.CompilerServices.CallSiteBinder * Type * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.DynamicExpression" Usage="System.Linq.Expressions.Expression.Dynamic (binder, returnType, arg0, arg1, arg2, arg3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.DynamicExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Runtime.CompilerServices.CallSiteBinder" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="returnType" Type="System.Type" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="arg1" Type="System.Linq.Expressions.Expression" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="arg2" Type="System.Linq.Expressions.Expression" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="arg3" Type="System.Linq.Expressions.Expression" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="binder"><span data-ttu-id="7593b-1142">动态操作的运行时联编程序。</span><span class="sxs-lookup"><span data-stu-id="7593b-1142">The runtime binder for the dynamic operation.</span></span></param>
        <param name="returnType"><span data-ttu-id="7593b-1143">动态表达式的结果类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-1143">The result type of the dynamic expression.</span></span></param>
        <param name="arg0"><span data-ttu-id="7593b-1144">动态操作的第一个参数。</span><span class="sxs-lookup"><span data-stu-id="7593b-1144">The first argument to the dynamic operation.</span></span></param>
        <param name="arg1"><span data-ttu-id="7593b-1145">动态操作的第二个自变量。</span><span class="sxs-lookup"><span data-stu-id="7593b-1145">The second argument to the dynamic operation.</span></span></param>
        <param name="arg2"><span data-ttu-id="7593b-1146">动态操作的第三个自变量。</span><span class="sxs-lookup"><span data-stu-id="7593b-1146">The third argument to the dynamic operation.</span></span></param>
        <param name="arg3"><span data-ttu-id="7593b-1147">动态操作的第四个参数。</span><span class="sxs-lookup"><span data-stu-id="7593b-1147">The fourth argument to the dynamic operation.</span></span></param>
        <summary><span data-ttu-id="7593b-1148">创建一个 <see cref="T:System.Linq.Expressions.DynamicExpression" />，它表示由提供的 <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> 绑定的动态操作。</span><span class="sxs-lookup"><span data-stu-id="7593b-1148">Creates a <see cref="T:System.Linq.Expressions.DynamicExpression" /> that represents a dynamic operation bound by the provided <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" />.</span></span></summary>
        <returns><span data-ttu-id="7593b-1149">一个 <see cref="T:System.Linq.Expressions.DynamicExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 等于 <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" />，并且其 <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> 和 <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> 均设置为指定的值。</span><span class="sxs-lookup"><span data-stu-id="7593b-1149">A <see cref="T:System.Linq.Expressions.DynamicExpression" /> that has <see cref="P:System.Linq.Expressions.Expression.NodeType" /> equal to <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> and has the <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> and <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7593b-1150">将从参数的类型和指定的返回类型推断结果的 <xref:System.Linq.Expressions.DynamicExpression.DelegateType%2A> 属性。</span><span class="sxs-lookup"><span data-stu-id="7593b-1150">The <xref:System.Linq.Expressions.DynamicExpression.DelegateType%2A> property of the result will be inferred from the types of the arguments and the specified return type.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ElementInit">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="7593b-1151">创建一个 <see cref="T:System.Linq.Expressions.ElementInit" />.</span><span class="sxs-lookup"><span data-stu-id="7593b-1151">Creates an <see cref="T:System.Linq.Expressions.ElementInit" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ElementInit">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ElementInit ElementInit (System.Reflection.MethodInfo addMethod, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ElementInit ElementInit(class System.Reflection.MethodInfo addMethod, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ElementInit(System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ElementInit (addMethod As MethodInfo, arguments As IEnumerable(Of Expression)) As ElementInit" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::ElementInit ^ ElementInit(System::Reflection::MethodInfo ^ addMethod, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberSignature Language="F#" Value="static member ElementInit : System.Reflection.MethodInfo * seq&lt;System.Linq.Expressions.Expression&gt; -&gt; System.Linq.Expressions.ElementInit" Usage="System.Linq.Expressions.Expression.ElementInit (addMethod, arguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ElementInit</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="addMethod" Type="System.Reflection.MethodInfo" />
        <Parameter Name="arguments" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="addMethod"><span data-ttu-id="7593b-1152">要将 <see cref="T:System.Reflection.MethodInfo" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.ElementInit.AddMethod" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-1152">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.ElementInit.AddMethod" /> property equal to.</span></span></param>
        <param name="arguments"><span data-ttu-id="7593b-1153"><see cref="T:System.Collections.Generic.IEnumerable`1" />（包含 <see cref="T:System.Linq.Expressions.Expression" /> 对象）要将 <see cref="P:System.Linq.Expressions.ElementInit.Arguments" /> 属性设置为与其相等。</span><span class="sxs-lookup"><span data-stu-id="7593b-1153">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.Expression" /> objects to set the <see cref="P:System.Linq.Expressions.ElementInit.Arguments" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="7593b-1154">在给定 <see cref="T:System.Linq.Expressions.ElementInit" /> 作为第二个参数的情况下，创建一个 <see cref="T:System.Collections.Generic.IEnumerable`1" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-1154">Creates an <see cref="T:System.Linq.Expressions.ElementInit" />, given an <see cref="T:System.Collections.Generic.IEnumerable`1" /> as the second argument.</span></span></summary>
        <returns><span data-ttu-id="7593b-1155">一个 <see cref="T:System.Linq.Expressions.ElementInit" />，其 <see cref="P:System.Linq.Expressions.ElementInit.AddMethod" /> 和 <see cref="P:System.Linq.Expressions.ElementInit.Arguments" /> 属性设置为指定值。</span><span class="sxs-lookup"><span data-stu-id="7593b-1155">An <see cref="T:System.Linq.Expressions.ElementInit" /> that has the <see cref="P:System.Linq.Expressions.ElementInit.AddMethod" /> and <see cref="P:System.Linq.Expressions.ElementInit.Arguments" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7593b-1156">`addMethod` 参数必须表示名为 "Add" （不区分大小写）的实例方法。</span><span class="sxs-lookup"><span data-stu-id="7593b-1156">The `addMethod` parameter must represent an instance method named "Add" (case insensitive).</span></span> <span data-ttu-id="7593b-1157">Add 方法的参数数目必须与 `arguments`中的元素数相同。</span><span class="sxs-lookup"><span data-stu-id="7593b-1157">The add method must have the same number of parameters as the number of elements in `arguments`.</span></span> <span data-ttu-id="7593b-1158">`arguments` 中每个元素的 <xref:System.Linq.Expressions.Expression.Type%2A> 属性都必须分配给添加方法的对应参数的类型，可能在加*引号*后。</span><span class="sxs-lookup"><span data-stu-id="7593b-1158">The <xref:System.Linq.Expressions.Expression.Type%2A> property of each element in `arguments` must be assignable to the type of the corresponding parameter of the add method, possibly after *quoting*.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="7593b-1159">仅当对应的方法参数为类型 <xref:System.Linq.Expressions.Expression>时，才会将元素括起来。</span><span class="sxs-lookup"><span data-stu-id="7593b-1159">An element will be quoted only if the corresponding method parameter is of type <xref:System.Linq.Expressions.Expression>.</span></span> <span data-ttu-id="7593b-1160">引号表示元素包装在 <xref:System.Linq.Expressions.ExpressionType.Quote> 节点中。</span><span class="sxs-lookup"><span data-stu-id="7593b-1160">Quoting means the element is wrapped in a <xref:System.Linq.Expressions.ExpressionType.Quote> node.</span></span> <span data-ttu-id="7593b-1161">生成的节点是一个 <xref:System.Linq.Expressions.UnaryExpression>，其 <xref:System.Linq.Expressions.UnaryExpression.Operand%2A> 属性是 `arguments`的元素。</span><span class="sxs-lookup"><span data-stu-id="7593b-1161">The resulting node is a <xref:System.Linq.Expressions.UnaryExpression> whose <xref:System.Linq.Expressions.UnaryExpression.Operand%2A> property is the element of `arguments`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="7593b-1162">下面的示例演示如何使用 <xref:System.Linq.Expressions.Expression.ElementInit%28System.Reflection.MethodInfo%2CSystem.Linq.Expressions.Expression%5B%5D%29> 方法创建一个表示调用 <xref:System.Collections.Generic.Dictionary%602.Add%2A> 方法以初始化字典集合的元素的 <xref:System.Linq.Expressions.ElementInit>。</span><span class="sxs-lookup"><span data-stu-id="7593b-1162">The following example demonstrates how to use the <xref:System.Linq.Expressions.Expression.ElementInit%28System.Reflection.MethodInfo%2CSystem.Linq.Expressions.Expression%5B%5D%29> method to create an <xref:System.Linq.Expressions.ElementInit> that represents calling the <xref:System.Collections.Generic.Dictionary%602.Add%2A> method to initialize an element of a dictionary collection.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.Expression#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#4)]
 [!code-vb[System.Linq.Expressions.Expression#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="7593b-1163"><paramref name="addMethod" /> 或 <paramref name="arguments" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-1163"><paramref name="addMethod" /> or <paramref name="arguments" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="7593b-1164"><paramref name="addMethod" /> 表示的方法的名称不是“Add”（不区分大小写）。</span><span class="sxs-lookup"><span data-stu-id="7593b-1164">The method that <paramref name="addMethod" /> represents is not named "Add" (case insensitive).</span></span>  
  
<span data-ttu-id="7593b-1165">- 或 -</span><span class="sxs-lookup"><span data-stu-id="7593b-1165">-or-</span></span> 
<span data-ttu-id="7593b-1166"><paramref name="addMethod" /> 表示的方法不是实例方法。</span><span class="sxs-lookup"><span data-stu-id="7593b-1166">The method that <paramref name="addMethod" /> represents is not an instance method.</span></span>  
  
<span data-ttu-id="7593b-1167">- 或 -</span><span class="sxs-lookup"><span data-stu-id="7593b-1167">-or-</span></span> 
 <span data-ttu-id="7593b-1168"><paramref name="arguments" /> 不包含与 <paramref name="addMethod" /> 表示的方法的参数数目相同的元素数目。</span><span class="sxs-lookup"><span data-stu-id="7593b-1168"><paramref name="arguments" /> does not contain the same number of elements as the number of parameters for the method that <paramref name="addMethod" /> represents.</span></span>  
  
<span data-ttu-id="7593b-1169">- 或 -</span><span class="sxs-lookup"><span data-stu-id="7593b-1169">-or-</span></span> 
<span data-ttu-id="7593b-1170"><see cref="P:System.Linq.Expressions.Expression.Type" /> 的一个或多个元素的 <paramref name="arguments" /> 属性不能赋给 <paramref name="addMethod" /> 表示的方法的相应参数类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-1170">The <see cref="P:System.Linq.Expressions.Expression.Type" /> property of one or more elements of <paramref name="arguments" /> is not assignable to the type of the corresponding parameter of the method that <paramref name="addMethod" /> represents.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ElementInit">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ElementInit ElementInit (System.Reflection.MethodInfo addMethod, params System.Linq.Expressions.Expression[] arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ElementInit ElementInit(class System.Reflection.MethodInfo addMethod, class System.Linq.Expressions.Expression[] arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ElementInit(System.Reflection.MethodInfo,System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ElementInit (addMethod As MethodInfo, ParamArray arguments As Expression()) As ElementInit" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::ElementInit ^ ElementInit(System::Reflection::MethodInfo ^ addMethod, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberSignature Language="F#" Value="static member ElementInit : System.Reflection.MethodInfo * System.Linq.Expressions.Expression[] -&gt; System.Linq.Expressions.ElementInit" Usage="System.Linq.Expressions.Expression.ElementInit (addMethod, arguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ElementInit</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="addMethod" Type="System.Reflection.MethodInfo" />
        <Parameter Name="arguments" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="addMethod"><span data-ttu-id="7593b-1171">要将 <see cref="T:System.Reflection.MethodInfo" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.ElementInit.AddMethod" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-1171">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.ElementInit.AddMethod" /> property equal to.</span></span></param>
        <param name="arguments"><span data-ttu-id="7593b-1172">要将 <see cref="T:System.Linq.Expressions.Expression" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.ElementInit.Arguments" /> 对象的数组。</span><span class="sxs-lookup"><span data-stu-id="7593b-1172">An array of <see cref="T:System.Linq.Expressions.Expression" /> objects to set the <see cref="P:System.Linq.Expressions.ElementInit.Arguments" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="7593b-1173">在给定值数组作为第二个自变量的情况下，创建一个 <see cref="T:System.Linq.Expressions.ElementInit" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-1173">Creates an <see cref="T:System.Linq.Expressions.ElementInit" />, given an array of values as the second argument.</span></span></summary>
        <returns><span data-ttu-id="7593b-1174">一个 <see cref="T:System.Linq.Expressions.ElementInit" />，其 <see cref="P:System.Linq.Expressions.ElementInit.AddMethod" /> 和 <see cref="P:System.Linq.Expressions.ElementInit.Arguments" /> 属性设置为指定值。</span><span class="sxs-lookup"><span data-stu-id="7593b-1174">An <see cref="T:System.Linq.Expressions.ElementInit" /> that has the <see cref="P:System.Linq.Expressions.ElementInit.AddMethod" /> and <see cref="P:System.Linq.Expressions.ElementInit.Arguments" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7593b-1175">`addMethod` 参数必须表示名为 "Add" （不区分大小写）的实例方法。</span><span class="sxs-lookup"><span data-stu-id="7593b-1175">The `addMethod` parameter must represent an instance method named "Add" (case insensitive).</span></span> <span data-ttu-id="7593b-1176">Add 方法的参数数目必须与 `arguments`中的元素数相同。</span><span class="sxs-lookup"><span data-stu-id="7593b-1176">The add method must have the same number of parameters as the number of elements in `arguments`.</span></span> <span data-ttu-id="7593b-1177">`arguments` 中每个元素的 <xref:System.Linq.Expressions.Expression.Type%2A> 属性都必须分配给添加方法的对应参数的类型，可能在加*引号*后。</span><span class="sxs-lookup"><span data-stu-id="7593b-1177">The <xref:System.Linq.Expressions.Expression.Type%2A> property of each element in `arguments` must be assignable to the type of the corresponding parameter of the add method, possibly after *quoting*.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="7593b-1178">仅当对应的方法参数为类型 <xref:System.Linq.Expressions.Expression>时，才会将元素括起来。</span><span class="sxs-lookup"><span data-stu-id="7593b-1178">An element will be quoted only if the corresponding method parameter is of type <xref:System.Linq.Expressions.Expression>.</span></span> <span data-ttu-id="7593b-1179">引号表示元素包装在 <xref:System.Linq.Expressions.ExpressionType.Quote> 节点中。</span><span class="sxs-lookup"><span data-stu-id="7593b-1179">Quoting means the element is wrapped in a <xref:System.Linq.Expressions.ExpressionType.Quote> node.</span></span> <span data-ttu-id="7593b-1180">生成的节点是一个 <xref:System.Linq.Expressions.UnaryExpression>，其 <xref:System.Linq.Expressions.UnaryExpression.Operand%2A> 属性是 `arguments`的元素。</span><span class="sxs-lookup"><span data-stu-id="7593b-1180">The resulting node is a <xref:System.Linq.Expressions.UnaryExpression> whose <xref:System.Linq.Expressions.UnaryExpression.Operand%2A> property is the element of `arguments`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="7593b-1181">下面的示例演示如何使用 <xref:System.Linq.Expressions.Expression.ElementInit%28System.Reflection.MethodInfo%2CSystem.Linq.Expressions.Expression%5B%5D%29> 方法创建一个表示调用 <xref:System.Collections.Generic.Dictionary%602.Add%2A> 方法以初始化字典集合的元素的 <xref:System.Linq.Expressions.ElementInit>。</span><span class="sxs-lookup"><span data-stu-id="7593b-1181">The following example demonstrates how to use the <xref:System.Linq.Expressions.Expression.ElementInit%28System.Reflection.MethodInfo%2CSystem.Linq.Expressions.Expression%5B%5D%29> method to create an <xref:System.Linq.Expressions.ElementInit> that represents calling the <xref:System.Collections.Generic.Dictionary%602.Add%2A> method to initialize an element of a dictionary collection.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.Expression#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#4)]
 [!code-vb[System.Linq.Expressions.Expression#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="7593b-1182"><paramref name="addMethod" /> 或 <paramref name="arguments" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-1182"><paramref name="addMethod" /> or <paramref name="arguments" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="7593b-1183">addMethod 表示的方法未命名为"Add"（不区分大小写）。</span><span class="sxs-lookup"><span data-stu-id="7593b-1183">The method that addMethod represents is not named "Add" (case insensitive).</span></span>  
  
<span data-ttu-id="7593b-1184">- 或 -</span><span class="sxs-lookup"><span data-stu-id="7593b-1184">-or-</span></span> 
<span data-ttu-id="7593b-1185">addMethod 表示的方法不是实例方法。</span><span class="sxs-lookup"><span data-stu-id="7593b-1185">The method that addMethod represents is not an instance method.</span></span>  
  
<span data-ttu-id="7593b-1186">- 或 -</span><span class="sxs-lookup"><span data-stu-id="7593b-1186">-or-</span></span> 
<span data-ttu-id="7593b-1187">arguments 包含的元素数量与 addMethod 所表示的方法的参数数量不同。</span><span class="sxs-lookup"><span data-stu-id="7593b-1187">arguments does not contain the same number of elements as the number of parameters for the method that addMethod represents.</span></span>  
  
<span data-ttu-id="7593b-1188">- 或 -</span><span class="sxs-lookup"><span data-stu-id="7593b-1188">-or-</span></span> 
<span data-ttu-id="7593b-1189"><see cref="P:System.Linq.Expressions.Expression.Type" /> 的一个或多个元素的 <paramref name="arguments" /> 属性不能赋给 <paramref name="addMethod" /> 表示的方法的相应参数类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-1189">The <see cref="P:System.Linq.Expressions.Expression.Type" /> property of one or more elements of <paramref name="arguments" /> is not assignable to the type of the corresponding parameter of the method that <paramref name="addMethod" /> represents.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Empty">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.DefaultExpression Empty ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.DefaultExpression Empty() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Empty" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Empty () As DefaultExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::DefaultExpression ^ Empty();" />
      <MemberSignature Language="F#" Value="static member Empty : unit -&gt; System.Linq.Expressions.DefaultExpression" Usage="System.Linq.Expressions.Expression.Empty " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.DefaultExpression</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="7593b-1190">创建具有 <see cref="T:System.Void" /> 类型的空表达式。</span><span class="sxs-lookup"><span data-stu-id="7593b-1190">Creates an empty expression that has <see cref="T:System.Void" /> type.</span></span></summary>
        <returns><span data-ttu-id="7593b-1191">一个 <see cref="T:System.Linq.Expressions.DefaultExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 属性等于 <see cref="F:System.Linq.Expressions.ExpressionType.Default" />，并且其 <see cref="P:System.Linq.Expressions.Expression.Type" /> 属性设置为 <see cref="T:System.Void" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-1191">A <see cref="T:System.Linq.Expressions.DefaultExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Default" /> and the <see cref="P:System.Linq.Expressions.Expression.Type" /> property set to <see cref="T:System.Void" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7593b-1192">如果需要表达式，但不需要执行任何操作，则可以使用空表达式。</span><span class="sxs-lookup"><span data-stu-id="7593b-1192">An empty expression can be used where an expression is expected but no action is desired.</span></span> <span data-ttu-id="7593b-1193">例如，你可以使用空表达式作为块表达式中的最后一个表达式。</span><span class="sxs-lookup"><span data-stu-id="7593b-1193">For example, you can use an empty expression as the last expression in a block expression.</span></span> <span data-ttu-id="7593b-1194">在这种情况下，块表达式的返回值为 void。</span><span class="sxs-lookup"><span data-stu-id="7593b-1194">In this case, the block expression's return value is void.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="7593b-1195">下面的代码示例演示如何创建一个空表达式并将其添加到块表达式。</span><span class="sxs-lookup"><span data-stu-id="7593b-1195">The following code example shows how to create an empty expression and add it to a block expression.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#31](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#31)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#31](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#31)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Equal">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="7593b-1196">创建一个表示相等比较的 <see cref="T:System.Linq.Expressions.BinaryExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-1196">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an equality comparison.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Equal">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Equal (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Equal(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Equal(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Equal (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Equal(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member Equal : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.Equal (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="7593b-1197">要将 <see cref="T:System.Linq.Expressions.Expression" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-1197">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="7593b-1198">要将 <see cref="T:System.Linq.Expressions.Expression" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-1198">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="7593b-1199">创建一个表示相等比较的 <see cref="T:System.Linq.Expressions.BinaryExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-1199">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an equality comparison.</span></span></summary>
        <returns><span data-ttu-id="7593b-1200">一个 <see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 属性等于 <see cref="F:System.Linq.Expressions.ExpressionType.Equal" />，并且其 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 属性设置为指定值。</span><span class="sxs-lookup"><span data-stu-id="7593b-1200">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Equal" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7593b-1201">生成的 <xref:System.Linq.Expressions.BinaryExpression> 具有设置为实现方法的 <xref:System.Linq.Expressions.BinaryExpression.Method%2A> 属性。</span><span class="sxs-lookup"><span data-stu-id="7593b-1201">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="7593b-1202"><xref:System.Linq.Expressions.Expression.Type%2A> 属性设置为节点的类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-1202">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="7593b-1203">如果节点已提升，则 `true`<xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> 属性。</span><span class="sxs-lookup"><span data-stu-id="7593b-1203">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> property is `true`.</span></span> <span data-ttu-id="7593b-1204">否则，它是 `false`。</span><span class="sxs-lookup"><span data-stu-id="7593b-1204">Otherwise, it is `false`.</span></span> <span data-ttu-id="7593b-1205"><xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> 属性始终为 `false`。</span><span class="sxs-lookup"><span data-stu-id="7593b-1205">The <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> property is always `false`.</span></span> <span data-ttu-id="7593b-1206">以下信息描述了实现方法、节点类型以及节点是否已提升。</span><span class="sxs-lookup"><span data-stu-id="7593b-1206">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="7593b-1207">实现方法</span><span class="sxs-lookup"><span data-stu-id="7593b-1207">Implementing Method</span></span>  
 <span data-ttu-id="7593b-1208">以下规则确定操作的实现方法：</span><span class="sxs-lookup"><span data-stu-id="7593b-1208">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="7593b-1209">如果 `left` 或 `right` 的 <xref:System.Linq.Expressions.Expression.Type%2A> 属性表示重载相等运算符的用户定义的类型，则表示该方法的 <xref:System.Reflection.MethodInfo> 是实现方法。</span><span class="sxs-lookup"><span data-stu-id="7593b-1209">If the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the equality operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="7593b-1210">否则，实现方法为 `null`。</span><span class="sxs-lookup"><span data-stu-id="7593b-1210">Otherwise, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="7593b-1211">节点类型和提升和非提升</span><span class="sxs-lookup"><span data-stu-id="7593b-1211">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="7593b-1212">如果不 `null`实现方法：</span><span class="sxs-lookup"><span data-stu-id="7593b-1212">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="7593b-1213">如果 `left`。键入并 `right`。类型可分配给实现方法的相应参数类型，不提升节点。</span><span class="sxs-lookup"><span data-stu-id="7593b-1213">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="7593b-1214">节点的类型是实现方法的返回类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-1214">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="7593b-1215">如果满足以下两个条件，则会提升节点并 <xref:System.Boolean>节点的类型：</span><span class="sxs-lookup"><span data-stu-id="7593b-1215">If the following two conditions are satisfied, the node is lifted and the type of the node is <xref:System.Boolean>:</span></span>  
  
    -   <span data-ttu-id="7593b-1216">`left`。键入并 `right`。类型既是值类型，其中至少有一个可为 null，并且相应的不可为 null 的类型等于实现方法的相应参数类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-1216">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="7593b-1217">实现方法的返回类型为 <xref:System.Boolean>。</span><span class="sxs-lookup"><span data-stu-id="7593b-1217">The return type of the implementing method is <xref:System.Boolean>.</span></span>  
  
 <span data-ttu-id="7593b-1218">如果实现方法为 `null`：</span><span class="sxs-lookup"><span data-stu-id="7593b-1218">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="7593b-1219">如果 `left`。键入并 `right`。类型不可以为 null，则不提升节点。</span><span class="sxs-lookup"><span data-stu-id="7593b-1219">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="7593b-1220">节点的类型为 <xref:System.Boolean>。</span><span class="sxs-lookup"><span data-stu-id="7593b-1220">The type of the node is <xref:System.Boolean>.</span></span>  
  
-   <span data-ttu-id="7593b-1221">如果 `left`。键入并 `right`。类型均可为 null，则提升节点。</span><span class="sxs-lookup"><span data-stu-id="7593b-1221">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="7593b-1222">节点的类型为 <xref:System.Boolean>。</span><span class="sxs-lookup"><span data-stu-id="7593b-1222">The type of the node is <xref:System.Boolean>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="7593b-1223">下面的代码示例演示如何创建一个表达式，用于检查其两个参数的值是否相等。</span><span class="sxs-lookup"><span data-stu-id="7593b-1223">The following code example shows how to create an expression that checks whether the values of its two arguments are equal.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#8)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="7593b-1224"><paramref name="left" /> 或 <paramref name="right" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-1224"><paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="7593b-1225">没有为 <paramref name="left" />.Type 和 <paramref name="right" />.Type 定义相等运算符。</span><span class="sxs-lookup"><span data-stu-id="7593b-1225">The equality operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Equal">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Equal (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, bool liftToNull, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Equal(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, bool liftToNull, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Equal(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Equal (left As Expression, right As Expression, liftToNull As Boolean, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Equal(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, bool liftToNull, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member Equal : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * bool * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.Equal (left, right, liftToNull, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="liftToNull" Type="System.Boolean" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="7593b-1226">要将 <see cref="T:System.Linq.Expressions.Expression" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-1226">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="7593b-1227">要将 <see cref="T:System.Linq.Expressions.Expression" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-1227">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <param name="liftToNull"><span data-ttu-id="7593b-1228">若要将 <see langword="true" /> 设置为 <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" />，则为 <see langword="true" />；若要将 <see langword="false" /> 设置为 <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" />，则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-1228"><see langword="true" /> to set <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> to <see langword="true" />; <see langword="false" /> to set <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> to <see langword="false" />.</span></span></param>
        <param name="method"><span data-ttu-id="7593b-1229">要将 <see cref="T:System.Reflection.MethodInfo" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-1229">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="7593b-1230">创建一个表示相等比较的 <see cref="T:System.Linq.Expressions.BinaryExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-1230">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an equality comparison.</span></span> <span data-ttu-id="7593b-1231">可指定实现方法。</span><span class="sxs-lookup"><span data-stu-id="7593b-1231">The implementing method can be specified.</span></span></summary>
        <returns><span data-ttu-id="7593b-1232">一个 <see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 属性等于 <see cref="F:System.Linq.Expressions.ExpressionType.Equal" />，并且其 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />、<see cref="P:System.Linq.Expressions.BinaryExpression.Right" />、<see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> 属性设置为指定值。</span><span class="sxs-lookup"><span data-stu-id="7593b-1232">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Equal" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7593b-1233">生成的 <xref:System.Linq.Expressions.BinaryExpression> 具有设置为实现方法的 <xref:System.Linq.Expressions.BinaryExpression.Method%2A> 属性。</span><span class="sxs-lookup"><span data-stu-id="7593b-1233">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="7593b-1234"><xref:System.Linq.Expressions.Expression.Type%2A> 属性设置为节点的类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-1234">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="7593b-1235">如果节点已提升，则 `true` <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> 属性，<xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> 属性等于 `liftToNull`。</span><span class="sxs-lookup"><span data-stu-id="7593b-1235">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> property is `true` and the <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> property is equal to `liftToNull`.</span></span> <span data-ttu-id="7593b-1236">否则，它们都 `false`。</span><span class="sxs-lookup"><span data-stu-id="7593b-1236">Otherwise, they are both `false`.</span></span> <span data-ttu-id="7593b-1237">以下信息描述了实现方法、节点类型以及节点是否已提升。</span><span class="sxs-lookup"><span data-stu-id="7593b-1237">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="7593b-1238">实现方法</span><span class="sxs-lookup"><span data-stu-id="7593b-1238">Implementing Method</span></span>  
 <span data-ttu-id="7593b-1239">以下规则确定操作的实现方法：</span><span class="sxs-lookup"><span data-stu-id="7593b-1239">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="7593b-1240">如果 `method` 未 `null` 并且它表示采用两个自变量的非 void、`static``Shared` （Visual Basic）方法，则它是实现方法。</span><span class="sxs-lookup"><span data-stu-id="7593b-1240">If `method` is not `null` and it represents a non-void, `static` (`Shared` in Visual Basic) method that takes two arguments, it is the implementing method.</span></span>  
  
-   <span data-ttu-id="7593b-1241">否则，如果 `left` 或 `right` 的 <xref:System.Linq.Expressions.Expression.Type%2A> 属性表示重载相等运算符的用户定义的类型，则表示该方法的 <xref:System.Reflection.MethodInfo> 是实现方法。</span><span class="sxs-lookup"><span data-stu-id="7593b-1241">Otherwise, if the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the equality operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="7593b-1242">否则，实现方法为 `null`。</span><span class="sxs-lookup"><span data-stu-id="7593b-1242">Otherwise, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="7593b-1243">节点类型和提升和非提升</span><span class="sxs-lookup"><span data-stu-id="7593b-1243">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="7593b-1244">如果不 `null`实现方法：</span><span class="sxs-lookup"><span data-stu-id="7593b-1244">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="7593b-1245">如果 `left`。键入并 `right`。类型可分配给实现方法的相应参数类型，不提升节点。</span><span class="sxs-lookup"><span data-stu-id="7593b-1245">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="7593b-1246">节点的类型是实现方法的返回类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-1246">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="7593b-1247">如果满足以下两个条件，则提升节点;此外，如果 `liftToNull` `false`，则节点类型可以为 null <xref:System.Boolean> 如果 `liftToNull` `true` 或 <xref:System.Boolean>：</span><span class="sxs-lookup"><span data-stu-id="7593b-1247">If the following two conditions are satisfied, the node is lifted; also, the type of the node is nullable <xref:System.Boolean> if `liftToNull` is `true` or <xref:System.Boolean> if `liftToNull` is `false`:</span></span>  
  
    -   <span data-ttu-id="7593b-1248">`left`。键入并 `right`。类型既是值类型，其中至少有一个可为 null，并且相应的不可为 null 的类型等于实现方法的相应参数类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-1248">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="7593b-1249">实现方法的返回类型为 <xref:System.Boolean>。</span><span class="sxs-lookup"><span data-stu-id="7593b-1249">The return type of the implementing method is <xref:System.Boolean>.</span></span>  
  
 <span data-ttu-id="7593b-1250">如果实现方法为 `null`：</span><span class="sxs-lookup"><span data-stu-id="7593b-1250">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="7593b-1251">如果 `left`。键入并 `right`。类型不可以为 null，则不提升节点。</span><span class="sxs-lookup"><span data-stu-id="7593b-1251">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="7593b-1252">节点的类型为 <xref:System.Boolean>。</span><span class="sxs-lookup"><span data-stu-id="7593b-1252">The type of the node is <xref:System.Boolean>.</span></span>  
  
-   <span data-ttu-id="7593b-1253">如果 `left`。键入并 `right`。类型均可为 null，则提升节点。</span><span class="sxs-lookup"><span data-stu-id="7593b-1253">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="7593b-1254">如果 `liftToNull` `true`，则节点的类型可以为 null <xref:System.Boolean> 如果 `liftToNull` `false`，则为 <xref:System.Boolean>。</span><span class="sxs-lookup"><span data-stu-id="7593b-1254">The type of the node is nullable <xref:System.Boolean> if `liftToNull` is `true` or <xref:System.Boolean> if `liftToNull` is `false`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="7593b-1255"><paramref name="left" /> 或 <paramref name="right" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-1255"><paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="7593b-1256"><paramref name="method" /> 不是 <see langword="null" />，它所表示的方法返回 <see langword="void" />，而不是 <see langword="static" />（Visual Basic 中为 <see langword="Shared" />），或者并非采用两个参数。</span><span class="sxs-lookup"><span data-stu-id="7593b-1256"><paramref name="method" /> is not <see langword="null" /> and the method it represents returns <see langword="void" />, is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic), or does not take exactly two arguments.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="7593b-1257"><paramref name="method" /> 为 <see langword="null" />，并且没有为 <paramref name="left" />.Type 和 <paramref name="right" />.Type 定义相等运算符。</span><span class="sxs-lookup"><span data-stu-id="7593b-1257"><paramref name="method" /> is <see langword="null" /> and the equality operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ExclusiveOr">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="7593b-1258">创建一个表示按位 <see cref="T:System.Linq.Expressions.BinaryExpression" /> 运算的 <see langword="XOR" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-1258">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise <see langword="XOR" /> operation.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ExclusiveOr">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression ExclusiveOr (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression ExclusiveOr(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ExclusiveOr(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ExclusiveOr (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ ExclusiveOr(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member ExclusiveOr : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.ExclusiveOr (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="7593b-1259">要将 <see cref="T:System.Linq.Expressions.Expression" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-1259">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="7593b-1260">要将 <see cref="T:System.Linq.Expressions.Expression" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-1260">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="7593b-1261">通过对用户定义的类型使用 <see cref="T:System.Linq.Expressions.BinaryExpression" />op_ExclusiveOr<see langword="XOR" />，创建一个表示按位 <c>运算的</c>。</span><span class="sxs-lookup"><span data-stu-id="7593b-1261">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise <see langword="XOR" /> operation, using <c>op_ExclusiveOr</c> for user-defined types.</span></span></summary>
        <returns><span data-ttu-id="7593b-1262">一个 <see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 属性等于 <see cref="F:System.Linq.Expressions.ExpressionType.ExclusiveOr" />，并且其 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 属性设置为指定值。</span><span class="sxs-lookup"><span data-stu-id="7593b-1262">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.ExclusiveOr" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7593b-1263">生成的 <xref:System.Linq.Expressions.BinaryExpression> 具有设置为实现方法的 <xref:System.Linq.Expressions.BinaryExpression.Method%2A> 属性。</span><span class="sxs-lookup"><span data-stu-id="7593b-1263">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="7593b-1264"><xref:System.Linq.Expressions.Expression.Type%2A> 属性设置为节点的类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-1264">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="7593b-1265">如果节点已提升，则 <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> 和 <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> 属性均 `true`。</span><span class="sxs-lookup"><span data-stu-id="7593b-1265">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="7593b-1266">否则，它们 `false`。</span><span class="sxs-lookup"><span data-stu-id="7593b-1266">Otherwise, they are `false`.</span></span> <span data-ttu-id="7593b-1267"><xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> 属性为 `null`。</span><span class="sxs-lookup"><span data-stu-id="7593b-1267">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="7593b-1268">以下信息描述了实现方法、节点类型以及节点是否已提升。</span><span class="sxs-lookup"><span data-stu-id="7593b-1268">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="7593b-1269">实现方法</span><span class="sxs-lookup"><span data-stu-id="7593b-1269">Implementing Method</span></span>  
 <span data-ttu-id="7593b-1270">以下规则确定操作的实现方法：</span><span class="sxs-lookup"><span data-stu-id="7593b-1270">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="7593b-1271">如果 `left` 或 `right` 的 <xref:System.Linq.Expressions.Expression.Type%2A> 属性表示重载 `XOR` 运算符的用户定义类型，则表示该方法的 <xref:System.Reflection.MethodInfo> 是实现方法。</span><span class="sxs-lookup"><span data-stu-id="7593b-1271">If the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the `XOR` operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="7593b-1272">否则，如果 `left`。键入并 `right`。类型为整型或布尔类型，则实现方法为 `null`。</span><span class="sxs-lookup"><span data-stu-id="7593b-1272">Otherwise, if `left`.Type and `right`.Type are integral or Boolean types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="7593b-1273">节点类型和提升和非提升</span><span class="sxs-lookup"><span data-stu-id="7593b-1273">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="7593b-1274">如果不 `null`实现方法：</span><span class="sxs-lookup"><span data-stu-id="7593b-1274">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="7593b-1275">如果 `left`。键入并 `right`。类型可分配给实现方法的相应参数类型，不提升节点。</span><span class="sxs-lookup"><span data-stu-id="7593b-1275">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="7593b-1276">节点的类型是实现方法的返回类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-1276">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="7593b-1277">如果满足以下两个条件，则会提升节点，并且该节点的类型为与实现方法的返回类型对应的可以为 null 的类型：</span><span class="sxs-lookup"><span data-stu-id="7593b-1277">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="7593b-1278">`left`。键入并 `right`。类型既是值类型，其中至少有一个可为 null，并且相应的不可为 null 的类型等于实现方法的相应参数类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-1278">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="7593b-1279">实现方法的返回类型是不可为 null 的值类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-1279">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="7593b-1280">如果实现方法为 `null`：</span><span class="sxs-lookup"><span data-stu-id="7593b-1280">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="7593b-1281">如果 `left`。键入并 `right`。类型不可以为 null，则不提升节点。</span><span class="sxs-lookup"><span data-stu-id="7593b-1281">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="7593b-1282">节点的类型是预定义的 `XOR` 运算符的结果类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-1282">The type of the node is the result type of the predefined `XOR` operator.</span></span>  
  
-   <span data-ttu-id="7593b-1283">如果 `left`。键入并 `right`。类型均可为 null，则提升节点。</span><span class="sxs-lookup"><span data-stu-id="7593b-1283">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="7593b-1284">节点的类型是与预定义 `XOR` 运算符的结果类型对应的可以为 null 的类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-1284">The type of the node is the nullable type that corresponds to the result type of the predefined `XOR` operator.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="7593b-1285">下面的代码示例演示如何创建表示逻辑 XOR 运算的表达式。</span><span class="sxs-lookup"><span data-stu-id="7593b-1285">The following code example shows how to create an expression that represents the logical XOR operation.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#9)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="7593b-1286"><paramref name="left" /> 或 <paramref name="right" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-1286"><paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="7593b-1287">没有为 <see langword="XOR" />.Type 和 <paramref name="left" />.Type 定义 <paramref name="right" /> 运算符。</span><span class="sxs-lookup"><span data-stu-id="7593b-1287">The <see langword="XOR" /> operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ExclusiveOr">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression ExclusiveOr (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression ExclusiveOr(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ExclusiveOr(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ExclusiveOr (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ ExclusiveOr(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member ExclusiveOr : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.ExclusiveOr (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="7593b-1288">要将 <see cref="T:System.Linq.Expressions.Expression" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-1288">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="7593b-1289">要将 <see cref="T:System.Linq.Expressions.Expression" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-1289">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <param name="method"><span data-ttu-id="7593b-1290">要将 <see cref="T:System.Reflection.MethodInfo" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-1290">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="7593b-1291">通过对用户定义的类型使用 <see cref="T:System.Linq.Expressions.BinaryExpression" />op_ExclusiveOr<see langword="XOR" />，创建一个表示按位 <c>运算的</c>。</span><span class="sxs-lookup"><span data-stu-id="7593b-1291">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise <see langword="XOR" /> operation, using <c>op_ExclusiveOr</c> for user-defined types.</span></span> <span data-ttu-id="7593b-1292">可指定实现方法。</span><span class="sxs-lookup"><span data-stu-id="7593b-1292">The implementing method can be specified.</span></span></summary>
        <returns><span data-ttu-id="7593b-1293">一个 <see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 属性等于 <see cref="F:System.Linq.Expressions.ExpressionType.ExclusiveOr" />，并且其 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />、<see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> 属性设置为指定值。</span><span class="sxs-lookup"><span data-stu-id="7593b-1293">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.ExclusiveOr" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7593b-1294">生成的 <xref:System.Linq.Expressions.BinaryExpression> 具有设置为实现方法的 <xref:System.Linq.Expressions.BinaryExpression.Method%2A> 属性。</span><span class="sxs-lookup"><span data-stu-id="7593b-1294">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="7593b-1295"><xref:System.Linq.Expressions.Expression.Type%2A> 属性设置为节点的类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-1295">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="7593b-1296">如果节点已提升，则 <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> 和 <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> 属性均 `true`。</span><span class="sxs-lookup"><span data-stu-id="7593b-1296">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="7593b-1297">否则，它们 `false`。</span><span class="sxs-lookup"><span data-stu-id="7593b-1297">Otherwise, they are `false`.</span></span> <span data-ttu-id="7593b-1298"><xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> 属性为 `null`。</span><span class="sxs-lookup"><span data-stu-id="7593b-1298">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="7593b-1299">以下信息描述了实现方法、节点类型以及节点是否已提升。</span><span class="sxs-lookup"><span data-stu-id="7593b-1299">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="7593b-1300">实现方法</span><span class="sxs-lookup"><span data-stu-id="7593b-1300">Implementing Method</span></span>  
 <span data-ttu-id="7593b-1301">以下规则确定为操作选择的实现方法：</span><span class="sxs-lookup"><span data-stu-id="7593b-1301">The following rules determine the chosen implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="7593b-1302">如果 `method` 未 `null` 并且它表示采用两个自变量的非 void、`static``Shared` （Visual Basic）方法，则它是实现方法。</span><span class="sxs-lookup"><span data-stu-id="7593b-1302">If `method` is not `null` and it represents a non-void, `static` (`Shared` in Visual Basic) method that takes two arguments, it is the implementing method.</span></span>  
  
-   <span data-ttu-id="7593b-1303">否则，如果 `left` 或 `right` 的 <xref:System.Linq.Expressions.Expression.Type%2A> 属性表示重载 `XOR` 运算符的用户定义类型，则表示该方法的 <xref:System.Reflection.MethodInfo> 是实现方法。</span><span class="sxs-lookup"><span data-stu-id="7593b-1303">Otherwise, if the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the `XOR` operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="7593b-1304">否则，如果 `left`。键入并 `right`。类型为整型或布尔类型，则实现方法为 `null`。</span><span class="sxs-lookup"><span data-stu-id="7593b-1304">Otherwise, if `left`.Type and `right`.Type are integral or Boolean types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="7593b-1305">节点类型和提升和非提升</span><span class="sxs-lookup"><span data-stu-id="7593b-1305">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="7593b-1306">如果不 `null`实现方法：</span><span class="sxs-lookup"><span data-stu-id="7593b-1306">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="7593b-1307">如果 `left`。键入并 `right`。类型可分配给实现方法的相应参数类型，不提升节点。</span><span class="sxs-lookup"><span data-stu-id="7593b-1307">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="7593b-1308">节点的类型是实现方法的返回类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-1308">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="7593b-1309">如果满足以下两个条件，则会提升节点，并且该节点的类型为与实现方法的返回类型对应的可以为 null 的类型：</span><span class="sxs-lookup"><span data-stu-id="7593b-1309">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="7593b-1310">`left`。键入并 `right`。类型既是值类型，其中至少有一个可为 null，并且相应的不可为 null 的类型等于实现方法的相应参数类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-1310">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="7593b-1311">实现方法的返回类型是不可为 null 的值类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-1311">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="7593b-1312">如果实现方法为 `null`：</span><span class="sxs-lookup"><span data-stu-id="7593b-1312">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="7593b-1313">如果 `left`。键入并 `right`。类型不可以为 null，则不提升节点。</span><span class="sxs-lookup"><span data-stu-id="7593b-1313">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="7593b-1314">节点的类型是预定义的 `XOR` 运算符的结果类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-1314">The type of the node is the result type of the predefined `XOR` operator.</span></span>  
  
-   <span data-ttu-id="7593b-1315">如果 `left`。键入并 `right`。类型均可为 null，则提升节点。</span><span class="sxs-lookup"><span data-stu-id="7593b-1315">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="7593b-1316">节点的类型是与预定义 `XOR` 运算符的结果类型对应的可以为 null 的类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-1316">The type of the node is the nullable type that corresponds to the result type of the predefined `XOR` operator.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="7593b-1317"><paramref name="left" /> 或 <paramref name="right" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-1317"><paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="7593b-1318"><paramref name="method" /> 不是 <see langword="null" />，它所表示的方法返回 <see langword="void" />，而不是 <see langword="static" />（Visual Basic 中为 <see langword="Shared" />），或者并非采用两个参数。</span><span class="sxs-lookup"><span data-stu-id="7593b-1318"><paramref name="method" /> is not <see langword="null" /> and the method it represents returns <see langword="void" />, is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic), or does not take exactly two arguments.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="7593b-1319"><paramref name="method" /> 是 <see langword="null" />，且没有为 <see langword="XOR" />.Type 和 <paramref name="left" />.Type 定义 <paramref name="right" /> 运算符。</span><span class="sxs-lookup"><span data-stu-id="7593b-1319"><paramref name="method" /> is <see langword="null" /> and the <see langword="XOR" /> operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ExclusiveOrAssign">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="7593b-1320">创建一个表示按位 XOR 赋值运算的 <see cref="T:System.Linq.Expressions.BinaryExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-1320">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise XOR assignment operation.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ExclusiveOrAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression ExclusiveOrAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression ExclusiveOrAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ExclusiveOrAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ExclusiveOrAssign (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ ExclusiveOrAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member ExclusiveOrAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.ExclusiveOrAssign (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="7593b-1321">要将 <see cref="T:System.Linq.Expressions.Expression" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-1321">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="7593b-1322">要将 <see cref="T:System.Linq.Expressions.Expression" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-1322">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="7593b-1323">通过对用户定义的类型使用 <see cref="T:System.Linq.Expressions.BinaryExpression" />op_ExclusiveOr<c>，创建一个表示按位 XOR 赋值运算的</c>。</span><span class="sxs-lookup"><span data-stu-id="7593b-1323">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise XOR assignment operation, using <c>op_ExclusiveOr</c> for user-defined types.</span></span></summary>
        <returns><span data-ttu-id="7593b-1324">一个 <see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 属性等于 <see cref="F:System.Linq.Expressions.ExpressionType.ExclusiveOrAssign" />，并且其 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 属性设置为指定值。</span><span class="sxs-lookup"><span data-stu-id="7593b-1324">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.ExclusiveOrAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ExclusiveOrAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression ExclusiveOrAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression ExclusiveOrAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ExclusiveOrAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ExclusiveOrAssign (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ ExclusiveOrAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member ExclusiveOrAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.ExclusiveOrAssign (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="7593b-1325">要将 <see cref="T:System.Linq.Expressions.Expression" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-1325">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="7593b-1326">要将 <see cref="T:System.Linq.Expressions.Expression" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-1326">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <param name="method"><span data-ttu-id="7593b-1327">要将 <see cref="T:System.Reflection.MethodInfo" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-1327">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="7593b-1328">通过对用户定义的类型使用 <see cref="T:System.Linq.Expressions.BinaryExpression" />op_ExclusiveOr<c>，创建一个表示按位 XOR 赋值运算的</c>。</span><span class="sxs-lookup"><span data-stu-id="7593b-1328">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise XOR assignment operation, using <c>op_ExclusiveOr</c> for user-defined types.</span></span></summary>
        <returns><span data-ttu-id="7593b-1329">一个 <see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 属性等于 <see cref="F:System.Linq.Expressions.ExpressionType.ExclusiveOrAssign" />，并且其 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />、<see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> 属性设置为指定值。</span><span class="sxs-lookup"><span data-stu-id="7593b-1329">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.ExclusiveOrAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ExclusiveOrAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression ExclusiveOrAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method, System.Linq.Expressions.LambdaExpression conversion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression ExclusiveOrAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method, class System.Linq.Expressions.LambdaExpression conversion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ExclusiveOrAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ExclusiveOrAssign (left As Expression, right As Expression, method As MethodInfo, conversion As LambdaExpression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ ExclusiveOrAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method, System::Linq::Expressions::LambdaExpression ^ conversion);" />
      <MemberSignature Language="F#" Value="static member ExclusiveOrAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo * System.Linq.Expressions.LambdaExpression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.ExclusiveOrAssign (left, right, method, conversion)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="conversion" Type="System.Linq.Expressions.LambdaExpression" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="7593b-1330">要将 <see cref="T:System.Linq.Expressions.Expression" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-1330">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="7593b-1331">要将 <see cref="T:System.Linq.Expressions.Expression" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-1331">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <param name="method"><span data-ttu-id="7593b-1332">要将 <see cref="T:System.Reflection.MethodInfo" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-1332">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span></span></param>
        <param name="conversion"><span data-ttu-id="7593b-1333">要将 <see cref="T:System.Linq.Expressions.LambdaExpression" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-1333">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="7593b-1334">通过对用户定义的类型使用 <see cref="T:System.Linq.Expressions.BinaryExpression" />op_ExclusiveOr<c>，创建一个表示按位 XOR 赋值运算的</c>。</span><span class="sxs-lookup"><span data-stu-id="7593b-1334">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise XOR assignment operation, using <c>op_ExclusiveOr</c> for user-defined types.</span></span></summary>
        <returns><span data-ttu-id="7593b-1335">一个 <see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 属性等于 <see cref="F:System.Linq.Expressions.ExpressionType.ExclusiveOrAssign" />，并且其 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />、<see cref="P:System.Linq.Expressions.BinaryExpression.Right" />、<see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> 属性设置为指定值。</span><span class="sxs-lookup"><span data-stu-id="7593b-1335">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.ExclusiveOrAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Field">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="7593b-1336">创建一个表示访问字段的 <see cref="T:System.Linq.Expressions.MemberExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-1336">Creates a <see cref="T:System.Linq.Expressions.MemberExpression" /> that represents accessing a field.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Field">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberExpression Field (System.Linq.Expressions.Expression expression, System.Reflection.FieldInfo field);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberExpression Field(class System.Linq.Expressions.Expression expression, class System.Reflection.FieldInfo field) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Field(System.Linq.Expressions.Expression,System.Reflection.FieldInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberExpression ^ Field(System::Linq::Expressions::Expression ^ expression, System::Reflection::FieldInfo ^ field);" />
      <MemberSignature Language="F#" Value="static member Field : System.Linq.Expressions.Expression * System.Reflection.FieldInfo -&gt; System.Linq.Expressions.MemberExpression" Usage="System.Linq.Expressions.Expression.Field (expression, field)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="field" Type="System.Reflection.FieldInfo" />
      </Parameters>
      <Docs>
        <param name="expression"><span data-ttu-id="7593b-1337">要将 <see cref="T:System.Linq.Expressions.Expression" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.MemberExpression.Expression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-1337">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> property equal to.</span></span> <span data-ttu-id="7593b-1338">对于 <see langword="static" />（在 Visual Basic 中为 <see langword="Shared" />），<paramref name="expression" /> 必须是 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-1338">For <see langword="static" /> (<see langword="Shared" /> in Visual Basic), <paramref name="expression" /> must be <see langword="null" />.</span></span></param>
        <param name="field"><span data-ttu-id="7593b-1339">要将 <see cref="T:System.Reflection.FieldInfo" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.MemberExpression.Member" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-1339">The <see cref="T:System.Reflection.FieldInfo" /> to set the <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="7593b-1340">创建一个表示访问字段的 <see cref="T:System.Linq.Expressions.MemberExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-1340">Creates a <see cref="T:System.Linq.Expressions.MemberExpression" /> that represents accessing a field.</span></span></summary>
        <returns><span data-ttu-id="7593b-1341">一个 <see cref="T:System.Linq.Expressions.MemberExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 属性等于 <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" />，并且其 <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> 和 <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> 属性设置为指定值。</span><span class="sxs-lookup"><span data-stu-id="7593b-1341">A <see cref="T:System.Linq.Expressions.MemberExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" /> and the <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> and <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7593b-1342">生成的 <xref:System.Linq.Expressions.MemberExpression> 的 <xref:System.Linq.Expressions.Expression.Type%2A> 属性等于 `field`的 <xref:System.Reflection.FieldInfo.FieldType%2A> 属性。</span><span class="sxs-lookup"><span data-stu-id="7593b-1342">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.MemberExpression> is equal to the <xref:System.Reflection.FieldInfo.FieldType%2A> property of `field`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="7593b-1343"><paramref name="field" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-1343"><paramref name="field" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="7593b-1344">- 或 -</span><span class="sxs-lookup"><span data-stu-id="7593b-1344">-or-</span></span> 
<span data-ttu-id="7593b-1345"><paramref name="field" /> 表示的字段不为 <see langword="static" />（在 Visual Basic 中不为 <see langword="Shared" />），且 <paramref name="expression" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-1345">The field represented by <paramref name="field" /> is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic) and <paramref name="expression" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="7593b-1346"><paramref name="expression" />.Type 不能赋给 <paramref name="field" /> 所表示的字段的声明类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-1346"><paramref name="expression" />.Type is not assignable to the declaring type of the field represented by <paramref name="field" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Field">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberExpression Field (System.Linq.Expressions.Expression expression, string fieldName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberExpression Field(class System.Linq.Expressions.Expression expression, string fieldName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Field(System.Linq.Expressions.Expression,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberExpression ^ Field(System::Linq::Expressions::Expression ^ expression, System::String ^ fieldName);" />
      <MemberSignature Language="F#" Value="static member Field : System.Linq.Expressions.Expression * string -&gt; System.Linq.Expressions.MemberExpression" Usage="System.Linq.Expressions.Expression.Field (expression, fieldName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="fieldName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="expression"><span data-ttu-id="7593b-1347">一个 <see cref="T:System.Linq.Expressions.Expression" />，其 <see cref="P:System.Linq.Expressions.Expression.Type" /> 中包含一个名为 <paramref name="fieldName" /> 的字段。</span><span class="sxs-lookup"><span data-stu-id="7593b-1347">An <see cref="T:System.Linq.Expressions.Expression" /> whose <see cref="P:System.Linq.Expressions.Expression.Type" /> contains a field named <paramref name="fieldName" />.</span></span> <span data-ttu-id="7593b-1348">对于静态字段，这可以为 null。</span><span class="sxs-lookup"><span data-stu-id="7593b-1348">This can be null for static fields.</span></span></param>
        <param name="fieldName"><span data-ttu-id="7593b-1349">要访问的字段的名称。</span><span class="sxs-lookup"><span data-stu-id="7593b-1349">The name of a field to be accessed.</span></span></param>
        <summary><span data-ttu-id="7593b-1350">在给定字段名称的情况下，创建一个表示访问此字段的 <see cref="T:System.Linq.Expressions.MemberExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-1350">Creates a <see cref="T:System.Linq.Expressions.MemberExpression" /> that represents accessing a field given the name of the field.</span></span></summary>
        <returns><span data-ttu-id="7593b-1351"><see cref="T:System.Linq.Expressions.MemberExpression" /> 的 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 属性等于 <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" />，<see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> 属性设置为 <paramref name="expression" />，<see cref="P:System.Linq.Expressions.MemberExpression.Member" /> 属性设置为 <see cref="T:System.Reflection.FieldInfo" />（表示由 <paramref name="fieldName" /> 表示的字段）。</span><span class="sxs-lookup"><span data-stu-id="7593b-1351">A <see cref="T:System.Linq.Expressions.MemberExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" />, the <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> property set to <paramref name="expression" />, and the <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> property set to the <see cref="T:System.Reflection.FieldInfo" /> that represents the field denoted by <paramref name="fieldName" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7593b-1352">生成的 <xref:System.Linq.Expressions.MemberExpression> 的 <xref:System.Linq.Expressions.Expression.Type%2A> 属性等于 <xref:System.Reflection.FieldInfo> 的 <xref:System.Reflection.FieldInfo.FieldType%2A> 属性，该属性表示 `fieldName`表示的字段。</span><span class="sxs-lookup"><span data-stu-id="7593b-1352">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.MemberExpression> is equal to the <xref:System.Reflection.FieldInfo.FieldType%2A> property of the <xref:System.Reflection.FieldInfo> that represents the field denoted by `fieldName`.</span></span>  
  
 <span data-ttu-id="7593b-1353">此方法搜索 `expression`。类型及其基类型，用于名称 `fieldName`。</span><span class="sxs-lookup"><span data-stu-id="7593b-1353">This method searches `expression`.Type and its base types for a field that has the name `fieldName`.</span></span> <span data-ttu-id="7593b-1354">公共字段的优先级高于非公共字段。</span><span class="sxs-lookup"><span data-stu-id="7593b-1354">Public fields are given preference over non-public fields.</span></span> <span data-ttu-id="7593b-1355">如果找到了匹配字段，此方法会将 `expression`，并将表示该字段的 <xref:System.Reflection.FieldInfo> 传递给 <xref:System.Linq.Expressions.Expression.Field%2A>。</span><span class="sxs-lookup"><span data-stu-id="7593b-1355">If a matching field is found, this method passes `expression` and the <xref:System.Reflection.FieldInfo> that represents that field to <xref:System.Linq.Expressions.Expression.Field%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="7593b-1356">下面的代码示例演示如何创建一个表示访问字段的表达式。</span><span class="sxs-lookup"><span data-stu-id="7593b-1356">The following code example shows how to create an expression that represents accessing a field.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#37](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#37)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#37](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#37)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="7593b-1357"><paramref name="expression" /> 或 <paramref name="fieldName" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-1357"><paramref name="expression" /> or <paramref name="fieldName" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="7593b-1358">没有在 <paramref name="fieldName" />.Type 或其基类型中定义名为 <paramref name="expression" /> 的字段。</span><span class="sxs-lookup"><span data-stu-id="7593b-1358">No field named <paramref name="fieldName" /> is defined in <paramref name="expression" />.Type or its base types.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Field">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberExpression Field (System.Linq.Expressions.Expression expression, Type type, string fieldName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberExpression Field(class System.Linq.Expressions.Expression expression, class System.Type type, string fieldName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Field(System.Linq.Expressions.Expression,System.Type,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberExpression ^ Field(System::Linq::Expressions::Expression ^ expression, Type ^ type, System::String ^ fieldName);" />
      <MemberSignature Language="F#" Value="static member Field : System.Linq.Expressions.Expression * Type * string -&gt; System.Linq.Expressions.MemberExpression" Usage="System.Linq.Expressions.Expression.Field (expression, type, fieldName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="type" Type="System.Type" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="fieldName" Type="System.String" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="expression"><span data-ttu-id="7593b-1359">字段的包含对象。</span><span class="sxs-lookup"><span data-stu-id="7593b-1359">The containing object of the field.</span></span> <span data-ttu-id="7593b-1360">对于静态字段，这可以为 null。</span><span class="sxs-lookup"><span data-stu-id="7593b-1360">This can be null for static fields.</span></span></param>
        <param name="type"><span data-ttu-id="7593b-1361">包含字段的 <see cref="P:System.Linq.Expressions.Expression.Type" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-1361">The <see cref="P:System.Linq.Expressions.Expression.Type" /> that contains the field.</span></span></param>
        <param name="fieldName"><span data-ttu-id="7593b-1362">要访问的字段。</span><span class="sxs-lookup"><span data-stu-id="7593b-1362">The field to be accessed.</span></span></param>
        <summary><span data-ttu-id="7593b-1363">创建一个表示访问字段的 <see cref="T:System.Linq.Expressions.MemberExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-1363">Creates a <see cref="T:System.Linq.Expressions.MemberExpression" /> that represents accessing a field.</span></span></summary>
        <returns><span data-ttu-id="7593b-1364">创建的 <see cref="T:System.Linq.Expressions.MemberExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-1364">The created <see cref="T:System.Linq.Expressions.MemberExpression" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetActionType">
      <MemberSignature Language="C#" Value="public static Type GetActionType (params Type[] typeArgs);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetActionType(class System.Type[] typeArgs) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.GetActionType(System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetActionType (ParamArray typeArgs As Type()) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetActionType(... cli::array &lt;Type ^&gt; ^ typeArgs);" />
      <MemberSignature Language="F#" Value="static member GetActionType : Type[] -&gt; Type" Usage="System.Linq.Expressions.Expression.GetActionType typeArgs" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeArgs" Type="System.Type[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="typeArgs"><span data-ttu-id="7593b-1365">包含多达十六个 <see cref="T:System.Type" /> 对象的数组，它指定 <see langword="System.Action" /> 委托类型的类型参数。</span><span class="sxs-lookup"><span data-stu-id="7593b-1365">An array of up to sixteen <see cref="T:System.Type" /> objects that specify the type arguments for the <see langword="System.Action" /> delegate type.</span></span></param>
        <summary><span data-ttu-id="7593b-1366">创建一个 <see cref="T:System.Type" /> 对象，它表示具有特定类型参数的泛型 <c>System.Action</c> 委托类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-1366">Creates a <see cref="T:System.Type" /> object that represents a generic <c>System.Action</c> delegate type that has specific type arguments.</span></span></summary>
        <returns><span data-ttu-id="7593b-1367">具有指定类型参数的 <c>System.Action</c> 委托的类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-1367">The type of a <c>System.Action</c> delegate that has the specified type arguments.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7593b-1368">例如，如果的元素 `typeArgs` 表示 `T1…Tn`的类型，则生成的 <xref:System.Type> 对象表示 `System.Action(Of T1,…,Tn)` 中的C#或 Visual Basic 中构造的委托 `System.Action<T1,…,Tn>` 类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-1368">As an example, if the elements of `typeArgs` represent the types `T1…Tn`, the resulting <xref:System.Type> object represents the constructed delegate type `System.Action<T1,…,Tn>` in C# or `System.Action(Of T1,…,Tn)` in Visual Basic.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="7593b-1369"><paramref name="typeArgs" /> 包含 16 个以上的元素。</span><span class="sxs-lookup"><span data-stu-id="7593b-1369"><paramref name="typeArgs" /> contains more than sixteen elements.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="7593b-1370"><paramref name="typeArgs" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-1370"><paramref name="typeArgs" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetDelegateType">
      <MemberSignature Language="C#" Value="public static Type GetDelegateType (params Type[] typeArgs);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetDelegateType(class System.Type[] typeArgs) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.GetDelegateType(System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDelegateType (ParamArray typeArgs As Type()) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetDelegateType(... cli::array &lt;Type ^&gt; ^ typeArgs);" />
      <MemberSignature Language="F#" Value="static member GetDelegateType : Type[] -&gt; Type" Usage="System.Linq.Expressions.Expression.GetDelegateType typeArgs" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeArgs" Type="System.Type[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="typeArgs"><span data-ttu-id="7593b-1371">该委托的类型参数。</span><span class="sxs-lookup"><span data-stu-id="7593b-1371">The type arguments of the delegate.</span></span></param>
        <summary><span data-ttu-id="7593b-1372">获取一个 <see cref="P:System.Linq.Expressions.Expression.Type" /> 对象，表示具有特定类型参数的泛型 <c>System.Func</c> 或 <c>System.Action</c> 委托类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-1372">Gets a <see cref="P:System.Linq.Expressions.Expression.Type" /> object that represents a generic <c>System.Func</c> or <c>System.Action</c> delegate type that has specific type arguments.</span></span></summary>
        <returns><span data-ttu-id="7593b-1373">委托类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-1373">The delegate type.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7593b-1374">最后一个类型参数确定委托的返回类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-1374">The last type argument determines the return type of the delegate.</span></span> <span data-ttu-id="7593b-1375">如果没有任何 Func 或操作足够大，则会生成自定义委托类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-1375">If no Func or Action is large enough, it will generate a custom delegate type.</span></span>  
  
 <span data-ttu-id="7593b-1376">与 Func 一样，最后一个参数是返回类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-1376">As with Func, the last argument is the return type.</span></span> <span data-ttu-id="7593b-1377">可以将其设置为 System.void 以生成操作。</span><span class="sxs-lookup"><span data-stu-id="7593b-1377">It can be set to System.Void to produce an Action.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetFuncType">
      <MemberSignature Language="C#" Value="public static Type GetFuncType (params Type[] typeArgs);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetFuncType(class System.Type[] typeArgs) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.GetFuncType(System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFuncType (ParamArray typeArgs As Type()) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetFuncType(... cli::array &lt;Type ^&gt; ^ typeArgs);" />
      <MemberSignature Language="F#" Value="static member GetFuncType : Type[] -&gt; Type" Usage="System.Linq.Expressions.Expression.GetFuncType typeArgs" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeArgs" Type="System.Type[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="typeArgs"><span data-ttu-id="7593b-1378">包含一到十七个 <see cref="T:System.Type" /> 对象的数组，它指定 <see langword="System.Func" /> 委托类型的类型参数。</span><span class="sxs-lookup"><span data-stu-id="7593b-1378">An array of one to seventeen <see cref="T:System.Type" /> objects that specify the type arguments for the <see langword="System.Func" /> delegate type.</span></span></param>
        <summary><span data-ttu-id="7593b-1379">创建一个 <see cref="P:System.Linq.Expressions.Expression.Type" /> 对象，表示具有特定类型参数的泛型 <c>System.Func</c> 委托类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-1379">Creates a <see cref="P:System.Linq.Expressions.Expression.Type" /> object that represents a generic <c>System.Func</c> delegate type that has specific type arguments.</span></span> <span data-ttu-id="7593b-1380">最后一个类型参数指定已创建委托的返回类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-1380">The last type argument specifies the return type of the created delegate.</span></span></summary>
        <returns><span data-ttu-id="7593b-1381">具有指定类型参数的 <c>System.Func</c> 委托的类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-1381">The type of a <c>System.Func</c> delegate that has the specified type arguments.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7593b-1382">`typeArgs` 必须包含至少一个最多十七个元素。</span><span class="sxs-lookup"><span data-stu-id="7593b-1382">`typeArgs` must contain at least one and at most seventeen elements.</span></span>  
  
 <span data-ttu-id="7593b-1383">例如，如果的元素 `typeArgs` 表示 `T1…Tn`的类型，则生成的 <xref:System.Type> 对象表示 `System.Func(Of T1,…,Tn)` 中的C#或 Visual Basic 中构造的委托 `System.Func<T1,…,Tn>` 类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-1383">As an example, if the elements of `typeArgs` represent the types `T1…Tn`, the resulting <xref:System.Type> object represents the constructed delegate type `System.Func<T1,…,Tn>` in C# or `System.Func(Of T1,…,Tn)` in Visual Basic.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="7593b-1384"><paramref name="typeArgs" /> 包含少于一个或多于十七个的元素。</span><span class="sxs-lookup"><span data-stu-id="7593b-1384"><paramref name="typeArgs" /> contains fewer than one or more than seventeen elements.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="7593b-1385"><paramref name="typeArgs" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-1385"><paramref name="typeArgs" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Goto">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="7593b-1386">创建一个表示“go to”语句的 <see cref="T:System.Linq.Expressions.GotoExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-1386">Creates a <see cref="T:System.Linq.Expressions.GotoExpression" /> representing a "go to" statement.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Goto">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.GotoExpression Goto (System.Linq.Expressions.LabelTarget target);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.GotoExpression Goto(class System.Linq.Expressions.LabelTarget target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Goto(System.Linq.Expressions.LabelTarget)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Goto (target As LabelTarget) As GotoExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::GotoExpression ^ Goto(System::Linq::Expressions::LabelTarget ^ target);" />
      <MemberSignature Language="F#" Value="static member Goto : System.Linq.Expressions.LabelTarget -&gt; System.Linq.Expressions.GotoExpression" Usage="System.Linq.Expressions.Expression.Goto target" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.GotoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="target"><span data-ttu-id="7593b-1387"><see cref="T:System.Linq.Expressions.LabelTarget" /> 将跳至的 <see cref="T:System.Linq.Expressions.GotoExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-1387">The <see cref="T:System.Linq.Expressions.LabelTarget" /> that the <see cref="T:System.Linq.Expressions.GotoExpression" /> will jump to.</span></span></param>
        <summary><span data-ttu-id="7593b-1388">创建一个表示“go to”语句的 <see cref="T:System.Linq.Expressions.GotoExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-1388">Creates a <see cref="T:System.Linq.Expressions.GotoExpression" /> representing a "go to" statement.</span></span></summary>
        <returns><span data-ttu-id="7593b-1389">一个 <see cref="T:System.Linq.Expressions.GotoExpression" />，其 <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> 等于 Goto，其 <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> 属性设置为指定值，此外还有一个在跳转时将传递给目标标签的 null 值。</span><span class="sxs-lookup"><span data-stu-id="7593b-1389">A <see cref="T:System.Linq.Expressions.GotoExpression" /> with <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> equal to Goto, the <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> property set to the specified value, and a null value to be passed to the target label upon jumping.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="7593b-1390">下面的示例演示如何创建包含 <xref:System.Linq.Expressions.GotoExpression> 对象的表达式。</span><span class="sxs-lookup"><span data-stu-id="7593b-1390">The following example demonstrates how to create an expression that contains a <xref:System.Linq.Expressions.GotoExpression> object.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#45](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#45)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#45](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#45)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Goto">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.GotoExpression Goto (System.Linq.Expressions.LabelTarget target, System.Linq.Expressions.Expression value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.GotoExpression Goto(class System.Linq.Expressions.LabelTarget target, class System.Linq.Expressions.Expression value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Goto(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Goto (target As LabelTarget, value As Expression) As GotoExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::GotoExpression ^ Goto(System::Linq::Expressions::LabelTarget ^ target, System::Linq::Expressions::Expression ^ value);" />
      <MemberSignature Language="F#" Value="static member Goto : System.Linq.Expressions.LabelTarget * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.GotoExpression" Usage="System.Linq.Expressions.Expression.Goto (target, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.GotoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="value" Type="System.Linq.Expressions.Expression" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="target"><span data-ttu-id="7593b-1391"><see cref="T:System.Linq.Expressions.LabelTarget" /> 将跳至的 <see cref="T:System.Linq.Expressions.GotoExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-1391">The <see cref="T:System.Linq.Expressions.LabelTarget" /> that the <see cref="T:System.Linq.Expressions.GotoExpression" /> will jump to.</span></span></param>
        <param name="value"><span data-ttu-id="7593b-1392">将在跳转时传递给关联标签的值。</span><span class="sxs-lookup"><span data-stu-id="7593b-1392">The value that will be passed to the associated label upon jumping.</span></span></param>
        <summary><span data-ttu-id="7593b-1393">创建一个表示“go to”语句的 <see cref="T:System.Linq.Expressions.GotoExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-1393">Creates a <see cref="T:System.Linq.Expressions.GotoExpression" /> representing a "go to" statement.</span></span> <span data-ttu-id="7593b-1394">可以指定在跳转时传递给标签的值。</span><span class="sxs-lookup"><span data-stu-id="7593b-1394">The value passed to the label upon jumping can be specified.</span></span></summary>
        <returns><span data-ttu-id="7593b-1395">一个 <see cref="T:System.Linq.Expressions.GotoExpression" />，其 <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> 等于 Goto，并且其 <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> 属性设置为 <paramref name="target" />，此外还有一个在跳转时将传递给目标标签的 <paramref name="value" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-1395">A <see cref="T:System.Linq.Expressions.GotoExpression" /> with <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> equal to Goto, the <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> property set to <paramref name="target" />, and <paramref name="value" /> to be passed to the target label upon jumping.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Goto">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.GotoExpression Goto (System.Linq.Expressions.LabelTarget target, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.GotoExpression Goto(class System.Linq.Expressions.LabelTarget target, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Goto(System.Linq.Expressions.LabelTarget,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::GotoExpression ^ Goto(System::Linq::Expressions::LabelTarget ^ target, Type ^ type);" />
      <MemberSignature Language="F#" Value="static member Goto : System.Linq.Expressions.LabelTarget * Type -&gt; System.Linq.Expressions.GotoExpression" Usage="System.Linq.Expressions.Expression.Goto (target, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.GotoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="type" Type="System.Type" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="target"><span data-ttu-id="7593b-1396"><see cref="T:System.Linq.Expressions.LabelTarget" /> 将跳至的 <see cref="T:System.Linq.Expressions.GotoExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-1396">The <see cref="T:System.Linq.Expressions.LabelTarget" /> that the <see cref="T:System.Linq.Expressions.GotoExpression" /> will jump to.</span></span></param>
        <param name="type"><span data-ttu-id="7593b-1397">要将 <see cref="T:System.Type" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.Expression.Type" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-1397">An <see cref="T:System.Type" /> to set the <see cref="P:System.Linq.Expressions.Expression.Type" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="7593b-1398">创建一个表示具有指定类型的“go to”语句的 <see cref="T:System.Linq.Expressions.GotoExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-1398">Creates a <see cref="T:System.Linq.Expressions.GotoExpression" /> representing a "go to" statement with the specified type.</span></span></summary>
        <returns><span data-ttu-id="7593b-1399">一个 <see cref="T:System.Linq.Expressions.GotoExpression" />，其 <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> 等于 Goto，其 <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> 属性设置为指定值，并且其 <see cref="P:System.Linq.Expressions.Expression.Type" /> 属性设置为 <paramref name="type" />，此外还有一个在跳转时将传递给目标标签的 null 值。</span><span class="sxs-lookup"><span data-stu-id="7593b-1399">A <see cref="T:System.Linq.Expressions.GotoExpression" /> with <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> equal to Goto, the <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> property set to the specified value, the <see cref="P:System.Linq.Expressions.Expression.Type" /> property set to <paramref name="type" />, and a null value to be passed to the target label upon jumping.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Goto">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.GotoExpression Goto (System.Linq.Expressions.LabelTarget target, System.Linq.Expressions.Expression value, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.GotoExpression Goto(class System.Linq.Expressions.LabelTarget target, class System.Linq.Expressions.Expression value, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Goto(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::GotoExpression ^ Goto(System::Linq::Expressions::LabelTarget ^ target, System::Linq::Expressions::Expression ^ value, Type ^ type);" />
      <MemberSignature Language="F#" Value="static member Goto : System.Linq.Expressions.LabelTarget * System.Linq.Expressions.Expression * Type -&gt; System.Linq.Expressions.GotoExpression" Usage="System.Linq.Expressions.Expression.Goto (target, value, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.GotoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="value" Type="System.Linq.Expressions.Expression" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="type" Type="System.Type" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="target"><span data-ttu-id="7593b-1400"><see cref="T:System.Linq.Expressions.LabelTarget" /> 将跳至的 <see cref="T:System.Linq.Expressions.GotoExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-1400">The <see cref="T:System.Linq.Expressions.LabelTarget" /> that the <see cref="T:System.Linq.Expressions.GotoExpression" /> will jump to.</span></span></param>
        <param name="value"><span data-ttu-id="7593b-1401">将在跳转时传递给关联标签的值。</span><span class="sxs-lookup"><span data-stu-id="7593b-1401">The value that will be passed to the associated label upon jumping.</span></span></param>
        <param name="type"><span data-ttu-id="7593b-1402">要将 <see cref="T:System.Type" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.Expression.Type" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-1402">An <see cref="T:System.Type" /> to set the <see cref="P:System.Linq.Expressions.Expression.Type" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="7593b-1403">创建一个表示具有指定类型的“go to”语句的 <see cref="T:System.Linq.Expressions.GotoExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-1403">Creates a <see cref="T:System.Linq.Expressions.GotoExpression" /> representing a "go to" statement with the specified type.</span></span> <span data-ttu-id="7593b-1404">可以指定在跳转时传递给标签的值。</span><span class="sxs-lookup"><span data-stu-id="7593b-1404">The value passed to the label upon jumping can be specified.</span></span></summary>
        <returns><span data-ttu-id="7593b-1405">一个 <see cref="T:System.Linq.Expressions.GotoExpression" />，其 <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> 等于 Goto，其 <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> 属性设置为 <paramref name="target" />，并且其 <see cref="P:System.Linq.Expressions.Expression.Type" /> 属性设置为 <paramref name="type" />，此外还有一个在跳转时将传递给目标标签的 <paramref name="value" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-1405">A <see cref="T:System.Linq.Expressions.GotoExpression" /> with <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> equal to Goto, the <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> property set to <paramref name="target" />, the <see cref="P:System.Linq.Expressions.Expression.Type" /> property set to <paramref name="type" />, and <paramref name="value" /> to be passed to the target label upon jumping.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GreaterThan">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="7593b-1406">创建一个表示“大于”数值比较的 <see cref="T:System.Linq.Expressions.BinaryExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-1406">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a "greater than" numeric comparison.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GreaterThan">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression GreaterThan (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression GreaterThan(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.GreaterThan(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GreaterThan (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ GreaterThan(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member GreaterThan : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.GreaterThan (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="7593b-1407">要将 <see cref="T:System.Linq.Expressions.Expression" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-1407">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="7593b-1408">要将 <see cref="T:System.Linq.Expressions.Expression" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-1408">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="7593b-1409">创建一个表示“大于”数值比较的 <see cref="T:System.Linq.Expressions.BinaryExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-1409">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a "greater than" numeric comparison.</span></span></summary>
        <returns><span data-ttu-id="7593b-1410">一个 <see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 属性等于 <see cref="F:System.Linq.Expressions.ExpressionType.GreaterThan" />，并且其 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 属性设置为指定值。</span><span class="sxs-lookup"><span data-stu-id="7593b-1410">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.GreaterThan" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7593b-1411">生成的 <xref:System.Linq.Expressions.BinaryExpression> 具有设置为实现方法的 <xref:System.Linq.Expressions.BinaryExpression.Method%2A> 属性。</span><span class="sxs-lookup"><span data-stu-id="7593b-1411">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="7593b-1412"><xref:System.Linq.Expressions.Expression.Type%2A> 属性设置为节点的类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-1412">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="7593b-1413">如果节点已提升，则 `true`<xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> 属性。</span><span class="sxs-lookup"><span data-stu-id="7593b-1413">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> property is `true`.</span></span> <span data-ttu-id="7593b-1414">否则，它是 `false`。</span><span class="sxs-lookup"><span data-stu-id="7593b-1414">Otherwise, it is `false`.</span></span> <span data-ttu-id="7593b-1415"><xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> 属性始终为 `false`。</span><span class="sxs-lookup"><span data-stu-id="7593b-1415">The <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> property is always `false`.</span></span> <span data-ttu-id="7593b-1416"><xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> 属性为 `null`。</span><span class="sxs-lookup"><span data-stu-id="7593b-1416">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="7593b-1417">以下信息描述了实现方法、节点类型以及节点是否已提升。</span><span class="sxs-lookup"><span data-stu-id="7593b-1417">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="7593b-1418">实现方法</span><span class="sxs-lookup"><span data-stu-id="7593b-1418">Implementing Method</span></span>  
 <span data-ttu-id="7593b-1419">以下规则确定操作的实现方法：</span><span class="sxs-lookup"><span data-stu-id="7593b-1419">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="7593b-1420">如果 `left` 或 `right` 的 <xref:System.Linq.Expressions.Expression.Type%2A> 属性表示重载 "大于" 运算符的用户定义类型，则表示该方法的 <xref:System.Reflection.MethodInfo> 是实现方法。</span><span class="sxs-lookup"><span data-stu-id="7593b-1420">If the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the "greater than" operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="7593b-1421">否则，如果 `left`。键入并 `right`。类型为数值类型，则实现方法为 `null`。</span><span class="sxs-lookup"><span data-stu-id="7593b-1421">Otherwise, if `left`.Type and `right`.Type are numeric types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="7593b-1422">节点类型和提升和非提升</span><span class="sxs-lookup"><span data-stu-id="7593b-1422">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="7593b-1423">如果不 `null`实现方法：</span><span class="sxs-lookup"><span data-stu-id="7593b-1423">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="7593b-1424">如果 `left`。键入并 `right`。类型可分配给实现方法的相应参数类型，不提升节点。</span><span class="sxs-lookup"><span data-stu-id="7593b-1424">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="7593b-1425">节点的类型是实现方法的返回类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-1425">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="7593b-1426">如果满足以下两个条件，则会提升节点并 <xref:System.Boolean>节点的类型：</span><span class="sxs-lookup"><span data-stu-id="7593b-1426">If the following two conditions are satisfied, the node is lifted and the type of the node is <xref:System.Boolean>:</span></span>  
  
    -   <span data-ttu-id="7593b-1427">`left`。键入并 `right`。类型既是值类型，其中至少有一个可为 null，并且相应的不可为 null 的类型等于实现方法的相应参数类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-1427">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="7593b-1428">实现方法的返回类型为 <xref:System.Boolean>。</span><span class="sxs-lookup"><span data-stu-id="7593b-1428">The return type of the implementing method is <xref:System.Boolean>.</span></span>  
  
 <span data-ttu-id="7593b-1429">如果实现方法为 `null`：</span><span class="sxs-lookup"><span data-stu-id="7593b-1429">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="7593b-1430">如果 `left`。键入并 `right`。类型不可以为 null，则不提升节点。</span><span class="sxs-lookup"><span data-stu-id="7593b-1430">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="7593b-1431">节点的类型为 <xref:System.Boolean>。</span><span class="sxs-lookup"><span data-stu-id="7593b-1431">The type of the node is <xref:System.Boolean>.</span></span>  
  
-   <span data-ttu-id="7593b-1432">如果 `left`。键入并 `right`。类型均可为 null，则提升节点。</span><span class="sxs-lookup"><span data-stu-id="7593b-1432">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="7593b-1433">节点的类型为 <xref:System.Boolean>。</span><span class="sxs-lookup"><span data-stu-id="7593b-1433">The type of the node is <xref:System.Boolean>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="7593b-1434">下面的代码示例演示如何创建对两个整数进行比较的表达式。</span><span class="sxs-lookup"><span data-stu-id="7593b-1434">The following code example shows how to create an expression that compares two integers.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#10)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="7593b-1435"><paramref name="left" /> 或 <paramref name="right" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-1435"><paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="7593b-1436">没有为 <paramref name="left" />.Type 和 <paramref name="right" />.Type 定义"大于"运算符。</span><span class="sxs-lookup"><span data-stu-id="7593b-1436">The "greater than" operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GreaterThan">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression GreaterThan (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, bool liftToNull, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression GreaterThan(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, bool liftToNull, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.GreaterThan(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GreaterThan (left As Expression, right As Expression, liftToNull As Boolean, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ GreaterThan(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, bool liftToNull, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member GreaterThan : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * bool * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.GreaterThan (left, right, liftToNull, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="liftToNull" Type="System.Boolean" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="7593b-1437">要将 <see cref="T:System.Linq.Expressions.Expression" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-1437">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="7593b-1438">要将 <see cref="T:System.Linq.Expressions.Expression" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-1438">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <param name="liftToNull"><span data-ttu-id="7593b-1439">若要将 <see langword="true" /> 设置为 <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" />，则为 <see langword="true" />；若要将 <see langword="false" /> 设置为 <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" />，则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-1439"><see langword="true" /> to set <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> to <see langword="true" />; <see langword="false" /> to set <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> to <see langword="false" />.</span></span></param>
        <param name="method"><span data-ttu-id="7593b-1440">要将 <see cref="T:System.Reflection.MethodInfo" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-1440">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="7593b-1441">创建一个表示“大于”数值比较的 <see cref="T:System.Linq.Expressions.BinaryExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-1441">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a "greater than" numeric comparison.</span></span> <span data-ttu-id="7593b-1442">可指定实现方法。</span><span class="sxs-lookup"><span data-stu-id="7593b-1442">The implementing method can be specified.</span></span></summary>
        <returns><span data-ttu-id="7593b-1443">一个 <see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 属性等于 <see cref="F:System.Linq.Expressions.ExpressionType.GreaterThan" />，并且其 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />、<see cref="P:System.Linq.Expressions.BinaryExpression.Right" />、<see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> 属性设置为指定值。</span><span class="sxs-lookup"><span data-stu-id="7593b-1443">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.GreaterThan" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7593b-1444">生成的 <xref:System.Linq.Expressions.BinaryExpression> 具有设置为实现方法的 <xref:System.Linq.Expressions.BinaryExpression.Method%2A> 属性。</span><span class="sxs-lookup"><span data-stu-id="7593b-1444">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="7593b-1445"><xref:System.Linq.Expressions.Expression.Type%2A> 属性设置为节点的类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-1445">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="7593b-1446">如果节点已提升，则 `true` <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> 属性，<xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> 属性等于 `liftToNull`。</span><span class="sxs-lookup"><span data-stu-id="7593b-1446">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> property is `true` and the <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> property is equal to `liftToNull`.</span></span> <span data-ttu-id="7593b-1447">否则，它们都 `false`。</span><span class="sxs-lookup"><span data-stu-id="7593b-1447">Otherwise, they are both `false`.</span></span> <span data-ttu-id="7593b-1448"><xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> 属性为 `null`。</span><span class="sxs-lookup"><span data-stu-id="7593b-1448">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="7593b-1449">以下信息描述了实现方法、节点类型以及节点是否已提升。</span><span class="sxs-lookup"><span data-stu-id="7593b-1449">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="7593b-1450">实现方法</span><span class="sxs-lookup"><span data-stu-id="7593b-1450">Implementing Method</span></span>  
 <span data-ttu-id="7593b-1451">以下规则确定操作的实现方法：</span><span class="sxs-lookup"><span data-stu-id="7593b-1451">The following rules determine the implementing method for the operation :</span></span>  
  
-   <span data-ttu-id="7593b-1452">如果 `method` 未 `null` 并且它表示采用两个自变量的非 void、`static``Shared` （Visual Basic）方法，则它是实现方法。</span><span class="sxs-lookup"><span data-stu-id="7593b-1452">If `method` is not `null` and it represents a non-void, `static` (`Shared` in Visual Basic) method that takes two arguments, it is the implementing method.</span></span>  
  
-   <span data-ttu-id="7593b-1453">否则，如果 `left` 或 `right` 的 <xref:System.Linq.Expressions.Expression.Type%2A> 属性表示重载 "大于" 运算符的用户定义类型，则表示该方法的 <xref:System.Reflection.MethodInfo> 是实现方法。</span><span class="sxs-lookup"><span data-stu-id="7593b-1453">Otherwise, if the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the "greater than" operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="7593b-1454">否则，如果 `left`。键入并 `right`。类型为数值类型，则实现方法为 `null`。</span><span class="sxs-lookup"><span data-stu-id="7593b-1454">Otherwise, if `left`.Type and `right`.Type are numeric types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="7593b-1455">节点类型和提升和非提升</span><span class="sxs-lookup"><span data-stu-id="7593b-1455">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="7593b-1456">如果不 `null`实现方法：</span><span class="sxs-lookup"><span data-stu-id="7593b-1456">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="7593b-1457">如果 `left`。键入并 `right`。类型可分配给实现方法的相应参数类型，不提升节点。</span><span class="sxs-lookup"><span data-stu-id="7593b-1457">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="7593b-1458">节点的类型是实现方法的返回类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-1458">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="7593b-1459">如果满足以下两个条件，则提升节点;此外，如果 `liftToNull` `false`，则节点类型可以为 null <xref:System.Boolean> 如果 `liftToNull` `true` 或 <xref:System.Boolean>：</span><span class="sxs-lookup"><span data-stu-id="7593b-1459">If the following two conditions are satisfied, the node is lifted; also, the type of the node is nullable <xref:System.Boolean> if `liftToNull` is `true` or <xref:System.Boolean> if `liftToNull` is `false`:</span></span>  
  
    -   <span data-ttu-id="7593b-1460">`left`。键入并 `right`。类型既是值类型，其中至少有一个可为 null，并且相应的不可为 null 的类型等于实现方法的相应参数类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-1460">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="7593b-1461">实现方法的返回类型为 <xref:System.Boolean>。</span><span class="sxs-lookup"><span data-stu-id="7593b-1461">The return type of the implementing method is <xref:System.Boolean>.</span></span>  
  
 <span data-ttu-id="7593b-1462">如果实现方法为 `null`：</span><span class="sxs-lookup"><span data-stu-id="7593b-1462">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="7593b-1463">如果 `left`。键入并 `right`。类型不可以为 null，则不提升节点。</span><span class="sxs-lookup"><span data-stu-id="7593b-1463">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="7593b-1464">节点的类型为 <xref:System.Boolean>。</span><span class="sxs-lookup"><span data-stu-id="7593b-1464">The type of the node is <xref:System.Boolean>.</span></span>  
  
-   <span data-ttu-id="7593b-1465">如果 `left`。键入并 `right`。类型均可为 null，则提升节点。</span><span class="sxs-lookup"><span data-stu-id="7593b-1465">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="7593b-1466">如果 `liftToNull` `true`，则节点的类型可以为 null <xref:System.Boolean> 如果 `liftToNull` `false`，则为 <xref:System.Boolean>。</span><span class="sxs-lookup"><span data-stu-id="7593b-1466">The type of the node is nullable <xref:System.Boolean> if `liftToNull` is `true` or <xref:System.Boolean> if `liftToNull` is `false`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="7593b-1467"><paramref name="left" /> 或 <paramref name="right" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-1467"><paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="7593b-1468"><paramref name="method" /> 不是 <see langword="null" />，它所表示的方法返回 <see langword="void" />，而不是 <see langword="static" />（Visual Basic 中为 <see langword="Shared" />），或者并非采用两个参数。</span><span class="sxs-lookup"><span data-stu-id="7593b-1468"><paramref name="method" /> is not <see langword="null" /> and the method it represents returns <see langword="void" />, is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic), or does not take exactly two arguments.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="7593b-1469"><paramref name="method" /> 为 <see langword="null" />，并且没有为 <paramref name="left" />.Type 和 <paramref name="right" />.Type 定义"大于"运算符。</span><span class="sxs-lookup"><span data-stu-id="7593b-1469"><paramref name="method" /> is <see langword="null" /> and the "greater than" operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="GreaterThanOrEqual">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="7593b-1470">创建一个表示“大于或等于”数值比较的 <see cref="T:System.Linq.Expressions.BinaryExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-1470">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a "greater than or equal" numeric comparison.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GreaterThanOrEqual">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression GreaterThanOrEqual (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression GreaterThanOrEqual(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.GreaterThanOrEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GreaterThanOrEqual (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ GreaterThanOrEqual(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member GreaterThanOrEqual : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.GreaterThanOrEqual (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="7593b-1471">要将 <see cref="T:System.Linq.Expressions.Expression" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-1471">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="7593b-1472">要将 <see cref="T:System.Linq.Expressions.Expression" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-1472">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="7593b-1473">创建一个表示“大于或等于”数值比较的 <see cref="T:System.Linq.Expressions.BinaryExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-1473">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a "greater than or equal" numeric comparison.</span></span></summary>
        <returns><span data-ttu-id="7593b-1474">一个 <see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 属性等于 <see cref="F:System.Linq.Expressions.ExpressionType.GreaterThanOrEqual" />，并且其 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 属性设置为指定值。</span><span class="sxs-lookup"><span data-stu-id="7593b-1474">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.GreaterThanOrEqual" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7593b-1475">生成的 <xref:System.Linq.Expressions.BinaryExpression> 具有设置为实现方法的 <xref:System.Linq.Expressions.BinaryExpression.Method%2A> 属性。</span><span class="sxs-lookup"><span data-stu-id="7593b-1475">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="7593b-1476"><xref:System.Linq.Expressions.Expression.Type%2A> 属性设置为节点的类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-1476">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="7593b-1477">如果节点已提升，则 `true`<xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> 属性。</span><span class="sxs-lookup"><span data-stu-id="7593b-1477">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> property is `true`.</span></span> <span data-ttu-id="7593b-1478">否则，它是 `false`。</span><span class="sxs-lookup"><span data-stu-id="7593b-1478">Otherwise, it is `false`.</span></span> <span data-ttu-id="7593b-1479"><xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> 属性始终为 `false`。</span><span class="sxs-lookup"><span data-stu-id="7593b-1479">The <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> property is always `false`.</span></span> <span data-ttu-id="7593b-1480"><xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> 属性为 `null`。</span><span class="sxs-lookup"><span data-stu-id="7593b-1480">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="7593b-1481">以下信息描述了实现方法、节点类型以及节点是否已提升。</span><span class="sxs-lookup"><span data-stu-id="7593b-1481">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="7593b-1482">实现方法</span><span class="sxs-lookup"><span data-stu-id="7593b-1482">Implementing Method</span></span>  
 <span data-ttu-id="7593b-1483">以下规则确定操作的实现方法：</span><span class="sxs-lookup"><span data-stu-id="7593b-1483">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="7593b-1484">如果 `left` 或 `right` 的 <xref:System.Linq.Expressions.Expression.Type%2A> 属性表示重载 "大于或等于" 运算符的用户定义类型，则表示该方法的 <xref:System.Reflection.MethodInfo> 是实现方法。</span><span class="sxs-lookup"><span data-stu-id="7593b-1484">If the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the "greater than or equal" operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="7593b-1485">否则，如果 `left`。键入并 `right`。类型为数值类型，则实现方法为 `null`。</span><span class="sxs-lookup"><span data-stu-id="7593b-1485">Otherwise, if `left`.Type and `right`.Type are numeric types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="7593b-1486">节点类型和提升和非提升</span><span class="sxs-lookup"><span data-stu-id="7593b-1486">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="7593b-1487">如果不 `null`实现方法：</span><span class="sxs-lookup"><span data-stu-id="7593b-1487">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="7593b-1488">如果 `left`。键入并 `right`。类型可分配给实现方法的相应参数类型，不提升节点。</span><span class="sxs-lookup"><span data-stu-id="7593b-1488">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="7593b-1489">节点的类型是实现方法的返回类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-1489">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="7593b-1490">如果满足以下两个条件，则会提升节点并 <xref:System.Boolean>节点的类型：</span><span class="sxs-lookup"><span data-stu-id="7593b-1490">If the following two conditions are satisfied, the node is lifted and the type of the node is <xref:System.Boolean>:</span></span>  
  
    -   <span data-ttu-id="7593b-1491">`left`。键入并 `right`。类型既是值类型，其中至少有一个可为 null，并且相应的不可为 null 的类型等于实现方法的相应参数类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-1491">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="7593b-1492">实现方法的返回类型为 <xref:System.Boolean>。</span><span class="sxs-lookup"><span data-stu-id="7593b-1492">The return type of the implementing method is <xref:System.Boolean>.</span></span>  
  
 <span data-ttu-id="7593b-1493">如果实现方法为 `null`：</span><span class="sxs-lookup"><span data-stu-id="7593b-1493">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="7593b-1494">如果 `left`。键入并 `right`。类型不可以为 null，则不提升节点。</span><span class="sxs-lookup"><span data-stu-id="7593b-1494">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="7593b-1495">节点的类型为 <xref:System.Boolean>。</span><span class="sxs-lookup"><span data-stu-id="7593b-1495">The type of the node is <xref:System.Boolean>.</span></span>  
  
-   <span data-ttu-id="7593b-1496">如果 `left`。键入并 `right`。类型均可为 null，则提升节点。</span><span class="sxs-lookup"><span data-stu-id="7593b-1496">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="7593b-1497">节点的类型为 <xref:System.Boolean>。</span><span class="sxs-lookup"><span data-stu-id="7593b-1497">The type of the node is <xref:System.Boolean>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="7593b-1498">下面的代码示例演示如何创建对两个整数进行比较的表达式。</span><span class="sxs-lookup"><span data-stu-id="7593b-1498">The following code example shows how to create an expression that compares two integers.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#11)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="7593b-1499"><paramref name="left" /> 或 <paramref name="right" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-1499"><paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="7593b-1500">没有为 <paramref name="left" />.Type 和 <paramref name="right" />.Type 定义"大于或等于"运算符。</span><span class="sxs-lookup"><span data-stu-id="7593b-1500">The "greater than or equal" operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GreaterThanOrEqual">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression GreaterThanOrEqual (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, bool liftToNull, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression GreaterThanOrEqual(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, bool liftToNull, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.GreaterThanOrEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GreaterThanOrEqual (left As Expression, right As Expression, liftToNull As Boolean, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ GreaterThanOrEqual(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, bool liftToNull, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member GreaterThanOrEqual : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * bool * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.GreaterThanOrEqual (left, right, liftToNull, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="liftToNull" Type="System.Boolean" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="7593b-1501">要将 <see cref="T:System.Linq.Expressions.Expression" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-1501">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="7593b-1502">要将 <see cref="T:System.Linq.Expressions.Expression" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-1502">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <param name="liftToNull"><span data-ttu-id="7593b-1503">若要将 <see langword="true" /> 设置为 <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" />，则为 <see langword="true" />；若要将 <see langword="false" /> 设置为 <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" />，则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-1503"><see langword="true" /> to set <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> to <see langword="true" />; <see langword="false" /> to set <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> to <see langword="false" />.</span></span></param>
        <param name="method"><span data-ttu-id="7593b-1504">要将 <see cref="T:System.Reflection.MethodInfo" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-1504">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="7593b-1505">创建一个表示“大于或等于”数值比较的 <see cref="T:System.Linq.Expressions.BinaryExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-1505">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a "greater than or equal" numeric comparison.</span></span></summary>
        <returns><span data-ttu-id="7593b-1506">一个 <see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 属性等于 <see cref="F:System.Linq.Expressions.ExpressionType.GreaterThanOrEqual" />，并且其 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />、<see cref="P:System.Linq.Expressions.BinaryExpression.Right" />、<see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> 属性设置为指定值。</span><span class="sxs-lookup"><span data-stu-id="7593b-1506">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.GreaterThanOrEqual" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7593b-1507">生成的 <xref:System.Linq.Expressions.BinaryExpression> 具有设置为实现方法的 <xref:System.Linq.Expressions.BinaryExpression.Method%2A> 属性。</span><span class="sxs-lookup"><span data-stu-id="7593b-1507">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="7593b-1508"><xref:System.Linq.Expressions.Expression.Type%2A> 属性设置为节点的类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-1508">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="7593b-1509">如果节点已提升，则 `true` <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> 属性，<xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> 属性等于 `liftToNull`。</span><span class="sxs-lookup"><span data-stu-id="7593b-1509">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> property is `true` and the <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> property is equal to `liftToNull`.</span></span> <span data-ttu-id="7593b-1510">否则，它们都 `false`。</span><span class="sxs-lookup"><span data-stu-id="7593b-1510">Otherwise, they are both `false`.</span></span> <span data-ttu-id="7593b-1511"><xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> 属性为 `null`。</span><span class="sxs-lookup"><span data-stu-id="7593b-1511">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="7593b-1512">以下信息描述了实现方法、节点类型以及节点是否已提升。</span><span class="sxs-lookup"><span data-stu-id="7593b-1512">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="7593b-1513">实现方法</span><span class="sxs-lookup"><span data-stu-id="7593b-1513">Implementing Method</span></span>  
 <span data-ttu-id="7593b-1514">以下规则确定操作的实现方法：</span><span class="sxs-lookup"><span data-stu-id="7593b-1514">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="7593b-1515">如果 `method` 未 `null` 并且它表示采用两个自变量的非 void、`static``Shared` （Visual Basic）方法，则它是实现方法。</span><span class="sxs-lookup"><span data-stu-id="7593b-1515">If `method` is not `null` and it represents a non-void, `static` (`Shared` in Visual Basic) method that takes two arguments, it is the implementing method.</span></span>  
  
-   <span data-ttu-id="7593b-1516">否则，如果 `left` 或 `right` 的 <xref:System.Linq.Expressions.Expression.Type%2A> 属性表示重载 "大于或等于" 运算符的用户定义类型，则表示该方法的 <xref:System.Reflection.MethodInfo> 是实现方法。</span><span class="sxs-lookup"><span data-stu-id="7593b-1516">Otherwise, if the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the "greater than or equal" operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="7593b-1517">否则，如果 `left`。键入并 `right`。类型为数值类型，则实现方法为 `null`。</span><span class="sxs-lookup"><span data-stu-id="7593b-1517">Otherwise, if `left`.Type and `right`.Type are numeric types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="7593b-1518">节点类型和提升和非提升</span><span class="sxs-lookup"><span data-stu-id="7593b-1518">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="7593b-1519">如果不 `null`实现方法：</span><span class="sxs-lookup"><span data-stu-id="7593b-1519">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="7593b-1520">如果 `left`。键入并 `right`。类型可分配给实现方法的相应参数类型，不提升节点。</span><span class="sxs-lookup"><span data-stu-id="7593b-1520">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="7593b-1521">节点的类型是实现方法的返回类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-1521">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="7593b-1522">如果满足以下两个条件，则提升节点;此外，如果 `liftToNull` `false`，则节点类型可以为 null <xref:System.Boolean> 如果 `liftToNull` `true` 或 <xref:System.Boolean>：</span><span class="sxs-lookup"><span data-stu-id="7593b-1522">If the following two conditions are satisfied, the node is lifted; also, the type of the node is nullable <xref:System.Boolean> if `liftToNull` is `true` or <xref:System.Boolean> if `liftToNull` is `false`:</span></span>  
  
    -   <span data-ttu-id="7593b-1523">`left`。键入并 `right`。类型既是值类型，其中至少有一个可为 null，并且相应的不可为 null 的类型等于实现方法的相应参数类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-1523">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="7593b-1524">实现方法的返回类型为 <xref:System.Boolean>。</span><span class="sxs-lookup"><span data-stu-id="7593b-1524">The return type of the implementing method is <xref:System.Boolean>.</span></span>  
  
 <span data-ttu-id="7593b-1525">如果实现方法为 `null`：</span><span class="sxs-lookup"><span data-stu-id="7593b-1525">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="7593b-1526">如果 `left`。键入并 `right`。类型不可以为 null，则不提升节点。</span><span class="sxs-lookup"><span data-stu-id="7593b-1526">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="7593b-1527">节点的类型为 <xref:System.Boolean>。</span><span class="sxs-lookup"><span data-stu-id="7593b-1527">The type of the node is <xref:System.Boolean>.</span></span>  
  
-   <span data-ttu-id="7593b-1528">如果 `left`。键入并 `right`。类型均可为 null，则提升节点。</span><span class="sxs-lookup"><span data-stu-id="7593b-1528">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="7593b-1529">如果 `liftToNull` `true`，则节点的类型可以为 null <xref:System.Boolean> 如果 `liftToNull` `false`，则为 <xref:System.Boolean>。</span><span class="sxs-lookup"><span data-stu-id="7593b-1529">The type of the node is nullable <xref:System.Boolean> if `liftToNull` is `true` or <xref:System.Boolean> if `liftToNull` is `false`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="7593b-1530"><paramref name="left" /> 或 <paramref name="right" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-1530"><paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="7593b-1531"><paramref name="method" /> 不是 <see langword="null" />，它所表示的方法返回 <see langword="void" />，而不是 <see langword="static" />（Visual Basic 中为 <see langword="Shared" />），或者并非采用两个参数。</span><span class="sxs-lookup"><span data-stu-id="7593b-1531"><paramref name="method" /> is not <see langword="null" /> and the method it represents returns <see langword="void" />, is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic), or does not take exactly two arguments.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="7593b-1532"><paramref name="method" /> 为 <see langword="null" />，且没有为 <paramref name="left" />.Type 和 <paramref name="right" />.Type 定义“大于或等于”运算符。</span><span class="sxs-lookup"><span data-stu-id="7593b-1532"><paramref name="method" /> is <see langword="null" /> and the "greater than or equal" operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="IfThen">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ConditionalExpression IfThen (System.Linq.Expressions.Expression test, System.Linq.Expressions.Expression ifTrue);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ConditionalExpression IfThen(class System.Linq.Expressions.Expression test, class System.Linq.Expressions.Expression ifTrue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.IfThen(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IfThen (test As Expression, ifTrue As Expression) As ConditionalExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::ConditionalExpression ^ IfThen(System::Linq::Expressions::Expression ^ test, System::Linq::Expressions::Expression ^ ifTrue);" />
      <MemberSignature Language="F#" Value="static member IfThen : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.ConditionalExpression" Usage="System.Linq.Expressions.Expression.IfThen (test, ifTrue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ConditionalExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="test" Type="System.Linq.Expressions.Expression" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="ifTrue" Type="System.Linq.Expressions.Expression" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="test"><span data-ttu-id="7593b-1533">要将 <see cref="T:System.Linq.Expressions.Expression" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-1533">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" /> property equal to.</span></span></param>
        <param name="ifTrue"><span data-ttu-id="7593b-1534">要将 <see cref="T:System.Linq.Expressions.Expression" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-1534">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="7593b-1535">创建一个 <see cref="T:System.Linq.Expressions.ConditionalExpression" />，它表示带 <see langword="if" /> 语句的条件块。</span><span class="sxs-lookup"><span data-stu-id="7593b-1535">Creates a <see cref="T:System.Linq.Expressions.ConditionalExpression" /> that represents a conditional block with an <see langword="if" /> statement.</span></span></summary>
        <returns><span data-ttu-id="7593b-1536">一个 <see cref="T:System.Linq.Expressions.ConditionalExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 属性等于 <see cref="F:System.Linq.Expressions.ExpressionType.Conditional" />，并且 <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" />、<see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" /> 属性设置为指定值。</span><span class="sxs-lookup"><span data-stu-id="7593b-1536">A <see cref="T:System.Linq.Expressions.ConditionalExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Conditional" /> and the <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" />, <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" />, properties set to the specified values.</span></span> <span data-ttu-id="7593b-1537"><see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> 属性设置为默认表达式，并且此方法返回的结果 <see cref="T:System.Linq.Expressions.ConditionalExpression" /> 的类型为 <see cref="T:System.Void" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-1537">The <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> property is set to default expression and the type of the resulting <see cref="T:System.Linq.Expressions.ConditionalExpression" /> returned by this method is <see cref="T:System.Void" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="7593b-1538">下面的代码示例演示如何创建表示条件块的表达式。</span><span class="sxs-lookup"><span data-stu-id="7593b-1538">The following code example shows how to create an expression that represents a conditional block.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#32](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#32)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#32](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#32)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IfThenElse">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ConditionalExpression IfThenElse (System.Linq.Expressions.Expression test, System.Linq.Expressions.Expression ifTrue, System.Linq.Expressions.Expression ifFalse);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ConditionalExpression IfThenElse(class System.Linq.Expressions.Expression test, class System.Linq.Expressions.Expression ifTrue, class System.Linq.Expressions.Expression ifFalse) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.IfThenElse(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IfThenElse (test As Expression, ifTrue As Expression, ifFalse As Expression) As ConditionalExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::ConditionalExpression ^ IfThenElse(System::Linq::Expressions::Expression ^ test, System::Linq::Expressions::Expression ^ ifTrue, System::Linq::Expressions::Expression ^ ifFalse);" />
      <MemberSignature Language="F#" Value="static member IfThenElse : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.ConditionalExpression" Usage="System.Linq.Expressions.Expression.IfThenElse (test, ifTrue, ifFalse)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ConditionalExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="test" Type="System.Linq.Expressions.Expression" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="ifTrue" Type="System.Linq.Expressions.Expression" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="ifFalse" Type="System.Linq.Expressions.Expression" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="test"><span data-ttu-id="7593b-1539">要将 <see cref="T:System.Linq.Expressions.Expression" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-1539">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" /> property equal to.</span></span></param>
        <param name="ifTrue"><span data-ttu-id="7593b-1540">要将 <see cref="T:System.Linq.Expressions.Expression" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-1540">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" /> property equal to.</span></span></param>
        <param name="ifFalse"><span data-ttu-id="7593b-1541">要将 <see cref="T:System.Linq.Expressions.Expression" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-1541">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="7593b-1542">创建一个 <see cref="T:System.Linq.Expressions.ConditionalExpression" />，它表示带 <see langword="if" /> 和 <see langword="else" /> 语句的条件块。</span><span class="sxs-lookup"><span data-stu-id="7593b-1542">Creates a <see cref="T:System.Linq.Expressions.ConditionalExpression" /> that represents a conditional block with <see langword="if" /> and <see langword="else" /> statements.</span></span></summary>
        <returns><span data-ttu-id="7593b-1543">一个 <see cref="T:System.Linq.Expressions.ConditionalExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 属性等于 <see cref="F:System.Linq.Expressions.ExpressionType.Conditional" />，并且其 <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" />、<see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" /> 和 <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> 属性设置为指定值。</span><span class="sxs-lookup"><span data-stu-id="7593b-1543">A <see cref="T:System.Linq.Expressions.ConditionalExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Conditional" /> and the <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" />, <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" />, and <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> properties set to the specified values.</span></span> <span data-ttu-id="7593b-1544">此方法返回的结果 <see cref="T:System.Linq.Expressions.ConditionalExpression" /> 的类型为 <see cref="T:System.Void" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-1544">The type of the resulting <see cref="T:System.Linq.Expressions.ConditionalExpression" /> returned by this method is <see cref="T:System.Void" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="7593b-1545">下面的代码示例演示如何创建表示条件块的表达式。</span><span class="sxs-lookup"><span data-stu-id="7593b-1545">The following code example shows how to create an expression that represents a conditional block.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#33](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#33)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#33](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#33)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Increment">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="7593b-1546">创建一个 <see cref="T:System.Linq.Expressions.UnaryExpression" />，它表示按 1 递增表达式值。</span><span class="sxs-lookup"><span data-stu-id="7593b-1546">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents the incrementing of the expression value by 1.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Increment">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression Increment (System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression Increment(class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Increment(System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ Increment(System::Linq::Expressions::Expression ^ expression);" />
      <MemberSignature Language="F#" Value="static member Increment : System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.Increment expression" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="expression"><span data-ttu-id="7593b-1547">要递增的 <see cref="T:System.Linq.Expressions.Expression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-1547">An <see cref="T:System.Linq.Expressions.Expression" /> to increment.</span></span></param>
        <summary><span data-ttu-id="7593b-1548">创建一个 <see cref="T:System.Linq.Expressions.UnaryExpression" />，它表示按 1 递增表达式值。</span><span class="sxs-lookup"><span data-stu-id="7593b-1548">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents the incrementing of the expression value by 1.</span></span></summary>
        <returns><span data-ttu-id="7593b-1549">一个表示已递增的表达式的 <see cref="T:System.Linq.Expressions.UnaryExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-1549">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents the incremented expression.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7593b-1550">此表达式是有效的，并且不会更改传递给它的对象的值。</span><span class="sxs-lookup"><span data-stu-id="7593b-1550">This expression is functional and does not change the value of the object that is passed to it.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="7593b-1551">下面的代码示例演示如何创建表示增量运算的表达式。</span><span class="sxs-lookup"><span data-stu-id="7593b-1551">The following code example shows how to create an expression that represents an increment operation.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#24](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#24)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#24](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#24)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Increment">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression Increment (System.Linq.Expressions.Expression expression, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression Increment(class System.Linq.Expressions.Expression expression, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Increment(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ Increment(System::Linq::Expressions::Expression ^ expression, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member Increment : System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.Increment (expression, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="expression"><span data-ttu-id="7593b-1552">要递增的 <see cref="T:System.Linq.Expressions.Expression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-1552">An <see cref="T:System.Linq.Expressions.Expression" /> to increment.</span></span></param>
        <param name="method"><span data-ttu-id="7593b-1553">表示实现方法的 <see cref="T:System.Reflection.MethodInfo" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-1553">A <see cref="T:System.Reflection.MethodInfo" /> that represents the implementing method.</span></span></param>
        <summary><span data-ttu-id="7593b-1554">创建一个 <see cref="T:System.Linq.Expressions.UnaryExpression" />，它表示按 1 递增表达式值。</span><span class="sxs-lookup"><span data-stu-id="7593b-1554">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents the incrementing of the expression by 1.</span></span></summary>
        <returns><span data-ttu-id="7593b-1555">一个表示已递增的表达式的 <see cref="T:System.Linq.Expressions.UnaryExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-1555">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents the incremented expression.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7593b-1556">此表达式是有效的，并且不会更改传递给它的对象的值。</span><span class="sxs-lookup"><span data-stu-id="7593b-1556">This expression is functional and does not change the value of the object that is passed to it.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Invoke">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="7593b-1557">创建一个 <see cref="T:System.Linq.Expressions.InvocationExpression" />.</span><span class="sxs-lookup"><span data-stu-id="7593b-1557">Creates an <see cref="T:System.Linq.Expressions.InvocationExpression" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.InvocationExpression Invoke (System.Linq.Expressions.Expression expression, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.InvocationExpression Invoke(class System.Linq.Expressions.Expression expression, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Invoke(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::InvocationExpression ^ Invoke(System::Linq::Expressions::Expression ^ expression, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberSignature Language="F#" Value="static member Invoke : System.Linq.Expressions.Expression * seq&lt;System.Linq.Expressions.Expression&gt; -&gt; System.Linq.Expressions.InvocationExpression" Usage="System.Linq.Expressions.Expression.Invoke (expression, arguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.InvocationExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arguments" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="expression"><span data-ttu-id="7593b-1558">一个 <see cref="T:System.Linq.Expressions.Expression" />，它表示要应用的委托或 lambda 表达式。</span><span class="sxs-lookup"><span data-stu-id="7593b-1558">An <see cref="T:System.Linq.Expressions.Expression" /> that represents the delegate or lambda expression to be applied to.</span></span></param>
        <param name="arguments"><span data-ttu-id="7593b-1559">一个包含 <see cref="T:System.Collections.Generic.IEnumerable`1" /> 对象的 <see cref="T:System.Linq.Expressions.Expression" />，这些对象表示要对其应用委托或 Lambda 表达式的自变量。</span><span class="sxs-lookup"><span data-stu-id="7593b-1559">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.Expression" /> objects that represent the arguments that the delegate or lambda expression is applied to.</span></span></param>
        <summary><span data-ttu-id="7593b-1560">创建一个 <see cref="T:System.Linq.Expressions.InvocationExpression" />，它将委托或 lambda 表达式应用于一个自变量表达式列表。</span><span class="sxs-lookup"><span data-stu-id="7593b-1560">Creates an <see cref="T:System.Linq.Expressions.InvocationExpression" /> that applies a delegate or lambda expression to a list of argument expressions.</span></span></summary>
        <returns><span data-ttu-id="7593b-1561">一个 <see cref="T:System.Linq.Expressions.InvocationExpression" />，它对提供的自变量应用指定的委托或 lambda 表达式。</span><span class="sxs-lookup"><span data-stu-id="7593b-1561">An <see cref="T:System.Linq.Expressions.InvocationExpression" /> that applies the specified delegate or lambda expression to the provided arguments.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7593b-1562">生成的 <xref:System.Linq.Expressions.InvocationExpression> 的 <xref:System.Linq.Expressions.Expression.Type%2A> 属性表示 `expression`表示的委托的返回类型。类别.</span><span class="sxs-lookup"><span data-stu-id="7593b-1562">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.InvocationExpression> represents the return type of the delegate that is represented by `expression`.Type.</span></span>  
  
 <span data-ttu-id="7593b-1563">如果 `null``arguments`，则生成的 <xref:System.Linq.Expressions.InvocationExpression> 的 <xref:System.Linq.Expressions.InvocationExpression.Arguments%2A> 属性为空。</span><span class="sxs-lookup"><span data-stu-id="7593b-1563">The <xref:System.Linq.Expressions.InvocationExpression.Arguments%2A> property of the resulting <xref:System.Linq.Expressions.InvocationExpression> is empty if `arguments` is `null`.</span></span> <span data-ttu-id="7593b-1564">否则，它包含与 `arguments` 相同的元素，只不过其中某些 <xref:System.Linq.Expressions.Expression> 对象可能会被*括起来*。</span><span class="sxs-lookup"><span data-stu-id="7593b-1564">Otherwise, it contains the same elements as `arguments` except that some of these <xref:System.Linq.Expressions.Expression> objects may be *quoted*.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="7593b-1565">仅当 `expression` 表示的委托的相应参数为 <xref:System.Linq.Expressions.Expression>类型时，才会将元素括起来。</span><span class="sxs-lookup"><span data-stu-id="7593b-1565">An element will be quoted only if the corresponding parameter of the delegate represented by `expression` is of type <xref:System.Linq.Expressions.Expression>.</span></span> <span data-ttu-id="7593b-1566">引号表示元素包装在 <xref:System.Linq.Expressions.ExpressionType.Quote> 节点中。</span><span class="sxs-lookup"><span data-stu-id="7593b-1566">Quoting means the element is wrapped in a <xref:System.Linq.Expressions.ExpressionType.Quote> node.</span></span> <span data-ttu-id="7593b-1567">生成的节点是一个 <xref:System.Linq.Expressions.UnaryExpression>，其 <xref:System.Linq.Expressions.UnaryExpression.Operand%2A> 属性是 `arguments`的元素。</span><span class="sxs-lookup"><span data-stu-id="7593b-1567">The resulting node is a <xref:System.Linq.Expressions.UnaryExpression> whose <xref:System.Linq.Expressions.UnaryExpression.Operand%2A> property is the element of `arguments`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="7593b-1568">下面的示例演示如何使用 <xref:System.Linq.Expressions.Expression.Invoke%28System.Linq.Expressions.Expression%2CSystem.Linq.Expressions.Expression%5B%5D%29> 方法创建一个表示调用具有指定自变量的 lambda 表达式的 <xref:System.Linq.Expressions.InvocationExpression>。</span><span class="sxs-lookup"><span data-stu-id="7593b-1568">The following example demonstrates how to use the <xref:System.Linq.Expressions.Expression.Invoke%28System.Linq.Expressions.Expression%2CSystem.Linq.Expressions.Expression%5B%5D%29> method to create an <xref:System.Linq.Expressions.InvocationExpression> that represents the invocation of a lambda expression with specified arguments.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.Expression#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#6)]
 [!code-vb[System.Linq.Expressions.Expression#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="7593b-1569"><paramref name="expression" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-1569"><paramref name="expression" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="7593b-1570"><paramref name="expression" />.Type 不表示委托类型或 <see cref="T:System.Linq.Expressions.Expression`1" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-1570"><paramref name="expression" />.Type does not represent a delegate type or an <see cref="T:System.Linq.Expressions.Expression`1" />.</span></span>  
  
<span data-ttu-id="7593b-1571">- 或 -</span><span class="sxs-lookup"><span data-stu-id="7593b-1571">-or-</span></span> 
<span data-ttu-id="7593b-1572"><see cref="P:System.Linq.Expressions.Expression.Type" /> 的元素的 <paramref name="arguments" /> 属性不能赋给 <paramref name="expression" /> 所表示的委托的相应参数的类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-1572">The <see cref="P:System.Linq.Expressions.Expression.Type" /> property of an element of <paramref name="arguments" /> is not assignable to the type of the corresponding parameter of the delegate represented by <paramref name="expression" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="7593b-1573"><paramref name="arguments" /> 没有包含与 <paramref name="expression" /> 所表示的委托的参数列表相同数量的元素。</span><span class="sxs-lookup"><span data-stu-id="7593b-1573"><paramref name="arguments" /> does not contain the same number of elements as the list of parameters for the delegate represented by <paramref name="expression" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.InvocationExpression Invoke (System.Linq.Expressions.Expression expression, params System.Linq.Expressions.Expression[] arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.InvocationExpression Invoke(class System.Linq.Expressions.Expression expression, class System.Linq.Expressions.Expression[] arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Invoke(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::InvocationExpression ^ Invoke(System::Linq::Expressions::Expression ^ expression, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberSignature Language="F#" Value="static member Invoke : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression[] -&gt; System.Linq.Expressions.InvocationExpression" Usage="System.Linq.Expressions.Expression.Invoke (expression, arguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.InvocationExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arguments" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="expression"><span data-ttu-id="7593b-1574">一个 <see cref="T:System.Linq.Expressions.Expression" />，它表示要应用的委托或 lambda 表达式。</span><span class="sxs-lookup"><span data-stu-id="7593b-1574">An <see cref="T:System.Linq.Expressions.Expression" /> that represents the delegate or lambda expression to be applied.</span></span></param>
        <param name="arguments"><span data-ttu-id="7593b-1575"><see cref="T:System.Linq.Expressions.Expression" /> 对象的数组，这些对象表示要对其应用委托或 lambda 表达式的自变量。</span><span class="sxs-lookup"><span data-stu-id="7593b-1575">An array of <see cref="T:System.Linq.Expressions.Expression" /> objects that represent the arguments that the delegate or lambda expression is applied to.</span></span></param>
        <summary><span data-ttu-id="7593b-1576">创建一个 <see cref="T:System.Linq.Expressions.InvocationExpression" />，它将委托或 lambda 表达式应用于一个自变量表达式列表。</span><span class="sxs-lookup"><span data-stu-id="7593b-1576">Creates an <see cref="T:System.Linq.Expressions.InvocationExpression" /> that applies a delegate or lambda expression to a list of argument expressions.</span></span></summary>
        <returns><span data-ttu-id="7593b-1577">一个 <see cref="T:System.Linq.Expressions.InvocationExpression" />，它对提供的自变量应用指定的委托或 lambda 表达式。</span><span class="sxs-lookup"><span data-stu-id="7593b-1577">An <see cref="T:System.Linq.Expressions.InvocationExpression" /> that applies the specified delegate or lambda expression to the provided arguments.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7593b-1578">生成的 <xref:System.Linq.Expressions.InvocationExpression> 的 <xref:System.Linq.Expressions.Expression.Type%2A> 属性表示 `expression`表示的委托的返回类型。类别.</span><span class="sxs-lookup"><span data-stu-id="7593b-1578">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.InvocationExpression> represents the return type of the delegate that is represented by `expression`.Type.</span></span>  
  
 <span data-ttu-id="7593b-1579">如果 `null``arguments`，则生成的 <xref:System.Linq.Expressions.InvocationExpression> 的 <xref:System.Linq.Expressions.InvocationExpression.Arguments%2A> 属性为空。</span><span class="sxs-lookup"><span data-stu-id="7593b-1579">The <xref:System.Linq.Expressions.InvocationExpression.Arguments%2A> property of the resulting <xref:System.Linq.Expressions.InvocationExpression> is empty if `arguments` is `null`.</span></span> <span data-ttu-id="7593b-1580">否则，它包含与 `arguments` 相同的元素，只不过其中某些 <xref:System.Linq.Expressions.Expression> 对象可能会被*括起来*。</span><span class="sxs-lookup"><span data-stu-id="7593b-1580">Otherwise, it contains the same elements as `arguments` except that some of these <xref:System.Linq.Expressions.Expression> objects may be *quoted*.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="7593b-1581">仅当 `expression` 表示的委托的相应参数为 <xref:System.Linq.Expressions.Expression>类型时，才会将元素括起来。</span><span class="sxs-lookup"><span data-stu-id="7593b-1581">An element will be quoted only if the corresponding parameter of the delegate represented by `expression` is of type <xref:System.Linq.Expressions.Expression>.</span></span> <span data-ttu-id="7593b-1582">引号表示元素包装在 <xref:System.Linq.Expressions.ExpressionType.Quote> 节点中。</span><span class="sxs-lookup"><span data-stu-id="7593b-1582">Quoting means the element is wrapped in a <xref:System.Linq.Expressions.ExpressionType.Quote> node.</span></span> <span data-ttu-id="7593b-1583">生成的节点是一个 <xref:System.Linq.Expressions.UnaryExpression>，其 <xref:System.Linq.Expressions.UnaryExpression.Operand%2A> 属性是 `arguments`的元素。</span><span class="sxs-lookup"><span data-stu-id="7593b-1583">The resulting node is a <xref:System.Linq.Expressions.UnaryExpression> whose <xref:System.Linq.Expressions.UnaryExpression.Operand%2A> property is the element of `arguments`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="7593b-1584">下面的示例演示如何使用 <xref:System.Linq.Expressions.Expression.Invoke%28System.Linq.Expressions.Expression%2CSystem.Linq.Expressions.Expression%5B%5D%29> 方法创建一个表示调用具有指定自变量的 lambda 表达式的 <xref:System.Linq.Expressions.InvocationExpression>。</span><span class="sxs-lookup"><span data-stu-id="7593b-1584">The following example demonstrates how to use the <xref:System.Linq.Expressions.Expression.Invoke%28System.Linq.Expressions.Expression%2CSystem.Linq.Expressions.Expression%5B%5D%29> method to create an <xref:System.Linq.Expressions.InvocationExpression> that represents the invocation of a lambda expression with specified arguments.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.Expression#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#6)]
 [!code-vb[System.Linq.Expressions.Expression#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="7593b-1585"><paramref name="expression" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-1585"><paramref name="expression" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="7593b-1586"><paramref name="expression" />.Type 不表示委托类型或 <see cref="T:System.Linq.Expressions.Expression`1" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-1586"><paramref name="expression" />.Type does not represent a delegate type or an <see cref="T:System.Linq.Expressions.Expression`1" />.</span></span>  
  
<span data-ttu-id="7593b-1587">- 或 -</span><span class="sxs-lookup"><span data-stu-id="7593b-1587">-or-</span></span> 
<span data-ttu-id="7593b-1588"><see cref="P:System.Linq.Expressions.Expression.Type" /> 的元素的 <paramref name="arguments" /> 属性不能赋给 <paramref name="expression" /> 所表示的委托的相应参数的类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-1588">The <see cref="P:System.Linq.Expressions.Expression.Type" /> property of an element of <paramref name="arguments" /> is not assignable to the type of the corresponding parameter of the delegate represented by <paramref name="expression" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="7593b-1589"><paramref name="arguments" /> 没有包含与 <paramref name="expression" /> 所表示的委托的参数列表相同数量的元素。</span><span class="sxs-lookup"><span data-stu-id="7593b-1589"><paramref name="arguments" /> does not contain the same number of elements as the list of parameters for the delegate represented by <paramref name="expression" />.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="IsFalse">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="7593b-1590">返回表达式的计算结果是否为 false。</span><span class="sxs-lookup"><span data-stu-id="7593b-1590">Returns whether the expression evaluates to false.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsFalse">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression IsFalse (System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression IsFalse(class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.IsFalse(System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ IsFalse(System::Linq::Expressions::Expression ^ expression);" />
      <MemberSignature Language="F#" Value="static member IsFalse : System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.IsFalse expression" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="expression"><span data-ttu-id="7593b-1591">要计算的 <see cref="T:System.Linq.Expressions.Expression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-1591">An <see cref="T:System.Linq.Expressions.Expression" /> to evaluate.</span></span></param>
        <summary><span data-ttu-id="7593b-1592">返回表达式的计算结果是否为 false。</span><span class="sxs-lookup"><span data-stu-id="7593b-1592">Returns whether the expression evaluates to false.</span></span></summary>
        <returns><span data-ttu-id="7593b-1593"><see cref="T:System.Linq.Expressions.UnaryExpression" /> 的实例。</span><span class="sxs-lookup"><span data-stu-id="7593b-1593">An instance of <see cref="T:System.Linq.Expressions.UnaryExpression" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsFalse">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression IsFalse (System.Linq.Expressions.Expression expression, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression IsFalse(class System.Linq.Expressions.Expression expression, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.IsFalse(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ IsFalse(System::Linq::Expressions::Expression ^ expression, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member IsFalse : System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.IsFalse (expression, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="expression"><span data-ttu-id="7593b-1594">要计算的 <see cref="T:System.Linq.Expressions.Expression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-1594">An <see cref="T:System.Linq.Expressions.Expression" /> to evaluate.</span></span></param>
        <param name="method"><span data-ttu-id="7593b-1595">表示实现方法的 <see cref="T:System.Reflection.MethodInfo" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-1595">A <see cref="T:System.Reflection.MethodInfo" /> that represents the implementing method.</span></span></param>
        <summary><span data-ttu-id="7593b-1596">返回表达式的计算结果是否为 false。</span><span class="sxs-lookup"><span data-stu-id="7593b-1596">Returns whether the expression evaluates to false.</span></span></summary>
        <returns><span data-ttu-id="7593b-1597"><see cref="T:System.Linq.Expressions.UnaryExpression" /> 的实例。</span><span class="sxs-lookup"><span data-stu-id="7593b-1597">An instance of <see cref="T:System.Linq.Expressions.UnaryExpression" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="IsTrue">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="7593b-1598">返回表达式的计算结果是否为 true。</span><span class="sxs-lookup"><span data-stu-id="7593b-1598">Returns whether the expression evaluates to true.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsTrue">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression IsTrue (System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression IsTrue(class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.IsTrue(System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ IsTrue(System::Linq::Expressions::Expression ^ expression);" />
      <MemberSignature Language="F#" Value="static member IsTrue : System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.IsTrue expression" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="expression"><span data-ttu-id="7593b-1599">要计算的 <see cref="T:System.Linq.Expressions.Expression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-1599">An <see cref="T:System.Linq.Expressions.Expression" /> to evaluate.</span></span></param>
        <summary><span data-ttu-id="7593b-1600">返回表达式的计算结果是否为 true。</span><span class="sxs-lookup"><span data-stu-id="7593b-1600">Returns whether the expression evaluates to true.</span></span></summary>
        <returns><span data-ttu-id="7593b-1601"><see cref="T:System.Linq.Expressions.UnaryExpression" /> 的实例。</span><span class="sxs-lookup"><span data-stu-id="7593b-1601">An instance of <see cref="T:System.Linq.Expressions.UnaryExpression" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsTrue">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression IsTrue (System.Linq.Expressions.Expression expression, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression IsTrue(class System.Linq.Expressions.Expression expression, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.IsTrue(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ IsTrue(System::Linq::Expressions::Expression ^ expression, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member IsTrue : System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.IsTrue (expression, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="expression"><span data-ttu-id="7593b-1602">要计算的 <see cref="T:System.Linq.Expressions.Expression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-1602">An <see cref="T:System.Linq.Expressions.Expression" /> to evaluate.</span></span></param>
        <param name="method"><span data-ttu-id="7593b-1603">表示实现方法的 <see cref="T:System.Reflection.MethodInfo" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-1603">A <see cref="T:System.Reflection.MethodInfo" /> that represents the implementing method.</span></span></param>
        <summary><span data-ttu-id="7593b-1604">返回表达式的计算结果是否为 true。</span><span class="sxs-lookup"><span data-stu-id="7593b-1604">Returns whether the expression evaluates to true.</span></span></summary>
        <returns><span data-ttu-id="7593b-1605"><see cref="T:System.Linq.Expressions.UnaryExpression" /> 的实例。</span><span class="sxs-lookup"><span data-stu-id="7593b-1605">An instance of <see cref="T:System.Linq.Expressions.UnaryExpression" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Label">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="7593b-1606">创建一个表示标签的 <see cref="T:System.Linq.Expressions.LabelTarget" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-1606">Creates a <see cref="T:System.Linq.Expressions.LabelTarget" /> representing a label.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Label">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LabelTarget Label ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LabelTarget Label() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Label" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Label () As LabelTarget" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LabelTarget ^ Label();" />
      <MemberSignature Language="F#" Value="static member Label : unit -&gt; System.Linq.Expressions.LabelTarget" Usage="System.Linq.Expressions.Expression.Label " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LabelTarget</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="7593b-1607">创建一个 <see cref="T:System.Linq.Expressions.LabelTarget" />，它表示具有 void 类型但没有名称的标签。</span><span class="sxs-lookup"><span data-stu-id="7593b-1607">Creates a <see cref="T:System.Linq.Expressions.LabelTarget" /> representing a label with void type and no name.</span></span></summary>
        <returns><span data-ttu-id="7593b-1608">新的 <see cref="T:System.Linq.Expressions.LabelTarget" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-1608">The new <see cref="T:System.Linq.Expressions.LabelTarget" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="7593b-1609">下面的示例演示如何创建包含 <xref:System.Linq.Expressions.LabelTarget> 对象的表达式。</span><span class="sxs-lookup"><span data-stu-id="7593b-1609">The following example demonstrates how to create an expression that contains a <xref:System.Linq.Expressions.LabelTarget> object.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#43](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#43)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#43](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#43)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Label">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LabelExpression Label (System.Linq.Expressions.LabelTarget target);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LabelExpression Label(class System.Linq.Expressions.LabelTarget target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Label(System.Linq.Expressions.LabelTarget)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Label (target As LabelTarget) As LabelExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LabelExpression ^ Label(System::Linq::Expressions::LabelTarget ^ target);" />
      <MemberSignature Language="F#" Value="static member Label : System.Linq.Expressions.LabelTarget -&gt; System.Linq.Expressions.LabelExpression" Usage="System.Linq.Expressions.Expression.Label target" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LabelExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="target"><span data-ttu-id="7593b-1610">此 <see cref="T:System.Linq.Expressions.LabelTarget" /> 将关联的 <see cref="T:System.Linq.Expressions.LabelExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-1610">The <see cref="T:System.Linq.Expressions.LabelTarget" /> which this <see cref="T:System.Linq.Expressions.LabelExpression" /> will be associated with.</span></span></param>
        <summary><span data-ttu-id="7593b-1611">创建一个<see cref="T:System.Linq.Expressions.LabelExpression" />，它表示不带默认值的标签。</span><span class="sxs-lookup"><span data-stu-id="7593b-1611">Creates a <see cref="T:System.Linq.Expressions.LabelExpression" /> representing a label without a default value.</span></span></summary>
        <returns><span data-ttu-id="7593b-1612">不带默认值的 <see cref="T:System.Linq.Expressions.LabelExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-1612">A <see cref="T:System.Linq.Expressions.LabelExpression" /> without a default value.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Label">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LabelTarget Label (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LabelTarget Label(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Label(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Label (name As String) As LabelTarget" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LabelTarget ^ Label(System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member Label : string -&gt; System.Linq.Expressions.LabelTarget" Usage="System.Linq.Expressions.Expression.Label name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LabelTarget</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="7593b-1613">标签的名称。</span><span class="sxs-lookup"><span data-stu-id="7593b-1613">The name of the label.</span></span></param>
        <summary><span data-ttu-id="7593b-1614">创建一个 <see cref="T:System.Linq.Expressions.LabelTarget" />，它表示具有 void 类型和给定名称的标签。</span><span class="sxs-lookup"><span data-stu-id="7593b-1614">Creates a <see cref="T:System.Linq.Expressions.LabelTarget" /> representing a label with void type and the given name.</span></span></summary>
        <returns><span data-ttu-id="7593b-1615">新的 <see cref="T:System.Linq.Expressions.LabelTarget" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-1615">The new <see cref="T:System.Linq.Expressions.LabelTarget" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Label">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LabelTarget Label (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LabelTarget Label(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Label(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LabelTarget ^ Label(Type ^ type);" />
      <MemberSignature Language="F#" Value="static member Label : Type -&gt; System.Linq.Expressions.LabelTarget" Usage="System.Linq.Expressions.Expression.Label type" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LabelTarget</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="type"><span data-ttu-id="7593b-1616">跳转到标签时传递的值的类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-1616">The type of value that is passed when jumping to the label.</span></span></param>
        <summary><span data-ttu-id="7593b-1617">创建一个 <see cref="T:System.Linq.Expressions.LabelTarget" />，它表示具有给定类型的标签。</span><span class="sxs-lookup"><span data-stu-id="7593b-1617">Creates a <see cref="T:System.Linq.Expressions.LabelTarget" /> representing a label with the given type.</span></span></summary>
        <returns><span data-ttu-id="7593b-1618">新的 <see cref="T:System.Linq.Expressions.LabelTarget" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-1618">The new <see cref="T:System.Linq.Expressions.LabelTarget" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="7593b-1619">下面的示例演示如何使用循环表达式中的 <xref:System.Linq.Expressions.LabelTarget> 对象。</span><span class="sxs-lookup"><span data-stu-id="7593b-1619">The following example demonstrates how to use a <xref:System.Linq.Expressions.LabelTarget> object in a loop expression.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#44](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#44)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#44](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#44)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Label">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LabelExpression Label (System.Linq.Expressions.LabelTarget target, System.Linq.Expressions.Expression defaultValue);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LabelExpression Label(class System.Linq.Expressions.LabelTarget target, class System.Linq.Expressions.Expression defaultValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Label(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Label (target As LabelTarget, defaultValue As Expression) As LabelExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LabelExpression ^ Label(System::Linq::Expressions::LabelTarget ^ target, System::Linq::Expressions::Expression ^ defaultValue);" />
      <MemberSignature Language="F#" Value="static member Label : System.Linq.Expressions.LabelTarget * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.LabelExpression" Usage="System.Linq.Expressions.Expression.Label (target, defaultValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LabelExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="defaultValue" Type="System.Linq.Expressions.Expression" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="target"><span data-ttu-id="7593b-1620">此 <see cref="T:System.Linq.Expressions.LabelTarget" /> 将关联的 <see cref="T:System.Linq.Expressions.LabelExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-1620">The <see cref="T:System.Linq.Expressions.LabelTarget" /> which this <see cref="T:System.Linq.Expressions.LabelExpression" /> will be associated with.</span></span></param>
        <param name="defaultValue"><span data-ttu-id="7593b-1621">当通过常规控制流到达标签时，此 <see cref="T:System.Linq.Expressions.LabelExpression" /> 的值。</span><span class="sxs-lookup"><span data-stu-id="7593b-1621">The value of this <see cref="T:System.Linq.Expressions.LabelExpression" /> when the label is reached through regular control flow.</span></span></param>
        <summary><span data-ttu-id="7593b-1622">创建一个 <see cref="T:System.Linq.Expressions.LabelExpression" />，它表示具有给定默认值的标签。</span><span class="sxs-lookup"><span data-stu-id="7593b-1622">Creates a <see cref="T:System.Linq.Expressions.LabelExpression" /> representing a label with the given default value.</span></span></summary>
        <returns><span data-ttu-id="7593b-1623">具有给定默认值的 <see cref="T:System.Linq.Expressions.LabelExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-1623">A <see cref="T:System.Linq.Expressions.LabelExpression" /> with the given default value.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Label">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LabelTarget Label (Type type, string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LabelTarget Label(class System.Type type, string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Label(System.Type,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LabelTarget ^ Label(Type ^ type, System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member Label : Type * string -&gt; System.Linq.Expressions.LabelTarget" Usage="System.Linq.Expressions.Expression.Label (type, name)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LabelTarget</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="name" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="type"><span data-ttu-id="7593b-1624">跳转到标签时传递的值的类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-1624">The type of value that is passed when jumping to the label.</span></span></param>
        <param name="name"><span data-ttu-id="7593b-1625">标签的名称。</span><span class="sxs-lookup"><span data-stu-id="7593b-1625">The name of the label.</span></span></param>
        <summary><span data-ttu-id="7593b-1626">创建一个 <see cref="T:System.Linq.Expressions.LabelTarget" />，它表示具有给定类型和名称的标签。</span><span class="sxs-lookup"><span data-stu-id="7593b-1626">Creates a <see cref="T:System.Linq.Expressions.LabelTarget" /> representing a label with the given type and name.</span></span></summary>
        <returns><span data-ttu-id="7593b-1627">新的 <see cref="T:System.Linq.Expressions.LabelTarget" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-1627">The new <see cref="T:System.Linq.Expressions.LabelTarget" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Lambda">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="7593b-1628">创建一个表示 Lambda 表达式的表达式树。</span><span class="sxs-lookup"><span data-stu-id="7593b-1628">Creates an expression tree that represents a lambda expression.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Lambda">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LambdaExpression Lambda (System.Linq.Expressions.Expression body, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LambdaExpression Lambda(class System.Linq.Expressions.Expression body, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Lambda (body As Expression, parameters As IEnumerable(Of ParameterExpression)) As LambdaExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LambdaExpression ^ Lambda(System::Linq::Expressions::Expression ^ body, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="static member Lambda : System.Linq.Expressions.Expression * seq&lt;System.Linq.Expressions.ParameterExpression&gt; -&gt; System.Linq.Expressions.LambdaExpression" Usage="System.Linq.Expressions.Expression.Lambda (body, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LambdaExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="parameters" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="body"><span data-ttu-id="7593b-1629">要将 <see cref="T:System.Linq.Expressions.Expression" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-1629">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> property equal to.</span></span></param>
        <param name="parameters"><span data-ttu-id="7593b-1630">一个 <see cref="T:System.Collections.Generic.IEnumerable`1" />，包含用来填充 <see cref="T:System.Linq.Expressions.ParameterExpression" /> 集合的 <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> 对象。</span><span class="sxs-lookup"><span data-stu-id="7593b-1630">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.ParameterExpression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> collection.</span></span></param>
        <summary><span data-ttu-id="7593b-1631">首先从表达式主体构造一个委托类型以及一个参数表达式的可枚举集合，以便创建 <see cref="T:System.Linq.Expressions.LambdaExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-1631">Creates a <see cref="T:System.Linq.Expressions.LambdaExpression" /> by first constructing a delegate type from the expression body, and an enumerable collection of parameter expressions.</span></span> <span data-ttu-id="7593b-1632">如果委托类型在编译时未知，则可以使用它。</span><span class="sxs-lookup"><span data-stu-id="7593b-1632">It can be used when the delegate type is not known at compile time.</span></span></summary>
        <returns><span data-ttu-id="7593b-1633">一个 <see cref="T:System.Linq.Expressions.LambdaExpression" />，其 <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> 属性等于 Lambda，并且其 <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> 和 <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> 属性均设置为指定的值。</span><span class="sxs-lookup"><span data-stu-id="7593b-1633">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> that has the <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> property equal to Lambda and the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> and <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Lambda">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LambdaExpression Lambda (System.Linq.Expressions.Expression body, params System.Linq.Expressions.ParameterExpression[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LambdaExpression Lambda(class System.Linq.Expressions.Expression body, class System.Linq.Expressions.ParameterExpression[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda(System.Linq.Expressions.Expression,System.Linq.Expressions.ParameterExpression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Lambda (body As Expression, ParamArray parameters As ParameterExpression()) As LambdaExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LambdaExpression ^ Lambda(System::Linq::Expressions::Expression ^ body, ... cli::array &lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="static member Lambda : System.Linq.Expressions.Expression * System.Linq.Expressions.ParameterExpression[] -&gt; System.Linq.Expressions.LambdaExpression" Usage="System.Linq.Expressions.Expression.Lambda (body, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LambdaExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="parameters" Type="System.Linq.Expressions.ParameterExpression[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="body"><span data-ttu-id="7593b-1634">要将 <see cref="T:System.Linq.Expressions.Expression" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-1634">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> property equal to.</span></span></param>
        <param name="parameters"><span data-ttu-id="7593b-1635">用于填充 <see cref="T:System.Linq.Expressions.ParameterExpression" /> 集合的 <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> 对象的数组。</span><span class="sxs-lookup"><span data-stu-id="7593b-1635">An array of <see cref="T:System.Linq.Expressions.ParameterExpression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> collection.</span></span></param>
        <summary><span data-ttu-id="7593b-1636">首先从表达式主体构造一个委托类型以及一个参数表达式的数组，以便创建 <see cref="T:System.Linq.Expressions.LambdaExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-1636">Creates a <see cref="T:System.Linq.Expressions.LambdaExpression" /> by first constructing a delegate type from the expression body, and an array of parameter expressions.</span></span> <span data-ttu-id="7593b-1637">如果委托类型在编译时未知，则可以使用它。</span><span class="sxs-lookup"><span data-stu-id="7593b-1637">It can be used when the delegate type is not known at compile time.</span></span></summary>
        <returns><span data-ttu-id="7593b-1638">一个 <see cref="T:System.Linq.Expressions.LambdaExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 属性等于 <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" />，并且其 <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> 和 <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> 属性设置为指定值。</span><span class="sxs-lookup"><span data-stu-id="7593b-1638">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> and the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> and <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7593b-1639">`parameters` 参数不能包含十六个以上的元素。</span><span class="sxs-lookup"><span data-stu-id="7593b-1639">The `parameters` parameter must not have more than sixteen elements.</span></span>  
  
 <span data-ttu-id="7593b-1640">`parameters` 的元素必须是与 `body`中的参数表达式相等的引用。</span><span class="sxs-lookup"><span data-stu-id="7593b-1640">The elements of `parameters` must be reference equal to the parameter expressions in `body`.</span></span>  
  
 <span data-ttu-id="7593b-1641">此方法从一个 `System.Func` 泛型委托构造适当的委托类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-1641">This method constructs an appropriate delegate type from one of the `System.Func` generic delegates.</span></span> <span data-ttu-id="7593b-1642">然后，它将委托类型传递给 <xref:System.Linq.Expressions.ExpressionType.Lambda> 工厂方法之一，以创建 <xref:System.Linq.Expressions.LambdaExpression>。</span><span class="sxs-lookup"><span data-stu-id="7593b-1642">It then passes the delegate type to one of the <xref:System.Linq.Expressions.ExpressionType.Lambda> factory methods to create a <xref:System.Linq.Expressions.LambdaExpression>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="7593b-1643"><paramref name="body" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-1643"><paramref name="body" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="7593b-1644">- 或 -</span><span class="sxs-lookup"><span data-stu-id="7593b-1644">-or-</span></span> 
<span data-ttu-id="7593b-1645"><paramref name="parameters" /> 的一个或多个元素为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-1645">One or more elements of <paramref name="parameters" /> are <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="7593b-1646"><paramref name="parameters" /> 包含 16 个以上的元素。</span><span class="sxs-lookup"><span data-stu-id="7593b-1646"><paramref name="parameters" /> contains more than sixteen elements.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Lambda">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LambdaExpression Lambda (System.Linq.Expressions.Expression body, bool tailCall, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LambdaExpression Lambda(class System.Linq.Expressions.Expression body, bool tailCall, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda(System.Linq.Expressions.Expression,System.Boolean,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Lambda (body As Expression, tailCall As Boolean, parameters As IEnumerable(Of ParameterExpression)) As LambdaExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LambdaExpression ^ Lambda(System::Linq::Expressions::Expression ^ body, bool tailCall, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="static member Lambda : System.Linq.Expressions.Expression * bool * seq&lt;System.Linq.Expressions.ParameterExpression&gt; -&gt; System.Linq.Expressions.LambdaExpression" Usage="System.Linq.Expressions.Expression.Lambda (body, tailCall, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LambdaExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="tailCall" Type="System.Boolean" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="parameters" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="body"><span data-ttu-id="7593b-1647">要将 <see cref="T:System.Linq.Expressions.Expression" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-1647">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> property equal to.</span></span></param>
        <param name="tailCall"><span data-ttu-id="7593b-1648">一个 <see cref="T:System.Boolean" />，指示在编译创建的表达式时是否将应用尾调用优化。</span><span class="sxs-lookup"><span data-stu-id="7593b-1648">A <see cref="T:System.Boolean" /> that indicates if tail call optimization will be applied when compiling the created expression.</span></span></param>
        <param name="parameters"><span data-ttu-id="7593b-1649">一个 <see cref="T:System.Collections.Generic.IEnumerable`1" />，包含用来填充 <see cref="T:System.Linq.Expressions.ParameterExpression" /> 集合的 <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> 对象。</span><span class="sxs-lookup"><span data-stu-id="7593b-1649">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.ParameterExpression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> collection.</span></span></param>
        <summary><span data-ttu-id="7593b-1650">首先从表达式主体构造一个委托类型，一个表示是否将应用尾调用优化的参数以及一个参数表达式的可枚举集合，以便创建 <see cref="T:System.Linq.Expressions.LambdaExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-1650">Creates a <see cref="T:System.Linq.Expressions.LambdaExpression" /> by first constructing a delegate type from the expression body, a parameter that indicates whether tail call optimization will be applied, and an enumerable collection of parameter expressions.</span></span> <span data-ttu-id="7593b-1651">如果委托类型在编译时未知，则可以使用它。</span><span class="sxs-lookup"><span data-stu-id="7593b-1651">It can be used when the delegate type is not known at compile time.</span></span></summary>
        <returns><span data-ttu-id="7593b-1652">一个 <see cref="T:System.Linq.Expressions.LambdaExpression" />，其 <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> 属性等于 Lambda，并且其 <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> 和 <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> 属性均设置为指定的值。</span><span class="sxs-lookup"><span data-stu-id="7593b-1652">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> that has the <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> property equal to Lambda and the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> and <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Lambda">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LambdaExpression Lambda (System.Linq.Expressions.Expression body, bool tailCall, params System.Linq.Expressions.ParameterExpression[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LambdaExpression Lambda(class System.Linq.Expressions.Expression body, bool tailCall, class System.Linq.Expressions.ParameterExpression[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda(System.Linq.Expressions.Expression,System.Boolean,System.Linq.Expressions.ParameterExpression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Lambda (body As Expression, tailCall As Boolean, ParamArray parameters As ParameterExpression()) As LambdaExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LambdaExpression ^ Lambda(System::Linq::Expressions::Expression ^ body, bool tailCall, ... cli::array &lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="static member Lambda : System.Linq.Expressions.Expression * bool * System.Linq.Expressions.ParameterExpression[] -&gt; System.Linq.Expressions.LambdaExpression" Usage="System.Linq.Expressions.Expression.Lambda (body, tailCall, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LambdaExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="tailCall" Type="System.Boolean" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="parameters" Type="System.Linq.Expressions.ParameterExpression[]" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="body"><span data-ttu-id="7593b-1653">要将 <see cref="T:System.Linq.Expressions.Expression" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-1653">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> property equal to.</span></span></param>
        <param name="tailCall"><span data-ttu-id="7593b-1654">一个 <see cref="T:System.Boolean" />，指示在编译创建的表达式时是否将应用尾调用优化。</span><span class="sxs-lookup"><span data-stu-id="7593b-1654">A <see cref="T:System.Boolean" /> that indicates if tail call optimization will be applied when compiling the created expression.</span></span></param>
        <param name="parameters"><span data-ttu-id="7593b-1655">其中包含用于填充 <see cref="T:System.Linq.Expressions.ParameterExpression" /> 集合的 <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> 对象的数组。</span><span class="sxs-lookup"><span data-stu-id="7593b-1655">An array that contains <see cref="T:System.Linq.Expressions.ParameterExpression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> collection.</span></span></param>
        <summary><span data-ttu-id="7593b-1656">首先从表达式主体构造一个委托类型，一个表示是否将应用尾调用优化的参数以及一个参数表达式的数组，以便创建 <see cref="T:System.Linq.Expressions.LambdaExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-1656">Creates a <see cref="T:System.Linq.Expressions.LambdaExpression" /> by first constructing a delegate type from the expression body, a parameter that indicates whether tail call optimization will be applied, and an array of parameter expressions.</span></span> <span data-ttu-id="7593b-1657">如果委托类型在编译时未知，则可以使用它。</span><span class="sxs-lookup"><span data-stu-id="7593b-1657">It can be used when the delegate type is not known at compile time.</span></span></summary>
        <returns><span data-ttu-id="7593b-1658">一个 <see cref="T:System.Linq.Expressions.LambdaExpression" />，其 <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> 属性等于 Lambda，并且其 <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> 和 <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> 属性均设置为指定的值。</span><span class="sxs-lookup"><span data-stu-id="7593b-1658">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> that has the <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> property equal to Lambda and the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> and <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Lambda">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LambdaExpression Lambda (System.Linq.Expressions.Expression body, string name, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LambdaExpression Lambda(class System.Linq.Expressions.Expression body, string name, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda(System.Linq.Expressions.Expression,System.String,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Lambda (body As Expression, name As String, parameters As IEnumerable(Of ParameterExpression)) As LambdaExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LambdaExpression ^ Lambda(System::Linq::Expressions::Expression ^ body, System::String ^ name, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="static member Lambda : System.Linq.Expressions.Expression * string * seq&lt;System.Linq.Expressions.ParameterExpression&gt; -&gt; System.Linq.Expressions.LambdaExpression" Usage="System.Linq.Expressions.Expression.Lambda (body, name, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LambdaExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="name" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="parameters" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="body"><span data-ttu-id="7593b-1659">要将 <see cref="T:System.Linq.Expressions.Expression" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-1659">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> property equal to.</span></span></param>
        <param name="name"><span data-ttu-id="7593b-1660">lambda 的名称。</span><span class="sxs-lookup"><span data-stu-id="7593b-1660">The name for the lambda.</span></span> <span data-ttu-id="7593b-1661">用于发出调试信息。</span><span class="sxs-lookup"><span data-stu-id="7593b-1661">Used for emitting debug information.</span></span></param>
        <param name="parameters"><span data-ttu-id="7593b-1662">一个 <see cref="T:System.Collections.Generic.IEnumerable`1" />，包含用来填充 <see cref="T:System.Linq.Expressions.ParameterExpression" /> 集合的 <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> 对象。</span><span class="sxs-lookup"><span data-stu-id="7593b-1662">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.ParameterExpression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> collection.</span></span></param>
        <summary><span data-ttu-id="7593b-1663">首先从表达式主体构造一个委托类型、lambda 的名称和一个参数表达式的可枚举集合，以便创建 <see cref="T:System.Linq.Expressions.LambdaExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-1663">Creates a <see cref="T:System.Linq.Expressions.LambdaExpression" /> by first constructing a delegate type from the expression body, the name for the lambda, and an enumerable collection of parameter expressions.</span></span> <span data-ttu-id="7593b-1664">如果委托类型在编译时未知，则可以使用它。</span><span class="sxs-lookup"><span data-stu-id="7593b-1664">It can be used when the delegate type is not known at compile time.</span></span></summary>
        <returns><span data-ttu-id="7593b-1665">一个 <see cref="T:System.Linq.Expressions.LambdaExpression" />，其 <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> 属性等于 Lambda，并且其 <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> 和 <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> 属性均设置为指定的值。</span><span class="sxs-lookup"><span data-stu-id="7593b-1665">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> that has the <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> property equal to Lambda and the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> and <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Lambda">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LambdaExpression Lambda (Type delegateType, System.Linq.Expressions.Expression body, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LambdaExpression Lambda(class System.Type delegateType, class System.Linq.Expressions.Expression body, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda(System.Type,System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Lambda (delegateType As Type, body As Expression, parameters As IEnumerable(Of ParameterExpression)) As LambdaExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LambdaExpression ^ Lambda(Type ^ delegateType, System::Linq::Expressions::Expression ^ body, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="static member Lambda : Type * System.Linq.Expressions.Expression * seq&lt;System.Linq.Expressions.ParameterExpression&gt; -&gt; System.Linq.Expressions.LambdaExpression" Usage="System.Linq.Expressions.Expression.Lambda (delegateType, body, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LambdaExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegateType" Type="System.Type" />
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="parameters" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" />
      </Parameters>
      <Docs>
        <param name="delegateType"><span data-ttu-id="7593b-1666">一个 <see cref="T:System.Type" />，它表示 lambda 的委托签名。</span><span class="sxs-lookup"><span data-stu-id="7593b-1666">A <see cref="T:System.Type" /> that represents a delegate signature for the lambda.</span></span></param>
        <param name="body"><span data-ttu-id="7593b-1667">要将 <see cref="T:System.Linq.Expressions.Expression" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-1667">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> property equal to.</span></span></param>
        <param name="parameters"><span data-ttu-id="7593b-1668">一个 <see cref="T:System.Collections.Generic.IEnumerable`1" />，包含用来填充 <see cref="T:System.Linq.Expressions.ParameterExpression" /> 集合的 <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> 对象。</span><span class="sxs-lookup"><span data-stu-id="7593b-1668">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.ParameterExpression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> collection.</span></span></param>
        <summary><span data-ttu-id="7593b-1669">使用参数表达式的可枚举集合创建一个在编译时委托类型已知的 <see cref="T:System.Linq.Expressions.LambdaExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-1669">Creates a <see cref="T:System.Linq.Expressions.LambdaExpression" /> where the delegate type is known at compile time, with an enumerable collection of parameter expressions.</span></span></summary>
        <returns><span data-ttu-id="7593b-1670">一个表示 lambda 表达式的对象，该表达式的 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 属性等于 <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" />，并且 <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> 和 <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> 属性设置为指定值。</span><span class="sxs-lookup"><span data-stu-id="7593b-1670">An object that represents a lambda expression which has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> and the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> and <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7593b-1671">从此函数返回的对象的类型为 <xref:System.Linq.Expressions.Expression%601>。</span><span class="sxs-lookup"><span data-stu-id="7593b-1671">The object that is returned from this function is of type <xref:System.Linq.Expressions.Expression%601>.</span></span> <span data-ttu-id="7593b-1672"><xref:System.Linq.Expressions.LambdaExpression> 类型用于表示返回的对象，因为 lambda 表达式的具体类型在编译时是未知的。</span><span class="sxs-lookup"><span data-stu-id="7593b-1672">The <xref:System.Linq.Expressions.LambdaExpression> type is used to represent the returned object because the concrete type of the lambda expression is not known at compile time.</span></span>  
  
 <span data-ttu-id="7593b-1673">`delegateType` 表示的委托类型的参数数目必须等于 `parameters`的长度。</span><span class="sxs-lookup"><span data-stu-id="7593b-1673">The number of parameters for the delegate type represented by`delegateType` must equal the length of `parameters`.</span></span>  
  
 <span data-ttu-id="7593b-1674">`parameters` 的元素必须是与 `body`中的参数表达式相等的引用。</span><span class="sxs-lookup"><span data-stu-id="7593b-1674">The elements of `parameters` must be reference equal to the parameter expressions in `body`.</span></span>  
  
 <span data-ttu-id="7593b-1675">生成的对象的 <xref:System.Linq.Expressions.Expression.Type%2A> 属性等于 `delegateType`。</span><span class="sxs-lookup"><span data-stu-id="7593b-1675">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting object is equal to `delegateType`.</span></span> <span data-ttu-id="7593b-1676">如果 `null``parameters`，则生成的对象的 <xref:System.Linq.Expressions.LambdaExpression.Parameters%2A> 属性为空集合。</span><span class="sxs-lookup"><span data-stu-id="7593b-1676">If `parameters` is `null`, the <xref:System.Linq.Expressions.LambdaExpression.Parameters%2A> property of the resulting object is an empty collection.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="7593b-1677">下面的示例演示如何创建一个表达式，该表达式表示将1添加到传递的自变量的 lambda 表达式。</span><span class="sxs-lookup"><span data-stu-id="7593b-1677">The following example demonstrates how to create an expression that represents a lambda expression that adds 1 to the passed argument.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#42](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#42)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#42](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="7593b-1678"><paramref name="delegateType" /> 或 <paramref name="body" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-1678"><paramref name="delegateType" /> or <paramref name="body" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="7593b-1679">- 或 -</span><span class="sxs-lookup"><span data-stu-id="7593b-1679">-or-</span></span> 
<span data-ttu-id="7593b-1680"><paramref name="parameters" /> 中的一个或多个元素为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-1680">One or more elements in <paramref name="parameters" /> are <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="7593b-1681"><paramref name="delegateType" /> 不表示委托类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-1681"><paramref name="delegateType" /> does not represent a delegate type.</span></span>  
  
<span data-ttu-id="7593b-1682">- 或 -</span><span class="sxs-lookup"><span data-stu-id="7593b-1682">-or-</span></span> 
 <span data-ttu-id="7593b-1683"><paramref name="body" />.Type 表示一个类型，该类型不能赋给 <paramref name="delegateType" /> 所表示的委托类型的返回类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-1683"><paramref name="body" />.Type represents a type that is not assignable to the return type of the delegate type represented by <paramref name="delegateType" />.</span></span>  
  
<span data-ttu-id="7593b-1684">- 或 -</span><span class="sxs-lookup"><span data-stu-id="7593b-1684">-or-</span></span> 
 <span data-ttu-id="7593b-1685"><paramref name="parameters" /> 没有包含与 <paramref name="delegateType" /> 所表示的委托类型的参数列表相同数量的元素。</span><span class="sxs-lookup"><span data-stu-id="7593b-1685"><paramref name="parameters" /> does not contain the same number of elements as the list of parameters for the delegate type represented by <paramref name="delegateType" />.</span></span>  
  
<span data-ttu-id="7593b-1686">- 或 -</span><span class="sxs-lookup"><span data-stu-id="7593b-1686">-or-</span></span> 
<span data-ttu-id="7593b-1687"><see cref="P:System.Linq.Expressions.Expression.Type" /> 的元素的 <paramref name="parameters" /> 属性不可从 <paramref name="delegateType" /> 所表示的委托类型的相应参数类型的类型赋值。</span><span class="sxs-lookup"><span data-stu-id="7593b-1687">The <see cref="P:System.Linq.Expressions.Expression.Type" /> property of an element of <paramref name="parameters" /> is not assignable from the type of the corresponding parameter type of the delegate type represented by <paramref name="delegateType" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Lambda">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LambdaExpression Lambda (Type delegateType, System.Linq.Expressions.Expression body, params System.Linq.Expressions.ParameterExpression[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LambdaExpression Lambda(class System.Type delegateType, class System.Linq.Expressions.Expression body, class System.Linq.Expressions.ParameterExpression[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda(System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.ParameterExpression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Lambda (delegateType As Type, body As Expression, ParamArray parameters As ParameterExpression()) As LambdaExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LambdaExpression ^ Lambda(Type ^ delegateType, System::Linq::Expressions::Expression ^ body, ... cli::array &lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="static member Lambda : Type * System.Linq.Expressions.Expression * System.Linq.Expressions.ParameterExpression[] -&gt; System.Linq.Expressions.LambdaExpression" Usage="System.Linq.Expressions.Expression.Lambda (delegateType, body, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LambdaExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegateType" Type="System.Type" />
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="parameters" Type="System.Linq.Expressions.ParameterExpression[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="delegateType"><span data-ttu-id="7593b-1688">一个 <see cref="T:System.Type" />，它表示 lambda 的委托签名。</span><span class="sxs-lookup"><span data-stu-id="7593b-1688">A <see cref="T:System.Type" /> that represents a delegate signature for the lambda.</span></span></param>
        <param name="body"><span data-ttu-id="7593b-1689">要将 <see cref="T:System.Linq.Expressions.Expression" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-1689">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> property equal to.</span></span></param>
        <param name="parameters"><span data-ttu-id="7593b-1690">用于填充 <see cref="T:System.Linq.Expressions.ParameterExpression" /> 集合的 <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> 对象的数组。</span><span class="sxs-lookup"><span data-stu-id="7593b-1690">An array of <see cref="T:System.Linq.Expressions.ParameterExpression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> collection.</span></span></param>
        <summary><span data-ttu-id="7593b-1691">使用参数表达式的数组创建一个在编译时委托类型已知的 <see cref="T:System.Linq.Expressions.LambdaExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-1691">Creates a <see cref="T:System.Linq.Expressions.LambdaExpression" /> where the delegate type is known at compile time, with an array of parameter expressions.</span></span></summary>
        <returns><span data-ttu-id="7593b-1692">一个表示 lambda 表达式的对象，该表达式的 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 属性等于 <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" />，并且 <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> 和 <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> 属性设置为指定值。</span><span class="sxs-lookup"><span data-stu-id="7593b-1692">An object that represents a lambda expression which has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> and the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> and <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7593b-1693">从此函数返回的对象的类型为 <xref:System.Linq.Expressions.Expression%601>。</span><span class="sxs-lookup"><span data-stu-id="7593b-1693">The object that is returned from this function is of type <xref:System.Linq.Expressions.Expression%601>.</span></span> <span data-ttu-id="7593b-1694"><xref:System.Linq.Expressions.LambdaExpression> 类型用于表示返回的对象，因为 lambda 表达式的具体类型在编译时是未知的。</span><span class="sxs-lookup"><span data-stu-id="7593b-1694">The <xref:System.Linq.Expressions.LambdaExpression> type is used to represent the returned object because the concrete type of the lambda expression is not known at compile time.</span></span>  
  
 <span data-ttu-id="7593b-1695">`delegateType` 表示的委托类型的参数数目必须等于 `parameters`的长度。</span><span class="sxs-lookup"><span data-stu-id="7593b-1695">The number of parameters for the delegate type represented by `delegateType` must equal the length of `parameters`.</span></span>  
  
 <span data-ttu-id="7593b-1696">`parameters` 的元素必须是与 `body`中的参数表达式相等的引用。</span><span class="sxs-lookup"><span data-stu-id="7593b-1696">The elements of `parameters` must be reference equal to the parameter expressions in `body`.</span></span>  
  
 <span data-ttu-id="7593b-1697">生成的对象的 <xref:System.Linq.Expressions.Expression.Type%2A> 属性等于 `delegateType`。</span><span class="sxs-lookup"><span data-stu-id="7593b-1697">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting object is equal to `delegateType`.</span></span> <span data-ttu-id="7593b-1698">如果 `null``parameters`，则生成的对象的 <xref:System.Linq.Expressions.LambdaExpression.Parameters%2A> 属性为空集合。</span><span class="sxs-lookup"><span data-stu-id="7593b-1698">If `parameters` is `null`, the <xref:System.Linq.Expressions.LambdaExpression.Parameters%2A> property of the resulting object is an empty collection.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="7593b-1699"><paramref name="delegateType" /> 或 <paramref name="body" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-1699"><paramref name="delegateType" /> or <paramref name="body" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="7593b-1700">- 或 -</span><span class="sxs-lookup"><span data-stu-id="7593b-1700">-or-</span></span> 
<span data-ttu-id="7593b-1701"><paramref name="parameters" /> 中的一个或多个元素为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-1701">One or more elements in <paramref name="parameters" /> are <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="7593b-1702"><paramref name="delegateType" /> 不表示委托类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-1702"><paramref name="delegateType" /> does not represent a delegate type.</span></span>  
  
<span data-ttu-id="7593b-1703">- 或 -</span><span class="sxs-lookup"><span data-stu-id="7593b-1703">-or-</span></span> 
 <span data-ttu-id="7593b-1704"><paramref name="body" />.Type 表示一个类型，该类型不能赋给 <paramref name="delegateType" /> 所表示的委托类型的返回类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-1704"><paramref name="body" />.Type represents a type that is not assignable to the return type of the delegate type represented by <paramref name="delegateType" />.</span></span>  
  
<span data-ttu-id="7593b-1705">- 或 -</span><span class="sxs-lookup"><span data-stu-id="7593b-1705">-or-</span></span> 
 <span data-ttu-id="7593b-1706"><paramref name="parameters" /> 没有包含与 <paramref name="delegateType" /> 所表示的委托类型的参数列表相同数量的元素。</span><span class="sxs-lookup"><span data-stu-id="7593b-1706"><paramref name="parameters" /> does not contain the same number of elements as the list of parameters for the delegate type represented by <paramref name="delegateType" />.</span></span>  
  
<span data-ttu-id="7593b-1707">- 或 -</span><span class="sxs-lookup"><span data-stu-id="7593b-1707">-or-</span></span> 
<span data-ttu-id="7593b-1708"><see cref="P:System.Linq.Expressions.Expression.Type" /> 的元素的 <paramref name="parameters" /> 属性不可从 <paramref name="delegateType" /> 所表示的委托类型的相应参数类型的类型赋值。</span><span class="sxs-lookup"><span data-stu-id="7593b-1708">The <see cref="P:System.Linq.Expressions.Expression.Type" /> property of an element of <paramref name="parameters" /> is not assignable from the type of the corresponding parameter type of the delegate type represented by <paramref name="delegateType" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Lambda">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LambdaExpression Lambda (System.Linq.Expressions.Expression body, string name, bool tailCall, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LambdaExpression Lambda(class System.Linq.Expressions.Expression body, string name, bool tailCall, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda(System.Linq.Expressions.Expression,System.String,System.Boolean,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Lambda (body As Expression, name As String, tailCall As Boolean, parameters As IEnumerable(Of ParameterExpression)) As LambdaExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LambdaExpression ^ Lambda(System::Linq::Expressions::Expression ^ body, System::String ^ name, bool tailCall, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="static member Lambda : System.Linq.Expressions.Expression * string * bool * seq&lt;System.Linq.Expressions.ParameterExpression&gt; -&gt; System.Linq.Expressions.LambdaExpression" Usage="System.Linq.Expressions.Expression.Lambda (body, name, tailCall, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LambdaExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="name" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="tailCall" Type="System.Boolean" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="parameters" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="body"><span data-ttu-id="7593b-1709">要将 <see cref="T:System.Linq.Expressions.Expression" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-1709">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> property equal to.</span></span></param>
        <param name="name"><span data-ttu-id="7593b-1710">lambda 的名称。</span><span class="sxs-lookup"><span data-stu-id="7593b-1710">The name for the lambda.</span></span> <span data-ttu-id="7593b-1711">用于发出调试信息。</span><span class="sxs-lookup"><span data-stu-id="7593b-1711">Used for emitting debug information.</span></span></param>
        <param name="tailCall"><span data-ttu-id="7593b-1712">一个 <see cref="T:System.Boolean" />，指示在编译创建的表达式时是否将应用尾调用优化。</span><span class="sxs-lookup"><span data-stu-id="7593b-1712">A <see cref="T:System.Boolean" /> that indicates if tail call optimization will be applied when compiling the created expression.</span></span></param>
        <param name="parameters"><span data-ttu-id="7593b-1713">一个 <see cref="T:System.Collections.Generic.IEnumerable`1" />，包含用来填充 <see cref="T:System.Linq.Expressions.ParameterExpression" /> 集合的 <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> 对象。</span><span class="sxs-lookup"><span data-stu-id="7593b-1713">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.ParameterExpression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> collection.</span></span></param>
        <summary><span data-ttu-id="7593b-1714">首先从表达式主体构造一个委托类型、lambda 的名称、一个表示是否将应用尾调用优化的参数，以及一个参数表达式的可枚举集合，以便创建 <see cref="T:System.Linq.Expressions.LambdaExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-1714">Creates a <see cref="T:System.Linq.Expressions.LambdaExpression" /> by first constructing a delegate type from the expression body, the name for the lambda, a parameter that indicates whether tail call optimization will be applied, and an enumerable collection of parameter expressions.</span></span> <span data-ttu-id="7593b-1715">如果委托类型在编译时未知，则可以使用它。</span><span class="sxs-lookup"><span data-stu-id="7593b-1715">It can be used when the delegate type is not known at compile time.</span></span></summary>
        <returns><span data-ttu-id="7593b-1716">一个 <see cref="T:System.Linq.Expressions.LambdaExpression" />，其 <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> 属性等于 Lambda，并且其 <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> 和 <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> 属性均设置为指定的值。</span><span class="sxs-lookup"><span data-stu-id="7593b-1716">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> that has the <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> property equal to Lambda and the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> and <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Lambda">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LambdaExpression Lambda (Type delegateType, System.Linq.Expressions.Expression body, bool tailCall, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LambdaExpression Lambda(class System.Type delegateType, class System.Linq.Expressions.Expression body, bool tailCall, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda(System.Type,System.Linq.Expressions.Expression,System.Boolean,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Lambda (delegateType As Type, body As Expression, tailCall As Boolean, parameters As IEnumerable(Of ParameterExpression)) As LambdaExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LambdaExpression ^ Lambda(Type ^ delegateType, System::Linq::Expressions::Expression ^ body, bool tailCall, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="static member Lambda : Type * System.Linq.Expressions.Expression * bool * seq&lt;System.Linq.Expressions.ParameterExpression&gt; -&gt; System.Linq.Expressions.LambdaExpression" Usage="System.Linq.Expressions.Expression.Lambda (delegateType, body, tailCall, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LambdaExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegateType" Type="System.Type" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="tailCall" Type="System.Boolean" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="parameters" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="delegateType"><span data-ttu-id="7593b-1717">一个 <see cref="P:System.Linq.Expressions.Expression.Type" />，它表示 lambda 的委托签名。</span><span class="sxs-lookup"><span data-stu-id="7593b-1717">A <see cref="P:System.Linq.Expressions.Expression.Type" /> representing the delegate signature for the lambda.</span></span></param>
        <param name="body"><span data-ttu-id="7593b-1718">要将 <see cref="T:System.Linq.Expressions.Expression" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-1718">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> property equal to.</span></span></param>
        <param name="tailCall"><span data-ttu-id="7593b-1719">一个 <see cref="T:System.Boolean" />，指示在编译创建的表达式时是否将应用尾调用优化。</span><span class="sxs-lookup"><span data-stu-id="7593b-1719">A <see cref="T:System.Boolean" /> that indicates if tail call optimization will be applied when compiling the created expression.</span></span></param>
        <param name="parameters"><span data-ttu-id="7593b-1720">一个 <see cref="T:System.Collections.Generic.IEnumerable`1" />，包含用来填充 <see cref="T:System.Linq.Expressions.ParameterExpression" /> 集合的 <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> 对象。</span><span class="sxs-lookup"><span data-stu-id="7593b-1720">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.ParameterExpression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> collection.</span></span></param>
        <summary><span data-ttu-id="7593b-1721">使用表示是否将应用尾调用优化的参数和一个参数表达式的可枚举集合，创建一个在编译时委托类型已知的 <see cref="T:System.Linq.Expressions.LambdaExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-1721">Creates a <see cref="T:System.Linq.Expressions.LambdaExpression" /> where the delegate type is known at compile time, with a parameter that indicates whether tail call optimization will be applied, and an enumerable collection of parameter expressions.</span></span></summary>
        <returns><span data-ttu-id="7593b-1722">一个 <see cref="T:System.Linq.Expressions.LambdaExpression" />，其 <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> 属性等于 Lambda，并且其 <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> 和 <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> 属性均设置为指定的值。</span><span class="sxs-lookup"><span data-stu-id="7593b-1722">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> that has the <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> property equal to Lambda and the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> and <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Lambda">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LambdaExpression Lambda (Type delegateType, System.Linq.Expressions.Expression body, bool tailCall, params System.Linq.Expressions.ParameterExpression[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LambdaExpression Lambda(class System.Type delegateType, class System.Linq.Expressions.Expression body, bool tailCall, class System.Linq.Expressions.ParameterExpression[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda(System.Type,System.Linq.Expressions.Expression,System.Boolean,System.Linq.Expressions.ParameterExpression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Lambda (delegateType As Type, body As Expression, tailCall As Boolean, ParamArray parameters As ParameterExpression()) As LambdaExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LambdaExpression ^ Lambda(Type ^ delegateType, System::Linq::Expressions::Expression ^ body, bool tailCall, ... cli::array &lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="static member Lambda : Type * System.Linq.Expressions.Expression * bool * System.Linq.Expressions.ParameterExpression[] -&gt; System.Linq.Expressions.LambdaExpression" Usage="System.Linq.Expressions.Expression.Lambda (delegateType, body, tailCall, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LambdaExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegateType" Type="System.Type" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="tailCall" Type="System.Boolean" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="parameters" Type="System.Linq.Expressions.ParameterExpression[]" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="delegateType"><span data-ttu-id="7593b-1723">一个 <see cref="P:System.Linq.Expressions.Expression.Type" />，它表示 lambda 的委托签名。</span><span class="sxs-lookup"><span data-stu-id="7593b-1723">A <see cref="P:System.Linq.Expressions.Expression.Type" /> representing the delegate signature for the lambda.</span></span></param>
        <param name="body"><span data-ttu-id="7593b-1724">要将 <see cref="T:System.Linq.Expressions.Expression" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-1724">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> property equal to.</span></span></param>
        <param name="tailCall"><span data-ttu-id="7593b-1725">一个 <see cref="T:System.Boolean" />，指示在编译创建的表达式时是否将应用尾调用优化。</span><span class="sxs-lookup"><span data-stu-id="7593b-1725">A <see cref="T:System.Boolean" /> that indicates if tail call optimization will be applied when compiling the created expression.</span></span></param>
        <param name="parameters"><span data-ttu-id="7593b-1726">其中包含用于填充 <see cref="T:System.Linq.Expressions.ParameterExpression" /> 集合的 <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> 对象的数组。</span><span class="sxs-lookup"><span data-stu-id="7593b-1726">An array that contains <see cref="T:System.Linq.Expressions.ParameterExpression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> collection.</span></span></param>
        <summary><span data-ttu-id="7593b-1727">使用表示是否将应用尾调用优化的参数和一个参数表达式的数组，创建一个在编译时委托类型已知的 <see cref="T:System.Linq.Expressions.LambdaExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-1727">Creates a <see cref="T:System.Linq.Expressions.LambdaExpression" /> where the delegate type is known at compile time, with a parameter that indicates whether tail call optimization will be applied, and an array of parameter expressions.</span></span></summary>
        <returns><span data-ttu-id="7593b-1728">一个 <see cref="T:System.Linq.Expressions.LambdaExpression" />，其 <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> 属性等于 Lambda，并且其 <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> 和 <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> 属性均设置为指定的值。</span><span class="sxs-lookup"><span data-stu-id="7593b-1728">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> that has the <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> property equal to Lambda and the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> and <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Lambda">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LambdaExpression Lambda (Type delegateType, System.Linq.Expressions.Expression body, string name, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LambdaExpression Lambda(class System.Type delegateType, class System.Linq.Expressions.Expression body, string name, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda(System.Type,System.Linq.Expressions.Expression,System.String,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Lambda (delegateType As Type, body As Expression, name As String, parameters As IEnumerable(Of ParameterExpression)) As LambdaExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LambdaExpression ^ Lambda(Type ^ delegateType, System::Linq::Expressions::Expression ^ body, System::String ^ name, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="static member Lambda : Type * System.Linq.Expressions.Expression * string * seq&lt;System.Linq.Expressions.ParameterExpression&gt; -&gt; System.Linq.Expressions.LambdaExpression" Usage="System.Linq.Expressions.Expression.Lambda (delegateType, body, name, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LambdaExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegateType" Type="System.Type" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="name" Type="System.String" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="parameters" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="delegateType"><span data-ttu-id="7593b-1729">一个 <see cref="P:System.Linq.Expressions.Expression.Type" />，它表示 lambda 的委托签名。</span><span class="sxs-lookup"><span data-stu-id="7593b-1729">A <see cref="P:System.Linq.Expressions.Expression.Type" /> representing the delegate signature for the lambda.</span></span></param>
        <param name="body"><span data-ttu-id="7593b-1730">要将 <see cref="T:System.Linq.Expressions.Expression" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-1730">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> property equal to.</span></span></param>
        <param name="name"><span data-ttu-id="7593b-1731">lambda 的名称。</span><span class="sxs-lookup"><span data-stu-id="7593b-1731">The name for the lambda.</span></span> <span data-ttu-id="7593b-1732">用于发出调试信息。</span><span class="sxs-lookup"><span data-stu-id="7593b-1732">Used for emitting debug information.</span></span></param>
        <param name="parameters"><span data-ttu-id="7593b-1733">一个 <see cref="T:System.Collections.Generic.IEnumerable`1" />，包含用来填充 <see cref="T:System.Linq.Expressions.ParameterExpression" /> 集合的 <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> 对象。</span><span class="sxs-lookup"><span data-stu-id="7593b-1733">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.ParameterExpression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> collection.</span></span></param>
        <summary><span data-ttu-id="7593b-1734">使用 lambda 的名称和参数表达式的可枚举集合，创建一个在编译时委托类型已知的 <see cref="T:System.Linq.Expressions.LambdaExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-1734">Creates a <see cref="T:System.Linq.Expressions.LambdaExpression" /> where the delegate type is known at compile time, with the name for the lambda, and an enumerable collection of parameter expressions.</span></span></summary>
        <returns><span data-ttu-id="7593b-1735">一个 <see cref="T:System.Linq.Expressions.LambdaExpression" />，其 <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> 属性等于 Lambda，并且其 <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> 和 <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> 属性均设置为指定的值。</span><span class="sxs-lookup"><span data-stu-id="7593b-1735">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> that has the <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> property equal to Lambda and the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> and <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Lambda">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LambdaExpression Lambda (Type delegateType, System.Linq.Expressions.Expression body, string name, bool tailCall, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LambdaExpression Lambda(class System.Type delegateType, class System.Linq.Expressions.Expression body, string name, bool tailCall, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda(System.Type,System.Linq.Expressions.Expression,System.String,System.Boolean,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Lambda (delegateType As Type, body As Expression, name As String, tailCall As Boolean, parameters As IEnumerable(Of ParameterExpression)) As LambdaExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LambdaExpression ^ Lambda(Type ^ delegateType, System::Linq::Expressions::Expression ^ body, System::String ^ name, bool tailCall, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="static member Lambda : Type * System.Linq.Expressions.Expression * string * bool * seq&lt;System.Linq.Expressions.ParameterExpression&gt; -&gt; System.Linq.Expressions.LambdaExpression" Usage="System.Linq.Expressions.Expression.Lambda (delegateType, body, name, tailCall, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LambdaExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegateType" Type="System.Type" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="name" Type="System.String" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="tailCall" Type="System.Boolean" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="parameters" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" Index="4" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="delegateType"><span data-ttu-id="7593b-1736">一个 <see cref="P:System.Linq.Expressions.Expression.Type" />，它表示 lambda 的委托签名。</span><span class="sxs-lookup"><span data-stu-id="7593b-1736">A <see cref="P:System.Linq.Expressions.Expression.Type" /> representing the delegate signature for the lambda.</span></span></param>
        <param name="body"><span data-ttu-id="7593b-1737">要将 <see cref="T:System.Linq.Expressions.Expression" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-1737">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> property equal to.</span></span></param>
        <param name="name"><span data-ttu-id="7593b-1738">lambda 的名称。</span><span class="sxs-lookup"><span data-stu-id="7593b-1738">The name for the lambda.</span></span> <span data-ttu-id="7593b-1739">用于发出调试信息。</span><span class="sxs-lookup"><span data-stu-id="7593b-1739">Used for emitting debug information.</span></span></param>
        <param name="tailCall"><span data-ttu-id="7593b-1740">一个 <see cref="T:System.Boolean" />，指示在编译创建的表达式时是否将应用尾调用优化。</span><span class="sxs-lookup"><span data-stu-id="7593b-1740">A <see cref="T:System.Boolean" /> that indicates if tail call optimization will be applied when compiling the created expression.</span></span></param>
        <param name="parameters"><span data-ttu-id="7593b-1741">一个 <see cref="T:System.Collections.Generic.IEnumerable`1" />，包含用来填充 <see cref="T:System.Linq.Expressions.ParameterExpression" /> 集合的 <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> 对象。</span><span class="sxs-lookup"><span data-stu-id="7593b-1741">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.ParameterExpression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> collection.</span></span></param>
        <summary><span data-ttu-id="7593b-1742">使用 lambda 的名称、表示是否将应用尾调用优化的参数和一个参数表达式的可枚举集合，创建一个在编译时委托类型已知的 <see cref="T:System.Linq.Expressions.LambdaExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-1742">Creates a <see cref="T:System.Linq.Expressions.LambdaExpression" /> where the delegate type is known at compile time, with the name for the lambda, a parameter that indicates whether tail call optimization will be applied, and an enumerable collection of parameter expressions.</span></span></summary>
        <returns><span data-ttu-id="7593b-1743">一个 <see cref="T:System.Linq.Expressions.LambdaExpression" />，其 <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> 属性等于 Lambda，并且其 <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> 和 <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> 属性均设置为指定的值。</span><span class="sxs-lookup"><span data-stu-id="7593b-1743">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> that has the <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> property equal to Lambda and the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> and <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Lambda&lt;TDelegate&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.Expression&lt;TDelegate&gt; Lambda&lt;TDelegate&gt; (System.Linq.Expressions.Expression body, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.Expression`1&lt;!!TDelegate&gt; Lambda&lt;TDelegate&gt;(class System.Linq.Expressions.Expression body, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda``1(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Lambda(Of TDelegate) (body As Expression, parameters As IEnumerable(Of ParameterExpression)) As Expression(Of TDelegate)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TDelegate&gt;&#xA; static System::Linq::Expressions::Expression&lt;TDelegate&gt; ^ Lambda(System::Linq::Expressions::Expression ^ body, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="static member Lambda : System.Linq.Expressions.Expression * seq&lt;System.Linq.Expressions.ParameterExpression&gt; -&gt; System.Linq.Expressions.Expression&lt;'Delegate&gt;" Usage="System.Linq.Expressions.Expression.Lambda (body, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.Expression&lt;TDelegate&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TDelegate" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="parameters" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TDelegate"><span data-ttu-id="7593b-1744">一种委托类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-1744">A delegate type.</span></span></typeparam>
        <param name="body"><span data-ttu-id="7593b-1745">要将 <see cref="T:System.Linq.Expressions.Expression" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-1745">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> property equal to.</span></span></param>
        <param name="parameters"><span data-ttu-id="7593b-1746">一个 <see cref="T:System.Collections.Generic.IEnumerable`1" />，包含用来填充 <see cref="T:System.Linq.Expressions.ParameterExpression" /> 集合的 <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> 对象。</span><span class="sxs-lookup"><span data-stu-id="7593b-1746">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.ParameterExpression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> collection.</span></span></param>
        <summary><span data-ttu-id="7593b-1747">使用参数表达式的可枚举集合，创建一个在编译时委托类型已知的 <see cref="T:System.Linq.Expressions.Expression`1" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-1747">Creates an <see cref="T:System.Linq.Expressions.Expression`1" /> where the delegate type is known at compile time, with an enumerable collection of parameter expressions.</span></span></summary>
        <returns><span data-ttu-id="7593b-1748">一个 <see cref="T:System.Linq.Expressions.Expression`1" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 属性等于 <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" />，并且其 <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> 和 <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> 属性设置为指定值。</span><span class="sxs-lookup"><span data-stu-id="7593b-1748">An <see cref="T:System.Linq.Expressions.Expression`1" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> and the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> and <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7593b-1749">委托类型 `TDelegate` 的参数数目必须等于 `parameters`中的元素数目。</span><span class="sxs-lookup"><span data-stu-id="7593b-1749">The number of parameters for the delegate type `TDelegate` must equal the number of elements in `parameters`.</span></span>  
  
 <span data-ttu-id="7593b-1750">`parameters` 的元素必须是与 `body`中的参数表达式相等的引用。</span><span class="sxs-lookup"><span data-stu-id="7593b-1750">The elements of `parameters` must be reference equal to the parameter expressions in `body`.</span></span>  
  
 <span data-ttu-id="7593b-1751">生成的对象的 <xref:System.Linq.Expressions.Expression.Type%2A> 属性表示 `TDelegate`类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-1751">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting object represents the type `TDelegate`.</span></span> <span data-ttu-id="7593b-1752">如果 `null``parameters`，则生成的对象的 <xref:System.Linq.Expressions.LambdaExpression.Parameters%2A> 属性为空集合。</span><span class="sxs-lookup"><span data-stu-id="7593b-1752">If `parameters` is `null`, the <xref:System.Linq.Expressions.LambdaExpression.Parameters%2A> property of the resulting object is an empty collection.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="7593b-1753"><paramref name="body" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-1753"><paramref name="body" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="7593b-1754">- 或 -</span><span class="sxs-lookup"><span data-stu-id="7593b-1754">-or-</span></span> 
<span data-ttu-id="7593b-1755"><paramref name="parameters" /> 中的一个或多个元素为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-1755">One or more elements in <paramref name="parameters" /> are <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="7593b-1756"><paramref name="TDelegate" /> 不是委托类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-1756"><paramref name="TDelegate" /> is not a delegate type.</span></span>  
  
<span data-ttu-id="7593b-1757">- 或 -</span><span class="sxs-lookup"><span data-stu-id="7593b-1757">-or-</span></span> 
 <span data-ttu-id="7593b-1758"><paramref name="body" />.Type 表示一种不能赋给 <paramref name="TDelegate" /> 的返回类型的类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-1758"><paramref name="body" />.Type represents a type that is not assignable to the return type of <paramref name="TDelegate" />.</span></span>  
  
<span data-ttu-id="7593b-1759">- 或 -</span><span class="sxs-lookup"><span data-stu-id="7593b-1759">-or-</span></span> 
 <span data-ttu-id="7593b-1760"><paramref name="parameters" /> 没有包含与 <paramref name="TDelegate" /> 的参数列表相同数量的元素。</span><span class="sxs-lookup"><span data-stu-id="7593b-1760"><paramref name="parameters" /> does not contain the same number of elements as the list of parameters for <paramref name="TDelegate" />.</span></span>  
  
<span data-ttu-id="7593b-1761">- 或 -</span><span class="sxs-lookup"><span data-stu-id="7593b-1761">-or-</span></span> 
<span data-ttu-id="7593b-1762"><see cref="P:System.Linq.Expressions.Expression.Type" /> 的元素的 <paramref name="parameters" /> 属性不可从 <paramref name="TDelegate" /> 的相应参数类型的类型赋值。</span><span class="sxs-lookup"><span data-stu-id="7593b-1762">The <see cref="P:System.Linq.Expressions.Expression.Type" /> property of an element of <paramref name="parameters" /> is not assignable from the type of the corresponding parameter type of <paramref name="TDelegate" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Lambda&lt;TDelegate&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.Expression&lt;TDelegate&gt; Lambda&lt;TDelegate&gt; (System.Linq.Expressions.Expression body, params System.Linq.Expressions.ParameterExpression[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.Expression`1&lt;!!TDelegate&gt; Lambda&lt;TDelegate&gt;(class System.Linq.Expressions.Expression body, class System.Linq.Expressions.ParameterExpression[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda``1(System.Linq.Expressions.Expression,System.Linq.Expressions.ParameterExpression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Lambda(Of TDelegate) (body As Expression, ParamArray parameters As ParameterExpression()) As Expression(Of TDelegate)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TDelegate&gt;&#xA; static System::Linq::Expressions::Expression&lt;TDelegate&gt; ^ Lambda(System::Linq::Expressions::Expression ^ body, ... cli::array &lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="static member Lambda : System.Linq.Expressions.Expression * System.Linq.Expressions.ParameterExpression[] -&gt; System.Linq.Expressions.Expression&lt;'Delegate&gt;" Usage="System.Linq.Expressions.Expression.Lambda (body, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.Expression&lt;TDelegate&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TDelegate" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="parameters" Type="System.Linq.Expressions.ParameterExpression[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="TDelegate"><span data-ttu-id="7593b-1763">一种委托类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-1763">A delegate type.</span></span></typeparam>
        <param name="body"><span data-ttu-id="7593b-1764">要将 <see cref="T:System.Linq.Expressions.Expression" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-1764">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> property equal to.</span></span></param>
        <param name="parameters"><span data-ttu-id="7593b-1765">用于填充 <see cref="T:System.Linq.Expressions.ParameterExpression" /> 集合的 <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> 对象的数组。</span><span class="sxs-lookup"><span data-stu-id="7593b-1765">An array of <see cref="T:System.Linq.Expressions.ParameterExpression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> collection.</span></span></param>
        <summary><span data-ttu-id="7593b-1766">使用参数表达式的数组创建一个在编译时委托类型已知的 <see cref="T:System.Linq.Expressions.Expression`1" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-1766">Creates an <see cref="T:System.Linq.Expressions.Expression`1" /> where the delegate type is known at compile time, with an array of parameter expressions.</span></span></summary>
        <returns><span data-ttu-id="7593b-1767">一个 <see cref="T:System.Linq.Expressions.Expression`1" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 属性等于 <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" />，并且其 <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> 和 <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> 属性设置为指定值。</span><span class="sxs-lookup"><span data-stu-id="7593b-1767">An <see cref="T:System.Linq.Expressions.Expression`1" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> and the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> and <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7593b-1768">委托类型 `TDelegate` 的参数数目必须等于 `parameters`中的元素数目。</span><span class="sxs-lookup"><span data-stu-id="7593b-1768">The number of parameters for the delegate type `TDelegate` must equal the number of elements in `parameters`.</span></span>  
  
 <span data-ttu-id="7593b-1769">`parameters` 的元素必须是与`body`中的参数表达式相等的引用。</span><span class="sxs-lookup"><span data-stu-id="7593b-1769">The elements of `parameters` must be reference equal to the parameter expressions in`body`.</span></span>  
  
 <span data-ttu-id="7593b-1770">生成的对象的 <xref:System.Linq.Expressions.Expression.Type%2A> 属性表示 `TDelegate`类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-1770">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting object represents the type `TDelegate`.</span></span> <span data-ttu-id="7593b-1771">如果 `null``parameters`，则生成的对象的 <xref:System.Linq.Expressions.LambdaExpression.Parameters%2A> 属性为空集合。</span><span class="sxs-lookup"><span data-stu-id="7593b-1771">If `parameters` is `null`, the <xref:System.Linq.Expressions.LambdaExpression.Parameters%2A> property of the resulting object is an empty collection.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="7593b-1772"><paramref name="body" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-1772"><paramref name="body" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="7593b-1773">- 或 -</span><span class="sxs-lookup"><span data-stu-id="7593b-1773">-or-</span></span> 
<span data-ttu-id="7593b-1774"><paramref name="parameters" /> 中的一个或多个元素为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-1774">One or more elements in <paramref name="parameters" /> are <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="7593b-1775"><paramref name="TDelegate" /> 不是委托类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-1775"><paramref name="TDelegate" /> is not a delegate type.</span></span>  
  
<span data-ttu-id="7593b-1776">- 或 -</span><span class="sxs-lookup"><span data-stu-id="7593b-1776">-or-</span></span> 
 <span data-ttu-id="7593b-1777"><paramref name="body" />.Type 表示一种不能赋给 <paramref name="TDelegate" /> 的返回类型的类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-1777"><paramref name="body" />.Type represents a type that is not assignable to the return type of <paramref name="TDelegate" />.</span></span>  
  
<span data-ttu-id="7593b-1778">- 或 -</span><span class="sxs-lookup"><span data-stu-id="7593b-1778">-or-</span></span> 
 <span data-ttu-id="7593b-1779"><paramref name="parameters" /> 没有包含与 <paramref name="TDelegate" /> 的参数列表相同数量的元素。</span><span class="sxs-lookup"><span data-stu-id="7593b-1779"><paramref name="parameters" /> does not contain the same number of elements as the list of parameters for <paramref name="TDelegate" />.</span></span>  
  
<span data-ttu-id="7593b-1780">- 或 -</span><span class="sxs-lookup"><span data-stu-id="7593b-1780">-or-</span></span> 
<span data-ttu-id="7593b-1781"><see cref="P:System.Linq.Expressions.Expression.Type" /> 的元素的 <paramref name="parameters" /> 属性不可从 <paramref name="TDelegate" /> 的相应参数类型的类型赋值。</span><span class="sxs-lookup"><span data-stu-id="7593b-1781">The <see cref="P:System.Linq.Expressions.Expression.Type" /> property of an element of <paramref name="parameters" /> is not assignable from the type of the corresponding parameter type of <paramref name="TDelegate" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Lambda&lt;TDelegate&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.Expression&lt;TDelegate&gt; Lambda&lt;TDelegate&gt; (System.Linq.Expressions.Expression body, bool tailCall, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.Expression`1&lt;!!TDelegate&gt; Lambda&lt;TDelegate&gt;(class System.Linq.Expressions.Expression body, bool tailCall, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda``1(System.Linq.Expressions.Expression,System.Boolean,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Lambda(Of TDelegate) (body As Expression, tailCall As Boolean, parameters As IEnumerable(Of ParameterExpression)) As Expression(Of TDelegate)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TDelegate&gt;&#xA; static System::Linq::Expressions::Expression&lt;TDelegate&gt; ^ Lambda(System::Linq::Expressions::Expression ^ body, bool tailCall, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="static member Lambda : System.Linq.Expressions.Expression * bool * seq&lt;System.Linq.Expressions.ParameterExpression&gt; -&gt; System.Linq.Expressions.Expression&lt;'Delegate&gt;" Usage="System.Linq.Expressions.Expression.Lambda (body, tailCall, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.Expression&lt;TDelegate&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TDelegate" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="tailCall" Type="System.Boolean" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="parameters" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="TDelegate"><span data-ttu-id="7593b-1782">委托类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-1782">The delegate type.</span></span></typeparam>
        <param name="body"><span data-ttu-id="7593b-1783">要将 <see cref="T:System.Linq.Expressions.Expression" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-1783">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> property equal to.</span></span></param>
        <param name="tailCall"><span data-ttu-id="7593b-1784">一个 <see cref="T:System.Boolean" />，指示在编译创建的表达式时是否将应用尾调用优化。</span><span class="sxs-lookup"><span data-stu-id="7593b-1784">A <see cref="T:System.Boolean" /> that indicates if tail call optimization will be applied when compiling the created expression.</span></span></param>
        <param name="parameters"><span data-ttu-id="7593b-1785">一个 <see cref="T:System.Collections.Generic.IEnumerable`1" />，包含用来填充 <see cref="T:System.Linq.Expressions.ParameterExpression" /> 集合的 <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> 对象。</span><span class="sxs-lookup"><span data-stu-id="7593b-1785">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.ParameterExpression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> collection.</span></span></param>
        <summary><span data-ttu-id="7593b-1786">使用表示是否将应用尾调用优化的参数和一个参数表达式的可枚举集合，创建一个在编译时委托类型已知的 <see cref="T:System.Linq.Expressions.Expression`1" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-1786">Creates an <see cref="T:System.Linq.Expressions.Expression`1" /> where the delegate type is known at compile time, with a parameter that indicates whether tail call optimization will be applied, and an enumerable collection of parameter expressions.</span></span></summary>
        <returns><span data-ttu-id="7593b-1787">一个 <see cref="T:System.Linq.Expressions.Expression`1" />，其 <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> 属性等于 <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" />，并且其 <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> 和 <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> 属性设置为指定值。</span><span class="sxs-lookup"><span data-stu-id="7593b-1787">An <see cref="T:System.Linq.Expressions.Expression`1" /> that has the <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> and the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> and <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Lambda&lt;TDelegate&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.Expression&lt;TDelegate&gt; Lambda&lt;TDelegate&gt; (System.Linq.Expressions.Expression body, bool tailCall, params System.Linq.Expressions.ParameterExpression[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.Expression`1&lt;!!TDelegate&gt; Lambda&lt;TDelegate&gt;(class System.Linq.Expressions.Expression body, bool tailCall, class System.Linq.Expressions.ParameterExpression[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda``1(System.Linq.Expressions.Expression,System.Boolean,System.Linq.Expressions.ParameterExpression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Lambda(Of TDelegate) (body As Expression, tailCall As Boolean, ParamArray parameters As ParameterExpression()) As Expression(Of TDelegate)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TDelegate&gt;&#xA; static System::Linq::Expressions::Expression&lt;TDelegate&gt; ^ Lambda(System::Linq::Expressions::Expression ^ body, bool tailCall, ... cli::array &lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="static member Lambda : System.Linq.Expressions.Expression * bool * System.Linq.Expressions.ParameterExpression[] -&gt; System.Linq.Expressions.Expression&lt;'Delegate&gt;" Usage="System.Linq.Expressions.Expression.Lambda (body, tailCall, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.Expression&lt;TDelegate&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TDelegate" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="tailCall" Type="System.Boolean" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="parameters" Type="System.Linq.Expressions.ParameterExpression[]" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="TDelegate"><span data-ttu-id="7593b-1788">委托类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-1788">The delegate type.</span></span></typeparam>
        <param name="body"><span data-ttu-id="7593b-1789">要将 <see cref="T:System.Linq.Expressions.Expression" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-1789">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> property equal to.</span></span></param>
        <param name="tailCall"><span data-ttu-id="7593b-1790">一个 <see cref="T:System.Boolean" />，指示在编译创建的表达式时是否将应用尾调用优化。</span><span class="sxs-lookup"><span data-stu-id="7593b-1790">A <see cref="T:System.Boolean" /> that indicates if tail call optimization will be applied when compiling the created expression.</span></span></param>
        <param name="parameters"><span data-ttu-id="7593b-1791">其中包含用于填充 <see cref="T:System.Linq.Expressions.ParameterExpression" /> 集合的 <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> 对象的数组。</span><span class="sxs-lookup"><span data-stu-id="7593b-1791">An array that contains <see cref="T:System.Linq.Expressions.ParameterExpression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> collection.</span></span></param>
        <summary><span data-ttu-id="7593b-1792">使用表示是否将应用尾调用优化的参数和一个参数表达式的数组，创建一个在编译时委托类型已知的 <see cref="T:System.Linq.Expressions.Expression`1" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-1792">Creates an <see cref="T:System.Linq.Expressions.Expression`1" /> where the delegate type is known at compile time, with a parameter that indicates whether tail call optimization will be applied, and an array of parameter expressions.</span></span></summary>
        <returns><span data-ttu-id="7593b-1793">一个 <see cref="T:System.Linq.Expressions.Expression`1" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 属性等于 <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" />，并且其 <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> 和 <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> 属性设置为指定值。</span><span class="sxs-lookup"><span data-stu-id="7593b-1793">An <see cref="T:System.Linq.Expressions.Expression`1" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> and the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> and <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Lambda&lt;TDelegate&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.Expression&lt;TDelegate&gt; Lambda&lt;TDelegate&gt; (System.Linq.Expressions.Expression body, string name, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.Expression`1&lt;!!TDelegate&gt; Lambda&lt;TDelegate&gt;(class System.Linq.Expressions.Expression body, string name, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda``1(System.Linq.Expressions.Expression,System.String,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Lambda(Of TDelegate) (body As Expression, name As String, parameters As IEnumerable(Of ParameterExpression)) As Expression(Of TDelegate)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TDelegate&gt;&#xA; static System::Linq::Expressions::Expression&lt;TDelegate&gt; ^ Lambda(System::Linq::Expressions::Expression ^ body, System::String ^ name, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="static member Lambda : System.Linq.Expressions.Expression * string * seq&lt;System.Linq.Expressions.ParameterExpression&gt; -&gt; System.Linq.Expressions.Expression&lt;'Delegate&gt;" Usage="System.Linq.Expressions.Expression.Lambda (body, name, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.Expression&lt;TDelegate&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TDelegate" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="name" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="parameters" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="TDelegate"><span data-ttu-id="7593b-1794">委托类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-1794">The delegate type.</span></span></typeparam>
        <param name="body"><span data-ttu-id="7593b-1795">要将 <see cref="T:System.Linq.Expressions.Expression" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-1795">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> property equal to.</span></span></param>
        <param name="name"><span data-ttu-id="7593b-1796">lambda 的名称。</span><span class="sxs-lookup"><span data-stu-id="7593b-1796">The name of the lambda.</span></span> <span data-ttu-id="7593b-1797">用于生成调试信息。</span><span class="sxs-lookup"><span data-stu-id="7593b-1797">Used for generating debugging information.</span></span></param>
        <param name="parameters"><span data-ttu-id="7593b-1798">一个 <see cref="T:System.Collections.Generic.IEnumerable`1" />，包含用来填充 <see cref="T:System.Linq.Expressions.ParameterExpression" /> 集合的 <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> 对象。</span><span class="sxs-lookup"><span data-stu-id="7593b-1798">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.ParameterExpression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> collection.</span></span></param>
        <summary><span data-ttu-id="7593b-1799">使用 lambda 的名称和一个参数表达式的可枚举集合，创建一个在编译时委托类型已知的 <see cref="T:System.Linq.Expressions.Expression`1" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-1799">Creates an <see cref="T:System.Linq.Expressions.Expression`1" /> where the delegate type is known at compile time, with the name for the lambda, and an enumerable collection of parameter expressions.</span></span></summary>
        <returns><span data-ttu-id="7593b-1800">一个 <see cref="T:System.Linq.Expressions.Expression`1" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 属性等于 <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" />，并且其 <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> 和 <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> 属性设置为指定值。</span><span class="sxs-lookup"><span data-stu-id="7593b-1800">An <see cref="T:System.Linq.Expressions.Expression`1" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> and the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> and <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Lambda&lt;TDelegate&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.Expression&lt;TDelegate&gt; Lambda&lt;TDelegate&gt; (System.Linq.Expressions.Expression body, string name, bool tailCall, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.Expression`1&lt;!!TDelegate&gt; Lambda&lt;TDelegate&gt;(class System.Linq.Expressions.Expression body, string name, bool tailCall, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda``1(System.Linq.Expressions.Expression,System.String,System.Boolean,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Lambda(Of TDelegate) (body As Expression, name As String, tailCall As Boolean, parameters As IEnumerable(Of ParameterExpression)) As Expression(Of TDelegate)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TDelegate&gt;&#xA; static System::Linq::Expressions::Expression&lt;TDelegate&gt; ^ Lambda(System::Linq::Expressions::Expression ^ body, System::String ^ name, bool tailCall, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="static member Lambda : System.Linq.Expressions.Expression * string * bool * seq&lt;System.Linq.Expressions.ParameterExpression&gt; -&gt; System.Linq.Expressions.Expression&lt;'Delegate&gt;" Usage="System.Linq.Expressions.Expression.Lambda (body, name, tailCall, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.Expression&lt;TDelegate&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TDelegate" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="name" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="tailCall" Type="System.Boolean" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="parameters" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="TDelegate"><span data-ttu-id="7593b-1801">委托类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-1801">The delegate type.</span></span></typeparam>
        <param name="body"><span data-ttu-id="7593b-1802">要将 <see cref="T:System.Linq.Expressions.Expression" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-1802">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> property equal to.</span></span></param>
        <param name="name"><span data-ttu-id="7593b-1803">lambda 的名称。</span><span class="sxs-lookup"><span data-stu-id="7593b-1803">The name of the lambda.</span></span> <span data-ttu-id="7593b-1804">用于生成调试信息。</span><span class="sxs-lookup"><span data-stu-id="7593b-1804">Used for generating debugging info.</span></span></param>
        <param name="tailCall"><span data-ttu-id="7593b-1805">一个 <see cref="T:System.Boolean" />，指示在编译创建的表达式时是否将应用尾调用优化。</span><span class="sxs-lookup"><span data-stu-id="7593b-1805">A <see cref="T:System.Boolean" /> that indicates if tail call optimization will be applied when compiling the created expression.</span></span></param>
        <param name="parameters"><span data-ttu-id="7593b-1806">一个 <see cref="T:System.Collections.Generic.IEnumerable`1" />，包含用来填充 <see cref="T:System.Linq.Expressions.ParameterExpression" /> 集合的 <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> 对象。</span><span class="sxs-lookup"><span data-stu-id="7593b-1806">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.ParameterExpression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> collection.</span></span></param>
        <summary><span data-ttu-id="7593b-1807">使用 lambda 的名称、表示是否将应用尾调用优化的参数以及一个参数表达式的可枚举集合，创建一个在编译时委托类型已知的 <see cref="T:System.Linq.Expressions.Expression`1" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-1807">Creates an <see cref="T:System.Linq.Expressions.Expression`1" /> where the delegate type is known at compile time, with the name for the lambda, a parameter that indicates whether tail call optimization will be applied, and an enumerable collection of parameter expressions.</span></span></summary>
        <returns><span data-ttu-id="7593b-1808">一个 <see cref="T:System.Linq.Expressions.Expression`1" />，其 <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> 属性等于 <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" />，并且其 <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> 和 <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> 属性设置为指定值。</span><span class="sxs-lookup"><span data-stu-id="7593b-1808">An <see cref="T:System.Linq.Expressions.Expression`1" /> that has the <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> and the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> and <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="LeftShift">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="7593b-1809">创建一个表示按位左移运算的 <see cref="T:System.Linq.Expressions.BinaryExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-1809">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise left-shift operation.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="LeftShift">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression LeftShift (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression LeftShift(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.LeftShift(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LeftShift (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ LeftShift(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member LeftShift : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.LeftShift (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="7593b-1810">要将 <see cref="T:System.Linq.Expressions.Expression" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-1810">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="7593b-1811">要将 <see cref="T:System.Linq.Expressions.Expression" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-1811">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="7593b-1812">创建一个表示按位左移运算的 <see cref="T:System.Linq.Expressions.BinaryExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-1812">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise left-shift operation.</span></span></summary>
        <returns><span data-ttu-id="7593b-1813">一个 <see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 属性等于 <see cref="F:System.Linq.Expressions.ExpressionType.LeftShift" />，并且其 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 属性设置为指定值。</span><span class="sxs-lookup"><span data-stu-id="7593b-1813">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.LeftShift" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7593b-1814">生成的 <xref:System.Linq.Expressions.BinaryExpression> 具有设置为实现方法的 <xref:System.Linq.Expressions.BinaryExpression.Method%2A> 属性。</span><span class="sxs-lookup"><span data-stu-id="7593b-1814">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="7593b-1815"><xref:System.Linq.Expressions.Expression.Type%2A> 属性设置为节点的类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-1815">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="7593b-1816">如果节点已提升，则 <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> 和 <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> 属性均 `true`。</span><span class="sxs-lookup"><span data-stu-id="7593b-1816">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="7593b-1817">否则，它们 `false`。</span><span class="sxs-lookup"><span data-stu-id="7593b-1817">Otherwise, they are `false`.</span></span> <span data-ttu-id="7593b-1818"><xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> 属性为 `null`。</span><span class="sxs-lookup"><span data-stu-id="7593b-1818">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="7593b-1819">以下信息描述了实现方法、节点类型以及节点是否已提升。</span><span class="sxs-lookup"><span data-stu-id="7593b-1819">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="7593b-1820">实现方法</span><span class="sxs-lookup"><span data-stu-id="7593b-1820">Implementing Method</span></span>  
 <span data-ttu-id="7593b-1821">以下规则确定为操作选定的实现方法：</span><span class="sxs-lookup"><span data-stu-id="7593b-1821">The following rules determine the selected implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="7593b-1822">如果 `left` 或 `right` 的 <xref:System.Linq.Expressions.Expression.Type%2A> 属性表示重载左移位运算符的用户定义类型，则表示该方法的 <xref:System.Reflection.MethodInfo> 是实现方法。</span><span class="sxs-lookup"><span data-stu-id="7593b-1822">If the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the left-shift operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="7593b-1823">否则，如果 `left`。类型为整型类型（<xref:System.Byte>、<xref:System.SByte>、<xref:System.Int16>、<xref:System.UInt16>、<xref:System.Int32>、<xref:System.UInt32>、<xref:System.Int64>、<xref:System.UInt64>或对应的可以为 null 的类型）和 `right`。类型为 <xref:System.Int32>，则实现方法为 `null`。</span><span class="sxs-lookup"><span data-stu-id="7593b-1823">Otherwise, if `left`.Type is an integral type (one of <xref:System.Byte>, <xref:System.SByte>, <xref:System.Int16>, <xref:System.UInt16>, <xref:System.Int32>, <xref:System.UInt32>, <xref:System.Int64>, <xref:System.UInt64>, or the corresponding nullable types) and `right`.Type is <xref:System.Int32>, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="7593b-1824">节点类型和提升和非提升</span><span class="sxs-lookup"><span data-stu-id="7593b-1824">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="7593b-1825">如果不 `null`实现方法：</span><span class="sxs-lookup"><span data-stu-id="7593b-1825">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="7593b-1826">如果 `left`。键入并 `right`。类型可分配给实现方法的相应参数类型，不提升节点。</span><span class="sxs-lookup"><span data-stu-id="7593b-1826">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="7593b-1827">节点的类型是实现方法的返回类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-1827">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="7593b-1828">如果满足以下两个条件，则会提升节点，并且该节点的类型为与实现方法的返回类型对应的可以为 null 的类型：</span><span class="sxs-lookup"><span data-stu-id="7593b-1828">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="7593b-1829">`left`。键入并 `right`。类型既是值类型，其中至少有一个可为 null，并且相应的不可为 null 的类型等于实现方法的相应参数类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-1829">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="7593b-1830">实现方法的返回类型是不可为 null 的值类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-1830">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="7593b-1831">如果实现方法为 `null`：</span><span class="sxs-lookup"><span data-stu-id="7593b-1831">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="7593b-1832">如果 `left`。键入并 `right`。类型不可以为 null，则不提升节点。</span><span class="sxs-lookup"><span data-stu-id="7593b-1832">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="7593b-1833">节点的类型是预定义的左移运算符的结果类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-1833">The type of the node is the result type of the predefined left-shift operator.</span></span>  
  
-   <span data-ttu-id="7593b-1834">如果 `left`。键入并 `right`。类型均可为 null，则提升节点。</span><span class="sxs-lookup"><span data-stu-id="7593b-1834">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="7593b-1835">节点的类型是与预定义左移位运算符的结果类型相对应的可为 null 的类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-1835">The type of the node is the nullable type that corresponds to the result type of the predefined left-shift operator.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="7593b-1836"><paramref name="left" /> 或 <paramref name="right" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-1836"><paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="7593b-1837">没有为 <paramref name="left" />.Type 和 <paramref name="right" />.Type 定义左移位运算符。</span><span class="sxs-lookup"><span data-stu-id="7593b-1837">The left-shift operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="LeftShift">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression LeftShift (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression LeftShift(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.LeftShift(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LeftShift (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ LeftShift(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member LeftShift : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.LeftShift (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="7593b-1838">要将 <see cref="T:System.Linq.Expressions.Expression" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-1838">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="7593b-1839">要将 <see cref="T:System.Linq.Expressions.Expression" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-1839">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <param name="method"><span data-ttu-id="7593b-1840">要将 <see cref="T:System.Reflection.MethodInfo" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-1840">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="7593b-1841">创建一个表示按位左移运算的 <see cref="T:System.Linq.Expressions.BinaryExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-1841">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise left-shift operation.</span></span></summary>
        <returns><span data-ttu-id="7593b-1842">一个 <see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 属性等于 <see cref="F:System.Linq.Expressions.ExpressionType.LeftShift" />，并且其 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />、<see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> 属性设置为指定值。</span><span class="sxs-lookup"><span data-stu-id="7593b-1842">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.LeftShift" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7593b-1843">生成的 <xref:System.Linq.Expressions.BinaryExpression> 具有设置为实现方法的 <xref:System.Linq.Expressions.BinaryExpression.Method%2A> 属性。</span><span class="sxs-lookup"><span data-stu-id="7593b-1843">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="7593b-1844"><xref:System.Linq.Expressions.Expression.Type%2A> 属性设置为节点的类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-1844">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="7593b-1845">如果节点已提升，则 <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> 和 <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> 属性均 `true`。</span><span class="sxs-lookup"><span data-stu-id="7593b-1845">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="7593b-1846">否则，它们 `false`。</span><span class="sxs-lookup"><span data-stu-id="7593b-1846">Otherwise, they are `false`.</span></span> <span data-ttu-id="7593b-1847"><xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> 属性为 `null`。</span><span class="sxs-lookup"><span data-stu-id="7593b-1847">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="7593b-1848">以下信息描述了实现方法、节点类型以及节点是否已提升。</span><span class="sxs-lookup"><span data-stu-id="7593b-1848">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="7593b-1849">实现方法</span><span class="sxs-lookup"><span data-stu-id="7593b-1849">Implementing Method</span></span>  
 <span data-ttu-id="7593b-1850">以下规则确定为操作选定的实现方法：</span><span class="sxs-lookup"><span data-stu-id="7593b-1850">The following rules determine the selected implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="7593b-1851">如果 `method` 未 `null` 并且它表示采用两个自变量的非 void、`static``Shared` （Visual Basic）方法，则它是节点的实现方法。</span><span class="sxs-lookup"><span data-stu-id="7593b-1851">If `method` is not `null` and it represents a non-void, `static` (`Shared` in Visual Basic) method that takes two arguments, it is the implementing method for the node.</span></span>  
  
-   <span data-ttu-id="7593b-1852">否则，如果 `left` 或 `right` 的 <xref:System.Linq.Expressions.Expression.Type%2A> 属性表示重载左移位运算符的用户定义类型，则表示该方法的 <xref:System.Reflection.MethodInfo> 是实现方法。</span><span class="sxs-lookup"><span data-stu-id="7593b-1852">Otherwise, if the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the left-shift operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="7593b-1853">否则，如果 `left`。类型为整型类型（<xref:System.Byte>、<xref:System.SByte>、<xref:System.Int16>、<xref:System.UInt16>、<xref:System.Int32>、<xref:System.UInt32>、<xref:System.Int64>、<xref:System.UInt64>或对应的可以为 null 的类型）和 `right`。类型为 <xref:System.Int32>，则实现方法为 `null`。</span><span class="sxs-lookup"><span data-stu-id="7593b-1853">Otherwise, if `left`.Type is an integral type (one of <xref:System.Byte>, <xref:System.SByte>, <xref:System.Int16>, <xref:System.UInt16>, <xref:System.Int32>, <xref:System.UInt32>, <xref:System.Int64>, <xref:System.UInt64>, or the corresponding nullable types) and `right`.Type is <xref:System.Int32>, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="7593b-1854">节点类型和提升和非提升</span><span class="sxs-lookup"><span data-stu-id="7593b-1854">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="7593b-1855">如果不 `null`实现方法：</span><span class="sxs-lookup"><span data-stu-id="7593b-1855">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="7593b-1856">如果 `left`。键入并 `right`。类型可分配给实现方法的相应参数类型，不提升节点。</span><span class="sxs-lookup"><span data-stu-id="7593b-1856">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="7593b-1857">节点的类型是实现方法的返回类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-1857">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="7593b-1858">如果满足以下两个条件，则会提升节点，并且该节点的类型为与实现方法的返回类型对应的可以为 null 的类型：</span><span class="sxs-lookup"><span data-stu-id="7593b-1858">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="7593b-1859">`left`。键入并 `right`。类型既是值类型，其中至少有一个可为 null，并且相应的不可为 null 的类型等于实现方法的相应参数类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-1859">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="7593b-1860">实现方法的返回类型是不可为 null 的值类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-1860">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="7593b-1861">如果实现方法为 `null`：</span><span class="sxs-lookup"><span data-stu-id="7593b-1861">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="7593b-1862">如果 `left`。键入并 `right`。类型不可以为 null，则不提升节点。</span><span class="sxs-lookup"><span data-stu-id="7593b-1862">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="7593b-1863">节点的类型是预定义的左移运算符的结果类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-1863">The type of the node is the result type of the predefined left-shift operator.</span></span>  
  
-   <span data-ttu-id="7593b-1864">如果 `left`。键入并 `right`。类型均可为 null，则提升节点。</span><span class="sxs-lookup"><span data-stu-id="7593b-1864">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="7593b-1865">节点的类型是与预定义左移位运算符的结果类型相对应的可为 null 的类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-1865">The type of the node is the nullable type that corresponds to the result type of the predefined left-shift operator.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="7593b-1866"><paramref name="left" /> 或 <paramref name="right" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-1866"><paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="7593b-1867"><paramref name="method" /> 不是 <see langword="null" />，它所表示的方法返回 <see langword="void" />，而不是 <see langword="static" />（Visual Basic 中为 <see langword="Shared" />），或者并非采用两个参数。</span><span class="sxs-lookup"><span data-stu-id="7593b-1867"><paramref name="method" /> is not <see langword="null" /> and the method it represents returns <see langword="void" />, is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic), or does not take exactly two arguments.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="7593b-1868"><paramref name="method" /> 为 <see langword="null" />，并且没有为 <paramref name="left" />.Type 和 <paramref name="right" />.Type 定义左移位运算符。</span><span class="sxs-lookup"><span data-stu-id="7593b-1868"><paramref name="method" /> is <see langword="null" /> and the left-shift operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="LeftShiftAssign">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="7593b-1869">创建一个表示按位左移赋值运算的 <see cref="T:System.Linq.Expressions.BinaryExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-1869">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise left-shift assignment operation.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="LeftShiftAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression LeftShiftAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression LeftShiftAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.LeftShiftAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LeftShiftAssign (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ LeftShiftAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member LeftShiftAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.LeftShiftAssign (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="7593b-1870">要将 <see cref="T:System.Linq.Expressions.Expression" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-1870">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="7593b-1871">要将 <see cref="T:System.Linq.Expressions.Expression" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-1871">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="7593b-1872">创建一个表示按位左移赋值运算的 <see cref="T:System.Linq.Expressions.BinaryExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-1872">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise left-shift assignment operation.</span></span></summary>
        <returns><span data-ttu-id="7593b-1873">一个 <see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 属性等于 <see cref="F:System.Linq.Expressions.ExpressionType.LeftShiftAssign" />，并且其 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 属性设置为指定值。</span><span class="sxs-lookup"><span data-stu-id="7593b-1873">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.LeftShiftAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LeftShiftAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression LeftShiftAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression LeftShiftAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.LeftShiftAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LeftShiftAssign (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ LeftShiftAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member LeftShiftAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.LeftShiftAssign (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="7593b-1874">要将 <see cref="T:System.Linq.Expressions.Expression" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-1874">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="7593b-1875">要将 <see cref="T:System.Linq.Expressions.Expression" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-1875">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <param name="method"><span data-ttu-id="7593b-1876">要将 <see cref="T:System.Reflection.MethodInfo" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-1876">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="7593b-1877">创建一个表示按位左移赋值运算的 <see cref="T:System.Linq.Expressions.BinaryExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-1877">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise left-shift assignment operation.</span></span></summary>
        <returns><span data-ttu-id="7593b-1878">一个 <see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 属性等于 <see cref="F:System.Linq.Expressions.ExpressionType.LeftShiftAssign" />，并且其 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />、<see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> 属性设置为指定值。</span><span class="sxs-lookup"><span data-stu-id="7593b-1878">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.LeftShiftAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LeftShiftAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression LeftShiftAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method, System.Linq.Expressions.LambdaExpression conversion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression LeftShiftAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method, class System.Linq.Expressions.LambdaExpression conversion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.LeftShiftAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LeftShiftAssign (left As Expression, right As Expression, method As MethodInfo, conversion As LambdaExpression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ LeftShiftAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method, System::Linq::Expressions::LambdaExpression ^ conversion);" />
      <MemberSignature Language="F#" Value="static member LeftShiftAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo * System.Linq.Expressions.LambdaExpression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.LeftShiftAssign (left, right, method, conversion)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="conversion" Type="System.Linq.Expressions.LambdaExpression" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="7593b-1879">要将 <see cref="T:System.Linq.Expressions.Expression" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-1879">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="7593b-1880">要将 <see cref="T:System.Linq.Expressions.Expression" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-1880">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <param name="method"><span data-ttu-id="7593b-1881">要将 <see cref="T:System.Reflection.MethodInfo" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-1881">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span></span></param>
        <param name="conversion"><span data-ttu-id="7593b-1882">要将 <see cref="T:System.Linq.Expressions.LambdaExpression" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-1882">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="7593b-1883">创建一个表示按位左移赋值运算的 <see cref="T:System.Linq.Expressions.BinaryExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-1883">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise left-shift assignment operation.</span></span></summary>
        <returns><span data-ttu-id="7593b-1884">一个 <see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 属性等于 <see cref="F:System.Linq.Expressions.ExpressionType.LeftShiftAssign" />，并且其 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />、<see cref="P:System.Linq.Expressions.BinaryExpression.Right" />、<see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> 属性设置为指定值。</span><span class="sxs-lookup"><span data-stu-id="7593b-1884">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.LeftShiftAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="LessThan">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="7593b-1885">创建一个表示“小于”数值比较的 <see cref="T:System.Linq.Expressions.BinaryExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-1885">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a "less than" numeric comparison.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="LessThan">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression LessThan (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression LessThan(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.LessThan(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LessThan (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ LessThan(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member LessThan : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.LessThan (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="7593b-1886">要将 <see cref="T:System.Linq.Expressions.Expression" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-1886">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="7593b-1887">要将 <see cref="T:System.Linq.Expressions.Expression" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-1887">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="7593b-1888">创建一个表示“小于”数值比较的 <see cref="T:System.Linq.Expressions.BinaryExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-1888">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a "less than" numeric comparison.</span></span></summary>
        <returns><span data-ttu-id="7593b-1889">一个 <see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 属性等于 <see cref="F:System.Linq.Expressions.ExpressionType.LessThan" />，并且其 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 属性设置为指定值。</span><span class="sxs-lookup"><span data-stu-id="7593b-1889">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.LessThan" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7593b-1890">生成的 <xref:System.Linq.Expressions.BinaryExpression> 具有设置为实现方法的 <xref:System.Linq.Expressions.BinaryExpression.Method%2A> 属性。</span><span class="sxs-lookup"><span data-stu-id="7593b-1890">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="7593b-1891"><xref:System.Linq.Expressions.Expression.Type%2A> 属性设置为节点的类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-1891">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="7593b-1892">如果节点已提升，则 `true`<xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> 属性。</span><span class="sxs-lookup"><span data-stu-id="7593b-1892">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> property is `true`.</span></span> <span data-ttu-id="7593b-1893">否则，它是 `false`。</span><span class="sxs-lookup"><span data-stu-id="7593b-1893">Otherwise, it is `false`.</span></span> <span data-ttu-id="7593b-1894"><xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> 属性始终为 `false`。</span><span class="sxs-lookup"><span data-stu-id="7593b-1894">The <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> property is always `false`.</span></span> <span data-ttu-id="7593b-1895"><xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> 属性为 `null`。</span><span class="sxs-lookup"><span data-stu-id="7593b-1895">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="7593b-1896">以下信息描述了实现方法、节点类型以及节点是否已提升。</span><span class="sxs-lookup"><span data-stu-id="7593b-1896">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="7593b-1897">实现方法</span><span class="sxs-lookup"><span data-stu-id="7593b-1897">Implementing Method</span></span>  
 <span data-ttu-id="7593b-1898">根据以下规则选择操作的实现方法：</span><span class="sxs-lookup"><span data-stu-id="7593b-1898">The implementing method for the operation is chosen based on the following rules:</span></span>  
  
-   <span data-ttu-id="7593b-1899">如果 `left` 或 `right` 的 <xref:System.Linq.Expressions.Expression.Type%2A> 属性表示重载 "小于" 运算符的用户定义类型，则表示该方法的 <xref:System.Reflection.MethodInfo> 是实现方法。</span><span class="sxs-lookup"><span data-stu-id="7593b-1899">If the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the "less than" operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="7593b-1900">否则，如果 `left`。键入并 `right`。类型为数值类型，则实现方法为 `null`。</span><span class="sxs-lookup"><span data-stu-id="7593b-1900">Otherwise, if `left`.Type and `right`.Type are numeric types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="7593b-1901">节点类型和提升和非提升</span><span class="sxs-lookup"><span data-stu-id="7593b-1901">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="7593b-1902">如果不 `null`实现方法：</span><span class="sxs-lookup"><span data-stu-id="7593b-1902">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="7593b-1903">如果 `left`。键入并 `right`。类型可分配给实现方法的相应参数类型，不提升节点。</span><span class="sxs-lookup"><span data-stu-id="7593b-1903">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="7593b-1904">节点的类型是实现方法的返回类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-1904">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="7593b-1905">如果满足以下两个条件，则会提升节点并 <xref:System.Boolean>节点的类型：</span><span class="sxs-lookup"><span data-stu-id="7593b-1905">If the following two conditions are satisfied, the node is lifted and the type of the node is <xref:System.Boolean>:</span></span>  
  
    -   <span data-ttu-id="7593b-1906">`left`。键入并 `right`。类型既是值类型，其中至少有一个可为 null，并且相应的不可为 null 的类型等于实现方法的相应参数类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-1906">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="7593b-1907">实现方法的返回类型为 <xref:System.Boolean>。</span><span class="sxs-lookup"><span data-stu-id="7593b-1907">The return type of the implementing method is <xref:System.Boolean>.</span></span>  
  
 <span data-ttu-id="7593b-1908">如果实现方法为 `null`：</span><span class="sxs-lookup"><span data-stu-id="7593b-1908">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="7593b-1909">如果 `left`。键入并 `right`。类型不可以为 null，则不提升节点。</span><span class="sxs-lookup"><span data-stu-id="7593b-1909">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="7593b-1910">节点的类型为 <xref:System.Boolean>。</span><span class="sxs-lookup"><span data-stu-id="7593b-1910">The type of the node is <xref:System.Boolean>.</span></span>  
  
-   <span data-ttu-id="7593b-1911">如果 `left`。键入并 `right`。类型均可为 null，则提升节点。</span><span class="sxs-lookup"><span data-stu-id="7593b-1911">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="7593b-1912">节点的类型为 <xref:System.Boolean>。</span><span class="sxs-lookup"><span data-stu-id="7593b-1912">The type of the node is <xref:System.Boolean>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="7593b-1913">下面的代码示例演示如何创建对两个整数进行比较的表达式。</span><span class="sxs-lookup"><span data-stu-id="7593b-1913">The following code example shows how to create an expression that compares two integers.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#25](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#25)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#25](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#25)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="7593b-1914"><paramref name="left" /> 或 <paramref name="right" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-1914"><paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="7593b-1915">没有为 <paramref name="left" />.Type 和 <paramref name="right" />.Type 定义"小于"运算符。</span><span class="sxs-lookup"><span data-stu-id="7593b-1915">The "less than" operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="LessThan">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression LessThan (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, bool liftToNull, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression LessThan(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, bool liftToNull, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.LessThan(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LessThan (left As Expression, right As Expression, liftToNull As Boolean, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ LessThan(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, bool liftToNull, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member LessThan : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * bool * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.LessThan (left, right, liftToNull, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="liftToNull" Type="System.Boolean" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="7593b-1916">要将 <see cref="T:System.Linq.Expressions.Expression" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-1916">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="7593b-1917">要将 <see cref="T:System.Linq.Expressions.Expression" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-1917">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <param name="liftToNull"><span data-ttu-id="7593b-1918">若要将 <see langword="true" /> 设置为 <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" />，则为 <see langword="true" />；若要将 <see langword="false" /> 设置为 <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" />，则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-1918"><see langword="true" /> to set <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> to <see langword="true" />; <see langword="false" /> to set <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> to <see langword="false" />.</span></span></param>
        <param name="method"><span data-ttu-id="7593b-1919">要将 <see cref="T:System.Reflection.MethodInfo" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-1919">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="7593b-1920">创建一个表示“小于”数值比较的 <see cref="T:System.Linq.Expressions.BinaryExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-1920">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a "less than" numeric comparison.</span></span></summary>
        <returns><span data-ttu-id="7593b-1921">一个 <see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 属性等于 <see cref="F:System.Linq.Expressions.ExpressionType.LessThan" />，并且其 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />、<see cref="P:System.Linq.Expressions.BinaryExpression.Right" />、<see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> 属性设置为指定值。</span><span class="sxs-lookup"><span data-stu-id="7593b-1921">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.LessThan" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7593b-1922">生成的 <xref:System.Linq.Expressions.BinaryExpression> 具有设置为实现方法的 <xref:System.Linq.Expressions.BinaryExpression.Method%2A> 属性。</span><span class="sxs-lookup"><span data-stu-id="7593b-1922">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="7593b-1923"><xref:System.Linq.Expressions.Expression.Type%2A> 属性设置为节点的类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-1923">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="7593b-1924">如果节点已提升，则 `true` <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> 属性，<xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> 属性等于 `liftToNull`。</span><span class="sxs-lookup"><span data-stu-id="7593b-1924">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> property is `true` and the <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> property is equal to `liftToNull`.</span></span> <span data-ttu-id="7593b-1925">否则，它们都 `false`。</span><span class="sxs-lookup"><span data-stu-id="7593b-1925">Otherwise, they are both `false`.</span></span> <span data-ttu-id="7593b-1926"><xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> 属性为 `null`。</span><span class="sxs-lookup"><span data-stu-id="7593b-1926">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="7593b-1927">以下信息描述了实现方法、节点类型以及节点是否已提升。</span><span class="sxs-lookup"><span data-stu-id="7593b-1927">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="7593b-1928">实现方法</span><span class="sxs-lookup"><span data-stu-id="7593b-1928">Implementing Method</span></span>  
 <span data-ttu-id="7593b-1929">以下规则确定操作的实现方法：</span><span class="sxs-lookup"><span data-stu-id="7593b-1929">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="7593b-1930">如果 `method` 未 `null` 并且它表示采用两个自变量的非 void、`static``Shared` （Visual Basic）方法，则它是实现方法。</span><span class="sxs-lookup"><span data-stu-id="7593b-1930">If `method` is not `null` and it represents a non-void, `static` (`Shared` in Visual Basic) method that takes two arguments, it is the implementing method.</span></span>  
  
-   <span data-ttu-id="7593b-1931">否则，如果 `left` 或 `right` 的 <xref:System.Linq.Expressions.Expression.Type%2A> 属性表示重载 "小于" 运算符的用户定义类型，则表示该方法的 <xref:System.Reflection.MethodInfo> 是实现方法。</span><span class="sxs-lookup"><span data-stu-id="7593b-1931">Otherwise, if the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the "less than" operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="7593b-1932">否则，如果 `left`。键入并 `right`。类型为数值类型，则实现方法为 `null`。</span><span class="sxs-lookup"><span data-stu-id="7593b-1932">Otherwise, if `left`.Type and `right`.Type are numeric types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="7593b-1933">节点类型和提升和非提升</span><span class="sxs-lookup"><span data-stu-id="7593b-1933">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="7593b-1934">如果不 `null`实现方法：</span><span class="sxs-lookup"><span data-stu-id="7593b-1934">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="7593b-1935">如果 `left`。键入并 `right`。类型可分配给实现方法的相应参数类型，不提升节点。</span><span class="sxs-lookup"><span data-stu-id="7593b-1935">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="7593b-1936">节点的类型是实现方法的返回类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-1936">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="7593b-1937">如果满足以下两个条件，则提升节点;此外，如果 `liftToNull` `false`，则节点类型可以为 null <xref:System.Boolean> 如果 `liftToNull` `true` 或 <xref:System.Boolean>：</span><span class="sxs-lookup"><span data-stu-id="7593b-1937">If the following two conditions are satisfied, the node is lifted; also, the type of the node is nullable <xref:System.Boolean> if `liftToNull` is `true` or <xref:System.Boolean> if `liftToNull` is `false`:</span></span>  
  
    -   <span data-ttu-id="7593b-1938">`left`。键入并 `right`。类型既是值类型，其中至少有一个可为 null，并且相应的不可为 null 的类型等于实现方法的相应参数类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-1938">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="7593b-1939">实现方法的返回类型为 <xref:System.Boolean>。</span><span class="sxs-lookup"><span data-stu-id="7593b-1939">The return type of the implementing method is <xref:System.Boolean>.</span></span>  
  
 <span data-ttu-id="7593b-1940">如果实现方法为 `null`：</span><span class="sxs-lookup"><span data-stu-id="7593b-1940">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="7593b-1941">如果 `left`。键入并 `right`。类型不可以为 null，则不提升节点。</span><span class="sxs-lookup"><span data-stu-id="7593b-1941">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="7593b-1942">节点的类型为 <xref:System.Boolean>。</span><span class="sxs-lookup"><span data-stu-id="7593b-1942">The type of the node is <xref:System.Boolean>.</span></span>  
  
-   <span data-ttu-id="7593b-1943">如果 `left`。键入并 `right`。类型均可为 null，则提升节点。</span><span class="sxs-lookup"><span data-stu-id="7593b-1943">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="7593b-1944">如果 `liftToNull` `true`，则节点的类型可以为 null <xref:System.Boolean> 如果 `liftToNull` `false`，则为 <xref:System.Boolean>。</span><span class="sxs-lookup"><span data-stu-id="7593b-1944">The type of the node is nullable <xref:System.Boolean> if `liftToNull` is `true` or <xref:System.Boolean> if `liftToNull` is `false`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="7593b-1945"><paramref name="left" /> 或 <paramref name="right" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-1945"><paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="7593b-1946"><paramref name="method" /> 不是 <see langword="null" />，它所表示的方法返回 <see langword="void" />，而不是 <see langword="static" />（Visual Basic 中为 <see langword="Shared" />），或者并非采用两个参数。</span><span class="sxs-lookup"><span data-stu-id="7593b-1946"><paramref name="method" /> is not <see langword="null" /> and the method it represents returns <see langword="void" />, is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic), or does not take exactly two arguments.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="7593b-1947"><paramref name="method" /> 是 <see langword="null" />，且没有为 <paramref name="left" /> 类型和 <paramref name="right" /> 类型定义“小于”运算符。</span><span class="sxs-lookup"><span data-stu-id="7593b-1947"><paramref name="method" /> is <see langword="null" /> and the "less than" operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="LessThanOrEqual">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="7593b-1948">创建一个表示“小于或等于”数值比较的 <see cref="T:System.Linq.Expressions.BinaryExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-1948">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a " less than or equal" numeric comparison.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="LessThanOrEqual">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression LessThanOrEqual (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression LessThanOrEqual(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.LessThanOrEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LessThanOrEqual (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ LessThanOrEqual(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member LessThanOrEqual : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.LessThanOrEqual (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="7593b-1949">要将 <see cref="T:System.Linq.Expressions.Expression" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-1949">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="7593b-1950">要将 <see cref="T:System.Linq.Expressions.Expression" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-1950">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="7593b-1951">创建一个表示“小于或等于”数值比较的 <see cref="T:System.Linq.Expressions.BinaryExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-1951">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a " less than or equal" numeric comparison.</span></span></summary>
        <returns><span data-ttu-id="7593b-1952">一个 <see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 属性等于 <see cref="F:System.Linq.Expressions.ExpressionType.LessThanOrEqual" />，并且其 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 属性设置为指定值。</span><span class="sxs-lookup"><span data-stu-id="7593b-1952">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.LessThanOrEqual" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7593b-1953">生成的 <xref:System.Linq.Expressions.BinaryExpression> 具有设置为实现方法的 <xref:System.Linq.Expressions.BinaryExpression.Method%2A> 属性。</span><span class="sxs-lookup"><span data-stu-id="7593b-1953">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="7593b-1954"><xref:System.Linq.Expressions.Expression.Type%2A> 属性设置为节点的类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-1954">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="7593b-1955">如果节点已提升，则 `true`<xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> 属性。</span><span class="sxs-lookup"><span data-stu-id="7593b-1955">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> property is `true`.</span></span> <span data-ttu-id="7593b-1956">否则，它是 `false`。</span><span class="sxs-lookup"><span data-stu-id="7593b-1956">Otherwise, it is `false`.</span></span> <span data-ttu-id="7593b-1957"><xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> 属性始终为 `false`。</span><span class="sxs-lookup"><span data-stu-id="7593b-1957">The <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> property is always `false`.</span></span> <span data-ttu-id="7593b-1958"><xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> 属性为 `null`。</span><span class="sxs-lookup"><span data-stu-id="7593b-1958">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="7593b-1959">以下信息描述了实现方法、节点类型以及节点是否已提升。</span><span class="sxs-lookup"><span data-stu-id="7593b-1959">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="7593b-1960">实现方法</span><span class="sxs-lookup"><span data-stu-id="7593b-1960">Implementing Method</span></span>  
 <span data-ttu-id="7593b-1961">以下规则确定操作的实现方法：</span><span class="sxs-lookup"><span data-stu-id="7593b-1961">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="7593b-1962">如果 `left` 或 `right` 的 <xref:System.Linq.Expressions.Expression.Type%2A> 属性表示重载 "小于或等于" 运算符的用户定义类型，则表示该方法的 <xref:System.Reflection.MethodInfo> 是实现方法。</span><span class="sxs-lookup"><span data-stu-id="7593b-1962">If the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the "less than or equal" operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="7593b-1963">否则，如果 `left`。键入并 `right`。类型为数值类型，则实现方法为 `null`。</span><span class="sxs-lookup"><span data-stu-id="7593b-1963">Otherwise, if `left`.Type and `right`.Type are numeric types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="7593b-1964">节点类型和提升和非提升</span><span class="sxs-lookup"><span data-stu-id="7593b-1964">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="7593b-1965">如果不 `null`实现方法：</span><span class="sxs-lookup"><span data-stu-id="7593b-1965">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="7593b-1966">如果 `left`。键入并 `right`。类型可分配给实现方法的相应参数类型，不提升节点。</span><span class="sxs-lookup"><span data-stu-id="7593b-1966">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="7593b-1967">节点的类型是实现方法的返回类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-1967">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="7593b-1968">如果满足以下两个条件，则会提升节点并 <xref:System.Boolean>节点的类型：</span><span class="sxs-lookup"><span data-stu-id="7593b-1968">If the following two conditions are satisfied, the node is lifted and the type of the node is <xref:System.Boolean>:</span></span>  
  
    -   <span data-ttu-id="7593b-1969">`left`。键入并 `right`。类型既是值类型，其中至少有一个可为 null，并且相应的不可为 null 的类型等于实现方法的相应参数类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-1969">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="7593b-1970">实现方法的返回类型为 <xref:System.Boolean>。</span><span class="sxs-lookup"><span data-stu-id="7593b-1970">The return type of the implementing method is <xref:System.Boolean>.</span></span>  
  
 <span data-ttu-id="7593b-1971">如果实现方法为 `null`：</span><span class="sxs-lookup"><span data-stu-id="7593b-1971">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="7593b-1972">如果 `left`。键入并 `right`。类型不可以为 null，则不提升节点。</span><span class="sxs-lookup"><span data-stu-id="7593b-1972">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="7593b-1973">节点的类型为 <xref:System.Boolean>。</span><span class="sxs-lookup"><span data-stu-id="7593b-1973">The type of the node is <xref:System.Boolean>.</span></span>  
  
-   <span data-ttu-id="7593b-1974">如果 `left`。键入并 `right`。类型均可为 null，则提升节点。</span><span class="sxs-lookup"><span data-stu-id="7593b-1974">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="7593b-1975">节点的类型为 <xref:System.Boolean>。</span><span class="sxs-lookup"><span data-stu-id="7593b-1975">The type of the node is <xref:System.Boolean>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="7593b-1976">下面的代码示例演示如何创建对两个整数进行比较的表达式。</span><span class="sxs-lookup"><span data-stu-id="7593b-1976">The following code example shows how to create an expression that compares two integers.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#26](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#26)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#26](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#26)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="7593b-1977"><paramref name="left" /> 或 <paramref name="right" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-1977"><paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="7593b-1978">没有为 <paramref name="left" />.Type 和 <paramref name="right" />.Type 定义"小于或等于"运算符。</span><span class="sxs-lookup"><span data-stu-id="7593b-1978">The "less than or equal" operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="LessThanOrEqual">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression LessThanOrEqual (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, bool liftToNull, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression LessThanOrEqual(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, bool liftToNull, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.LessThanOrEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LessThanOrEqual (left As Expression, right As Expression, liftToNull As Boolean, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ LessThanOrEqual(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, bool liftToNull, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member LessThanOrEqual : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * bool * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.LessThanOrEqual (left, right, liftToNull, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="liftToNull" Type="System.Boolean" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="7593b-1979">要将 <see cref="T:System.Linq.Expressions.Expression" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-1979">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="7593b-1980">要将 <see cref="T:System.Linq.Expressions.Expression" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-1980">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <param name="liftToNull"><span data-ttu-id="7593b-1981">若要将 <see langword="true" /> 设置为 <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" />，则为 <see langword="true" />；若要将 <see langword="false" /> 设置为 <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" />，则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-1981"><see langword="true" /> to set <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> to <see langword="true" />; <see langword="false" /> to set <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> to <see langword="false" />.</span></span></param>
        <param name="method"><span data-ttu-id="7593b-1982">要将 <see cref="T:System.Reflection.MethodInfo" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-1982">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="7593b-1983">创建一个表示“小于或等于”数值比较的 <see cref="T:System.Linq.Expressions.BinaryExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-1983">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a "less than or equal" numeric comparison.</span></span></summary>
        <returns><span data-ttu-id="7593b-1984">一个 <see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 属性等于 <see cref="F:System.Linq.Expressions.ExpressionType.LessThanOrEqual" />，并且其 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />、<see cref="P:System.Linq.Expressions.BinaryExpression.Right" />、<see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> 属性设置为指定值。</span><span class="sxs-lookup"><span data-stu-id="7593b-1984">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.LessThanOrEqual" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7593b-1985">生成的 <xref:System.Linq.Expressions.BinaryExpression> 具有设置为实现方法的 <xref:System.Linq.Expressions.BinaryExpression.Method%2A> 属性。</span><span class="sxs-lookup"><span data-stu-id="7593b-1985">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="7593b-1986"><xref:System.Linq.Expressions.Expression.Type%2A> 属性设置为节点的类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-1986">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="7593b-1987">如果节点已提升，则 `true` <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> 属性，<xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> 属性等于 `liftToNull`。</span><span class="sxs-lookup"><span data-stu-id="7593b-1987">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> property is `true` and the <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> property is equal to `liftToNull`.</span></span> <span data-ttu-id="7593b-1988">否则，它们都 `false`。</span><span class="sxs-lookup"><span data-stu-id="7593b-1988">Otherwise, they are both `false`.</span></span> <span data-ttu-id="7593b-1989"><xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> 属性为 `null`。</span><span class="sxs-lookup"><span data-stu-id="7593b-1989">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="7593b-1990">以下信息描述了实现方法、节点类型以及节点是否已提升。</span><span class="sxs-lookup"><span data-stu-id="7593b-1990">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="7593b-1991">实现方法</span><span class="sxs-lookup"><span data-stu-id="7593b-1991">Implementing Method</span></span>  
 <span data-ttu-id="7593b-1992">以下规则确定操作的实现方法：</span><span class="sxs-lookup"><span data-stu-id="7593b-1992">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="7593b-1993">如果 `method` 未 `null` 并且它表示采用两个自变量的非 void、`static``Shared` （Visual Basic）方法，则它是实现方法。</span><span class="sxs-lookup"><span data-stu-id="7593b-1993">If `method` is not `null` and it represents a non-void, `static` (`Shared` in Visual Basic) method that takes two arguments, it is the implementing method.</span></span>  
  
-   <span data-ttu-id="7593b-1994">否则，如果 `left` 或 `right` 的 <xref:System.Linq.Expressions.Expression.Type%2A> 属性表示重载 "小于或等于" 运算符的用户定义类型，则表示该方法的 <xref:System.Reflection.MethodInfo> 是实现方法。</span><span class="sxs-lookup"><span data-stu-id="7593b-1994">Otherwise, if the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the "less than or equal" operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="7593b-1995">否则，如果 `left`。键入并 `right`。类型为数值类型，则实现方法为 `null`。</span><span class="sxs-lookup"><span data-stu-id="7593b-1995">Otherwise, if `left`.Type and `right`.Type are numeric types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="7593b-1996">节点类型和提升和非提升</span><span class="sxs-lookup"><span data-stu-id="7593b-1996">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="7593b-1997">如果不 `null`实现方法：</span><span class="sxs-lookup"><span data-stu-id="7593b-1997">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="7593b-1998">如果 `left`。键入并 `right`。类型可分配给实现方法的相应参数类型，不提升节点。</span><span class="sxs-lookup"><span data-stu-id="7593b-1998">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="7593b-1999">节点的类型是实现方法的返回类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-1999">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="7593b-2000">如果满足以下两个条件，则提升节点;此外，如果 `liftToNull` `false`，则节点类型可以为 null <xref:System.Boolean> 如果 `liftToNull` `true` 或 <xref:System.Boolean>：</span><span class="sxs-lookup"><span data-stu-id="7593b-2000">If the following two conditions are satisfied, the node is lifted; also, the type of the node is nullable <xref:System.Boolean> if `liftToNull` is `true` or <xref:System.Boolean> if `liftToNull` is `false`:</span></span>  
  
    -   <span data-ttu-id="7593b-2001">`left`。键入并 `right`。类型既是值类型，其中至少有一个可为 null，并且相应的不可为 null 的类型等于实现方法的相应参数类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-2001">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="7593b-2002">实现方法的返回类型为 <xref:System.Boolean>。</span><span class="sxs-lookup"><span data-stu-id="7593b-2002">The return type of the implementing method is <xref:System.Boolean>.</span></span>  
  
 <span data-ttu-id="7593b-2003">如果实现方法为 `null`：</span><span class="sxs-lookup"><span data-stu-id="7593b-2003">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="7593b-2004">如果 `left`。键入并 `right`。类型不可以为 null，则不提升节点。</span><span class="sxs-lookup"><span data-stu-id="7593b-2004">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="7593b-2005">节点的类型为 <xref:System.Boolean>。</span><span class="sxs-lookup"><span data-stu-id="7593b-2005">The type of the node is <xref:System.Boolean>.</span></span>  
  
-   <span data-ttu-id="7593b-2006">如果 `left`。键入并 `right`。类型均可为 null，则提升节点。</span><span class="sxs-lookup"><span data-stu-id="7593b-2006">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="7593b-2007">如果 `liftToNull` `true`，则节点的类型可以为 null <xref:System.Boolean> 如果 `liftToNull` `false`，则为 <xref:System.Boolean>。</span><span class="sxs-lookup"><span data-stu-id="7593b-2007">The type of the node is nullable <xref:System.Boolean> if `liftToNull` is `true` or <xref:System.Boolean> if `liftToNull` is `false`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="7593b-2008"><paramref name="left" /> 或 <paramref name="right" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2008"><paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="7593b-2009"><paramref name="method" /> 不是 <see langword="null" />，它所表示的方法返回 <see langword="void" />，而不是 <see langword="static" />（Visual Basic 中为 <see langword="Shared" />），或者并非采用两个参数。</span><span class="sxs-lookup"><span data-stu-id="7593b-2009"><paramref name="method" /> is not <see langword="null" /> and the method it represents returns <see langword="void" />, is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic), or does not take exactly two arguments.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="7593b-2010"><paramref name="method" /> 为 <see langword="null" />，并且没有为 <paramref name="left" />.Type 和 <paramref name="right" />.Type 定义"小于或等于"运算符。</span><span class="sxs-lookup"><span data-stu-id="7593b-2010"><paramref name="method" /> is <see langword="null" /> and the "less than or equal" operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ListBind">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="7593b-2011">创建一个 <see cref="T:System.Linq.Expressions.MemberListBinding" /> 对象。</span><span class="sxs-lookup"><span data-stu-id="7593b-2011">Creates a <see cref="T:System.Linq.Expressions.MemberListBinding" /> object.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ListBind">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberListBinding ListBind (System.Reflection.MemberInfo member, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ElementInit&gt; initializers);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberListBinding ListBind(class System.Reflection.MemberInfo member, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ElementInit&gt; initializers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ListBind(System.Reflection.MemberInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ElementInit})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ListBind (member As MemberInfo, initializers As IEnumerable(Of ElementInit)) As MemberListBinding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberListBinding ^ ListBind(System::Reflection::MemberInfo ^ member, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ElementInit ^&gt; ^ initializers);" />
      <MemberSignature Language="F#" Value="static member ListBind : System.Reflection.MemberInfo * seq&lt;System.Linq.Expressions.ElementInit&gt; -&gt; System.Linq.Expressions.MemberListBinding" Usage="System.Linq.Expressions.Expression.ListBind (member, initializers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberListBinding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="member" Type="System.Reflection.MemberInfo" />
        <Parameter Name="initializers" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ElementInit&gt;" />
      </Parameters>
      <Docs>
        <param name="member"><span data-ttu-id="7593b-2012">一个 <see cref="T:System.Reflection.MemberInfo" />，表示要将 <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> 属性设置为与其相等的字段或属性。</span><span class="sxs-lookup"><span data-stu-id="7593b-2012">A <see cref="T:System.Reflection.MemberInfo" /> that represents a field or property to set the <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> property equal to.</span></span></param>
        <param name="initializers"><span data-ttu-id="7593b-2013">一个 <see cref="T:System.Collections.Generic.IEnumerable`1" />，包含用来填充 <see cref="T:System.Linq.Expressions.ElementInit" /> 集合的 <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> 对象。</span><span class="sxs-lookup"><span data-stu-id="7593b-2013">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.ElementInit" /> objects to use to populate the <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> collection.</span></span></param>
        <summary><span data-ttu-id="7593b-2014">创建一个其成员为字段或属性的 <see cref="T:System.Linq.Expressions.MemberListBinding" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2014">Creates a <see cref="T:System.Linq.Expressions.MemberListBinding" /> where the member is a field or property.</span></span></summary>
        <returns><span data-ttu-id="7593b-2015">一个 <see cref="T:System.Linq.Expressions.MemberListBinding" />，其 <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> 属性等于 <see cref="F:System.Linq.Expressions.MemberBindingType.ListBinding" />，并且其 <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> 和 <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> 属性设置为指定值。</span><span class="sxs-lookup"><span data-stu-id="7593b-2015">A <see cref="T:System.Linq.Expressions.MemberListBinding" /> that has the <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> property equal to <see cref="F:System.Linq.Expressions.MemberBindingType.ListBinding" /> and the <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> and <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="7593b-2016"><paramref name="member" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2016"><paramref name="member" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="7593b-2017">- 或 -</span><span class="sxs-lookup"><span data-stu-id="7593b-2017">-or-</span></span> 
<span data-ttu-id="7593b-2018"><paramref name="initializers" /> 的一个或多个元素为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2018">One or more elements of <paramref name="initializers" /> are <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="7593b-2019"><paramref name="member" /> 不表示字段或属性。</span><span class="sxs-lookup"><span data-stu-id="7593b-2019"><paramref name="member" /> does not represent a field or property.</span></span>  
  
<span data-ttu-id="7593b-2020">- 或 -</span><span class="sxs-lookup"><span data-stu-id="7593b-2020">-or-</span></span> 
<span data-ttu-id="7593b-2021"><see cref="P:System.Reflection.FieldInfo.FieldType" /> 所表示的字段或属性的 <see cref="P:System.Reflection.PropertyInfo.PropertyType" /> 或 <paramref name="member" /> 没有实现 <see cref="T:System.Collections.IEnumerable" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2021">The <see cref="P:System.Reflection.FieldInfo.FieldType" /> or <see cref="P:System.Reflection.PropertyInfo.PropertyType" /> of the field or property that <paramref name="member" /> represents does not implement <see cref="T:System.Collections.IEnumerable" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ListBind">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberListBinding ListBind (System.Reflection.MemberInfo member, params System.Linq.Expressions.ElementInit[] initializers);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberListBinding ListBind(class System.Reflection.MemberInfo member, class System.Linq.Expressions.ElementInit[] initializers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ListBind(System.Reflection.MemberInfo,System.Linq.Expressions.ElementInit[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ListBind (member As MemberInfo, ParamArray initializers As ElementInit()) As MemberListBinding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberListBinding ^ ListBind(System::Reflection::MemberInfo ^ member, ... cli::array &lt;System::Linq::Expressions::ElementInit ^&gt; ^ initializers);" />
      <MemberSignature Language="F#" Value="static member ListBind : System.Reflection.MemberInfo * System.Linq.Expressions.ElementInit[] -&gt; System.Linq.Expressions.MemberListBinding" Usage="System.Linq.Expressions.Expression.ListBind (member, initializers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberListBinding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="member" Type="System.Reflection.MemberInfo" />
        <Parameter Name="initializers" Type="System.Linq.Expressions.ElementInit[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="member"><span data-ttu-id="7593b-2022">一个 <see cref="T:System.Reflection.MemberInfo" />，表示要将 <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> 属性设置为与其相等的字段或属性。</span><span class="sxs-lookup"><span data-stu-id="7593b-2022">A <see cref="T:System.Reflection.MemberInfo" /> that represents a field or property to set the <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> property equal to.</span></span></param>
        <param name="initializers"><span data-ttu-id="7593b-2023">用于填充 <see cref="T:System.Linq.Expressions.ElementInit" /> 集合的 <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> 对象的数组。</span><span class="sxs-lookup"><span data-stu-id="7593b-2023">An array of <see cref="T:System.Linq.Expressions.ElementInit" /> objects to use to populate the <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> collection.</span></span></param>
        <summary><span data-ttu-id="7593b-2024">创建一个其成员为字段或属性的 <see cref="T:System.Linq.Expressions.MemberListBinding" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2024">Creates a <see cref="T:System.Linq.Expressions.MemberListBinding" /> where the member is a field or property.</span></span></summary>
        <returns><span data-ttu-id="7593b-2025">一个 <see cref="T:System.Linq.Expressions.MemberListBinding" />，其 <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> 属性等于 <see cref="F:System.Linq.Expressions.MemberBindingType.ListBinding" />，并且其 <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> 和 <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> 属性设置为指定值。</span><span class="sxs-lookup"><span data-stu-id="7593b-2025">A <see cref="T:System.Linq.Expressions.MemberListBinding" /> that has the <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> property equal to <see cref="F:System.Linq.Expressions.MemberBindingType.ListBinding" /> and the <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> and <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="7593b-2026"><paramref name="member" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2026"><paramref name="member" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="7593b-2027">- 或 -</span><span class="sxs-lookup"><span data-stu-id="7593b-2027">-or-</span></span> 
<span data-ttu-id="7593b-2028"><paramref name="initializers" /> 的一个或多个元素为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2028">One or more elements of <paramref name="initializers" /> are <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="7593b-2029"><paramref name="member" /> 不表示字段或属性。</span><span class="sxs-lookup"><span data-stu-id="7593b-2029"><paramref name="member" /> does not represent a field or property.</span></span>  
  
<span data-ttu-id="7593b-2030">- 或 -</span><span class="sxs-lookup"><span data-stu-id="7593b-2030">-or-</span></span> 
<span data-ttu-id="7593b-2031"><see cref="P:System.Reflection.FieldInfo.FieldType" /> 所表示的字段或属性的 <see cref="P:System.Reflection.PropertyInfo.PropertyType" /> 或 <paramref name="member" /> 没有实现 <see cref="T:System.Collections.IEnumerable" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2031">The <see cref="P:System.Reflection.FieldInfo.FieldType" /> or <see cref="P:System.Reflection.PropertyInfo.PropertyType" /> of the field or property that <paramref name="member" /> represents does not implement <see cref="T:System.Collections.IEnumerable" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ListBind">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberListBinding ListBind (System.Reflection.MethodInfo propertyAccessor, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ElementInit&gt; initializers);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberListBinding ListBind(class System.Reflection.MethodInfo propertyAccessor, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ElementInit&gt; initializers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ListBind(System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ElementInit})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ListBind (propertyAccessor As MethodInfo, initializers As IEnumerable(Of ElementInit)) As MemberListBinding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberListBinding ^ ListBind(System::Reflection::MethodInfo ^ propertyAccessor, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ElementInit ^&gt; ^ initializers);" />
      <MemberSignature Language="F#" Value="static member ListBind : System.Reflection.MethodInfo * seq&lt;System.Linq.Expressions.ElementInit&gt; -&gt; System.Linq.Expressions.MemberListBinding" Usage="System.Linq.Expressions.Expression.ListBind (propertyAccessor, initializers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberListBinding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyAccessor" Type="System.Reflection.MethodInfo" />
        <Parameter Name="initializers" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ElementInit&gt;" />
      </Parameters>
      <Docs>
        <param name="propertyAccessor"><span data-ttu-id="7593b-2032">一个表示属性访问器方法的 <see cref="T:System.Reflection.MethodInfo" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2032">A <see cref="T:System.Reflection.MethodInfo" /> that represents a property accessor method.</span></span></param>
        <param name="initializers"><span data-ttu-id="7593b-2033">一个 <see cref="T:System.Collections.Generic.IEnumerable`1" />，包含用来填充 <see cref="T:System.Linq.Expressions.ElementInit" /> 集合的 <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> 对象。</span><span class="sxs-lookup"><span data-stu-id="7593b-2033">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.ElementInit" /> objects to use to populate the <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> collection.</span></span></param>
        <summary><span data-ttu-id="7593b-2034">基于指定的属性访问器方法创建一个 <see cref="T:System.Linq.Expressions.MemberListBinding" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2034">Creates a <see cref="T:System.Linq.Expressions.MemberListBinding" /> based on a specified property accessor method.</span></span></summary>
        <returns><span data-ttu-id="7593b-2035">一个 <see cref="T:System.Linq.Expressions.MemberListBinding" />，其 <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> 属性等于 <see cref="F:System.Linq.Expressions.MemberBindingType.ListBinding" />，<see cref="P:System.Linq.Expressions.MemberBinding.Member" /> 属性设置为表示在 <see cref="T:System.Reflection.MemberInfo" /> 中访问的属性的 <paramref name="propertyAccessor" />，并且 <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> 填充了 <paramref name="initializers" /> 的元素。</span><span class="sxs-lookup"><span data-stu-id="7593b-2035">A <see cref="T:System.Linq.Expressions.MemberListBinding" /> that has the <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> property equal to <see cref="F:System.Linq.Expressions.MemberBindingType.ListBinding" />, the <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> property set to the <see cref="T:System.Reflection.MemberInfo" /> that represents the property accessed in <paramref name="propertyAccessor" />, and <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> populated with the elements of <paramref name="initializers" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="7593b-2036"><paramref name="propertyAccessor" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2036"><paramref name="propertyAccessor" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="7593b-2037">- 或 -</span><span class="sxs-lookup"><span data-stu-id="7593b-2037">-or-</span></span> 
<span data-ttu-id="7593b-2038"><paramref name="initializers" /> 的一个或多个元素为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2038">One or more elements of <paramref name="initializers" /> are <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="7593b-2039"><paramref name="propertyAccessor" /> 不表示属性访问器方法。</span><span class="sxs-lookup"><span data-stu-id="7593b-2039"><paramref name="propertyAccessor" /> does not represent a property accessor method.</span></span>  
  
<span data-ttu-id="7593b-2040">- 或 -</span><span class="sxs-lookup"><span data-stu-id="7593b-2040">-or-</span></span> 
<span data-ttu-id="7593b-2041"><see cref="P:System.Reflection.PropertyInfo.PropertyType" /> 所表示的方法所访问的属性的 <paramref name="propertyAccessor" /> 没有实现 <see cref="T:System.Collections.IEnumerable" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2041">The <see cref="P:System.Reflection.PropertyInfo.PropertyType" /> of the property that the method represented by <paramref name="propertyAccessor" /> accesses does not implement <see cref="T:System.Collections.IEnumerable" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ListBind">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberListBinding ListBind (System.Reflection.MethodInfo propertyAccessor, params System.Linq.Expressions.ElementInit[] initializers);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberListBinding ListBind(class System.Reflection.MethodInfo propertyAccessor, class System.Linq.Expressions.ElementInit[] initializers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ListBind(System.Reflection.MethodInfo,System.Linq.Expressions.ElementInit[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ListBind (propertyAccessor As MethodInfo, ParamArray initializers As ElementInit()) As MemberListBinding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberListBinding ^ ListBind(System::Reflection::MethodInfo ^ propertyAccessor, ... cli::array &lt;System::Linq::Expressions::ElementInit ^&gt; ^ initializers);" />
      <MemberSignature Language="F#" Value="static member ListBind : System.Reflection.MethodInfo * System.Linq.Expressions.ElementInit[] -&gt; System.Linq.Expressions.MemberListBinding" Usage="System.Linq.Expressions.Expression.ListBind (propertyAccessor, initializers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberListBinding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyAccessor" Type="System.Reflection.MethodInfo" />
        <Parameter Name="initializers" Type="System.Linq.Expressions.ElementInit[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="propertyAccessor"><span data-ttu-id="7593b-2042">一个表示属性访问器方法的 <see cref="T:System.Reflection.MethodInfo" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2042">A <see cref="T:System.Reflection.MethodInfo" /> that represents a property accessor method.</span></span></param>
        <param name="initializers"><span data-ttu-id="7593b-2043">用于填充 <see cref="T:System.Linq.Expressions.ElementInit" /> 集合的 <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> 对象的数组。</span><span class="sxs-lookup"><span data-stu-id="7593b-2043">An array of <see cref="T:System.Linq.Expressions.ElementInit" /> objects to use to populate the <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> collection.</span></span></param>
        <summary><span data-ttu-id="7593b-2044">基于指定的属性访问器方法创建一个 <see cref="T:System.Linq.Expressions.MemberListBinding" /> 对象。</span><span class="sxs-lookup"><span data-stu-id="7593b-2044">Creates a <see cref="T:System.Linq.Expressions.MemberListBinding" /> object based on a specified property accessor method.</span></span></summary>
        <returns><span data-ttu-id="7593b-2045">一个 <see cref="T:System.Linq.Expressions.MemberListBinding" />，其 <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> 属性等于 <see cref="F:System.Linq.Expressions.MemberBindingType.ListBinding" />，<see cref="P:System.Linq.Expressions.MemberBinding.Member" /> 属性设置为表示在 <see cref="T:System.Reflection.MemberInfo" /> 中访问的属性的 <paramref name="propertyAccessor" />，并且 <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> 填充了 <paramref name="initializers" /> 的元素。</span><span class="sxs-lookup"><span data-stu-id="7593b-2045">A <see cref="T:System.Linq.Expressions.MemberListBinding" /> that has the <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> property equal to <see cref="F:System.Linq.Expressions.MemberBindingType.ListBinding" />, the <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> property set to the <see cref="T:System.Reflection.MemberInfo" /> that represents the property accessed in <paramref name="propertyAccessor" />, and <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> populated with the elements of <paramref name="initializers" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="7593b-2046"><paramref name="propertyAccessor" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2046"><paramref name="propertyAccessor" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="7593b-2047">- 或 -</span><span class="sxs-lookup"><span data-stu-id="7593b-2047">-or-</span></span> 
<span data-ttu-id="7593b-2048"><paramref name="initializers" /> 的一个或多个元素为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2048">One or more elements of <paramref name="initializers" /> are <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="7593b-2049"><paramref name="propertyAccessor" /> 不表示属性访问器方法。</span><span class="sxs-lookup"><span data-stu-id="7593b-2049"><paramref name="propertyAccessor" /> does not represent a property accessor method.</span></span>  
  
<span data-ttu-id="7593b-2050">- 或 -</span><span class="sxs-lookup"><span data-stu-id="7593b-2050">-or-</span></span> 
<span data-ttu-id="7593b-2051"><see cref="P:System.Reflection.PropertyInfo.PropertyType" /> 所表示的方法所访问的属性的 <paramref name="propertyAccessor" /> 没有实现 <see cref="T:System.Collections.IEnumerable" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2051">The <see cref="P:System.Reflection.PropertyInfo.PropertyType" /> of the property that the method represented by <paramref name="propertyAccessor" /> accesses does not implement <see cref="T:System.Collections.IEnumerable" />.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ListInit">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="7593b-2052">创建一个 <see cref="T:System.Linq.Expressions.ListInitExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2052">Creates a <see cref="T:System.Linq.Expressions.ListInitExpression" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ListInit">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ListInitExpression ListInit (System.Linq.Expressions.NewExpression newExpression, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ElementInit&gt; initializers);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ListInitExpression ListInit(class System.Linq.Expressions.NewExpression newExpression, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ElementInit&gt; initializers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ListInit(System.Linq.Expressions.NewExpression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ElementInit})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::ListInitExpression ^ ListInit(System::Linq::Expressions::NewExpression ^ newExpression, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ElementInit ^&gt; ^ initializers);" />
      <MemberSignature Language="F#" Value="static member ListInit : System.Linq.Expressions.NewExpression * seq&lt;System.Linq.Expressions.ElementInit&gt; -&gt; System.Linq.Expressions.ListInitExpression" Usage="System.Linq.Expressions.Expression.ListInit (newExpression, initializers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ListInitExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="newExpression" Type="System.Linq.Expressions.NewExpression" />
        <Parameter Name="initializers" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ElementInit&gt;" />
      </Parameters>
      <Docs>
        <param name="newExpression"><span data-ttu-id="7593b-2053">要将 <see cref="T:System.Linq.Expressions.NewExpression" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2053">A <see cref="T:System.Linq.Expressions.NewExpression" /> to set the <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> property equal to.</span></span></param>
        <param name="initializers"><span data-ttu-id="7593b-2054">一个 <see cref="T:System.Collections.Generic.IEnumerable`1" />，包含用来填充 <see cref="T:System.Linq.Expressions.ElementInit" /> 集合的 <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" /> 对象。</span><span class="sxs-lookup"><span data-stu-id="7593b-2054">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.ElementInit" /> objects to use to populate the <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" /> collection.</span></span></param>
        <summary><span data-ttu-id="7593b-2055">创建一个使用指定 <see cref="T:System.Linq.Expressions.ListInitExpression" /> 对象来初始化集合的 <see cref="T:System.Linq.Expressions.ElementInit" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2055">Creates a <see cref="T:System.Linq.Expressions.ListInitExpression" /> that uses specified <see cref="T:System.Linq.Expressions.ElementInit" /> objects to initialize a collection.</span></span></summary>
        <returns><span data-ttu-id="7593b-2056">一个 <see cref="T:System.Linq.Expressions.ListInitExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 属性等于 <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" />，并且其 <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> 和 <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" /> 属性设置为指定值。</span><span class="sxs-lookup"><span data-stu-id="7593b-2056">A <see cref="T:System.Linq.Expressions.ListInitExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" /> and the <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> and <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7593b-2057">`newExpression` 的 <xref:System.Linq.Expressions.Expression.Type%2A> 属性必须表示实现 <xref:System.Collections.IEnumerable>的类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-2057">The <xref:System.Linq.Expressions.Expression.Type%2A> property of `newExpression` must represent a type that implements <xref:System.Collections.IEnumerable>.</span></span>  
  
 <span data-ttu-id="7593b-2058">生成的 <xref:System.Linq.Expressions.ListInitExpression> 的 <xref:System.Linq.Expressions.Expression.Type%2A> 属性等于 `newExpression`。类别.</span><span class="sxs-lookup"><span data-stu-id="7593b-2058">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.ListInitExpression> is equal to `newExpression`.Type.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="7593b-2059">下面的示例演示如何使用 <xref:System.Linq.Expressions.Expression.ListInit%28System.Linq.Expressions.NewExpression%2CSystem.Linq.Expressions.ElementInit%5B%5D%29> 方法创建一个表示具有两个键/值对的新字典实例初始化的 <xref:System.Linq.Expressions.ListInitExpression>。</span><span class="sxs-lookup"><span data-stu-id="7593b-2059">The following example demonstrates how to use the <xref:System.Linq.Expressions.Expression.ListInit%28System.Linq.Expressions.NewExpression%2CSystem.Linq.Expressions.ElementInit%5B%5D%29> method to create a <xref:System.Linq.Expressions.ListInitExpression> that represents the initialization of a new dictionary instance with two key-value pairs.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.Expression#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#7)]
 [!code-vb[System.Linq.Expressions.Expression#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="7593b-2060"><paramref name="newExpression" /> 或 <paramref name="initializers" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2060"><paramref name="newExpression" /> or <paramref name="initializers" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="7593b-2061">- 或 -</span><span class="sxs-lookup"><span data-stu-id="7593b-2061">-or-</span></span> 
<span data-ttu-id="7593b-2062"><paramref name="initializers" /> 的一个或多个元素为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2062">One or more elements of <paramref name="initializers" /> are <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="7593b-2063"><paramref name="newExpression" />.Type 不实现 <see cref="T:System.Collections.IEnumerable" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2063"><paramref name="newExpression" />.Type does not implement <see cref="T:System.Collections.IEnumerable" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ListInit">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ListInitExpression ListInit (System.Linq.Expressions.NewExpression newExpression, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; initializers);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ListInitExpression ListInit(class System.Linq.Expressions.NewExpression newExpression, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; initializers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ListInit(System.Linq.Expressions.NewExpression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::ListInitExpression ^ ListInit(System::Linq::Expressions::NewExpression ^ newExpression, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ initializers);" />
      <MemberSignature Language="F#" Value="static member ListInit : System.Linq.Expressions.NewExpression * seq&lt;System.Linq.Expressions.Expression&gt; -&gt; System.Linq.Expressions.ListInitExpression" Usage="System.Linq.Expressions.Expression.ListInit (newExpression, initializers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ListInitExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="newExpression" Type="System.Linq.Expressions.NewExpression" />
        <Parameter Name="initializers" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="newExpression"><span data-ttu-id="7593b-2064">要将 <see cref="T:System.Linq.Expressions.NewExpression" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2064">A <see cref="T:System.Linq.Expressions.NewExpression" /> to set the <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> property equal to.</span></span></param>
        <param name="initializers"><span data-ttu-id="7593b-2065">一个 <see cref="T:System.Collections.Generic.IEnumerable`1" />，包含用来填充 <see cref="T:System.Linq.Expressions.Expression" /> 集合的 <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" /> 对象。</span><span class="sxs-lookup"><span data-stu-id="7593b-2065">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.Expression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" /> collection.</span></span></param>
        <summary><span data-ttu-id="7593b-2066">创建一个使用名为“Add”的方法将元素添加到集合中的 <see cref="T:System.Linq.Expressions.ListInitExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2066">Creates a <see cref="T:System.Linq.Expressions.ListInitExpression" /> that uses a method named "Add" to add elements to a collection.</span></span></summary>
        <returns><span data-ttu-id="7593b-2067">一个 <see cref="T:System.Linq.Expressions.ListInitExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 属性等于 <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" />，并且其 <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> 属性设置为指定值。</span><span class="sxs-lookup"><span data-stu-id="7593b-2067">A <see cref="T:System.Linq.Expressions.ListInitExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" /> and the <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> property set to the specified value.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7593b-2068">`newExpression` 的 <xref:System.Linq.Expressions.Expression.Type%2A> 属性必须表示实现 <xref:System.Collections.IEnumerable>的类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-2068">The <xref:System.Linq.Expressions.Expression.Type%2A> property of `newExpression` must represent a type that implements <xref:System.Collections.IEnumerable>.</span></span>  
  
 <span data-ttu-id="7593b-2069">若要将此重载用于 <xref:System.Linq.Expressions.Expression.ListInit%28System.Linq.Expressions.NewExpression%2CSystem.Collections.Generic.IEnumerable%7BSystem.Linq.Expressions.Expression%7D%29>，请 `newExpression`。类型或其基类型必须声明一个名为 "Add" （不区分大小写）的方法，该方法只采用一个参数。</span><span class="sxs-lookup"><span data-stu-id="7593b-2069">In order to use this overload of <xref:System.Linq.Expressions.Expression.ListInit%28System.Linq.Expressions.NewExpression%2CSystem.Collections.Generic.IEnumerable%7BSystem.Linq.Expressions.Expression%7D%29>, `newExpression`.Type or its base type must declare a single method named "Add" (case insensitive) that takes exactly one argument.</span></span> <span data-ttu-id="7593b-2070">参数的类型必须可从 `initializers`的第一个元素的 <xref:System.Linq.Expressions.Expression.Type%2A> 属性表示的类型中赋值。</span><span class="sxs-lookup"><span data-stu-id="7593b-2070">The type of the argument must be assignable from the type represented by the <xref:System.Linq.Expressions.Expression.Type%2A> property of the first element of `initializers`.</span></span>  
  
 <span data-ttu-id="7593b-2071">返回的 <xref:System.Linq.Expressions.ListInitExpression> 的 <xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> 属性包含 `initializers`的每个元素的类型 <xref:System.Linq.Expressions.ElementInit> 的一个元素。</span><span class="sxs-lookup"><span data-stu-id="7593b-2071">The <xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> property of the returned <xref:System.Linq.Expressions.ListInitExpression> contains one element of type <xref:System.Linq.Expressions.ElementInit> for each element of `initializers`.</span></span> <span data-ttu-id="7593b-2072"><xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> 的每个元素的 <xref:System.Linq.Expressions.ElementInit.Arguments%2A> 属性是一个单独的集合，其中包含 `initializers`的对应元素。</span><span class="sxs-lookup"><span data-stu-id="7593b-2072">The <xref:System.Linq.Expressions.ElementInit.Arguments%2A> property of each element of <xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> is a singleton collection that contains the corresponding element of `initializers`.</span></span> <span data-ttu-id="7593b-2073"><xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> 的每个元素的 <xref:System.Linq.Expressions.ElementInit.AddMethod%2A> 属性表示在 `newExpression`上发现的 add 方法。类型或其基类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-2073">The <xref:System.Linq.Expressions.ElementInit.AddMethod%2A> property of each element of <xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> represents the add method that was discovered on `newExpression`.Type or its base type.</span></span>  
  
 <span data-ttu-id="7593b-2074">生成的 <xref:System.Linq.Expressions.ListInitExpression> 的 <xref:System.Linq.Expressions.Expression.Type%2A> 属性等于 `newExpression`。类别.</span><span class="sxs-lookup"><span data-stu-id="7593b-2074">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.ListInitExpression> is equal to `newExpression`.Type.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="7593b-2075"><paramref name="newExpression" /> 或 <paramref name="initializers" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2075"><paramref name="newExpression" /> or <paramref name="initializers" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="7593b-2076">- 或 -</span><span class="sxs-lookup"><span data-stu-id="7593b-2076">-or-</span></span> 
<span data-ttu-id="7593b-2077"><paramref name="initializers" /> 的一个或多个元素为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2077">One or more elements of <paramref name="initializers" /> are <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="7593b-2078"><paramref name="newExpression" />.Type 不实现 <see cref="T:System.Collections.IEnumerable" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2078"><paramref name="newExpression" />.Type does not implement <see cref="T:System.Collections.IEnumerable" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="7593b-2079">没有在 <paramref name="newExpression" />.Type 或其基类型中声明的名为“Add”（不区分大小写）的实例方法。</span><span class="sxs-lookup"><span data-stu-id="7593b-2079">There is no instance method named "Add" (case insensitive) declared in <paramref name="newExpression" />.Type or its base type.</span></span>  
  
<span data-ttu-id="7593b-2080">- 或 -</span><span class="sxs-lookup"><span data-stu-id="7593b-2080">-or-</span></span> 
<span data-ttu-id="7593b-2081"><paramref name="newExpression" />.Type 或其基类型上的 add 方法不采用确切的参数。</span><span class="sxs-lookup"><span data-stu-id="7593b-2081">The add method on <paramref name="newExpression" />.Type or its base type does not take exactly one argument.</span></span>  
  
<span data-ttu-id="7593b-2082">- 或 -</span><span class="sxs-lookup"><span data-stu-id="7593b-2082">-or-</span></span> 
<span data-ttu-id="7593b-2083">由 <see cref="P:System.Linq.Expressions.Expression.Type" /> 的第一个元素的 <paramref name="initializers" /> 属性表示的类型不可分配给 <paramref name="newExpression" />.Type 或其基类型上 add 方法的参数类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-2083">The type represented by the <see cref="P:System.Linq.Expressions.Expression.Type" /> property of the first element of <paramref name="initializers" /> is not assignable to the argument type of the add method on <paramref name="newExpression" />.Type or its base type.</span></span>  
  
<span data-ttu-id="7593b-2084">- 或 -</span><span class="sxs-lookup"><span data-stu-id="7593b-2084">-or-</span></span> 
<span data-ttu-id="7593b-2085"><paramref name="newExpression" />.Type 和/或其基类型上存在多个名为“Add”（不区分大小写）且与参数兼容的方法。</span><span class="sxs-lookup"><span data-stu-id="7593b-2085">More than one argument-compatible method named "Add" (case-insensitive) exists on <paramref name="newExpression" />.Type and/or its base type.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ListInit">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ListInitExpression ListInit (System.Linq.Expressions.NewExpression newExpression, params System.Linq.Expressions.ElementInit[] initializers);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ListInitExpression ListInit(class System.Linq.Expressions.NewExpression newExpression, class System.Linq.Expressions.ElementInit[] initializers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ListInit(System.Linq.Expressions.NewExpression,System.Linq.Expressions.ElementInit[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::ListInitExpression ^ ListInit(System::Linq::Expressions::NewExpression ^ newExpression, ... cli::array &lt;System::Linq::Expressions::ElementInit ^&gt; ^ initializers);" />
      <MemberSignature Language="F#" Value="static member ListInit : System.Linq.Expressions.NewExpression * System.Linq.Expressions.ElementInit[] -&gt; System.Linq.Expressions.ListInitExpression" Usage="System.Linq.Expressions.Expression.ListInit (newExpression, initializers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ListInitExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="newExpression" Type="System.Linq.Expressions.NewExpression" />
        <Parameter Name="initializers" Type="System.Linq.Expressions.ElementInit[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="newExpression"><span data-ttu-id="7593b-2086">要将 <see cref="T:System.Linq.Expressions.NewExpression" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2086">A <see cref="T:System.Linq.Expressions.NewExpression" /> to set the <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> property equal to.</span></span></param>
        <param name="initializers"><span data-ttu-id="7593b-2087">用于填充 <see cref="T:System.Linq.Expressions.ElementInit" /> 集合的 <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" /> 对象的数组。</span><span class="sxs-lookup"><span data-stu-id="7593b-2087">An array of <see cref="T:System.Linq.Expressions.ElementInit" /> objects to use to populate the <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" /> collection.</span></span></param>
        <summary><span data-ttu-id="7593b-2088">创建一个使用指定 <see cref="T:System.Linq.Expressions.ListInitExpression" /> 对象来初始化集合的 <see cref="T:System.Linq.Expressions.ElementInit" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2088">Creates a <see cref="T:System.Linq.Expressions.ListInitExpression" /> that uses specified <see cref="T:System.Linq.Expressions.ElementInit" /> objects to initialize a collection.</span></span></summary>
        <returns><span data-ttu-id="7593b-2089">一个 <see cref="T:System.Linq.Expressions.ListInitExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 属性等于 <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" />，并且其 <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> 和 <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" /> 属性设置为指定值。</span><span class="sxs-lookup"><span data-stu-id="7593b-2089">A <see cref="T:System.Linq.Expressions.ListInitExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" /> and the <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> and <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7593b-2090">`newExpression` 的 <xref:System.Linq.Expressions.Expression.Type%2A> 属性必须表示实现 <xref:System.Collections.IEnumerable>的类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-2090">The <xref:System.Linq.Expressions.Expression.Type%2A> property of `newExpression` must represent a type that implements <xref:System.Collections.IEnumerable>.</span></span>  
  
 <span data-ttu-id="7593b-2091">生成的 <xref:System.Linq.Expressions.ListInitExpression> 的 <xref:System.Linq.Expressions.Expression.Type%2A> 属性等于 `newExpression`。类别.</span><span class="sxs-lookup"><span data-stu-id="7593b-2091">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.ListInitExpression> is equal to `newExpression`.Type.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="7593b-2092">下面的示例演示如何使用 <xref:System.Linq.Expressions.Expression.ListInit%28System.Linq.Expressions.NewExpression%2CSystem.Linq.Expressions.ElementInit%5B%5D%29> 方法创建一个表示具有两个键/值对的新字典实例初始化的 <xref:System.Linq.Expressions.ListInitExpression>。</span><span class="sxs-lookup"><span data-stu-id="7593b-2092">The following example demonstrates how to use the <xref:System.Linq.Expressions.Expression.ListInit%28System.Linq.Expressions.NewExpression%2CSystem.Linq.Expressions.ElementInit%5B%5D%29> method to create a <xref:System.Linq.Expressions.ListInitExpression> that represents the initialization of a new dictionary instance with two key-value pairs.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.Expression#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#7)]
 [!code-vb[System.Linq.Expressions.Expression#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="7593b-2093"><paramref name="newExpression" /> 或 <paramref name="initializers" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2093"><paramref name="newExpression" /> or <paramref name="initializers" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="7593b-2094">- 或 -</span><span class="sxs-lookup"><span data-stu-id="7593b-2094">-or-</span></span> 
<span data-ttu-id="7593b-2095"><paramref name="initializers" /> 的一个或多个元素为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2095">One or more elements of <paramref name="initializers" /> are <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="7593b-2096"><paramref name="newExpression" />.Type 不实现 <see cref="T:System.Collections.IEnumerable" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2096"><paramref name="newExpression" />.Type does not implement <see cref="T:System.Collections.IEnumerable" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ListInit">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ListInitExpression ListInit (System.Linq.Expressions.NewExpression newExpression, params System.Linq.Expressions.Expression[] initializers);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ListInitExpression ListInit(class System.Linq.Expressions.NewExpression newExpression, class System.Linq.Expressions.Expression[] initializers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ListInit(System.Linq.Expressions.NewExpression,System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::ListInitExpression ^ ListInit(System::Linq::Expressions::NewExpression ^ newExpression, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ initializers);" />
      <MemberSignature Language="F#" Value="static member ListInit : System.Linq.Expressions.NewExpression * System.Linq.Expressions.Expression[] -&gt; System.Linq.Expressions.ListInitExpression" Usage="System.Linq.Expressions.Expression.ListInit (newExpression, initializers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ListInitExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="newExpression" Type="System.Linq.Expressions.NewExpression" />
        <Parameter Name="initializers" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="newExpression"><span data-ttu-id="7593b-2097">要将 <see cref="T:System.Linq.Expressions.NewExpression" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2097">A <see cref="T:System.Linq.Expressions.NewExpression" /> to set the <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> property equal to.</span></span></param>
        <param name="initializers"><span data-ttu-id="7593b-2098">用于填充 <see cref="T:System.Linq.Expressions.Expression" /> 集合的 <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" /> 对象的数组。</span><span class="sxs-lookup"><span data-stu-id="7593b-2098">An array of <see cref="T:System.Linq.Expressions.Expression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" /> collection.</span></span></param>
        <summary><span data-ttu-id="7593b-2099">创建一个使用名为“Add”的方法将元素添加到集合中的 <see cref="T:System.Linq.Expressions.ListInitExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2099">Creates a <see cref="T:System.Linq.Expressions.ListInitExpression" /> that uses a method named "Add" to add elements to a collection.</span></span></summary>
        <returns><span data-ttu-id="7593b-2100">一个 <see cref="T:System.Linq.Expressions.ListInitExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 属性等于 <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" />，并且其 <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> 属性设置为指定值。</span><span class="sxs-lookup"><span data-stu-id="7593b-2100">A <see cref="T:System.Linq.Expressions.ListInitExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" /> and the <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> property set to the specified value.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7593b-2101">`newExpression` 的 <xref:System.Linq.Expressions.Expression.Type%2A> 属性必须表示实现 <xref:System.Collections.IEnumerable>的类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-2101">The <xref:System.Linq.Expressions.Expression.Type%2A> property of `newExpression` must represent a type that implements <xref:System.Collections.IEnumerable>.</span></span>  
  
 <span data-ttu-id="7593b-2102">若要将此重载用于 <xref:System.Linq.Expressions.Expression.ListInit%28System.Linq.Expressions.NewExpression%2CSystem.Linq.Expressions.Expression%5B%5D%29>，请 `newExpression`。类型或其基类型必须声明一个名为 "Add" （不区分大小写）的方法，该方法只采用一个参数。</span><span class="sxs-lookup"><span data-stu-id="7593b-2102">In order to use this overload of <xref:System.Linq.Expressions.Expression.ListInit%28System.Linq.Expressions.NewExpression%2CSystem.Linq.Expressions.Expression%5B%5D%29>, `newExpression`.Type or its base type must declare a single method named "Add" (case insensitive) that takes exactly one argument.</span></span> <span data-ttu-id="7593b-2103">参数的类型必须可从 `initializers`的第一个元素的 <xref:System.Linq.Expressions.Expression.Type%2A> 属性表示的类型中赋值。</span><span class="sxs-lookup"><span data-stu-id="7593b-2103">The type of the argument must be assignable from the type represented by the <xref:System.Linq.Expressions.Expression.Type%2A> property of the first element of `initializers`.</span></span>  
  
 <span data-ttu-id="7593b-2104">返回的 <xref:System.Linq.Expressions.ListInitExpression> 的 <xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> 属性包含 `initializers`的每个元素的类型 <xref:System.Linq.Expressions.ElementInit> 的一个元素。</span><span class="sxs-lookup"><span data-stu-id="7593b-2104">The <xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> property of the returned <xref:System.Linq.Expressions.ListInitExpression> contains one element of type <xref:System.Linq.Expressions.ElementInit> for each element of `initializers`.</span></span> <span data-ttu-id="7593b-2105"><xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> 的每个元素的 <xref:System.Linq.Expressions.ElementInit.Arguments%2A> 属性是一个单独的集合，其中包含 `initializers`的对应元素。</span><span class="sxs-lookup"><span data-stu-id="7593b-2105">The <xref:System.Linq.Expressions.ElementInit.Arguments%2A> property of each element of <xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> is a singleton collection that contains the corresponding element of `initializers`.</span></span> <span data-ttu-id="7593b-2106"><xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> 的每个元素的 <xref:System.Linq.Expressions.ElementInit.AddMethod%2A> 属性表示在 `newExpression`上发现的 add 方法。类型或其基类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-2106">The <xref:System.Linq.Expressions.ElementInit.AddMethod%2A> property of each element of <xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> represents the add method that was discovered on `newExpression`.Type or its base type.</span></span>  
  
 <span data-ttu-id="7593b-2107">生成的 <xref:System.Linq.Expressions.ListInitExpression> 的 <xref:System.Linq.Expressions.Expression.Type%2A> 属性等于 `newExpression`。类别.</span><span class="sxs-lookup"><span data-stu-id="7593b-2107">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.ListInitExpression> is equal to `newExpression`.Type.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="7593b-2108"><paramref name="newExpression" /> 或 <paramref name="initializers" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2108"><paramref name="newExpression" /> or <paramref name="initializers" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="7593b-2109">- 或 -</span><span class="sxs-lookup"><span data-stu-id="7593b-2109">-or-</span></span> 
<span data-ttu-id="7593b-2110"><paramref name="initializers" /> 的一个或多个元素为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2110">One or more elements of <paramref name="initializers" /> are <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="7593b-2111"><paramref name="newExpression" />.Type 不实现 <see cref="T:System.Collections.IEnumerable" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2111"><paramref name="newExpression" />.Type does not implement <see cref="T:System.Collections.IEnumerable" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="7593b-2112">没有在 <paramref name="newExpression" />.Type 或其基类型中声明的名为“Add”（不区分大小写）的实例方法。</span><span class="sxs-lookup"><span data-stu-id="7593b-2112">There is no instance method named "Add" (case insensitive) declared in <paramref name="newExpression" />.Type or its base type.</span></span>  
  
<span data-ttu-id="7593b-2113">- 或 -</span><span class="sxs-lookup"><span data-stu-id="7593b-2113">-or-</span></span> 
<span data-ttu-id="7593b-2114"><paramref name="newExpression" />.Type 或其基类型上的 add 方法不采用确切的参数。</span><span class="sxs-lookup"><span data-stu-id="7593b-2114">The add method on <paramref name="newExpression" />.Type or its base type does not take exactly one argument.</span></span>  
  
<span data-ttu-id="7593b-2115">- 或 -</span><span class="sxs-lookup"><span data-stu-id="7593b-2115">-or-</span></span> 
<span data-ttu-id="7593b-2116">由 <see cref="P:System.Linq.Expressions.Expression.Type" /> 的第一个元素的 <paramref name="initializers" /> 属性表示的类型不可分配给 <paramref name="newExpression" />.Type 或其基类型上 add 方法的参数类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-2116">The type represented by the <see cref="P:System.Linq.Expressions.Expression.Type" /> property of the first element of <paramref name="initializers" /> is not assignable to the argument type of the add method on <paramref name="newExpression" />.Type or its base type.</span></span>  
  
<span data-ttu-id="7593b-2117">- 或 -</span><span class="sxs-lookup"><span data-stu-id="7593b-2117">-or-</span></span> 
<span data-ttu-id="7593b-2118"><paramref name="newExpression" />.Type 和/或其基类型上存在多个名为“Add”（不区分大小写）且与参数兼容的方法。</span><span class="sxs-lookup"><span data-stu-id="7593b-2118">More than one argument-compatible method named "Add" (case-insensitive) exists on <paramref name="newExpression" />.Type and/or its base type.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ListInit">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ListInitExpression ListInit (System.Linq.Expressions.NewExpression newExpression, System.Reflection.MethodInfo addMethod, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; initializers);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ListInitExpression ListInit(class System.Linq.Expressions.NewExpression newExpression, class System.Reflection.MethodInfo addMethod, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; initializers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ListInit(System.Linq.Expressions.NewExpression,System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::ListInitExpression ^ ListInit(System::Linq::Expressions::NewExpression ^ newExpression, System::Reflection::MethodInfo ^ addMethod, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ initializers);" />
      <MemberSignature Language="F#" Value="static member ListInit : System.Linq.Expressions.NewExpression * System.Reflection.MethodInfo * seq&lt;System.Linq.Expressions.Expression&gt; -&gt; System.Linq.Expressions.ListInitExpression" Usage="System.Linq.Expressions.Expression.ListInit (newExpression, addMethod, initializers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ListInitExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="newExpression" Type="System.Linq.Expressions.NewExpression" />
        <Parameter Name="addMethod" Type="System.Reflection.MethodInfo" />
        <Parameter Name="initializers" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="newExpression"><span data-ttu-id="7593b-2119">要将 <see cref="T:System.Linq.Expressions.NewExpression" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2119">A <see cref="T:System.Linq.Expressions.NewExpression" /> to set the <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> property equal to.</span></span></param>
        <param name="addMethod"><span data-ttu-id="7593b-2120">一个 <see cref="T:System.Reflection.MethodInfo" />，表示名为“Add”（不区分大小写），用于将元素添加到集合的实例方法。</span><span class="sxs-lookup"><span data-stu-id="7593b-2120">A <see cref="T:System.Reflection.MethodInfo" /> that represents an instance method named "Add" (case insensitive), that adds an element to a collection.</span></span></param>
        <param name="initializers"><span data-ttu-id="7593b-2121">一个 <see cref="T:System.Collections.Generic.IEnumerable`1" />，包含用来填充 <see cref="T:System.Linq.Expressions.Expression" /> 集合的 <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" /> 对象。</span><span class="sxs-lookup"><span data-stu-id="7593b-2121">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.Expression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" /> collection.</span></span></param>
        <summary><span data-ttu-id="7593b-2122">创建一个使用指定方法将元素添加到集合中的 <see cref="T:System.Linq.Expressions.ListInitExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2122">Creates a <see cref="T:System.Linq.Expressions.ListInitExpression" /> that uses a specified method to add elements to a collection.</span></span></summary>
        <returns><span data-ttu-id="7593b-2123">一个 <see cref="T:System.Linq.Expressions.ListInitExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 属性等于 <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" />，并且其 <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> 属性设置为指定值。</span><span class="sxs-lookup"><span data-stu-id="7593b-2123">A <see cref="T:System.Linq.Expressions.ListInitExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" /> and the <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> property set to the specified value.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7593b-2124">`newExpression` 的 <xref:System.Linq.Expressions.Expression.Type%2A> 属性必须表示实现 <xref:System.Collections.IEnumerable>的类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-2124">The <xref:System.Linq.Expressions.Expression.Type%2A> property of `newExpression` must represent a type that implements <xref:System.Collections.IEnumerable>.</span></span>  
  
 <span data-ttu-id="7593b-2125">如果 `null``addMethod`，请 `newExpression`。类型或其基类型必须声明一个名为 "Add" （不区分大小写）的方法，该方法只采用一个参数。</span><span class="sxs-lookup"><span data-stu-id="7593b-2125">If `addMethod` is `null`, `newExpression`.Type or its base type must declare a single method named "Add" (case insensitive) that takes exactly one argument.</span></span> <span data-ttu-id="7593b-2126">如果未 `null``addMethod`，则它必须表示一个名为 "Add" （不区分大小写）且正好包含一个参数的实例方法。</span><span class="sxs-lookup"><span data-stu-id="7593b-2126">If `addMethod` is not `null`, it must represent an instance method named "Add" (case insensitive) that has exactly one parameter.</span></span> <span data-ttu-id="7593b-2127">`initializers` 的每个元素的 <xref:System.Linq.Expressions.Expression.Type%2A> 属性表示的类型必须可分配给 add 方法的参数类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-2127">The type represented by the <xref:System.Linq.Expressions.Expression.Type%2A> property of each element of `initializers` must be assignable to the argument type of the add method.</span></span>  
  
 <span data-ttu-id="7593b-2128">返回的 <xref:System.Linq.Expressions.ListInitExpression> 的 <xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> 属性包含 `initializers`的每个元素的类型 <xref:System.Linq.Expressions.ElementInit> 的一个元素。</span><span class="sxs-lookup"><span data-stu-id="7593b-2128">The <xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> property of the returned <xref:System.Linq.Expressions.ListInitExpression> contains one element of type <xref:System.Linq.Expressions.ElementInit> for each element of `initializers`.</span></span> <span data-ttu-id="7593b-2129"><xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> 的每个元素的 <xref:System.Linq.Expressions.ElementInit.Arguments%2A> 属性是一个单独的集合，其中包含 `initializers`的对应元素。</span><span class="sxs-lookup"><span data-stu-id="7593b-2129">The <xref:System.Linq.Expressions.ElementInit.Arguments%2A> property of each element of <xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> is a singleton collection that contains the corresponding element of `initializers`.</span></span> <span data-ttu-id="7593b-2130"><xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> 的每个元素的 <xref:System.Linq.Expressions.ElementInit.AddMethod%2A> 属性等于 `addMethod`。</span><span class="sxs-lookup"><span data-stu-id="7593b-2130">The <xref:System.Linq.Expressions.ElementInit.AddMethod%2A> property of each element of <xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> is equal to `addMethod`.</span></span>  
  
 <span data-ttu-id="7593b-2131">生成的 <xref:System.Linq.Expressions.ListInitExpression> 的 <xref:System.Linq.Expressions.Expression.Type%2A> 属性等于 `newExpression`。类别.</span><span class="sxs-lookup"><span data-stu-id="7593b-2131">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.ListInitExpression> is equal to `newExpression`.Type.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="7593b-2132"><paramref name="newExpression" /> 或 <paramref name="initializers" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2132"><paramref name="newExpression" /> or <paramref name="initializers" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="7593b-2133">- 或 -</span><span class="sxs-lookup"><span data-stu-id="7593b-2133">-or-</span></span> 
<span data-ttu-id="7593b-2134"><paramref name="initializers" /> 的一个或多个元素为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2134">One or more elements of <paramref name="initializers" /> are <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="7593b-2135"><paramref name="newExpression" />.Type 不实现 <see cref="T:System.Collections.IEnumerable" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2135"><paramref name="newExpression" />.Type does not implement <see cref="T:System.Collections.IEnumerable" />.</span></span>  
  
<span data-ttu-id="7593b-2136">- 或 -</span><span class="sxs-lookup"><span data-stu-id="7593b-2136">-or-</span></span> 
 <span data-ttu-id="7593b-2137"><paramref name="addMethod" /> 不为 <see langword="null" />，并且它不表示名为"Add"（不区分大小写）的正好带一个参数的实例方法。</span><span class="sxs-lookup"><span data-stu-id="7593b-2137"><paramref name="addMethod" /> is not <see langword="null" /> and it does not represent an instance method named "Add" (case insensitive) that takes exactly one argument.</span></span>  
  
<span data-ttu-id="7593b-2138">- 或 -</span><span class="sxs-lookup"><span data-stu-id="7593b-2138">-or-</span></span> 
 <span data-ttu-id="7593b-2139"><paramref name="addMethod" /> 不为 <see langword="null" />，并且 <see cref="P:System.Linq.Expressions.Expression.Type" /> 的一个或多个元素的 <paramref name="initializers" /> 属性所表示的类型不能赋给 <paramref name="addMethod" /> 所表示的方法的参数类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-2139"><paramref name="addMethod" /> is not <see langword="null" /> and the type represented by the <see cref="P:System.Linq.Expressions.Expression.Type" /> property of one or more elements of <paramref name="initializers" /> is not assignable to the argument type of the method that <paramref name="addMethod" /> represents.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="7593b-2140"><paramref name="addMethod" /> 为 <see langword="null" />，并且 <paramref name="newExpression" />.Type 或其基类型上不存在名为"Add"的带一个兼容类型的参数的任何实例方法。</span><span class="sxs-lookup"><span data-stu-id="7593b-2140"><paramref name="addMethod" /> is <see langword="null" /> and no instance method named "Add" that takes one type-compatible argument exists on <paramref name="newExpression" />.Type or its base type.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ListInit">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ListInitExpression ListInit (System.Linq.Expressions.NewExpression newExpression, System.Reflection.MethodInfo addMethod, params System.Linq.Expressions.Expression[] initializers);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ListInitExpression ListInit(class System.Linq.Expressions.NewExpression newExpression, class System.Reflection.MethodInfo addMethod, class System.Linq.Expressions.Expression[] initializers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ListInit(System.Linq.Expressions.NewExpression,System.Reflection.MethodInfo,System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::ListInitExpression ^ ListInit(System::Linq::Expressions::NewExpression ^ newExpression, System::Reflection::MethodInfo ^ addMethod, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ initializers);" />
      <MemberSignature Language="F#" Value="static member ListInit : System.Linq.Expressions.NewExpression * System.Reflection.MethodInfo * System.Linq.Expressions.Expression[] -&gt; System.Linq.Expressions.ListInitExpression" Usage="System.Linq.Expressions.Expression.ListInit (newExpression, addMethod, initializers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ListInitExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="newExpression" Type="System.Linq.Expressions.NewExpression" />
        <Parameter Name="addMethod" Type="System.Reflection.MethodInfo" />
        <Parameter Name="initializers" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="newExpression"><span data-ttu-id="7593b-2141">要将 <see cref="T:System.Linq.Expressions.NewExpression" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2141">A <see cref="T:System.Linq.Expressions.NewExpression" /> to set the <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> property equal to.</span></span></param>
        <param name="addMethod"><span data-ttu-id="7593b-2142">一个 <see cref="T:System.Reflection.MethodInfo" />，表示带一个参数，用于将元素添加到集合中的实例方法。</span><span class="sxs-lookup"><span data-stu-id="7593b-2142">A <see cref="T:System.Reflection.MethodInfo" /> that represents an instance method that takes one argument, that adds an element to a collection.</span></span></param>
        <param name="initializers"><span data-ttu-id="7593b-2143">用于填充 <see cref="T:System.Linq.Expressions.Expression" /> 集合的 <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" /> 对象的数组。</span><span class="sxs-lookup"><span data-stu-id="7593b-2143">An array of <see cref="T:System.Linq.Expressions.Expression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" /> collection.</span></span></param>
        <summary><span data-ttu-id="7593b-2144">创建一个使用指定方法将元素添加到集合中的 <see cref="T:System.Linq.Expressions.ListInitExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2144">Creates a <see cref="T:System.Linq.Expressions.ListInitExpression" /> that uses a specified method to add elements to a collection.</span></span></summary>
        <returns><span data-ttu-id="7593b-2145">一个 <see cref="T:System.Linq.Expressions.ListInitExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 属性等于 <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" />，并且其 <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> 属性设置为指定值。</span><span class="sxs-lookup"><span data-stu-id="7593b-2145">A <see cref="T:System.Linq.Expressions.ListInitExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" /> and the <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> property set to the specified value.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7593b-2146">`newExpression` 的 <xref:System.Linq.Expressions.Expression.Type%2A> 属性必须表示实现 <xref:System.Collections.IEnumerable>的类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-2146">The <xref:System.Linq.Expressions.Expression.Type%2A> property of `newExpression` must represent a type that implements <xref:System.Collections.IEnumerable>.</span></span>  
  
 <span data-ttu-id="7593b-2147">如果 `null``addMethod`，请 `newExpression`。类型或其基类型必须声明一个名为 "Add" （不区分大小写）的方法，该方法只采用一个参数。</span><span class="sxs-lookup"><span data-stu-id="7593b-2147">If `addMethod` is `null`, `newExpression`.Type or its base type must declare a single method named "Add" (case insensitive) that takes exactly one argument.</span></span> <span data-ttu-id="7593b-2148">如果未 `null``addMethod`，则它必须表示一个名为 "Add" （不区分大小写）且正好包含一个参数的实例方法。</span><span class="sxs-lookup"><span data-stu-id="7593b-2148">If `addMethod` is not `null`, it must represent an instance method named "Add" (case insensitive) that has exactly one parameter.</span></span> <span data-ttu-id="7593b-2149">`initializers` 的每个元素的 <xref:System.Linq.Expressions.Expression.Type%2A> 属性表示的类型必须可分配给 add 方法的参数类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-2149">The type represented by the <xref:System.Linq.Expressions.Expression.Type%2A> property of each element of `initializers` must be assignable to the argument type of the add method.</span></span>  
  
 <span data-ttu-id="7593b-2150">返回的 <xref:System.Linq.Expressions.ListInitExpression> 的 <xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> 属性包含 `initializers`的每个元素的类型 <xref:System.Linq.Expressions.ElementInit> 的一个元素。</span><span class="sxs-lookup"><span data-stu-id="7593b-2150">The <xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> property of the returned <xref:System.Linq.Expressions.ListInitExpression> contains one element of type <xref:System.Linq.Expressions.ElementInit> for each element of `initializers`.</span></span> <span data-ttu-id="7593b-2151"><xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> 的每个元素的 <xref:System.Linq.Expressions.ElementInit.Arguments%2A> 属性是一个单独的集合，其中包含 `initializers`的对应元素。</span><span class="sxs-lookup"><span data-stu-id="7593b-2151">The <xref:System.Linq.Expressions.ElementInit.Arguments%2A> property of each element of <xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> is a singleton collection that contains the corresponding element of `initializers`.</span></span> <span data-ttu-id="7593b-2152"><xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> 的每个元素的 <xref:System.Linq.Expressions.ElementInit.AddMethod%2A> 属性等于 `addMethod`。</span><span class="sxs-lookup"><span data-stu-id="7593b-2152">The <xref:System.Linq.Expressions.ElementInit.AddMethod%2A> property of each element of <xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> is equal to `addMethod`.</span></span>  
  
 <span data-ttu-id="7593b-2153">生成的 <xref:System.Linq.Expressions.ListInitExpression> 的 <xref:System.Linq.Expressions.Expression.Type%2A> 属性等于 `newExpression`。类别.</span><span class="sxs-lookup"><span data-stu-id="7593b-2153">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.ListInitExpression> is equal to `newExpression`.Type.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="7593b-2154"><paramref name="newExpression" /> 或 <paramref name="initializers" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2154"><paramref name="newExpression" /> or <paramref name="initializers" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="7593b-2155">- 或 -</span><span class="sxs-lookup"><span data-stu-id="7593b-2155">-or-</span></span> 
<span data-ttu-id="7593b-2156"><paramref name="initializers" /> 的一个或多个元素为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2156">One or more elements of <paramref name="initializers" /> are <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="7593b-2157"><paramref name="newExpression" />.Type 不实现 <see cref="T:System.Collections.IEnumerable" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2157"><paramref name="newExpression" />.Type does not implement <see cref="T:System.Collections.IEnumerable" />.</span></span>  
  
<span data-ttu-id="7593b-2158">- 或 -</span><span class="sxs-lookup"><span data-stu-id="7593b-2158">-or-</span></span> 
 <span data-ttu-id="7593b-2159"><paramref name="addMethod" /> 不为 <see langword="null" />，并且它不表示名为"Add"（不区分大小写）的正好带一个参数的实例方法。</span><span class="sxs-lookup"><span data-stu-id="7593b-2159"><paramref name="addMethod" /> is not <see langword="null" /> and it does not represent an instance method named "Add" (case insensitive) that takes exactly one argument.</span></span>  
  
<span data-ttu-id="7593b-2160">- 或 -</span><span class="sxs-lookup"><span data-stu-id="7593b-2160">-or-</span></span> 
 <span data-ttu-id="7593b-2161"><paramref name="addMethod" /> 不为 <see langword="null" />，并且 <see cref="P:System.Linq.Expressions.Expression.Type" /> 的一个或多个元素的 <paramref name="initializers" /> 属性所表示的类型不能赋给 <paramref name="addMethod" /> 所表示的方法的参数类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-2161"><paramref name="addMethod" /> is not <see langword="null" /> and the type represented by the <see cref="P:System.Linq.Expressions.Expression.Type" /> property of one or more elements of <paramref name="initializers" /> is not assignable to the argument type of the method that <paramref name="addMethod" /> represents.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="7593b-2162"><paramref name="addMethod" /> 为 <see langword="null" />，并且 <paramref name="newExpression" />.Type 或其基类型上不存在名为"Add"的带一个兼容类型的参数的任何实例方法。</span><span class="sxs-lookup"><span data-stu-id="7593b-2162"><paramref name="addMethod" /> is <see langword="null" /> and no instance method named "Add" that takes one type-compatible argument exists on <paramref name="newExpression" />.Type or its base type.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Loop">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="7593b-2163">创建一个 <see cref="T:System.Linq.Expressions.LoopExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2163">Creates a <see cref="T:System.Linq.Expressions.LoopExpression" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Loop">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LoopExpression Loop (System.Linq.Expressions.Expression body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LoopExpression Loop(class System.Linq.Expressions.Expression body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Loop(System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Loop (body As Expression) As LoopExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LoopExpression ^ Loop(System::Linq::Expressions::Expression ^ body);" />
      <MemberSignature Language="F#" Value="static member Loop : System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.LoopExpression" Usage="System.Linq.Expressions.Expression.Loop body" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LoopExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="body"><span data-ttu-id="7593b-2164">循环体。</span><span class="sxs-lookup"><span data-stu-id="7593b-2164">The body of the loop.</span></span></param>
        <summary><span data-ttu-id="7593b-2165">创建具有给定主体的 <see cref="T:System.Linq.Expressions.LoopExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2165">Creates a <see cref="T:System.Linq.Expressions.LoopExpression" /> with the given body.</span></span></summary>
        <returns><span data-ttu-id="7593b-2166">创建的 <see cref="T:System.Linq.Expressions.LoopExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2166">The created <see cref="T:System.Linq.Expressions.LoopExpression" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Loop">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LoopExpression Loop (System.Linq.Expressions.Expression body, System.Linq.Expressions.LabelTarget break);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LoopExpression Loop(class System.Linq.Expressions.Expression body, class System.Linq.Expressions.LabelTarget break) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Loop(System.Linq.Expressions.Expression,System.Linq.Expressions.LabelTarget)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Loop (body As Expression, break As LabelTarget) As LoopExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LoopExpression ^ Loop(System::Linq::Expressions::Expression ^ body, System::Linq::Expressions::LabelTarget ^ break);" />
      <MemberSignature Language="F#" Value="static member Loop : System.Linq.Expressions.Expression * System.Linq.Expressions.LabelTarget -&gt; System.Linq.Expressions.LoopExpression" Usage="System.Linq.Expressions.Expression.Loop (body, break)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LoopExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="break" Type="System.Linq.Expressions.LabelTarget" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="body"><span data-ttu-id="7593b-2167">循环体。</span><span class="sxs-lookup"><span data-stu-id="7593b-2167">The body of the loop.</span></span></param>
        <param name="break"><span data-ttu-id="7593b-2168">循环体使用的中断目标。</span><span class="sxs-lookup"><span data-stu-id="7593b-2168">The break target used by the loop body.</span></span></param>
        <summary><span data-ttu-id="7593b-2169">创建具有给定主体和中断目标的 <see cref="T:System.Linq.Expressions.LoopExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2169">Creates a <see cref="T:System.Linq.Expressions.LoopExpression" /> with the given body and break target.</span></span></summary>
        <returns><span data-ttu-id="7593b-2170">创建的 <see cref="T:System.Linq.Expressions.LoopExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2170">The created <see cref="T:System.Linq.Expressions.LoopExpression" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="7593b-2171">下面的示例演示如何创建包含 <xref:System.Linq.Expressions.LoopExpression> 对象的块表达式。</span><span class="sxs-lookup"><span data-stu-id="7593b-2171">The following example demonstrates how to create a block expression that contains a <xref:System.Linq.Expressions.LoopExpression> object.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#44](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#44)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#44](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#44)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Loop">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LoopExpression Loop (System.Linq.Expressions.Expression body, System.Linq.Expressions.LabelTarget break, System.Linq.Expressions.LabelTarget continue);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LoopExpression Loop(class System.Linq.Expressions.Expression body, class System.Linq.Expressions.LabelTarget break, class System.Linq.Expressions.LabelTarget continue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Loop(System.Linq.Expressions.Expression,System.Linq.Expressions.LabelTarget,System.Linq.Expressions.LabelTarget)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Loop (body As Expression, break As LabelTarget, continue As LabelTarget) As LoopExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LoopExpression ^ Loop(System::Linq::Expressions::Expression ^ body, System::Linq::Expressions::LabelTarget ^ break, System::Linq::Expressions::LabelTarget ^ continue);" />
      <MemberSignature Language="F#" Value="static member Loop : System.Linq.Expressions.Expression * System.Linq.Expressions.LabelTarget * System.Linq.Expressions.LabelTarget -&gt; System.Linq.Expressions.LoopExpression" Usage="System.Linq.Expressions.Expression.Loop (body, break, continue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LoopExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="break" Type="System.Linq.Expressions.LabelTarget" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="continue" Type="System.Linq.Expressions.LabelTarget" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="body"><span data-ttu-id="7593b-2172">循环体。</span><span class="sxs-lookup"><span data-stu-id="7593b-2172">The body of the loop.</span></span></param>
        <param name="break"><span data-ttu-id="7593b-2173">循环体使用的中断目标。</span><span class="sxs-lookup"><span data-stu-id="7593b-2173">The break target used by the loop body.</span></span></param>
        <param name="continue"><span data-ttu-id="7593b-2174">循环体使用的继续目标。</span><span class="sxs-lookup"><span data-stu-id="7593b-2174">The continue target used by the loop body.</span></span></param>
        <summary><span data-ttu-id="7593b-2175">创建具有给定主体的 <see cref="T:System.Linq.Expressions.LoopExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2175">Creates a <see cref="T:System.Linq.Expressions.LoopExpression" /> with the given body.</span></span></summary>
        <returns><span data-ttu-id="7593b-2176">创建的 <see cref="T:System.Linq.Expressions.LoopExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2176">The created <see cref="T:System.Linq.Expressions.LoopExpression" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="MakeBinary">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="7593b-2177">通过调用适当的工厂方法来创建一个 <see cref="T:System.Linq.Expressions.BinaryExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2177">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> by calling the appropriate factory method.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MakeBinary">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression MakeBinary (System.Linq.Expressions.ExpressionType binaryType, System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression MakeBinary(valuetype System.Linq.Expressions.ExpressionType binaryType, class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MakeBinary(System.Linq.Expressions.ExpressionType,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MakeBinary (binaryType As ExpressionType, left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ MakeBinary(System::Linq::Expressions::ExpressionType binaryType, System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member MakeBinary : System.Linq.Expressions.ExpressionType * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.MakeBinary (binaryType, left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binaryType" Type="System.Linq.Expressions.ExpressionType" />
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="binaryType"><span data-ttu-id="7593b-2178">指定二元运算类型的 <see cref="T:System.Linq.Expressions.ExpressionType" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2178">The <see cref="T:System.Linq.Expressions.ExpressionType" /> that specifies the type of binary operation.</span></span></param>
        <param name="left"><span data-ttu-id="7593b-2179">一个表示左操作数的 <see cref="T:System.Linq.Expressions.Expression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2179">An <see cref="T:System.Linq.Expressions.Expression" /> that represents the left operand.</span></span></param>
        <param name="right"><span data-ttu-id="7593b-2180">一个表示右操作数的 <see cref="T:System.Linq.Expressions.Expression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2180">An <see cref="T:System.Linq.Expressions.Expression" /> that represents the right operand.</span></span></param>
        <summary><span data-ttu-id="7593b-2181">在给定左操作数和右操作数的情况下，通过调用适当的工厂方法来创建一个 <see cref="T:System.Linq.Expressions.BinaryExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2181">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" />, given the left and right operands, by calling an appropriate factory method.</span></span></summary>
        <returns><span data-ttu-id="7593b-2182">通过调用适当的工厂方法生成的 <see cref="T:System.Linq.Expressions.BinaryExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2182">The <see cref="T:System.Linq.Expressions.BinaryExpression" /> that results from calling the appropriate factory method.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7593b-2183">`binaryType` 参数确定此方法调用的 <xref:System.Linq.Expressions.BinaryExpression> 工厂方法。</span><span class="sxs-lookup"><span data-stu-id="7593b-2183">The `binaryType` parameter determines which <xref:System.Linq.Expressions.BinaryExpression> factory method this method calls.</span></span> <span data-ttu-id="7593b-2184">例如，如果 <xref:System.Linq.Expressions.ExpressionType.Subtract>`binaryType`，则此方法将调用 <xref:System.Linq.Expressions.Expression.Subtract%2A>。</span><span class="sxs-lookup"><span data-stu-id="7593b-2184">For example, if `binaryType` is <xref:System.Linq.Expressions.ExpressionType.Subtract>, this method invokes <xref:System.Linq.Expressions.Expression.Subtract%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="7593b-2185">下面的示例演示如何使用 <xref:System.Linq.Expressions.Expression.MakeBinary%28System.Linq.Expressions.ExpressionType%2CSystem.Linq.Expressions.Expression%2CSystem.Linq.Expressions.Expression%29> 方法创建一个表示一个数字与另一个数的减法的 <xref:System.Linq.Expressions.BinaryExpression>。</span><span class="sxs-lookup"><span data-stu-id="7593b-2185">The following example demonstrates how to use the <xref:System.Linq.Expressions.Expression.MakeBinary%28System.Linq.Expressions.ExpressionType%2CSystem.Linq.Expressions.Expression%2CSystem.Linq.Expressions.Expression%29> method to create a <xref:System.Linq.Expressions.BinaryExpression> that represents the subtraction of one number from another.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.Expression#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#8)]
 [!code-vb[System.Linq.Expressions.Expression#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="7593b-2186"><paramref name="binaryType" /> 与二元表达式节点不对应。</span><span class="sxs-lookup"><span data-stu-id="7593b-2186"><paramref name="binaryType" /> does not correspond to a binary expression node.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="7593b-2187"><paramref name="left" /> 或 <paramref name="right" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2187"><paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="MakeBinary">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression MakeBinary (System.Linq.Expressions.ExpressionType binaryType, System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, bool liftToNull, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression MakeBinary(valuetype System.Linq.Expressions.ExpressionType binaryType, class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, bool liftToNull, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MakeBinary(System.Linq.Expressions.ExpressionType,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MakeBinary (binaryType As ExpressionType, left As Expression, right As Expression, liftToNull As Boolean, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ MakeBinary(System::Linq::Expressions::ExpressionType binaryType, System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, bool liftToNull, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member MakeBinary : System.Linq.Expressions.ExpressionType * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * bool * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.MakeBinary (binaryType, left, right, liftToNull, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binaryType" Type="System.Linq.Expressions.ExpressionType" />
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="liftToNull" Type="System.Boolean" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="binaryType"><span data-ttu-id="7593b-2188">指定二元运算类型的 <see cref="T:System.Linq.Expressions.ExpressionType" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2188">The <see cref="T:System.Linq.Expressions.ExpressionType" /> that specifies the type of binary operation.</span></span></param>
        <param name="left"><span data-ttu-id="7593b-2189">一个表示左操作数的 <see cref="T:System.Linq.Expressions.Expression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2189">An <see cref="T:System.Linq.Expressions.Expression" /> that represents the left operand.</span></span></param>
        <param name="right"><span data-ttu-id="7593b-2190">一个表示右操作数的 <see cref="T:System.Linq.Expressions.Expression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2190">An <see cref="T:System.Linq.Expressions.Expression" /> that represents the right operand.</span></span></param>
        <param name="liftToNull"><span data-ttu-id="7593b-2191">若要将 <see langword="true" /> 设置为 <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" />，则为 <see langword="true" />；若要将 <see langword="false" /> 设置为 <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" />，则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2191"><see langword="true" /> to set <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> to <see langword="true" />; <see langword="false" /> to set <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> to <see langword="false" />.</span></span></param>
        <param name="method"><span data-ttu-id="7593b-2192">一个指定实现方法的 <see cref="T:System.Reflection.MethodInfo" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2192">A <see cref="T:System.Reflection.MethodInfo" /> that specifies the implementing method.</span></span></param>
        <summary><span data-ttu-id="7593b-2193">在给定左操作数、右操作数和实现方法的情况下，通过调用适当的工厂方法来创建一个 <see cref="T:System.Linq.Expressions.BinaryExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2193">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" />, given the left operand, right operand and implementing method, by calling the appropriate factory method.</span></span></summary>
        <returns><span data-ttu-id="7593b-2194">通过调用适当的工厂方法生成的 <see cref="T:System.Linq.Expressions.BinaryExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2194">The <see cref="T:System.Linq.Expressions.BinaryExpression" /> that results from calling the appropriate factory method.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7593b-2195">`binaryType` 参数确定此方法将调用的 <xref:System.Linq.Expressions.BinaryExpression> 工厂方法。</span><span class="sxs-lookup"><span data-stu-id="7593b-2195">The `binaryType` parameter determines which <xref:System.Linq.Expressions.BinaryExpression> factory method this method will call.</span></span> <span data-ttu-id="7593b-2196">例如，如果 <xref:System.Linq.Expressions.ExpressionType.Subtract>`binaryType`，则此方法将调用 <xref:System.Linq.Expressions.Expression.Subtract%2A>。</span><span class="sxs-lookup"><span data-stu-id="7593b-2196">For example, if `binaryType` is <xref:System.Linq.Expressions.ExpressionType.Subtract>, this method invokes <xref:System.Linq.Expressions.Expression.Subtract%2A>.</span></span> <span data-ttu-id="7593b-2197">如果适当的工厂方法没有相应的参数，则将忽略 `liftToNull` 和 `method` 参数。</span><span class="sxs-lookup"><span data-stu-id="7593b-2197">The `liftToNull` and `method` parameters are ignored if the appropriate factory method does not have a corresponding parameter.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="7593b-2198"><paramref name="binaryType" /> 与二元表达式节点不对应。</span><span class="sxs-lookup"><span data-stu-id="7593b-2198"><paramref name="binaryType" /> does not correspond to a binary expression node.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="7593b-2199"><paramref name="left" /> 或 <paramref name="right" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2199"><paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="MakeBinary">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression MakeBinary (System.Linq.Expressions.ExpressionType binaryType, System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, bool liftToNull, System.Reflection.MethodInfo method, System.Linq.Expressions.LambdaExpression conversion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression MakeBinary(valuetype System.Linq.Expressions.ExpressionType binaryType, class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, bool liftToNull, class System.Reflection.MethodInfo method, class System.Linq.Expressions.LambdaExpression conversion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MakeBinary(System.Linq.Expressions.ExpressionType,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MakeBinary (binaryType As ExpressionType, left As Expression, right As Expression, liftToNull As Boolean, method As MethodInfo, conversion As LambdaExpression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ MakeBinary(System::Linq::Expressions::ExpressionType binaryType, System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, bool liftToNull, System::Reflection::MethodInfo ^ method, System::Linq::Expressions::LambdaExpression ^ conversion);" />
      <MemberSignature Language="F#" Value="static member MakeBinary : System.Linq.Expressions.ExpressionType * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * bool * System.Reflection.MethodInfo * System.Linq.Expressions.LambdaExpression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.MakeBinary (binaryType, left, right, liftToNull, method, conversion)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binaryType" Type="System.Linq.Expressions.ExpressionType" />
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="liftToNull" Type="System.Boolean" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="conversion" Type="System.Linq.Expressions.LambdaExpression" />
      </Parameters>
      <Docs>
        <param name="binaryType"><span data-ttu-id="7593b-2200">指定二元运算类型的 <see cref="T:System.Linq.Expressions.ExpressionType" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2200">The <see cref="T:System.Linq.Expressions.ExpressionType" /> that specifies the type of binary operation.</span></span></param>
        <param name="left"><span data-ttu-id="7593b-2201">一个表示左操作数的 <see cref="T:System.Linq.Expressions.Expression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2201">An <see cref="T:System.Linq.Expressions.Expression" /> that represents the left operand.</span></span></param>
        <param name="right"><span data-ttu-id="7593b-2202">一个表示右操作数的 <see cref="T:System.Linq.Expressions.Expression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2202">An <see cref="T:System.Linq.Expressions.Expression" /> that represents the right operand.</span></span></param>
        <param name="liftToNull"><span data-ttu-id="7593b-2203">若要将 <see langword="true" /> 设置为 <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" />，则为 <see langword="true" />；若要将 <see langword="false" /> 设置为 <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" />，则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2203"><see langword="true" /> to set <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> to <see langword="true" />; <see langword="false" /> to set <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> to <see langword="false" />.</span></span></param>
        <param name="method"><span data-ttu-id="7593b-2204">一个指定实现方法的 <see cref="T:System.Reflection.MethodInfo" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2204">A <see cref="T:System.Reflection.MethodInfo" /> that specifies the implementing method.</span></span></param>
        <param name="conversion"><span data-ttu-id="7593b-2205">一个表示类型转换函数的 <see cref="T:System.Linq.Expressions.LambdaExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2205">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> that represents a type conversion function.</span></span> <span data-ttu-id="7593b-2206">只有在 <paramref name="binaryType" /> 为 <see cref="F:System.Linq.Expressions.ExpressionType.Coalesce" /> 或复合赋值时，才使用此参数。</span><span class="sxs-lookup"><span data-stu-id="7593b-2206">This parameter is used only if <paramref name="binaryType" /> is <see cref="F:System.Linq.Expressions.ExpressionType.Coalesce" /> or compound assignment.</span></span></param>
        <summary><span data-ttu-id="7593b-2207">在给定左操作数、右操作数、实现方法和类型转换函数的情况下，通过调用适当的工厂方法来创建一个 <see cref="T:System.Linq.Expressions.BinaryExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2207">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" />, given the left operand, right operand, implementing method and type conversion function, by calling the appropriate factory method.</span></span></summary>
        <returns><span data-ttu-id="7593b-2208">通过调用适当的工厂方法生成的 <see cref="T:System.Linq.Expressions.BinaryExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2208">The <see cref="T:System.Linq.Expressions.BinaryExpression" /> that results from calling the appropriate factory method.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7593b-2209">`binaryType` 参数确定此方法将调用的 <xref:System.Linq.Expressions.BinaryExpression> 工厂方法。</span><span class="sxs-lookup"><span data-stu-id="7593b-2209">The `binaryType` parameter determines which <xref:System.Linq.Expressions.BinaryExpression> factory method this method will call.</span></span> <span data-ttu-id="7593b-2210">例如，如果 <xref:System.Linq.Expressions.ExpressionType.Subtract>`binaryType`，则此方法将调用 <xref:System.Linq.Expressions.Expression.Subtract%2A>。</span><span class="sxs-lookup"><span data-stu-id="7593b-2210">For example, if `binaryType` is <xref:System.Linq.Expressions.ExpressionType.Subtract>, this method invokes <xref:System.Linq.Expressions.Expression.Subtract%2A>.</span></span> <span data-ttu-id="7593b-2211">如果适当的工厂方法没有对应的参数，则将忽略 `liftToNull`、`method` 和 `conversion` 参数。</span><span class="sxs-lookup"><span data-stu-id="7593b-2211">The `liftToNull`, `method` and `conversion` parameters are ignored if the appropriate factory method does not have a corresponding parameter.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="7593b-2212"><paramref name="binaryType" /> 与二元表达式节点不对应。</span><span class="sxs-lookup"><span data-stu-id="7593b-2212"><paramref name="binaryType" /> does not correspond to a binary expression node.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="7593b-2213"><paramref name="left" /> 或 <paramref name="right" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2213"><paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="MakeCatchBlock">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.CatchBlock MakeCatchBlock (Type type, System.Linq.Expressions.ParameterExpression variable, System.Linq.Expressions.Expression body, System.Linq.Expressions.Expression filter);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.CatchBlock MakeCatchBlock(class System.Type type, class System.Linq.Expressions.ParameterExpression variable, class System.Linq.Expressions.Expression body, class System.Linq.Expressions.Expression filter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MakeCatchBlock(System.Type,System.Linq.Expressions.ParameterExpression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::CatchBlock ^ MakeCatchBlock(Type ^ type, System::Linq::Expressions::ParameterExpression ^ variable, System::Linq::Expressions::Expression ^ body, System::Linq::Expressions::Expression ^ filter);" />
      <MemberSignature Language="F#" Value="static member MakeCatchBlock : Type * System.Linq.Expressions.ParameterExpression * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.CatchBlock" Usage="System.Linq.Expressions.Expression.MakeCatchBlock (type, variable, body, filter)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.CatchBlock</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="variable" Type="System.Linq.Expressions.ParameterExpression" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="filter" Type="System.Linq.Expressions.Expression" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="type"><span data-ttu-id="7593b-2214">此 <see cref="P:System.Linq.Expressions.Expression.Type" /> 将处理的 <see cref="T:System.Exception" /> 的 <see cref="T:System.Linq.Expressions.CatchBlock" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2214">The <see cref="P:System.Linq.Expressions.Expression.Type" /> of <see cref="T:System.Exception" /> this <see cref="T:System.Linq.Expressions.CatchBlock" /> will handle.</span></span></param>
        <param name="variable"><span data-ttu-id="7593b-2215">一个 <see cref="T:System.Linq.Expressions.ParameterExpression" />，它表示对此处理程序捕获的 <see cref="T:System.Exception" /> 对象的引用。</span><span class="sxs-lookup"><span data-stu-id="7593b-2215">A <see cref="T:System.Linq.Expressions.ParameterExpression" /> representing a reference to the <see cref="T:System.Exception" /> object caught by this handler.</span></span></param>
        <param name="body"><span data-ttu-id="7593b-2216">catch 语句的主体。</span><span class="sxs-lookup"><span data-stu-id="7593b-2216">The body of the catch statement.</span></span></param>
        <param name="filter"><span data-ttu-id="7593b-2217"><see cref="T:System.Exception" /> 筛选器的主体。</span><span class="sxs-lookup"><span data-stu-id="7593b-2217">The body of the <see cref="T:System.Exception" /> filter.</span></span></param>
        <summary><span data-ttu-id="7593b-2218">创建一个表示具有指定元素的 catch 语句的 <see cref="T:System.Linq.Expressions.CatchBlock" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2218">Creates a <see cref="T:System.Linq.Expressions.CatchBlock" /> representing a catch statement with the specified elements.</span></span></summary>
        <returns><span data-ttu-id="7593b-2219">创建的 <see cref="T:System.Linq.Expressions.CatchBlock" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2219">The created <see cref="T:System.Linq.Expressions.CatchBlock" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7593b-2220">`type` 必须为非 null，并且匹配 `variable` 的类型（如果已提供）。</span><span class="sxs-lookup"><span data-stu-id="7593b-2220">`type` must be non-null and match the type of `variable` (if it is supplied).</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="MakeDynamic">
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="7593b-2221">创建一个表示动态操作的 <see cref="T:System.Linq.Expressions.DynamicExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2221">Creates a <see cref="T:System.Linq.Expressions.DynamicExpression" /> that represents a dynamic operation.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MakeDynamic">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.DynamicExpression MakeDynamic (Type delegateType, System.Runtime.CompilerServices.CallSiteBinder binder, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.DynamicExpression MakeDynamic(class System.Type delegateType, class System.Runtime.CompilerServices.CallSiteBinder binder, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MakeDynamic(System.Type,System.Runtime.CompilerServices.CallSiteBinder,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MakeDynamic (delegateType As Type, binder As CallSiteBinder, arguments As IEnumerable(Of Expression)) As DynamicExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::DynamicExpression ^ MakeDynamic(Type ^ delegateType, System::Runtime::CompilerServices::CallSiteBinder ^ binder, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberSignature Language="F#" Value="static member MakeDynamic : Type * System.Runtime.CompilerServices.CallSiteBinder * seq&lt;System.Linq.Expressions.Expression&gt; -&gt; System.Linq.Expressions.DynamicExpression" Usage="System.Linq.Expressions.Expression.MakeDynamic (delegateType, binder, arguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.DynamicExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegateType" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="binder" Type="System.Runtime.CompilerServices.CallSiteBinder" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="arguments" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="delegateType"><span data-ttu-id="7593b-2222"><see cref="T:System.Runtime.CompilerServices.CallSite" /> 使用的委托的类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-2222">The type of the delegate used by the <see cref="T:System.Runtime.CompilerServices.CallSite" />.</span></span></param>
        <param name="binder"><span data-ttu-id="7593b-2223">动态操作的运行时联编程序。</span><span class="sxs-lookup"><span data-stu-id="7593b-2223">The runtime binder for the dynamic operation.</span></span></param>
        <param name="arguments"><span data-ttu-id="7593b-2224">动态操作的自变量。</span><span class="sxs-lookup"><span data-stu-id="7593b-2224">The arguments to the dynamic operation.</span></span></param>
        <summary><span data-ttu-id="7593b-2225">创建一个 <see cref="T:System.Linq.Expressions.DynamicExpression" />，它表示由提供的 <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> 绑定的动态操作。</span><span class="sxs-lookup"><span data-stu-id="7593b-2225">Creates a <see cref="T:System.Linq.Expressions.DynamicExpression" /> that represents a dynamic operation bound by the provided <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" />.</span></span></summary>
        <returns><span data-ttu-id="7593b-2226">一个 <see cref="T:System.Linq.Expressions.DynamicExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 等于 <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" />，并且其 <see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" />、<see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> 和 <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> 均设置为指定的值。</span><span class="sxs-lookup"><span data-stu-id="7593b-2226">A <see cref="T:System.Linq.Expressions.DynamicExpression" /> that has <see cref="P:System.Linq.Expressions.Expression.NodeType" /> equal to <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> and has the <see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" />, <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" />, and <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MakeDynamic">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.DynamicExpression MakeDynamic (Type delegateType, System.Runtime.CompilerServices.CallSiteBinder binder, System.Linq.Expressions.Expression arg0);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.DynamicExpression MakeDynamic(class System.Type delegateType, class System.Runtime.CompilerServices.CallSiteBinder binder, class System.Linq.Expressions.Expression arg0) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MakeDynamic(System.Type,System.Runtime.CompilerServices.CallSiteBinder,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MakeDynamic (delegateType As Type, binder As CallSiteBinder, arg0 As Expression) As DynamicExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::DynamicExpression ^ MakeDynamic(Type ^ delegateType, System::Runtime::CompilerServices::CallSiteBinder ^ binder, System::Linq::Expressions::Expression ^ arg0);" />
      <MemberSignature Language="F#" Value="static member MakeDynamic : Type * System.Runtime.CompilerServices.CallSiteBinder * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.DynamicExpression" Usage="System.Linq.Expressions.Expression.MakeDynamic (delegateType, binder, arg0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.DynamicExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegateType" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="binder" Type="System.Runtime.CompilerServices.CallSiteBinder" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="delegateType"><span data-ttu-id="7593b-2227"><see cref="T:System.Runtime.CompilerServices.CallSite" /> 使用的委托的类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-2227">The type of the delegate used by the <see cref="T:System.Runtime.CompilerServices.CallSite" />.</span></span></param>
        <param name="binder"><span data-ttu-id="7593b-2228">动态操作的运行时联编程序。</span><span class="sxs-lookup"><span data-stu-id="7593b-2228">The runtime binder for the dynamic operation.</span></span></param>
        <param name="arg0"><span data-ttu-id="7593b-2229">动态操作的参数。</span><span class="sxs-lookup"><span data-stu-id="7593b-2229">The argument to the dynamic operation.</span></span></param>
        <summary><span data-ttu-id="7593b-2230">创建一个 <see cref="T:System.Linq.Expressions.DynamicExpression" />，它表示由提供的 <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> 和一个参数绑定的动态操作。</span><span class="sxs-lookup"><span data-stu-id="7593b-2230">Creates a <see cref="T:System.Linq.Expressions.DynamicExpression" /> that represents a dynamic operation bound by the provided <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> and one argument.</span></span></summary>
        <returns><span data-ttu-id="7593b-2231">一个 <see cref="T:System.Linq.Expressions.DynamicExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 等于 <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" />，并且其 <see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" />、<see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> 和 <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> 均设置为指定的值。</span><span class="sxs-lookup"><span data-stu-id="7593b-2231">A <see cref="T:System.Linq.Expressions.DynamicExpression" /> that has <see cref="P:System.Linq.Expressions.Expression.NodeType" /> equal to <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> and has the <see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" />, <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" />, and <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MakeDynamic">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.DynamicExpression MakeDynamic (Type delegateType, System.Runtime.CompilerServices.CallSiteBinder binder, params System.Linq.Expressions.Expression[] arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.DynamicExpression MakeDynamic(class System.Type delegateType, class System.Runtime.CompilerServices.CallSiteBinder binder, class System.Linq.Expressions.Expression[] arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MakeDynamic(System.Type,System.Runtime.CompilerServices.CallSiteBinder,System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MakeDynamic (delegateType As Type, binder As CallSiteBinder, ParamArray arguments As Expression()) As DynamicExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::DynamicExpression ^ MakeDynamic(Type ^ delegateType, System::Runtime::CompilerServices::CallSiteBinder ^ binder, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberSignature Language="F#" Value="static member MakeDynamic : Type * System.Runtime.CompilerServices.CallSiteBinder * System.Linq.Expressions.Expression[] -&gt; System.Linq.Expressions.DynamicExpression" Usage="System.Linq.Expressions.Expression.MakeDynamic (delegateType, binder, arguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.DynamicExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegateType" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="binder" Type="System.Runtime.CompilerServices.CallSiteBinder" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="arguments" Type="System.Linq.Expressions.Expression[]" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="delegateType"><span data-ttu-id="7593b-2232"><see cref="T:System.Runtime.CompilerServices.CallSite" /> 使用的委托的类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-2232">The type of the delegate used by the <see cref="T:System.Runtime.CompilerServices.CallSite" />.</span></span></param>
        <param name="binder"><span data-ttu-id="7593b-2233">动态操作的运行时联编程序。</span><span class="sxs-lookup"><span data-stu-id="7593b-2233">The runtime binder for the dynamic operation.</span></span></param>
        <param name="arguments"><span data-ttu-id="7593b-2234">动态操作的自变量。</span><span class="sxs-lookup"><span data-stu-id="7593b-2234">The arguments to the dynamic operation.</span></span></param>
        <summary><span data-ttu-id="7593b-2235">创建一个 <see cref="T:System.Linq.Expressions.DynamicExpression" />，它表示由提供的 <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> 绑定的动态操作。</span><span class="sxs-lookup"><span data-stu-id="7593b-2235">Creates a <see cref="T:System.Linq.Expressions.DynamicExpression" /> that represents a dynamic operation bound by the provided <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" />.</span></span></summary>
        <returns><span data-ttu-id="7593b-2236">一个 <see cref="T:System.Linq.Expressions.DynamicExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 等于 <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" />，并且其 <see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" />、<see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> 和 <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> 均设置为指定的值。</span><span class="sxs-lookup"><span data-stu-id="7593b-2236">A <see cref="T:System.Linq.Expressions.DynamicExpression" /> that has <see cref="P:System.Linq.Expressions.Expression.NodeType" /> equal to <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> and has the <see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" />, <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" />, and <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MakeDynamic">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.DynamicExpression MakeDynamic (Type delegateType, System.Runtime.CompilerServices.CallSiteBinder binder, System.Linq.Expressions.Expression arg0, System.Linq.Expressions.Expression arg1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.DynamicExpression MakeDynamic(class System.Type delegateType, class System.Runtime.CompilerServices.CallSiteBinder binder, class System.Linq.Expressions.Expression arg0, class System.Linq.Expressions.Expression arg1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MakeDynamic(System.Type,System.Runtime.CompilerServices.CallSiteBinder,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MakeDynamic (delegateType As Type, binder As CallSiteBinder, arg0 As Expression, arg1 As Expression) As DynamicExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::DynamicExpression ^ MakeDynamic(Type ^ delegateType, System::Runtime::CompilerServices::CallSiteBinder ^ binder, System::Linq::Expressions::Expression ^ arg0, System::Linq::Expressions::Expression ^ arg1);" />
      <MemberSignature Language="F#" Value="static member MakeDynamic : Type * System.Runtime.CompilerServices.CallSiteBinder * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.DynamicExpression" Usage="System.Linq.Expressions.Expression.MakeDynamic (delegateType, binder, arg0, arg1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.DynamicExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegateType" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="binder" Type="System.Runtime.CompilerServices.CallSiteBinder" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="arg1" Type="System.Linq.Expressions.Expression" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="delegateType"><span data-ttu-id="7593b-2237"><see cref="T:System.Runtime.CompilerServices.CallSite" /> 使用的委托的类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-2237">The type of the delegate used by the <see cref="T:System.Runtime.CompilerServices.CallSite" />.</span></span></param>
        <param name="binder"><span data-ttu-id="7593b-2238">动态操作的运行时联编程序。</span><span class="sxs-lookup"><span data-stu-id="7593b-2238">The runtime binder for the dynamic operation.</span></span></param>
        <param name="arg0"><span data-ttu-id="7593b-2239">动态操作的第一个参数。</span><span class="sxs-lookup"><span data-stu-id="7593b-2239">The first argument to the dynamic operation.</span></span></param>
        <param name="arg1"><span data-ttu-id="7593b-2240">动态操作的第二个自变量。</span><span class="sxs-lookup"><span data-stu-id="7593b-2240">The second argument to the dynamic operation.</span></span></param>
        <summary><span data-ttu-id="7593b-2241">创建一个 <see cref="T:System.Linq.Expressions.DynamicExpression" />，它表示由提供的 <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> 和两个自变量绑定的动态操作。</span><span class="sxs-lookup"><span data-stu-id="7593b-2241">Creates a <see cref="T:System.Linq.Expressions.DynamicExpression" /> that represents a dynamic operation bound by the provided <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> and two arguments.</span></span></summary>
        <returns><span data-ttu-id="7593b-2242">一个 <see cref="T:System.Linq.Expressions.DynamicExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 等于 <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" />，并且其 <see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" />、<see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> 和 <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> 均设置为指定的值。</span><span class="sxs-lookup"><span data-stu-id="7593b-2242">A <see cref="T:System.Linq.Expressions.DynamicExpression" /> that has <see cref="P:System.Linq.Expressions.Expression.NodeType" /> equal to <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> and has the <see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" />, <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" />, and <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MakeDynamic">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.DynamicExpression MakeDynamic (Type delegateType, System.Runtime.CompilerServices.CallSiteBinder binder, System.Linq.Expressions.Expression arg0, System.Linq.Expressions.Expression arg1, System.Linq.Expressions.Expression arg2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.DynamicExpression MakeDynamic(class System.Type delegateType, class System.Runtime.CompilerServices.CallSiteBinder binder, class System.Linq.Expressions.Expression arg0, class System.Linq.Expressions.Expression arg1, class System.Linq.Expressions.Expression arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MakeDynamic(System.Type,System.Runtime.CompilerServices.CallSiteBinder,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MakeDynamic (delegateType As Type, binder As CallSiteBinder, arg0 As Expression, arg1 As Expression, arg2 As Expression) As DynamicExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::DynamicExpression ^ MakeDynamic(Type ^ delegateType, System::Runtime::CompilerServices::CallSiteBinder ^ binder, System::Linq::Expressions::Expression ^ arg0, System::Linq::Expressions::Expression ^ arg1, System::Linq::Expressions::Expression ^ arg2);" />
      <MemberSignature Language="F#" Value="static member MakeDynamic : Type * System.Runtime.CompilerServices.CallSiteBinder * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.DynamicExpression" Usage="System.Linq.Expressions.Expression.MakeDynamic (delegateType, binder, arg0, arg1, arg2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.DynamicExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegateType" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="binder" Type="System.Runtime.CompilerServices.CallSiteBinder" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="arg1" Type="System.Linq.Expressions.Expression" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="arg2" Type="System.Linq.Expressions.Expression" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="delegateType"><span data-ttu-id="7593b-2243"><see cref="T:System.Runtime.CompilerServices.CallSite" /> 使用的委托的类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-2243">The type of the delegate used by the <see cref="T:System.Runtime.CompilerServices.CallSite" />.</span></span></param>
        <param name="binder"><span data-ttu-id="7593b-2244">动态操作的运行时联编程序。</span><span class="sxs-lookup"><span data-stu-id="7593b-2244">The runtime binder for the dynamic operation.</span></span></param>
        <param name="arg0"><span data-ttu-id="7593b-2245">动态操作的第一个参数。</span><span class="sxs-lookup"><span data-stu-id="7593b-2245">The first argument to the dynamic operation.</span></span></param>
        <param name="arg1"><span data-ttu-id="7593b-2246">动态操作的第二个自变量。</span><span class="sxs-lookup"><span data-stu-id="7593b-2246">The second argument to the dynamic operation.</span></span></param>
        <param name="arg2"><span data-ttu-id="7593b-2247">动态操作的第三个自变量。</span><span class="sxs-lookup"><span data-stu-id="7593b-2247">The third argument to the dynamic operation.</span></span></param>
        <summary><span data-ttu-id="7593b-2248">创建一个 <see cref="T:System.Linq.Expressions.DynamicExpression" />，它表示由提供的 <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> 和三个参数绑定的动态操作。</span><span class="sxs-lookup"><span data-stu-id="7593b-2248">Creates a <see cref="T:System.Linq.Expressions.DynamicExpression" /> that represents a dynamic operation bound by the provided <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> and three arguments.</span></span></summary>
        <returns><span data-ttu-id="7593b-2249">一个 <see cref="T:System.Linq.Expressions.DynamicExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 等于 <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" />，并且其 <see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" />、<see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> 和 <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> 均设置为指定的值。</span><span class="sxs-lookup"><span data-stu-id="7593b-2249">A <see cref="T:System.Linq.Expressions.DynamicExpression" /> that has <see cref="P:System.Linq.Expressions.Expression.NodeType" /> equal to <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> and has the <see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" />, <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" />, and <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MakeDynamic">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.DynamicExpression MakeDynamic (Type delegateType, System.Runtime.CompilerServices.CallSiteBinder binder, System.Linq.Expressions.Expression arg0, System.Linq.Expressions.Expression arg1, System.Linq.Expressions.Expression arg2, System.Linq.Expressions.Expression arg3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.DynamicExpression MakeDynamic(class System.Type delegateType, class System.Runtime.CompilerServices.CallSiteBinder binder, class System.Linq.Expressions.Expression arg0, class System.Linq.Expressions.Expression arg1, class System.Linq.Expressions.Expression arg2, class System.Linq.Expressions.Expression arg3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MakeDynamic(System.Type,System.Runtime.CompilerServices.CallSiteBinder,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MakeDynamic (delegateType As Type, binder As CallSiteBinder, arg0 As Expression, arg1 As Expression, arg2 As Expression, arg3 As Expression) As DynamicExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::DynamicExpression ^ MakeDynamic(Type ^ delegateType, System::Runtime::CompilerServices::CallSiteBinder ^ binder, System::Linq::Expressions::Expression ^ arg0, System::Linq::Expressions::Expression ^ arg1, System::Linq::Expressions::Expression ^ arg2, System::Linq::Expressions::Expression ^ arg3);" />
      <MemberSignature Language="F#" Value="static member MakeDynamic : Type * System.Runtime.CompilerServices.CallSiteBinder * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.DynamicExpression" Usage="System.Linq.Expressions.Expression.MakeDynamic (delegateType, binder, arg0, arg1, arg2, arg3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.DynamicExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegateType" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="binder" Type="System.Runtime.CompilerServices.CallSiteBinder" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="arg1" Type="System.Linq.Expressions.Expression" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="arg2" Type="System.Linq.Expressions.Expression" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="arg3" Type="System.Linq.Expressions.Expression" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="delegateType"><span data-ttu-id="7593b-2250"><see cref="T:System.Runtime.CompilerServices.CallSite" /> 使用的委托的类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-2250">The type of the delegate used by the <see cref="T:System.Runtime.CompilerServices.CallSite" />.</span></span></param>
        <param name="binder"><span data-ttu-id="7593b-2251">动态操作的运行时联编程序。</span><span class="sxs-lookup"><span data-stu-id="7593b-2251">The runtime binder for the dynamic operation.</span></span></param>
        <param name="arg0"><span data-ttu-id="7593b-2252">动态操作的第一个参数。</span><span class="sxs-lookup"><span data-stu-id="7593b-2252">The first argument to the dynamic operation.</span></span></param>
        <param name="arg1"><span data-ttu-id="7593b-2253">动态操作的第二个自变量。</span><span class="sxs-lookup"><span data-stu-id="7593b-2253">The second argument to the dynamic operation.</span></span></param>
        <param name="arg2"><span data-ttu-id="7593b-2254">动态操作的第三个自变量。</span><span class="sxs-lookup"><span data-stu-id="7593b-2254">The third argument to the dynamic operation.</span></span></param>
        <param name="arg3"><span data-ttu-id="7593b-2255">动态操作的第四个参数。</span><span class="sxs-lookup"><span data-stu-id="7593b-2255">The fourth argument to the dynamic operation.</span></span></param>
        <summary><span data-ttu-id="7593b-2256">创建一个 <see cref="T:System.Linq.Expressions.DynamicExpression" />，它表示由提供的 <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> 和四个参数绑定的动态操作。</span><span class="sxs-lookup"><span data-stu-id="7593b-2256">Creates a <see cref="T:System.Linq.Expressions.DynamicExpression" /> that represents a dynamic operation bound by the provided <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> and four arguments.</span></span></summary>
        <returns><span data-ttu-id="7593b-2257">一个 <see cref="T:System.Linq.Expressions.DynamicExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 等于 <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" />，并且其 <see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" />、<see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> 和 <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> 均设置为指定的值。</span><span class="sxs-lookup"><span data-stu-id="7593b-2257">A <see cref="T:System.Linq.Expressions.DynamicExpression" /> that has <see cref="P:System.Linq.Expressions.Expression.NodeType" /> equal to <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> and has the <see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" />, <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" />, and <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MakeGoto">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.GotoExpression MakeGoto (System.Linq.Expressions.GotoExpressionKind kind, System.Linq.Expressions.LabelTarget target, System.Linq.Expressions.Expression value, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.GotoExpression MakeGoto(valuetype System.Linq.Expressions.GotoExpressionKind kind, class System.Linq.Expressions.LabelTarget target, class System.Linq.Expressions.Expression value, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MakeGoto(System.Linq.Expressions.GotoExpressionKind,System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::GotoExpression ^ MakeGoto(System::Linq::Expressions::GotoExpressionKind kind, System::Linq::Expressions::LabelTarget ^ target, System::Linq::Expressions::Expression ^ value, Type ^ type);" />
      <MemberSignature Language="F#" Value="static member MakeGoto : System.Linq.Expressions.GotoExpressionKind * System.Linq.Expressions.LabelTarget * System.Linq.Expressions.Expression * Type -&gt; System.Linq.Expressions.GotoExpression" Usage="System.Linq.Expressions.Expression.MakeGoto (kind, target, value, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.GotoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="kind" Type="System.Linq.Expressions.GotoExpressionKind" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="value" Type="System.Linq.Expressions.Expression" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="type" Type="System.Type" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="kind"><span data-ttu-id="7593b-2258"><see cref="T:System.Linq.Expressions.GotoExpressionKind" /> 的 <see cref="T:System.Linq.Expressions.GotoExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2258">The <see cref="T:System.Linq.Expressions.GotoExpressionKind" /> of the <see cref="T:System.Linq.Expressions.GotoExpression" />.</span></span></param>
        <param name="target"><span data-ttu-id="7593b-2259"><see cref="T:System.Linq.Expressions.LabelTarget" /> 将跳至的 <see cref="T:System.Linq.Expressions.GotoExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2259">The <see cref="T:System.Linq.Expressions.LabelTarget" /> that the <see cref="T:System.Linq.Expressions.GotoExpression" /> will jump to.</span></span></param>
        <param name="value"><span data-ttu-id="7593b-2260">将在跳转时传递给关联标签的值。</span><span class="sxs-lookup"><span data-stu-id="7593b-2260">The value that will be passed to the associated label upon jumping.</span></span></param>
        <param name="type"><span data-ttu-id="7593b-2261">要将 <see cref="T:System.Type" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.Expression.Type" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2261">An <see cref="T:System.Type" /> to set the <see cref="P:System.Linq.Expressions.Expression.Type" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="7593b-2262">创建一个 <see cref="T:System.Linq.Expressions.GotoExpression" />，它表示指定的 <see cref="T:System.Linq.Expressions.GotoExpressionKind" /> 的跳转。</span><span class="sxs-lookup"><span data-stu-id="7593b-2262">Creates a <see cref="T:System.Linq.Expressions.GotoExpression" /> representing a jump of the specified <see cref="T:System.Linq.Expressions.GotoExpressionKind" />.</span></span> <span data-ttu-id="7593b-2263">也可以指定在跳转时传递给标签的值。</span><span class="sxs-lookup"><span data-stu-id="7593b-2263">The value passed to the label upon jumping can also be specified.</span></span></summary>
        <returns><span data-ttu-id="7593b-2264">一个 <see cref="T:System.Linq.Expressions.GotoExpression" />，其 <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> 等于 <paramref name="kind" />，其 <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> 属性设置为 <paramref name="target" />，并且其 <see cref="P:System.Linq.Expressions.Expression.Type" /> 属性设置为 <paramref name="type" />，此外还有一个在跳转时将传递给目标标签的 <paramref name="value" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2264">A <see cref="T:System.Linq.Expressions.GotoExpression" /> with <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> equal to <paramref name="kind" />, the <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> property set to <paramref name="target" />, the <see cref="P:System.Linq.Expressions.Expression.Type" /> property set to <paramref name="type" />, and <paramref name="value" /> to be passed to the target label upon jumping.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MakeIndex">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.IndexExpression MakeIndex (System.Linq.Expressions.Expression instance, System.Reflection.PropertyInfo indexer, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.IndexExpression MakeIndex(class System.Linq.Expressions.Expression instance, class System.Reflection.PropertyInfo indexer, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MakeIndex(System.Linq.Expressions.Expression,System.Reflection.PropertyInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MakeIndex (instance As Expression, indexer As PropertyInfo, arguments As IEnumerable(Of Expression)) As IndexExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::IndexExpression ^ MakeIndex(System::Linq::Expressions::Expression ^ instance, System::Reflection::PropertyInfo ^ indexer, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberSignature Language="F#" Value="static member MakeIndex : System.Linq.Expressions.Expression * System.Reflection.PropertyInfo * seq&lt;System.Linq.Expressions.Expression&gt; -&gt; System.Linq.Expressions.IndexExpression" Usage="System.Linq.Expressions.Expression.MakeIndex (instance, indexer, arguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.IndexExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Linq.Expressions.Expression" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="indexer" Type="System.Reflection.PropertyInfo" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arguments" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="instance"><span data-ttu-id="7593b-2265">属性所属的对象。</span><span class="sxs-lookup"><span data-stu-id="7593b-2265">The object to which the property belongs.</span></span> <span data-ttu-id="7593b-2266">如果属性为 <see langword="static" />（在 Visual Basic 中为 <see langword="shared" />），则它应为 null。</span><span class="sxs-lookup"><span data-stu-id="7593b-2266">It should be null if the property is <see langword="static" /> (<see langword="shared" /> in Visual Basic).</span></span></param>
        <param name="indexer"><span data-ttu-id="7593b-2267">一个 <see cref="T:System.Linq.Expressions.Expression" />，它表示要编制索引的属性。</span><span class="sxs-lookup"><span data-stu-id="7593b-2267">An <see cref="T:System.Linq.Expressions.Expression" /> representing the property to index.</span></span></param>
        <param name="arguments"><span data-ttu-id="7593b-2268">一个 <c>IEnumerable&lt;Expression&gt;</c>（在 Visual Basic 中为 <c>IEnumerable (Of Expression)</c>），其中包含将用于为属性编制索引的自变量。</span><span class="sxs-lookup"><span data-stu-id="7593b-2268">An <c>IEnumerable&lt;Expression&gt;</c> (<c>IEnumerable (Of Expression)</c> in Visual Basic) that contains the arguments that will be used to index the property.</span></span></param>
        <summary><span data-ttu-id="7593b-2269">创建一个 <see cref="T:System.Linq.Expressions.IndexExpression" />，它表示访问对象中的索引属性。</span><span class="sxs-lookup"><span data-stu-id="7593b-2269">Creates an <see cref="T:System.Linq.Expressions.IndexExpression" /> that represents accessing an indexed property in an object.</span></span></summary>
        <returns><span data-ttu-id="7593b-2270">创建的 <see cref="T:System.Linq.Expressions.IndexExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2270">The created <see cref="T:System.Linq.Expressions.IndexExpression" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MakeMemberAccess">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberExpression MakeMemberAccess (System.Linq.Expressions.Expression expression, System.Reflection.MemberInfo member);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberExpression MakeMemberAccess(class System.Linq.Expressions.Expression expression, class System.Reflection.MemberInfo member) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MakeMemberAccess(System.Linq.Expressions.Expression,System.Reflection.MemberInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberExpression ^ MakeMemberAccess(System::Linq::Expressions::Expression ^ expression, System::Reflection::MemberInfo ^ member);" />
      <MemberSignature Language="F#" Value="static member MakeMemberAccess : System.Linq.Expressions.Expression * System.Reflection.MemberInfo -&gt; System.Linq.Expressions.MemberExpression" Usage="System.Linq.Expressions.Expression.MakeMemberAccess (expression, member)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="member" Type="System.Reflection.MemberInfo" />
      </Parameters>
      <Docs>
        <param name="expression"><span data-ttu-id="7593b-2271">一个表示成员所属对象的 <see cref="T:System.Linq.Expressions.Expression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2271">An <see cref="T:System.Linq.Expressions.Expression" /> that represents the object that the member belongs to.</span></span> <span data-ttu-id="7593b-2272">对于静态成员，这可以为 null。</span><span class="sxs-lookup"><span data-stu-id="7593b-2272">This can be null for static members.</span></span></param>
        <param name="member"><span data-ttu-id="7593b-2273">描述要访问的字段或属性的 <see cref="T:System.Reflection.MemberInfo" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2273">The <see cref="T:System.Reflection.MemberInfo" /> that describes the field or property to be accessed.</span></span></param>
        <summary><span data-ttu-id="7593b-2274">创建一个表示访问字段或属性的 <see cref="T:System.Linq.Expressions.MemberExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2274">Creates a <see cref="T:System.Linq.Expressions.MemberExpression" /> that represents accessing either a field or a property.</span></span></summary>
        <returns><span data-ttu-id="7593b-2275">通过调用适当的工厂方法生成的 <see cref="T:System.Linq.Expressions.MemberExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2275">The <see cref="T:System.Linq.Expressions.MemberExpression" /> that results from calling the appropriate factory method.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7593b-2276">此方法可用于创建表示访问字段或属性的 <xref:System.Linq.Expressions.MemberExpression>，具体取决于 `member`的类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-2276">This method can be used to create a <xref:System.Linq.Expressions.MemberExpression> that represents accessing either a field or a property, depending on the type of `member`.</span></span> <span data-ttu-id="7593b-2277">如果 `member` 的类型 <xref:System.Reflection.FieldInfo>，则此方法将调用 <xref:System.Linq.Expressions.Expression.Field%2A> 来创建 <xref:System.Linq.Expressions.MemberExpression>。</span><span class="sxs-lookup"><span data-stu-id="7593b-2277">If `member` is of type <xref:System.Reflection.FieldInfo>, this method calls <xref:System.Linq.Expressions.Expression.Field%2A> to create the <xref:System.Linq.Expressions.MemberExpression>.</span></span> <span data-ttu-id="7593b-2278">如果 `member` 的类型 <xref:System.Reflection.PropertyInfo>，则此方法将调用 <xref:System.Linq.Expressions.Expression.Property%2A> 来创建 <xref:System.Linq.Expressions.MemberExpression>。</span><span class="sxs-lookup"><span data-stu-id="7593b-2278">If `member` is of type <xref:System.Reflection.PropertyInfo>, this method calls <xref:System.Linq.Expressions.Expression.Property%2A> to create the <xref:System.Linq.Expressions.MemberExpression>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="7593b-2279"><paramref name="member" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2279"><paramref name="member" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="7593b-2280"><paramref name="member" /> 不表示字段或属性。</span><span class="sxs-lookup"><span data-stu-id="7593b-2280"><paramref name="member" /> does not represent a field or property.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="MakeTry">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.TryExpression MakeTry (Type type, System.Linq.Expressions.Expression body, System.Linq.Expressions.Expression finally, System.Linq.Expressions.Expression fault, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.CatchBlock&gt; handlers);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.TryExpression MakeTry(class System.Type type, class System.Linq.Expressions.Expression body, class System.Linq.Expressions.Expression finally, class System.Linq.Expressions.Expression fault, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.CatchBlock&gt; handlers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MakeTry(System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.CatchBlock})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::TryExpression ^ MakeTry(Type ^ type, System::Linq::Expressions::Expression ^ body, System::Linq::Expressions::Expression ^ finally, System::Linq::Expressions::Expression ^ fault, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::CatchBlock ^&gt; ^ handlers);" />
      <MemberSignature Language="F#" Value="static member MakeTry : Type * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * seq&lt;System.Linq.Expressions.CatchBlock&gt; -&gt; System.Linq.Expressions.TryExpression" Usage="System.Linq.Expressions.Expression.MakeTry (type, body, finally, fault, handlers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.TryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="finally" Type="System.Linq.Expressions.Expression" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="fault" Type="System.Linq.Expressions.Expression" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="handlers" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.CatchBlock&gt;" Index="4" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="type"><span data-ttu-id="7593b-2281">try 表达式的结果类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-2281">The result type of the try expression.</span></span> <span data-ttu-id="7593b-2282">如果为 null，则正文和所有处理程序必须具有相同的类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-2282">If null, body and all handlers must have identical type.</span></span></param>
        <param name="body"><span data-ttu-id="7593b-2283">try 块的主体。</span><span class="sxs-lookup"><span data-stu-id="7593b-2283">The body of the try block.</span></span></param>
        <param name="finally"><span data-ttu-id="7593b-2284">finally 块的主体。</span><span class="sxs-lookup"><span data-stu-id="7593b-2284">The body of the finally block.</span></span> <span data-ttu-id="7593b-2285">如果 try 块不具有关联的 finally 块，则传递 null。</span><span class="sxs-lookup"><span data-stu-id="7593b-2285">Pass null if the try block has no finally block associated with it.</span></span></param>
        <param name="fault"><span data-ttu-id="7593b-2286">fault 块的主体。</span><span class="sxs-lookup"><span data-stu-id="7593b-2286">The body of the fault block.</span></span> <span data-ttu-id="7593b-2287">如果 try 块不具有关联的 fault 块，则传递 null。</span><span class="sxs-lookup"><span data-stu-id="7593b-2287">Pass null if the try block has no fault block associated with it.</span></span></param>
        <param name="handlers"><span data-ttu-id="7593b-2288">表示要与 try 块关联的 catch 语句的 <see cref="T:System.Linq.Expressions.CatchBlock" /> 的集合。</span><span class="sxs-lookup"><span data-stu-id="7593b-2288">A collection of <see cref="T:System.Linq.Expressions.CatchBlock" />s representing the catch statements to be associated with the try block.</span></span></param>
        <summary><span data-ttu-id="7593b-2289">创建一个表示具有指定元素的 try 块的 <see cref="T:System.Linq.Expressions.TryExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2289">Creates a <see cref="T:System.Linq.Expressions.TryExpression" /> representing a try block with the specified elements.</span></span></summary>
        <returns><span data-ttu-id="7593b-2290">创建的 <see cref="T:System.Linq.Expressions.TryExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2290">The created <see cref="T:System.Linq.Expressions.TryExpression" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="MakeUnary">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="7593b-2291">通过调用适当的工厂方法来创建一个 <see cref="T:System.Linq.Expressions.UnaryExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2291">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> by calling the appropriate factory method.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MakeUnary">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression MakeUnary (System.Linq.Expressions.ExpressionType unaryType, System.Linq.Expressions.Expression operand, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression MakeUnary(valuetype System.Linq.Expressions.ExpressionType unaryType, class System.Linq.Expressions.Expression operand, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MakeUnary(System.Linq.Expressions.ExpressionType,System.Linq.Expressions.Expression,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ MakeUnary(System::Linq::Expressions::ExpressionType unaryType, System::Linq::Expressions::Expression ^ operand, Type ^ type);" />
      <MemberSignature Language="F#" Value="static member MakeUnary : System.Linq.Expressions.ExpressionType * System.Linq.Expressions.Expression * Type -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.MakeUnary (unaryType, operand, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="unaryType" Type="System.Linq.Expressions.ExpressionType" />
        <Parameter Name="operand" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="unaryType"><span data-ttu-id="7593b-2292">指定一元运算类型的 <see cref="T:System.Linq.Expressions.ExpressionType" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2292">The <see cref="T:System.Linq.Expressions.ExpressionType" /> that specifies the type of unary operation.</span></span></param>
        <param name="operand"><span data-ttu-id="7593b-2293">一个表示操作数的 <see cref="T:System.Linq.Expressions.Expression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2293">An <see cref="T:System.Linq.Expressions.Expression" /> that represents the operand.</span></span></param>
        <param name="type"><span data-ttu-id="7593b-2294">指定转换的目标类型的 <see cref="T:System.Type" />（如果不适用，则传递 <see langword="null" />）。</span><span class="sxs-lookup"><span data-stu-id="7593b-2294">The <see cref="T:System.Type" /> that specifies the type to be converted to (pass <see langword="null" /> if not applicable).</span></span></param>
        <summary><span data-ttu-id="7593b-2295">在给定操作数的情况下，通过调用适当的工厂方法来创建一个 <see cref="T:System.Linq.Expressions.UnaryExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2295">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" />, given an operand, by calling the appropriate factory method.</span></span></summary>
        <returns><span data-ttu-id="7593b-2296">通过调用适当的工厂方法生成的 <see cref="T:System.Linq.Expressions.UnaryExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2296">The <see cref="T:System.Linq.Expressions.UnaryExpression" /> that results from calling the appropriate factory method.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7593b-2297">`unaryType` 参数确定此方法调用的 <xref:System.Linq.Expressions.UnaryExpression> 工厂方法。</span><span class="sxs-lookup"><span data-stu-id="7593b-2297">The `unaryType` parameter determines which <xref:System.Linq.Expressions.UnaryExpression> factory method this method calls.</span></span> <span data-ttu-id="7593b-2298">例如，如果 `unaryType` 等于 <xref:System.Linq.Expressions.ExpressionType.Convert>，则此方法将调用 <xref:System.Linq.Expressions.Expression.Convert%2A>。</span><span class="sxs-lookup"><span data-stu-id="7593b-2298">For example, if `unaryType` is equal to <xref:System.Linq.Expressions.ExpressionType.Convert>, this method invokes <xref:System.Linq.Expressions.Expression.Convert%2A>.</span></span> <span data-ttu-id="7593b-2299">如果 `type`参数不适用于调用的工厂方法，则将其忽略。</span><span class="sxs-lookup"><span data-stu-id="7593b-2299">The `type`parameter is ignored if it does not apply to the factory method that is called.</span></span>  

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="7593b-2300"><paramref name="operand" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2300"><paramref name="operand" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="7593b-2301"><paramref name="unaryType" /> 与一元表达式节点不对应。</span><span class="sxs-lookup"><span data-stu-id="7593b-2301"><paramref name="unaryType" /> does not correspond to a unary expression node.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="MakeUnary">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression MakeUnary (System.Linq.Expressions.ExpressionType unaryType, System.Linq.Expressions.Expression operand, Type type, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression MakeUnary(valuetype System.Linq.Expressions.ExpressionType unaryType, class System.Linq.Expressions.Expression operand, class System.Type type, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MakeUnary(System.Linq.Expressions.ExpressionType,System.Linq.Expressions.Expression,System.Type,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ MakeUnary(System::Linq::Expressions::ExpressionType unaryType, System::Linq::Expressions::Expression ^ operand, Type ^ type, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member MakeUnary : System.Linq.Expressions.ExpressionType * System.Linq.Expressions.Expression * Type * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.MakeUnary (unaryType, operand, type, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="unaryType" Type="System.Linq.Expressions.ExpressionType" />
        <Parameter Name="operand" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="unaryType"><span data-ttu-id="7593b-2302">指定一元运算类型的 <see cref="T:System.Linq.Expressions.ExpressionType" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2302">The <see cref="T:System.Linq.Expressions.ExpressionType" /> that specifies the type of unary operation.</span></span></param>
        <param name="operand"><span data-ttu-id="7593b-2303">一个表示操作数的 <see cref="T:System.Linq.Expressions.Expression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2303">An <see cref="T:System.Linq.Expressions.Expression" /> that represents the operand.</span></span></param>
        <param name="type"><span data-ttu-id="7593b-2304">指定转换的目标类型的 <see cref="T:System.Type" />（如果不适用，则传递 <see langword="null" />）。</span><span class="sxs-lookup"><span data-stu-id="7593b-2304">The <see cref="T:System.Type" /> that specifies the type to be converted to (pass <see langword="null" /> if not applicable).</span></span></param>
        <param name="method"><span data-ttu-id="7593b-2305">表示实现方法的 <see cref="T:System.Reflection.MethodInfo" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2305">The <see cref="T:System.Reflection.MethodInfo" /> that represents the implementing method.</span></span></param>
        <summary><span data-ttu-id="7593b-2306">在给定操作数和实现方法的情况下，通过调用适当的工厂方法来创建一个 <see cref="T:System.Linq.Expressions.UnaryExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2306">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" />, given an operand and implementing method, by calling the appropriate factory method.</span></span></summary>
        <returns><span data-ttu-id="7593b-2307">通过调用适当的工厂方法生成的 <see cref="T:System.Linq.Expressions.UnaryExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2307">The <see cref="T:System.Linq.Expressions.UnaryExpression" /> that results from calling the appropriate factory method.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7593b-2308">`unaryType` 参数确定此方法调用的 <xref:System.Linq.Expressions.UnaryExpression> 工厂方法。</span><span class="sxs-lookup"><span data-stu-id="7593b-2308">The `unaryType` parameter determines which <xref:System.Linq.Expressions.UnaryExpression> factory method this method calls.</span></span> <span data-ttu-id="7593b-2309">例如，如果 `unaryType` 等于 <xref:System.Linq.Expressions.ExpressionType.Convert>，则此方法将调用 <xref:System.Linq.Expressions.Expression.Convert%2A>。</span><span class="sxs-lookup"><span data-stu-id="7593b-2309">For example, if `unaryType` is equal to <xref:System.Linq.Expressions.ExpressionType.Convert>, this method invokes <xref:System.Linq.Expressions.Expression.Convert%2A>.</span></span> <span data-ttu-id="7593b-2310">如果 `type` 和 `method` 参数不适用于调用的工厂方法，则会将其忽略。</span><span class="sxs-lookup"><span data-stu-id="7593b-2310">The `type` and `method` parameters are ignored if they do not apply to the factory method that is called.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="7593b-2311"><paramref name="operand" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2311"><paramref name="operand" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="7593b-2312"><paramref name="unaryType" /> 与一元表达式节点不对应。</span><span class="sxs-lookup"><span data-stu-id="7593b-2312"><paramref name="unaryType" /> does not correspond to a unary expression node.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="MemberBind">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="7593b-2313">创建一个表示递归初始化某个成员的成员的 <see cref="T:System.Linq.Expressions.MemberMemberBinding" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2313">Creates a <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> that represents the recursive initialization of members of a member.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MemberBind">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberMemberBinding MemberBind (System.Reflection.MemberInfo member, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.MemberBinding&gt; bindings);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberMemberBinding MemberBind(class System.Reflection.MemberInfo member, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.MemberBinding&gt; bindings) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MemberBind(System.Reflection.MemberInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.MemberBinding})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MemberBind (member As MemberInfo, bindings As IEnumerable(Of MemberBinding)) As MemberMemberBinding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberMemberBinding ^ MemberBind(System::Reflection::MemberInfo ^ member, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::MemberBinding ^&gt; ^ bindings);" />
      <MemberSignature Language="F#" Value="static member MemberBind : System.Reflection.MemberInfo * seq&lt;System.Linq.Expressions.MemberBinding&gt; -&gt; System.Linq.Expressions.MemberMemberBinding" Usage="System.Linq.Expressions.Expression.MemberBind (member, bindings)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberMemberBinding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="member" Type="System.Reflection.MemberInfo" />
        <Parameter Name="bindings" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.MemberBinding&gt;" />
      </Parameters>
      <Docs>
        <param name="member"><span data-ttu-id="7593b-2314">要将 <see cref="T:System.Reflection.MemberInfo" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.MemberBinding.Member" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2314">The <see cref="T:System.Reflection.MemberInfo" /> to set the <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> property equal to.</span></span></param>
        <param name="bindings"><span data-ttu-id="7593b-2315">一个 <see cref="T:System.Collections.Generic.IEnumerable`1" />，包含用来填充 <see cref="T:System.Linq.Expressions.MemberBinding" /> 集合的 <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" /> 对象。</span><span class="sxs-lookup"><span data-stu-id="7593b-2315">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.MemberBinding" /> objects to use to populate the <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" /> collection.</span></span></param>
        <summary><span data-ttu-id="7593b-2316">创建一个表示递归初始化某个字段或属性的成员的 <see cref="T:System.Linq.Expressions.MemberMemberBinding" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2316">Creates a <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> that represents the recursive initialization of members of a field or property.</span></span></summary>
        <returns><span data-ttu-id="7593b-2317">一个 <see cref="T:System.Linq.Expressions.MemberMemberBinding" />，其 <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> 属性等于 <see cref="F:System.Linq.Expressions.MemberBindingType.MemberBinding" />，并且其 <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> 和 <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" /> 属性设置为指定值。</span><span class="sxs-lookup"><span data-stu-id="7593b-2317">A <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> that has the <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> property equal to <see cref="F:System.Linq.Expressions.MemberBindingType.MemberBinding" /> and the <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> and <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7593b-2318">`member` 参数必须表示字段或属性。</span><span class="sxs-lookup"><span data-stu-id="7593b-2318">The `member` parameter must represent a field or property.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="7593b-2319"><paramref name="member" /> 或 <paramref name="bindings" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2319"><paramref name="member" /> or <paramref name="bindings" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="7593b-2320"><paramref name="member" /> 不表示字段或属性。</span><span class="sxs-lookup"><span data-stu-id="7593b-2320"><paramref name="member" /> does not represent a field or property.</span></span>  
  
<span data-ttu-id="7593b-2321">- 或 -</span><span class="sxs-lookup"><span data-stu-id="7593b-2321">-or-</span></span> 
<span data-ttu-id="7593b-2322"><see cref="P:System.Linq.Expressions.MemberBinding.Member" /> 的元素的 <paramref name="bindings" /> 属性不表示 <paramref name="member" /> 所表示的字段或属性类型的成员。</span><span class="sxs-lookup"><span data-stu-id="7593b-2322">The <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> property of an element of <paramref name="bindings" /> does not represent a member of the type of the field or property that <paramref name="member" /> represents.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="MemberBind">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberMemberBinding MemberBind (System.Reflection.MemberInfo member, params System.Linq.Expressions.MemberBinding[] bindings);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberMemberBinding MemberBind(class System.Reflection.MemberInfo member, class System.Linq.Expressions.MemberBinding[] bindings) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MemberBind(System.Reflection.MemberInfo,System.Linq.Expressions.MemberBinding[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MemberBind (member As MemberInfo, ParamArray bindings As MemberBinding()) As MemberMemberBinding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberMemberBinding ^ MemberBind(System::Reflection::MemberInfo ^ member, ... cli::array &lt;System::Linq::Expressions::MemberBinding ^&gt; ^ bindings);" />
      <MemberSignature Language="F#" Value="static member MemberBind : System.Reflection.MemberInfo * System.Linq.Expressions.MemberBinding[] -&gt; System.Linq.Expressions.MemberMemberBinding" Usage="System.Linq.Expressions.Expression.MemberBind (member, bindings)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberMemberBinding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="member" Type="System.Reflection.MemberInfo" />
        <Parameter Name="bindings" Type="System.Linq.Expressions.MemberBinding[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="member"><span data-ttu-id="7593b-2323">要将 <see cref="T:System.Reflection.MemberInfo" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.MemberBinding.Member" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2323">The <see cref="T:System.Reflection.MemberInfo" /> to set the <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> property equal to.</span></span></param>
        <param name="bindings"><span data-ttu-id="7593b-2324">用于填充 <see cref="T:System.Linq.Expressions.MemberBinding" /> 集合的 <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" /> 对象的数组。</span><span class="sxs-lookup"><span data-stu-id="7593b-2324">An array of <see cref="T:System.Linq.Expressions.MemberBinding" /> objects to use to populate the <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" /> collection.</span></span></param>
        <summary><span data-ttu-id="7593b-2325">创建一个表示递归初始化某个字段或属性的成员的 <see cref="T:System.Linq.Expressions.MemberMemberBinding" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2325">Creates a <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> that represents the recursive initialization of members of a field or property.</span></span></summary>
        <returns><span data-ttu-id="7593b-2326">一个 <see cref="T:System.Linq.Expressions.MemberMemberBinding" />，其 <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> 属性等于 <see cref="F:System.Linq.Expressions.MemberBindingType.MemberBinding" />，并且其 <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> 和 <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" /> 属性设置为指定值。</span><span class="sxs-lookup"><span data-stu-id="7593b-2326">A <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> that has the <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> property equal to <see cref="F:System.Linq.Expressions.MemberBindingType.MemberBinding" /> and the <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> and <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7593b-2327">`member` 参数必须表示字段或属性。</span><span class="sxs-lookup"><span data-stu-id="7593b-2327">The `member` parameter must represent a field or property.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="7593b-2328"><paramref name="member" /> 或 <paramref name="bindings" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2328"><paramref name="member" /> or <paramref name="bindings" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="7593b-2329"><paramref name="member" /> 不表示字段或属性。</span><span class="sxs-lookup"><span data-stu-id="7593b-2329"><paramref name="member" /> does not represent a field or property.</span></span>  
  
<span data-ttu-id="7593b-2330">- 或 -</span><span class="sxs-lookup"><span data-stu-id="7593b-2330">-or-</span></span> 
<span data-ttu-id="7593b-2331"><see cref="P:System.Linq.Expressions.MemberBinding.Member" /> 的元素的 <paramref name="bindings" /> 属性不表示 <paramref name="member" /> 所表示的字段或属性类型的成员。</span><span class="sxs-lookup"><span data-stu-id="7593b-2331">The <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> property of an element of <paramref name="bindings" /> does not represent a member of the type of the field or property that <paramref name="member" /> represents.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="MemberBind">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberMemberBinding MemberBind (System.Reflection.MethodInfo propertyAccessor, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.MemberBinding&gt; bindings);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberMemberBinding MemberBind(class System.Reflection.MethodInfo propertyAccessor, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.MemberBinding&gt; bindings) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MemberBind(System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.MemberBinding})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MemberBind (propertyAccessor As MethodInfo, bindings As IEnumerable(Of MemberBinding)) As MemberMemberBinding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberMemberBinding ^ MemberBind(System::Reflection::MethodInfo ^ propertyAccessor, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::MemberBinding ^&gt; ^ bindings);" />
      <MemberSignature Language="F#" Value="static member MemberBind : System.Reflection.MethodInfo * seq&lt;System.Linq.Expressions.MemberBinding&gt; -&gt; System.Linq.Expressions.MemberMemberBinding" Usage="System.Linq.Expressions.Expression.MemberBind (propertyAccessor, bindings)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberMemberBinding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyAccessor" Type="System.Reflection.MethodInfo" />
        <Parameter Name="bindings" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.MemberBinding&gt;" />
      </Parameters>
      <Docs>
        <param name="propertyAccessor"><span data-ttu-id="7593b-2332">表示属性访问器方法的 <see cref="T:System.Reflection.MethodInfo" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2332">The <see cref="T:System.Reflection.MethodInfo" /> that represents a property accessor method.</span></span></param>
        <param name="bindings"><span data-ttu-id="7593b-2333">一个 <see cref="T:System.Collections.Generic.IEnumerable`1" />，包含用来填充 <see cref="T:System.Linq.Expressions.MemberBinding" /> 集合的 <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" /> 对象。</span><span class="sxs-lookup"><span data-stu-id="7593b-2333">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.MemberBinding" /> objects to use to populate the <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" /> collection.</span></span></param>
        <summary><span data-ttu-id="7593b-2334">使用属性访问器方法创建一个表示对所访问的成员的成员进行递归初始化的 <see cref="T:System.Linq.Expressions.MemberMemberBinding" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2334">Creates a <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> that represents the recursive initialization of members of a member that is accessed by using a property accessor method.</span></span></summary>
        <returns><span data-ttu-id="7593b-2335">一个 <see cref="T:System.Linq.Expressions.MemberMemberBinding" />，其 <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> 属性等于 <see cref="F:System.Linq.Expressions.MemberBindingType.MemberBinding" />，<see cref="P:System.Linq.Expressions.MemberBinding.Member" /> 属性设置为表示在 <see cref="T:System.Reflection.PropertyInfo" /> 中访问的属性的 <paramref name="propertyAccessor" />，并且 <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" /> 属性设置为指定值。</span><span class="sxs-lookup"><span data-stu-id="7593b-2335">A <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> that has the <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> property equal to <see cref="F:System.Linq.Expressions.MemberBindingType.MemberBinding" />, the <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> property set to the <see cref="T:System.Reflection.PropertyInfo" /> that represents the property accessed in <paramref name="propertyAccessor" />, and <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="7593b-2336"><paramref name="propertyAccessor" /> 或 <paramref name="bindings" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2336"><paramref name="propertyAccessor" /> or <paramref name="bindings" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="7593b-2337"><paramref name="propertyAccessor" /> 不表示属性访问器方法。</span><span class="sxs-lookup"><span data-stu-id="7593b-2337"><paramref name="propertyAccessor" /> does not represent a property accessor method.</span></span>  
  
<span data-ttu-id="7593b-2338">- 或 -</span><span class="sxs-lookup"><span data-stu-id="7593b-2338">-or-</span></span> 
<span data-ttu-id="7593b-2339"><see cref="P:System.Linq.Expressions.MemberBinding.Member" /> 的元素的 <paramref name="bindings" /> 属性不表示 <paramref name="propertyAccessor" /> 所表示的方法访问的属性类型的成员。</span><span class="sxs-lookup"><span data-stu-id="7593b-2339">The <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> property of an element of <paramref name="bindings" /> does not represent a member of the type of the property accessed by the method that <paramref name="propertyAccessor" /> represents.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="MemberBind">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberMemberBinding MemberBind (System.Reflection.MethodInfo propertyAccessor, params System.Linq.Expressions.MemberBinding[] bindings);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberMemberBinding MemberBind(class System.Reflection.MethodInfo propertyAccessor, class System.Linq.Expressions.MemberBinding[] bindings) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MemberBind(System.Reflection.MethodInfo,System.Linq.Expressions.MemberBinding[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MemberBind (propertyAccessor As MethodInfo, ParamArray bindings As MemberBinding()) As MemberMemberBinding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberMemberBinding ^ MemberBind(System::Reflection::MethodInfo ^ propertyAccessor, ... cli::array &lt;System::Linq::Expressions::MemberBinding ^&gt; ^ bindings);" />
      <MemberSignature Language="F#" Value="static member MemberBind : System.Reflection.MethodInfo * System.Linq.Expressions.MemberBinding[] -&gt; System.Linq.Expressions.MemberMemberBinding" Usage="System.Linq.Expressions.Expression.MemberBind (propertyAccessor, bindings)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberMemberBinding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyAccessor" Type="System.Reflection.MethodInfo" />
        <Parameter Name="bindings" Type="System.Linq.Expressions.MemberBinding[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="propertyAccessor"><span data-ttu-id="7593b-2340">表示属性访问器方法的 <see cref="T:System.Reflection.MethodInfo" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2340">The <see cref="T:System.Reflection.MethodInfo" /> that represents a property accessor method.</span></span></param>
        <param name="bindings"><span data-ttu-id="7593b-2341">用于填充 <see cref="T:System.Linq.Expressions.MemberBinding" /> 集合的 <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" /> 对象的数组。</span><span class="sxs-lookup"><span data-stu-id="7593b-2341">An array of <see cref="T:System.Linq.Expressions.MemberBinding" /> objects to use to populate the <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" /> collection.</span></span></param>
        <summary><span data-ttu-id="7593b-2342">使用属性访问器方法创建一个表示对所访问的成员的成员进行递归初始化的 <see cref="T:System.Linq.Expressions.MemberMemberBinding" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2342">Creates a <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> that represents the recursive initialization of members of a member that is accessed by using a property accessor method.</span></span></summary>
        <returns><span data-ttu-id="7593b-2343">一个 <see cref="T:System.Linq.Expressions.MemberMemberBinding" />，其 <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> 属性等于 <see cref="F:System.Linq.Expressions.MemberBindingType.MemberBinding" />，<see cref="P:System.Linq.Expressions.MemberBinding.Member" /> 属性设置为表示在 <see cref="T:System.Reflection.PropertyInfo" /> 中访问的属性的 <paramref name="propertyAccessor" />，并且 <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" /> 属性设置为指定值。</span><span class="sxs-lookup"><span data-stu-id="7593b-2343">A <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> that has the <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> property equal to <see cref="F:System.Linq.Expressions.MemberBindingType.MemberBinding" />, the <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> property set to the <see cref="T:System.Reflection.PropertyInfo" /> that represents the property accessed in <paramref name="propertyAccessor" />, and <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="7593b-2344"><paramref name="propertyAccessor" /> 或 <paramref name="bindings" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2344"><paramref name="propertyAccessor" /> or <paramref name="bindings" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="7593b-2345"><paramref name="propertyAccessor" /> 不表示属性访问器方法。</span><span class="sxs-lookup"><span data-stu-id="7593b-2345"><paramref name="propertyAccessor" /> does not represent a property accessor method.</span></span>  
  
<span data-ttu-id="7593b-2346">- 或 -</span><span class="sxs-lookup"><span data-stu-id="7593b-2346">-or-</span></span> 
<span data-ttu-id="7593b-2347"><see cref="P:System.Linq.Expressions.MemberBinding.Member" /> 的元素的 <paramref name="bindings" /> 属性不表示 <paramref name="propertyAccessor" /> 所表示的方法访问的属性类型的成员。</span><span class="sxs-lookup"><span data-stu-id="7593b-2347">The <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> property of an element of <paramref name="bindings" /> does not represent a member of the type of the property accessed by the method that <paramref name="propertyAccessor" /> represents.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="MemberInit">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="7593b-2348">表示一个表达式，该表达式创建新对象并初始化该对象的一个属性。</span><span class="sxs-lookup"><span data-stu-id="7593b-2348">Represents an expression that creates a new object and initializes a property of the object.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MemberInit">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberInitExpression MemberInit (System.Linq.Expressions.NewExpression newExpression, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.MemberBinding&gt; bindings);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberInitExpression MemberInit(class System.Linq.Expressions.NewExpression newExpression, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.MemberBinding&gt; bindings) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MemberInit(System.Linq.Expressions.NewExpression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.MemberBinding})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberInitExpression ^ MemberInit(System::Linq::Expressions::NewExpression ^ newExpression, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::MemberBinding ^&gt; ^ bindings);" />
      <MemberSignature Language="F#" Value="static member MemberInit : System.Linq.Expressions.NewExpression * seq&lt;System.Linq.Expressions.MemberBinding&gt; -&gt; System.Linq.Expressions.MemberInitExpression" Usage="System.Linq.Expressions.Expression.MemberInit (newExpression, bindings)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberInitExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="newExpression" Type="System.Linq.Expressions.NewExpression" />
        <Parameter Name="bindings" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.MemberBinding&gt;" />
      </Parameters>
      <Docs>
        <param name="newExpression"><span data-ttu-id="7593b-2349">要将 <see cref="T:System.Linq.Expressions.NewExpression" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.MemberInitExpression.NewExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2349">A <see cref="T:System.Linq.Expressions.NewExpression" /> to set the <see cref="P:System.Linq.Expressions.MemberInitExpression.NewExpression" /> property equal to.</span></span></param>
        <param name="bindings"><span data-ttu-id="7593b-2350">一个 <see cref="T:System.Collections.Generic.IEnumerable`1" />，包含用来填充 <see cref="T:System.Linq.Expressions.MemberBinding" /> 集合的 <see cref="P:System.Linq.Expressions.MemberInitExpression.Bindings" /> 对象。</span><span class="sxs-lookup"><span data-stu-id="7593b-2350">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.MemberBinding" /> objects to use to populate the <see cref="P:System.Linq.Expressions.MemberInitExpression.Bindings" /> collection.</span></span></param>
        <summary><span data-ttu-id="7593b-2351">表示一个表达式，该表达式创建新对象并初始化该对象的一个属性。</span><span class="sxs-lookup"><span data-stu-id="7593b-2351">Represents an expression that creates a new object and initializes a property of the object.</span></span></summary>
        <returns><span data-ttu-id="7593b-2352">一个 <see cref="T:System.Linq.Expressions.MemberInitExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 属性等于 <see cref="F:System.Linq.Expressions.ExpressionType.MemberInit" />，并且其 <see cref="P:System.Linq.Expressions.MemberInitExpression.NewExpression" /> 和 <see cref="P:System.Linq.Expressions.MemberInitExpression.Bindings" /> 属性设置为指定值。</span><span class="sxs-lookup"><span data-stu-id="7593b-2352">A <see cref="T:System.Linq.Expressions.MemberInitExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.MemberInit" /> and the <see cref="P:System.Linq.Expressions.MemberInitExpression.NewExpression" /> and <see cref="P:System.Linq.Expressions.MemberInitExpression.Bindings" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7593b-2353">生成的 <xref:System.Linq.Expressions.MemberInitExpression> 的 <xref:System.Linq.Expressions.Expression.Type%2A> 属性等于 `newExpression`的 <xref:System.Linq.Expressions.Expression.Type%2A> 属性。</span><span class="sxs-lookup"><span data-stu-id="7593b-2353">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.MemberInitExpression> is equal to the <xref:System.Linq.Expressions.Expression.Type%2A> property of `newExpression`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="7593b-2354">下面的示例演示了一个表达式，该表达式创建一个新的对象并初始化该对象的一个属性。</span><span class="sxs-lookup"><span data-stu-id="7593b-2354">The following example demonstrates an expression that creates a new object and initializes a property of the object.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#40](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#40)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#40](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#40)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="7593b-2355"><paramref name="newExpression" /> 或 <paramref name="bindings" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2355"><paramref name="newExpression" /> or <paramref name="bindings" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="7593b-2356"><see cref="P:System.Linq.Expressions.MemberBinding.Member" /> 的元素的 <paramref name="bindings" /> 属性不表示 <paramref name="newExpression" />.Type 所表示的类型的成员。</span><span class="sxs-lookup"><span data-stu-id="7593b-2356">The <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> property of an element of <paramref name="bindings" /> does not represent a member of the type that <paramref name="newExpression" />.Type represents.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="MemberInit">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberInitExpression MemberInit (System.Linq.Expressions.NewExpression newExpression, params System.Linq.Expressions.MemberBinding[] bindings);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberInitExpression MemberInit(class System.Linq.Expressions.NewExpression newExpression, class System.Linq.Expressions.MemberBinding[] bindings) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MemberInit(System.Linq.Expressions.NewExpression,System.Linq.Expressions.MemberBinding[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberInitExpression ^ MemberInit(System::Linq::Expressions::NewExpression ^ newExpression, ... cli::array &lt;System::Linq::Expressions::MemberBinding ^&gt; ^ bindings);" />
      <MemberSignature Language="F#" Value="static member MemberInit : System.Linq.Expressions.NewExpression * System.Linq.Expressions.MemberBinding[] -&gt; System.Linq.Expressions.MemberInitExpression" Usage="System.Linq.Expressions.Expression.MemberInit (newExpression, bindings)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberInitExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="newExpression" Type="System.Linq.Expressions.NewExpression" />
        <Parameter Name="bindings" Type="System.Linq.Expressions.MemberBinding[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="newExpression"><span data-ttu-id="7593b-2357">要将 <see cref="T:System.Linq.Expressions.NewExpression" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.MemberInitExpression.NewExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2357">A <see cref="T:System.Linq.Expressions.NewExpression" /> to set the <see cref="P:System.Linq.Expressions.MemberInitExpression.NewExpression" /> property equal to.</span></span></param>
        <param name="bindings"><span data-ttu-id="7593b-2358">用于填充 <see cref="T:System.Linq.Expressions.MemberBinding" /> 集合的 <see cref="P:System.Linq.Expressions.MemberInitExpression.Bindings" /> 对象的数组。</span><span class="sxs-lookup"><span data-stu-id="7593b-2358">An array of <see cref="T:System.Linq.Expressions.MemberBinding" /> objects to use to populate the <see cref="P:System.Linq.Expressions.MemberInitExpression.Bindings" /> collection.</span></span></param>
        <summary><span data-ttu-id="7593b-2359">创建一个 <see cref="T:System.Linq.Expressions.MemberInitExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2359">Creates a <see cref="T:System.Linq.Expressions.MemberInitExpression" />.</span></span></summary>
        <returns><span data-ttu-id="7593b-2360">一个 <see cref="T:System.Linq.Expressions.MemberInitExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 属性等于 <see cref="F:System.Linq.Expressions.ExpressionType.MemberInit" />，并且其 <see cref="P:System.Linq.Expressions.MemberInitExpression.NewExpression" /> 和 <see cref="P:System.Linq.Expressions.MemberInitExpression.Bindings" /> 属性设置为指定值。</span><span class="sxs-lookup"><span data-stu-id="7593b-2360">A <see cref="T:System.Linq.Expressions.MemberInitExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.MemberInit" /> and the <see cref="P:System.Linq.Expressions.MemberInitExpression.NewExpression" /> and <see cref="P:System.Linq.Expressions.MemberInitExpression.Bindings" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7593b-2361">生成的 <xref:System.Linq.Expressions.MemberInitExpression> 的 <xref:System.Linq.Expressions.Expression.Type%2A> 属性等于 `newExpression`的 <xref:System.Linq.Expressions.Expression.Type%2A> 属性。</span><span class="sxs-lookup"><span data-stu-id="7593b-2361">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.MemberInitExpression> is equal to the <xref:System.Linq.Expressions.Expression.Type%2A> property of `newExpression`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="7593b-2362">下面的示例演示如何使用 <xref:System.Linq.Expressions.Expression.MemberInit%28System.Linq.Expressions.NewExpression%2CSystem.Linq.Expressions.MemberBinding%5B%5D%29> 方法来创建表示新对象的两个成员的初始化的 <xref:System.Linq.Expressions.MemberInitExpression>。</span><span class="sxs-lookup"><span data-stu-id="7593b-2362">The following example demonstrates how to use the <xref:System.Linq.Expressions.Expression.MemberInit%28System.Linq.Expressions.NewExpression%2CSystem.Linq.Expressions.MemberBinding%5B%5D%29> method to create a <xref:System.Linq.Expressions.MemberInitExpression> that represents the initialization of two members of a new object.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.Expression#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#9)]
 [!code-vb[System.Linq.Expressions.Expression#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="7593b-2363"><paramref name="newExpression" /> 或 <paramref name="bindings" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2363"><paramref name="newExpression" /> or <paramref name="bindings" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="7593b-2364"><see cref="P:System.Linq.Expressions.MemberBinding.Member" /> 的元素的 <paramref name="bindings" /> 属性不表示 <paramref name="newExpression" />.Type 所表示的类型的成员。</span><span class="sxs-lookup"><span data-stu-id="7593b-2364">The <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> property of an element of <paramref name="bindings" /> does not represent a member of the type that <paramref name="newExpression" />.Type represents.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Modulo">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="7593b-2365">创建一个表示算术余数运算的 <see cref="T:System.Linq.Expressions.BinaryExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2365">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an arithmetic remainder operation.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Modulo">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Modulo (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Modulo(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Modulo(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Modulo (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Modulo(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member Modulo : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.Modulo (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="7593b-2366">要将 <see cref="T:System.Linq.Expressions.Expression" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2366">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="7593b-2367">要将 <see cref="T:System.Linq.Expressions.Expression" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2367">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="7593b-2368">创建一个表示算术余数运算的 <see cref="T:System.Linq.Expressions.BinaryExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2368">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an arithmetic remainder operation.</span></span></summary>
        <returns><span data-ttu-id="7593b-2369">一个 <see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 属性等于 <see cref="F:System.Linq.Expressions.ExpressionType.Modulo" />，并且其 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 属性设置为指定值。</span><span class="sxs-lookup"><span data-stu-id="7593b-2369">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Modulo" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7593b-2370">生成的 <xref:System.Linq.Expressions.BinaryExpression> 具有设置为实现方法的 <xref:System.Linq.Expressions.BinaryExpression.Method%2A> 属性。</span><span class="sxs-lookup"><span data-stu-id="7593b-2370">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="7593b-2371"><xref:System.Linq.Expressions.Expression.Type%2A> 属性设置为节点的类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-2371">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="7593b-2372">如果节点已提升，则 <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> 和 <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> 属性均 `true`。</span><span class="sxs-lookup"><span data-stu-id="7593b-2372">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="7593b-2373">否则，它们 `false`。</span><span class="sxs-lookup"><span data-stu-id="7593b-2373">Otherwise, they are `false`.</span></span> <span data-ttu-id="7593b-2374"><xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> 属性为 `null`。</span><span class="sxs-lookup"><span data-stu-id="7593b-2374">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="7593b-2375">以下信息描述了实现方法、节点类型以及节点是否已提升。</span><span class="sxs-lookup"><span data-stu-id="7593b-2375">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="7593b-2376">实现方法</span><span class="sxs-lookup"><span data-stu-id="7593b-2376">Implementing Method</span></span>  
 <span data-ttu-id="7593b-2377">以下规则确定为操作选定的实现方法：</span><span class="sxs-lookup"><span data-stu-id="7593b-2377">The following rules determine the selected implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="7593b-2378">如果 `left` 或 `right` 的 <xref:System.Linq.Expressions.Expression.Type%2A> 属性表示重载取模运算符的用户定义类型，则表示该方法的 <xref:System.Reflection.MethodInfo> 是实现方法。</span><span class="sxs-lookup"><span data-stu-id="7593b-2378">If the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the modulus operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="7593b-2379">否则，如果 `left`。键入并 `right`。类型为数值类型，则实现方法为 `null`。</span><span class="sxs-lookup"><span data-stu-id="7593b-2379">Otherwise, if `left`.Type and `right`.Type are numeric types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="7593b-2380">节点类型和提升和非提升</span><span class="sxs-lookup"><span data-stu-id="7593b-2380">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="7593b-2381">如果不 `null`实现方法：</span><span class="sxs-lookup"><span data-stu-id="7593b-2381">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="7593b-2382">如果 `left`。键入并 `right`。类型可分配给实现方法的相应参数类型，不提升节点。</span><span class="sxs-lookup"><span data-stu-id="7593b-2382">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="7593b-2383">节点的类型是实现方法的返回类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-2383">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="7593b-2384">如果满足以下两个条件，则会提升节点，并且该节点的类型为与实现方法的返回类型对应的可以为 null 的类型：</span><span class="sxs-lookup"><span data-stu-id="7593b-2384">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="7593b-2385">`left`。键入并 `right`。类型既是值类型，其中至少有一个可为 null，并且相应的不可为 null 的类型等于实现方法的相应参数类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-2385">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="7593b-2386">实现方法的返回类型是不可为 null 的值类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-2386">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="7593b-2387">如果实现方法为 `null`：</span><span class="sxs-lookup"><span data-stu-id="7593b-2387">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="7593b-2388">如果 `left`。键入并 `right`。类型不可以为 null，则不提升节点。</span><span class="sxs-lookup"><span data-stu-id="7593b-2388">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="7593b-2389">节点的类型为预定义取模运算符的结果类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-2389">The type of the node is the result type of the predefined modulus operator.</span></span>  
  
-   <span data-ttu-id="7593b-2390">如果 `left`。键入并 `right`。类型均可为 null，则提升节点。</span><span class="sxs-lookup"><span data-stu-id="7593b-2390">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="7593b-2391">节点的类型是与预定义取模运算符的结果类型对应的可以为 null 的类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-2391">The type of the node is the nullable type that corresponds to the result type of the predefined modulus operator.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="7593b-2392"><paramref name="left" /> 或 <paramref name="right" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2392"><paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="7593b-2393">没有为 <paramref name="left" />.Type 和 <paramref name="right" />.Type 定义取模运算符。</span><span class="sxs-lookup"><span data-stu-id="7593b-2393">The modulus operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Modulo">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Modulo (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Modulo(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Modulo(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Modulo (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Modulo(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member Modulo : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.Modulo (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="7593b-2394">要将 <see cref="T:System.Linq.Expressions.Expression" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2394">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="7593b-2395">要将 <see cref="T:System.Linq.Expressions.Expression" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2395">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <param name="method"><span data-ttu-id="7593b-2396">要将 <see cref="T:System.Reflection.MethodInfo" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2396">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="7593b-2397">创建一个表示算术余数运算的 <see cref="T:System.Linq.Expressions.BinaryExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2397">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an arithmetic remainder operation.</span></span></summary>
        <returns><span data-ttu-id="7593b-2398">一个 <see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 属性等于 <see cref="F:System.Linq.Expressions.ExpressionType.Modulo" />，并且其 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />、<see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> 属性设置为指定值。</span><span class="sxs-lookup"><span data-stu-id="7593b-2398">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Modulo" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7593b-2399">生成的 <xref:System.Linq.Expressions.BinaryExpression> 具有设置为实现方法的 <xref:System.Linq.Expressions.BinaryExpression.Method%2A> 属性。</span><span class="sxs-lookup"><span data-stu-id="7593b-2399">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="7593b-2400"><xref:System.Linq.Expressions.Expression.Type%2A> 属性设置为节点的类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-2400">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="7593b-2401">如果节点已提升，则 <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> 和 <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> 属性均 `true`。</span><span class="sxs-lookup"><span data-stu-id="7593b-2401">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="7593b-2402">否则，它们 `false`。</span><span class="sxs-lookup"><span data-stu-id="7593b-2402">Otherwise, they are `false`.</span></span> <span data-ttu-id="7593b-2403"><xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> 属性为 `null`。</span><span class="sxs-lookup"><span data-stu-id="7593b-2403">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="7593b-2404">以下信息描述了实现方法、节点类型以及节点是否已提升。</span><span class="sxs-lookup"><span data-stu-id="7593b-2404">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="7593b-2405">实现方法</span><span class="sxs-lookup"><span data-stu-id="7593b-2405">Implementing Method</span></span>  
 <span data-ttu-id="7593b-2406">根据以下规则选择操作的实现方法：</span><span class="sxs-lookup"><span data-stu-id="7593b-2406">The implementing method for the operation is chosen based on the following rules:</span></span>  
  
-   <span data-ttu-id="7593b-2407">如果 `method` 未 `null` 并且它表示采用两个自变量的非 void、`static``Shared` （Visual Basic）方法，则它是节点的实现方法。</span><span class="sxs-lookup"><span data-stu-id="7593b-2407">If `method` is not `null` and it represents a non-void, `static` (`Shared` in Visual Basic) method that takes two arguments, it is the implementing method for the node.</span></span>  
  
-   <span data-ttu-id="7593b-2408">否则，如果 `left` 或 `right` 的 <xref:System.Linq.Expressions.Expression.Type%2A> 属性表示重载取模运算符的用户定义类型，则表示该方法的 <xref:System.Reflection.MethodInfo> 是实现方法。</span><span class="sxs-lookup"><span data-stu-id="7593b-2408">Otherwise, if the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the modulus operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="7593b-2409">否则，如果 `left`。键入并 `right`。类型为数值类型，则实现方法为 `null`。</span><span class="sxs-lookup"><span data-stu-id="7593b-2409">Otherwise, if `left`.Type and `right`.Type are numeric types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="7593b-2410">节点类型和提升和非提升</span><span class="sxs-lookup"><span data-stu-id="7593b-2410">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="7593b-2411">如果不 `null`实现方法：</span><span class="sxs-lookup"><span data-stu-id="7593b-2411">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="7593b-2412">如果 `left`。键入并 `right`。类型可分配给实现方法的相应参数类型，不提升节点。</span><span class="sxs-lookup"><span data-stu-id="7593b-2412">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="7593b-2413">节点的类型是实现方法的返回类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-2413">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="7593b-2414">如果满足以下两个条件，则会提升节点，并且该节点的类型为与实现方法的返回类型对应的可以为 null 的类型：</span><span class="sxs-lookup"><span data-stu-id="7593b-2414">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="7593b-2415">`left`。键入并 `right`。类型既是值类型，其中至少有一个可为 null，并且相应的不可为 null 的类型等于实现方法的相应参数类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-2415">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="7593b-2416">实现方法的返回类型是不可为 null 的值类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-2416">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="7593b-2417">如果实现方法为 `null`：</span><span class="sxs-lookup"><span data-stu-id="7593b-2417">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="7593b-2418">如果 `left`。键入并 `right`。类型不可以为 null，则不提升节点。</span><span class="sxs-lookup"><span data-stu-id="7593b-2418">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="7593b-2419">节点的类型为预定义取模运算符的结果类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-2419">The type of the node is the result type of the predefined modulus operator.</span></span>  
  
-   <span data-ttu-id="7593b-2420">如果 `left`。键入并 `right`。类型均可为 null，则提升节点。</span><span class="sxs-lookup"><span data-stu-id="7593b-2420">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="7593b-2421">节点的类型是与预定义取模运算符的结果类型对应的可以为 null 的类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-2421">The type of the node is the nullable type that corresponds to the result type of the predefined modulus operator.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="7593b-2422"><paramref name="left" /> 或 <paramref name="right" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2422"><paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="7593b-2423"><paramref name="method" /> 不是 <see langword="null" />，它所表示的方法返回 <see langword="void" />，而不是 <see langword="static" />（Visual Basic 中为 <see langword="Shared" />），或者并非采用两个参数。</span><span class="sxs-lookup"><span data-stu-id="7593b-2423"><paramref name="method" /> is not <see langword="null" /> and the method it represents returns <see langword="void" />, is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic), or does not take exactly two arguments.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="7593b-2424"><paramref name="method" /> 为 <see langword="null" />，且没有为 <paramref name="left" />.Type 和 <paramref name="right" />.Type 定义取模运算符。</span><span class="sxs-lookup"><span data-stu-id="7593b-2424"><paramref name="method" /> is <see langword="null" /> and the modulus operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ModuloAssign">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="7593b-2425">创建一个表示余数赋值运算的 <see cref="T:System.Linq.Expressions.BinaryExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2425">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a remainder assignment operation.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ModuloAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression ModuloAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression ModuloAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ModuloAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ModuloAssign (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ ModuloAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member ModuloAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.ModuloAssign (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="7593b-2426">要将 <see cref="T:System.Linq.Expressions.Expression" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2426">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="7593b-2427">要将 <see cref="T:System.Linq.Expressions.Expression" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2427">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="7593b-2428">创建一个表示余数赋值运算的 <see cref="T:System.Linq.Expressions.BinaryExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2428">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a remainder assignment operation.</span></span></summary>
        <returns><span data-ttu-id="7593b-2429">一个 <see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 属性等于 <see cref="F:System.Linq.Expressions.ExpressionType.ModuloAssign" />，并且其 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 属性设置为指定值。</span><span class="sxs-lookup"><span data-stu-id="7593b-2429">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.ModuloAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ModuloAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression ModuloAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression ModuloAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ModuloAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ModuloAssign (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ ModuloAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member ModuloAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.ModuloAssign (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="7593b-2430">要将 <see cref="T:System.Linq.Expressions.Expression" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2430">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="7593b-2431">要将 <see cref="T:System.Linq.Expressions.Expression" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2431">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <param name="method"><span data-ttu-id="7593b-2432">要将 <see cref="T:System.Reflection.MethodInfo" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2432">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="7593b-2433">创建一个表示余数赋值运算的 <see cref="T:System.Linq.Expressions.BinaryExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2433">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a remainder assignment operation.</span></span></summary>
        <returns><span data-ttu-id="7593b-2434">一个 <see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 属性等于 <see cref="F:System.Linq.Expressions.ExpressionType.ModuloAssign" />，并且其 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />、<see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> 属性设置为指定值。</span><span class="sxs-lookup"><span data-stu-id="7593b-2434">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.ModuloAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ModuloAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression ModuloAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method, System.Linq.Expressions.LambdaExpression conversion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression ModuloAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method, class System.Linq.Expressions.LambdaExpression conversion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ModuloAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ModuloAssign (left As Expression, right As Expression, method As MethodInfo, conversion As LambdaExpression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ ModuloAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method, System::Linq::Expressions::LambdaExpression ^ conversion);" />
      <MemberSignature Language="F#" Value="static member ModuloAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo * System.Linq.Expressions.LambdaExpression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.ModuloAssign (left, right, method, conversion)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="conversion" Type="System.Linq.Expressions.LambdaExpression" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="7593b-2435">要将 <see cref="T:System.Linq.Expressions.Expression" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2435">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="7593b-2436">要将 <see cref="T:System.Linq.Expressions.Expression" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2436">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <param name="method"><span data-ttu-id="7593b-2437">要将 <see cref="T:System.Reflection.MethodInfo" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2437">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span></span></param>
        <param name="conversion"><span data-ttu-id="7593b-2438">要将 <see cref="T:System.Linq.Expressions.LambdaExpression" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2438">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="7593b-2439">创建一个表示余数赋值运算的 <see cref="T:System.Linq.Expressions.BinaryExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2439">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a remainder assignment operation.</span></span></summary>
        <returns><span data-ttu-id="7593b-2440">一个 <see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 属性等于 <see cref="F:System.Linq.Expressions.ExpressionType.ModuloAssign" />，并且其 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />、<see cref="P:System.Linq.Expressions.BinaryExpression.Right" />、<see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> 属性设置为指定值。</span><span class="sxs-lookup"><span data-stu-id="7593b-2440">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.ModuloAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Multiply">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="7593b-2441">创建一个表示不进行溢出检查的算术乘法运算的 <see cref="T:System.Linq.Expressions.BinaryExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2441">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an arithmetic multiplication operation that does not have overflow checking.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Multiply">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Multiply (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Multiply(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Multiply(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Multiply (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Multiply(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member Multiply : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.Multiply (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="7593b-2442">要将 <see cref="T:System.Linq.Expressions.Expression" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2442">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="7593b-2443">要将 <see cref="T:System.Linq.Expressions.Expression" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2443">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="7593b-2444">创建一个表示不进行溢出检查的算术乘法运算的 <see cref="T:System.Linq.Expressions.BinaryExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2444">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an arithmetic multiplication operation that does not have overflow checking.</span></span></summary>
        <returns><span data-ttu-id="7593b-2445">一个 <see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 属性等于 <see cref="F:System.Linq.Expressions.ExpressionType.Multiply" />，并且其 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 属性设置为指定值。</span><span class="sxs-lookup"><span data-stu-id="7593b-2445">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Multiply" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7593b-2446">生成的 <xref:System.Linq.Expressions.BinaryExpression> 具有设置为实现方法的 <xref:System.Linq.Expressions.BinaryExpression.Method%2A> 属性。</span><span class="sxs-lookup"><span data-stu-id="7593b-2446">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="7593b-2447"><xref:System.Linq.Expressions.Expression.Type%2A> 属性设置为节点的类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-2447">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="7593b-2448">如果节点已提升，则 <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> 和 <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> 属性均 `true`。</span><span class="sxs-lookup"><span data-stu-id="7593b-2448">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="7593b-2449">否则，它们 `false`。</span><span class="sxs-lookup"><span data-stu-id="7593b-2449">Otherwise, they are `false`.</span></span> <span data-ttu-id="7593b-2450"><xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> 属性为 `null`。</span><span class="sxs-lookup"><span data-stu-id="7593b-2450">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="7593b-2451">以下信息描述了实现方法、节点类型以及节点是否已提升。</span><span class="sxs-lookup"><span data-stu-id="7593b-2451">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="7593b-2452">实现方法</span><span class="sxs-lookup"><span data-stu-id="7593b-2452">Implementing Method</span></span>  
 <span data-ttu-id="7593b-2453">以下规则确定为操作选定的实现方法：</span><span class="sxs-lookup"><span data-stu-id="7593b-2453">The following rules determine the selected implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="7593b-2454">如果 `left` 或 `right` 的 <xref:System.Linq.Expressions.Expression.Type%2A> 属性表示重载乘法运算符的用户定义类型，则表示该方法的 <xref:System.Reflection.MethodInfo> 是实现方法。</span><span class="sxs-lookup"><span data-stu-id="7593b-2454">If the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the multiplication operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="7593b-2455">否则，如果 `left`。键入并 `right`。类型为数值类型，则实现方法为 `null`。</span><span class="sxs-lookup"><span data-stu-id="7593b-2455">Otherwise, if `left`.Type and `right`.Type are numeric types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="7593b-2456">节点类型和提升和非提升</span><span class="sxs-lookup"><span data-stu-id="7593b-2456">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="7593b-2457">如果不 `null`实现方法：</span><span class="sxs-lookup"><span data-stu-id="7593b-2457">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="7593b-2458">如果 `left`。键入并 `right`。类型可分配给实现方法的相应参数类型，不提升节点。</span><span class="sxs-lookup"><span data-stu-id="7593b-2458">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="7593b-2459">节点的类型是实现方法的返回类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-2459">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="7593b-2460">如果满足以下两个条件，则会提升节点，并且该节点的类型为与实现方法的返回类型对应的可以为 null 的类型：</span><span class="sxs-lookup"><span data-stu-id="7593b-2460">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="7593b-2461">`left`。键入并 `right`。类型既是值类型，其中至少有一个可为 null，并且相应的不可为 null 的类型等于实现方法的相应参数类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-2461">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="7593b-2462">实现方法的返回类型是不可为 null 的值类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-2462">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="7593b-2463">如果实现方法为 `null`：</span><span class="sxs-lookup"><span data-stu-id="7593b-2463">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="7593b-2464">如果 `left`。键入并 `right`。类型不可以为 null，则不提升节点。</span><span class="sxs-lookup"><span data-stu-id="7593b-2464">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="7593b-2465">节点的类型是预定义的乘法运算符的结果类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-2465">The type of the node is the result type of the predefined multiplication operator.</span></span>  
  
-   <span data-ttu-id="7593b-2466">如果 `left`。键入并 `right`。类型均可为 null，则提升节点。</span><span class="sxs-lookup"><span data-stu-id="7593b-2466">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="7593b-2467">节点的类型是与预定义乘法运算符的结果类型对应的可以为 null 的类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-2467">The type of the node is the nullable type that corresponds to the result type of the predefined multiplication operator.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="7593b-2468">下面的代码示例演示如何创建一个表达式，用于将两个值相乘。</span><span class="sxs-lookup"><span data-stu-id="7593b-2468">The following code example shows how to create an expression that multiplies two values.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#27](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#27)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#27](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#27)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="7593b-2469"><paramref name="left" /> 或 <paramref name="right" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2469"><paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="7593b-2470">没有为 <paramref name="left" />.Type 和 <paramref name="right" />.Type 定义乘法运算符。</span><span class="sxs-lookup"><span data-stu-id="7593b-2470">The multiplication operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Multiply">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Multiply (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Multiply(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Multiply(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Multiply (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Multiply(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member Multiply : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.Multiply (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="7593b-2471">要将 <see cref="T:System.Linq.Expressions.Expression" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2471">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="7593b-2472">要将 <see cref="T:System.Linq.Expressions.Expression" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2472">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <param name="method"><span data-ttu-id="7593b-2473">要将 <see cref="T:System.Reflection.MethodInfo" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2473">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="7593b-2474">创建一个表示不进行溢出检查的算术乘法运算的 <see cref="T:System.Linq.Expressions.BinaryExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2474">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an arithmetic multiplication operation that does not have overflow checking.</span></span></summary>
        <returns><span data-ttu-id="7593b-2475">一个 <see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 属性等于 <see cref="F:System.Linq.Expressions.ExpressionType.Multiply" />，并且其 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />、<see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> 属性设置为指定值。</span><span class="sxs-lookup"><span data-stu-id="7593b-2475">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Multiply" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7593b-2476">生成的 <xref:System.Linq.Expressions.BinaryExpression> 具有设置为实现方法的 <xref:System.Linq.Expressions.BinaryExpression.Method%2A> 属性。</span><span class="sxs-lookup"><span data-stu-id="7593b-2476">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="7593b-2477"><xref:System.Linq.Expressions.Expression.Type%2A> 属性设置为节点的类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-2477">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="7593b-2478">如果节点已提升，则 <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> 和 <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> 属性均 `true`。</span><span class="sxs-lookup"><span data-stu-id="7593b-2478">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="7593b-2479">否则，它们 `false`。</span><span class="sxs-lookup"><span data-stu-id="7593b-2479">Otherwise, they are `false`.</span></span> <span data-ttu-id="7593b-2480"><xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> 属性为 `null`。</span><span class="sxs-lookup"><span data-stu-id="7593b-2480">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="7593b-2481">以下信息描述了实现方法、节点类型以及节点是否已提升。</span><span class="sxs-lookup"><span data-stu-id="7593b-2481">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="7593b-2482">实现方法</span><span class="sxs-lookup"><span data-stu-id="7593b-2482">Implementing Method</span></span>  
 <span data-ttu-id="7593b-2483">以下规则确定操作的实现方法：</span><span class="sxs-lookup"><span data-stu-id="7593b-2483">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="7593b-2484">如果 `method` 未 `null` 并且它表示采用两个自变量的非 void、`static``Shared` （Visual Basic）方法，则它是节点的实现方法。</span><span class="sxs-lookup"><span data-stu-id="7593b-2484">If `method` is not `null` and it represents a non-void, `static` (`Shared` in Visual Basic) method that takes two arguments, it is the implementing method for the node.</span></span>  
  
-   <span data-ttu-id="7593b-2485">否则，如果 `left` 或 `right` 的 <xref:System.Linq.Expressions.Expression.Type%2A> 属性表示重载乘法运算符的用户定义类型，则表示该方法的 <xref:System.Reflection.MethodInfo> 是实现方法。</span><span class="sxs-lookup"><span data-stu-id="7593b-2485">Otherwise, if the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the multiplication operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="7593b-2486">否则，如果 `left`。键入并 `right`。类型为数值类型，则实现方法为 `null`。</span><span class="sxs-lookup"><span data-stu-id="7593b-2486">Otherwise, if `left`.Type and `right`.Type are numeric types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="7593b-2487">节点类型和提升和非提升</span><span class="sxs-lookup"><span data-stu-id="7593b-2487">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="7593b-2488">如果不 `null`实现方法：</span><span class="sxs-lookup"><span data-stu-id="7593b-2488">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="7593b-2489">如果 `left`。键入并 `right`。类型可分配给实现方法的相应参数类型，不提升节点。</span><span class="sxs-lookup"><span data-stu-id="7593b-2489">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="7593b-2490">节点的类型是实现方法的返回类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-2490">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="7593b-2491">如果满足以下两个条件，则会提升节点，并且该节点的类型为与实现方法的返回类型对应的可以为 null 的类型：</span><span class="sxs-lookup"><span data-stu-id="7593b-2491">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="7593b-2492">`left`。键入并 `right`。类型既是值类型，其中至少有一个可为 null，并且相应的不可为 null 的类型等于实现方法的相应参数类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-2492">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="7593b-2493">实现方法的返回类型是不可为 null 的值类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-2493">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="7593b-2494">如果实现方法为 `null`：</span><span class="sxs-lookup"><span data-stu-id="7593b-2494">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="7593b-2495">如果 `left`。键入并 `right`。类型不可以为 null，则不提升节点。</span><span class="sxs-lookup"><span data-stu-id="7593b-2495">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="7593b-2496">节点的类型是预定义的乘法运算符的结果类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-2496">The type of the node is the result type of the predefined multiplication operator.</span></span>  
  
-   <span data-ttu-id="7593b-2497">如果 `left`。键入并 `right`。类型均可为 null，则提升节点。</span><span class="sxs-lookup"><span data-stu-id="7593b-2497">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="7593b-2498">节点的类型是与预定义乘法运算符的结果类型对应的可以为 null 的类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-2498">The type of the node is the nullable type that corresponds to the result type of the predefined multiplication operator.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="7593b-2499"><paramref name="left" /> 或 <paramref name="right" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2499"><paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="7593b-2500"><paramref name="method" /> 不是 <see langword="null" />，它所表示的方法返回 <see langword="void" />，而不是 <see langword="static" />（Visual Basic 中为 <see langword="Shared" />），或者并非采用两个参数。</span><span class="sxs-lookup"><span data-stu-id="7593b-2500"><paramref name="method" /> is not <see langword="null" /> and the method it represents returns <see langword="void" />, is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic), or does not take exactly two arguments.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="7593b-2501"><paramref name="method" /> 为 <see langword="null" />，并且没有为 <paramref name="left" />.Type 和 <paramref name="right" />.Type 定义乘法运算符。</span><span class="sxs-lookup"><span data-stu-id="7593b-2501"><paramref name="method" /> is <see langword="null" /> and the multiplication operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="MultiplyAssign">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="7593b-2502">创建一个表示不进行溢出检查的乘法赋值运算的 <see cref="T:System.Linq.Expressions.BinaryExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2502">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a multiplication assignment operation that does not have overflow checking.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MultiplyAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression MultiplyAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression MultiplyAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MultiplyAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MultiplyAssign (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ MultiplyAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member MultiplyAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.MultiplyAssign (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="7593b-2503">要将 <see cref="T:System.Linq.Expressions.Expression" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2503">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="7593b-2504">要将 <see cref="T:System.Linq.Expressions.Expression" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2504">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="7593b-2505">创建一个表示不进行溢出检查的乘法赋值运算的 <see cref="T:System.Linq.Expressions.BinaryExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2505">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a multiplication assignment operation that does not have overflow checking.</span></span></summary>
        <returns><span data-ttu-id="7593b-2506">一个 <see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 属性等于 <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssign" />，并且其 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 属性设置为指定值。</span><span class="sxs-lookup"><span data-stu-id="7593b-2506">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MultiplyAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression MultiplyAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression MultiplyAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MultiplyAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MultiplyAssign (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ MultiplyAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member MultiplyAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.MultiplyAssign (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="7593b-2507">要将 <see cref="T:System.Linq.Expressions.Expression" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2507">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="7593b-2508">要将 <see cref="T:System.Linq.Expressions.Expression" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2508">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <param name="method"><span data-ttu-id="7593b-2509">要将 <see cref="T:System.Reflection.MethodInfo" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2509">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="7593b-2510">创建一个表示不进行溢出检查的乘法赋值运算的 <see cref="T:System.Linq.Expressions.BinaryExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2510">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a multiplication assignment operation that does not have overflow checking.</span></span></summary>
        <returns><span data-ttu-id="7593b-2511">一个 <see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 属性等于 <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssign" />，并且其 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />、<see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> 属性设置为指定值。</span><span class="sxs-lookup"><span data-stu-id="7593b-2511">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MultiplyAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression MultiplyAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method, System.Linq.Expressions.LambdaExpression conversion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression MultiplyAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method, class System.Linq.Expressions.LambdaExpression conversion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MultiplyAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MultiplyAssign (left As Expression, right As Expression, method As MethodInfo, conversion As LambdaExpression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ MultiplyAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method, System::Linq::Expressions::LambdaExpression ^ conversion);" />
      <MemberSignature Language="F#" Value="static member MultiplyAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo * System.Linq.Expressions.LambdaExpression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.MultiplyAssign (left, right, method, conversion)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="conversion" Type="System.Linq.Expressions.LambdaExpression" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="7593b-2512">要将 <see cref="T:System.Linq.Expressions.Expression" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2512">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="7593b-2513">要将 <see cref="T:System.Linq.Expressions.Expression" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2513">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <param name="method"><span data-ttu-id="7593b-2514">要将 <see cref="T:System.Reflection.MethodInfo" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2514">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span></span></param>
        <param name="conversion"><span data-ttu-id="7593b-2515">要将 <see cref="T:System.Linq.Expressions.LambdaExpression" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2515">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="7593b-2516">创建一个表示不进行溢出检查的乘法赋值运算的 <see cref="T:System.Linq.Expressions.BinaryExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2516">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a multiplication assignment operation that does not have overflow checking.</span></span></summary>
        <returns><span data-ttu-id="7593b-2517">一个 <see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 属性等于 <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssign" />，并且其 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />、<see cref="P:System.Linq.Expressions.BinaryExpression.Right" />、<see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> 属性设置为指定值。</span><span class="sxs-lookup"><span data-stu-id="7593b-2517">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="MultiplyAssignChecked">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="7593b-2518">创建一个表示进行溢出检查的乘法赋值运算的 <see cref="T:System.Linq.Expressions.BinaryExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2518">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a multiplication assignment operation that has overflow checking.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MultiplyAssignChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression MultiplyAssignChecked (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression MultiplyAssignChecked(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MultiplyAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MultiplyAssignChecked (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ MultiplyAssignChecked(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member MultiplyAssignChecked : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.MultiplyAssignChecked (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="7593b-2519">要将 <see cref="T:System.Linq.Expressions.Expression" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2519">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="7593b-2520">要将 <see cref="T:System.Linq.Expressions.Expression" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2520">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="7593b-2521">创建一个表示进行溢出检查的乘法赋值运算的 <see cref="T:System.Linq.Expressions.BinaryExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2521">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a multiplication assignment operation that has overflow checking.</span></span></summary>
        <returns><span data-ttu-id="7593b-2522">一个 <see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 属性等于 <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssignChecked" />，并且其 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 属性设置为指定值。</span><span class="sxs-lookup"><span data-stu-id="7593b-2522">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssignChecked" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MultiplyAssignChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression MultiplyAssignChecked (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression MultiplyAssignChecked(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MultiplyAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MultiplyAssignChecked (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ MultiplyAssignChecked(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member MultiplyAssignChecked : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.MultiplyAssignChecked (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="7593b-2523">要将 <see cref="T:System.Linq.Expressions.Expression" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2523">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="7593b-2524">要将 <see cref="T:System.Linq.Expressions.Expression" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2524">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <param name="method"><span data-ttu-id="7593b-2525">要将 <see cref="T:System.Reflection.MethodInfo" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2525">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="7593b-2526">创建一个表示进行溢出检查的乘法赋值运算的 <see cref="T:System.Linq.Expressions.BinaryExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2526">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a multiplication assignment operation that has overflow checking.</span></span></summary>
        <returns><span data-ttu-id="7593b-2527">一个 <see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 属性等于 <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssignChecked" />，并且其 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />、<see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> 属性设置为指定值。</span><span class="sxs-lookup"><span data-stu-id="7593b-2527">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssignChecked" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MultiplyAssignChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression MultiplyAssignChecked (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method, System.Linq.Expressions.LambdaExpression conversion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression MultiplyAssignChecked(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method, class System.Linq.Expressions.LambdaExpression conversion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MultiplyAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MultiplyAssignChecked (left As Expression, right As Expression, method As MethodInfo, conversion As LambdaExpression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ MultiplyAssignChecked(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method, System::Linq::Expressions::LambdaExpression ^ conversion);" />
      <MemberSignature Language="F#" Value="static member MultiplyAssignChecked : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo * System.Linq.Expressions.LambdaExpression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.MultiplyAssignChecked (left, right, method, conversion)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="conversion" Type="System.Linq.Expressions.LambdaExpression" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="7593b-2528">要将 <see cref="T:System.Linq.Expressions.Expression" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2528">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="7593b-2529">要将 <see cref="T:System.Linq.Expressions.Expression" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2529">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <param name="method"><span data-ttu-id="7593b-2530">要将 <see cref="T:System.Reflection.MethodInfo" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2530">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span></span></param>
        <param name="conversion"><span data-ttu-id="7593b-2531">要将 <see cref="T:System.Linq.Expressions.LambdaExpression" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2531">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="7593b-2532">创建一个表示进行溢出检查的乘法赋值运算的 <see cref="T:System.Linq.Expressions.BinaryExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2532">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a multiplication assignment operation that has overflow checking.</span></span></summary>
        <returns><span data-ttu-id="7593b-2533">一个 <see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 属性等于 <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssignChecked" />，并且其 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />、<see cref="P:System.Linq.Expressions.BinaryExpression.Right" />、<see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> 属性设置为指定值。</span><span class="sxs-lookup"><span data-stu-id="7593b-2533">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssignChecked" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="MultiplyChecked">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="7593b-2534">创建一个表示进行溢出检查的算术乘法运算的 <see cref="T:System.Linq.Expressions.BinaryExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2534">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an arithmetic multiplication operation that has overflow checking.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MultiplyChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression MultiplyChecked (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression MultiplyChecked(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MultiplyChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MultiplyChecked (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ MultiplyChecked(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member MultiplyChecked : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.MultiplyChecked (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="7593b-2535">要将 <see cref="T:System.Linq.Expressions.Expression" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2535">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="7593b-2536">要将 <see cref="T:System.Linq.Expressions.Expression" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2536">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="7593b-2537">创建一个表示进行溢出检查的算术乘法运算的 <see cref="T:System.Linq.Expressions.BinaryExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2537">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an arithmetic multiplication operation that has overflow checking.</span></span></summary>
        <returns><span data-ttu-id="7593b-2538">一个 <see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 属性等于 <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyChecked" />，并且其 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 属性设置为指定值。</span><span class="sxs-lookup"><span data-stu-id="7593b-2538">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyChecked" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7593b-2539">生成的 <xref:System.Linq.Expressions.BinaryExpression> 具有设置为实现方法的 <xref:System.Linq.Expressions.BinaryExpression.Method%2A> 属性。</span><span class="sxs-lookup"><span data-stu-id="7593b-2539">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="7593b-2540"><xref:System.Linq.Expressions.Expression.Type%2A> 属性设置为节点的类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-2540">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="7593b-2541">如果节点已提升，则 <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> 和 <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> 属性均 `true`。</span><span class="sxs-lookup"><span data-stu-id="7593b-2541">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="7593b-2542">否则，它们 `false`。</span><span class="sxs-lookup"><span data-stu-id="7593b-2542">Otherwise, they are `false`.</span></span> <span data-ttu-id="7593b-2543"><xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> 属性为 `null`。</span><span class="sxs-lookup"><span data-stu-id="7593b-2543">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="7593b-2544">以下信息描述了实现方法、节点类型以及节点是否已提升。</span><span class="sxs-lookup"><span data-stu-id="7593b-2544">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="7593b-2545">实现方法</span><span class="sxs-lookup"><span data-stu-id="7593b-2545">Implementing Method</span></span>  
 <span data-ttu-id="7593b-2546">以下规则确定为操作选定的实现方法：</span><span class="sxs-lookup"><span data-stu-id="7593b-2546">The following rules determine the selected implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="7593b-2547">如果 `left` 或 `right` 的 <xref:System.Linq.Expressions.Expression.Type%2A> 属性表示重载乘法运算符的用户定义类型，则表示该方法的 <xref:System.Reflection.MethodInfo> 是实现方法。</span><span class="sxs-lookup"><span data-stu-id="7593b-2547">If the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the multiplication operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="7593b-2548">否则，如果 `left`。键入并 `right`。类型为数值类型，则实现方法为 `null`。</span><span class="sxs-lookup"><span data-stu-id="7593b-2548">Otherwise, if `left`.Type and `right`.Type are numeric types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="7593b-2549">节点类型和提升和非提升</span><span class="sxs-lookup"><span data-stu-id="7593b-2549">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="7593b-2550">如果不 `null`实现方法：</span><span class="sxs-lookup"><span data-stu-id="7593b-2550">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="7593b-2551">如果 `left`。键入并 `right`。类型可分配给实现方法的相应参数类型，不提升节点。</span><span class="sxs-lookup"><span data-stu-id="7593b-2551">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="7593b-2552">节点的类型是实现方法的返回类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-2552">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="7593b-2553">如果满足以下两个条件，则会提升节点，并且该节点的类型为与实现方法的返回类型对应的可以为 null 的类型：</span><span class="sxs-lookup"><span data-stu-id="7593b-2553">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="7593b-2554">`left`。键入并 `right`。类型既是值类型，其中至少有一个可为 null，并且相应的不可为 null 的类型等于实现方法的相应参数类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-2554">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="7593b-2555">实现方法的返回类型是不可为 null 的值类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-2555">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="7593b-2556">如果实现方法为 `null`：</span><span class="sxs-lookup"><span data-stu-id="7593b-2556">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="7593b-2557">如果 `left`。键入并 `right`。类型不可以为 null，则不提升节点。</span><span class="sxs-lookup"><span data-stu-id="7593b-2557">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="7593b-2558">节点的类型是预定义的乘法运算符的结果类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-2558">The type of the node is the result type of the predefined multiplication operator.</span></span>  
  
-   <span data-ttu-id="7593b-2559">如果 `left`。键入并 `right`。类型均可为 null，则提升节点。</span><span class="sxs-lookup"><span data-stu-id="7593b-2559">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="7593b-2560">节点的类型是与预定义乘法运算符的结果类型对应的可以为 null 的类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-2560">The type of the node is the nullable type that corresponds to the result type of the predefined multiplication operator.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="7593b-2561"><paramref name="left" /> 或 <paramref name="right" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2561"><paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="7593b-2562">没有为 <paramref name="left" />.Type 和 <paramref name="right" />.Type 定义乘法运算符。</span><span class="sxs-lookup"><span data-stu-id="7593b-2562">The multiplication operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="MultiplyChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression MultiplyChecked (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression MultiplyChecked(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MultiplyChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MultiplyChecked (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ MultiplyChecked(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member MultiplyChecked : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.MultiplyChecked (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="7593b-2563">要将 <see cref="T:System.Linq.Expressions.Expression" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2563">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="7593b-2564">要将 <see cref="T:System.Linq.Expressions.Expression" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2564">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <param name="method"><span data-ttu-id="7593b-2565">要将 <see cref="T:System.Reflection.MethodInfo" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2565">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="7593b-2566">创建一个表示进行溢出检查的算术乘法运算的 <see cref="T:System.Linq.Expressions.BinaryExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2566">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an arithmetic multiplication operation that has overflow checking.</span></span></summary>
        <returns><span data-ttu-id="7593b-2567">一个 <see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 属性等于 <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyChecked" />，并且其 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />、<see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> 属性设置为指定值。</span><span class="sxs-lookup"><span data-stu-id="7593b-2567">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyChecked" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7593b-2568">生成的 <xref:System.Linq.Expressions.BinaryExpression> 具有设置为实现方法的 <xref:System.Linq.Expressions.BinaryExpression.Method%2A> 属性。</span><span class="sxs-lookup"><span data-stu-id="7593b-2568">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="7593b-2569"><xref:System.Linq.Expressions.Expression.Type%2A> 属性设置为节点的类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-2569">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="7593b-2570">如果节点已提升，则 <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> 和 <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> 属性均 `true`。</span><span class="sxs-lookup"><span data-stu-id="7593b-2570">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="7593b-2571">否则，它们 `false`。</span><span class="sxs-lookup"><span data-stu-id="7593b-2571">Otherwise, they are `false`.</span></span> <span data-ttu-id="7593b-2572"><xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> 属性为 `null`。</span><span class="sxs-lookup"><span data-stu-id="7593b-2572">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="7593b-2573">以下信息描述了实现方法、节点类型以及节点是否已提升。</span><span class="sxs-lookup"><span data-stu-id="7593b-2573">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="7593b-2574">实现方法</span><span class="sxs-lookup"><span data-stu-id="7593b-2574">Implementing Method</span></span>  
 <span data-ttu-id="7593b-2575">以下规则确定操作的实现方法：</span><span class="sxs-lookup"><span data-stu-id="7593b-2575">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="7593b-2576">如果 `method` 未 `null` 并且它表示采用两个自变量的非 void、`static``Shared` （Visual Basic）方法，则它是节点的实现方法。</span><span class="sxs-lookup"><span data-stu-id="7593b-2576">If `method` is not `null` and it represents a non-void, `static` (`Shared` in Visual Basic) method that takes two arguments, it is the implementing method for the node.</span></span>  
  
-   <span data-ttu-id="7593b-2577">否则，如果 `left` 或 `right` 的 <xref:System.Linq.Expressions.Expression.Type%2A> 属性表示重载乘法运算符的用户定义类型，则表示该方法的 <xref:System.Reflection.MethodInfo> 是实现方法。</span><span class="sxs-lookup"><span data-stu-id="7593b-2577">Otherwise, if the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the multiplication operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="7593b-2578">否则，如果 `left`。键入并 `right`。类型为数值类型，则实现方法为 `null`。</span><span class="sxs-lookup"><span data-stu-id="7593b-2578">Otherwise, if `left`.Type and `right`.Type are numeric types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="7593b-2579">节点类型和提升和非提升</span><span class="sxs-lookup"><span data-stu-id="7593b-2579">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="7593b-2580">如果不 `null`实现方法：</span><span class="sxs-lookup"><span data-stu-id="7593b-2580">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="7593b-2581">如果 `left`。键入并 `right`。类型可分配给实现方法的相应参数类型，不提升节点。</span><span class="sxs-lookup"><span data-stu-id="7593b-2581">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="7593b-2582">节点的类型是实现方法的返回类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-2582">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="7593b-2583">如果满足以下两个条件，则会提升节点，并且该节点的类型为与实现方法的返回类型对应的可以为 null 的类型：</span><span class="sxs-lookup"><span data-stu-id="7593b-2583">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="7593b-2584">`left`。键入并 `right`。类型既是值类型，其中至少有一个可为 null，并且相应的不可为 null 的类型等于实现方法的相应参数类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-2584">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="7593b-2585">实现方法的返回类型是不可为 null 的值类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-2585">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="7593b-2586">如果实现方法为 `null`：</span><span class="sxs-lookup"><span data-stu-id="7593b-2586">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="7593b-2587">如果 `left`。键入并 `right`。类型不可以为 null，则不提升节点。</span><span class="sxs-lookup"><span data-stu-id="7593b-2587">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="7593b-2588">节点的类型是预定义的乘法运算符的结果类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-2588">The type of the node is the result type of the predefined multiplication operator.</span></span>  
  
-   <span data-ttu-id="7593b-2589">如果 `left`。键入并 `right`。类型均可为 null，则提升节点。</span><span class="sxs-lookup"><span data-stu-id="7593b-2589">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="7593b-2590">节点的类型是与预定义乘法运算符的结果类型对应的可以为 null 的类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-2590">The type of the node is the nullable type that corresponds to the result type of the predefined multiplication operator.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="7593b-2591"><paramref name="left" /> 或 <paramref name="right" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2591"><paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="7593b-2592"><paramref name="method" /> 不是 <see langword="null" />，它所表示的方法返回 <see langword="void" />，而不是 <see langword="static" />（Visual Basic 中为 <see langword="Shared" />），或者并非采用两个参数。</span><span class="sxs-lookup"><span data-stu-id="7593b-2592"><paramref name="method" /> is not <see langword="null" /> and the method it represents returns <see langword="void" />, is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic), or does not take exactly two arguments.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="7593b-2593"><paramref name="method" /> 为 <see langword="null" />，并且没有为 <paramref name="left" />.Type 和 <paramref name="right" />.Type 定义乘法运算符。</span><span class="sxs-lookup"><span data-stu-id="7593b-2593"><paramref name="method" /> is <see langword="null" /> and the multiplication operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Negate">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="7593b-2594">创建一个表示算术求反运算的 <see cref="T:System.Linq.Expressions.UnaryExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2594">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents an arithmetic negation operation.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Negate">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression Negate (System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression Negate(class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Negate(System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ Negate(System::Linq::Expressions::Expression ^ expression);" />
      <MemberSignature Language="F#" Value="static member Negate : System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.Negate expression" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="expression"><span data-ttu-id="7593b-2595">要将 <see cref="T:System.Linq.Expressions.Expression" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2595">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="7593b-2596">创建一个表示算术求反运算的 <see cref="T:System.Linq.Expressions.UnaryExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2596">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents an arithmetic negation operation.</span></span></summary>
        <returns><span data-ttu-id="7593b-2597">一个 <see cref="T:System.Linq.Expressions.UnaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 属性等于 <see cref="F:System.Linq.Expressions.ExpressionType.Negate" />，并且其 <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> 属性设置为指定值。</span><span class="sxs-lookup"><span data-stu-id="7593b-2597">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Negate" /> and the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> property set to the specified value.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7593b-2598">生成的 <xref:System.Linq.Expressions.UnaryExpression> 的 <xref:System.Linq.Expressions.UnaryExpression.Method%2A> 属性被设置为实现方法。</span><span class="sxs-lookup"><span data-stu-id="7593b-2598">The <xref:System.Linq.Expressions.UnaryExpression.Method%2A> property of the resulting <xref:System.Linq.Expressions.UnaryExpression> is set to the implementing method.</span></span> <span data-ttu-id="7593b-2599"><xref:System.Linq.Expressions.Expression.Type%2A> 属性设置为节点的类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-2599">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="7593b-2600">如果节点已提升，则 <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> 和 <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> 属性均 `true`。</span><span class="sxs-lookup"><span data-stu-id="7593b-2600">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="7593b-2601">否则为 false。</span><span class="sxs-lookup"><span data-stu-id="7593b-2601">Otherwise, they are false.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="7593b-2602">实现方法</span><span class="sxs-lookup"><span data-stu-id="7593b-2602">Implementing Method</span></span>  
 <span data-ttu-id="7593b-2603">以下规则确定操作的实现方法：</span><span class="sxs-lookup"><span data-stu-id="7593b-2603">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="7593b-2604">如果 `expression`。类型是定义一元减号运算符的用户定义类型，表示该运算符的 <xref:System.Reflection.MethodInfo> 是实现方法。</span><span class="sxs-lookup"><span data-stu-id="7593b-2604">If `expression`.Type is a user-defined type that defines the unary minus operator, the <xref:System.Reflection.MethodInfo> that represents that operator is the implementing method.</span></span>  
  
-   <span data-ttu-id="7593b-2605">否则，如果 `expression`。Type 为数值类型，则实现方法为 `null`。</span><span class="sxs-lookup"><span data-stu-id="7593b-2605">Otherwise, if `expression`.Type is a numeric type, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="7593b-2606">节点类型和提升和非提升</span><span class="sxs-lookup"><span data-stu-id="7593b-2606">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="7593b-2607">如果不 `null`实现方法：</span><span class="sxs-lookup"><span data-stu-id="7593b-2607">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="7593b-2608">如果 `expression`。类型可赋给实现方法的参数类型，不会提升节点。</span><span class="sxs-lookup"><span data-stu-id="7593b-2608">If `expression`.Type is assignable to the argument type of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="7593b-2609">节点的类型是实现方法的返回类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-2609">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="7593b-2610">如果满足以下两个条件，则会提升节点，并且该节点的类型为与实现方法的返回类型对应的可以为 null 的类型：</span><span class="sxs-lookup"><span data-stu-id="7593b-2610">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="7593b-2611">`expression`。类型是可以为 null 的值类型，并且相应的不可为 null 的值类型等于实现方法的参数类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-2611">`expression`.Type is a nullable value type and the corresponding non-nullable value type is equal to the argument type of the implementing method.</span></span>  
  
    -   <span data-ttu-id="7593b-2612">实现方法的返回类型是不可为 null 的值类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-2612">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="7593b-2613">如果实现方法为 `null`，则 `expression`节点的类型。类别.</span><span class="sxs-lookup"><span data-stu-id="7593b-2613">If the implementing method is `null`, the type of the node is `expression`.Type.</span></span> <span data-ttu-id="7593b-2614">如果 `expression`。类型不可为 null，则不提升节点。</span><span class="sxs-lookup"><span data-stu-id="7593b-2614">If `expression`.Type is non-nullable, the node is not lifted.</span></span> <span data-ttu-id="7593b-2615">否则，节点会提升。</span><span class="sxs-lookup"><span data-stu-id="7593b-2615">Otherwise, the node is lifted.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="7593b-2616">下面的示例演示如何创建表示算术求反运算的表达式。</span><span class="sxs-lookup"><span data-stu-id="7593b-2616">The following example demonstrates how to create an expression that represents an arithmetic negation operation.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#50](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#50)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#50](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#50)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="7593b-2617"><paramref name="expression" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2617"><paramref name="expression" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="7593b-2618">没有为 <paramref name="expression" />.Type 定义一元负运算符。</span><span class="sxs-lookup"><span data-stu-id="7593b-2618">The unary minus operator is not defined for <paramref name="expression" />.Type.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Negate">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression Negate (System.Linq.Expressions.Expression expression, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression Negate(class System.Linq.Expressions.Expression expression, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Negate(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ Negate(System::Linq::Expressions::Expression ^ expression, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member Negate : System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.Negate (expression, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="expression"><span data-ttu-id="7593b-2619">要将 <see cref="T:System.Linq.Expressions.Expression" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2619">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> property equal to.</span></span></param>
        <param name="method"><span data-ttu-id="7593b-2620">要将 <see cref="T:System.Reflection.MethodInfo" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.UnaryExpression.Method" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2620">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="7593b-2621">创建一个表示算术求反运算的 <see cref="T:System.Linq.Expressions.UnaryExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2621">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents an arithmetic negation operation.</span></span></summary>
        <returns><span data-ttu-id="7593b-2622">一个 <see cref="T:System.Linq.Expressions.UnaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 属性等于 <see cref="F:System.Linq.Expressions.ExpressionType.Negate" />，并且其 <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> 和 <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> 属性设置为指定值。</span><span class="sxs-lookup"><span data-stu-id="7593b-2622">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Negate" /> and the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> and <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7593b-2623">生成的 <xref:System.Linq.Expressions.UnaryExpression> 的 <xref:System.Linq.Expressions.UnaryExpression.Method%2A> 属性被设置为实现方法。</span><span class="sxs-lookup"><span data-stu-id="7593b-2623">The <xref:System.Linq.Expressions.UnaryExpression.Method%2A> property of the resulting <xref:System.Linq.Expressions.UnaryExpression> is set to the implementing method.</span></span> <span data-ttu-id="7593b-2624"><xref:System.Linq.Expressions.Expression.Type%2A> 属性设置为节点的类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-2624">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="7593b-2625">如果节点已提升，则 <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> 和 <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> 属性均 `true`。</span><span class="sxs-lookup"><span data-stu-id="7593b-2625">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="7593b-2626">否则为 false。</span><span class="sxs-lookup"><span data-stu-id="7593b-2626">Otherwise, they are false.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="7593b-2627">实现方法</span><span class="sxs-lookup"><span data-stu-id="7593b-2627">Implementing Method</span></span>  
 <span data-ttu-id="7593b-2628">以下规则确定操作的实现方法：</span><span class="sxs-lookup"><span data-stu-id="7593b-2628">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="7593b-2629">如果 `method` 未 `null` 并且它表示采用一个自变量的非 void、`static` （Visual Basic`Shared`）方法，则该方法为节点的实现方法。</span><span class="sxs-lookup"><span data-stu-id="7593b-2629">If `method` is not `null` and it represents a non-void, `static` (`Shared` in Visual Basic) method that takes one argument, it is the implementing method for the node.</span></span>  
  
-   <span data-ttu-id="7593b-2630">如果 `expression`。类型是定义一元减号运算符的用户定义类型，表示该运算符的 <xref:System.Reflection.MethodInfo> 是实现方法。</span><span class="sxs-lookup"><span data-stu-id="7593b-2630">If `expression`.Type is a user-defined type that defines the unary minus operator, the <xref:System.Reflection.MethodInfo> that represents that operator is the implementing method.</span></span>  
  
-   <span data-ttu-id="7593b-2631">否则，如果 `expression`。Type 为数值类型，则实现方法为 `null`。</span><span class="sxs-lookup"><span data-stu-id="7593b-2631">Otherwise, if `expression`.Type is a numeric type, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="7593b-2632">节点类型和提升和非提升</span><span class="sxs-lookup"><span data-stu-id="7593b-2632">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="7593b-2633">如果不 `null`实现方法：</span><span class="sxs-lookup"><span data-stu-id="7593b-2633">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="7593b-2634">如果 `expression`。类型可赋给实现方法的参数类型，不会提升节点。</span><span class="sxs-lookup"><span data-stu-id="7593b-2634">If `expression`.Type is assignable to the argument type of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="7593b-2635">节点的类型是实现方法的返回类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-2635">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="7593b-2636">如果满足以下两个条件，则会提升节点，并且该节点的类型为与实现方法的返回类型对应的可以为 null 的类型：</span><span class="sxs-lookup"><span data-stu-id="7593b-2636">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="7593b-2637">`expression`。类型是可以为 null 的值类型，并且相应的不可为 null 的值类型等于实现方法的参数类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-2637">`expression`.Type is a nullable value type and the corresponding non-nullable value type is equal to the argument type of the implementing method.</span></span>  
  
    -   <span data-ttu-id="7593b-2638">实现方法的返回类型是不可为 null 的值类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-2638">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="7593b-2639">如果实现方法为 `null`，则 `expression`节点的类型。类别.</span><span class="sxs-lookup"><span data-stu-id="7593b-2639">If the implementing method is `null`, the type of the node is `expression`.Type.</span></span> <span data-ttu-id="7593b-2640">如果 `expression`。类型不可为 null，则不提升节点。</span><span class="sxs-lookup"><span data-stu-id="7593b-2640">If `expression`.Type is non-nullable, the node is not lifted.</span></span> <span data-ttu-id="7593b-2641">否则，节点会提升。</span><span class="sxs-lookup"><span data-stu-id="7593b-2641">Otherwise, the node is lifted.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="7593b-2642"><paramref name="expression" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2642"><paramref name="expression" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="7593b-2643"><paramref name="method" /> 不为 <see langword="null" /> 且其表示的方法返回 <see langword="void" />；不为 <see langword="static" />（在 Visual Basic 中不为 <see langword="Shared" />）；或者不是正好带一个参数。</span><span class="sxs-lookup"><span data-stu-id="7593b-2643"><paramref name="method" /> is not <see langword="null" /> and the method it represents returns <see langword="void" />, is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic), or does not take exactly one argument.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="7593b-2644"><paramref name="method" /> 为 <see langword="null" />，并且没有为 <paramref name="expression" />.Type 定义一元负运算符。</span><span class="sxs-lookup"><span data-stu-id="7593b-2644"><paramref name="method" /> is <see langword="null" /> and the unary minus operator is not defined for <paramref name="expression" />.Type.</span></span>  
  
<span data-ttu-id="7593b-2645">- 或 -</span><span class="sxs-lookup"><span data-stu-id="7593b-2645">-or-</span></span> 
 <span data-ttu-id="7593b-2646"><paramref name="expression" />.Type（如果它是可以为 null 的值类型，则取其相应的不可以为 null 的类型）不能赋给 <paramref name="method" /> 所表示的方法的参数类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-2646"><paramref name="expression" />.Type (or its corresponding non-nullable type if it is a nullable value type) is not assignable to the argument type of the method represented by <paramref name="method" />.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="NegateChecked">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="7593b-2647">创建一个表示进行溢出检查的算术求反运算的 <see cref="T:System.Linq.Expressions.UnaryExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2647">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents an arithmetic negation operation that has overflow checking.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="NegateChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression NegateChecked (System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression NegateChecked(class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.NegateChecked(System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ NegateChecked(System::Linq::Expressions::Expression ^ expression);" />
      <MemberSignature Language="F#" Value="static member NegateChecked : System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.NegateChecked expression" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="expression"><span data-ttu-id="7593b-2648">要将 <see cref="T:System.Linq.Expressions.Expression" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2648">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="7593b-2649">创建一个表示进行溢出检查的算术求反运算的 <see cref="T:System.Linq.Expressions.UnaryExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2649">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents an arithmetic negation operation that has overflow checking.</span></span></summary>
        <returns><span data-ttu-id="7593b-2650">一个 <see cref="T:System.Linq.Expressions.UnaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 属性等于 <see cref="F:System.Linq.Expressions.ExpressionType.NegateChecked" />，并且其 <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> 属性设置为指定值。</span><span class="sxs-lookup"><span data-stu-id="7593b-2650">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.NegateChecked" /> and the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> property set to the specified value.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7593b-2651">生成的 <xref:System.Linq.Expressions.UnaryExpression> 的 <xref:System.Linq.Expressions.UnaryExpression.Method%2A> 属性被设置为实现方法。</span><span class="sxs-lookup"><span data-stu-id="7593b-2651">The <xref:System.Linq.Expressions.UnaryExpression.Method%2A> property of the resulting <xref:System.Linq.Expressions.UnaryExpression> is set to the implementing method.</span></span> <span data-ttu-id="7593b-2652"><xref:System.Linq.Expressions.Expression.Type%2A> 属性设置为节点的类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-2652">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="7593b-2653">如果节点已提升，则 <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> 和 <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> 属性均 `true`。</span><span class="sxs-lookup"><span data-stu-id="7593b-2653">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="7593b-2654">否则为 false。</span><span class="sxs-lookup"><span data-stu-id="7593b-2654">Otherwise, they are false.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="7593b-2655">实现方法</span><span class="sxs-lookup"><span data-stu-id="7593b-2655">Implementing Method</span></span>  
 <span data-ttu-id="7593b-2656">以下规则确定操作的实现方法：</span><span class="sxs-lookup"><span data-stu-id="7593b-2656">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="7593b-2657">如果 `expression`。类型是定义一元减号运算符的用户定义类型，表示该运算符的 <xref:System.Reflection.MethodInfo> 是实现方法。</span><span class="sxs-lookup"><span data-stu-id="7593b-2657">If `expression`.Type is a user-defined type that defines the unary minus operator, the <xref:System.Reflection.MethodInfo> that represents that operator is the implementing method.</span></span>  
  
-   <span data-ttu-id="7593b-2658">否则，如果 `expression`。Type 为数值类型，则实现方法为 `null`。</span><span class="sxs-lookup"><span data-stu-id="7593b-2658">Otherwise, if `expression`.Type is a numeric type, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="7593b-2659">节点类型和提升和非提升</span><span class="sxs-lookup"><span data-stu-id="7593b-2659">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="7593b-2660">如果不 `null`实现方法：</span><span class="sxs-lookup"><span data-stu-id="7593b-2660">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="7593b-2661">如果 `expression`。类型可赋给实现方法的参数类型，不会提升节点。</span><span class="sxs-lookup"><span data-stu-id="7593b-2661">If `expression`.Type is assignable to the argument type of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="7593b-2662">节点的类型是实现方法的返回类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-2662">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="7593b-2663">如果满足以下两个条件，则会提升节点，并且该节点的类型为与实现方法的返回类型对应的可以为 null 的类型：</span><span class="sxs-lookup"><span data-stu-id="7593b-2663">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="7593b-2664">`expression`。类型是可以为 null 的值类型，并且相应的不可为 null 的值类型等于实现方法的参数类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-2664">`expression`.Type is a nullable value type and the corresponding non-nullable value type is equal to the argument type of the implementing method.</span></span>  
  
    -   <span data-ttu-id="7593b-2665">实现方法的返回类型是不可为 null 的值类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-2665">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="7593b-2666">如果实现方法为 `null`，则 `expression`节点的类型。类别.</span><span class="sxs-lookup"><span data-stu-id="7593b-2666">If the implementing method is `null`, the type of the node is `expression`.Type.</span></span> <span data-ttu-id="7593b-2667">如果 `expression`。类型不可为 null，则不提升节点。</span><span class="sxs-lookup"><span data-stu-id="7593b-2667">If `expression`.Type is non-nullable, the node is not lifted.</span></span> <span data-ttu-id="7593b-2668">否则，节点会提升。</span><span class="sxs-lookup"><span data-stu-id="7593b-2668">Otherwise, the node is lifted.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="7593b-2669"><paramref name="expression" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2669"><paramref name="expression" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="7593b-2670">没有为 <paramref name="expression" />.Type 定义一元负运算符。</span><span class="sxs-lookup"><span data-stu-id="7593b-2670">The unary minus operator is not defined for <paramref name="expression" />.Type.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="NegateChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression NegateChecked (System.Linq.Expressions.Expression expression, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression NegateChecked(class System.Linq.Expressions.Expression expression, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.NegateChecked(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ NegateChecked(System::Linq::Expressions::Expression ^ expression, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member NegateChecked : System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.NegateChecked (expression, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="expression"><span data-ttu-id="7593b-2671">要将 <see cref="T:System.Linq.Expressions.Expression" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2671">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> property equal to.</span></span></param>
        <param name="method"><span data-ttu-id="7593b-2672">要将 <see cref="T:System.Reflection.MethodInfo" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.UnaryExpression.Method" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2672">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="7593b-2673">创建一个表示进行溢出检查的算术求反运算的 <see cref="T:System.Linq.Expressions.UnaryExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2673">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents an arithmetic negation operation that has overflow checking.</span></span> <span data-ttu-id="7593b-2674">可指定实现方法。</span><span class="sxs-lookup"><span data-stu-id="7593b-2674">The implementing method can be specified.</span></span></summary>
        <returns><span data-ttu-id="7593b-2675">一个 <see cref="T:System.Linq.Expressions.UnaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 属性等于 <see cref="F:System.Linq.Expressions.ExpressionType.NegateChecked" />，并且其 <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> 和 <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> 属性设置为指定值。</span><span class="sxs-lookup"><span data-stu-id="7593b-2675">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.NegateChecked" /> and the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> and <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7593b-2676">生成的 <xref:System.Linq.Expressions.UnaryExpression> 的 <xref:System.Linq.Expressions.UnaryExpression.Method%2A> 属性被设置为实现方法。</span><span class="sxs-lookup"><span data-stu-id="7593b-2676">The <xref:System.Linq.Expressions.UnaryExpression.Method%2A> property of the resulting <xref:System.Linq.Expressions.UnaryExpression> is set to the implementing method.</span></span> <span data-ttu-id="7593b-2677"><xref:System.Linq.Expressions.Expression.Type%2A> 属性设置为节点的类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-2677">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="7593b-2678">如果节点已提升，则 <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> 和 <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> 属性均 `true`。</span><span class="sxs-lookup"><span data-stu-id="7593b-2678">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="7593b-2679">否则为 false。</span><span class="sxs-lookup"><span data-stu-id="7593b-2679">Otherwise, they are false.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="7593b-2680">实现方法</span><span class="sxs-lookup"><span data-stu-id="7593b-2680">Implementing Method</span></span>  
 <span data-ttu-id="7593b-2681">以下规则确定操作的实现方法：</span><span class="sxs-lookup"><span data-stu-id="7593b-2681">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="7593b-2682">如果 `method` 未 `null` 并且它表示采用一个自变量的非 void、`static` （Visual Basic`Shared`）方法，则该方法为节点的实现方法。</span><span class="sxs-lookup"><span data-stu-id="7593b-2682">If `method` is not `null` and it represents a non-void, `static` (`Shared` in Visual Basic) method that takes one argument, it is the implementing method for the node.</span></span>  
  
-   <span data-ttu-id="7593b-2683">如果 `expression`。类型是定义一元减号运算符的用户定义类型，表示该运算符的 <xref:System.Reflection.MethodInfo> 是实现方法。</span><span class="sxs-lookup"><span data-stu-id="7593b-2683">If `expression`.Type is a user-defined type that defines the unary minus operator, the <xref:System.Reflection.MethodInfo> that represents that operator is the implementing method.</span></span>  
  
-   <span data-ttu-id="7593b-2684">否则，如果 `expression`。Type 为数值类型，则实现方法为 `null`。</span><span class="sxs-lookup"><span data-stu-id="7593b-2684">Otherwise, if `expression`.Type is a numeric type, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="7593b-2685">节点类型和提升和非提升</span><span class="sxs-lookup"><span data-stu-id="7593b-2685">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="7593b-2686">如果不 `null`实现方法：</span><span class="sxs-lookup"><span data-stu-id="7593b-2686">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="7593b-2687">如果 `expression`。类型可赋给实现方法的参数类型，不会提升节点。</span><span class="sxs-lookup"><span data-stu-id="7593b-2687">If `expression`.Type is assignable to the argument type of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="7593b-2688">节点的类型是实现方法的返回类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-2688">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="7593b-2689">如果满足以下两个条件，则会提升节点，并且该节点的类型为与实现方法的返回类型对应的可以为 null 的类型：</span><span class="sxs-lookup"><span data-stu-id="7593b-2689">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="7593b-2690">`expression`。类型是可以为 null 的值类型，并且相应的不可为 null 的值类型等于实现方法的参数类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-2690">`expression`.Type is a nullable value type and the corresponding non-nullable value type is equal to the argument type of the implementing method.</span></span>  
  
    -   <span data-ttu-id="7593b-2691">实现方法的返回类型是不可为 null 的值类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-2691">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="7593b-2692">如果实现方法为 `null`，则 `expression`节点的类型。类别.</span><span class="sxs-lookup"><span data-stu-id="7593b-2692">If the implementing method is `null`, the type of the node is `expression`.Type.</span></span> <span data-ttu-id="7593b-2693">如果 `expression`。类型不可为 null，则不提升节点。</span><span class="sxs-lookup"><span data-stu-id="7593b-2693">If `expression`.Type is non-nullable, the node is not lifted.</span></span> <span data-ttu-id="7593b-2694">否则，节点会提升。</span><span class="sxs-lookup"><span data-stu-id="7593b-2694">Otherwise, the node is lifted.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="7593b-2695"><paramref name="expression" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2695"><paramref name="expression" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="7593b-2696"><paramref name="method" /> 不为 <see langword="null" /> 且其表示的方法返回 <see langword="void" />；不为 <see langword="static" />（在 Visual Basic 中不为 <see langword="Shared" />）；或者不是正好带一个参数。</span><span class="sxs-lookup"><span data-stu-id="7593b-2696"><paramref name="method" /> is not <see langword="null" /> and the method it represents returns <see langword="void" />, is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic), or does not take exactly one argument.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="7593b-2697"><paramref name="method" /> 为 <see langword="null" />，并且没有为 <paramref name="expression" />.Type 定义一元负运算符。</span><span class="sxs-lookup"><span data-stu-id="7593b-2697"><paramref name="method" /> is <see langword="null" /> and the unary minus operator is not defined for <paramref name="expression" />.Type.</span></span>  
  
<span data-ttu-id="7593b-2698">- 或 -</span><span class="sxs-lookup"><span data-stu-id="7593b-2698">-or-</span></span> 
 <span data-ttu-id="7593b-2699"><paramref name="expression" />.Type（如果它是可以为 null 的值类型，则取其相应的不可以为 null 的类型）不能赋给 <paramref name="method" /> 所表示的方法的参数类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-2699"><paramref name="expression" />.Type (or its corresponding non-nullable type if it is a nullable value type) is not assignable to the argument type of the method represented by <paramref name="method" />.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="New">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="7593b-2700">创建一个 <see cref="T:System.Linq.Expressions.NewExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2700">Creates a <see cref="T:System.Linq.Expressions.NewExpression" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="New">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.NewExpression New (System.Reflection.ConstructorInfo constructor);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.NewExpression New(class System.Reflection.ConstructorInfo constructor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.New(System.Reflection.ConstructorInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function New (constructor As ConstructorInfo) As NewExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::NewExpression ^ New(System::Reflection::ConstructorInfo ^ constructor);" />
      <MemberSignature Language="F#" Value="static member New : System.Reflection.ConstructorInfo -&gt; System.Linq.Expressions.NewExpression" Usage="System.Linq.Expressions.Expression.New constructor" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.NewExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="constructor" Type="System.Reflection.ConstructorInfo" />
      </Parameters>
      <Docs>
        <param name="constructor"><span data-ttu-id="7593b-2701">要将 <see cref="T:System.Reflection.ConstructorInfo" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.NewExpression.Constructor" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2701">The <see cref="T:System.Reflection.ConstructorInfo" /> to set the <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="7593b-2702">创建一个表示调用不带自变量的指定构造函数的 <see cref="T:System.Linq.Expressions.NewExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2702">Creates a <see cref="T:System.Linq.Expressions.NewExpression" /> that represents calling the specified constructor that takes no arguments.</span></span></summary>
        <returns><span data-ttu-id="7593b-2703">一个 <see cref="T:System.Linq.Expressions.NewExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 属性等于 <see cref="F:System.Linq.Expressions.ExpressionType.New" />，并且其 <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> 属性设置为指定值。</span><span class="sxs-lookup"><span data-stu-id="7593b-2703">A <see cref="T:System.Linq.Expressions.NewExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.New" /> and the <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> property set to the specified value.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7593b-2704">生成的 <xref:System.Linq.Expressions.NewExpression> 的 <xref:System.Linq.Expressions.NewExpression.Arguments%2A> 和 <xref:System.Linq.Expressions.NewExpression.Members%2A> 属性为空集合。</span><span class="sxs-lookup"><span data-stu-id="7593b-2704">The <xref:System.Linq.Expressions.NewExpression.Arguments%2A> and <xref:System.Linq.Expressions.NewExpression.Members%2A> properties of the resulting <xref:System.Linq.Expressions.NewExpression> are empty collections.</span></span> <span data-ttu-id="7593b-2705"><xref:System.Linq.Expressions.Expression.Type%2A> 属性表示 `constructor`所表示的构造函数的声明类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-2705">The <xref:System.Linq.Expressions.Expression.Type%2A> property represents the declaring type of the constructor represented by `constructor`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="7593b-2706"><paramref name="constructor" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2706"><paramref name="constructor" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="7593b-2707"><paramref name="constructor" /> 表示的构造函数至少具有一个参数。</span><span class="sxs-lookup"><span data-stu-id="7593b-2707">The constructor that <paramref name="constructor" /> represents has at least one parameter.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="New">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.NewExpression New (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.NewExpression New(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.New(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::NewExpression ^ New(Type ^ type);" />
      <MemberSignature Language="F#" Value="static member New : Type -&gt; System.Linq.Expressions.NewExpression" Usage="System.Linq.Expressions.Expression.New type" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.NewExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type"><span data-ttu-id="7593b-2708">一个具有不带自变量的构造函数的 <see cref="T:System.Type" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2708">A <see cref="T:System.Type" /> that has a constructor that takes no arguments.</span></span></param>
        <summary><span data-ttu-id="7593b-2709">创建一个表示调用指定类型的无参数构造函数的 <see cref="T:System.Linq.Expressions.NewExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2709">Creates a <see cref="T:System.Linq.Expressions.NewExpression" /> that represents calling the parameterless constructor of the specified type.</span></span></summary>
        <returns><span data-ttu-id="7593b-2710">一个 <see cref="T:System.Linq.Expressions.NewExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 属性等于 <see cref="F:System.Linq.Expressions.ExpressionType.New" />，并且其 <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> 属性设置为 <see cref="T:System.Reflection.ConstructorInfo" />，这表示不带指定类型的参数的构造函数。</span><span class="sxs-lookup"><span data-stu-id="7593b-2710">A <see cref="T:System.Linq.Expressions.NewExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.New" /> and the <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> property set to the <see cref="T:System.Reflection.ConstructorInfo" /> that represents the constructor without parameters for the specified type.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7593b-2711">`type` 参数必须表示具有不带参数的构造函数的类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-2711">The `type` parameter must represent a type that has a constructor without parameters.</span></span>  
  
 <span data-ttu-id="7593b-2712">生成的 <xref:System.Linq.Expressions.NewExpression> 的 <xref:System.Linq.Expressions.NewExpression.Arguments%2A> 和 <xref:System.Linq.Expressions.NewExpression.Members%2A> 属性为空集合。</span><span class="sxs-lookup"><span data-stu-id="7593b-2712">The <xref:System.Linq.Expressions.NewExpression.Arguments%2A> and <xref:System.Linq.Expressions.NewExpression.Members%2A> properties of the resulting <xref:System.Linq.Expressions.NewExpression> are empty collections.</span></span> <span data-ttu-id="7593b-2713"><xref:System.Linq.Expressions.Expression.Type%2A> 属性等于 `type`。</span><span class="sxs-lookup"><span data-stu-id="7593b-2713">The <xref:System.Linq.Expressions.Expression.Type%2A> property is equal to `type`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="7593b-2714">下面的示例演示如何使用 <xref:System.Linq.Expressions.Expression.New%28System.Type%29> 方法，通过调用不带参数的构造函数来创建表示构造字典对象的新实例的 <xref:System.Linq.Expressions.NewExpression>。</span><span class="sxs-lookup"><span data-stu-id="7593b-2714">The following example demonstrates how to use the <xref:System.Linq.Expressions.Expression.New%28System.Type%29> method to create a <xref:System.Linq.Expressions.NewExpression> that represents constructing a new instance of a dictionary object by calling the constructor without parameters.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.Expression#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#10)]
 [!code-vb[System.Linq.Expressions.Expression#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="7593b-2715"><paramref name="type" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2715"><paramref name="type" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="7593b-2716"><paramref name="type" /> 所表示的类型不具有无参数构造函数。</span><span class="sxs-lookup"><span data-stu-id="7593b-2716">The type that <paramref name="type" /> represents does not have a constructor without parameters.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="New">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.NewExpression New (System.Reflection.ConstructorInfo constructor, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.NewExpression New(class System.Reflection.ConstructorInfo constructor, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.New(System.Reflection.ConstructorInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function New (constructor As ConstructorInfo, arguments As IEnumerable(Of Expression)) As NewExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::NewExpression ^ New(System::Reflection::ConstructorInfo ^ constructor, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberSignature Language="F#" Value="static member New : System.Reflection.ConstructorInfo * seq&lt;System.Linq.Expressions.Expression&gt; -&gt; System.Linq.Expressions.NewExpression" Usage="System.Linq.Expressions.Expression.New (constructor, arguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.NewExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="constructor" Type="System.Reflection.ConstructorInfo" />
        <Parameter Name="arguments" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="constructor"><span data-ttu-id="7593b-2717">要将 <see cref="T:System.Reflection.ConstructorInfo" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.NewExpression.Constructor" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2717">The <see cref="T:System.Reflection.ConstructorInfo" /> to set the <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> property equal to.</span></span></param>
        <param name="arguments"><span data-ttu-id="7593b-2718">一个 <see cref="T:System.Collections.Generic.IEnumerable`1" />，包含用来填充 <see cref="T:System.Linq.Expressions.Expression" /> 集合的 <see cref="P:System.Linq.Expressions.NewExpression.Arguments" /> 对象。</span><span class="sxs-lookup"><span data-stu-id="7593b-2718">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.Expression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.NewExpression.Arguments" /> collection.</span></span></param>
        <summary><span data-ttu-id="7593b-2719">创建一个表示调用带指定参数的指定构造函数的 <see cref="T:System.Linq.Expressions.NewExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2719">Creates a <see cref="T:System.Linq.Expressions.NewExpression" /> that represents calling the specified constructor with the specified arguments.</span></span></summary>
        <returns><span data-ttu-id="7593b-2720">一个 <see cref="T:System.Linq.Expressions.NewExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 属性等于 <see cref="F:System.Linq.Expressions.ExpressionType.New" />，并且其 <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> 和 <see cref="P:System.Linq.Expressions.NewExpression.Arguments" /> 属性设置为指定值。</span><span class="sxs-lookup"><span data-stu-id="7593b-2720">A <see cref="T:System.Linq.Expressions.NewExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.New" /> and the <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> and <see cref="P:System.Linq.Expressions.NewExpression.Arguments" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7593b-2721">`arguments` 参数必须包含与 `constructor`所表示的构造函数的参数数目相同的元素数目。</span><span class="sxs-lookup"><span data-stu-id="7593b-2721">The `arguments` parameter must contain the same number of elements as the number of parameters for the constructor represented by `constructor`.</span></span> <span data-ttu-id="7593b-2722">如果 `null``arguments`，则将其视为空，并且生成的 <xref:System.Linq.Expressions.NewExpression> 的 <xref:System.Linq.Expressions.NewExpression.Arguments%2A> 属性为空集合。</span><span class="sxs-lookup"><span data-stu-id="7593b-2722">If `arguments` is `null`, it is considered empty, and the <xref:System.Linq.Expressions.NewExpression.Arguments%2A> property of the resulting <xref:System.Linq.Expressions.NewExpression> is an empty collection.</span></span>  
  
 <span data-ttu-id="7593b-2723">生成的 <xref:System.Linq.Expressions.NewExpression> 的 <xref:System.Linq.Expressions.Expression.Type%2A> 属性表示 `constructor`表示的构造函数的声明类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-2723">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.NewExpression> represents the declaring type of the constructor represented by `constructor`.</span></span> <span data-ttu-id="7593b-2724"><xref:System.Linq.Expressions.NewExpression.Members%2A> 属性为空集合。</span><span class="sxs-lookup"><span data-stu-id="7593b-2724">The <xref:System.Linq.Expressions.NewExpression.Members%2A> property is an empty collection.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="7593b-2725"><paramref name="constructor" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2725"><paramref name="constructor" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="7593b-2726">- 或 -</span><span class="sxs-lookup"><span data-stu-id="7593b-2726">-or-</span></span> 
<span data-ttu-id="7593b-2727"><paramref name="arguments" /> 的元素为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2727">An element of <paramref name="arguments" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="7593b-2728"><paramref name="arguments" /> 参数包含的元素数量与 <paramref name="constructor" /> 所表示的构造函数的参数数量不同。</span><span class="sxs-lookup"><span data-stu-id="7593b-2728">The <paramref name="arguments" /> parameter does not contain the same number of elements as the number of parameters for the constructor that <paramref name="constructor" /> represents.</span></span>  
  
<span data-ttu-id="7593b-2729">- 或 -</span><span class="sxs-lookup"><span data-stu-id="7593b-2729">-or-</span></span> 
<span data-ttu-id="7593b-2730"><see cref="P:System.Linq.Expressions.Expression.Type" /> 的元素的 <paramref name="arguments" /> 属性不能赋给 <paramref name="constructor" /> 表示的构造函数的相应参数类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-2730">The <see cref="P:System.Linq.Expressions.Expression.Type" /> property of an element of <paramref name="arguments" /> is not assignable to the type of the corresponding parameter of the constructor that <paramref name="constructor" /> represents.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="New">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.NewExpression New (System.Reflection.ConstructorInfo constructor, params System.Linq.Expressions.Expression[] arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.NewExpression New(class System.Reflection.ConstructorInfo constructor, class System.Linq.Expressions.Expression[] arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.New(System.Reflection.ConstructorInfo,System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function New (constructor As ConstructorInfo, ParamArray arguments As Expression()) As NewExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::NewExpression ^ New(System::Reflection::ConstructorInfo ^ constructor, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberSignature Language="F#" Value="static member New : System.Reflection.ConstructorInfo * System.Linq.Expressions.Expression[] -&gt; System.Linq.Expressions.NewExpression" Usage="System.Linq.Expressions.Expression.New (constructor, arguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.NewExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="constructor" Type="System.Reflection.ConstructorInfo" />
        <Parameter Name="arguments" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="constructor"><span data-ttu-id="7593b-2731">要将 <see cref="T:System.Reflection.ConstructorInfo" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.NewExpression.Constructor" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2731">The <see cref="T:System.Reflection.ConstructorInfo" /> to set the <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> property equal to.</span></span></param>
        <param name="arguments"><span data-ttu-id="7593b-2732">用于填充 <see cref="T:System.Linq.Expressions.Expression" /> 集合的 <see cref="P:System.Linq.Expressions.NewExpression.Arguments" /> 对象的数组。</span><span class="sxs-lookup"><span data-stu-id="7593b-2732">An array of <see cref="T:System.Linq.Expressions.Expression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.NewExpression.Arguments" /> collection.</span></span></param>
        <summary><span data-ttu-id="7593b-2733">创建一个表示调用带指定参数的指定构造函数的 <see cref="T:System.Linq.Expressions.NewExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2733">Creates a <see cref="T:System.Linq.Expressions.NewExpression" /> that represents calling the specified constructor with the specified arguments.</span></span></summary>
        <returns><span data-ttu-id="7593b-2734">一个 <see cref="T:System.Linq.Expressions.NewExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 属性等于 <see cref="F:System.Linq.Expressions.ExpressionType.New" />，并且其 <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> 和 <see cref="P:System.Linq.Expressions.NewExpression.Arguments" /> 属性设置为指定值。</span><span class="sxs-lookup"><span data-stu-id="7593b-2734">A <see cref="T:System.Linq.Expressions.NewExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.New" /> and the <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> and <see cref="P:System.Linq.Expressions.NewExpression.Arguments" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7593b-2735">`arguments` 参数必须包含与 `constructor`所表示的构造函数的参数数目相同的元素数目。</span><span class="sxs-lookup"><span data-stu-id="7593b-2735">The `arguments` parameter must contain the same number of elements as the number of parameters for the constructor represented by `constructor`.</span></span> <span data-ttu-id="7593b-2736">如果 `null``arguments`，则将其视为空，并且生成的 <xref:System.Linq.Expressions.NewExpression> 的 <xref:System.Linq.Expressions.NewExpression.Arguments%2A> 属性为空集合。</span><span class="sxs-lookup"><span data-stu-id="7593b-2736">If `arguments` is `null`, it is considered empty, and the <xref:System.Linq.Expressions.NewExpression.Arguments%2A> property of the resulting <xref:System.Linq.Expressions.NewExpression> is an empty collection.</span></span>  
  
 <span data-ttu-id="7593b-2737">生成的 <xref:System.Linq.Expressions.NewExpression> 的 <xref:System.Linq.Expressions.Expression.Type%2A> 属性表示 `constructor`表示的构造函数的声明类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-2737">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.NewExpression> represents the declaring type of the constructor represented by `constructor`.</span></span> <span data-ttu-id="7593b-2738"><xref:System.Linq.Expressions.NewExpression.Members%2A> 属性为空集合。</span><span class="sxs-lookup"><span data-stu-id="7593b-2738">The <xref:System.Linq.Expressions.NewExpression.Members%2A> property is an empty collection.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="7593b-2739"><paramref name="constructor" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2739"><paramref name="constructor" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="7593b-2740">- 或 -</span><span class="sxs-lookup"><span data-stu-id="7593b-2740">-or-</span></span> 
<span data-ttu-id="7593b-2741"><paramref name="arguments" /> 的元素为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2741">An element of <paramref name="arguments" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="7593b-2742"><paramref name="arguments" /> 的长度与 <paramref name="constructor" /> 表示的构造函数的参数数目不符。</span><span class="sxs-lookup"><span data-stu-id="7593b-2742">The length of <paramref name="arguments" /> does match the number of parameters for the constructor that <paramref name="constructor" /> represents.</span></span>  
  
<span data-ttu-id="7593b-2743">- 或 -</span><span class="sxs-lookup"><span data-stu-id="7593b-2743">-or-</span></span> 
<span data-ttu-id="7593b-2744"><see cref="P:System.Linq.Expressions.Expression.Type" /> 的元素的 <paramref name="arguments" /> 属性不能赋给 <paramref name="constructor" /> 表示的构造函数的相应参数类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-2744">The <see cref="P:System.Linq.Expressions.Expression.Type" /> property of an element of <paramref name="arguments" /> is not assignable to the type of the corresponding parameter of the constructor that <paramref name="constructor" /> represents.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="New">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.NewExpression New (System.Reflection.ConstructorInfo constructor, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; arguments, System.Collections.Generic.IEnumerable&lt;System.Reflection.MemberInfo&gt; members);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.NewExpression New(class System.Reflection.ConstructorInfo constructor, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; arguments, class System.Collections.Generic.IEnumerable`1&lt;class System.Reflection.MemberInfo&gt; members) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.New(System.Reflection.ConstructorInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression},System.Collections.Generic.IEnumerable{System.Reflection.MemberInfo})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function New (constructor As ConstructorInfo, arguments As IEnumerable(Of Expression), members As IEnumerable(Of MemberInfo)) As NewExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::NewExpression ^ New(System::Reflection::ConstructorInfo ^ constructor, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ arguments, System::Collections::Generic::IEnumerable&lt;System::Reflection::MemberInfo ^&gt; ^ members);" />
      <MemberSignature Language="F#" Value="static member New : System.Reflection.ConstructorInfo * seq&lt;System.Linq.Expressions.Expression&gt; * seq&lt;System.Reflection.MemberInfo&gt; -&gt; System.Linq.Expressions.NewExpression" Usage="System.Linq.Expressions.Expression.New (constructor, arguments, members)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.NewExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="constructor" Type="System.Reflection.ConstructorInfo" />
        <Parameter Name="arguments" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
        <Parameter Name="members" Type="System.Collections.Generic.IEnumerable&lt;System.Reflection.MemberInfo&gt;" />
      </Parameters>
      <Docs>
        <param name="constructor"><span data-ttu-id="7593b-2745">要将 <see cref="T:System.Reflection.ConstructorInfo" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.NewExpression.Constructor" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2745">The <see cref="T:System.Reflection.ConstructorInfo" /> to set the <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> property equal to.</span></span></param>
        <param name="arguments"><span data-ttu-id="7593b-2746">一个 <see cref="T:System.Collections.Generic.IEnumerable`1" />，包含用来填充 <see cref="T:System.Linq.Expressions.Expression" /> 集合的 <see cref="P:System.Linq.Expressions.NewExpression.Arguments" /> 对象。</span><span class="sxs-lookup"><span data-stu-id="7593b-2746">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.Expression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.NewExpression.Arguments" /> collection.</span></span></param>
        <param name="members"><span data-ttu-id="7593b-2747">一个 <see cref="T:System.Collections.Generic.IEnumerable`1" />，包含用来填充 <see cref="T:System.Reflection.MemberInfo" /> 集合的 <see cref="P:System.Linq.Expressions.NewExpression.Members" /> 对象。</span><span class="sxs-lookup"><span data-stu-id="7593b-2747">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Reflection.MemberInfo" /> objects to use to populate the <see cref="P:System.Linq.Expressions.NewExpression.Members" /> collection.</span></span></param>
        <summary><span data-ttu-id="7593b-2748">创建一个表示调用带指定参数的指定构造函数的 <see cref="T:System.Linq.Expressions.NewExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2748">Creates a <see cref="T:System.Linq.Expressions.NewExpression" /> that represents calling the specified constructor with the specified arguments.</span></span> <span data-ttu-id="7593b-2749">其中指定了访问构造函数初始化的字段的成员。</span><span class="sxs-lookup"><span data-stu-id="7593b-2749">The members that access the constructor initialized fields are specified.</span></span></summary>
        <returns><span data-ttu-id="7593b-2750">一个 <see cref="T:System.Linq.Expressions.NewExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 属性等于 <see cref="F:System.Linq.Expressions.ExpressionType.New" />，并且其 <see cref="P:System.Linq.Expressions.NewExpression.Constructor" />、<see cref="P:System.Linq.Expressions.NewExpression.Arguments" /> 和 <see cref="P:System.Linq.Expressions.NewExpression.Members" /> 属性设置为指定值。</span><span class="sxs-lookup"><span data-stu-id="7593b-2750">A <see cref="T:System.Linq.Expressions.NewExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.New" /> and the <see cref="P:System.Linq.Expressions.NewExpression.Constructor" />, <see cref="P:System.Linq.Expressions.NewExpression.Arguments" /> and <see cref="P:System.Linq.Expressions.NewExpression.Members" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7593b-2751">`arguments` 参数必须包含与 `constructor`所表示的构造函数的参数数目相同的元素数目。</span><span class="sxs-lookup"><span data-stu-id="7593b-2751">The `arguments` parameter must contain the same number of elements as the number of parameters for the constructor represented by `constructor`.</span></span> <span data-ttu-id="7593b-2752">如果 `null``arguments`，则将其视为空，并且生成的 <xref:System.Linq.Expressions.NewExpression> 的 <xref:System.Linq.Expressions.NewExpression.Arguments%2A> 属性为空集合。</span><span class="sxs-lookup"><span data-stu-id="7593b-2752">If `arguments` is `null`, it is considered empty, and the <xref:System.Linq.Expressions.NewExpression.Arguments%2A> property of the resulting <xref:System.Linq.Expressions.NewExpression> is an empty collection.</span></span>  
  
 <span data-ttu-id="7593b-2753">如果 `null``members`，则生成的 <xref:System.Linq.Expressions.NewExpression> 的 <xref:System.Linq.Expressions.NewExpression.Members%2A> 属性为空集合。</span><span class="sxs-lookup"><span data-stu-id="7593b-2753">If `members` is `null`, the <xref:System.Linq.Expressions.NewExpression.Members%2A> property of the resulting <xref:System.Linq.Expressions.NewExpression> is an empty collection.</span></span> <span data-ttu-id="7593b-2754">如果未 `null``members`，则它必须具有与 `arguments` 相同的元素数，并且每个元素不能 `null`。</span><span class="sxs-lookup"><span data-stu-id="7593b-2754">If `members` is not `null`, it must have the same number of elements as `arguments` and each element must not be `null`.</span></span> <span data-ttu-id="7593b-2755">`members` 的每个元素必须是一个 <xref:System.Reflection.PropertyInfo>、<xref:System.Reflection.FieldInfo> 或 <xref:System.Reflection.MethodInfo>，表示 `constructor`所表示的构造函数的声明类型上的实例成员。</span><span class="sxs-lookup"><span data-stu-id="7593b-2755">Each element of `members` must be a <xref:System.Reflection.PropertyInfo>, <xref:System.Reflection.FieldInfo> or <xref:System.Reflection.MethodInfo> that represents an instance member on the declaring type of the constructor represented by `constructor`.</span></span> <span data-ttu-id="7593b-2756">如果它表示一个属性，则该属性必须具有 `get` 访问器。</span><span class="sxs-lookup"><span data-stu-id="7593b-2756">If it represents a property, the property must have a `get` accessor.</span></span> <span data-ttu-id="7593b-2757">`members` 的每个元素的 `arguments` 的相应元素必须具有一个 <xref:System.Linq.Expressions.Expression.Type%2A> 属性，该属性表示可分配给 `members` 元素表示的成员类型的类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-2757">The corresponding element of `arguments` for each element of `members` must have a <xref:System.Linq.Expressions.Expression.Type%2A> property that represents a type that is assignable to the type of the member that the `members` element represents.</span></span>  
  
 <span data-ttu-id="7593b-2758">生成的 <xref:System.Linq.Expressions.NewExpression> 的 <xref:System.Linq.Expressions.Expression.Type%2A> 属性表示 `constructor` 表示的构造函数的声明类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-2758">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.NewExpression> represents the declaring type of the constructor that `constructor` represents.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="7593b-2759"><paramref name="constructor" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2759"><paramref name="constructor" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="7593b-2760">- 或 -</span><span class="sxs-lookup"><span data-stu-id="7593b-2760">-or-</span></span> 
<span data-ttu-id="7593b-2761"><paramref name="arguments" /> 的元素为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2761">An element of <paramref name="arguments" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="7593b-2762">- 或 -</span><span class="sxs-lookup"><span data-stu-id="7593b-2762">-or-</span></span> 
<span data-ttu-id="7593b-2763"><paramref name="members" /> 的元素为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2763">An element of <paramref name="members" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="7593b-2764"><paramref name="arguments" /> 参数包含的元素数量与 <paramref name="constructor" /> 所表示的构造函数的参数数量不同。</span><span class="sxs-lookup"><span data-stu-id="7593b-2764">The <paramref name="arguments" /> parameter does not contain the same number of elements as the number of parameters for the constructor that <paramref name="constructor" /> represents.</span></span>  
  
<span data-ttu-id="7593b-2765">- 或 -</span><span class="sxs-lookup"><span data-stu-id="7593b-2765">-or-</span></span> 
<span data-ttu-id="7593b-2766"><see cref="P:System.Linq.Expressions.Expression.Type" /> 的元素的 <paramref name="arguments" /> 属性不能赋给 <paramref name="constructor" /> 表示的构造函数的相应参数类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-2766">The <see cref="P:System.Linq.Expressions.Expression.Type" /> property of an element of <paramref name="arguments" /> is not assignable to the type of the corresponding parameter of the constructor that <paramref name="constructor" /> represents.</span></span>  
  
<span data-ttu-id="7593b-2767">- 或 -</span><span class="sxs-lookup"><span data-stu-id="7593b-2767">-or-</span></span> 
<span data-ttu-id="7593b-2768"><paramref name="members" /> 参数没有包含与 <paramref name="arguments" /> 相同数量的元素。</span><span class="sxs-lookup"><span data-stu-id="7593b-2768">The <paramref name="members" /> parameter does not have the same number of elements as <paramref name="arguments" />.</span></span>  
  
<span data-ttu-id="7593b-2769">- 或 -</span><span class="sxs-lookup"><span data-stu-id="7593b-2769">-or-</span></span> 
<span data-ttu-id="7593b-2770"><paramref name="arguments" /> 的元素具有 <see cref="P:System.Linq.Expressions.Expression.Type" /> 属性，该属性表示不能赋给 <paramref name="members" /> 的相应元素所表示的成员类型的类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-2770">An element of <paramref name="arguments" /> has a <see cref="P:System.Linq.Expressions.Expression.Type" /> property that represents a type that is not assignable to the type of the member that is represented by the corresponding element of <paramref name="members" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="New">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.NewExpression New (System.Reflection.ConstructorInfo constructor, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; arguments, params System.Reflection.MemberInfo[] members);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.NewExpression New(class System.Reflection.ConstructorInfo constructor, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; arguments, class System.Reflection.MemberInfo[] members) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.New(System.Reflection.ConstructorInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression},System.Reflection.MemberInfo[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function New (constructor As ConstructorInfo, arguments As IEnumerable(Of Expression), ParamArray members As MemberInfo()) As NewExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::NewExpression ^ New(System::Reflection::ConstructorInfo ^ constructor, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ arguments, ... cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ members);" />
      <MemberSignature Language="F#" Value="static member New : System.Reflection.ConstructorInfo * seq&lt;System.Linq.Expressions.Expression&gt; * System.Reflection.MemberInfo[] -&gt; System.Linq.Expressions.NewExpression" Usage="System.Linq.Expressions.Expression.New (constructor, arguments, members)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.NewExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="constructor" Type="System.Reflection.ConstructorInfo" />
        <Parameter Name="arguments" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
        <Parameter Name="members" Type="System.Reflection.MemberInfo[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="constructor"><span data-ttu-id="7593b-2771">要将 <see cref="T:System.Reflection.ConstructorInfo" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.NewExpression.Constructor" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2771">The <see cref="T:System.Reflection.ConstructorInfo" /> to set the <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> property equal to.</span></span></param>
        <param name="arguments"><span data-ttu-id="7593b-2772">一个 <see cref="T:System.Collections.Generic.IEnumerable`1" />，包含用来填充 <see cref="T:System.Linq.Expressions.Expression" /> 集合的 <see cref="P:System.Linq.Expressions.NewExpression.Arguments" /> 对象。</span><span class="sxs-lookup"><span data-stu-id="7593b-2772">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.Expression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.NewExpression.Arguments" /> collection.</span></span></param>
        <param name="members"><span data-ttu-id="7593b-2773">用于填充 <see cref="T:System.Reflection.MemberInfo" /> 集合的 <see cref="P:System.Linq.Expressions.NewExpression.Members" /> 对象的数组。</span><span class="sxs-lookup"><span data-stu-id="7593b-2773">An array of <see cref="T:System.Reflection.MemberInfo" /> objects to use to populate the <see cref="P:System.Linq.Expressions.NewExpression.Members" /> collection.</span></span></param>
        <summary><span data-ttu-id="7593b-2774">创建一个表示调用带指定参数的指定构造函数的 <see cref="T:System.Linq.Expressions.NewExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2774">Creates a <see cref="T:System.Linq.Expressions.NewExpression" /> that represents calling the specified constructor with the specified arguments.</span></span> <span data-ttu-id="7593b-2775">将访问构造函数初始化字段的成员指定为数组。</span><span class="sxs-lookup"><span data-stu-id="7593b-2775">The members that access the constructor initialized fields are specified as an array.</span></span></summary>
        <returns><span data-ttu-id="7593b-2776">一个 <see cref="T:System.Linq.Expressions.NewExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 属性等于 <see cref="F:System.Linq.Expressions.ExpressionType.New" />，并且其 <see cref="P:System.Linq.Expressions.NewExpression.Constructor" />、<see cref="P:System.Linq.Expressions.NewExpression.Arguments" /> 和 <see cref="P:System.Linq.Expressions.NewExpression.Members" /> 属性设置为指定值。</span><span class="sxs-lookup"><span data-stu-id="7593b-2776">A <see cref="T:System.Linq.Expressions.NewExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.New" /> and the <see cref="P:System.Linq.Expressions.NewExpression.Constructor" />, <see cref="P:System.Linq.Expressions.NewExpression.Arguments" /> and <see cref="P:System.Linq.Expressions.NewExpression.Members" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7593b-2777">`arguments` 参数必须包含与 `constructor`所表示的构造函数的参数数目相同的元素数目。</span><span class="sxs-lookup"><span data-stu-id="7593b-2777">The `arguments` parameter must contain the same number of elements as the number of parameters for the constructor represented by `constructor`.</span></span> <span data-ttu-id="7593b-2778">如果 `null``arguments`，则将其视为空，并且生成的 <xref:System.Linq.Expressions.NewExpression> 的 <xref:System.Linq.Expressions.NewExpression.Arguments%2A> 属性为空集合。</span><span class="sxs-lookup"><span data-stu-id="7593b-2778">If `arguments` is `null`, it is considered empty, and the <xref:System.Linq.Expressions.NewExpression.Arguments%2A> property of the resulting <xref:System.Linq.Expressions.NewExpression> is an empty collection.</span></span>  
  
 <span data-ttu-id="7593b-2779">如果 `null``members`，则生成的 <xref:System.Linq.Expressions.NewExpression> 的 <xref:System.Linq.Expressions.NewExpression.Members%2A> 属性为空集合。</span><span class="sxs-lookup"><span data-stu-id="7593b-2779">If `members` is `null`, the <xref:System.Linq.Expressions.NewExpression.Members%2A> property of the resulting <xref:System.Linq.Expressions.NewExpression> is an empty collection.</span></span> <span data-ttu-id="7593b-2780">如果未 `null``members`，则它必须具有与 `arguments` 相同的元素数，并且每个元素不能 `null`。</span><span class="sxs-lookup"><span data-stu-id="7593b-2780">If `members` is not `null`, it must have the same number of elements as `arguments` and each element must not be `null`.</span></span> <span data-ttu-id="7593b-2781">`members` 的每个元素必须是一个 <xref:System.Reflection.PropertyInfo>、<xref:System.Reflection.FieldInfo> 或 <xref:System.Reflection.MethodInfo>，表示 `constructor`所表示的构造函数的声明类型上的实例成员。</span><span class="sxs-lookup"><span data-stu-id="7593b-2781">Each element of `members` must be a <xref:System.Reflection.PropertyInfo>, <xref:System.Reflection.FieldInfo> or <xref:System.Reflection.MethodInfo> that represents an instance member on the declaring type of the constructor represented by `constructor`.</span></span> <span data-ttu-id="7593b-2782">如果它表示一个属性，则该属性必须能够检索关联字段的值。</span><span class="sxs-lookup"><span data-stu-id="7593b-2782">If it represents a property, the property must be able to retrieve the value of the associated field.</span></span> <span data-ttu-id="7593b-2783">`members` 的每个元素的 `arguments` 的相应元素必须具有一个 <xref:System.Linq.Expressions.Expression.Type%2A> 属性，该属性表示可分配给 `members` 元素表示的成员类型的类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-2783">The corresponding element of `arguments` for each element of `members` must have a <xref:System.Linq.Expressions.Expression.Type%2A> property that represents a type that is assignable to the type of the member that the `members` element represents.</span></span>  
  
 <span data-ttu-id="7593b-2784">生成的 <xref:System.Linq.Expressions.NewExpression> 的 <xref:System.Linq.Expressions.Expression.Type%2A> 属性表示 `constructor` 表示的构造函数的声明类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-2784">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.NewExpression> represents the declaring type of the constructor that `constructor` represents.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="7593b-2785"><paramref name="constructor" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2785"><paramref name="constructor" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="7593b-2786">- 或 -</span><span class="sxs-lookup"><span data-stu-id="7593b-2786">-or-</span></span> 
<span data-ttu-id="7593b-2787"><paramref name="arguments" /> 的元素为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2787">An element of <paramref name="arguments" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="7593b-2788">- 或 -</span><span class="sxs-lookup"><span data-stu-id="7593b-2788">-or-</span></span> 
<span data-ttu-id="7593b-2789"><paramref name="members" /> 的元素为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2789">An element of <paramref name="members" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="7593b-2790"><paramref name="arguments" /> 参数包含的元素数量与 <paramref name="constructor" /> 所表示的构造函数的参数数量不同。</span><span class="sxs-lookup"><span data-stu-id="7593b-2790">The <paramref name="arguments" /> parameter does not contain the same number of elements as the number of parameters for the constructor that <paramref name="constructor" /> represents.</span></span>  
  
<span data-ttu-id="7593b-2791">- 或 -</span><span class="sxs-lookup"><span data-stu-id="7593b-2791">-or-</span></span> 
<span data-ttu-id="7593b-2792"><see cref="P:System.Linq.Expressions.Expression.Type" /> 的元素的 <paramref name="arguments" /> 属性不能赋给 <paramref name="constructor" /> 表示的构造函数的相应参数类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-2792">The <see cref="P:System.Linq.Expressions.Expression.Type" /> property of an element of <paramref name="arguments" /> is not assignable to the type of the corresponding parameter of the constructor that <paramref name="constructor" /> represents.</span></span>  
  
<span data-ttu-id="7593b-2793">- 或 -</span><span class="sxs-lookup"><span data-stu-id="7593b-2793">-or-</span></span> 
<span data-ttu-id="7593b-2794"><paramref name="members" /> 参数没有包含与 <paramref name="arguments" /> 相同数量的元素。</span><span class="sxs-lookup"><span data-stu-id="7593b-2794">The <paramref name="members" /> parameter does not have the same number of elements as <paramref name="arguments" />.</span></span>  
  
<span data-ttu-id="7593b-2795">- 或 -</span><span class="sxs-lookup"><span data-stu-id="7593b-2795">-or-</span></span> 
<span data-ttu-id="7593b-2796"><paramref name="arguments" /> 的元素具有 <see cref="P:System.Linq.Expressions.Expression.Type" /> 属性，该属性表示不能赋给 <paramref name="members" /> 的相应元素所表示的成员类型的类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-2796">An element of <paramref name="arguments" /> has a <see cref="P:System.Linq.Expressions.Expression.Type" /> property that represents a type that is not assignable to the type of the member that is represented by the corresponding element of <paramref name="members" />.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="NewArrayBounds">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="7593b-2797">创建一个表示创建具有指定秩的数组的 <see cref="T:System.Linq.Expressions.NewArrayExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2797">Creates a <see cref="T:System.Linq.Expressions.NewArrayExpression" /> that represents creating an array that has a specified rank.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="NewArrayBounds">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.NewArrayExpression NewArrayBounds (Type type, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; bounds);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.NewArrayExpression NewArrayBounds(class System.Type type, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; bounds) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.NewArrayBounds(System.Type,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::NewArrayExpression ^ NewArrayBounds(Type ^ type, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ bounds);" />
      <MemberSignature Language="F#" Value="static member NewArrayBounds : Type * seq&lt;System.Linq.Expressions.Expression&gt; -&gt; System.Linq.Expressions.NewArrayExpression" Usage="System.Linq.Expressions.Expression.NewArrayBounds (type, bounds)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.NewArrayExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="bounds" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="type"><span data-ttu-id="7593b-2798">一个表示数组的元素类型的 <see cref="T:System.Type" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2798">A <see cref="T:System.Type" /> that represents the element type of the array.</span></span></param>
        <param name="bounds"><span data-ttu-id="7593b-2799">一个 <see cref="T:System.Collections.Generic.IEnumerable`1" />，包含用来填充 <see cref="T:System.Linq.Expressions.Expression" /> 集合的 <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" /> 对象。</span><span class="sxs-lookup"><span data-stu-id="7593b-2799">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.Expression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" /> collection.</span></span></param>
        <summary><span data-ttu-id="7593b-2800">创建一个表示创建具有指定秩的数组的 <see cref="T:System.Linq.Expressions.NewArrayExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2800">Creates a <see cref="T:System.Linq.Expressions.NewArrayExpression" /> that represents creating an array that has a specified rank.</span></span></summary>
        <returns><span data-ttu-id="7593b-2801">一个 <see cref="T:System.Linq.Expressions.NewArrayExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 属性等于 <see cref="F:System.Linq.Expressions.ExpressionType.NewArrayBounds" />，并且其 <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" /> 属性设置为指定值。</span><span class="sxs-lookup"><span data-stu-id="7593b-2801">A <see cref="T:System.Linq.Expressions.NewArrayExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.NewArrayBounds" /> and the <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" /> property set to the specified value.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7593b-2802">生成的 <xref:System.Linq.Expressions.NewArrayExpression> 的 <xref:System.Linq.Expressions.Expression.Type%2A> 属性表示一个数组类型，其秩等于 `bounds` 的长度，其元素类型为 `type`。</span><span class="sxs-lookup"><span data-stu-id="7593b-2802">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.NewArrayExpression> represents an array type whose rank is equal to the length of `bounds` and whose element type is `type`.</span></span>  
  
 <span data-ttu-id="7593b-2803">`bounds` 的每个元素的 <xref:System.Linq.Expressions.Expression.Type%2A> 属性必须表示整数类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-2803">The <xref:System.Linq.Expressions.Expression.Type%2A> property of each element of `bounds` must represent an integral type.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="7593b-2804">下面的示例演示如何使用 <xref:System.Linq.Expressions.Expression.NewArrayBounds%2A> 方法创建表达式树，该表达式树表示创建排名为2的字符串数组。</span><span class="sxs-lookup"><span data-stu-id="7593b-2804">The following example demonstrates how to use the <xref:System.Linq.Expressions.Expression.NewArrayBounds%2A> method to create an expression tree that represents creating a string array that has a rank of 2.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.Expression#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#2)]
 [!code-vb[System.Linq.Expressions.Expression#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="7593b-2805"><paramref name="type" /> 或 <paramref name="bounds" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2805"><paramref name="type" /> or <paramref name="bounds" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="7593b-2806">- 或 -</span><span class="sxs-lookup"><span data-stu-id="7593b-2806">-or-</span></span> 
<span data-ttu-id="7593b-2807"><paramref name="bounds" /> 的元素为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2807">An element of <paramref name="bounds" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="7593b-2808"><see cref="P:System.Linq.Expressions.Expression.Type" /> 的元素的 <paramref name="bounds" /> 属性不表示整型。</span><span class="sxs-lookup"><span data-stu-id="7593b-2808">The <see cref="P:System.Linq.Expressions.Expression.Type" /> property of an element of <paramref name="bounds" /> does not represent an integral type.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="NewArrayBounds">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.NewArrayExpression NewArrayBounds (Type type, params System.Linq.Expressions.Expression[] bounds);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.NewArrayExpression NewArrayBounds(class System.Type type, class System.Linq.Expressions.Expression[] bounds) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.NewArrayBounds(System.Type,System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::NewArrayExpression ^ NewArrayBounds(Type ^ type, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ bounds);" />
      <MemberSignature Language="F#" Value="static member NewArrayBounds : Type * System.Linq.Expressions.Expression[] -&gt; System.Linq.Expressions.NewArrayExpression" Usage="System.Linq.Expressions.Expression.NewArrayBounds (type, bounds)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.NewArrayExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="bounds" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="type"><span data-ttu-id="7593b-2809">一个表示数组的元素类型的 <see cref="T:System.Type" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2809">A <see cref="T:System.Type" /> that represents the element type of the array.</span></span></param>
        <param name="bounds"><span data-ttu-id="7593b-2810">用于填充 <see cref="T:System.Linq.Expressions.Expression" /> 集合的 <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" /> 对象的数组。</span><span class="sxs-lookup"><span data-stu-id="7593b-2810">An array of <see cref="T:System.Linq.Expressions.Expression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" /> collection.</span></span></param>
        <summary><span data-ttu-id="7593b-2811">创建一个表示创建具有指定秩的数组的 <see cref="T:System.Linq.Expressions.NewArrayExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2811">Creates a <see cref="T:System.Linq.Expressions.NewArrayExpression" /> that represents creating an array that has a specified rank.</span></span></summary>
        <returns><span data-ttu-id="7593b-2812">一个 <see cref="T:System.Linq.Expressions.NewArrayExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 属性等于 <see cref="F:System.Linq.Expressions.ExpressionType.NewArrayBounds" />，并且其 <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" /> 属性设置为指定值。</span><span class="sxs-lookup"><span data-stu-id="7593b-2812">A <see cref="T:System.Linq.Expressions.NewArrayExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.NewArrayBounds" /> and the <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" /> property set to the specified value.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7593b-2813">生成的 <xref:System.Linq.Expressions.NewArrayExpression> 的 <xref:System.Linq.Expressions.Expression.Type%2A> 属性表示一个数组类型，其秩等于 `bounds` 的长度，其元素类型为 `type`。</span><span class="sxs-lookup"><span data-stu-id="7593b-2813">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.NewArrayExpression> represents an array type whose rank is equal to the length of `bounds` and whose element type is `type`.</span></span>  
  
 <span data-ttu-id="7593b-2814">`bounds` 的每个元素的 <xref:System.Linq.Expressions.Expression.Type%2A> 属性必须表示整数类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-2814">The <xref:System.Linq.Expressions.Expression.Type%2A> property of each element of `bounds` must represent an integral type.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="7593b-2815">下面的示例演示如何使用 <xref:System.Linq.Expressions.Expression.NewArrayBounds%2A> 方法创建表达式树，该表达式树表示创建排名为2的字符串数组。</span><span class="sxs-lookup"><span data-stu-id="7593b-2815">The following example demonstrates how to use the <xref:System.Linq.Expressions.Expression.NewArrayBounds%2A> method to create an expression tree that represents creating a string array that has a rank of 2.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.Expression#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#2)]
 [!code-vb[System.Linq.Expressions.Expression#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="7593b-2816"><paramref name="type" /> 或 <paramref name="bounds" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2816"><paramref name="type" /> or <paramref name="bounds" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="7593b-2817">- 或 -</span><span class="sxs-lookup"><span data-stu-id="7593b-2817">-or-</span></span> 
<span data-ttu-id="7593b-2818"><paramref name="bounds" /> 的元素为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2818">An element of <paramref name="bounds" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="7593b-2819"><see cref="P:System.Linq.Expressions.Expression.Type" /> 的元素的 <paramref name="bounds" /> 属性不表示整型。</span><span class="sxs-lookup"><span data-stu-id="7593b-2819">The <see cref="P:System.Linq.Expressions.Expression.Type" /> property of an element of <paramref name="bounds" /> does not represent an integral type.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="NewArrayInit">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="7593b-2820">创建一个表示创建一维数组并使用元素列表初始化该数组的 <see cref="T:System.Linq.Expressions.NewArrayExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2820">Creates a <see cref="T:System.Linq.Expressions.NewArrayExpression" /> that represents creating a one-dimensional array and initializing it from a list of elements.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="NewArrayInit">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.NewArrayExpression NewArrayInit (Type type, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; initializers);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.NewArrayExpression NewArrayInit(class System.Type type, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; initializers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.NewArrayInit(System.Type,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::NewArrayExpression ^ NewArrayInit(Type ^ type, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ initializers);" />
      <MemberSignature Language="F#" Value="static member NewArrayInit : Type * seq&lt;System.Linq.Expressions.Expression&gt; -&gt; System.Linq.Expressions.NewArrayExpression" Usage="System.Linq.Expressions.Expression.NewArrayInit (type, initializers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.NewArrayExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="initializers" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="type"><span data-ttu-id="7593b-2821">一个表示数组的元素类型的 <see cref="T:System.Type" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2821">A <see cref="T:System.Type" /> that represents the element type of the array.</span></span></param>
        <param name="initializers"><span data-ttu-id="7593b-2822">一个 <see cref="T:System.Collections.Generic.IEnumerable`1" />，包含用来填充 <see cref="T:System.Linq.Expressions.Expression" /> 集合的 <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" /> 对象。</span><span class="sxs-lookup"><span data-stu-id="7593b-2822">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.Expression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" /> collection.</span></span></param>
        <summary><span data-ttu-id="7593b-2823">创建一个表示创建一维数组并使用元素列表初始化该数组的 <see cref="T:System.Linq.Expressions.NewArrayExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2823">Creates a <see cref="T:System.Linq.Expressions.NewArrayExpression" /> that represents creating a one-dimensional array and initializing it from a list of elements.</span></span></summary>
        <returns><span data-ttu-id="7593b-2824">一个 <see cref="T:System.Linq.Expressions.NewArrayExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 属性等于 <see cref="F:System.Linq.Expressions.ExpressionType.NewArrayInit" />，并且其 <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" /> 属性设置为指定值。</span><span class="sxs-lookup"><span data-stu-id="7593b-2824">A <see cref="T:System.Linq.Expressions.NewArrayExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.NewArrayInit" /> and the <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" /> property set to the specified value.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7593b-2825">`initializers` 的每个元素的 <xref:System.Linq.Expressions.Expression.Type%2A> 属性必须表示一个类型，该类型可分配给由 `type`表示的类型（可能在被*引用*后）。</span><span class="sxs-lookup"><span data-stu-id="7593b-2825">The <xref:System.Linq.Expressions.Expression.Type%2A> property of each element of `initializers` must represent a type that is assignable to the type represented by `type`, possibly after it is *quoted*.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="7593b-2826">仅当 <xref:System.Linq.Expressions.Expression>`type` 时，才将元素括起来。</span><span class="sxs-lookup"><span data-stu-id="7593b-2826">An element will be quoted only if `type` is <xref:System.Linq.Expressions.Expression>.</span></span> <span data-ttu-id="7593b-2827">引号表示元素包装在 <xref:System.Linq.Expressions.ExpressionType.Quote> 节点中。</span><span class="sxs-lookup"><span data-stu-id="7593b-2827">Quoting means the element is wrapped in a <xref:System.Linq.Expressions.ExpressionType.Quote> node.</span></span> <span data-ttu-id="7593b-2828">生成的节点是一个 <xref:System.Linq.Expressions.UnaryExpression>，其 <xref:System.Linq.Expressions.UnaryExpression.Operand%2A> 属性是 `initializers`的元素。</span><span class="sxs-lookup"><span data-stu-id="7593b-2828">The resulting node is a <xref:System.Linq.Expressions.UnaryExpression> whose <xref:System.Linq.Expressions.UnaryExpression.Operand%2A> property is the element of `initializers`.</span></span>  
  
 <span data-ttu-id="7593b-2829">生成的 <xref:System.Linq.Expressions.NewArrayExpression> 的 <xref:System.Linq.Expressions.Expression.Type%2A> 属性表示其秩为1且元素类型为 `type`的数组类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-2829">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.NewArrayExpression> represents an array type whose rank is 1 and whose element type is `type`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="7593b-2830">下面的示例演示如何使用 <xref:System.Linq.Expressions.Expression.NewArrayInit%2A> 方法创建表示创建一维字符串数组的表达式树，该数组是使用字符串表达式列表进行初始化的。</span><span class="sxs-lookup"><span data-stu-id="7593b-2830">The following example demonstrates how to use the <xref:System.Linq.Expressions.Expression.NewArrayInit%2A> method to create an expression tree that represents creating a one-dimensional string array that is initialized with a list of string expressions.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.Expression#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#1)]
 [!code-vb[System.Linq.Expressions.Expression#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="7593b-2831"><paramref name="type" /> 或 <paramref name="initializers" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2831"><paramref name="type" /> or <paramref name="initializers" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="7593b-2832">- 或 -</span><span class="sxs-lookup"><span data-stu-id="7593b-2832">-or-</span></span> 
<span data-ttu-id="7593b-2833"><paramref name="initializers" /> 的元素为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2833">An element of <paramref name="initializers" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="7593b-2834"><see cref="P:System.Linq.Expressions.Expression.Type" /> 的元素的 <paramref name="initializers" /> 属性表示不能赋给 <paramref name="type" /> 所表示的类型的类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-2834">The <see cref="P:System.Linq.Expressions.Expression.Type" /> property of an element of <paramref name="initializers" /> represents a type that is not assignable to the type that <paramref name="type" /> represents.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="NewArrayInit">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.NewArrayExpression NewArrayInit (Type type, params System.Linq.Expressions.Expression[] initializers);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.NewArrayExpression NewArrayInit(class System.Type type, class System.Linq.Expressions.Expression[] initializers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.NewArrayInit(System.Type,System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::NewArrayExpression ^ NewArrayInit(Type ^ type, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ initializers);" />
      <MemberSignature Language="F#" Value="static member NewArrayInit : Type * System.Linq.Expressions.Expression[] -&gt; System.Linq.Expressions.NewArrayExpression" Usage="System.Linq.Expressions.Expression.NewArrayInit (type, initializers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.NewArrayExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="initializers" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="type"><span data-ttu-id="7593b-2835">一个表示数组的元素类型的 <see cref="T:System.Type" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2835">A <see cref="T:System.Type" /> that represents the element type of the array.</span></span></param>
        <param name="initializers"><span data-ttu-id="7593b-2836">用于填充 <see cref="T:System.Linq.Expressions.Expression" /> 集合的 <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" /> 对象的数组。</span><span class="sxs-lookup"><span data-stu-id="7593b-2836">An array of <see cref="T:System.Linq.Expressions.Expression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" /> collection.</span></span></param>
        <summary><span data-ttu-id="7593b-2837">创建一个表示创建一维数组并使用元素列表初始化该数组的 <see cref="T:System.Linq.Expressions.NewArrayExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2837">Creates a <see cref="T:System.Linq.Expressions.NewArrayExpression" /> that represents creating a one-dimensional array and initializing it from a list of elements.</span></span></summary>
        <returns><span data-ttu-id="7593b-2838">一个 <see cref="T:System.Linq.Expressions.NewArrayExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 属性等于 <see cref="F:System.Linq.Expressions.ExpressionType.NewArrayInit" />，并且其 <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" /> 属性设置为指定值。</span><span class="sxs-lookup"><span data-stu-id="7593b-2838">A <see cref="T:System.Linq.Expressions.NewArrayExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.NewArrayInit" /> and the <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" /> property set to the specified value.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7593b-2839">`initializers` 的每个元素的 <xref:System.Linq.Expressions.Expression.Type%2A> 属性必须表示一个类型，该类型可分配给由 `type`表示的类型（可能在被*引用*后）。</span><span class="sxs-lookup"><span data-stu-id="7593b-2839">The <xref:System.Linq.Expressions.Expression.Type%2A> property of each element of `initializers` must represent a type that is assignable to the type represented by `type`, possibly after it is *quoted*.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="7593b-2840">仅当 <xref:System.Linq.Expressions.Expression>`type` 时，才将元素括起来。</span><span class="sxs-lookup"><span data-stu-id="7593b-2840">An element will be quoted only if `type` is <xref:System.Linq.Expressions.Expression>.</span></span> <span data-ttu-id="7593b-2841">引号表示元素包装在 <xref:System.Linq.Expressions.ExpressionType.Quote> 节点中。</span><span class="sxs-lookup"><span data-stu-id="7593b-2841">Quoting means the element is wrapped in a <xref:System.Linq.Expressions.ExpressionType.Quote> node.</span></span> <span data-ttu-id="7593b-2842">生成的节点是一个 <xref:System.Linq.Expressions.UnaryExpression>，其 <xref:System.Linq.Expressions.UnaryExpression.Operand%2A> 属性是 `initializers`的元素。</span><span class="sxs-lookup"><span data-stu-id="7593b-2842">The resulting node is a <xref:System.Linq.Expressions.UnaryExpression> whose <xref:System.Linq.Expressions.UnaryExpression.Operand%2A> property is the element of `initializers`.</span></span>  
  
 <span data-ttu-id="7593b-2843">生成的 <xref:System.Linq.Expressions.NewArrayExpression> 的 <xref:System.Linq.Expressions.Expression.Type%2A> 属性表示其秩为1且元素类型为 `type`的数组类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-2843">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.NewArrayExpression> represents an array type whose rank is 1 and whose element type is `type`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="7593b-2844">下面的示例演示如何使用 <xref:System.Linq.Expressions.Expression.NewArrayInit%2A> 方法创建表示创建一维字符串数组的表达式树，该数组是使用字符串表达式列表进行初始化的。</span><span class="sxs-lookup"><span data-stu-id="7593b-2844">The following example demonstrates how to use the <xref:System.Linq.Expressions.Expression.NewArrayInit%2A> method to create an expression tree that represents creating a one-dimensional string array that is initialized with a list of string expressions.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.Expression#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#1)]
 [!code-vb[System.Linq.Expressions.Expression#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="7593b-2845"><paramref name="type" /> 或 <paramref name="initializers" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2845"><paramref name="type" /> or <paramref name="initializers" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="7593b-2846">- 或 -</span><span class="sxs-lookup"><span data-stu-id="7593b-2846">-or-</span></span> 
<span data-ttu-id="7593b-2847"><paramref name="initializers" /> 的元素为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2847">An element of <paramref name="initializers" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="7593b-2848"><see cref="P:System.Linq.Expressions.Expression.Type" /> 的元素的 <paramref name="initializers" /> 属性表示不能赋给类型 <paramref name="type" /> 的类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-2848">The <see cref="P:System.Linq.Expressions.Expression.Type" /> property of an element of <paramref name="initializers" /> represents a type that is not assignable to the type <paramref name="type" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="NodeType">
      <MemberSignature Language="C#" Value="public virtual System.Linq.Expressions.ExpressionType NodeType { get; }" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Linq.Expressions.ExpressionType NodeType" />
      <MemberSignature Language="DocId" Value="P:System.Linq.Expressions.Expression.NodeType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property NodeType As ExpressionType" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Linq::Expressions::ExpressionType NodeType { System::Linq::Expressions::ExpressionType get(); };" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.NodeType : System.Linq.Expressions.ExpressionType" Usage="System.Linq.Expressions.Expression.NodeType" />
      <MemberSignature Language="C#" Value="public System.Linq.Expressions.ExpressionType NodeType { get; }" FrameworkAlternate="netframework-3.5" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property NodeType As ExpressionType" FrameworkAlternate="netframework-3.5" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Linq::Expressions::ExpressionType NodeType { System::Linq::Expressions::ExpressionType get(); };" FrameworkAlternate="netframework-3.5" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ExpressionType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="7593b-2849">获取此 <see cref="T:System.Linq.Expressions.Expression" /> 的节点类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-2849">Gets the node type of this <see cref="T:System.Linq.Expressions.Expression" />.</span></span></summary>
        <value><span data-ttu-id="7593b-2850"><see cref="T:System.Linq.Expressions.ExpressionType" /> 值之一。</span><span class="sxs-lookup"><span data-stu-id="7593b-2850">One of the <see cref="T:System.Linq.Expressions.ExpressionType" /> values.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7593b-2851"><xref:System.Linq.Expressions.Expression.NodeType%2A> 属性提供了更专用于其派生类型的 <xref:System.Linq.Expressions.Expression> 的说明。</span><span class="sxs-lookup"><span data-stu-id="7593b-2851">The <xref:System.Linq.Expressions.Expression.NodeType%2A> property provides a more specialized description of an <xref:System.Linq.Expressions.Expression> than just its derived type.</span></span> <span data-ttu-id="7593b-2852">例如，可以使用 <xref:System.Linq.Expressions.BinaryExpression> 来表示多种不同类型的二进制表达式，如除法运算或 "大于" 运算。</span><span class="sxs-lookup"><span data-stu-id="7593b-2852">For example, a <xref:System.Linq.Expressions.BinaryExpression> can be used to represent many different kinds of binary expressions, such as a division operation or a "greater than" operation.</span></span> <span data-ttu-id="7593b-2853"><xref:System.Linq.Expressions.Expression.NodeType%2A> 属性会将这些二进制表达式分别描述为 <xref:System.Linq.Expressions.ExpressionType.Divide> 和 <xref:System.Linq.Expressions.ExpressionType.GreaterThan>。</span><span class="sxs-lookup"><span data-stu-id="7593b-2853">The <xref:System.Linq.Expressions.Expression.NodeType%2A> property would describe these binary expressions as <xref:System.Linq.Expressions.ExpressionType.Divide> and <xref:System.Linq.Expressions.ExpressionType.GreaterThan>, respectively.</span></span>  
  
 <span data-ttu-id="7593b-2854"><xref:System.Linq.Expressions.Expression> 对象表示的表达式的静态 CLR 类型由 <xref:System.Linq.Expressions.Expression.Type%2A> 属性表示。</span><span class="sxs-lookup"><span data-stu-id="7593b-2854">The static CLR type of the expression that the <xref:System.Linq.Expressions.Expression> object represents is represented by the <xref:System.Linq.Expressions.Expression.Type%2A> property.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Not">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="7593b-2855">创建一个表示按位求补运算的 <see cref="T:System.Linq.Expressions.UnaryExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2855">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents a bitwise complement operation.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Not">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression Not (System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression Not(class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Not(System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ Not(System::Linq::Expressions::Expression ^ expression);" />
      <MemberSignature Language="F#" Value="static member Not : System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.Not expression" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="expression"><span data-ttu-id="7593b-2856">要将 <see cref="T:System.Linq.Expressions.Expression" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2856">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="7593b-2857">创建一个表示按位求补运算的 <see cref="T:System.Linq.Expressions.UnaryExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2857">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents a bitwise complement operation.</span></span></summary>
        <returns><span data-ttu-id="7593b-2858">一个 <see cref="T:System.Linq.Expressions.UnaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 属性等于 <see cref="F:System.Linq.Expressions.ExpressionType.Not" />，并且其 <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> 属性设置为指定值。</span><span class="sxs-lookup"><span data-stu-id="7593b-2858">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Not" /> and the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> property set to the specified value.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7593b-2859">生成的 <xref:System.Linq.Expressions.UnaryExpression> 的 <xref:System.Linq.Expressions.UnaryExpression.Method%2A> 属性被设置为实现方法。</span><span class="sxs-lookup"><span data-stu-id="7593b-2859">The <xref:System.Linq.Expressions.UnaryExpression.Method%2A> property of the resulting <xref:System.Linq.Expressions.UnaryExpression> is set to the implementing method.</span></span> <span data-ttu-id="7593b-2860"><xref:System.Linq.Expressions.Expression.Type%2A> 属性设置为节点的类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-2860">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="7593b-2861">如果节点已提升，则 <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> 和 <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> 属性均 `true`。</span><span class="sxs-lookup"><span data-stu-id="7593b-2861">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="7593b-2862">否则，它们 `false`。</span><span class="sxs-lookup"><span data-stu-id="7593b-2862">Otherwise, they are `false`.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="7593b-2863">实现方法</span><span class="sxs-lookup"><span data-stu-id="7593b-2863">Implementing Method</span></span>  
 <span data-ttu-id="7593b-2864">以下规则确定操作的实现方法：</span><span class="sxs-lookup"><span data-stu-id="7593b-2864">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="7593b-2865">如果 `expression`。类型是一种定义一元 not 运算符的用户定义类型，表示该运算符的 <xref:System.Reflection.MethodInfo> 是实现方法。</span><span class="sxs-lookup"><span data-stu-id="7593b-2865">If `expression`.Type is a user-defined type that defines the unary not operator, the <xref:System.Reflection.MethodInfo> that represents that operator is the implementing method.</span></span>  
  
-   <span data-ttu-id="7593b-2866">否则，如果 `expression`。Type 为数值或布尔类型，则实现方法为 `null`。</span><span class="sxs-lookup"><span data-stu-id="7593b-2866">Otherwise, if `expression`.Type is a numeric or Boolean type, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="7593b-2867">节点类型和提升和非提升</span><span class="sxs-lookup"><span data-stu-id="7593b-2867">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="7593b-2868">如果不 `null`实现方法：</span><span class="sxs-lookup"><span data-stu-id="7593b-2868">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="7593b-2869">如果 `expression`。类型可赋给实现方法的参数类型，不会提升节点。</span><span class="sxs-lookup"><span data-stu-id="7593b-2869">If `expression`.Type is assignable to the argument type of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="7593b-2870">节点的类型是实现方法的返回类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-2870">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="7593b-2871">如果满足以下两个条件，则会提升节点，并且该节点的类型为与实现方法的返回类型对应的可以为 null 的类型：</span><span class="sxs-lookup"><span data-stu-id="7593b-2871">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="7593b-2872">`expression`。类型是可以为 null 的值类型，并且相应的不可为 null 的类型等于实现方法的参数类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-2872">`expression`.Type is a nullable value type and the corresponding non-nullable type is equal to the argument type of the implementing method.</span></span>  
  
    -   <span data-ttu-id="7593b-2873">实现方法的返回类型是不可为 null 的值类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-2873">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="7593b-2874">如果实现方法为 `null`，则 `expression`节点的类型。类别.</span><span class="sxs-lookup"><span data-stu-id="7593b-2874">If the implementing method is `null`, the type of the node is `expression`.Type.</span></span> <span data-ttu-id="7593b-2875">如果 `expression`。类型不可为 null，则不提升节点。</span><span class="sxs-lookup"><span data-stu-id="7593b-2875">If `expression`.Type is non-nullable, the node is not lifted.</span></span> <span data-ttu-id="7593b-2876">否则，节点会提升。</span><span class="sxs-lookup"><span data-stu-id="7593b-2876">Otherwise, the node is lifted.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="7593b-2877">下面的示例演示如何创建表示逻辑 "非" 运算的表达式。</span><span class="sxs-lookup"><span data-stu-id="7593b-2877">The following example demonstrates how to create an expression that represents a logical NOT operation.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#51](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#51)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#51](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#51)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="7593b-2878"><paramref name="expression" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2878"><paramref name="expression" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="7593b-2879">没有为 <paramref name="expression" />.Type 定义一元 not 运算符。</span><span class="sxs-lookup"><span data-stu-id="7593b-2879">The unary not operator is not defined for <paramref name="expression" />.Type.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Not">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression Not (System.Linq.Expressions.Expression expression, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression Not(class System.Linq.Expressions.Expression expression, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Not(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ Not(System::Linq::Expressions::Expression ^ expression, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member Not : System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.Not (expression, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="expression"><span data-ttu-id="7593b-2880">要将 <see cref="T:System.Linq.Expressions.Expression" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2880">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> property equal to.</span></span></param>
        <param name="method"><span data-ttu-id="7593b-2881">要将 <see cref="T:System.Reflection.MethodInfo" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.UnaryExpression.Method" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2881">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="7593b-2882">创建一个表示按位求补运算的 <see cref="T:System.Linq.Expressions.UnaryExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2882">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents a bitwise complement operation.</span></span> <span data-ttu-id="7593b-2883">可指定实现方法。</span><span class="sxs-lookup"><span data-stu-id="7593b-2883">The implementing method can be specified.</span></span></summary>
        <returns><span data-ttu-id="7593b-2884">一个 <see cref="T:System.Linq.Expressions.UnaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 属性等于 <see cref="F:System.Linq.Expressions.ExpressionType.Not" />，并且其 <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> 和 <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> 属性设置为指定值。</span><span class="sxs-lookup"><span data-stu-id="7593b-2884">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Not" /> and the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> and <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7593b-2885">生成的 <xref:System.Linq.Expressions.UnaryExpression> 的 <xref:System.Linq.Expressions.UnaryExpression.Method%2A> 属性被设置为实现方法。</span><span class="sxs-lookup"><span data-stu-id="7593b-2885">The <xref:System.Linq.Expressions.UnaryExpression.Method%2A> property of the resulting <xref:System.Linq.Expressions.UnaryExpression> is set to the implementing method.</span></span> <span data-ttu-id="7593b-2886"><xref:System.Linq.Expressions.Expression.Type%2A> 属性设置为节点的类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-2886">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="7593b-2887">如果节点已提升，则 <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> 和 <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> 属性均 `true`。</span><span class="sxs-lookup"><span data-stu-id="7593b-2887">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="7593b-2888">否则，它们 `false`。</span><span class="sxs-lookup"><span data-stu-id="7593b-2888">Otherwise, they are `false`.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="7593b-2889">实现方法</span><span class="sxs-lookup"><span data-stu-id="7593b-2889">Implementing Method</span></span>  
 <span data-ttu-id="7593b-2890">以下规则确定操作的实现方法：</span><span class="sxs-lookup"><span data-stu-id="7593b-2890">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="7593b-2891">如果 `method` 未 `null` 并且它表示采用一个自变量的非 void、`static` （Visual Basic`Shared`）方法，则该方法为节点的实现方法。</span><span class="sxs-lookup"><span data-stu-id="7593b-2891">If `method` is not `null` and it represents a non-void, `static` (`Shared` in Visual Basic) method that takes one argument, it is the implementing method for the node.</span></span>  
  
-   <span data-ttu-id="7593b-2892">如果 `expression`。类型是一种定义一元 not 运算符的用户定义类型，表示该运算符的 <xref:System.Reflection.MethodInfo> 是实现方法。</span><span class="sxs-lookup"><span data-stu-id="7593b-2892">If `expression`.Type is a user-defined type that defines the unary not operator, the <xref:System.Reflection.MethodInfo> that represents that operator is the implementing method.</span></span>  
  
-   <span data-ttu-id="7593b-2893">否则，如果 `expression`。Type 为数值类型，则实现方法为 `null`。</span><span class="sxs-lookup"><span data-stu-id="7593b-2893">Otherwise, if `expression`.Type is a numeric type, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="7593b-2894">节点类型和提升和非提升</span><span class="sxs-lookup"><span data-stu-id="7593b-2894">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="7593b-2895">如果不 `null`实现方法：</span><span class="sxs-lookup"><span data-stu-id="7593b-2895">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="7593b-2896">如果 `expression`。类型可赋给实现方法的参数类型，不会提升节点。</span><span class="sxs-lookup"><span data-stu-id="7593b-2896">If `expression`.Type is assignable to the argument type of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="7593b-2897">节点的类型是实现方法的返回类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-2897">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="7593b-2898">如果满足以下两个条件，则会提升节点，并且该节点的类型为与实现方法的返回类型对应的可以为 null 的类型：</span><span class="sxs-lookup"><span data-stu-id="7593b-2898">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="7593b-2899">`expression`。类型是可以为 null 的值类型，并且相应的不可为 null 的值类型等于实现方法的参数类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-2899">`expression`.Type is a nullable value type and the corresponding non-nullable value type is equal to the argument type of the implementing method.</span></span>  
  
    -   <span data-ttu-id="7593b-2900">实现方法的返回类型是不可为 null 的值类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-2900">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="7593b-2901">如果实现方法为 `null`，则 `expression`节点的类型。类别.</span><span class="sxs-lookup"><span data-stu-id="7593b-2901">If the implementing method is `null`, the type of the node is `expression`.Type.</span></span> <span data-ttu-id="7593b-2902">如果 `expression`。类型不可为 null，则不提升节点。</span><span class="sxs-lookup"><span data-stu-id="7593b-2902">If `expression`.Type is non-nullable, the node is not lifted.</span></span> <span data-ttu-id="7593b-2903">否则，节点会提升。</span><span class="sxs-lookup"><span data-stu-id="7593b-2903">Otherwise, the node is lifted.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="7593b-2904"><paramref name="expression" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2904"><paramref name="expression" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="7593b-2905"><paramref name="method" /> 不为 <see langword="null" /> 且其表示的方法返回 <see langword="void" />；不为 <see langword="static" />（在 Visual Basic 中不为 <see langword="Shared" />）；或者不是正好带一个参数。</span><span class="sxs-lookup"><span data-stu-id="7593b-2905"><paramref name="method" /> is not <see langword="null" /> and the method it represents returns <see langword="void" />, is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic), or does not take exactly one argument.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="7593b-2906"><paramref name="method" /> 为 <see langword="null" />，并且没有为 <paramref name="expression" />.Type 定义一元 not 运算符。</span><span class="sxs-lookup"><span data-stu-id="7593b-2906"><paramref name="method" /> is <see langword="null" /> and the unary not operator is not defined for <paramref name="expression" />.Type.</span></span>  
  
<span data-ttu-id="7593b-2907">- 或 -</span><span class="sxs-lookup"><span data-stu-id="7593b-2907">-or-</span></span> 
 <span data-ttu-id="7593b-2908"><paramref name="expression" />.Type（如果它是可以为 null 的值类型，则取其相应的不可以为 null 的类型）不能赋给 <paramref name="method" /> 所表示的方法的参数类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-2908"><paramref name="expression" />.Type (or its corresponding non-nullable type if it is a nullable value type) is not assignable to the argument type of the method represented by <paramref name="method" />.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="NotEqual">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="7593b-2909">创建一个表示不相等比较的 <see cref="T:System.Linq.Expressions.BinaryExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2909">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an inequality comparison.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="NotEqual">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression NotEqual (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression NotEqual(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.NotEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function NotEqual (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ NotEqual(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member NotEqual : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.NotEqual (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="7593b-2910">要将 <see cref="T:System.Linq.Expressions.Expression" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2910">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="7593b-2911">要将 <see cref="T:System.Linq.Expressions.Expression" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2911">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="7593b-2912">创建一个表示不相等比较的 <see cref="T:System.Linq.Expressions.BinaryExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2912">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an inequality comparison.</span></span></summary>
        <returns><span data-ttu-id="7593b-2913">一个 <see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 属性等于 <see cref="F:System.Linq.Expressions.ExpressionType.NotEqual" />，并且其 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 属性设置为指定值。</span><span class="sxs-lookup"><span data-stu-id="7593b-2913">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.NotEqual" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7593b-2914">生成的 <xref:System.Linq.Expressions.BinaryExpression> 具有设置为实现方法的 <xref:System.Linq.Expressions.BinaryExpression.Method%2A> 属性。</span><span class="sxs-lookup"><span data-stu-id="7593b-2914">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="7593b-2915"><xref:System.Linq.Expressions.Expression.Type%2A> 属性设置为节点的类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-2915">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="7593b-2916">如果节点已提升，则 `true`<xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> 属性。</span><span class="sxs-lookup"><span data-stu-id="7593b-2916">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> property is `true`.</span></span> <span data-ttu-id="7593b-2917">否则，它是 `false`。</span><span class="sxs-lookup"><span data-stu-id="7593b-2917">Otherwise, it is `false`.</span></span> <span data-ttu-id="7593b-2918"><xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> 属性始终为 `false`。</span><span class="sxs-lookup"><span data-stu-id="7593b-2918">The <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> property is always `false`.</span></span> <span data-ttu-id="7593b-2919"><xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> 属性为 `null`。</span><span class="sxs-lookup"><span data-stu-id="7593b-2919">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="7593b-2920">以下信息描述了实现方法、节点类型以及节点是否已提升。</span><span class="sxs-lookup"><span data-stu-id="7593b-2920">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="7593b-2921">实现方法</span><span class="sxs-lookup"><span data-stu-id="7593b-2921">Implementing Method</span></span>  
 <span data-ttu-id="7593b-2922">以下规则确定操作的实现方法：</span><span class="sxs-lookup"><span data-stu-id="7593b-2922">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="7593b-2923">如果 `left` 或 `right` 的 <xref:System.Linq.Expressions.Expression.Type%2A> 属性表示重载不相等运算符的用户定义类型，则表示该方法的 <xref:System.Reflection.MethodInfo> 是实现方法。</span><span class="sxs-lookup"><span data-stu-id="7593b-2923">If the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the inequality operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="7593b-2924">否则，实现方法为 `null`。</span><span class="sxs-lookup"><span data-stu-id="7593b-2924">Otherwise, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="7593b-2925">节点类型和提升和非提升</span><span class="sxs-lookup"><span data-stu-id="7593b-2925">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="7593b-2926">如果不 `null`实现方法：</span><span class="sxs-lookup"><span data-stu-id="7593b-2926">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="7593b-2927">如果 `left`。键入并 `right`。类型可分配给实现方法的相应参数类型，不提升节点。</span><span class="sxs-lookup"><span data-stu-id="7593b-2927">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="7593b-2928">节点的类型是实现方法的返回类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-2928">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="7593b-2929">如果满足以下两个条件，则会提升节点并 <xref:System.Boolean>节点的类型：</span><span class="sxs-lookup"><span data-stu-id="7593b-2929">If the following two conditions are satisfied, the node is lifted and the type of the node is <xref:System.Boolean>:</span></span>  
  
    -   <span data-ttu-id="7593b-2930">`left`。键入并 `right`。类型既是值类型，其中至少有一个可为 null，并且相应的不可为 null 的类型等于实现方法的相应参数类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-2930">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="7593b-2931">实现方法的返回类型为 <xref:System.Boolean>。</span><span class="sxs-lookup"><span data-stu-id="7593b-2931">The return type of the implementing method is <xref:System.Boolean>.</span></span>  
  
 <span data-ttu-id="7593b-2932">如果实现方法为 `null`：</span><span class="sxs-lookup"><span data-stu-id="7593b-2932">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="7593b-2933">如果 `left`。键入并 `right`。类型不可以为 null，则不提升节点。</span><span class="sxs-lookup"><span data-stu-id="7593b-2933">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="7593b-2934">节点的类型为 <xref:System.Boolean>。</span><span class="sxs-lookup"><span data-stu-id="7593b-2934">The type of the node is <xref:System.Boolean>.</span></span>  
  
-   <span data-ttu-id="7593b-2935">如果 `left`。键入并 `right`。类型均可为 null，则提升节点。</span><span class="sxs-lookup"><span data-stu-id="7593b-2935">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="7593b-2936">节点的类型为 <xref:System.Boolean>。</span><span class="sxs-lookup"><span data-stu-id="7593b-2936">The type of the node is <xref:System.Boolean>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="7593b-2937"><paramref name="left" /> 或 <paramref name="right" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2937"><paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="7593b-2938">没有为 <paramref name="left" />.Type 和 <paramref name="right" />.Type 定义不相等运算符。</span><span class="sxs-lookup"><span data-stu-id="7593b-2938">The inequality operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="NotEqual">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression NotEqual (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, bool liftToNull, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression NotEqual(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, bool liftToNull, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.NotEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function NotEqual (left As Expression, right As Expression, liftToNull As Boolean, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ NotEqual(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, bool liftToNull, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member NotEqual : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * bool * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.NotEqual (left, right, liftToNull, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="liftToNull" Type="System.Boolean" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="7593b-2939">要将 <see cref="T:System.Linq.Expressions.Expression" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2939">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="7593b-2940">要将 <see cref="T:System.Linq.Expressions.Expression" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2940">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <param name="liftToNull"><span data-ttu-id="7593b-2941">若要将 <see langword="true" /> 设置为 <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" />，则为 <see langword="true" />；若要将 <see langword="false" /> 设置为 <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" />，则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2941"><see langword="true" /> to set <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> to <see langword="true" />; <see langword="false" /> to set <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> to <see langword="false" />.</span></span></param>
        <param name="method"><span data-ttu-id="7593b-2942">要将 <see cref="T:System.Reflection.MethodInfo" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2942">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="7593b-2943">创建一个表示不相等比较的 <see cref="T:System.Linq.Expressions.BinaryExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2943">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an inequality comparison.</span></span></summary>
        <returns><span data-ttu-id="7593b-2944">一个 <see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 属性等于 <see cref="F:System.Linq.Expressions.ExpressionType.NotEqual" />，并且其 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />、<see cref="P:System.Linq.Expressions.BinaryExpression.Right" />、<see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> 属性设置为指定值。</span><span class="sxs-lookup"><span data-stu-id="7593b-2944">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.NotEqual" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7593b-2945">生成的 <xref:System.Linq.Expressions.BinaryExpression> 具有设置为实现方法的 <xref:System.Linq.Expressions.BinaryExpression.Method%2A> 属性。</span><span class="sxs-lookup"><span data-stu-id="7593b-2945">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="7593b-2946"><xref:System.Linq.Expressions.Expression.Type%2A> 属性设置为节点的类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-2946">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="7593b-2947">如果节点已提升，则 `true` <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> 属性，<xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> 属性等于 `liftToNull`。</span><span class="sxs-lookup"><span data-stu-id="7593b-2947">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> property is `true` and the <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> property is equal to `liftToNull`.</span></span> <span data-ttu-id="7593b-2948">否则，它们都 `false`。</span><span class="sxs-lookup"><span data-stu-id="7593b-2948">Otherwise, they are both `false`.</span></span> <span data-ttu-id="7593b-2949"><xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> 属性为 `null`。</span><span class="sxs-lookup"><span data-stu-id="7593b-2949">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="7593b-2950">以下信息描述了实现方法、节点类型以及节点是否已提升。</span><span class="sxs-lookup"><span data-stu-id="7593b-2950">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="7593b-2951">实现方法</span><span class="sxs-lookup"><span data-stu-id="7593b-2951">Implementing Method</span></span>  
 <span data-ttu-id="7593b-2952">以下规则确定操作的实现方法：</span><span class="sxs-lookup"><span data-stu-id="7593b-2952">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="7593b-2953">如果 `method` 未 `null` 并且它表示采用两个自变量的非 void、`static``Shared` （Visual Basic）方法，则它是实现方法。</span><span class="sxs-lookup"><span data-stu-id="7593b-2953">If `method` is not `null` and it represents a non-void, `static` (`Shared` in Visual Basic) method that takes two arguments, it is the implementing method.</span></span>  
  
-   <span data-ttu-id="7593b-2954">否则，如果 `left` 或 `right` 的 <xref:System.Linq.Expressions.Expression.Type%2A> 属性表示重载不相等运算符的用户定义的类型，则表示该方法的 <xref:System.Reflection.MethodInfo> 是实现方法。</span><span class="sxs-lookup"><span data-stu-id="7593b-2954">Otherwise, if the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the inequality operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="7593b-2955">否则，实现方法为 `null`。</span><span class="sxs-lookup"><span data-stu-id="7593b-2955">Otherwise, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="7593b-2956">节点类型和提升和非提升</span><span class="sxs-lookup"><span data-stu-id="7593b-2956">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="7593b-2957">如果不 `null`实现方法：</span><span class="sxs-lookup"><span data-stu-id="7593b-2957">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="7593b-2958">如果 `left`。键入并 `right`。类型可分配给实现方法的相应参数类型，不提升节点。</span><span class="sxs-lookup"><span data-stu-id="7593b-2958">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="7593b-2959">节点的类型是实现方法的返回类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-2959">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="7593b-2960">如果满足以下两个条件，则提升节点;此外，如果 `liftToNull` `false`，则节点类型可以为 null <xref:System.Boolean> 如果 `liftToNull` `true` 或 <xref:System.Boolean>：</span><span class="sxs-lookup"><span data-stu-id="7593b-2960">If the following two conditions are satisfied, the node is lifted; also, the type of the node is nullable <xref:System.Boolean> if `liftToNull` is `true` or <xref:System.Boolean> if `liftToNull` is `false`:</span></span>  
  
    -   <span data-ttu-id="7593b-2961">`left`。键入并 `right`。类型既是值类型，其中至少有一个可为 null，并且相应的不可为 null 的类型等于实现方法的相应参数类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-2961">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="7593b-2962">实现方法的返回类型为 <xref:System.Boolean>。</span><span class="sxs-lookup"><span data-stu-id="7593b-2962">The return type of the implementing method is <xref:System.Boolean>.</span></span>  
  
 <span data-ttu-id="7593b-2963">如果实现方法为 `null`：</span><span class="sxs-lookup"><span data-stu-id="7593b-2963">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="7593b-2964">如果 `left`。键入并 `right`。类型不可以为 null，则不提升节点。</span><span class="sxs-lookup"><span data-stu-id="7593b-2964">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="7593b-2965">节点的类型为 <xref:System.Boolean>。</span><span class="sxs-lookup"><span data-stu-id="7593b-2965">The type of the node is <xref:System.Boolean>.</span></span>  
  
-   <span data-ttu-id="7593b-2966">如果 `left`。键入并 `right`。类型均可为 null，则提升节点。</span><span class="sxs-lookup"><span data-stu-id="7593b-2966">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="7593b-2967">如果 `liftToNull` `true`，则节点的类型可以为 null <xref:System.Boolean> 如果 `liftToNull` `false`，则为 <xref:System.Boolean>。</span><span class="sxs-lookup"><span data-stu-id="7593b-2967">The type of the node is nullable <xref:System.Boolean> if `liftToNull` is `true` or <xref:System.Boolean> if `liftToNull` is `false`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="7593b-2968"><paramref name="left" /> 或 <paramref name="right" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2968"><paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="7593b-2969"><paramref name="method" /> 不是 <see langword="null" />，它所表示的方法返回 <see langword="void" />，而不是 <see langword="static" />（Visual Basic 中为 <see langword="Shared" />），或者并非采用两个参数。</span><span class="sxs-lookup"><span data-stu-id="7593b-2969"><paramref name="method" /> is not <see langword="null" /> and the method it represents returns <see langword="void" />, is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic), or does not take exactly two arguments.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="7593b-2970"><paramref name="method" /> 为 <see langword="null" />，并且没有为 <paramref name="left" />.Type 和 <paramref name="right" />.Type 定义不相等运算符。</span><span class="sxs-lookup"><span data-stu-id="7593b-2970"><paramref name="method" /> is <see langword="null" /> and the inequality operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="OnesComplement">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="7593b-2971">返回表示一的补数的表达式。</span><span class="sxs-lookup"><span data-stu-id="7593b-2971">Returns the expression representing the ones complement.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OnesComplement">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression OnesComplement (System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression OnesComplement(class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.OnesComplement(System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ OnesComplement(System::Linq::Expressions::Expression ^ expression);" />
      <MemberSignature Language="F#" Value="static member OnesComplement : System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.OnesComplement expression" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="expression"><span data-ttu-id="7593b-2972">一个 <see cref="T:System.Linq.Expressions.Expression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2972">An <see cref="T:System.Linq.Expressions.Expression" />.</span></span></param>
        <summary><span data-ttu-id="7593b-2973">返回表示一的补数的表达式。</span><span class="sxs-lookup"><span data-stu-id="7593b-2973">Returns the expression representing the ones complement.</span></span></summary>
        <returns><span data-ttu-id="7593b-2974"><see cref="T:System.Linq.Expressions.UnaryExpression" /> 的实例。</span><span class="sxs-lookup"><span data-stu-id="7593b-2974">An instance of <see cref="T:System.Linq.Expressions.UnaryExpression" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnesComplement">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression OnesComplement (System.Linq.Expressions.Expression expression, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression OnesComplement(class System.Linq.Expressions.Expression expression, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.OnesComplement(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ OnesComplement(System::Linq::Expressions::Expression ^ expression, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member OnesComplement : System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.OnesComplement (expression, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="expression"><span data-ttu-id="7593b-2975">一个 <see cref="T:System.Linq.Expressions.Expression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2975">An <see cref="T:System.Linq.Expressions.Expression" />.</span></span></param>
        <param name="method"><span data-ttu-id="7593b-2976">表示实现方法的 <see cref="T:System.Reflection.MethodInfo" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2976">A <see cref="T:System.Reflection.MethodInfo" /> that represents the implementing method.</span></span></param>
        <summary><span data-ttu-id="7593b-2977">返回表示一的补数的表达式。</span><span class="sxs-lookup"><span data-stu-id="7593b-2977">Returns the expression representing the ones complement.</span></span></summary>
        <returns><span data-ttu-id="7593b-2978"><see cref="T:System.Linq.Expressions.UnaryExpression" /> 的实例。</span><span class="sxs-lookup"><span data-stu-id="7593b-2978">An instance of <see cref="T:System.Linq.Expressions.UnaryExpression" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Or">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="7593b-2979">创建一个表示按位 <see cref="T:System.Linq.Expressions.BinaryExpression" /> 运算的 <see langword="OR" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2979">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise <see langword="OR" /> operation.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Or">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Or (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Or(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Or(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Or (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Or(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member Or : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.Or (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="7593b-2980">要将 <see cref="T:System.Linq.Expressions.Expression" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2980">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="7593b-2981">要将 <see cref="T:System.Linq.Expressions.Expression" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2981">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="7593b-2982">创建一个表示按位 <see cref="T:System.Linq.Expressions.BinaryExpression" /> 运算的 <see langword="OR" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-2982">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise <see langword="OR" /> operation.</span></span></summary>
        <returns><span data-ttu-id="7593b-2983">一个 <see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 属性等于 <see cref="F:System.Linq.Expressions.ExpressionType.Or" />，并且其 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 属性设置为指定值。</span><span class="sxs-lookup"><span data-stu-id="7593b-2983">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Or" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7593b-2984">生成的 <xref:System.Linq.Expressions.BinaryExpression> 具有设置为实现方法的 <xref:System.Linq.Expressions.BinaryExpression.Method%2A> 属性。</span><span class="sxs-lookup"><span data-stu-id="7593b-2984">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="7593b-2985"><xref:System.Linq.Expressions.Expression.Type%2A> 属性设置为节点的类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-2985">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="7593b-2986">如果节点已提升，则 <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> 和 <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> 属性均 `true`。</span><span class="sxs-lookup"><span data-stu-id="7593b-2986">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="7593b-2987">否则，它们 `false`。</span><span class="sxs-lookup"><span data-stu-id="7593b-2987">Otherwise, they are `false`.</span></span> <span data-ttu-id="7593b-2988"><xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> 属性为 `null`。</span><span class="sxs-lookup"><span data-stu-id="7593b-2988">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="7593b-2989">以下信息描述了实现方法、节点类型以及节点是否已提升。</span><span class="sxs-lookup"><span data-stu-id="7593b-2989">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="7593b-2990">实现方法</span><span class="sxs-lookup"><span data-stu-id="7593b-2990">Implementing Method</span></span>  
 <span data-ttu-id="7593b-2991">以下规则确定操作的实现方法：</span><span class="sxs-lookup"><span data-stu-id="7593b-2991">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="7593b-2992">如果 `left` 或 `right` 的 <xref:System.Linq.Expressions.Expression.Type%2A> 属性表示重载按位 `OR` 运算符的用户定义类型，则表示该方法的 <xref:System.Reflection.MethodInfo> 是实现方法。</span><span class="sxs-lookup"><span data-stu-id="7593b-2992">If the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the bitwise `OR` operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="7593b-2993">否则，如果 `left`。键入并 `right`。类型为整型或布尔类型，则实现方法为 `null`。</span><span class="sxs-lookup"><span data-stu-id="7593b-2993">Otherwise, if `left`.Type and `right`.Type are integral or Boolean types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="7593b-2994">节点类型和提升和非提升</span><span class="sxs-lookup"><span data-stu-id="7593b-2994">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="7593b-2995">如果不 `null`实现方法：</span><span class="sxs-lookup"><span data-stu-id="7593b-2995">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="7593b-2996">如果 `left`。键入并 `right`。类型可分配给实现方法的相应参数类型，不提升节点。</span><span class="sxs-lookup"><span data-stu-id="7593b-2996">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="7593b-2997">节点的类型是实现方法的返回类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-2997">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="7593b-2998">如果满足以下两个条件，则会提升节点，并且该节点的类型为与实现方法的返回类型对应的可以为 null 的类型：</span><span class="sxs-lookup"><span data-stu-id="7593b-2998">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="7593b-2999">`left`。键入并 `right`。类型既是值类型，其中至少有一个可为 null，并且相应的不可为 null 的类型等于实现方法的相应参数类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-2999">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="7593b-3000">实现方法的返回类型是不可为 null 的值类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-3000">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="7593b-3001">如果实现方法为 `null`：</span><span class="sxs-lookup"><span data-stu-id="7593b-3001">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="7593b-3002">如果 `left`。键入并 `right`。类型不可以为 null，则不提升节点。</span><span class="sxs-lookup"><span data-stu-id="7593b-3002">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="7593b-3003">节点的类型为预定义的按位 `OR` 运算符的结果类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-3003">The type of the node is the result type of the predefined bitwise `OR` operator.</span></span>  
  
-   <span data-ttu-id="7593b-3004">如果 `left`。键入并 `right`。类型均可为 null，则提升节点。</span><span class="sxs-lookup"><span data-stu-id="7593b-3004">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="7593b-3005">节点的类型是与预定义的按位 `OR` 运算符的结果类型对应的可以为 null 的类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-3005">The type of the node is the nullable type that corresponds to the result type of the predefined bitwise `OR` operator.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="7593b-3006">下面的代码示例演示如何创建表示逻辑或运算的表达式。</span><span class="sxs-lookup"><span data-stu-id="7593b-3006">The following code example shows how to create an expression that represents a logical OR operation.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#28](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#28)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#28](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#28)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="7593b-3007"><paramref name="left" /> 或 <paramref name="right" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-3007"><paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="7593b-3008">没有为 <see langword="OR" />.Type 和 <paramref name="left" />.Type 定义按位 <paramref name="right" /> 运算符。</span><span class="sxs-lookup"><span data-stu-id="7593b-3008">The bitwise <see langword="OR" /> operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Or">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Or (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Or(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Or(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Or (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Or(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member Or : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.Or (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="7593b-3009">要将 <see cref="T:System.Linq.Expressions.Expression" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-3009">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="7593b-3010">要将 <see cref="T:System.Linq.Expressions.Expression" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-3010">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <param name="method"><span data-ttu-id="7593b-3011">要将 <see cref="T:System.Reflection.MethodInfo" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-3011">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="7593b-3012">创建一个表示按位 <see cref="T:System.Linq.Expressions.BinaryExpression" /> 运算的 <see langword="OR" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-3012">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise <see langword="OR" /> operation.</span></span></summary>
        <returns><span data-ttu-id="7593b-3013">一个 <see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 属性等于 <see cref="F:System.Linq.Expressions.ExpressionType.Or" />，并且其 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />、<see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> 属性设置为指定值。</span><span class="sxs-lookup"><span data-stu-id="7593b-3013">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Or" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7593b-3014">生成的 <xref:System.Linq.Expressions.BinaryExpression> 具有设置为实现方法的 <xref:System.Linq.Expressions.BinaryExpression.Method%2A> 属性。</span><span class="sxs-lookup"><span data-stu-id="7593b-3014">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="7593b-3015"><xref:System.Linq.Expressions.Expression.Type%2A> 属性设置为节点的类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-3015">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="7593b-3016">如果节点已提升，则 <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> 和 <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> 属性均 `true`。</span><span class="sxs-lookup"><span data-stu-id="7593b-3016">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="7593b-3017">否则，它们 `false`。</span><span class="sxs-lookup"><span data-stu-id="7593b-3017">Otherwise, they are `false`.</span></span> <span data-ttu-id="7593b-3018"><xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> 属性为 `null`。</span><span class="sxs-lookup"><span data-stu-id="7593b-3018">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="7593b-3019">以下信息描述了实现方法、节点类型以及节点是否已提升。</span><span class="sxs-lookup"><span data-stu-id="7593b-3019">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="7593b-3020">实现方法</span><span class="sxs-lookup"><span data-stu-id="7593b-3020">Implementing Method</span></span>  
 <span data-ttu-id="7593b-3021">以下规则确定操作的实现方法：</span><span class="sxs-lookup"><span data-stu-id="7593b-3021">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="7593b-3022">如果 `method` 未 `null` 并且它表示采用两个自变量的非 void、`static``Shared` （Visual Basic）方法，则它是实现方法。</span><span class="sxs-lookup"><span data-stu-id="7593b-3022">If `method` is not `null` and it represents a non-void, `static` (`Shared` in Visual Basic) method that takes two arguments, it is the implementing method.</span></span>  
  
-   <span data-ttu-id="7593b-3023">否则，如果 `left` 或 `right` 的 <xref:System.Linq.Expressions.Expression.Type%2A> 属性表示重载按位 `OR` 运算符的用户定义类型，则表示该方法的 <xref:System.Reflection.MethodInfo> 是实现方法。</span><span class="sxs-lookup"><span data-stu-id="7593b-3023">Otherwise, if the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the bitwise `OR` operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="7593b-3024">否则，如果 `left`。键入并 `right`。类型为整型或布尔类型，则实现方法为 `null`。</span><span class="sxs-lookup"><span data-stu-id="7593b-3024">Otherwise, if `left`.Type and `right`.Type are integral or Boolean types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="7593b-3025">节点类型和提升和非提升</span><span class="sxs-lookup"><span data-stu-id="7593b-3025">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="7593b-3026">如果不 `null`实现方法：</span><span class="sxs-lookup"><span data-stu-id="7593b-3026">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="7593b-3027">如果 `left`。键入并 `right`。类型可分配给实现方法的相应参数类型，不提升节点。</span><span class="sxs-lookup"><span data-stu-id="7593b-3027">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="7593b-3028">节点的类型是实现方法的返回类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-3028">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="7593b-3029">如果满足以下两个条件，则会提升节点，并且该节点的类型为与实现方法的返回类型对应的可以为 null 的类型：</span><span class="sxs-lookup"><span data-stu-id="7593b-3029">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="7593b-3030">`left`。键入并 `right`。类型既是值类型，其中至少有一个可为 null，并且相应的不可为 null 的类型等于实现方法的相应参数类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-3030">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="7593b-3031">实现方法的返回类型是不可为 null 的值类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-3031">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="7593b-3032">如果实现方法为 `null`：</span><span class="sxs-lookup"><span data-stu-id="7593b-3032">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="7593b-3033">如果 `left`。键入并 `right`。类型不可以为 null，则不提升节点。</span><span class="sxs-lookup"><span data-stu-id="7593b-3033">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="7593b-3034">节点的类型为预定义的按位 `OR` 运算符的结果类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-3034">The type of the node is the result type of the predefined bitwise `OR` operator.</span></span>  
  
-   <span data-ttu-id="7593b-3035">如果 `left`。键入并 `right`。类型均可为 null，则提升节点。</span><span class="sxs-lookup"><span data-stu-id="7593b-3035">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="7593b-3036">节点的类型是与预定义的按位 `OR` 运算符的结果类型对应的可以为 null 的类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-3036">The type of the node is the nullable type that corresponds to the result type of the predefined bitwise `OR` operator.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="7593b-3037"><paramref name="left" /> 或 <paramref name="right" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-3037"><paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="7593b-3038"><paramref name="method" /> 不是 <see langword="null" />，它所表示的方法返回 <see langword="void" />，而不是 <see langword="static" />（Visual Basic 中为 <see langword="Shared" />），或者并非采用两个参数。</span><span class="sxs-lookup"><span data-stu-id="7593b-3038"><paramref name="method" /> is not <see langword="null" /> and the method it represents returns <see langword="void" />, is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic), or does not take exactly two arguments.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="7593b-3039"><paramref name="method" /> 是 <see langword="null" />，且没有为 <see langword="OR" />.Type 和 <paramref name="left" />.Type 定义按位 <paramref name="right" /> 运算符。</span><span class="sxs-lookup"><span data-stu-id="7593b-3039"><paramref name="method" /> is <see langword="null" /> and the bitwise <see langword="OR" /> operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="OrAssign">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="7593b-3040">创建一个表示按位 OR 赋值运算的 <see cref="T:System.Linq.Expressions.BinaryExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-3040">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise OR assignment operation.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OrAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression OrAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression OrAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.OrAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OrAssign (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ OrAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member OrAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.OrAssign (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="7593b-3041">要将 <see cref="T:System.Linq.Expressions.Expression" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-3041">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="7593b-3042">要将 <see cref="T:System.Linq.Expressions.Expression" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-3042">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="7593b-3043">创建一个表示按位 OR 赋值运算的 <see cref="T:System.Linq.Expressions.BinaryExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-3043">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise OR assignment operation.</span></span></summary>
        <returns><span data-ttu-id="7593b-3044">一个 <see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 属性等于 <see cref="F:System.Linq.Expressions.ExpressionType.OrAssign" />，并且其 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 属性设置为指定值。</span><span class="sxs-lookup"><span data-stu-id="7593b-3044">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.OrAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OrAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression OrAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression OrAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.OrAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OrAssign (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ OrAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member OrAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.OrAssign (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="7593b-3045">要将 <see cref="T:System.Linq.Expressions.Expression" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-3045">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="7593b-3046">要将 <see cref="T:System.Linq.Expressions.Expression" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-3046">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <param name="method"><span data-ttu-id="7593b-3047">要将 <see cref="T:System.Reflection.MethodInfo" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-3047">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="7593b-3048">创建一个表示按位 OR 赋值运算的 <see cref="T:System.Linq.Expressions.BinaryExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-3048">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise OR assignment operation.</span></span></summary>
        <returns><span data-ttu-id="7593b-3049">一个 <see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 属性等于 <see cref="F:System.Linq.Expressions.ExpressionType.OrAssign" />，并且其 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />、<see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> 属性设置为指定值。</span><span class="sxs-lookup"><span data-stu-id="7593b-3049">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.OrAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OrAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression OrAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method, System.Linq.Expressions.LambdaExpression conversion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression OrAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method, class System.Linq.Expressions.LambdaExpression conversion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.OrAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OrAssign (left As Expression, right As Expression, method As MethodInfo, conversion As LambdaExpression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ OrAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method, System::Linq::Expressions::LambdaExpression ^ conversion);" />
      <MemberSignature Language="F#" Value="static member OrAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo * System.Linq.Expressions.LambdaExpression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.OrAssign (left, right, method, conversion)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="conversion" Type="System.Linq.Expressions.LambdaExpression" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="7593b-3050">要将 <see cref="T:System.Linq.Expressions.Expression" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-3050">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="7593b-3051">要将 <see cref="T:System.Linq.Expressions.Expression" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-3051">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <param name="method"><span data-ttu-id="7593b-3052">要将 <see cref="T:System.Reflection.MethodInfo" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-3052">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span></span></param>
        <param name="conversion"><span data-ttu-id="7593b-3053">要将 <see cref="T:System.Linq.Expressions.LambdaExpression" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-3053">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="7593b-3054">创建一个表示按位 OR 赋值运算的 <see cref="T:System.Linq.Expressions.BinaryExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-3054">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise OR assignment operation.</span></span></summary>
        <returns><span data-ttu-id="7593b-3055">一个 <see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 属性等于 <see cref="F:System.Linq.Expressions.ExpressionType.OrAssign" />，并且其 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />、<see cref="P:System.Linq.Expressions.BinaryExpression.Right" />、<see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> 属性设置为指定值。</span><span class="sxs-lookup"><span data-stu-id="7593b-3055">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.OrAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="OrElse">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="7593b-3056">创建一个 <see cref="T:System.Linq.Expressions.BinaryExpression" />，它表示仅在第一个操作数的计算结果为 <see langword="OR" /> 时才计算第二个操作数的条件 <see langword="false" /> 运算。</span><span class="sxs-lookup"><span data-stu-id="7593b-3056">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a conditional <see langword="OR" /> operation that evaluates the second operand only if the first operator evaluates to <see langword="false" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OrElse">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression OrElse (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression OrElse(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.OrElse(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OrElse (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ OrElse(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member OrElse : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.OrElse (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="7593b-3057">要将 <see cref="T:System.Linq.Expressions.Expression" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-3057">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="7593b-3058">要将 <see cref="T:System.Linq.Expressions.Expression" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-3058">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="7593b-3059">创建一个 <see cref="T:System.Linq.Expressions.BinaryExpression" />，它表示仅在第一个操作数的计算结果为 <see langword="OR" /> 时才计算第二个操作数的条件 <see langword="false" /> 运算。</span><span class="sxs-lookup"><span data-stu-id="7593b-3059">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a conditional <see langword="OR" /> operation that evaluates the second operand only if the first operand evaluates to <see langword="false" />.</span></span></summary>
        <returns><span data-ttu-id="7593b-3060">一个 <see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 属性等于 <see cref="F:System.Linq.Expressions.ExpressionType.OrElse" />，并且其 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 属性设置为指定值。</span><span class="sxs-lookup"><span data-stu-id="7593b-3060">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.OrElse" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7593b-3061">生成的 <xref:System.Linq.Expressions.BinaryExpression> 具有设置为实现方法的 <xref:System.Linq.Expressions.BinaryExpression.Method%2A> 属性。</span><span class="sxs-lookup"><span data-stu-id="7593b-3061">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="7593b-3062"><xref:System.Linq.Expressions.Expression.Type%2A> 属性设置为节点的类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-3062">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="7593b-3063">如果节点已提升，则 <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> 和 <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> 属性均 `true`。</span><span class="sxs-lookup"><span data-stu-id="7593b-3063">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="7593b-3064">否则，它们 `false`。</span><span class="sxs-lookup"><span data-stu-id="7593b-3064">Otherwise, they are `false`.</span></span> <span data-ttu-id="7593b-3065"><xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> 属性为 `null`。</span><span class="sxs-lookup"><span data-stu-id="7593b-3065">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="7593b-3066">以下信息描述了实现方法、节点类型以及节点是否已提升。</span><span class="sxs-lookup"><span data-stu-id="7593b-3066">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="7593b-3067">实现方法</span><span class="sxs-lookup"><span data-stu-id="7593b-3067">Implementing Method</span></span>  
 <span data-ttu-id="7593b-3068">以下规则确定操作的实现方法：</span><span class="sxs-lookup"><span data-stu-id="7593b-3068">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="7593b-3069">如果 `left` 或 `right` 的 <xref:System.Linq.Expressions.Expression.Type%2A> 属性表示重载按位 `OR` 运算符的用户定义类型，则表示该方法的 <xref:System.Reflection.MethodInfo> 是实现方法。</span><span class="sxs-lookup"><span data-stu-id="7593b-3069">If the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the bitwise `OR` operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="7593b-3070">不能在或 Visual Basic 中C#重载条件 `OR` 运算符。</span><span class="sxs-lookup"><span data-stu-id="7593b-3070">The conditional `OR` operator cannot be overloaded in C# or Visual Basic.</span></span> <span data-ttu-id="7593b-3071">不过，条件 `OR` 运算符使用按位 `OR` 运算符进行计算。</span><span class="sxs-lookup"><span data-stu-id="7593b-3071">However, the conditional `OR` operator is evaluated by using the bitwise `OR` operator.</span></span> <span data-ttu-id="7593b-3072">因此，按位 `OR` 运算符的用户定义的重载可以是此节点类型的实现方法。</span><span class="sxs-lookup"><span data-stu-id="7593b-3072">Thus, a user-defined overload of the bitwise `OR` operator can be the implementing method for this node type.</span></span>  
  
-   <span data-ttu-id="7593b-3073">否则，如果 `left`。键入并 `right`。类型是布尔类型，则实现方法为 `null`。</span><span class="sxs-lookup"><span data-stu-id="7593b-3073">Otherwise, if `left`.Type and `right`.Type are Boolean types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="7593b-3074">节点类型和提升和非提升</span><span class="sxs-lookup"><span data-stu-id="7593b-3074">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="7593b-3075">如果不 `null`实现方法：</span><span class="sxs-lookup"><span data-stu-id="7593b-3075">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="7593b-3076">如果 `left`。键入并 `right`。类型可分配给实现方法的相应参数类型，不提升节点。</span><span class="sxs-lookup"><span data-stu-id="7593b-3076">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="7593b-3077">节点的类型是实现方法的返回类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-3077">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="7593b-3078">如果满足以下两个条件，则会提升节点，并且该节点的类型为与实现方法的返回类型对应的可以为 null 的类型：</span><span class="sxs-lookup"><span data-stu-id="7593b-3078">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="7593b-3079">`left`。键入并 `right`。类型既是值类型，其中至少有一个可为 null，并且相应的不可为 null 的类型等于实现方法的相应参数类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-3079">`left`.Type and `right`.Type are both value types of which at least one is nullable, and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="7593b-3080">实现方法的返回类型是不可为 null 的值类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-3080">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="7593b-3081">如果实现方法为 `null`：</span><span class="sxs-lookup"><span data-stu-id="7593b-3081">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="7593b-3082">`left`。键入并 `right`。类型是相同的布尔类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-3082">`left`.Type and `right`.Type are the same Boolean type.</span></span>  
  
-   <span data-ttu-id="7593b-3083">如果 `left`。键入并 `right`。类型不可为 null，则不提升节点。</span><span class="sxs-lookup"><span data-stu-id="7593b-3083">If `left`.Type and `right`.Type are non-nullable, the node is not lifted.</span></span> <span data-ttu-id="7593b-3084">节点的类型是预定义的条件 `OR` 运算符的结果类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-3084">The type of the node is the result type of the predefined conditional `OR` operator.</span></span>  
  
-   <span data-ttu-id="7593b-3085">如果 `left`。键入并 `right`。类型可以为 null，则提升节点。</span><span class="sxs-lookup"><span data-stu-id="7593b-3085">If `left`.Type and `right`.Type are nullable, the node is lifted.</span></span> <span data-ttu-id="7593b-3086">节点的类型是与预定义条件 `OR` 运算符的结果类型对应的可以为 null 的类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-3086">The type of the node is the nullable type that corresponds to the result type of the predefined conditional `OR` operator.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="7593b-3087">下面的代码示例演示如何创建一个表达式，该表达式表示仅在第一个操作数的计算结果为 `false`时才计算第二个操作数的逻辑 `OR` 运算。</span><span class="sxs-lookup"><span data-stu-id="7593b-3087">The following code example shows how to create an expression that represents a logical `OR` operation that evaluates the second operand only if the first operand evaluates to `false`.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#29](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#29)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#29](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#29)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="7593b-3088"><paramref name="left" /> 或 <paramref name="right" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-3088"><paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="7593b-3089">没有为 <see langword="OR" />.Type 和 <paramref name="left" />.Type 定义按位 <paramref name="right" /> 运算符。</span><span class="sxs-lookup"><span data-stu-id="7593b-3089">The bitwise <see langword="OR" /> operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span></span>  
  
<span data-ttu-id="7593b-3090">- 或 -</span><span class="sxs-lookup"><span data-stu-id="7593b-3090">-or-</span></span> 
 <span data-ttu-id="7593b-3091"><paramref name="left" />.Type 和 <paramref name="right" />.Type 不是同一布尔值类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-3091"><paramref name="left" />.Type and <paramref name="right" />.Type are not the same Boolean type.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="OrElse">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression OrElse (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression OrElse(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.OrElse(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OrElse (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ OrElse(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member OrElse : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.OrElse (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="7593b-3092">要将 <see cref="T:System.Linq.Expressions.Expression" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-3092">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="7593b-3093">要将 <see cref="T:System.Linq.Expressions.Expression" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-3093">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <param name="method"><span data-ttu-id="7593b-3094">要将 <see cref="T:System.Reflection.MethodInfo" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-3094">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="7593b-3095">创建一个 <see cref="T:System.Linq.Expressions.BinaryExpression" />，它表示仅在第一个操作数的计算结果为 <see langword="OR" /> 时才计算第二个操作数的条件 <see langword="false" /> 运算。</span><span class="sxs-lookup"><span data-stu-id="7593b-3095">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a conditional <see langword="OR" /> operation that evaluates the second operand only if the first operand evaluates to <see langword="false" />.</span></span></summary>
        <returns><span data-ttu-id="7593b-3096">一个 <see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 属性等于 <see cref="F:System.Linq.Expressions.ExpressionType.OrElse" />，并且其 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />、<see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> 属性设置为指定值。</span><span class="sxs-lookup"><span data-stu-id="7593b-3096">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.OrElse" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7593b-3097">生成的 <xref:System.Linq.Expressions.BinaryExpression> 具有设置为实现方法的 <xref:System.Linq.Expressions.BinaryExpression.Method%2A> 属性。</span><span class="sxs-lookup"><span data-stu-id="7593b-3097">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="7593b-3098"><xref:System.Linq.Expressions.Expression.Type%2A> 属性设置为节点的类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-3098">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="7593b-3099">如果节点已提升，则 <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> 和 <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> 属性均 `true`。</span><span class="sxs-lookup"><span data-stu-id="7593b-3099">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="7593b-3100">否则，它们 `false`。</span><span class="sxs-lookup"><span data-stu-id="7593b-3100">Otherwise, they are `false`.</span></span> <span data-ttu-id="7593b-3101"><xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> 属性为 `null`。</span><span class="sxs-lookup"><span data-stu-id="7593b-3101">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="7593b-3102">以下信息描述了实现方法、节点类型以及节点是否已提升。</span><span class="sxs-lookup"><span data-stu-id="7593b-3102">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="7593b-3103">实现方法</span><span class="sxs-lookup"><span data-stu-id="7593b-3103">Implementing Method</span></span>  
 <span data-ttu-id="7593b-3104">以下规则确定操作的实现方法：</span><span class="sxs-lookup"><span data-stu-id="7593b-3104">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="7593b-3105">如果 `method` 未 `null` 并且它表示采用两个自变量的非 void、`static``Shared` （Visual Basic）方法，则它是节点的实现方法。</span><span class="sxs-lookup"><span data-stu-id="7593b-3105">If `method` is not `null` and it represents a non-void, `static` (`Shared` in Visual Basic) method that takes two arguments, it is the implementing method for the node.</span></span>  
  
-   <span data-ttu-id="7593b-3106">否则，如果 `left` 或 `right` 的 <xref:System.Linq.Expressions.Expression.Type%2A> 属性表示重载按位 `OR` 运算符的用户定义类型，则表示该方法的 <xref:System.Reflection.MethodInfo> 是实现方法。</span><span class="sxs-lookup"><span data-stu-id="7593b-3106">Otherwise, if the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the bitwise `OR` operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="7593b-3107">不能在或 Visual Basic 中C#重载条件 `OR` 运算符。</span><span class="sxs-lookup"><span data-stu-id="7593b-3107">The conditional `OR` operator cannot be overloaded in C# or Visual Basic.</span></span> <span data-ttu-id="7593b-3108">不过，条件 `OR` 运算符使用按位 `OR` 运算符进行计算。</span><span class="sxs-lookup"><span data-stu-id="7593b-3108">However, the conditional `OR` operator is evaluated by using the bitwise `OR` operator.</span></span> <span data-ttu-id="7593b-3109">因此，按位 `OR` 运算符的用户定义的重载可以是此节点类型的实现方法。</span><span class="sxs-lookup"><span data-stu-id="7593b-3109">Thus, a user-defined overload of the bitwise `OR` operator can be the implementing method for this node type.</span></span>  
  
-   <span data-ttu-id="7593b-3110">否则，如果 `left`。键入并 `right`。类型是布尔类型，则实现方法为 `null`。</span><span class="sxs-lookup"><span data-stu-id="7593b-3110">Otherwise, if `left`.Type and `right`.Type are Boolean types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="7593b-3111">节点类型和提升和非提升</span><span class="sxs-lookup"><span data-stu-id="7593b-3111">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="7593b-3112">如果不 `null`实现方法：</span><span class="sxs-lookup"><span data-stu-id="7593b-3112">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="7593b-3113">如果 `left`。键入并 `right`。类型可分配给实现方法的相应参数类型，不提升节点。</span><span class="sxs-lookup"><span data-stu-id="7593b-3113">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="7593b-3114">节点的类型是实现方法的返回类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-3114">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="7593b-3115">如果满足以下两个条件，则会提升节点，并且该节点的类型为与实现方法的返回类型对应的可以为 null 的类型：</span><span class="sxs-lookup"><span data-stu-id="7593b-3115">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="7593b-3116">`left`。键入并 `right`。类型既是值类型，其中至少有一个可为 null，并且相应的不可为 null 的类型等于实现方法的相应参数类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-3116">`left`.Type and `right`.Type are both value types of which at least one is nullable, and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="7593b-3117">实现方法的返回类型是不可为 null 的值类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-3117">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="7593b-3118">如果实现方法为 `null`：</span><span class="sxs-lookup"><span data-stu-id="7593b-3118">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="7593b-3119">`left`。键入并 `right`。类型是相同的布尔类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-3119">`left`.Type and `right`.Type are the same Boolean type.</span></span>  
  
-   <span data-ttu-id="7593b-3120">如果 `left`。键入并 `right`。类型不可为 null，则不提升节点。</span><span class="sxs-lookup"><span data-stu-id="7593b-3120">If `left`.Type and `right`.Type are non-nullable, the node is not lifted.</span></span> <span data-ttu-id="7593b-3121">节点的类型是预定义的条件 `OR` 运算符的结果类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-3121">The type of the node is the result type of the predefined conditional `OR` operator.</span></span>  
  
-   <span data-ttu-id="7593b-3122">如果 `left`。键入并 `right`。类型可以为 null，则提升节点。</span><span class="sxs-lookup"><span data-stu-id="7593b-3122">If `left`.Type and `right`.Type are nullable, the node is lifted.</span></span> <span data-ttu-id="7593b-3123">节点的类型是与预定义条件 `OR` 运算符的结果类型对应的可以为 null 的类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-3123">The type of the node is the nullable type that corresponds to the result type of the predefined conditional `OR` operator.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="7593b-3124"><paramref name="left" /> 或 <paramref name="right" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-3124"><paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="7593b-3125"><paramref name="method" /> 不是 <see langword="null" />，它所表示的方法返回 <see langword="void" />，而不是 <see langword="static" />（Visual Basic 中为 <see langword="Shared" />），或者并非采用两个参数。</span><span class="sxs-lookup"><span data-stu-id="7593b-3125"><paramref name="method" /> is not <see langword="null" /> and the method it represents returns <see langword="void" />, is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic), or does not take exactly two arguments.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="7593b-3126"><paramref name="method" /> 是 <see langword="null" />，且没有为 <see langword="OR" />.Type 和 <paramref name="left" />.Type 定义按位 <paramref name="right" /> 运算符。</span><span class="sxs-lookup"><span data-stu-id="7593b-3126"><paramref name="method" /> is <see langword="null" /> and the bitwise <see langword="OR" /> operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span></span>  
  
<span data-ttu-id="7593b-3127">- 或 -</span><span class="sxs-lookup"><span data-stu-id="7593b-3127">-or-</span></span> 
 <span data-ttu-id="7593b-3128"><paramref name="method" /> 为 <see langword="null" /> 并且 <paramref name="left" />.Type 和 <paramref name="right" />.Type 不是同一布尔值类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-3128"><paramref name="method" /> is <see langword="null" /> and <paramref name="left" />.Type and <paramref name="right" />.Type are not the same Boolean type.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Parameter">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="7593b-3129">创建一个 <see cref="T:System.Linq.Expressions.ParameterExpression" /> 节点，该节点可用于标识表达式树中的参数或变量。</span><span class="sxs-lookup"><span data-stu-id="7593b-3129">Creates a <see cref="T:System.Linq.Expressions.ParameterExpression" /> node that can be used to identify a parameter or a variable in an expression tree.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Parameter">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ParameterExpression Parameter (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ParameterExpression Parameter(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Parameter(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::ParameterExpression ^ Parameter(Type ^ type);" />
      <MemberSignature Language="F#" Value="static member Parameter : Type -&gt; System.Linq.Expressions.ParameterExpression" Usage="System.Linq.Expressions.Expression.Parameter type" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ParameterExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="type"><span data-ttu-id="7593b-3130">参数或变量的类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-3130">The type of the parameter or variable.</span></span></param>
        <summary><span data-ttu-id="7593b-3131">创建一个 <see cref="T:System.Linq.Expressions.ParameterExpression" /> 节点，该节点可用于标识表达式树中的参数或变量。</span><span class="sxs-lookup"><span data-stu-id="7593b-3131">Creates a <see cref="T:System.Linq.Expressions.ParameterExpression" /> node that can be used to identify a parameter or a variable in an expression tree.</span></span></summary>
        <returns><span data-ttu-id="7593b-3132">具有指定的名称和类型的 <see cref="T:System.Linq.Expressions.ParameterExpression" /> 节点。</span><span class="sxs-lookup"><span data-stu-id="7593b-3132">A <see cref="T:System.Linq.Expressions.ParameterExpression" /> node with the specified name and type.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="7593b-3133">下面的示例演示如何创建一个 <xref:System.Linq.Expressions.MethodCallExpression> 对象，该对象输出 <xref:System.Linq.Expressions.ParameterExpression> 对象的值。</span><span class="sxs-lookup"><span data-stu-id="7593b-3133">The following example demonstrates how to create a <xref:System.Linq.Expressions.MethodCallExpression> object that prints the value of a <xref:System.Linq.Expressions.ParameterExpression> object.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#49](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#49)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#49](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#49)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Parameter">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ParameterExpression Parameter (Type type, string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ParameterExpression Parameter(class System.Type type, string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Parameter(System.Type,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::ParameterExpression ^ Parameter(Type ^ type, System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member Parameter : Type * string -&gt; System.Linq.Expressions.ParameterExpression" Usage="System.Linq.Expressions.Expression.Parameter (type, name)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ParameterExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type"><span data-ttu-id="7593b-3134">参数或变量的类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-3134">The type of the parameter or variable.</span></span></param>
        <param name="name"><span data-ttu-id="7593b-3135">仅用于调试或打印目的的参数或变量的名称。</span><span class="sxs-lookup"><span data-stu-id="7593b-3135">The name of the parameter or variable, used for debugging or printing purpose only.</span></span></param>
        <summary><span data-ttu-id="7593b-3136">创建一个 <see cref="T:System.Linq.Expressions.ParameterExpression" /> 节点，该节点可用于标识表达式树中的参数或变量。</span><span class="sxs-lookup"><span data-stu-id="7593b-3136">Creates a <see cref="T:System.Linq.Expressions.ParameterExpression" /> node that can be used to identify a parameter or a variable in an expression tree.</span></span></summary>
        <returns><span data-ttu-id="7593b-3137">一个 <see cref="T:System.Linq.Expressions.ParameterExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 属性等于 <see cref="F:System.Linq.Expressions.ExpressionType.Parameter" />，并且其 <see cref="P:System.Linq.Expressions.Expression.Type" /> 和 <see cref="P:System.Linq.Expressions.ParameterExpression.Name" /> 属性设置为指定值。</span><span class="sxs-lookup"><span data-stu-id="7593b-3137">A <see cref="T:System.Linq.Expressions.ParameterExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Parameter" /> and the <see cref="P:System.Linq.Expressions.Expression.Type" /> and <see cref="P:System.Linq.Expressions.ParameterExpression.Name" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="7593b-3138"><paramref name="type" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-3138"><paramref name="type" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="PostDecrementAssign">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="7593b-3139">创建一个 <see cref="T:System.Linq.Expressions.UnaryExpression" />，它表示将原始表达式递减 1 之后再进行表达式赋值。</span><span class="sxs-lookup"><span data-stu-id="7593b-3139">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents the assignment of the expression followed by a subsequent decrement by 1 of the original expression.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="PostDecrementAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression PostDecrementAssign (System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression PostDecrementAssign(class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.PostDecrementAssign(System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ PostDecrementAssign(System::Linq::Expressions::Expression ^ expression);" />
      <MemberSignature Language="F#" Value="static member PostDecrementAssign : System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.PostDecrementAssign expression" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="expression"><span data-ttu-id="7593b-3140">要进行运算的 <see cref="T:System.Linq.Expressions.Expression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-3140">An <see cref="T:System.Linq.Expressions.Expression" /> to apply the operations on.</span></span></param>
        <summary><span data-ttu-id="7593b-3141">创建一个 <see cref="T:System.Linq.Expressions.UnaryExpression" />，它表示将原始表达式递减 1 之后再进行表达式赋值。</span><span class="sxs-lookup"><span data-stu-id="7593b-3141">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents the assignment of the expression followed by a subsequent decrement by 1 of the original expression.</span></span></summary>
        <returns><span data-ttu-id="7593b-3142">一个表示结果表达式的 <see cref="T:System.Linq.Expressions.UnaryExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-3142">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents the resultant expression.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PostDecrementAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression PostDecrementAssign (System.Linq.Expressions.Expression expression, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression PostDecrementAssign(class System.Linq.Expressions.Expression expression, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.PostDecrementAssign(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ PostDecrementAssign(System::Linq::Expressions::Expression ^ expression, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member PostDecrementAssign : System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.PostDecrementAssign (expression, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="expression"><span data-ttu-id="7593b-3143">要进行运算的 <see cref="T:System.Linq.Expressions.Expression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-3143">An <see cref="T:System.Linq.Expressions.Expression" /> to apply the operations on.</span></span></param>
        <param name="method"><span data-ttu-id="7593b-3144">表示实现方法的 <see cref="T:System.Reflection.MethodInfo" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-3144">A <see cref="T:System.Reflection.MethodInfo" /> that represents the implementing method.</span></span></param>
        <summary><span data-ttu-id="7593b-3145">创建一个 <see cref="T:System.Linq.Expressions.UnaryExpression" />，它表示将原始表达式递减 1 之后再进行表达式赋值。</span><span class="sxs-lookup"><span data-stu-id="7593b-3145">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents the assignment of the expression followed by a subsequent decrement by 1 of the original expression.</span></span></summary>
        <returns><span data-ttu-id="7593b-3146">一个表示结果表达式的 <see cref="T:System.Linq.Expressions.UnaryExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-3146">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents the resultant expression.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="PostIncrementAssign">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="7593b-3147">创建一个 <see cref="T:System.Linq.Expressions.UnaryExpression" />，它表示将原始表达式递增 1 之后再进行表达式赋值。</span><span class="sxs-lookup"><span data-stu-id="7593b-3147">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents the assignment of the expression followed by a subsequent increment by 1 of the original expression.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="PostIncrementAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression PostIncrementAssign (System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression PostIncrementAssign(class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.PostIncrementAssign(System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ PostIncrementAssign(System::Linq::Expressions::Expression ^ expression);" />
      <MemberSignature Language="F#" Value="static member PostIncrementAssign : System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.PostIncrementAssign expression" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="expression"><span data-ttu-id="7593b-3148">要进行运算的 <see cref="T:System.Linq.Expressions.Expression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-3148">An <see cref="T:System.Linq.Expressions.Expression" /> to apply the operations on.</span></span></param>
        <summary><span data-ttu-id="7593b-3149">创建一个 <see cref="T:System.Linq.Expressions.UnaryExpression" />，它表示将原始表达式递增 1 之后再进行表达式赋值。</span><span class="sxs-lookup"><span data-stu-id="7593b-3149">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents the assignment of the expression followed by a subsequent increment by 1 of the original expression.</span></span></summary>
        <returns><span data-ttu-id="7593b-3150">一个表示结果表达式的 <see cref="T:System.Linq.Expressions.UnaryExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-3150">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents the resultant expression.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PostIncrementAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression PostIncrementAssign (System.Linq.Expressions.Expression expression, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression PostIncrementAssign(class System.Linq.Expressions.Expression expression, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.PostIncrementAssign(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ PostIncrementAssign(System::Linq::Expressions::Expression ^ expression, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member PostIncrementAssign : System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.PostIncrementAssign (expression, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="expression"><span data-ttu-id="7593b-3151">要进行运算的 <see cref="T:System.Linq.Expressions.Expression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-3151">An <see cref="T:System.Linq.Expressions.Expression" /> to apply the operations on.</span></span></param>
        <param name="method"><span data-ttu-id="7593b-3152">表示实现方法的 <see cref="T:System.Reflection.MethodInfo" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-3152">A <see cref="T:System.Reflection.MethodInfo" /> that represents the implementing method.</span></span></param>
        <summary><span data-ttu-id="7593b-3153">创建一个 <see cref="T:System.Linq.Expressions.UnaryExpression" />，它表示将原始表达式递增 1 之后再进行表达式赋值。</span><span class="sxs-lookup"><span data-stu-id="7593b-3153">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents the assignment of the expression followed by a subsequent increment by 1 of the original expression.</span></span></summary>
        <returns><span data-ttu-id="7593b-3154">一个表示结果表达式的 <see cref="T:System.Linq.Expressions.UnaryExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-3154">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents the resultant expression.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Power">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="7593b-3155">创建一个表示对数进行幂运算的 <see cref="T:System.Linq.Expressions.BinaryExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-3155">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents raising a number to a power.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Power">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Power (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Power(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Power(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Power (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Power(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member Power : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.Power (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="7593b-3156">要将 <see cref="T:System.Linq.Expressions.Expression" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-3156">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="7593b-3157">要将 <see cref="T:System.Linq.Expressions.Expression" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-3157">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="7593b-3158">创建一个表示对数进行幂运算的 <see cref="T:System.Linq.Expressions.BinaryExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-3158">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents raising a number to a power.</span></span></summary>
        <returns><span data-ttu-id="7593b-3159">一个 <see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 属性等于 <see cref="F:System.Linq.Expressions.ExpressionType.Power" />，并且其 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 属性设置为指定值。</span><span class="sxs-lookup"><span data-stu-id="7593b-3159">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Power" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7593b-3160">生成的 <xref:System.Linq.Expressions.BinaryExpression> 具有设置为实现方法的 <xref:System.Linq.Expressions.BinaryExpression.Method%2A> 属性。</span><span class="sxs-lookup"><span data-stu-id="7593b-3160">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="7593b-3161"><xref:System.Linq.Expressions.Expression.Type%2A> 属性设置为节点的类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-3161">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="7593b-3162">如果节点已提升，则 <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> 和 <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> 属性均 `true`。</span><span class="sxs-lookup"><span data-stu-id="7593b-3162">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="7593b-3163">否则，它们 `false`。</span><span class="sxs-lookup"><span data-stu-id="7593b-3163">Otherwise, they are `false`.</span></span> <span data-ttu-id="7593b-3164"><xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> 属性为 `null`。</span><span class="sxs-lookup"><span data-stu-id="7593b-3164">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="7593b-3165">以下信息描述了实现方法、节点类型以及节点是否已提升。</span><span class="sxs-lookup"><span data-stu-id="7593b-3165">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="7593b-3166">实现方法</span><span class="sxs-lookup"><span data-stu-id="7593b-3166">Implementing Method</span></span>  
 <span data-ttu-id="7593b-3167">以下规则确定操作的实现方法：</span><span class="sxs-lookup"><span data-stu-id="7593b-3167">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="7593b-3168">如果 `left` 或 `right` 的 <xref:System.Linq.Expressions.Expression.Type%2A> 属性表示重载幂运算符的用户定义类型，则表示该方法的 <xref:System.Reflection.MethodInfo> 是实现方法。</span><span class="sxs-lookup"><span data-stu-id="7593b-3168">If the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the exponentiation operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="7593b-3169">否则，如果 `left`。键入并 `right`。类型均 <xref:System.Double>，则实现方法 <xref:System.Math.Pow%2A>。</span><span class="sxs-lookup"><span data-stu-id="7593b-3169">Otherwise, if `left`.Type and `right`.Type are both <xref:System.Double>, the implementing method is <xref:System.Math.Pow%2A>.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="7593b-3170">节点类型和提升和非提升</span><span class="sxs-lookup"><span data-stu-id="7593b-3170">Node Type and Lifted versus Non-Lifted</span></span>  
  
-   <span data-ttu-id="7593b-3171">如果 `left`。键入并 `right`。类型可分配给实现方法的相应参数类型，不提升节点。</span><span class="sxs-lookup"><span data-stu-id="7593b-3171">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="7593b-3172">节点的类型是实现方法的返回类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-3172">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="7593b-3173">如果满足以下两个条件，则会提升节点，并且该节点的类型为与实现方法的返回类型对应的可以为 null 的类型：</span><span class="sxs-lookup"><span data-stu-id="7593b-3173">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="7593b-3174">`left`。键入并 `right`。类型既是值类型，其中至少有一个可为 null，并且相应的不可为 null 的类型等于实现方法的相应参数类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-3174">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="7593b-3175">实现方法的返回类型是不可为 null 的值类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-3175">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="7593b-3176"><paramref name="left" /> 或 <paramref name="right" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-3176"><paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="7593b-3177">没有为 <paramref name="left" />.Type 和 <paramref name="right" />.Type 定义幂运算符。</span><span class="sxs-lookup"><span data-stu-id="7593b-3177">The exponentiation operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span></span>  
  
<span data-ttu-id="7593b-3178">- 或 -</span><span class="sxs-lookup"><span data-stu-id="7593b-3178">-or-</span></span> 
 <span data-ttu-id="7593b-3179"><paramref name="left" />.Type 和/或 <paramref name="right" />.Type 不是 <see cref="T:System.Double" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-3179"><paramref name="left" />.Type and/or <paramref name="right" />.Type are not <see cref="T:System.Double" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Power">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Power (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Power(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Power(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Power (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Power(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member Power : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.Power (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="7593b-3180">要将 <see cref="T:System.Linq.Expressions.Expression" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-3180">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="7593b-3181">要将 <see cref="T:System.Linq.Expressions.Expression" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-3181">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <param name="method"><span data-ttu-id="7593b-3182">要将 <see cref="T:System.Reflection.MethodInfo" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-3182">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="7593b-3183">创建一个表示对数进行幂运算的 <see cref="T:System.Linq.Expressions.BinaryExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-3183">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents raising a number to a power.</span></span></summary>
        <returns><span data-ttu-id="7593b-3184">一个 <see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 属性等于 <see cref="F:System.Linq.Expressions.ExpressionType.Power" />，并且其 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />、<see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> 属性设置为指定值。</span><span class="sxs-lookup"><span data-stu-id="7593b-3184">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Power" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7593b-3185">生成的 <xref:System.Linq.Expressions.BinaryExpression> 具有设置为实现方法的 <xref:System.Linq.Expressions.BinaryExpression.Method%2A> 属性。</span><span class="sxs-lookup"><span data-stu-id="7593b-3185">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="7593b-3186"><xref:System.Linq.Expressions.Expression.Type%2A> 属性设置为节点的类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-3186">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="7593b-3187">如果节点已提升，则 <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> 和 <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> 属性均 `true`。</span><span class="sxs-lookup"><span data-stu-id="7593b-3187">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="7593b-3188">否则，它们 `false`。</span><span class="sxs-lookup"><span data-stu-id="7593b-3188">Otherwise, they are `false`.</span></span> <span data-ttu-id="7593b-3189"><xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> 属性为 `null`。</span><span class="sxs-lookup"><span data-stu-id="7593b-3189">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="7593b-3190">以下信息描述了实现方法、节点类型以及节点是否已提升。</span><span class="sxs-lookup"><span data-stu-id="7593b-3190">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="7593b-3191">实现方法</span><span class="sxs-lookup"><span data-stu-id="7593b-3191">Implementing Method</span></span>  
 <span data-ttu-id="7593b-3192">以下规则确定操作的实现方法：</span><span class="sxs-lookup"><span data-stu-id="7593b-3192">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="7593b-3193">如果 `method` 未 `null` 并且它表示采用两个自变量的非 void、`static``Shared` （Visual Basic）方法，则它是实现方法。</span><span class="sxs-lookup"><span data-stu-id="7593b-3193">If `method` is not `null` and it represents a non-void, `static` (`Shared` in Visual Basic) method that takes two arguments, it is the implementing method.</span></span>  
  
-   <span data-ttu-id="7593b-3194">否则，如果 `left` 或 `right` 的 <xref:System.Linq.Expressions.Expression.Type%2A> 属性表示重载求幂运算符的用户定义类型，则表示该方法的 <xref:System.Reflection.MethodInfo> 是实现方法。</span><span class="sxs-lookup"><span data-stu-id="7593b-3194">Otherwise, if the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the exponentiation operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="7593b-3195">否则，如果 `left`。键入并 `right`。类型均 <xref:System.Double>，则实现方法 <xref:System.Math.Pow%2A>。</span><span class="sxs-lookup"><span data-stu-id="7593b-3195">Otherwise, if `left`.Type and `right`.Type are both <xref:System.Double>, the implementing method is <xref:System.Math.Pow%2A>.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="7593b-3196">节点类型和提升和非提升</span><span class="sxs-lookup"><span data-stu-id="7593b-3196">Node Type and Lifted versus Non-Lifted</span></span>  
  
-   <span data-ttu-id="7593b-3197">如果 `left`。键入并 `right`。类型可分配给实现方法的相应参数类型，不提升节点。</span><span class="sxs-lookup"><span data-stu-id="7593b-3197">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="7593b-3198">节点的类型是实现方法的返回类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-3198">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="7593b-3199">如果满足以下两个条件，则会提升节点，并且该节点的类型为与实现方法的返回类型对应的可以为 null 的类型：</span><span class="sxs-lookup"><span data-stu-id="7593b-3199">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="7593b-3200">`left`。键入并 `right`。类型既是值类型，其中至少有一个可为 null，并且相应的不可为 null 的类型等于实现方法的相应参数类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-3200">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="7593b-3201">实现方法的返回类型是不可为 null 的值类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-3201">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="7593b-3202"><paramref name="left" /> 或 <paramref name="right" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-3202"><paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="7593b-3203"><paramref name="method" /> 不是 <see langword="null" />，它所表示的方法返回 <see langword="void" />，而不是 <see langword="static" />（Visual Basic 中为 <see langword="Shared" />），或者并非采用两个参数。</span><span class="sxs-lookup"><span data-stu-id="7593b-3203"><paramref name="method" /> is not <see langword="null" /> and the method it represents returns <see langword="void" />, is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic), or does not take exactly two arguments.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="7593b-3204"><paramref name="method" /> 是 <see langword="null" />，且没有为 <paramref name="left" />.Type 和 <paramref name="right" />.Type 定义幂运算符。</span><span class="sxs-lookup"><span data-stu-id="7593b-3204"><paramref name="method" /> is <see langword="null" /> and the exponentiation operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span></span>  
  
<span data-ttu-id="7593b-3205">- 或 -</span><span class="sxs-lookup"><span data-stu-id="7593b-3205">-or-</span></span> 
 <span data-ttu-id="7593b-3206"><paramref name="method" /> 是 <see langword="null" />，且 <paramref name="left" />.Type 和/或 <paramref name="right" />.Type 不是 <see cref="T:System.Double" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-3206"><paramref name="method" /> is <see langword="null" /> and <paramref name="left" />.Type and/or <paramref name="right" />.Type are not <see cref="T:System.Double" />.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="PowerAssign">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="7593b-3207">创建一个 <see cref="T:System.Linq.Expressions.BinaryExpression" />，它表示对表达式求幂并将结果赋回给表达式。</span><span class="sxs-lookup"><span data-stu-id="7593b-3207">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents raising an expression to a power and assigning the result back to the expression.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="PowerAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression PowerAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression PowerAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.PowerAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function PowerAssign (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ PowerAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member PowerAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.PowerAssign (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="7593b-3208">要将 <see cref="T:System.Linq.Expressions.Expression" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-3208">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="7593b-3209">要将 <see cref="T:System.Linq.Expressions.Expression" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-3209">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="7593b-3210">创建一个 <see cref="T:System.Linq.Expressions.BinaryExpression" />，它表示对表达式求幂并将结果赋回给表达式。</span><span class="sxs-lookup"><span data-stu-id="7593b-3210">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents raising an expression to a power and assigning the result back to the expression.</span></span></summary>
        <returns><span data-ttu-id="7593b-3211">一个 <see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 属性等于 <see cref="F:System.Linq.Expressions.ExpressionType.PowerAssign" />，并且其 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 属性设置为指定值。</span><span class="sxs-lookup"><span data-stu-id="7593b-3211">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.PowerAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PowerAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression PowerAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression PowerAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.PowerAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function PowerAssign (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ PowerAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member PowerAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.PowerAssign (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="7593b-3212">要将 <see cref="T:System.Linq.Expressions.Expression" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-3212">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="7593b-3213">要将 <see cref="T:System.Linq.Expressions.Expression" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-3213">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <param name="method"><span data-ttu-id="7593b-3214">要将 <see cref="T:System.Reflection.MethodInfo" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-3214">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="7593b-3215">创建一个 <see cref="T:System.Linq.Expressions.BinaryExpression" />，它表示对表达式求幂并将结果赋回给表达式。</span><span class="sxs-lookup"><span data-stu-id="7593b-3215">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents raising an expression to a power and assigning the result back to the expression.</span></span></summary>
        <returns><span data-ttu-id="7593b-3216">一个 <see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 属性等于 <see cref="F:System.Linq.Expressions.ExpressionType.PowerAssign" />，并且其 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />、<see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> 属性设置为指定值。</span><span class="sxs-lookup"><span data-stu-id="7593b-3216">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.PowerAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PowerAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression PowerAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method, System.Linq.Expressions.LambdaExpression conversion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression PowerAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method, class System.Linq.Expressions.LambdaExpression conversion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.PowerAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function PowerAssign (left As Expression, right As Expression, method As MethodInfo, conversion As LambdaExpression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ PowerAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method, System::Linq::Expressions::LambdaExpression ^ conversion);" />
      <MemberSignature Language="F#" Value="static member PowerAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo * System.Linq.Expressions.LambdaExpression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.PowerAssign (left, right, method, conversion)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="conversion" Type="System.Linq.Expressions.LambdaExpression" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="7593b-3217">要将 <see cref="T:System.Linq.Expressions.Expression" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-3217">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="7593b-3218">要将 <see cref="T:System.Linq.Expressions.Expression" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-3218">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <param name="method"><span data-ttu-id="7593b-3219">要将 <see cref="T:System.Reflection.MethodInfo" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-3219">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span></span></param>
        <param name="conversion"><span data-ttu-id="7593b-3220">要将 <see cref="T:System.Linq.Expressions.LambdaExpression" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-3220">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="7593b-3221">创建一个 <see cref="T:System.Linq.Expressions.BinaryExpression" />，它表示对表达式求幂并将结果赋回给表达式。</span><span class="sxs-lookup"><span data-stu-id="7593b-3221">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents raising an expression to a power and assigning the result back to the expression.</span></span></summary>
        <returns><span data-ttu-id="7593b-3222">一个 <see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 属性等于 <see cref="F:System.Linq.Expressions.ExpressionType.PowerAssign" />，并且其 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />、<see cref="P:System.Linq.Expressions.BinaryExpression.Right" />、<see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> 属性设置为指定值。</span><span class="sxs-lookup"><span data-stu-id="7593b-3222">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.PowerAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="PreDecrementAssign">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="7593b-3223">创建一个 <see cref="T:System.Linq.Expressions.UnaryExpression" />，它将表达式递减 1 并将结果赋回给表达式。</span><span class="sxs-lookup"><span data-stu-id="7593b-3223">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that decrements the expression by 1 and assigns the result back to the expression.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="PreDecrementAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression PreDecrementAssign (System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression PreDecrementAssign(class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.PreDecrementAssign(System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ PreDecrementAssign(System::Linq::Expressions::Expression ^ expression);" />
      <MemberSignature Language="F#" Value="static member PreDecrementAssign : System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.PreDecrementAssign expression" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="expression"><span data-ttu-id="7593b-3224">要进行运算的 <see cref="T:System.Linq.Expressions.Expression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-3224">An <see cref="T:System.Linq.Expressions.Expression" /> to apply the operations on.</span></span></param>
        <summary><span data-ttu-id="7593b-3225">创建一个 <see cref="T:System.Linq.Expressions.UnaryExpression" />，它将表达式递减 1 并将结果赋回给表达式。</span><span class="sxs-lookup"><span data-stu-id="7593b-3225">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that decrements the expression by 1 and assigns the result back to the expression.</span></span></summary>
        <returns><span data-ttu-id="7593b-3226">一个表示结果表达式的 <see cref="T:System.Linq.Expressions.UnaryExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-3226">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents the resultant expression.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PreDecrementAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression PreDecrementAssign (System.Linq.Expressions.Expression expression, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression PreDecrementAssign(class System.Linq.Expressions.Expression expression, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.PreDecrementAssign(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ PreDecrementAssign(System::Linq::Expressions::Expression ^ expression, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member PreDecrementAssign : System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.PreDecrementAssign (expression, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="expression"><span data-ttu-id="7593b-3227">要进行运算的 <see cref="T:System.Linq.Expressions.Expression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-3227">An <see cref="T:System.Linq.Expressions.Expression" /> to apply the operations on.</span></span></param>
        <param name="method"><span data-ttu-id="7593b-3228">表示实现方法的 <see cref="T:System.Reflection.MethodInfo" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-3228">A <see cref="T:System.Reflection.MethodInfo" /> that represents the implementing method.</span></span></param>
        <summary><span data-ttu-id="7593b-3229">创建一个 <see cref="T:System.Linq.Expressions.UnaryExpression" />，它将表达式递减 1 并将结果赋回给表达式。</span><span class="sxs-lookup"><span data-stu-id="7593b-3229">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that decrements the expression by 1 and assigns the result back to the expression.</span></span></summary>
        <returns><span data-ttu-id="7593b-3230">一个表示结果表达式的 <see cref="T:System.Linq.Expressions.UnaryExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-3230">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents the resultant expression.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="PreIncrementAssign">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="7593b-3231">创建一个 <see cref="T:System.Linq.Expressions.UnaryExpression" />，它将表达式递增 1 并将结果赋回给表达式。</span><span class="sxs-lookup"><span data-stu-id="7593b-3231">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that increments the expression by 1 and assigns the result back to the expression.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="PreIncrementAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression PreIncrementAssign (System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression PreIncrementAssign(class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.PreIncrementAssign(System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ PreIncrementAssign(System::Linq::Expressions::Expression ^ expression);" />
      <MemberSignature Language="F#" Value="static member PreIncrementAssign : System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.PreIncrementAssign expression" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="expression"><span data-ttu-id="7593b-3232">要进行运算的 <see cref="T:System.Linq.Expressions.Expression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-3232">An <see cref="T:System.Linq.Expressions.Expression" /> to apply the operations on.</span></span></param>
        <summary><span data-ttu-id="7593b-3233">创建一个 <see cref="T:System.Linq.Expressions.UnaryExpression" />，它将表达式递增 1 并将结果赋回给表达式。</span><span class="sxs-lookup"><span data-stu-id="7593b-3233">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that increments the expression by 1 and assigns the result back to the expression.</span></span></summary>
        <returns><span data-ttu-id="7593b-3234">一个表示结果表达式的 <see cref="T:System.Linq.Expressions.UnaryExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-3234">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents the resultant expression.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PreIncrementAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression PreIncrementAssign (System.Linq.Expressions.Expression expression, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression PreIncrementAssign(class System.Linq.Expressions.Expression expression, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.PreIncrementAssign(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ PreIncrementAssign(System::Linq::Expressions::Expression ^ expression, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member PreIncrementAssign : System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.PreIncrementAssign (expression, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="expression"><span data-ttu-id="7593b-3235">要进行运算的 <see cref="T:System.Linq.Expressions.Expression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-3235">An <see cref="T:System.Linq.Expressions.Expression" /> to apply the operations on.</span></span></param>
        <param name="method"><span data-ttu-id="7593b-3236">表示实现方法的 <see cref="T:System.Reflection.MethodInfo" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-3236">A <see cref="T:System.Reflection.MethodInfo" /> that represents the implementing method.</span></span></param>
        <summary><span data-ttu-id="7593b-3237">创建一个 <see cref="T:System.Linq.Expressions.UnaryExpression" />，它将表达式递增 1 并将结果赋回给表达式。</span><span class="sxs-lookup"><span data-stu-id="7593b-3237">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that increments the expression by 1 and assigns the result back to the expression.</span></span></summary>
        <returns><span data-ttu-id="7593b-3238">一个表示结果表达式的 <see cref="T:System.Linq.Expressions.UnaryExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-3238">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents the resultant expression.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Property">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="7593b-3239">创建一个表示访问属性的 <see cref="T:System.Linq.Expressions.MemberExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-3239">Creates a <see cref="T:System.Linq.Expressions.MemberExpression" /> that represents accessing a property.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Property">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberExpression Property (System.Linq.Expressions.Expression expression, System.Reflection.MethodInfo propertyAccessor);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberExpression Property(class System.Linq.Expressions.Expression expression, class System.Reflection.MethodInfo propertyAccessor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberExpression ^ Property(System::Linq::Expressions::Expression ^ expression, System::Reflection::MethodInfo ^ propertyAccessor);" />
      <MemberSignature Language="F#" Value="static member Property : System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.MemberExpression" Usage="System.Linq.Expressions.Expression.Property (expression, propertyAccessor)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="propertyAccessor" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="expression"><span data-ttu-id="7593b-3240">要将 <see cref="T:System.Linq.Expressions.Expression" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.MemberExpression.Expression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-3240">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> property equal to.</span></span> <span data-ttu-id="7593b-3241">对于静态属性，这可以为 null。</span><span class="sxs-lookup"><span data-stu-id="7593b-3241">This can be null for static properties.</span></span></param>
        <param name="propertyAccessor"><span data-ttu-id="7593b-3242">表示属性访问器方法的 <see cref="T:System.Reflection.MethodInfo" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-3242">The <see cref="T:System.Reflection.MethodInfo" /> that represents a property accessor method.</span></span></param>
        <summary><span data-ttu-id="7593b-3243">使用属性访问器方法创建一个表示访问属性的 <see cref="T:System.Linq.Expressions.MemberExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-3243">Creates a <see cref="T:System.Linq.Expressions.MemberExpression" /> that represents accessing a property by using a property accessor method.</span></span></summary>
        <returns><span data-ttu-id="7593b-3244">一个 <see cref="T:System.Linq.Expressions.MemberExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 属性等于 <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" />，<see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> 属性设置为 <paramref name="expression" />，并且 <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> 属性设置为表示在 <see cref="T:System.Reflection.PropertyInfo" /> 中访问的属性的 <paramref name="propertyAccessor" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-3244">A <see cref="T:System.Linq.Expressions.MemberExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" />, the <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> property set to <paramref name="expression" /> and the <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> property set to the <see cref="T:System.Reflection.PropertyInfo" /> that represents the property accessed in <paramref name="propertyAccessor" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7593b-3245">生成的 <xref:System.Linq.Expressions.MemberExpression> 的 <xref:System.Linq.Expressions.Expression.Type%2A> 属性等于 <xref:System.Linq.Expressions.MemberExpression.Member%2A>的 <xref:System.Reflection.PropertyInfo.PropertyType%2A> 属性。</span><span class="sxs-lookup"><span data-stu-id="7593b-3245">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.MemberExpression> is equal to the <xref:System.Reflection.PropertyInfo.PropertyType%2A> property of <xref:System.Linq.Expressions.MemberExpression.Member%2A>.</span></span>  
  
 <span data-ttu-id="7593b-3246">如果 `propertyAccessor` 所表示的方法 `static` （`Shared` Visual Basic），则可以 `expression` `null`。</span><span class="sxs-lookup"><span data-stu-id="7593b-3246">If the method represented by `propertyAccessor` is `static` (`Shared` in Visual Basic), `expression` can be `null`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="7593b-3247"><paramref name="propertyAccessor" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-3247"><paramref name="propertyAccessor" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="7593b-3248">- 或 -</span><span class="sxs-lookup"><span data-stu-id="7593b-3248">-or-</span></span> 
<span data-ttu-id="7593b-3249"><paramref name="propertyAccessor" /> 所表示的方法不为 <see langword="static" />（在 Visual Basic 中为 <see langword="Shared" />），并且 <paramref name="expression" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-3249">The method that <paramref name="propertyAccessor" /> represents is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic) and <paramref name="expression" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="7593b-3250"><paramref name="expression" />.Type 不可分配给由 <paramref name="propertyAccessor" /> 表示的方法声明类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-3250"><paramref name="expression" />.Type is not assignable to the declaring type of the method represented by <paramref name="propertyAccessor" />.</span></span>  
  
<span data-ttu-id="7593b-3251">- 或 -</span><span class="sxs-lookup"><span data-stu-id="7593b-3251">-or-</span></span> 
<span data-ttu-id="7593b-3252"><paramref name="propertyAccessor" /> 所表示的方法不为属性访问器方法。</span><span class="sxs-lookup"><span data-stu-id="7593b-3252">The method that <paramref name="propertyAccessor" /> represents is not a property accessor method.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Property">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberExpression Property (System.Linq.Expressions.Expression expression, System.Reflection.PropertyInfo property);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberExpression Property(class System.Linq.Expressions.Expression expression, class System.Reflection.PropertyInfo property) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression,System.Reflection.PropertyInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberExpression ^ Property(System::Linq::Expressions::Expression ^ expression, System::Reflection::PropertyInfo ^ property);" />
      <MemberSignature Language="F#" Value="static member Property : System.Linq.Expressions.Expression * System.Reflection.PropertyInfo -&gt; System.Linq.Expressions.MemberExpression" Usage="System.Linq.Expressions.Expression.Property (expression, property)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="property" Type="System.Reflection.PropertyInfo" />
      </Parameters>
      <Docs>
        <param name="expression"><span data-ttu-id="7593b-3253">要将 <see cref="T:System.Linq.Expressions.Expression" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.MemberExpression.Expression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-3253">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> property equal to.</span></span> <span data-ttu-id="7593b-3254">对于静态属性，这可以为 null。</span><span class="sxs-lookup"><span data-stu-id="7593b-3254">This can be null for static properties.</span></span></param>
        <param name="property"><span data-ttu-id="7593b-3255">要将 <see cref="T:System.Reflection.PropertyInfo" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.MemberExpression.Member" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-3255">The <see cref="T:System.Reflection.PropertyInfo" /> to set the <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="7593b-3256">创建一个表示访问属性的 <see cref="T:System.Linq.Expressions.MemberExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-3256">Creates a <see cref="T:System.Linq.Expressions.MemberExpression" /> that represents accessing a property.</span></span></summary>
        <returns><span data-ttu-id="7593b-3257">一个 <see cref="T:System.Linq.Expressions.MemberExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 属性等于 <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" />，并且其 <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> 和 <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> 属性设置为指定值。</span><span class="sxs-lookup"><span data-stu-id="7593b-3257">A <see cref="T:System.Linq.Expressions.MemberExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" /> and the <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> and <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7593b-3258">生成的 <xref:System.Linq.Expressions.MemberExpression> 的 <xref:System.Linq.Expressions.Expression.Type%2A> 属性等于 <xref:System.Linq.Expressions.MemberExpression.Member%2A>的 <xref:System.Reflection.PropertyInfo.PropertyType%2A> 属性。</span><span class="sxs-lookup"><span data-stu-id="7593b-3258">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.MemberExpression> is equal to the <xref:System.Reflection.PropertyInfo.PropertyType%2A> property of <xref:System.Linq.Expressions.MemberExpression.Member%2A>.</span></span>  
  
 <span data-ttu-id="7593b-3259">如果 `property` 所表示的属性为 `static` （`Shared` Visual Basic），则可以 `expression` `null`。</span><span class="sxs-lookup"><span data-stu-id="7593b-3259">If the property represented by `property` is `static` (`Shared` in Visual Basic), `expression` can be `null`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="7593b-3260"><paramref name="property" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-3260"><paramref name="property" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="7593b-3261">- 或 -</span><span class="sxs-lookup"><span data-stu-id="7593b-3261">-or-</span></span> 
<span data-ttu-id="7593b-3262"><paramref name="property" /> 所表示的属性不为 <see langword="static" />（在 Visual Basic 中为 <see langword="Shared" />），并且 <paramref name="expression" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-3262">The property that <paramref name="property" /> represents is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic) and <paramref name="expression" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="7593b-3263"><paramref name="expression" />.Type 不能赋给 <paramref name="property" /> 所表示的属性的声明类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-3263"><paramref name="expression" />.Type is not assignable to the declaring type of the property that <paramref name="property" /> represents.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Property">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberExpression Property (System.Linq.Expressions.Expression expression, string propertyName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberExpression Property(class System.Linq.Expressions.Expression expression, string propertyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberExpression ^ Property(System::Linq::Expressions::Expression ^ expression, System::String ^ propertyName);" />
      <MemberSignature Language="F#" Value="static member Property : System.Linq.Expressions.Expression * string -&gt; System.Linq.Expressions.MemberExpression" Usage="System.Linq.Expressions.Expression.Property (expression, propertyName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="propertyName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="expression"><span data-ttu-id="7593b-3264">一个 <see cref="T:System.Linq.Expressions.Expression" />，其 <see cref="P:System.Linq.Expressions.Expression.Type" /> 包含一个名为 <paramref name="propertyName" /> 的属性。</span><span class="sxs-lookup"><span data-stu-id="7593b-3264">An <see cref="T:System.Linq.Expressions.Expression" /> whose <see cref="P:System.Linq.Expressions.Expression.Type" /> contains a property named <paramref name="propertyName" />.</span></span> <span data-ttu-id="7593b-3265">对于静态属性，这可以为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-3265">This can be <see langword="null" /> for static properties.</span></span></param>
        <param name="propertyName"><span data-ttu-id="7593b-3266">要访问的属性的名称。</span><span class="sxs-lookup"><span data-stu-id="7593b-3266">The name of a property to be accessed.</span></span></param>
        <summary><span data-ttu-id="7593b-3267">创建一个表示访问属性的 <see cref="T:System.Linq.Expressions.MemberExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-3267">Creates a <see cref="T:System.Linq.Expressions.MemberExpression" /> that represents accessing a property.</span></span></summary>
        <returns><span data-ttu-id="7593b-3268">一个 <see cref="T:System.Linq.Expressions.MemberExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 属性等于 <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" />，<see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> 属性设置为 <paramref name="expression" />，并且 <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> 属性设置为由 <see cref="T:System.Reflection.PropertyInfo" /> 表示的属性的 <paramref name="propertyName" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-3268">A <see cref="T:System.Linq.Expressions.MemberExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" />, the <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> property set to <paramref name="expression" />, and the <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> property set to the <see cref="T:System.Reflection.PropertyInfo" /> that represents the property denoted by <paramref name="propertyName" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7593b-3269">生成的 <xref:System.Linq.Expressions.MemberExpression> 的 <xref:System.Linq.Expressions.Expression.Type%2A> 属性等于表示 `propertyName`所表示的属性的 <xref:System.Reflection.PropertyInfo> 的 <xref:System.Reflection.PropertyInfo.PropertyType%2A> 属性。</span><span class="sxs-lookup"><span data-stu-id="7593b-3269">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.MemberExpression> is equal to the <xref:System.Reflection.PropertyInfo.PropertyType%2A> property of the <xref:System.Reflection.PropertyInfo> that represents the property denoted by `propertyName`.</span></span>  
  
 <span data-ttu-id="7593b-3270">此方法搜索 `expression`。类型及其基类型，用于名称 `propertyName`的属性。</span><span class="sxs-lookup"><span data-stu-id="7593b-3270">This method searches `expression`.Type and its base types for a property that has the name `propertyName`.</span></span> <span data-ttu-id="7593b-3271">公共属性优先于非公共属性。</span><span class="sxs-lookup"><span data-stu-id="7593b-3271">Public properties are given preference over non-public properties.</span></span> <span data-ttu-id="7593b-3272">如果找到匹配的属性，此方法会将 `expression`，并将表示该属性的 <xref:System.Reflection.PropertyInfo> 传递给 <xref:System.Linq.Expressions.Expression.Property%2A>。</span><span class="sxs-lookup"><span data-stu-id="7593b-3272">If a matching property is found, this method passes `expression` and the <xref:System.Reflection.PropertyInfo> that represents that property to <xref:System.Linq.Expressions.Expression.Property%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="7593b-3273">下面的示例演示如何创建一个表示访问属性的表达式。</span><span class="sxs-lookup"><span data-stu-id="7593b-3273">The following example shows how to create an expression that represents accessing a property.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#38](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#38)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#38](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#38)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="7593b-3274"><paramref name="expression" /> 或 <paramref name="propertyName" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-3274"><paramref name="expression" /> or <paramref name="propertyName" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="7593b-3275">没有在 <paramref name="propertyName" />.Type 或其基类型中定义名为 <paramref name="expression" /> 的属性。</span><span class="sxs-lookup"><span data-stu-id="7593b-3275">No property named <paramref name="propertyName" /> is defined in <paramref name="expression" />.Type or its base types.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Property">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.IndexExpression Property (System.Linq.Expressions.Expression instance, System.Reflection.PropertyInfo indexer, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.IndexExpression Property(class System.Linq.Expressions.Expression instance, class System.Reflection.PropertyInfo indexer, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression,System.Reflection.PropertyInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Property (instance As Expression, indexer As PropertyInfo, arguments As IEnumerable(Of Expression)) As IndexExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::IndexExpression ^ Property(System::Linq::Expressions::Expression ^ instance, System::Reflection::PropertyInfo ^ indexer, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberSignature Language="F#" Value="static member Property : System.Linq.Expressions.Expression * System.Reflection.PropertyInfo * seq&lt;System.Linq.Expressions.Expression&gt; -&gt; System.Linq.Expressions.IndexExpression" Usage="System.Linq.Expressions.Expression.Property (instance, indexer, arguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.IndexExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Linq.Expressions.Expression" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="indexer" Type="System.Reflection.PropertyInfo" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arguments" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="instance"><span data-ttu-id="7593b-3276">属性所属的对象。</span><span class="sxs-lookup"><span data-stu-id="7593b-3276">The object to which the property belongs.</span></span> <span data-ttu-id="7593b-3277">如果该属性为 static/shared，则此对象必须为 null。</span><span class="sxs-lookup"><span data-stu-id="7593b-3277">If the property is static/shared, it must be null.</span></span></param>
        <param name="indexer"><span data-ttu-id="7593b-3278">表示要编制索引的属性的 <see cref="T:System.Reflection.PropertyInfo" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-3278">The <see cref="T:System.Reflection.PropertyInfo" /> that represents the property to index.</span></span></param>
        <param name="arguments"><span data-ttu-id="7593b-3279">用于为属性编制索引的 <see cref="T:System.Collections.Generic.IEnumerable`1" /> 对象的 <see cref="T:System.Linq.Expressions.Expression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-3279">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> of <see cref="T:System.Linq.Expressions.Expression" /> objects that are used to index the property.</span></span></param>
        <summary><span data-ttu-id="7593b-3280">创建一个 <see cref="T:System.Linq.Expressions.IndexExpression" />，它表示对索引属性的访问。</span><span class="sxs-lookup"><span data-stu-id="7593b-3280">Creates an <see cref="T:System.Linq.Expressions.IndexExpression" /> representing the access to an indexed property.</span></span></summary>
        <returns><span data-ttu-id="7593b-3281">创建的 <see cref="T:System.Linq.Expressions.IndexExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-3281">The created <see cref="T:System.Linq.Expressions.IndexExpression" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Property">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.IndexExpression Property (System.Linq.Expressions.Expression instance, System.Reflection.PropertyInfo indexer, params System.Linq.Expressions.Expression[] arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.IndexExpression Property(class System.Linq.Expressions.Expression instance, class System.Reflection.PropertyInfo indexer, class System.Linq.Expressions.Expression[] arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression,System.Reflection.PropertyInfo,System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Property (instance As Expression, indexer As PropertyInfo, ParamArray arguments As Expression()) As IndexExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::IndexExpression ^ Property(System::Linq::Expressions::Expression ^ instance, System::Reflection::PropertyInfo ^ indexer, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberSignature Language="F#" Value="static member Property : System.Linq.Expressions.Expression * System.Reflection.PropertyInfo * System.Linq.Expressions.Expression[] -&gt; System.Linq.Expressions.IndexExpression" Usage="System.Linq.Expressions.Expression.Property (instance, indexer, arguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.IndexExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Linq.Expressions.Expression" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="indexer" Type="System.Reflection.PropertyInfo" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arguments" Type="System.Linq.Expressions.Expression[]" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="instance"><span data-ttu-id="7593b-3282">属性所属的对象。</span><span class="sxs-lookup"><span data-stu-id="7593b-3282">The object to which the property belongs.</span></span> <span data-ttu-id="7593b-3283">如果该属性为 static/shared，则此对象必须为 null。</span><span class="sxs-lookup"><span data-stu-id="7593b-3283">If the property is static/shared, it must be null.</span></span></param>
        <param name="indexer"><span data-ttu-id="7593b-3284">表示要编制索引的属性的 <see cref="T:System.Reflection.PropertyInfo" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-3284">The <see cref="T:System.Reflection.PropertyInfo" /> that represents the property to index.</span></span></param>
        <param name="arguments"><span data-ttu-id="7593b-3285">用于为属性编制索引的 <see cref="T:System.Linq.Expressions.Expression" /> 对象的数组。</span><span class="sxs-lookup"><span data-stu-id="7593b-3285">An array of <see cref="T:System.Linq.Expressions.Expression" /> objects that are used to index the property.</span></span></param>
        <summary><span data-ttu-id="7593b-3286">创建一个 <see cref="T:System.Linq.Expressions.IndexExpression" />，它表示对索引属性的访问。</span><span class="sxs-lookup"><span data-stu-id="7593b-3286">Creates an <see cref="T:System.Linq.Expressions.IndexExpression" /> representing the access to an indexed property.</span></span></summary>
        <returns><span data-ttu-id="7593b-3287">创建的 <see cref="T:System.Linq.Expressions.IndexExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-3287">The created <see cref="T:System.Linq.Expressions.IndexExpression" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Property">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.IndexExpression Property (System.Linq.Expressions.Expression instance, string propertyName, params System.Linq.Expressions.Expression[] arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.IndexExpression Property(class System.Linq.Expressions.Expression instance, string propertyName, class System.Linq.Expressions.Expression[] arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression,System.String,System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Property (instance As Expression, propertyName As String, ParamArray arguments As Expression()) As IndexExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::IndexExpression ^ Property(System::Linq::Expressions::Expression ^ instance, System::String ^ propertyName, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberSignature Language="F#" Value="static member Property : System.Linq.Expressions.Expression * string * System.Linq.Expressions.Expression[] -&gt; System.Linq.Expressions.IndexExpression" Usage="System.Linq.Expressions.Expression.Property (instance, propertyName, arguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.IndexExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Linq.Expressions.Expression" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="propertyName" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arguments" Type="System.Linq.Expressions.Expression[]" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="instance"><span data-ttu-id="7593b-3288">属性所属的对象。</span><span class="sxs-lookup"><span data-stu-id="7593b-3288">The object to which the property belongs.</span></span> <span data-ttu-id="7593b-3289">如果该属性为 static/shared，则此对象必须为 null。</span><span class="sxs-lookup"><span data-stu-id="7593b-3289">If the property is static/shared, it must be null.</span></span></param>
        <param name="propertyName"><span data-ttu-id="7593b-3290">索引器的名称。</span><span class="sxs-lookup"><span data-stu-id="7593b-3290">The name of the indexer.</span></span></param>
        <param name="arguments"><span data-ttu-id="7593b-3291">用于为属性编制索引的 <see cref="T:System.Linq.Expressions.Expression" /> 对象的数组。</span><span class="sxs-lookup"><span data-stu-id="7593b-3291">An array of <see cref="T:System.Linq.Expressions.Expression" /> objects that are used to index the property.</span></span></param>
        <summary><span data-ttu-id="7593b-3292">创建一个 <see cref="T:System.Linq.Expressions.IndexExpression" />，它表示对索引属性的访问。</span><span class="sxs-lookup"><span data-stu-id="7593b-3292">Creates an <see cref="T:System.Linq.Expressions.IndexExpression" /> representing the access to an indexed property.</span></span></summary>
        <returns><span data-ttu-id="7593b-3293">创建的 <see cref="T:System.Linq.Expressions.IndexExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-3293">The created <see cref="T:System.Linq.Expressions.IndexExpression" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Property">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberExpression Property (System.Linq.Expressions.Expression expression, Type type, string propertyName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberExpression Property(class System.Linq.Expressions.Expression expression, class System.Type type, string propertyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression,System.Type,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberExpression ^ Property(System::Linq::Expressions::Expression ^ expression, Type ^ type, System::String ^ propertyName);" />
      <MemberSignature Language="F#" Value="static member Property : System.Linq.Expressions.Expression * Type * string -&gt; System.Linq.Expressions.MemberExpression" Usage="System.Linq.Expressions.Expression.Property (expression, type, propertyName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="type" Type="System.Type" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="propertyName" Type="System.String" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="expression"><span data-ttu-id="7593b-3294">属性的包含对象。</span><span class="sxs-lookup"><span data-stu-id="7593b-3294">The containing object of the property.</span></span> <span data-ttu-id="7593b-3295">对于静态属性，这可以为 null。</span><span class="sxs-lookup"><span data-stu-id="7593b-3295">This can be null for static properties.</span></span></param>
        <param name="type"><span data-ttu-id="7593b-3296">包含属性的 <see cref="P:System.Linq.Expressions.Expression.Type" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-3296">The <see cref="P:System.Linq.Expressions.Expression.Type" /> that contains the property.</span></span></param>
        <param name="propertyName"><span data-ttu-id="7593b-3297">要访问的属性。</span><span class="sxs-lookup"><span data-stu-id="7593b-3297">The property to be accessed.</span></span></param>
        <summary><span data-ttu-id="7593b-3298">创建一个访问属性的 <see cref="T:System.Linq.Expressions.MemberExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-3298">Creates a <see cref="T:System.Linq.Expressions.MemberExpression" /> accessing a property.</span></span></summary>
        <returns><span data-ttu-id="7593b-3299">创建的 <see cref="T:System.Linq.Expressions.MemberExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-3299">The created <see cref="T:System.Linq.Expressions.MemberExpression" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PropertyOrField">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberExpression PropertyOrField (System.Linq.Expressions.Expression expression, string propertyOrFieldName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberExpression PropertyOrField(class System.Linq.Expressions.Expression expression, string propertyOrFieldName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.PropertyOrField(System.Linq.Expressions.Expression,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberExpression ^ PropertyOrField(System::Linq::Expressions::Expression ^ expression, System::String ^ propertyOrFieldName);" />
      <MemberSignature Language="F#" Value="static member PropertyOrField : System.Linq.Expressions.Expression * string -&gt; System.Linq.Expressions.MemberExpression" Usage="System.Linq.Expressions.Expression.PropertyOrField (expression, propertyOrFieldName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="propertyOrFieldName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="expression"><span data-ttu-id="7593b-3300">一个 <see cref="T:System.Linq.Expressions.Expression" />，其 <see cref="P:System.Linq.Expressions.Expression.Type" /> 包含一个名为 <paramref name="propertyOrFieldName" /> 的属性或字段。</span><span class="sxs-lookup"><span data-stu-id="7593b-3300">An <see cref="T:System.Linq.Expressions.Expression" /> whose <see cref="P:System.Linq.Expressions.Expression.Type" /> contains a property or field named <paramref name="propertyOrFieldName" />.</span></span> <span data-ttu-id="7593b-3301">对于静态成员，这可以为 null。</span><span class="sxs-lookup"><span data-stu-id="7593b-3301">This can be null for static members.</span></span></param>
        <param name="propertyOrFieldName"><span data-ttu-id="7593b-3302">要访问的属性或字段的名称。</span><span class="sxs-lookup"><span data-stu-id="7593b-3302">The name of a property or field to be accessed.</span></span></param>
        <summary><span data-ttu-id="7593b-3303">创建一个表示访问属性或字段的 <see cref="T:System.Linq.Expressions.MemberExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-3303">Creates a <see cref="T:System.Linq.Expressions.MemberExpression" /> that represents accessing a property or field.</span></span></summary>
        <returns><span data-ttu-id="7593b-3304">一个 <see cref="T:System.Linq.Expressions.MemberExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 属性等于 <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" />，<see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> 属性设置为 <paramref name="expression" />，并且 <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> 属性设置为表示 <see cref="T:System.Reflection.PropertyInfo" /> 所表示的属性或字段的 <see cref="T:System.Reflection.FieldInfo" /> 或 <paramref name="propertyOrFieldName" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-3304">A <see cref="T:System.Linq.Expressions.MemberExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" />, the <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> property set to <paramref name="expression" />, and the <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> property set to the <see cref="T:System.Reflection.PropertyInfo" /> or <see cref="T:System.Reflection.FieldInfo" /> that represents the property or field denoted by <paramref name="propertyOrFieldName" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7593b-3305">生成的 <xref:System.Linq.Expressions.MemberExpression> 的 <xref:System.Linq.Expressions.Expression.Type%2A> 属性分别等于 <xref:System.Reflection.PropertyInfo> 或 <xref:System.Reflection.FieldInfo>表示的属性或字段的 <xref:System.Reflection.PropertyInfo.PropertyType%2A> 或 <xref:System.Reflection.FieldInfo.FieldType%2A> 属性。`propertyOrFieldName`</span><span class="sxs-lookup"><span data-stu-id="7593b-3305">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.MemberExpression> is equal to the <xref:System.Reflection.PropertyInfo.PropertyType%2A> or <xref:System.Reflection.FieldInfo.FieldType%2A> properties of the <xref:System.Reflection.PropertyInfo> or <xref:System.Reflection.FieldInfo>, respectively, that represents the property or field denoted by `propertyOrFieldName`.</span></span>  
  
 <span data-ttu-id="7593b-3306">此方法搜索 `expression`。类型及其基类型，用于名称 `propertyOrFieldName`的属性或字段。</span><span class="sxs-lookup"><span data-stu-id="7593b-3306">This method searches `expression`.Type and its base types for a property or field that has the name `propertyOrFieldName`.</span></span> <span data-ttu-id="7593b-3307">公共属性和字段优先于非公共属性和字段。</span><span class="sxs-lookup"><span data-stu-id="7593b-3307">Public properties and fields are given preference over non-public properties and fields.</span></span> <span data-ttu-id="7593b-3308">另外，属性优先于字段。</span><span class="sxs-lookup"><span data-stu-id="7593b-3308">Also, properties are given preference over fields.</span></span> <span data-ttu-id="7593b-3309">如果找到了匹配的属性或字段，则此方法会将 `expression` 以及表示该属性或字段的 <xref:System.Reflection.PropertyInfo> 或 <xref:System.Reflection.FieldInfo> 分别传递到 <xref:System.Linq.Expressions.Expression.Property%2A> 或 <xref:System.Linq.Expressions.Expression.Field%2A>。</span><span class="sxs-lookup"><span data-stu-id="7593b-3309">If a matching property or field is found, this method passes `expression` and the <xref:System.Reflection.PropertyInfo> or <xref:System.Reflection.FieldInfo> that represents that property or field to <xref:System.Linq.Expressions.Expression.Property%2A> or <xref:System.Linq.Expressions.Expression.Field%2A>, respectively.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="7593b-3310">下面的示例演示如何创建一个表达式，该表达式表示访问属性或字段。</span><span class="sxs-lookup"><span data-stu-id="7593b-3310">The following example shows how to create an expression that represents accessing a property or field.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#39](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#39)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#39](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#39)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="7593b-3311"><paramref name="expression" /> 或 <paramref name="propertyOrFieldName" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-3311"><paramref name="expression" /> or <paramref name="propertyOrFieldName" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="7593b-3312">没有在 <paramref name="propertyOrFieldName" />.Type 或其基类型中定义名为 <paramref name="expression" /> 的属性或字段。</span><span class="sxs-lookup"><span data-stu-id="7593b-3312">No property or field named <paramref name="propertyOrFieldName" /> is defined in <paramref name="expression" />.Type or its base types.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Quote">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression Quote (System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression Quote(class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Quote(System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ Quote(System::Linq::Expressions::Expression ^ expression);" />
      <MemberSignature Language="F#" Value="static member Quote : System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.Quote expression" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="expression"><span data-ttu-id="7593b-3313">要将 <see cref="T:System.Linq.Expressions.Expression" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-3313">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="7593b-3314">创建一个表示具有类型 <see cref="T:System.Linq.Expressions.UnaryExpression" /> 的常量值的表达式的 <see cref="T:System.Linq.Expressions.Expression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-3314">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents an expression that has a constant value of type <see cref="T:System.Linq.Expressions.Expression" />.</span></span></summary>
        <returns><span data-ttu-id="7593b-3315">一个 <see cref="T:System.Linq.Expressions.UnaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 属性等于 <see cref="F:System.Linq.Expressions.ExpressionType.Quote" />，并且其 <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> 属性设置为指定值。</span><span class="sxs-lookup"><span data-stu-id="7593b-3315">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Quote" /> and the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> property set to the specified value.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7593b-3316">生成的 <xref:System.Linq.Expressions.UnaryExpression> 的 <xref:System.Linq.Expressions.Expression.Type%2A> 属性表示构造类型 <xref:System.Linq.Expressions.Expression%601>，其中类型参数是由 `expression`表示的类型。类别.</span><span class="sxs-lookup"><span data-stu-id="7593b-3316">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.UnaryExpression> represents the constructed type <xref:System.Linq.Expressions.Expression%601>, where the type argument is the type represented by `expression`.Type.</span></span> <span data-ttu-id="7593b-3317"><xref:System.Linq.Expressions.UnaryExpression.Method%2A> 属性为 `null`。</span><span class="sxs-lookup"><span data-stu-id="7593b-3317">The <xref:System.Linq.Expressions.UnaryExpression.Method%2A> property is `null`.</span></span> <span data-ttu-id="7593b-3318">同时 `false`<xref:System.Linq.Expressions.UnaryExpression.IsLifted%2A> 和 <xref:System.Linq.Expressions.UnaryExpression.IsLiftedToNull%2A>。</span><span class="sxs-lookup"><span data-stu-id="7593b-3318">Both <xref:System.Linq.Expressions.UnaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.UnaryExpression.IsLiftedToNull%2A> are `false`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="7593b-3319"><paramref name="expression" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-3319"><paramref name="expression" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Reduce">
      <MemberSignature Language="C#" Value="public virtual System.Linq.Expressions.Expression Reduce ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Linq.Expressions.Expression Reduce() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Reduce" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Reduce () As Expression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Linq::Expressions::Expression ^ Reduce();" />
      <MemberSignature Language="F#" Value="abstract member Reduce : unit -&gt; System.Linq.Expressions.Expression&#xA;override this.Reduce : unit -&gt; System.Linq.Expressions.Expression" Usage="expression.Reduce " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.Expression</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="7593b-3320">将此节点简化为更简单的表达式。</span><span class="sxs-lookup"><span data-stu-id="7593b-3320">Reduces this node to a simpler expression.</span></span> <span data-ttu-id="7593b-3321">如果 CanReduce 返回 true，则它应返回有效的表达式。</span><span class="sxs-lookup"><span data-stu-id="7593b-3321">If CanReduce returns true, this should return a valid expression.</span></span> <span data-ttu-id="7593b-3322">此方法可以返回本身必须简化的另一个节点。</span><span class="sxs-lookup"><span data-stu-id="7593b-3322">This method can return another node which itself must be reduced.</span></span></summary>
        <returns><span data-ttu-id="7593b-3323">已简化的表达式。</span><span class="sxs-lookup"><span data-stu-id="7593b-3323">The reduced expression.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReduceAndCheck">
      <MemberSignature Language="C#" Value="public System.Linq.Expressions.Expression ReduceAndCheck ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Linq.Expressions.Expression ReduceAndCheck() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ReduceAndCheck" />
      <MemberSignature Language="VB.NET" Value="Public Function ReduceAndCheck () As Expression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Linq::Expressions::Expression ^ ReduceAndCheck();" />
      <MemberSignature Language="F#" Value="member this.ReduceAndCheck : unit -&gt; System.Linq.Expressions.Expression" Usage="expression.ReduceAndCheck " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.Expression</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="7593b-3324">将此节点简化为更简单的表达式。</span><span class="sxs-lookup"><span data-stu-id="7593b-3324">Reduces this node to a simpler expression.</span></span> <span data-ttu-id="7593b-3325">如果 CanReduce 返回 true，则它应返回有效的表达式。</span><span class="sxs-lookup"><span data-stu-id="7593b-3325">If CanReduce returns true, this should return a valid expression.</span></span> <span data-ttu-id="7593b-3326">此方法可以返回本身必须简化的另一个节点。</span><span class="sxs-lookup"><span data-stu-id="7593b-3326">This method can return another node which itself must be reduced.</span></span></summary>
        <returns><span data-ttu-id="7593b-3327">已简化的表达式。</span><span class="sxs-lookup"><span data-stu-id="7593b-3327">The reduced expression.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7593b-3328">与 "减少" 不同，此方法会检查 "已减少" 节点是否满足某些固定条件。</span><span class="sxs-lookup"><span data-stu-id="7593b-3328">Unlike Reduce, this method checks that the reduced node satisfies certain invariants.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReduceExtensions">
      <MemberSignature Language="C#" Value="public System.Linq.Expressions.Expression ReduceExtensions ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Linq.Expressions.Expression ReduceExtensions() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ReduceExtensions" />
      <MemberSignature Language="VB.NET" Value="Public Function ReduceExtensions () As Expression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Linq::Expressions::Expression ^ ReduceExtensions();" />
      <MemberSignature Language="F#" Value="member this.ReduceExtensions : unit -&gt; System.Linq.Expressions.Expression" Usage="expression.ReduceExtensions " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.Expression</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="7593b-3329">将表达式简化为已知节点类型（即非 Extension 节点）或仅在此类型为已知类型时返回表达式。</span><span class="sxs-lookup"><span data-stu-id="7593b-3329">Reduces the expression to a known node type (that is not an Extension node) or just returns the expression if it is already a known type.</span></span></summary>
        <returns><span data-ttu-id="7593b-3330">已简化的表达式。</span><span class="sxs-lookup"><span data-stu-id="7593b-3330">The reduced expression.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReferenceEqual">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression ReferenceEqual (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression ReferenceEqual(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ReferenceEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReferenceEqual (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ ReferenceEqual(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member ReferenceEqual : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.ReferenceEqual (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="7593b-3331">要将 <see cref="T:System.Linq.Expressions.Expression" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-3331">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="7593b-3332">要将 <see cref="T:System.Linq.Expressions.Expression" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-3332">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="7593b-3333">创建一个表示引用相等比较的 <see cref="T:System.Linq.Expressions.BinaryExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-3333">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a reference equality comparison.</span></span></summary>
        <returns><span data-ttu-id="7593b-3334">一个 <see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 属性等于 <see cref="F:System.Linq.Expressions.ExpressionType.Equal" />，并且其 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 属性设置为指定值。</span><span class="sxs-lookup"><span data-stu-id="7593b-3334">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Equal" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReferenceNotEqual">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression ReferenceNotEqual (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression ReferenceNotEqual(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ReferenceNotEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReferenceNotEqual (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ ReferenceNotEqual(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member ReferenceNotEqual : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.ReferenceNotEqual (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="7593b-3335">要将 <see cref="T:System.Linq.Expressions.Expression" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-3335">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="7593b-3336">要将 <see cref="T:System.Linq.Expressions.Expression" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-3336">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="7593b-3337">创建一个表示引用不相等比较的 <see cref="T:System.Linq.Expressions.BinaryExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-3337">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a reference inequality comparison.</span></span></summary>
        <returns><span data-ttu-id="7593b-3338">一个 <see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 属性等于 <see cref="F:System.Linq.Expressions.ExpressionType.NotEqual" />，并且其 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 属性设置为指定值。</span><span class="sxs-lookup"><span data-stu-id="7593b-3338">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.NotEqual" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Rethrow">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="7593b-3339">创建一个 <see cref="T:System.Linq.Expressions.UnaryExpression" />，它表示重新引发异常。</span><span class="sxs-lookup"><span data-stu-id="7593b-3339">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents a rethrowing of an exception.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Rethrow">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression Rethrow ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression Rethrow() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Rethrow" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Rethrow () As UnaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ Rethrow();" />
      <MemberSignature Language="F#" Value="static member Rethrow : unit -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.Rethrow " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="7593b-3340">创建一个 <see cref="T:System.Linq.Expressions.UnaryExpression" />，它表示重新引发异常。</span><span class="sxs-lookup"><span data-stu-id="7593b-3340">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents a rethrowing of an exception.</span></span></summary>
        <returns><span data-ttu-id="7593b-3341">一个 <see cref="T:System.Linq.Expressions.UnaryExpression" />，它表示重新引发异常。</span><span class="sxs-lookup"><span data-stu-id="7593b-3341">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents a rethrowing of an exception.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Rethrow">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression Rethrow (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression Rethrow(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Rethrow(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ Rethrow(Type ^ type);" />
      <MemberSignature Language="F#" Value="static member Rethrow : Type -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.Rethrow type" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="type"><span data-ttu-id="7593b-3342">表达式的新 <see cref="T:System.Type" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-3342">The new <see cref="T:System.Type" /> of the expression.</span></span></param>
        <summary><span data-ttu-id="7593b-3343">创建一个 <see cref="T:System.Linq.Expressions.UnaryExpression" />，它表示重新引发具有给定类型的异常。</span><span class="sxs-lookup"><span data-stu-id="7593b-3343">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents a rethrowing of an exception with a given type.</span></span></summary>
        <returns><span data-ttu-id="7593b-3344">一个 <see cref="T:System.Linq.Expressions.UnaryExpression" />，它表示重新引发异常。</span><span class="sxs-lookup"><span data-stu-id="7593b-3344">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents a rethrowing of an exception.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Return">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="7593b-3345">创建一个表示 return 语句的 <see cref="T:System.Linq.Expressions.GotoExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-3345">Creates a <see cref="T:System.Linq.Expressions.GotoExpression" /> representing a return statement.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Return">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.GotoExpression Return (System.Linq.Expressions.LabelTarget target);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.GotoExpression Return(class System.Linq.Expressions.LabelTarget target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Return(System.Linq.Expressions.LabelTarget)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Return (target As LabelTarget) As GotoExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::GotoExpression ^ Return(System::Linq::Expressions::LabelTarget ^ target);" />
      <MemberSignature Language="F#" Value="static member Return : System.Linq.Expressions.LabelTarget -&gt; System.Linq.Expressions.GotoExpression" Usage="System.Linq.Expressions.Expression.Return target" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.GotoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="target"><span data-ttu-id="7593b-3346"><see cref="T:System.Linq.Expressions.LabelTarget" /> 将跳至的 <see cref="T:System.Linq.Expressions.GotoExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-3346">The <see cref="T:System.Linq.Expressions.LabelTarget" /> that the <see cref="T:System.Linq.Expressions.GotoExpression" /> will jump to.</span></span></param>
        <summary><span data-ttu-id="7593b-3347">创建一个表示 return 语句的 <see cref="T:System.Linq.Expressions.GotoExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-3347">Creates a <see cref="T:System.Linq.Expressions.GotoExpression" /> representing a return statement.</span></span></summary>
        <returns><span data-ttu-id="7593b-3348">一个 <see cref="T:System.Linq.Expressions.GotoExpression" />，其 <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> 等于 Return，其 <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> 属性设置为 <paramref name="target" />，此外还有一个在跳转时将传递给目标标签的 null 值。</span><span class="sxs-lookup"><span data-stu-id="7593b-3348">A <see cref="T:System.Linq.Expressions.GotoExpression" /> with <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> equal to Return, the <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> property set to <paramref name="target" />, and a null value to be passed to the target label upon jumping.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Return">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.GotoExpression Return (System.Linq.Expressions.LabelTarget target, System.Linq.Expressions.Expression value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.GotoExpression Return(class System.Linq.Expressions.LabelTarget target, class System.Linq.Expressions.Expression value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Return(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Return (target As LabelTarget, value As Expression) As GotoExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::GotoExpression ^ Return(System::Linq::Expressions::LabelTarget ^ target, System::Linq::Expressions::Expression ^ value);" />
      <MemberSignature Language="F#" Value="static member Return : System.Linq.Expressions.LabelTarget * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.GotoExpression" Usage="System.Linq.Expressions.Expression.Return (target, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.GotoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="value" Type="System.Linq.Expressions.Expression" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="target"><span data-ttu-id="7593b-3349"><see cref="T:System.Linq.Expressions.LabelTarget" /> 将跳至的 <see cref="T:System.Linq.Expressions.GotoExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-3349">The <see cref="T:System.Linq.Expressions.LabelTarget" /> that the <see cref="T:System.Linq.Expressions.GotoExpression" /> will jump to.</span></span></param>
        <param name="value"><span data-ttu-id="7593b-3350">将在跳转时传递给关联标签的值。</span><span class="sxs-lookup"><span data-stu-id="7593b-3350">The value that will be passed to the associated label upon jumping.</span></span></param>
        <summary><span data-ttu-id="7593b-3351">创建一个表示 return 语句的 <see cref="T:System.Linq.Expressions.GotoExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-3351">Creates a <see cref="T:System.Linq.Expressions.GotoExpression" /> representing a return statement.</span></span> <span data-ttu-id="7593b-3352">可以指定在跳转时传递给标签的值。</span><span class="sxs-lookup"><span data-stu-id="7593b-3352">The value passed to the label upon jumping can be specified.</span></span></summary>
        <returns><span data-ttu-id="7593b-3353">一个 <see cref="T:System.Linq.Expressions.GotoExpression" />，其 <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> 等于 Continue，其 <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> 属性设置为 <paramref name="target" />，此外还有一个在跳转时将传递给目标标签的 <paramref name="value" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-3353">A <see cref="T:System.Linq.Expressions.GotoExpression" /> with <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> equal to Continue, the <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> property set to <paramref name="target" />, and <paramref name="value" /> to be passed to the target label upon jumping.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="7593b-3354">下面的示例演示如何创建包含 <xref:System.Linq.Expressions.Expression.Return%2A> 方法的表达式。</span><span class="sxs-lookup"><span data-stu-id="7593b-3354">The following example demonstrates how to create an expression that contains the <xref:System.Linq.Expressions.Expression.Return%2A> method.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#43](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#43)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#43](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#43)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Return">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.GotoExpression Return (System.Linq.Expressions.LabelTarget target, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.GotoExpression Return(class System.Linq.Expressions.LabelTarget target, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Return(System.Linq.Expressions.LabelTarget,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::GotoExpression ^ Return(System::Linq::Expressions::LabelTarget ^ target, Type ^ type);" />
      <MemberSignature Language="F#" Value="static member Return : System.Linq.Expressions.LabelTarget * Type -&gt; System.Linq.Expressions.GotoExpression" Usage="System.Linq.Expressions.Expression.Return (target, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.GotoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="type" Type="System.Type" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="target"><span data-ttu-id="7593b-3355"><see cref="T:System.Linq.Expressions.LabelTarget" /> 将跳至的 <see cref="T:System.Linq.Expressions.GotoExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-3355">The <see cref="T:System.Linq.Expressions.LabelTarget" /> that the <see cref="T:System.Linq.Expressions.GotoExpression" /> will jump to.</span></span></param>
        <param name="type"><span data-ttu-id="7593b-3356">要将 <see cref="T:System.Type" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.Expression.Type" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-3356">An <see cref="T:System.Type" /> to set the <see cref="P:System.Linq.Expressions.Expression.Type" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="7593b-3357">创建一个表示具有指定类型的 return 语句的 <see cref="T:System.Linq.Expressions.GotoExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-3357">Creates a <see cref="T:System.Linq.Expressions.GotoExpression" /> representing a return statement with the specified type.</span></span></summary>
        <returns><span data-ttu-id="7593b-3358">一个 <see cref="T:System.Linq.Expressions.GotoExpression" />，其 <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> 等于 Return，其 <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> 属性设置为 <paramref name="target" />，并且其 <see cref="P:System.Linq.Expressions.Expression.Type" /> 属性设置为 <paramref name="type" />，此外还有一个在跳转时将传递给目标标签的 null 值。</span><span class="sxs-lookup"><span data-stu-id="7593b-3358">A <see cref="T:System.Linq.Expressions.GotoExpression" /> with <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> equal to Return, the <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> property set to <paramref name="target" />, the <see cref="P:System.Linq.Expressions.Expression.Type" /> property set to <paramref name="type" />, and a null value to be passed to the target label upon jumping.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Return">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.GotoExpression Return (System.Linq.Expressions.LabelTarget target, System.Linq.Expressions.Expression value, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.GotoExpression Return(class System.Linq.Expressions.LabelTarget target, class System.Linq.Expressions.Expression value, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Return(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::GotoExpression ^ Return(System::Linq::Expressions::LabelTarget ^ target, System::Linq::Expressions::Expression ^ value, Type ^ type);" />
      <MemberSignature Language="F#" Value="static member Return : System.Linq.Expressions.LabelTarget * System.Linq.Expressions.Expression * Type -&gt; System.Linq.Expressions.GotoExpression" Usage="System.Linq.Expressions.Expression.Return (target, value, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.GotoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="value" Type="System.Linq.Expressions.Expression" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="type" Type="System.Type" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="target"><span data-ttu-id="7593b-3359"><see cref="T:System.Linq.Expressions.LabelTarget" /> 将跳至的 <see cref="T:System.Linq.Expressions.GotoExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-3359">The <see cref="T:System.Linq.Expressions.LabelTarget" /> that the <see cref="T:System.Linq.Expressions.GotoExpression" /> will jump to.</span></span></param>
        <param name="value"><span data-ttu-id="7593b-3360">将在跳转时传递给关联标签的值。</span><span class="sxs-lookup"><span data-stu-id="7593b-3360">The value that will be passed to the associated label upon jumping.</span></span></param>
        <param name="type"><span data-ttu-id="7593b-3361">要将 <see cref="T:System.Type" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.Expression.Type" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-3361">An <see cref="T:System.Type" /> to set the <see cref="P:System.Linq.Expressions.Expression.Type" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="7593b-3362">创建一个表示具有指定类型的 return 语句的 <see cref="T:System.Linq.Expressions.GotoExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-3362">Creates a <see cref="T:System.Linq.Expressions.GotoExpression" /> representing a return statement with the specified type.</span></span> <span data-ttu-id="7593b-3363">可以指定在跳转时传递给标签的值。</span><span class="sxs-lookup"><span data-stu-id="7593b-3363">The value passed to the label upon jumping can be specified.</span></span></summary>
        <returns><span data-ttu-id="7593b-3364">一个 <see cref="T:System.Linq.Expressions.GotoExpression" />，其 <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> 等于 Continue，其 <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> 属性设置为 <paramref name="target" />，并且其 <see cref="P:System.Linq.Expressions.Expression.Type" /> 属性设置为 <paramref name="type" />，此外还有一个在跳转时将传递给目标标签的 <paramref name="value" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-3364">A <see cref="T:System.Linq.Expressions.GotoExpression" /> with <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> equal to Continue, the <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> property set to <paramref name="target" />, the <see cref="P:System.Linq.Expressions.Expression.Type" /> property set to <paramref name="type" />, and <paramref name="value" /> to be passed to the target label upon jumping.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="RightShift">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="7593b-3365">创建一个表示按位右移运算的 <see cref="T:System.Linq.Expressions.BinaryExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-3365">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise right-shift operation.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RightShift">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression RightShift (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression RightShift(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.RightShift(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RightShift (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ RightShift(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member RightShift : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.RightShift (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="7593b-3366">要将 <see cref="T:System.Linq.Expressions.Expression" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-3366">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="7593b-3367">要将 <see cref="T:System.Linq.Expressions.Expression" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-3367">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="7593b-3368">创建一个表示按位右移运算的 <see cref="T:System.Linq.Expressions.BinaryExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-3368">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise right-shift operation.</span></span></summary>
        <returns><span data-ttu-id="7593b-3369">一个 <see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 属性等于 <see cref="F:System.Linq.Expressions.ExpressionType.RightShift" />，并且其 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 属性设置为指定值。</span><span class="sxs-lookup"><span data-stu-id="7593b-3369">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.RightShift" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7593b-3370">生成的 <xref:System.Linq.Expressions.BinaryExpression> 具有设置为实现方法的 <xref:System.Linq.Expressions.BinaryExpression.Method%2A> 属性。</span><span class="sxs-lookup"><span data-stu-id="7593b-3370">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="7593b-3371"><xref:System.Linq.Expressions.Expression.Type%2A> 属性设置为节点的类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-3371">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="7593b-3372">如果节点已提升，则 <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> 和 <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> 属性均 `true`。</span><span class="sxs-lookup"><span data-stu-id="7593b-3372">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="7593b-3373">否则，它们 `false`。</span><span class="sxs-lookup"><span data-stu-id="7593b-3373">Otherwise, they are `false`.</span></span> <span data-ttu-id="7593b-3374"><xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> 属性为 `null`。</span><span class="sxs-lookup"><span data-stu-id="7593b-3374">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="7593b-3375">以下信息描述了实现方法、节点类型以及节点是否已提升。</span><span class="sxs-lookup"><span data-stu-id="7593b-3375">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="7593b-3376">实现方法</span><span class="sxs-lookup"><span data-stu-id="7593b-3376">Implementing Method</span></span>  
 <span data-ttu-id="7593b-3377">以下规则确定为操作选定的实现方法：</span><span class="sxs-lookup"><span data-stu-id="7593b-3377">The following rules determine the selected implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="7593b-3378">如果 `left` 或 `right` 的 <xref:System.Linq.Expressions.Expression.Type%2A> 属性表示重载右移位运算符的用户定义类型，则表示该方法的 <xref:System.Reflection.MethodInfo> 是实现方法。</span><span class="sxs-lookup"><span data-stu-id="7593b-3378">If the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the right-shift operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="7593b-3379">否则，如果 `left`。类型为整型类型（<xref:System.Byte>、<xref:System.SByte>、<xref:System.Int16>、<xref:System.UInt16>、<xref:System.Int32>、<xref:System.UInt32>、<xref:System.Int64>、<xref:System.UInt64>或对应的可以为 null 的类型）和 `right`。类型为 <xref:System.Int32>，则实现方法为 `null`。</span><span class="sxs-lookup"><span data-stu-id="7593b-3379">Otherwise, if `left`.Type is an integral type (one of <xref:System.Byte>, <xref:System.SByte>, <xref:System.Int16>, <xref:System.UInt16>, <xref:System.Int32>, <xref:System.UInt32>, <xref:System.Int64>, <xref:System.UInt64>, or the corresponding nullable types) and `right`.Type is <xref:System.Int32>, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="7593b-3380">节点类型和提升和非提升</span><span class="sxs-lookup"><span data-stu-id="7593b-3380">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="7593b-3381">如果不 `null`实现方法：</span><span class="sxs-lookup"><span data-stu-id="7593b-3381">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="7593b-3382">如果 `left`。键入并 `right`。类型可分配给实现方法的相应参数类型，不提升节点。</span><span class="sxs-lookup"><span data-stu-id="7593b-3382">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="7593b-3383">节点的类型是实现方法的返回类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-3383">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="7593b-3384">如果满足以下两个条件，则会提升节点，并且该节点的类型为与实现方法的返回类型对应的可以为 null 的类型：</span><span class="sxs-lookup"><span data-stu-id="7593b-3384">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="7593b-3385">`left`。键入并 `right`。类型既是值类型，其中至少有一个可为 null，并且相应的不可为 null 的类型等于实现方法的相应参数类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-3385">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="7593b-3386">实现方法的返回类型是不可为 null 的值类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-3386">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="7593b-3387">如果实现方法为 `null`：</span><span class="sxs-lookup"><span data-stu-id="7593b-3387">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="7593b-3388">如果 `left`。键入并 `right`。类型不可以为 null，则不提升节点。</span><span class="sxs-lookup"><span data-stu-id="7593b-3388">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="7593b-3389">节点的类型为预定义右移位运算符的结果类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-3389">The type of the node is the result type of the predefined right-shift operator.</span></span>  
  
-   <span data-ttu-id="7593b-3390">如果 `left`。键入并 `right`。类型均可为 null，则提升节点。</span><span class="sxs-lookup"><span data-stu-id="7593b-3390">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="7593b-3391">节点的类型是与预定义右移位运算符的结果类型对应的可以为 null 的类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-3391">The type of the node is the nullable type that corresponds to the result type of the predefined right-shift operator.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="7593b-3392"><paramref name="left" /> 或 <paramref name="right" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-3392"><paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="7593b-3393">没有为 <paramref name="left" />.Type 和 <paramref name="right" />.Type 定义右移位运算符。</span><span class="sxs-lookup"><span data-stu-id="7593b-3393">The right-shift operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="RightShift">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression RightShift (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression RightShift(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.RightShift(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RightShift (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ RightShift(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member RightShift : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.RightShift (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="7593b-3394">要将 <see cref="T:System.Linq.Expressions.Expression" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-3394">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="7593b-3395">要将 <see cref="T:System.Linq.Expressions.Expression" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-3395">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <param name="method"><span data-ttu-id="7593b-3396">要将 <see cref="T:System.Reflection.MethodInfo" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-3396">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="7593b-3397">创建一个表示按位右移运算的 <see cref="T:System.Linq.Expressions.BinaryExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-3397">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise right-shift operation.</span></span></summary>
        <returns><span data-ttu-id="7593b-3398">一个 <see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 属性等于 <see cref="F:System.Linq.Expressions.ExpressionType.RightShift" />，并且其 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />、<see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> 属性设置为指定值。</span><span class="sxs-lookup"><span data-stu-id="7593b-3398">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.RightShift" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7593b-3399">生成的 <xref:System.Linq.Expressions.BinaryExpression> 具有设置为实现方法的 <xref:System.Linq.Expressions.BinaryExpression.Method%2A> 属性。</span><span class="sxs-lookup"><span data-stu-id="7593b-3399">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="7593b-3400"><xref:System.Linq.Expressions.Expression.Type%2A> 属性设置为节点的类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-3400">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="7593b-3401">如果节点已提升，则 <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> 和 <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> 属性均 `true`。</span><span class="sxs-lookup"><span data-stu-id="7593b-3401">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="7593b-3402">否则，它们 `false`。</span><span class="sxs-lookup"><span data-stu-id="7593b-3402">Otherwise, they are `false`.</span></span> <span data-ttu-id="7593b-3403"><xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> 属性为 `null`。</span><span class="sxs-lookup"><span data-stu-id="7593b-3403">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="7593b-3404">以下信息描述了实现方法、节点类型以及节点是否已提升。</span><span class="sxs-lookup"><span data-stu-id="7593b-3404">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="7593b-3405">实现方法</span><span class="sxs-lookup"><span data-stu-id="7593b-3405">Implementing Method</span></span>  
 <span data-ttu-id="7593b-3406">以下规则确定为操作选定的实现方法：</span><span class="sxs-lookup"><span data-stu-id="7593b-3406">The following rules determine the selected implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="7593b-3407">如果 `method` 未 `null` 并且它表示采用两个自变量的非 void、`static``Shared` （Visual Basic）方法，则它是节点的实现方法。</span><span class="sxs-lookup"><span data-stu-id="7593b-3407">If `method` is not `null` and it represents a non-void, `static` (`Shared` in Visual Basic) method that takes two arguments, it is the implementing method for the node.</span></span>  
  
-   <span data-ttu-id="7593b-3408">否则，如果 `left` 或 `right` 的 <xref:System.Linq.Expressions.Expression.Type%2A> 属性表示重载右移位运算符的用户定义的类型，则表示该方法的 <xref:System.Reflection.MethodInfo> 是实现方法。</span><span class="sxs-lookup"><span data-stu-id="7593b-3408">Otherwise, if the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the right-shift operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="7593b-3409">否则，如果 `left`。类型为整型类型（<xref:System.Byte>、<xref:System.SByte>、<xref:System.Int16>、<xref:System.UInt16>、<xref:System.Int32>、<xref:System.UInt32>、<xref:System.Int64>、<xref:System.UInt64>或对应的可以为 null 的类型）和 `right`。类型为 <xref:System.Int32>，则实现方法为 `null`。</span><span class="sxs-lookup"><span data-stu-id="7593b-3409">Otherwise, if `left`.Type is an integral type (one of <xref:System.Byte>, <xref:System.SByte>, <xref:System.Int16>, <xref:System.UInt16>, <xref:System.Int32>, <xref:System.UInt32>, <xref:System.Int64>, <xref:System.UInt64>, or the corresponding nullable types) and `right`.Type is <xref:System.Int32>, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="7593b-3410">节点类型和提升和非提升</span><span class="sxs-lookup"><span data-stu-id="7593b-3410">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="7593b-3411">如果不 `null`实现方法：</span><span class="sxs-lookup"><span data-stu-id="7593b-3411">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="7593b-3412">如果 `left`。键入并 `right`。类型可分配给实现方法的相应参数类型，不提升节点。</span><span class="sxs-lookup"><span data-stu-id="7593b-3412">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="7593b-3413">节点的类型是实现方法的返回类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-3413">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="7593b-3414">如果满足以下两个条件，则会提升节点，并且该节点的类型为与实现方法的返回类型对应的可以为 null 的类型：</span><span class="sxs-lookup"><span data-stu-id="7593b-3414">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="7593b-3415">`left`。键入并 `right`。类型既是值类型，其中至少有一个可为 null，并且相应的不可为 null 的类型等于实现方法的相应参数类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-3415">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="7593b-3416">实现方法的返回类型是不可为 null 的值类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-3416">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="7593b-3417">如果实现方法为 `null`：</span><span class="sxs-lookup"><span data-stu-id="7593b-3417">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="7593b-3418">如果 `left`。键入并 `right`。类型不可以为 null，则不提升节点。</span><span class="sxs-lookup"><span data-stu-id="7593b-3418">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="7593b-3419">节点的类型为预定义右移位运算符的结果类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-3419">The type of the node is the result type of the predefined right-shift operator.</span></span>  
  
-   <span data-ttu-id="7593b-3420">如果 `left`。键入并 `right`。类型均可为 null，则提升节点。</span><span class="sxs-lookup"><span data-stu-id="7593b-3420">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="7593b-3421">节点的类型是与预定义右移位运算符的结果类型对应的可以为 null 的类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-3421">The type of the node is the nullable type that corresponds to the result type of the predefined right-shift operator.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="7593b-3422"><paramref name="left" /> 或 <paramref name="right" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-3422"><paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="7593b-3423"><paramref name="method" /> 不是 <see langword="null" />，它所表示的方法返回 <see langword="void" />，而不是 <see langword="static" />（Visual Basic 中为 <see langword="Shared" />），或者并非采用两个参数。</span><span class="sxs-lookup"><span data-stu-id="7593b-3423"><paramref name="method" /> is not <see langword="null" /> and the method it represents returns <see langword="void" />, is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic), or does not take exactly two arguments.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="7593b-3424"><paramref name="method" /> 为 <see langword="null" />，并且没有为 <paramref name="left" />.Type 和 <paramref name="right" />.Type 定义右移位运算符。</span><span class="sxs-lookup"><span data-stu-id="7593b-3424"><paramref name="method" /> is <see langword="null" /> and the right-shift operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="RightShiftAssign">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="7593b-3425">创建一个表示按位右移赋值运算的 <see cref="T:System.Linq.Expressions.BinaryExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-3425">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise right-shift assignment operation.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RightShiftAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression RightShiftAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression RightShiftAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.RightShiftAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RightShiftAssign (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ RightShiftAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member RightShiftAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.RightShiftAssign (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="7593b-3426">要将 <see cref="T:System.Linq.Expressions.Expression" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-3426">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="7593b-3427">要将 <see cref="T:System.Linq.Expressions.Expression" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-3427">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="7593b-3428">创建一个表示按位右移赋值运算的 <see cref="T:System.Linq.Expressions.BinaryExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-3428">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise right-shift assignment operation.</span></span></summary>
        <returns><span data-ttu-id="7593b-3429">一个 <see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 属性等于 <see cref="F:System.Linq.Expressions.ExpressionType.RightShiftAssign" />，并且其 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 属性设置为指定值。</span><span class="sxs-lookup"><span data-stu-id="7593b-3429">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.RightShiftAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RightShiftAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression RightShiftAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression RightShiftAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.RightShiftAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RightShiftAssign (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ RightShiftAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member RightShiftAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.RightShiftAssign (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="7593b-3430">要将 <see cref="T:System.Linq.Expressions.Expression" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-3430">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="7593b-3431">要将 <see cref="T:System.Linq.Expressions.Expression" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-3431">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <param name="method"><span data-ttu-id="7593b-3432">要将 <see cref="T:System.Reflection.MethodInfo" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-3432">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="7593b-3433">创建一个表示按位右移赋值运算的 <see cref="T:System.Linq.Expressions.BinaryExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-3433">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise right-shift assignment operation.</span></span></summary>
        <returns><span data-ttu-id="7593b-3434">一个 <see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 属性等于 <see cref="F:System.Linq.Expressions.ExpressionType.RightShiftAssign" />，并且其 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />、<see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> 属性设置为指定值。</span><span class="sxs-lookup"><span data-stu-id="7593b-3434">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.RightShiftAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RightShiftAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression RightShiftAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method, System.Linq.Expressions.LambdaExpression conversion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression RightShiftAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method, class System.Linq.Expressions.LambdaExpression conversion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.RightShiftAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RightShiftAssign (left As Expression, right As Expression, method As MethodInfo, conversion As LambdaExpression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ RightShiftAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method, System::Linq::Expressions::LambdaExpression ^ conversion);" />
      <MemberSignature Language="F#" Value="static member RightShiftAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo * System.Linq.Expressions.LambdaExpression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.RightShiftAssign (left, right, method, conversion)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="conversion" Type="System.Linq.Expressions.LambdaExpression" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="7593b-3435">要将 <see cref="T:System.Linq.Expressions.Expression" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-3435">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="7593b-3436">要将 <see cref="T:System.Linq.Expressions.Expression" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-3436">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <param name="method"><span data-ttu-id="7593b-3437">要将 <see cref="T:System.Reflection.MethodInfo" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-3437">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span></span></param>
        <param name="conversion"><span data-ttu-id="7593b-3438">要将 <see cref="T:System.Linq.Expressions.LambdaExpression" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-3438">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="7593b-3439">创建一个表示按位右移赋值运算的 <see cref="T:System.Linq.Expressions.BinaryExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-3439">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise right-shift assignment operation.</span></span></summary>
        <returns><span data-ttu-id="7593b-3440">一个 <see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 属性等于 <see cref="F:System.Linq.Expressions.ExpressionType.RightShiftAssign" />，并且其 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />、<see cref="P:System.Linq.Expressions.BinaryExpression.Right" />、<see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> 属性设置为指定值。</span><span class="sxs-lookup"><span data-stu-id="7593b-3440">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.RightShiftAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="RuntimeVariables">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="7593b-3441">创建 <see cref="T:System.Linq.Expressions.RuntimeVariablesExpression" /> 的实例。</span><span class="sxs-lookup"><span data-stu-id="7593b-3441">Creates an instance of <see cref="T:System.Linq.Expressions.RuntimeVariablesExpression" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RuntimeVariables">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.RuntimeVariablesExpression RuntimeVariables (System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; variables);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.RuntimeVariablesExpression RuntimeVariables(class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; variables) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.RuntimeVariables(System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RuntimeVariables (variables As IEnumerable(Of ParameterExpression)) As RuntimeVariablesExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::RuntimeVariablesExpression ^ RuntimeVariables(System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ variables);" />
      <MemberSignature Language="F#" Value="static member RuntimeVariables : seq&lt;System.Linq.Expressions.ParameterExpression&gt; -&gt; System.Linq.Expressions.RuntimeVariablesExpression" Usage="System.Linq.Expressions.Expression.RuntimeVariables variables" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.RuntimeVariablesExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="variables" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="variables"><span data-ttu-id="7593b-3442">用于填充 <see cref="T:System.Linq.Expressions.ParameterExpression" /> 集合的 <see cref="P:System.Linq.Expressions.RuntimeVariablesExpression.Variables" /> 对象的集合。</span><span class="sxs-lookup"><span data-stu-id="7593b-3442">A collection of <see cref="T:System.Linq.Expressions.ParameterExpression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.RuntimeVariablesExpression.Variables" /> collection.</span></span></param>
        <summary><span data-ttu-id="7593b-3443">创建 <see cref="T:System.Linq.Expressions.RuntimeVariablesExpression" /> 的实例。</span><span class="sxs-lookup"><span data-stu-id="7593b-3443">Creates an instance of <see cref="T:System.Linq.Expressions.RuntimeVariablesExpression" />.</span></span></summary>
        <returns><span data-ttu-id="7593b-3444">一个 <see cref="T:System.Linq.Expressions.RuntimeVariablesExpression" /> 的实例，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 属性等于 <see cref="F:System.Linq.Expressions.ExpressionType.RuntimeVariables" />，并且其 <see cref="P:System.Linq.Expressions.RuntimeVariablesExpression.Variables" /> 属性设置为指定的值。</span><span class="sxs-lookup"><span data-stu-id="7593b-3444">An instance of <see cref="T:System.Linq.Expressions.RuntimeVariablesExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.RuntimeVariables" /> and the <see cref="P:System.Linq.Expressions.RuntimeVariablesExpression.Variables" /> property set to the specified value.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RuntimeVariables">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.RuntimeVariablesExpression RuntimeVariables (params System.Linq.Expressions.ParameterExpression[] variables);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.RuntimeVariablesExpression RuntimeVariables(class System.Linq.Expressions.ParameterExpression[] variables) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.RuntimeVariables(System.Linq.Expressions.ParameterExpression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RuntimeVariables (ParamArray variables As ParameterExpression()) As RuntimeVariablesExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::RuntimeVariablesExpression ^ RuntimeVariables(... cli::array &lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ variables);" />
      <MemberSignature Language="F#" Value="static member RuntimeVariables : System.Linq.Expressions.ParameterExpression[] -&gt; System.Linq.Expressions.RuntimeVariablesExpression" Usage="System.Linq.Expressions.Expression.RuntimeVariables variables" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.RuntimeVariablesExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="variables" Type="System.Linq.Expressions.ParameterExpression[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="variables"><span data-ttu-id="7593b-3445">用于填充 <see cref="T:System.Linq.Expressions.ParameterExpression" /> 集合的 <see cref="P:System.Linq.Expressions.RuntimeVariablesExpression.Variables" /> 对象的数组。</span><span class="sxs-lookup"><span data-stu-id="7593b-3445">An array of <see cref="T:System.Linq.Expressions.ParameterExpression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.RuntimeVariablesExpression.Variables" /> collection.</span></span></param>
        <summary><span data-ttu-id="7593b-3446">创建 <see cref="T:System.Linq.Expressions.RuntimeVariablesExpression" /> 的实例。</span><span class="sxs-lookup"><span data-stu-id="7593b-3446">Creates an instance of <see cref="T:System.Linq.Expressions.RuntimeVariablesExpression" />.</span></span></summary>
        <returns><span data-ttu-id="7593b-3447">一个 <see cref="T:System.Linq.Expressions.RuntimeVariablesExpression" /> 的实例，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 属性等于 <see cref="F:System.Linq.Expressions.ExpressionType.RuntimeVariables" />，并且其 <see cref="P:System.Linq.Expressions.RuntimeVariablesExpression.Variables" /> 属性设置为指定的值。</span><span class="sxs-lookup"><span data-stu-id="7593b-3447">An instance of <see cref="T:System.Linq.Expressions.RuntimeVariablesExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.RuntimeVariables" /> and the <see cref="P:System.Linq.Expressions.RuntimeVariablesExpression.Variables" /> property set to the specified value.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Subtract">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="7593b-3448">创建一个表示不进行溢出检查的算术减法运算的 <see cref="T:System.Linq.Expressions.BinaryExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-3448">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an arithmetic subtraction operation that does not have overflow checking.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Subtract">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Subtract (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Subtract(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Subtract(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Subtract (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Subtract(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member Subtract : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.Subtract (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="7593b-3449">要将 <see cref="T:System.Linq.Expressions.Expression" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-3449">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="7593b-3450">要将 <see cref="T:System.Linq.Expressions.Expression" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-3450">A <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="7593b-3451">创建一个表示不进行溢出检查的算术减法运算的 <see cref="T:System.Linq.Expressions.BinaryExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-3451">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an arithmetic subtraction operation that does not have overflow checking.</span></span></summary>
        <returns><span data-ttu-id="7593b-3452">一个 <see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 属性等于 <see cref="F:System.Linq.Expressions.ExpressionType.Subtract" />，并且其 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 属性设置为指定值。</span><span class="sxs-lookup"><span data-stu-id="7593b-3452">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Subtract" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7593b-3453">生成的 <xref:System.Linq.Expressions.BinaryExpression> 具有设置为实现方法的 <xref:System.Linq.Expressions.BinaryExpression.Method%2A> 属性。</span><span class="sxs-lookup"><span data-stu-id="7593b-3453">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="7593b-3454"><xref:System.Linq.Expressions.Expression.Type%2A> 属性设置为节点的类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-3454">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="7593b-3455">如果节点已提升，则 <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> 和 <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> 属性均 `true`。</span><span class="sxs-lookup"><span data-stu-id="7593b-3455">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="7593b-3456">否则，它们 `false`。</span><span class="sxs-lookup"><span data-stu-id="7593b-3456">Otherwise, they are `false`.</span></span> <span data-ttu-id="7593b-3457"><xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> 属性为 `null`。</span><span class="sxs-lookup"><span data-stu-id="7593b-3457">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="7593b-3458">以下信息描述了实现方法、节点类型以及节点是否已提升。</span><span class="sxs-lookup"><span data-stu-id="7593b-3458">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="7593b-3459">实现方法</span><span class="sxs-lookup"><span data-stu-id="7593b-3459">Implementing Method</span></span>  
 <span data-ttu-id="7593b-3460">以下规则确定为操作选定的实现方法：</span><span class="sxs-lookup"><span data-stu-id="7593b-3460">The following rules determine the selected implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="7593b-3461">如果 `left` 或 `right` 的 <xref:System.Linq.Expressions.Expression.Type%2A> 属性表示重载减法运算符的用户定义类型，则表示该方法的 <xref:System.Reflection.MethodInfo> 是实现方法。</span><span class="sxs-lookup"><span data-stu-id="7593b-3461">If the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the subtraction operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="7593b-3462">否则，如果 `left`。键入并 `right`。类型为数值类型，则实现方法为 `null`。</span><span class="sxs-lookup"><span data-stu-id="7593b-3462">Otherwise, if `left`.Type and `right`.Type are numeric types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="7593b-3463">节点类型和提升和非提升</span><span class="sxs-lookup"><span data-stu-id="7593b-3463">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="7593b-3464">如果不 `null`实现方法：</span><span class="sxs-lookup"><span data-stu-id="7593b-3464">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="7593b-3465">如果 `left`。键入并 `right`。类型可分配给实现方法的相应参数类型，不提升节点。</span><span class="sxs-lookup"><span data-stu-id="7593b-3465">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="7593b-3466">节点的类型是实现方法的返回类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-3466">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="7593b-3467">如果满足以下两个条件，则会提升节点，并且该节点的类型为与实现方法的返回类型对应的可以为 null 的类型：</span><span class="sxs-lookup"><span data-stu-id="7593b-3467">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="7593b-3468">`left`。键入并 `right`。类型既是值类型，其中至少有一个可为 null，并且相应的不可为 null 的类型等于实现方法的相应参数类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-3468">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="7593b-3469">实现方法的返回类型是不可为 null 的值类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-3469">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="7593b-3470">如果实现方法为 `null`：</span><span class="sxs-lookup"><span data-stu-id="7593b-3470">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="7593b-3471">如果 `left`。键入并 `right`。类型不可以为 null，则不提升节点。</span><span class="sxs-lookup"><span data-stu-id="7593b-3471">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="7593b-3472">节点的类型为预定义减法运算符的结果类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-3472">The type of the node is the result type of the predefined subtraction operator.</span></span>  
  
-   <span data-ttu-id="7593b-3473">如果 `left`。键入并 `right`。类型均可为 null，则提升节点。</span><span class="sxs-lookup"><span data-stu-id="7593b-3473">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="7593b-3474">节点的类型是与预定义减法运算符的结果类型对应的可以为 null 的类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-3474">The type of the node is the nullable type that corresponds to the result type of the predefined subtraction operator.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="7593b-3475">下面的代码示例演示如何创建从第一个参数中减去自变量的表达式。</span><span class="sxs-lookup"><span data-stu-id="7593b-3475">The following code example shows how to create an expression that subtracts the argument from the first argument.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#30](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#30)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#30](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#30)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="7593b-3476"><paramref name="left" /> 或 <paramref name="right" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-3476"><paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="7593b-3477">没有为 <paramref name="left" />.Type 和 <paramref name="right" />.Type 定义减法运算符。</span><span class="sxs-lookup"><span data-stu-id="7593b-3477">The subtraction operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Subtract">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Subtract (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Subtract(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Subtract(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Subtract (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Subtract(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member Subtract : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.Subtract (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="7593b-3478">要将 <see cref="T:System.Linq.Expressions.Expression" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-3478">A <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="7593b-3479">要将 <see cref="T:System.Linq.Expressions.Expression" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-3479">A <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <param name="method"><span data-ttu-id="7593b-3480">要将 <see cref="T:System.Reflection.MethodInfo" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-3480">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="7593b-3481">创建一个表示不进行溢出检查的算术减法运算的 <see cref="T:System.Linq.Expressions.BinaryExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-3481">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an arithmetic subtraction operation that does not have overflow checking.</span></span></summary>
        <returns><span data-ttu-id="7593b-3482">一个 <see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 属性等于 <see cref="F:System.Linq.Expressions.ExpressionType.Subtract" />，并且其 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />、<see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> 属性设置为指定值。</span><span class="sxs-lookup"><span data-stu-id="7593b-3482">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Subtract" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7593b-3483">生成的 <xref:System.Linq.Expressions.BinaryExpression> 具有设置为实现方法的 <xref:System.Linq.Expressions.BinaryExpression.Method%2A> 属性。</span><span class="sxs-lookup"><span data-stu-id="7593b-3483">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="7593b-3484"><xref:System.Linq.Expressions.Expression.Type%2A> 属性设置为节点的类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-3484">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="7593b-3485">如果节点已提升，则 <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> 和 <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> 属性均 `true`。</span><span class="sxs-lookup"><span data-stu-id="7593b-3485">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="7593b-3486">否则，它们 `false`。</span><span class="sxs-lookup"><span data-stu-id="7593b-3486">Otherwise, they are `false`.</span></span> <span data-ttu-id="7593b-3487"><xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> 属性为 `null`。</span><span class="sxs-lookup"><span data-stu-id="7593b-3487">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="7593b-3488">以下信息描述了实现方法、节点类型以及节点是否已提升。</span><span class="sxs-lookup"><span data-stu-id="7593b-3488">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="7593b-3489">实现方法</span><span class="sxs-lookup"><span data-stu-id="7593b-3489">Implementing Method</span></span>  
 <span data-ttu-id="7593b-3490">以下规则确定操作的实现方法：</span><span class="sxs-lookup"><span data-stu-id="7593b-3490">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="7593b-3491">如果 `method` 未 `null` 并且它表示采用两个自变量的非 void、`static``Shared` （Visual Basic）方法，则它是节点的实现方法。</span><span class="sxs-lookup"><span data-stu-id="7593b-3491">If `method` is not `null` and it represents a non-void, `static` (`Shared` in Visual Basic) method that takes two arguments, it is the implementing method for the node.</span></span>  
  
-   <span data-ttu-id="7593b-3492">否则，如果 `left` 或 `right` 的 <xref:System.Linq.Expressions.Expression.Type%2A> 属性表示重载减法运算符的用户定义类型，则表示该方法的 <xref:System.Reflection.MethodInfo> 是实现方法。</span><span class="sxs-lookup"><span data-stu-id="7593b-3492">Otherwise, if the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the subtraction operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="7593b-3493">否则，如果 `left`。键入并 `right`。类型为数值类型，则实现方法为 `null`。</span><span class="sxs-lookup"><span data-stu-id="7593b-3493">Otherwise, if `left`.Type and `right`.Type are numeric types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="7593b-3494">节点类型和提升和非提升</span><span class="sxs-lookup"><span data-stu-id="7593b-3494">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="7593b-3495">如果不 `null`实现方法：</span><span class="sxs-lookup"><span data-stu-id="7593b-3495">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="7593b-3496">如果 `left`。键入并 `right`。类型可分配给实现方法的相应参数类型，不提升节点。</span><span class="sxs-lookup"><span data-stu-id="7593b-3496">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="7593b-3497">节点的类型是实现方法的返回类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-3497">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="7593b-3498">如果满足以下两个条件，则会提升节点，并且该节点的类型为与实现方法的返回类型对应的可以为 null 的类型：</span><span class="sxs-lookup"><span data-stu-id="7593b-3498">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="7593b-3499">`left`。键入并 `right`。类型既是值类型，其中至少有一个可为 null，并且相应的不可为 null 的类型等于实现方法的相应参数类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-3499">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="7593b-3500">实现方法的返回类型是不可为 null 的值类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-3500">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="7593b-3501">如果实现方法为 `null`：</span><span class="sxs-lookup"><span data-stu-id="7593b-3501">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="7593b-3502">如果 `left`。键入并 `right`。类型不可以为 null，则不提升节点。</span><span class="sxs-lookup"><span data-stu-id="7593b-3502">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="7593b-3503">节点的类型为预定义减法运算符的结果类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-3503">The type of the node is the result type of the predefined subtraction operator.</span></span>  
  
-   <span data-ttu-id="7593b-3504">如果 `left`。键入并 `right`。类型均可为 null，则提升节点。</span><span class="sxs-lookup"><span data-stu-id="7593b-3504">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="7593b-3505">节点的类型是与预定义减法运算符的结果类型对应的可以为 null 的类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-3505">The type of the node is the nullable type that corresponds to the result type of the predefined subtraction operator.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="7593b-3506"><paramref name="left" /> 或 <paramref name="right" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-3506"><paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="7593b-3507"><paramref name="method" /> 不是 <see langword="null" />，它所表示的方法返回 <see langword="void" />，而不是 <see langword="static" />（Visual Basic 中为 <see langword="Shared" />），或者并非采用两个参数。</span><span class="sxs-lookup"><span data-stu-id="7593b-3507"><paramref name="method" /> is not <see langword="null" /> and the method it represents returns <see langword="void" />, is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic), or does not take exactly two arguments.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="7593b-3508"><paramref name="method" /> 是 <see langword="null" />，且没有为 <paramref name="left" />.Type 和 <paramref name="right" />.Type 定义减法运算符。</span><span class="sxs-lookup"><span data-stu-id="7593b-3508"><paramref name="method" /> is <see langword="null" /> and the subtraction operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="SubtractAssign">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="7593b-3509">创建一个表示不进行溢出检查的减法赋值运算的 <see cref="T:System.Linq.Expressions.BinaryExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-3509">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a subtraction assignment operation that does not have overflow checking.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SubtractAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression SubtractAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression SubtractAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.SubtractAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SubtractAssign (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ SubtractAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member SubtractAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.SubtractAssign (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="7593b-3510">要将 <see cref="T:System.Linq.Expressions.Expression" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-3510">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="7593b-3511">要将 <see cref="T:System.Linq.Expressions.Expression" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-3511">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="7593b-3512">创建一个表示不进行溢出检查的减法赋值运算的 <see cref="T:System.Linq.Expressions.BinaryExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-3512">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a subtraction assignment operation that does not have overflow checking.</span></span></summary>
        <returns><span data-ttu-id="7593b-3513">一个 <see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 属性等于 <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssign" />，并且其 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 属性设置为指定值。</span><span class="sxs-lookup"><span data-stu-id="7593b-3513">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SubtractAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression SubtractAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression SubtractAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.SubtractAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SubtractAssign (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ SubtractAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member SubtractAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.SubtractAssign (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="7593b-3514">要将 <see cref="T:System.Linq.Expressions.Expression" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-3514">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="7593b-3515">要将 <see cref="T:System.Linq.Expressions.Expression" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-3515">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <param name="method"><span data-ttu-id="7593b-3516">要将 <see cref="T:System.Reflection.MethodInfo" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-3516">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="7593b-3517">创建一个表示不进行溢出检查的减法赋值运算的 <see cref="T:System.Linq.Expressions.BinaryExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-3517">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a subtraction assignment operation that does not have overflow checking.</span></span></summary>
        <returns><span data-ttu-id="7593b-3518">一个 <see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 属性等于 <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssign" />，并且其 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />、<see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> 属性设置为指定值。</span><span class="sxs-lookup"><span data-stu-id="7593b-3518">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SubtractAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression SubtractAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method, System.Linq.Expressions.LambdaExpression conversion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression SubtractAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method, class System.Linq.Expressions.LambdaExpression conversion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.SubtractAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SubtractAssign (left As Expression, right As Expression, method As MethodInfo, conversion As LambdaExpression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ SubtractAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method, System::Linq::Expressions::LambdaExpression ^ conversion);" />
      <MemberSignature Language="F#" Value="static member SubtractAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo * System.Linq.Expressions.LambdaExpression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.SubtractAssign (left, right, method, conversion)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="conversion" Type="System.Linq.Expressions.LambdaExpression" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="7593b-3519">要将 <see cref="T:System.Linq.Expressions.Expression" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-3519">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="7593b-3520">要将 <see cref="T:System.Linq.Expressions.Expression" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-3520">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <param name="method"><span data-ttu-id="7593b-3521">要将 <see cref="T:System.Reflection.MethodInfo" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-3521">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span></span></param>
        <param name="conversion"><span data-ttu-id="7593b-3522">要将 <see cref="T:System.Linq.Expressions.LambdaExpression" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-3522">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="7593b-3523">创建一个表示不进行溢出检查的减法赋值运算的 <see cref="T:System.Linq.Expressions.BinaryExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-3523">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a subtraction assignment operation that does not have overflow checking.</span></span></summary>
        <returns><span data-ttu-id="7593b-3524">一个 <see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 属性等于 <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssign" />，并且其 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />、<see cref="P:System.Linq.Expressions.BinaryExpression.Right" />、<see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> 属性设置为指定值。</span><span class="sxs-lookup"><span data-stu-id="7593b-3524">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="SubtractAssignChecked">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="7593b-3525">创建一个表示进行溢出检查的减法赋值运算的 <see cref="T:System.Linq.Expressions.BinaryExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-3525">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a subtraction assignment operation that has overflow checking.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SubtractAssignChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression SubtractAssignChecked (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression SubtractAssignChecked(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.SubtractAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SubtractAssignChecked (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ SubtractAssignChecked(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member SubtractAssignChecked : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.SubtractAssignChecked (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="7593b-3526">要将 <see cref="T:System.Linq.Expressions.Expression" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-3526">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="7593b-3527">要将 <see cref="T:System.Linq.Expressions.Expression" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-3527">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="7593b-3528">创建一个表示进行溢出检查的减法赋值运算的 <see cref="T:System.Linq.Expressions.BinaryExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-3528">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a subtraction assignment operation that has overflow checking.</span></span></summary>
        <returns><span data-ttu-id="7593b-3529">一个 <see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 属性等于 <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssignChecked" />，并且其 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 属性设置为指定值。</span><span class="sxs-lookup"><span data-stu-id="7593b-3529">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssignChecked" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SubtractAssignChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression SubtractAssignChecked (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression SubtractAssignChecked(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.SubtractAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SubtractAssignChecked (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ SubtractAssignChecked(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member SubtractAssignChecked : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.SubtractAssignChecked (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="7593b-3530">要将 <see cref="T:System.Linq.Expressions.Expression" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-3530">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="7593b-3531">要将 <see cref="T:System.Linq.Expressions.Expression" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-3531">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <param name="method"><span data-ttu-id="7593b-3532">要将 <see cref="T:System.Reflection.MethodInfo" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-3532">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="7593b-3533">创建一个表示进行溢出检查的减法赋值运算的 <see cref="T:System.Linq.Expressions.BinaryExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-3533">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a subtraction assignment operation that has overflow checking.</span></span></summary>
        <returns><span data-ttu-id="7593b-3534">一个 <see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 属性等于 <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssignChecked" />，并且其 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />、<see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> 属性设置为指定值。</span><span class="sxs-lookup"><span data-stu-id="7593b-3534">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssignChecked" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SubtractAssignChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression SubtractAssignChecked (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method, System.Linq.Expressions.LambdaExpression conversion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression SubtractAssignChecked(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method, class System.Linq.Expressions.LambdaExpression conversion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.SubtractAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SubtractAssignChecked (left As Expression, right As Expression, method As MethodInfo, conversion As LambdaExpression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ SubtractAssignChecked(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method, System::Linq::Expressions::LambdaExpression ^ conversion);" />
      <MemberSignature Language="F#" Value="static member SubtractAssignChecked : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo * System.Linq.Expressions.LambdaExpression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.SubtractAssignChecked (left, right, method, conversion)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="conversion" Type="System.Linq.Expressions.LambdaExpression" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="7593b-3535">要将 <see cref="T:System.Linq.Expressions.Expression" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-3535">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="7593b-3536">要将 <see cref="T:System.Linq.Expressions.Expression" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-3536">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <param name="method"><span data-ttu-id="7593b-3537">要将 <see cref="T:System.Reflection.MethodInfo" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-3537">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span></span></param>
        <param name="conversion"><span data-ttu-id="7593b-3538">要将 <see cref="T:System.Linq.Expressions.LambdaExpression" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-3538">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="7593b-3539">创建一个表示进行溢出检查的减法赋值运算的 <see cref="T:System.Linq.Expressions.BinaryExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-3539">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a subtraction assignment operation that has overflow checking.</span></span></summary>
        <returns><span data-ttu-id="7593b-3540">一个 <see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 属性等于 <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssignChecked" />，并且其 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />、<see cref="P:System.Linq.Expressions.BinaryExpression.Right" />、<see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> 属性设置为指定值。</span><span class="sxs-lookup"><span data-stu-id="7593b-3540">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssignChecked" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="SubtractChecked">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="7593b-3541">创建一个表示进行溢出检查的算术减法运算的 <see cref="T:System.Linq.Expressions.BinaryExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-3541">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an arithmetic subtraction operation that has overflow checking.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SubtractChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression SubtractChecked (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression SubtractChecked(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.SubtractChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SubtractChecked (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ SubtractChecked(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member SubtractChecked : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.SubtractChecked (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="7593b-3542">要将 <see cref="T:System.Linq.Expressions.Expression" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-3542">A <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="7593b-3543">要将 <see cref="T:System.Linq.Expressions.Expression" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-3543">A <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="7593b-3544">创建一个表示进行溢出检查的算术减法运算的 <see cref="T:System.Linq.Expressions.BinaryExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-3544">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an arithmetic subtraction operation that has overflow checking.</span></span></summary>
        <returns><span data-ttu-id="7593b-3545">一个 <see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 属性等于 <see cref="F:System.Linq.Expressions.ExpressionType.SubtractChecked" />，并且其 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 属性设置为指定值。</span><span class="sxs-lookup"><span data-stu-id="7593b-3545">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.SubtractChecked" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7593b-3546">生成的 <xref:System.Linq.Expressions.BinaryExpression> 具有设置为实现方法的 <xref:System.Linq.Expressions.BinaryExpression.Method%2A> 属性。</span><span class="sxs-lookup"><span data-stu-id="7593b-3546">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="7593b-3547"><xref:System.Linq.Expressions.Expression.Type%2A> 属性设置为节点的类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-3547">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="7593b-3548">如果节点已提升，则 <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> 和 <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> 属性均 `true`。</span><span class="sxs-lookup"><span data-stu-id="7593b-3548">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="7593b-3549">否则，它们 `false`。</span><span class="sxs-lookup"><span data-stu-id="7593b-3549">Otherwise, they are `false`.</span></span> <span data-ttu-id="7593b-3550"><xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> 属性为 `null`。</span><span class="sxs-lookup"><span data-stu-id="7593b-3550">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="7593b-3551">以下信息描述了实现方法、节点类型以及节点是否已提升。</span><span class="sxs-lookup"><span data-stu-id="7593b-3551">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="7593b-3552">实现方法</span><span class="sxs-lookup"><span data-stu-id="7593b-3552">Implementing Method</span></span>  
 <span data-ttu-id="7593b-3553">以下规则确定为操作选定的实现方法：</span><span class="sxs-lookup"><span data-stu-id="7593b-3553">The following rules determine the selected implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="7593b-3554">如果 `left` 或 `right` 的 <xref:System.Linq.Expressions.Expression.Type%2A> 属性表示重载减法运算符的用户定义类型，则表示该方法的 <xref:System.Reflection.MethodInfo> 是实现方法。</span><span class="sxs-lookup"><span data-stu-id="7593b-3554">If the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the subtraction operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="7593b-3555">否则，如果 `left`。键入并 `right`。类型为数值类型，则实现方法为 `null`。</span><span class="sxs-lookup"><span data-stu-id="7593b-3555">Otherwise, if `left`.Type and `right`.Type are numeric types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="7593b-3556">节点类型和提升和非提升</span><span class="sxs-lookup"><span data-stu-id="7593b-3556">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="7593b-3557">如果不 `null`实现方法：</span><span class="sxs-lookup"><span data-stu-id="7593b-3557">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="7593b-3558">如果 `left`。键入并 `right`。类型可分配给实现方法的相应参数类型，不提升节点。</span><span class="sxs-lookup"><span data-stu-id="7593b-3558">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="7593b-3559">节点的类型是实现方法的返回类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-3559">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="7593b-3560">如果满足以下两个条件，则会提升节点，并且该节点的类型为与实现方法的返回类型对应的可以为 null 的类型：</span><span class="sxs-lookup"><span data-stu-id="7593b-3560">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="7593b-3561">`left`。键入并 `right`。类型既是值类型，其中至少有一个可为 null，并且相应的不可为 null 的类型等于实现方法的相应参数类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-3561">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="7593b-3562">实现方法的返回类型是不可为 null 的值类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-3562">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="7593b-3563">如果实现方法为 `null`：</span><span class="sxs-lookup"><span data-stu-id="7593b-3563">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="7593b-3564">如果 `left`。键入并 `right`。类型不可以为 null，则不提升节点。</span><span class="sxs-lookup"><span data-stu-id="7593b-3564">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="7593b-3565">节点的类型为预定义减法运算符的结果类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-3565">The type of the node is the result type of the predefined subtraction operator.</span></span>  
  
-   <span data-ttu-id="7593b-3566">如果 `left`。键入并 `right`。类型均可为 null，则提升节点。</span><span class="sxs-lookup"><span data-stu-id="7593b-3566">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="7593b-3567">节点的类型是与预定义减法运算符的结果类型对应的可以为 null 的类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-3567">The type of the node is the nullable type that corresponds to the result type of the predefined subtraction operator.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="7593b-3568"><paramref name="left" /> 或 <paramref name="right" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-3568"><paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="7593b-3569">没有为 <paramref name="left" />.Type 和 <paramref name="right" />.Type 定义减法运算符。</span><span class="sxs-lookup"><span data-stu-id="7593b-3569">The subtraction operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="SubtractChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression SubtractChecked (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression SubtractChecked(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.SubtractChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SubtractChecked (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ SubtractChecked(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member SubtractChecked : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.SubtractChecked (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="7593b-3570">要将 <see cref="T:System.Linq.Expressions.Expression" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-3570">A <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="7593b-3571">要将 <see cref="T:System.Linq.Expressions.Expression" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-3571">A <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <param name="method"><span data-ttu-id="7593b-3572">要将 <see cref="T:System.Reflection.MethodInfo" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-3572">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="7593b-3573">创建一个表示进行溢出检查的算术减法运算的 <see cref="T:System.Linq.Expressions.BinaryExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-3573">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an arithmetic subtraction operation that has overflow checking.</span></span></summary>
        <returns><span data-ttu-id="7593b-3574">一个 <see cref="T:System.Linq.Expressions.BinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 属性等于 <see cref="F:System.Linq.Expressions.ExpressionType.SubtractChecked" />，并且其 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />、<see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 和 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> 属性设置为指定值。</span><span class="sxs-lookup"><span data-stu-id="7593b-3574">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.SubtractChecked" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7593b-3575">生成的 <xref:System.Linq.Expressions.BinaryExpression> 具有设置为实现方法的 <xref:System.Linq.Expressions.BinaryExpression.Method%2A> 属性。</span><span class="sxs-lookup"><span data-stu-id="7593b-3575">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="7593b-3576"><xref:System.Linq.Expressions.Expression.Type%2A> 属性设置为节点的类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-3576">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="7593b-3577">如果节点已提升，则 <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> 和 <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> 属性均 `true`。</span><span class="sxs-lookup"><span data-stu-id="7593b-3577">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="7593b-3578">否则，它们 `false`。</span><span class="sxs-lookup"><span data-stu-id="7593b-3578">Otherwise, they are `false`.</span></span> <span data-ttu-id="7593b-3579"><xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> 属性为 `null`。</span><span class="sxs-lookup"><span data-stu-id="7593b-3579">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="7593b-3580">以下信息描述了实现方法、节点类型以及节点是否已提升。</span><span class="sxs-lookup"><span data-stu-id="7593b-3580">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="7593b-3581">实现方法</span><span class="sxs-lookup"><span data-stu-id="7593b-3581">Implementing Method</span></span>  
 <span data-ttu-id="7593b-3582">以下规则确定操作的实现方法：</span><span class="sxs-lookup"><span data-stu-id="7593b-3582">The following rules determine the implementing method for the operation :</span></span>  
  
-   <span data-ttu-id="7593b-3583">如果 `method` 未 `null` 并且它表示采用两个自变量的非 void、`static``Shared` （Visual Basic）方法，则它是节点的实现方法。</span><span class="sxs-lookup"><span data-stu-id="7593b-3583">If `method` is not `null` and it represents a non-void, `static` (`Shared` in Visual Basic) method that takes two arguments, it is the implementing method for the node.</span></span>  
  
-   <span data-ttu-id="7593b-3584">否则，如果 `left` 或 `right` 的 <xref:System.Linq.Expressions.Expression.Type%2A> 属性表示重载减法运算符的用户定义类型，则表示该方法的 <xref:System.Reflection.MethodInfo> 是实现方法。</span><span class="sxs-lookup"><span data-stu-id="7593b-3584">Otherwise, if the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the subtraction operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="7593b-3585">否则，如果 `left`。键入并 `right`。类型为数值类型，则实现方法为 `null`。</span><span class="sxs-lookup"><span data-stu-id="7593b-3585">Otherwise, if `left`.Type and `right`.Type are numeric types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="7593b-3586">节点类型和提升和非提升</span><span class="sxs-lookup"><span data-stu-id="7593b-3586">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="7593b-3587">如果不 `null`实现方法：</span><span class="sxs-lookup"><span data-stu-id="7593b-3587">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="7593b-3588">如果 `left`。键入并 `right`。类型可分配给实现方法的相应参数类型，不提升节点。</span><span class="sxs-lookup"><span data-stu-id="7593b-3588">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="7593b-3589">节点的类型是实现方法的返回类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-3589">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="7593b-3590">如果满足以下两个条件，则会提升节点，并且该节点的类型为与实现方法的返回类型对应的可以为 null 的类型：</span><span class="sxs-lookup"><span data-stu-id="7593b-3590">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="7593b-3591">`left`。键入并 `right`。类型既是值类型，其中至少有一个可为 null，并且相应的不可为 null 的类型等于实现方法的相应参数类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-3591">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="7593b-3592">实现方法的返回类型是不可为 null 的值类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-3592">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="7593b-3593">如果实现方法为 `null`：</span><span class="sxs-lookup"><span data-stu-id="7593b-3593">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="7593b-3594">如果 `left`。键入并 `right`。类型不可以为 null，则不提升节点。</span><span class="sxs-lookup"><span data-stu-id="7593b-3594">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="7593b-3595">节点的类型为预定义减法运算符的结果类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-3595">The type of the node is the result type of the predefined subtraction operator.</span></span>  
  
-   <span data-ttu-id="7593b-3596">如果 `left`。键入并 `right`。类型均可为 null，则提升节点。</span><span class="sxs-lookup"><span data-stu-id="7593b-3596">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="7593b-3597">节点的类型是与预定义减法运算符的结果类型对应的可以为 null 的类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-3597">The type of the node is the nullable type that corresponds to the result type of the predefined subtraction operator.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="7593b-3598"><paramref name="left" /> 或 <paramref name="right" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-3598"><paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="7593b-3599"><paramref name="method" /> 不是 <see langword="null" />，它所表示的方法返回 <see langword="void" />，而不是 <see langword="static" />（Visual Basic 中为 <see langword="Shared" />），或者并非采用两个参数。</span><span class="sxs-lookup"><span data-stu-id="7593b-3599"><paramref name="method" /> is not <see langword="null" /> and the method it represents returns <see langword="void" />, is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic), or does not take exactly two arguments.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="7593b-3600"><paramref name="method" /> 是 <see langword="null" />，且没有为 <paramref name="left" />.Type 和 <paramref name="right" />.Type 定义减法运算符。</span><span class="sxs-lookup"><span data-stu-id="7593b-3600"><paramref name="method" /> is <see langword="null" /> and the subtraction operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Switch">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="7593b-3601">创建一个表示 <see cref="T:System.Linq.Expressions.SwitchExpression" /> 语句的 <see langword="switch" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-3601">Creates a <see cref="T:System.Linq.Expressions.SwitchExpression" /> that represents a <see langword="switch" /> statement.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Switch">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.SwitchExpression Switch (System.Linq.Expressions.Expression switchValue, params System.Linq.Expressions.SwitchCase[] cases);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.SwitchExpression Switch(class System.Linq.Expressions.Expression switchValue, class System.Linq.Expressions.SwitchCase[] cases) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Switch(System.Linq.Expressions.Expression,System.Linq.Expressions.SwitchCase[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Switch (switchValue As Expression, ParamArray cases As SwitchCase()) As SwitchExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::SwitchExpression ^ Switch(System::Linq::Expressions::Expression ^ switchValue, ... cli::array &lt;System::Linq::Expressions::SwitchCase ^&gt; ^ cases);" />
      <MemberSignature Language="F#" Value="static member Switch : System.Linq.Expressions.Expression * System.Linq.Expressions.SwitchCase[] -&gt; System.Linq.Expressions.SwitchExpression" Usage="System.Linq.Expressions.Expression.Switch (switchValue, cases)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.SwitchExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="switchValue" Type="System.Linq.Expressions.Expression" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="cases" Type="System.Linq.Expressions.SwitchCase[]" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="switchValue"><span data-ttu-id="7593b-3602">要针对每个分支测试的值。</span><span class="sxs-lookup"><span data-stu-id="7593b-3602">The value to be tested against each case.</span></span></param>
        <param name="cases"><span data-ttu-id="7593b-3603">此 switch 表达式的分支集。</span><span class="sxs-lookup"><span data-stu-id="7593b-3603">The set of cases for this switch expression.</span></span></param>
        <summary><span data-ttu-id="7593b-3604">创建一个表示不带默认分支的 <see cref="T:System.Linq.Expressions.SwitchExpression" /> 语句的 <see langword="switch" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-3604">Creates a <see cref="T:System.Linq.Expressions.SwitchExpression" /> that represents a <see langword="switch" /> statement without a default case.</span></span></summary>
        <returns><span data-ttu-id="7593b-3605">创建的 <see cref="T:System.Linq.Expressions.SwitchExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-3605">The created <see cref="T:System.Linq.Expressions.SwitchExpression" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7593b-3606"><xref:System.Linq.Expressions.SwitchExpression> 对象中的所有 <xref:System.Linq.Expressions.SwitchCase> 对象都必须具有相同的类型，除非 <xref:System.Linq.Expressions.SwitchExpression> 的类型 `void`。</span><span class="sxs-lookup"><span data-stu-id="7593b-3606">All <xref:System.Linq.Expressions.SwitchCase> objects in a <xref:System.Linq.Expressions.SwitchExpression> object must have the same type, unless the <xref:System.Linq.Expressions.SwitchExpression> has the type `void`.</span></span>  
  
 <span data-ttu-id="7593b-3607">每个 <xref:System.Linq.Expressions.SwitchCase> 对象都具有一个隐式 `break` 语句，这意味着没有从一个 case 标签到另一个 case 标签的隐式贯穿。</span><span class="sxs-lookup"><span data-stu-id="7593b-3607">Each <xref:System.Linq.Expressions.SwitchCase> object has an implicit `break` statement, which means that there is no implicit fall through from one case label to another.</span></span>  
  
 <span data-ttu-id="7593b-3608">如果 `switchValue` 与任何情况都不匹配，则不会引发异常。</span><span class="sxs-lookup"><span data-stu-id="7593b-3608">If `switchValue` does not match any of the cases, no exception is thrown.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="7593b-3609">下面的示例演示如何创建一个表达式，该表达式表示不带默认大小写的 switch 语句。</span><span class="sxs-lookup"><span data-stu-id="7593b-3609">The following example demonstrates how to create an expression that represents a switch statement without a default case.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#34](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#34)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#34](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#34)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Switch">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.SwitchExpression Switch (System.Linq.Expressions.Expression switchValue, System.Linq.Expressions.Expression defaultBody, params System.Linq.Expressions.SwitchCase[] cases);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.SwitchExpression Switch(class System.Linq.Expressions.Expression switchValue, class System.Linq.Expressions.Expression defaultBody, class System.Linq.Expressions.SwitchCase[] cases) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Switch(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.SwitchCase[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Switch (switchValue As Expression, defaultBody As Expression, ParamArray cases As SwitchCase()) As SwitchExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::SwitchExpression ^ Switch(System::Linq::Expressions::Expression ^ switchValue, System::Linq::Expressions::Expression ^ defaultBody, ... cli::array &lt;System::Linq::Expressions::SwitchCase ^&gt; ^ cases);" />
      <MemberSignature Language="F#" Value="static member Switch : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Linq.Expressions.SwitchCase[] -&gt; System.Linq.Expressions.SwitchExpression" Usage="System.Linq.Expressions.Expression.Switch (switchValue, defaultBody, cases)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.SwitchExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="switchValue" Type="System.Linq.Expressions.Expression" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="defaultBody" Type="System.Linq.Expressions.Expression" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="cases" Type="System.Linq.Expressions.SwitchCase[]" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="switchValue"><span data-ttu-id="7593b-3610">要针对每个分支测试的值。</span><span class="sxs-lookup"><span data-stu-id="7593b-3610">The value to be tested against each case.</span></span></param>
        <param name="defaultBody"><span data-ttu-id="7593b-3611"><paramref name="switchValue" /> 不匹配任何分支时，该 switch 的结果。</span><span class="sxs-lookup"><span data-stu-id="7593b-3611">The result of the switch if <paramref name="switchValue" /> does not match any of the cases.</span></span></param>
        <param name="cases"><span data-ttu-id="7593b-3612">此 switch 表达式的分支集。</span><span class="sxs-lookup"><span data-stu-id="7593b-3612">The set of cases for this switch expression.</span></span></param>
        <summary><span data-ttu-id="7593b-3613">创建一个表示具有默认分支的 <see cref="T:System.Linq.Expressions.SwitchExpression" /> 语句的 <see langword="switch" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-3613">Creates a <see cref="T:System.Linq.Expressions.SwitchExpression" /> that represents a <see langword="switch" /> statement that has a default case.</span></span></summary>
        <returns><span data-ttu-id="7593b-3614">创建的 <see cref="T:System.Linq.Expressions.SwitchExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-3614">The created <see cref="T:System.Linq.Expressions.SwitchExpression" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7593b-3615"><xref:System.Linq.Expressions.SwitchExpression> 对象中的所有 <xref:System.Linq.Expressions.SwitchCase> 对象都必须具有相同的类型，除非 <xref:System.Linq.Expressions.SwitchExpression> 的类型 `void`。</span><span class="sxs-lookup"><span data-stu-id="7593b-3615">All <xref:System.Linq.Expressions.SwitchCase> objects in a <xref:System.Linq.Expressions.SwitchExpression> object must have the same type, unless the <xref:System.Linq.Expressions.SwitchExpression> has the type `void`.</span></span>  
  
 <span data-ttu-id="7593b-3616">每个 <xref:System.Linq.Expressions.SwitchCase> 对象都具有一个隐式 `break` 语句，这意味着没有从一个 case 标签到另一个 case 标签的隐式贯穿。</span><span class="sxs-lookup"><span data-stu-id="7593b-3616">Each <xref:System.Linq.Expressions.SwitchCase> object has an implicit `break` statement, which means that there is no implicit fall through from one case label to another.</span></span>  
  
 <span data-ttu-id="7593b-3617">如果 `switchValue` 与任何情况都不匹配，则运行 `defaultBody` 所表示的默认事例。</span><span class="sxs-lookup"><span data-stu-id="7593b-3617">If `switchValue` does not match any of the cases, the default case represented by `defaultBody` is run.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="7593b-3618">下面的示例演示如何创建一个表达式，该表达式表示具有默认情况的 switch 语句。</span><span class="sxs-lookup"><span data-stu-id="7593b-3618">The following example demonstrates how to create an expression that represents a switch statement that has a default case.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#35](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#35)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#35](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#35)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Switch">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.SwitchExpression Switch (System.Linq.Expressions.Expression switchValue, System.Linq.Expressions.Expression defaultBody, System.Reflection.MethodInfo comparison, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.SwitchCase&gt; cases);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.SwitchExpression Switch(class System.Linq.Expressions.Expression switchValue, class System.Linq.Expressions.Expression defaultBody, class System.Reflection.MethodInfo comparison, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.SwitchCase&gt; cases) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Switch(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.SwitchCase})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Switch (switchValue As Expression, defaultBody As Expression, comparison As MethodInfo, cases As IEnumerable(Of SwitchCase)) As SwitchExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::SwitchExpression ^ Switch(System::Linq::Expressions::Expression ^ switchValue, System::Linq::Expressions::Expression ^ defaultBody, System::Reflection::MethodInfo ^ comparison, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::SwitchCase ^&gt; ^ cases);" />
      <MemberSignature Language="F#" Value="static member Switch : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo * seq&lt;System.Linq.Expressions.SwitchCase&gt; -&gt; System.Linq.Expressions.SwitchExpression" Usage="System.Linq.Expressions.Expression.Switch (switchValue, defaultBody, comparison, cases)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.SwitchExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="switchValue" Type="System.Linq.Expressions.Expression" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="defaultBody" Type="System.Linq.Expressions.Expression" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparison" Type="System.Reflection.MethodInfo" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="cases" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.SwitchCase&gt;" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="switchValue"><span data-ttu-id="7593b-3619">要针对每个分支测试的值。</span><span class="sxs-lookup"><span data-stu-id="7593b-3619">The value to be tested against each case.</span></span></param>
        <param name="defaultBody"><span data-ttu-id="7593b-3620"><paramref name="switchValue" /> 不匹配任何分支时，该 switch 的结果。</span><span class="sxs-lookup"><span data-stu-id="7593b-3620">The result of the switch if <paramref name="switchValue" /> does not match any of the cases.</span></span></param>
        <param name="comparison"><span data-ttu-id="7593b-3621">要使用的相等比较方法。</span><span class="sxs-lookup"><span data-stu-id="7593b-3621">The equality comparison method to use.</span></span></param>
        <param name="cases"><span data-ttu-id="7593b-3622">此 switch 表达式的分支集。</span><span class="sxs-lookup"><span data-stu-id="7593b-3622">The set of cases for this switch expression.</span></span></param>
        <summary><span data-ttu-id="7593b-3623">创建一个表示具有默认分支的 <see cref="T:System.Linq.Expressions.SwitchExpression" /> 语句的 <see langword="switch" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-3623">Creates a <see cref="T:System.Linq.Expressions.SwitchExpression" /> that represents a <see langword="switch" /> statement that has a default case.</span></span></summary>
        <returns><span data-ttu-id="7593b-3624">创建的 <see cref="T:System.Linq.Expressions.SwitchExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-3624">The created <see cref="T:System.Linq.Expressions.SwitchExpression" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Switch">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.SwitchExpression Switch (System.Linq.Expressions.Expression switchValue, System.Linq.Expressions.Expression defaultBody, System.Reflection.MethodInfo comparison, params System.Linq.Expressions.SwitchCase[] cases);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.SwitchExpression Switch(class System.Linq.Expressions.Expression switchValue, class System.Linq.Expressions.Expression defaultBody, class System.Reflection.MethodInfo comparison, class System.Linq.Expressions.SwitchCase[] cases) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Switch(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.SwitchCase[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Switch (switchValue As Expression, defaultBody As Expression, comparison As MethodInfo, ParamArray cases As SwitchCase()) As SwitchExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::SwitchExpression ^ Switch(System::Linq::Expressions::Expression ^ switchValue, System::Linq::Expressions::Expression ^ defaultBody, System::Reflection::MethodInfo ^ comparison, ... cli::array &lt;System::Linq::Expressions::SwitchCase ^&gt; ^ cases);" />
      <MemberSignature Language="F#" Value="static member Switch : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo * System.Linq.Expressions.SwitchCase[] -&gt; System.Linq.Expressions.SwitchExpression" Usage="System.Linq.Expressions.Expression.Switch (switchValue, defaultBody, comparison, cases)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.SwitchExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="switchValue" Type="System.Linq.Expressions.Expression" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="defaultBody" Type="System.Linq.Expressions.Expression" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparison" Type="System.Reflection.MethodInfo" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="cases" Type="System.Linq.Expressions.SwitchCase[]" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="switchValue"><span data-ttu-id="7593b-3625">要针对每个分支测试的值。</span><span class="sxs-lookup"><span data-stu-id="7593b-3625">The value to be tested against each case.</span></span></param>
        <param name="defaultBody"><span data-ttu-id="7593b-3626"><paramref name="switchValue" /> 不匹配任何分支时，该 switch 的结果。</span><span class="sxs-lookup"><span data-stu-id="7593b-3626">The result of the switch if <paramref name="switchValue" /> does not match any of the cases.</span></span></param>
        <param name="comparison"><span data-ttu-id="7593b-3627">要使用的相等比较方法。</span><span class="sxs-lookup"><span data-stu-id="7593b-3627">The equality comparison method to use.</span></span></param>
        <param name="cases"><span data-ttu-id="7593b-3628">此 switch 表达式的分支集。</span><span class="sxs-lookup"><span data-stu-id="7593b-3628">The set of cases for this switch expression.</span></span></param>
        <summary><span data-ttu-id="7593b-3629">创建一个表示具有默认分支的 <see cref="T:System.Linq.Expressions.SwitchExpression" /> 语句的 <see langword="switch" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-3629">Creates a <see cref="T:System.Linq.Expressions.SwitchExpression" /> that represents a <see langword="switch" /> statement that has a default case.</span></span></summary>
        <returns><span data-ttu-id="7593b-3630">创建的 <see cref="T:System.Linq.Expressions.SwitchExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-3630">The created <see cref="T:System.Linq.Expressions.SwitchExpression" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Switch">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.SwitchExpression Switch (Type type, System.Linq.Expressions.Expression switchValue, System.Linq.Expressions.Expression defaultBody, System.Reflection.MethodInfo comparison, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.SwitchCase&gt; cases);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.SwitchExpression Switch(class System.Type type, class System.Linq.Expressions.Expression switchValue, class System.Linq.Expressions.Expression defaultBody, class System.Reflection.MethodInfo comparison, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.SwitchCase&gt; cases) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Switch(System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.SwitchCase})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::SwitchExpression ^ Switch(Type ^ type, System::Linq::Expressions::Expression ^ switchValue, System::Linq::Expressions::Expression ^ defaultBody, System::Reflection::MethodInfo ^ comparison, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::SwitchCase ^&gt; ^ cases);" />
      <MemberSignature Language="F#" Value="static member Switch : Type * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo * seq&lt;System.Linq.Expressions.SwitchCase&gt; -&gt; System.Linq.Expressions.SwitchExpression" Usage="System.Linq.Expressions.Expression.Switch (type, switchValue, defaultBody, comparison, cases)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.SwitchExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="switchValue" Type="System.Linq.Expressions.Expression" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="defaultBody" Type="System.Linq.Expressions.Expression" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparison" Type="System.Reflection.MethodInfo" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="cases" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.SwitchCase&gt;" Index="4" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="type"><span data-ttu-id="7593b-3631">switch 的结果类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-3631">The result type of the switch.</span></span></param>
        <param name="switchValue"><span data-ttu-id="7593b-3632">要针对每个分支测试的值。</span><span class="sxs-lookup"><span data-stu-id="7593b-3632">The value to be tested against each case.</span></span></param>
        <param name="defaultBody"><span data-ttu-id="7593b-3633"><paramref name="switchValue" /> 不匹配任何分支时，该 switch 的结果。</span><span class="sxs-lookup"><span data-stu-id="7593b-3633">The result of the switch if <paramref name="switchValue" /> does not match any of the cases.</span></span></param>
        <param name="comparison"><span data-ttu-id="7593b-3634">要使用的相等比较方法。</span><span class="sxs-lookup"><span data-stu-id="7593b-3634">The equality comparison method to use.</span></span></param>
        <param name="cases"><span data-ttu-id="7593b-3635">此 switch 表达式的分支集。</span><span class="sxs-lookup"><span data-stu-id="7593b-3635">The set of cases for this switch expression.</span></span></param>
        <summary><span data-ttu-id="7593b-3636">创建一个表示具有默认分支的 <see cref="T:System.Linq.Expressions.SwitchExpression" /> 语句的 <see langword="switch" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-3636">Creates a <see cref="T:System.Linq.Expressions.SwitchExpression" /> that represents a <see langword="switch" /> statement that has a default case.</span></span></summary>
        <returns><span data-ttu-id="7593b-3637">创建的 <see cref="T:System.Linq.Expressions.SwitchExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-3637">The created <see cref="T:System.Linq.Expressions.SwitchExpression" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Switch">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.SwitchExpression Switch (Type type, System.Linq.Expressions.Expression switchValue, System.Linq.Expressions.Expression defaultBody, System.Reflection.MethodInfo comparison, params System.Linq.Expressions.SwitchCase[] cases);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.SwitchExpression Switch(class System.Type type, class System.Linq.Expressions.Expression switchValue, class System.Linq.Expressions.Expression defaultBody, class System.Reflection.MethodInfo comparison, class System.Linq.Expressions.SwitchCase[] cases) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Switch(System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.SwitchCase[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::SwitchExpression ^ Switch(Type ^ type, System::Linq::Expressions::Expression ^ switchValue, System::Linq::Expressions::Expression ^ defaultBody, System::Reflection::MethodInfo ^ comparison, ... cli::array &lt;System::Linq::Expressions::SwitchCase ^&gt; ^ cases);" />
      <MemberSignature Language="F#" Value="static member Switch : Type * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo * System.Linq.Expressions.SwitchCase[] -&gt; System.Linq.Expressions.SwitchExpression" Usage="System.Linq.Expressions.Expression.Switch (type, switchValue, defaultBody, comparison, cases)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.SwitchExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="switchValue" Type="System.Linq.Expressions.Expression" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="defaultBody" Type="System.Linq.Expressions.Expression" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparison" Type="System.Reflection.MethodInfo" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="cases" Type="System.Linq.Expressions.SwitchCase[]" Index="4" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="type"><span data-ttu-id="7593b-3638">switch 的结果类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-3638">The result type of the switch.</span></span></param>
        <param name="switchValue"><span data-ttu-id="7593b-3639">要针对每个分支测试的值。</span><span class="sxs-lookup"><span data-stu-id="7593b-3639">The value to be tested against each case.</span></span></param>
        <param name="defaultBody"><span data-ttu-id="7593b-3640"><paramref name="switchValue" /> 不匹配任何分支时，该 switch 的结果。</span><span class="sxs-lookup"><span data-stu-id="7593b-3640">The result of the switch if <paramref name="switchValue" /> does not match any of the cases.</span></span></param>
        <param name="comparison"><span data-ttu-id="7593b-3641">要使用的相等比较方法。</span><span class="sxs-lookup"><span data-stu-id="7593b-3641">The equality comparison method to use.</span></span></param>
        <param name="cases"><span data-ttu-id="7593b-3642">此 switch 表达式的分支集。</span><span class="sxs-lookup"><span data-stu-id="7593b-3642">The set of cases for this switch expression.</span></span></param>
        <summary><span data-ttu-id="7593b-3643">创建一个表示具有默认分支的 <see cref="T:System.Linq.Expressions.SwitchExpression" /> 语句的 <see langword="switch" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-3643">Creates a <see cref="T:System.Linq.Expressions.SwitchExpression" /> that represents a <see langword="switch" /> statement that has a default case.</span></span></summary>
        <returns><span data-ttu-id="7593b-3644">创建的 <see cref="T:System.Linq.Expressions.SwitchExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-3644">The created <see cref="T:System.Linq.Expressions.SwitchExpression" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="SwitchCase">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="7593b-3645">创建要在 <see cref="T:System.Linq.Expressions.SwitchCase" /> 对象中使用的 <see cref="T:System.Linq.Expressions.SwitchExpression" /> 对象。</span><span class="sxs-lookup"><span data-stu-id="7593b-3645">Creates a <see cref="T:System.Linq.Expressions.SwitchCase" /> object to be used in a <see cref="T:System.Linq.Expressions.SwitchExpression" /> object.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SwitchCase">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.SwitchCase SwitchCase (System.Linq.Expressions.Expression body, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; testValues);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.SwitchCase SwitchCase(class System.Linq.Expressions.Expression body, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; testValues) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.SwitchCase(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SwitchCase (body As Expression, testValues As IEnumerable(Of Expression)) As SwitchCase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::SwitchCase ^ SwitchCase(System::Linq::Expressions::Expression ^ body, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ testValues);" />
      <MemberSignature Language="F#" Value="static member SwitchCase : System.Linq.Expressions.Expression * seq&lt;System.Linq.Expressions.Expression&gt; -&gt; System.Linq.Expressions.SwitchCase" Usage="System.Linq.Expressions.Expression.SwitchCase (body, testValues)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.SwitchCase</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="testValues" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="body"><span data-ttu-id="7593b-3646">分支的主体。</span><span class="sxs-lookup"><span data-stu-id="7593b-3646">The body of the case.</span></span></param>
        <param name="testValues"><span data-ttu-id="7593b-3647">分支的测试值。</span><span class="sxs-lookup"><span data-stu-id="7593b-3647">The test values of the case.</span></span></param>
        <summary><span data-ttu-id="7593b-3648">创建要在 <see cref="T:System.Linq.Expressions.SwitchCase" /> 对象中使用的 <see cref="T:System.Linq.Expressions.SwitchExpression" /> 对象。</span><span class="sxs-lookup"><span data-stu-id="7593b-3648">Creates a <see cref="T:System.Linq.Expressions.SwitchCase" /> object to be used in a <see cref="T:System.Linq.Expressions.SwitchExpression" /> object.</span></span></summary>
        <returns><span data-ttu-id="7593b-3649">创建的 <see cref="T:System.Linq.Expressions.SwitchCase" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-3649">The created <see cref="T:System.Linq.Expressions.SwitchCase" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7593b-3650"><xref:System.Linq.Expressions.SwitchExpression> 对象中的所有 <xref:System.Linq.Expressions.SwitchCase> 对象都必须具有相同的类型，除非 <xref:System.Linq.Expressions.SwitchExpression> 的类型 `void`。</span><span class="sxs-lookup"><span data-stu-id="7593b-3650">All <xref:System.Linq.Expressions.SwitchCase> objects in a <xref:System.Linq.Expressions.SwitchExpression> object must have the same type, unless the <xref:System.Linq.Expressions.SwitchExpression> has the type `void`.</span></span>  
  
 <span data-ttu-id="7593b-3651">每个 <xref:System.Linq.Expressions.SwitchCase> 对象都具有一个隐式 `break` 语句，这意味着没有从一个 case 标签到另一个 case 标签的隐式贯穿。</span><span class="sxs-lookup"><span data-stu-id="7593b-3651">Each <xref:System.Linq.Expressions.SwitchCase> object has an implicit `break` statement, which means that there is no implicit fall through from one case label to another.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="7593b-3652">下面的示例演示如何创建一个表达式，该表达式表示具有默认情况的 switch 语句。</span><span class="sxs-lookup"><span data-stu-id="7593b-3652">The following example demonstrates how to create an expression that represents a switch statement that has a default case.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#35](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#35)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#35](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#35)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SwitchCase">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.SwitchCase SwitchCase (System.Linq.Expressions.Expression body, params System.Linq.Expressions.Expression[] testValues);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.SwitchCase SwitchCase(class System.Linq.Expressions.Expression body, class System.Linq.Expressions.Expression[] testValues) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.SwitchCase(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SwitchCase (body As Expression, ParamArray testValues As Expression()) As SwitchCase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::SwitchCase ^ SwitchCase(System::Linq::Expressions::Expression ^ body, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ testValues);" />
      <MemberSignature Language="F#" Value="static member SwitchCase : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression[] -&gt; System.Linq.Expressions.SwitchCase" Usage="System.Linq.Expressions.Expression.SwitchCase (body, testValues)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.SwitchCase</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="testValues" Type="System.Linq.Expressions.Expression[]" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="body"><span data-ttu-id="7593b-3653">分支的主体。</span><span class="sxs-lookup"><span data-stu-id="7593b-3653">The body of the case.</span></span></param>
        <param name="testValues"><span data-ttu-id="7593b-3654">分支的测试值。</span><span class="sxs-lookup"><span data-stu-id="7593b-3654">The test values of the case.</span></span></param>
        <summary><span data-ttu-id="7593b-3655">创建在 <see cref="T:System.Linq.Expressions.SwitchCase" /> 中使用的 <see cref="T:System.Linq.Expressions.SwitchExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-3655">Creates a <see cref="T:System.Linq.Expressions.SwitchCase" /> for use in a <see cref="T:System.Linq.Expressions.SwitchExpression" />.</span></span></summary>
        <returns><span data-ttu-id="7593b-3656">创建的 <see cref="T:System.Linq.Expressions.SwitchCase" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-3656">The created <see cref="T:System.Linq.Expressions.SwitchCase" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="SymbolDocument">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="7593b-3657">创建 <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> 的实例。</span><span class="sxs-lookup"><span data-stu-id="7593b-3657">Creates an instance of <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SymbolDocument">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.SymbolDocumentInfo SymbolDocument (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.SymbolDocumentInfo SymbolDocument(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.SymbolDocument(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SymbolDocument (fileName As String) As SymbolDocumentInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::SymbolDocumentInfo ^ SymbolDocument(System::String ^ fileName);" />
      <MemberSignature Language="F#" Value="static member SymbolDocument : string -&gt; System.Linq.Expressions.SymbolDocumentInfo" Usage="System.Linq.Expressions.Expression.SymbolDocument fileName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.SymbolDocumentInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="fileName"><span data-ttu-id="7593b-3658">要将 <see cref="T:System.String" /> 设置为与其相等的 <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-3658">A <see cref="T:System.String" /> to set the <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" /> equal to.</span></span></param>
        <summary><span data-ttu-id="7593b-3659">创建 <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> 的实例。</span><span class="sxs-lookup"><span data-stu-id="7593b-3659">Creates an instance of <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" />.</span></span></summary>
        <returns><span data-ttu-id="7593b-3660">一个 <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" />，其 <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" /> 属性设置为指定值。</span><span class="sxs-lookup"><span data-stu-id="7593b-3660">A <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> that has the <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" /> property set to the specified value.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SymbolDocument">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.SymbolDocumentInfo SymbolDocument (string fileName, Guid language);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.SymbolDocumentInfo SymbolDocument(string fileName, valuetype System.Guid language) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.SymbolDocument(System.String,System.Guid)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SymbolDocument (fileName As String, language As Guid) As SymbolDocumentInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::SymbolDocumentInfo ^ SymbolDocument(System::String ^ fileName, Guid language);" />
      <MemberSignature Language="F#" Value="static member SymbolDocument : string * Guid -&gt; System.Linq.Expressions.SymbolDocumentInfo" Usage="System.Linq.Expressions.Expression.SymbolDocument (fileName, language)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.SymbolDocumentInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="language" Type="System.Guid" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="fileName"><span data-ttu-id="7593b-3661">要将 <see cref="T:System.String" /> 设置为与其相等的 <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-3661">A <see cref="T:System.String" /> to set the <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" /> equal to.</span></span></param>
        <param name="language"><span data-ttu-id="7593b-3662">要将 <see cref="T:System.Guid" /> 设置为与其相等的 <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-3662">A <see cref="T:System.Guid" /> to set the <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" /> equal to.</span></span></param>
        <summary><span data-ttu-id="7593b-3663">创建 <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> 的实例。</span><span class="sxs-lookup"><span data-stu-id="7593b-3663">Creates an instance of <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" />.</span></span></summary>
        <returns><span data-ttu-id="7593b-3664">一个 <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" />，其 <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" /> 和 <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" /> 属性设置为指定值。</span><span class="sxs-lookup"><span data-stu-id="7593b-3664">A <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> that has the <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" /> and <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" /> properties set to the specified value.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SymbolDocument">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.SymbolDocumentInfo SymbolDocument (string fileName, Guid language, Guid languageVendor);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.SymbolDocumentInfo SymbolDocument(string fileName, valuetype System.Guid language, valuetype System.Guid languageVendor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.SymbolDocument(System.String,System.Guid,System.Guid)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SymbolDocument (fileName As String, language As Guid, languageVendor As Guid) As SymbolDocumentInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::SymbolDocumentInfo ^ SymbolDocument(System::String ^ fileName, Guid language, Guid languageVendor);" />
      <MemberSignature Language="F#" Value="static member SymbolDocument : string * Guid * Guid -&gt; System.Linq.Expressions.SymbolDocumentInfo" Usage="System.Linq.Expressions.Expression.SymbolDocument (fileName, language, languageVendor)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.SymbolDocumentInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="language" Type="System.Guid" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="languageVendor" Type="System.Guid" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="fileName"><span data-ttu-id="7593b-3665">要将 <see cref="T:System.String" /> 设置为与其相等的 <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-3665">A <see cref="T:System.String" /> to set the <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" /> equal to.</span></span></param>
        <param name="language"><span data-ttu-id="7593b-3666">要将 <see cref="T:System.Guid" /> 设置为与其相等的 <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-3666">A <see cref="T:System.Guid" /> to set the <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" /> equal to.</span></span></param>
        <param name="languageVendor"><span data-ttu-id="7593b-3667">要将 <see cref="T:System.Guid" /> 设置为与其相等的 <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.LanguageVendor" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-3667">A <see cref="T:System.Guid" /> to set the <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.LanguageVendor" /> equal to.</span></span></param>
        <summary><span data-ttu-id="7593b-3668">创建 <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> 的实例。</span><span class="sxs-lookup"><span data-stu-id="7593b-3668">Creates an instance of <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" />.</span></span></summary>
        <returns><span data-ttu-id="7593b-3669">一个 <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" />，其 <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" />、<see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" /> 和 <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.LanguageVendor" /> 属性设置为指定值。</span><span class="sxs-lookup"><span data-stu-id="7593b-3669">A <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> that has the <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" /> and <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" /> and <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.LanguageVendor" /> properties set to the specified value.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SymbolDocument">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.SymbolDocumentInfo SymbolDocument (string fileName, Guid language, Guid languageVendor, Guid documentType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.SymbolDocumentInfo SymbolDocument(string fileName, valuetype System.Guid language, valuetype System.Guid languageVendor, valuetype System.Guid documentType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.SymbolDocument(System.String,System.Guid,System.Guid,System.Guid)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SymbolDocument (fileName As String, language As Guid, languageVendor As Guid, documentType As Guid) As SymbolDocumentInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::SymbolDocumentInfo ^ SymbolDocument(System::String ^ fileName, Guid language, Guid languageVendor, Guid documentType);" />
      <MemberSignature Language="F#" Value="static member SymbolDocument : string * Guid * Guid * Guid -&gt; System.Linq.Expressions.SymbolDocumentInfo" Usage="System.Linq.Expressions.Expression.SymbolDocument (fileName, language, languageVendor, documentType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.SymbolDocumentInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="language" Type="System.Guid" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="languageVendor" Type="System.Guid" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="documentType" Type="System.Guid" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="fileName"><span data-ttu-id="7593b-3670">要将 <see cref="T:System.String" /> 设置为与其相等的 <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-3670">A <see cref="T:System.String" /> to set the <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" /> equal to.</span></span></param>
        <param name="language"><span data-ttu-id="7593b-3671">要将 <see cref="T:System.Guid" /> 设置为与其相等的 <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-3671">A <see cref="T:System.Guid" /> to set the <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" /> equal to.</span></span></param>
        <param name="languageVendor"><span data-ttu-id="7593b-3672">要将 <see cref="T:System.Guid" /> 设置为与其相等的 <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.LanguageVendor" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-3672">A <see cref="T:System.Guid" /> to set the <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.LanguageVendor" /> equal to.</span></span></param>
        <param name="documentType"><span data-ttu-id="7593b-3673">要将 <see cref="T:System.Guid" /> 设置为与其相等的 <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.DocumentType" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-3673">A <see cref="T:System.Guid" /> to set the <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.DocumentType" /> equal to.</span></span></param>
        <summary><span data-ttu-id="7593b-3674">创建 <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> 的实例。</span><span class="sxs-lookup"><span data-stu-id="7593b-3674">Creates an instance of <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" />.</span></span></summary>
        <returns><span data-ttu-id="7593b-3675">一个 <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" />，其 <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" />、<see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" />、<see cref="P:System.Linq.Expressions.SymbolDocumentInfo.LanguageVendor" /> 和 <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.DocumentType" /> 属性设置为指定值。</span><span class="sxs-lookup"><span data-stu-id="7593b-3675">A <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> that has the <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" /> and <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" /> and <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.LanguageVendor" /> and <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.DocumentType" /> properties set to the specified value.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Throw">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="7593b-3676">创建一个 <see cref="T:System.Linq.Expressions.UnaryExpression" />，它表示引发异常。</span><span class="sxs-lookup"><span data-stu-id="7593b-3676">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents a throwing of an exception.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Throw">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression Throw (System.Linq.Expressions.Expression value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression Throw(class System.Linq.Expressions.Expression value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Throw(System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Throw (value As Expression) As UnaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ Throw(System::Linq::Expressions::Expression ^ value);" />
      <MemberSignature Language="F#" Value="static member Throw : System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.Throw value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Linq.Expressions.Expression" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="7593b-3677">一个 <see cref="T:System.Linq.Expressions.Expression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-3677">An <see cref="T:System.Linq.Expressions.Expression" />.</span></span></param>
        <summary><span data-ttu-id="7593b-3678">创建一个 <see cref="T:System.Linq.Expressions.UnaryExpression" />，它表示引发异常。</span><span class="sxs-lookup"><span data-stu-id="7593b-3678">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents a throwing of an exception.</span></span></summary>
        <returns><span data-ttu-id="7593b-3679">一个表示异常的 <see cref="T:System.Linq.Expressions.UnaryExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-3679">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents the exception.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="7593b-3680">下面的示例演示如何创建一个使用 <xref:System.Linq.Expressions.Expression.Throw%2A> 方法的 <xref:System.Linq.Expressions.TryExpression> 对象。</span><span class="sxs-lookup"><span data-stu-id="7593b-3680">The following example demonstrates how to create a <xref:System.Linq.Expressions.TryExpression> object that uses the <xref:System.Linq.Expressions.Expression.Throw%2A> method.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#47](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#47)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#47](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#47)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Throw">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression Throw (System.Linq.Expressions.Expression value, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression Throw(class System.Linq.Expressions.Expression value, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Throw(System.Linq.Expressions.Expression,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ Throw(System::Linq::Expressions::Expression ^ value, Type ^ type);" />
      <MemberSignature Language="F#" Value="static member Throw : System.Linq.Expressions.Expression * Type -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.Throw (value, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Linq.Expressions.Expression" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="type" Type="System.Type" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="7593b-3681">一个 <see cref="T:System.Linq.Expressions.Expression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-3681">An <see cref="T:System.Linq.Expressions.Expression" />.</span></span></param>
        <param name="type"><span data-ttu-id="7593b-3682">表达式的新 <see cref="T:System.Type" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-3682">The new <see cref="T:System.Type" /> of the expression.</span></span></param>
        <summary><span data-ttu-id="7593b-3683">创建一个 <see cref="T:System.Linq.Expressions.UnaryExpression" />，它表示引发具有给定类型的异常。</span><span class="sxs-lookup"><span data-stu-id="7593b-3683">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents a throwing of an exception with a given type.</span></span></summary>
        <returns><span data-ttu-id="7593b-3684">一个表示异常的 <see cref="T:System.Linq.Expressions.UnaryExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-3684">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents the exception.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="expression.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="7593b-3685">返回 <see cref="T:System.Linq.Expressions.Expression" /> 的的文本化表示形式。</span><span class="sxs-lookup"><span data-stu-id="7593b-3685">Returns a textual representation of the <see cref="T:System.Linq.Expressions.Expression" />.</span></span></summary>
        <returns><span data-ttu-id="7593b-3686"><see cref="T:System.Linq.Expressions.Expression" /> 的文本化表示形式。</span><span class="sxs-lookup"><span data-stu-id="7593b-3686">A textual representation of the <see cref="T:System.Linq.Expressions.Expression" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryCatch">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.TryExpression TryCatch (System.Linq.Expressions.Expression body, params System.Linq.Expressions.CatchBlock[] handlers);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.TryExpression TryCatch(class System.Linq.Expressions.Expression body, class System.Linq.Expressions.CatchBlock[] handlers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.TryCatch(System.Linq.Expressions.Expression,System.Linq.Expressions.CatchBlock[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryCatch (body As Expression, ParamArray handlers As CatchBlock()) As TryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::TryExpression ^ TryCatch(System::Linq::Expressions::Expression ^ body, ... cli::array &lt;System::Linq::Expressions::CatchBlock ^&gt; ^ handlers);" />
      <MemberSignature Language="F#" Value="static member TryCatch : System.Linq.Expressions.Expression * System.Linq.Expressions.CatchBlock[] -&gt; System.Linq.Expressions.TryExpression" Usage="System.Linq.Expressions.Expression.TryCatch (body, handlers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.TryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="handlers" Type="System.Linq.Expressions.CatchBlock[]" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="body"><span data-ttu-id="7593b-3687">try 块的主体。</span><span class="sxs-lookup"><span data-stu-id="7593b-3687">The body of the try block.</span></span></param>
        <param name="handlers"><span data-ttu-id="7593b-3688">包含零个或多个 <see cref="T:System.Linq.Expressions.CatchBlock" /> 表达式的数组，这些表达式表示要与 try 块关联的 catch 语句。</span><span class="sxs-lookup"><span data-stu-id="7593b-3688">The array of zero or more <see cref="T:System.Linq.Expressions.CatchBlock" /> expressions representing the catch statements to be associated with the try block.</span></span></param>
        <summary><span data-ttu-id="7593b-3689">创建一个表示 try 块的 <see cref="T:System.Linq.Expressions.TryExpression" />，该 try 块包含任意数量的 catch 语句，但不包含 fault 和 finally 块。</span><span class="sxs-lookup"><span data-stu-id="7593b-3689">Creates a <see cref="T:System.Linq.Expressions.TryExpression" /> representing a try block with any number of catch statements and neither a fault nor finally block.</span></span></summary>
        <returns><span data-ttu-id="7593b-3690">创建的 <see cref="T:System.Linq.Expressions.TryExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-3690">The created <see cref="T:System.Linq.Expressions.TryExpression" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="7593b-3691">下面的示例演示如何创建包含 catch 语句的 <xref:System.Linq.Expressions.TryExpression> 对象。</span><span class="sxs-lookup"><span data-stu-id="7593b-3691">The following example demonstrates how to create a <xref:System.Linq.Expressions.TryExpression> object that contains a catch statement.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#47](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#47)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#47](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#47)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryCatchFinally">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.TryExpression TryCatchFinally (System.Linq.Expressions.Expression body, System.Linq.Expressions.Expression finally, params System.Linq.Expressions.CatchBlock[] handlers);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.TryExpression TryCatchFinally(class System.Linq.Expressions.Expression body, class System.Linq.Expressions.Expression finally, class System.Linq.Expressions.CatchBlock[] handlers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.TryCatchFinally(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.CatchBlock[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryCatchFinally (body As Expression, finally As Expression, ParamArray handlers As CatchBlock()) As TryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::TryExpression ^ TryCatchFinally(System::Linq::Expressions::Expression ^ body, System::Linq::Expressions::Expression ^ finally, ... cli::array &lt;System::Linq::Expressions::CatchBlock ^&gt; ^ handlers);" />
      <MemberSignature Language="F#" Value="static member TryCatchFinally : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Linq.Expressions.CatchBlock[] -&gt; System.Linq.Expressions.TryExpression" Usage="System.Linq.Expressions.Expression.TryCatchFinally (body, finally, handlers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.TryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="finally" Type="System.Linq.Expressions.Expression" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="handlers" Type="System.Linq.Expressions.CatchBlock[]" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="body"><span data-ttu-id="7593b-3692">try 块的主体。</span><span class="sxs-lookup"><span data-stu-id="7593b-3692">The body of the try block.</span></span></param>
        <param name="finally"><span data-ttu-id="7593b-3693">finally 块的主体。</span><span class="sxs-lookup"><span data-stu-id="7593b-3693">The body of the finally block.</span></span></param>
        <param name="handlers"><span data-ttu-id="7593b-3694">包含零个或多个 <see cref="T:System.Linq.Expressions.CatchBlock" /> 表达式的数组，这些表达式表示要与 try 块关联的 catch 语句。</span><span class="sxs-lookup"><span data-stu-id="7593b-3694">The array of zero or more <see cref="T:System.Linq.Expressions.CatchBlock" /> expressions representing the catch statements to be associated with the try block.</span></span></param>
        <summary><span data-ttu-id="7593b-3695">创建一个表示 try 块的 <see cref="T:System.Linq.Expressions.TryExpression" />，该 try 块包含任意数量的 catch 语句和一个 finally 块。</span><span class="sxs-lookup"><span data-stu-id="7593b-3695">Creates a <see cref="T:System.Linq.Expressions.TryExpression" /> representing a try block with any number of catch statements and a finally block.</span></span></summary>
        <returns><span data-ttu-id="7593b-3696">创建的 <see cref="T:System.Linq.Expressions.TryExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-3696">The created <see cref="T:System.Linq.Expressions.TryExpression" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="7593b-3697">下面的示例演示如何创建包含 catch 语句和 finally 语句的 <xref:System.Linq.Expressions.TryExpression> 对象。</span><span class="sxs-lookup"><span data-stu-id="7593b-3697">The following example demonstrates how to create a <xref:System.Linq.Expressions.TryExpression> object that contains a catch statement and a finally statement.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#48](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#48)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#48](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#48)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryFault">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.TryExpression TryFault (System.Linq.Expressions.Expression body, System.Linq.Expressions.Expression fault);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.TryExpression TryFault(class System.Linq.Expressions.Expression body, class System.Linq.Expressions.Expression fault) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.TryFault(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryFault (body As Expression, fault As Expression) As TryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::TryExpression ^ TryFault(System::Linq::Expressions::Expression ^ body, System::Linq::Expressions::Expression ^ fault);" />
      <MemberSignature Language="F#" Value="static member TryFault : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.TryExpression" Usage="System.Linq.Expressions.Expression.TryFault (body, fault)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.TryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="fault" Type="System.Linq.Expressions.Expression" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="body"><span data-ttu-id="7593b-3698">try 块的主体。</span><span class="sxs-lookup"><span data-stu-id="7593b-3698">The body of the try block.</span></span></param>
        <param name="fault"><span data-ttu-id="7593b-3699">fault 块的主体。</span><span class="sxs-lookup"><span data-stu-id="7593b-3699">The body of the fault block.</span></span></param>
        <summary><span data-ttu-id="7593b-3700">创建一个表示 try 块的 <see cref="T:System.Linq.Expressions.TryExpression" />，该 try 块包含一个 fault 块，但不包含 catch 语句。</span><span class="sxs-lookup"><span data-stu-id="7593b-3700">Creates a <see cref="T:System.Linq.Expressions.TryExpression" /> representing a try block with a fault block and no catch statements.</span></span></summary>
        <returns><span data-ttu-id="7593b-3701">创建的 <see cref="T:System.Linq.Expressions.TryExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-3701">The created <see cref="T:System.Linq.Expressions.TryExpression" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryFinally">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.TryExpression TryFinally (System.Linq.Expressions.Expression body, System.Linq.Expressions.Expression finally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.TryExpression TryFinally(class System.Linq.Expressions.Expression body, class System.Linq.Expressions.Expression finally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.TryFinally(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryFinally (body As Expression, finally As Expression) As TryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::TryExpression ^ TryFinally(System::Linq::Expressions::Expression ^ body, System::Linq::Expressions::Expression ^ finally);" />
      <MemberSignature Language="F#" Value="static member TryFinally : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.TryExpression" Usage="System.Linq.Expressions.Expression.TryFinally (body, finally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.TryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="finally" Type="System.Linq.Expressions.Expression" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="body"><span data-ttu-id="7593b-3702">try 块的主体。</span><span class="sxs-lookup"><span data-stu-id="7593b-3702">The body of the try block.</span></span></param>
        <param name="finally"><span data-ttu-id="7593b-3703">finally 块的主体。</span><span class="sxs-lookup"><span data-stu-id="7593b-3703">The body of the finally block.</span></span></param>
        <summary><span data-ttu-id="7593b-3704">创建一个表示 try 块的 <see cref="T:System.Linq.Expressions.TryExpression" />，该 try 块包含一个 finally 块，但不包含 catch 语句。</span><span class="sxs-lookup"><span data-stu-id="7593b-3704">Creates a <see cref="T:System.Linq.Expressions.TryExpression" /> representing a try block with a finally block and no catch statements.</span></span></summary>
        <returns><span data-ttu-id="7593b-3705">创建的 <see cref="T:System.Linq.Expressions.TryExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-3705">The created <see cref="T:System.Linq.Expressions.TryExpression" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryGetActionType">
      <MemberSignature Language="C#" Value="public static bool TryGetActionType (Type[] typeArgs, out Type actionType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryGetActionType(class System.Type[] typeArgs, [out] class System.Type&amp; actionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.TryGetActionType(System.Type[],System.Type@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryGetActionType (typeArgs As Type(), ByRef actionType As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryGetActionType(cli::array &lt;Type ^&gt; ^ typeArgs, [Runtime::InteropServices::Out] Type ^ % actionType);" />
      <MemberSignature Language="F#" Value="static member TryGetActionType : Type[] * Type -&gt; bool" Usage="System.Linq.Expressions.Expression.TryGetActionType (typeArgs, actionType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeArgs" Type="System.Type[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="actionType" Type="System.Type" RefType="out" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="typeArgs"><span data-ttu-id="7593b-3706">Type 对象的数组，这些对象指定 System.Action 委托类型的类型参数。</span><span class="sxs-lookup"><span data-stu-id="7593b-3706">An array of Type objects that specify the type arguments for the System.Action delegate type.</span></span></param>
        <param name="actionType"><span data-ttu-id="7593b-3707">在此方法返回时，包含具有特定类型参数的泛型 System.Action 委托类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-3707">When this method returns, contains the generic System.Action delegate type that has specific type arguments.</span></span> <span data-ttu-id="7593b-3708">如果没有与 <paramref name="typeArgs" /> 匹配的泛型 System.Action 委托，则包含 null。此参数以未初始化状态传递。</span><span class="sxs-lookup"><span data-stu-id="7593b-3708">Contains null if there is no generic System.Action delegate that matches the <paramref name="typeArgs" />.This parameter is passed uninitialized.</span></span></param>
        <summary><span data-ttu-id="7593b-3709">创建一个 <see cref="P:System.Linq.Expressions.Expression.Type" /> 对象，它表示具有特定类型参数的泛型 System.Action 委托类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-3709">Creates a <see cref="P:System.Linq.Expressions.Expression.Type" /> object that represents a generic System.Action delegate type that has specific type arguments.</span></span></summary>
        <returns><span data-ttu-id="7593b-3710">如果已为特定的 <see langword="true" /> 创建泛型 System.Action 委托类型，则为 <paramref name="typeArgs" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-3710"><see langword="true" /> if generic System.Action delegate type was created for specific <paramref name="typeArgs" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryGetFuncType">
      <MemberSignature Language="C#" Value="public static bool TryGetFuncType (Type[] typeArgs, out Type funcType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryGetFuncType(class System.Type[] typeArgs, [out] class System.Type&amp; funcType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.TryGetFuncType(System.Type[],System.Type@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryGetFuncType (typeArgs As Type(), ByRef funcType As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryGetFuncType(cli::array &lt;Type ^&gt; ^ typeArgs, [Runtime::InteropServices::Out] Type ^ % funcType);" />
      <MemberSignature Language="F#" Value="static member TryGetFuncType : Type[] * Type -&gt; bool" Usage="System.Linq.Expressions.Expression.TryGetFuncType (typeArgs, funcType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeArgs" Type="System.Type[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="funcType" Type="System.Type" RefType="out" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="typeArgs"><span data-ttu-id="7593b-3711">Type 对象的数组，这些对象指定 System.Func 委托类型的类型参数。</span><span class="sxs-lookup"><span data-stu-id="7593b-3711">An array of Type objects that specify the type arguments for the System.Func delegate type.</span></span></param>
        <param name="funcType"><span data-ttu-id="7593b-3712">在此方法返回时，包含具有特定类型参数的泛型 System.Func 委托类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-3712">When this method returns, contains the generic System.Func delegate type that has specific type arguments.</span></span> <span data-ttu-id="7593b-3713">如果没有与 <paramref name="typeArgs" /> 匹配的泛型 System.Func 委托，则包含 null。此参数以未初始化状态传递。</span><span class="sxs-lookup"><span data-stu-id="7593b-3713">Contains null if there is no generic System.Func delegate that matches the <paramref name="typeArgs" />.This parameter is passed uninitialized.</span></span></param>
        <summary><span data-ttu-id="7593b-3714">创建一个 <see cref="P:System.Linq.Expressions.Expression.Type" /> 对象，它表示具有特定类型参数的泛型 System.Func 委托类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-3714">Creates a <see cref="P:System.Linq.Expressions.Expression.Type" /> object that represents a generic System.Func delegate type that has specific type arguments.</span></span> <span data-ttu-id="7593b-3715">最后一个类型参数指定已创建委托的返回类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-3715">The last type argument specifies the return type of the created delegate.</span></span></summary>
        <returns><span data-ttu-id="7593b-3716">如果已为特定的 <see langword="true" /> 创建泛型 System.Func 委托类型，则为 <paramref name="typeArgs" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-3716"><see langword="true" /> if generic System.Func delegate type was created for specific <paramref name="typeArgs" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Type">
      <MemberSignature Language="C#" Value="public virtual Type Type { get; }" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type Type" />
      <MemberSignature Language="DocId" Value="P:System.Linq.Expressions.Expression.Type" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Type As Type" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ Type { Type ^ get(); };" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.Type : Type" Usage="System.Linq.Expressions.Expression.Type" />
      <MemberSignature Language="C#" Value="public Type Type { get; }" FrameworkAlternate="netframework-3.5" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Type As Type" FrameworkAlternate="netframework-3.5" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Type ^ Type { Type ^ get(); };" FrameworkAlternate="netframework-3.5" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="7593b-3717">获取此 <see cref="T:System.Linq.Expressions.Expression" /> 表示的表达式的静态类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-3717">Gets the static type of the expression that this <see cref="T:System.Linq.Expressions.Expression" /> represents.</span></span></summary>
        <value><span data-ttu-id="7593b-3718">表示表达式的静态类型的 <see cref="T:System.Type" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-3718">The <see cref="T:System.Type" /> that represents the static type of the expression.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7593b-3719"><xref:System.Linq.Expressions.Expression.NodeType%2A> 是表达式树节点的类型，而 <xref:System.Linq.Expressions.Expression.Type%2A> 表示该节点表示的表达式的静态公共语言运行时（CLR）类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-3719">The <xref:System.Linq.Expressions.Expression.NodeType%2A> is the type of the expression tree node, whereas the <xref:System.Linq.Expressions.Expression.Type%2A> represents the static common language runtime (CLR) type of the expression that the node represents.</span></span> <span data-ttu-id="7593b-3720">例如，两个具有不同节点类型的节点可具有相同的 <xref:System.Linq.Expressions.Expression.Type%2A>，如下面的代码示例中所示。</span><span class="sxs-lookup"><span data-stu-id="7593b-3720">For example, two nodes with different node types can have the same <xref:System.Linq.Expressions.Expression.Type%2A>, as shown in the following code example.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#36](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#36)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#36](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#36)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TypeAs">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression TypeAs (System.Linq.Expressions.Expression expression, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression TypeAs(class System.Linq.Expressions.Expression expression, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.TypeAs(System.Linq.Expressions.Expression,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ TypeAs(System::Linq::Expressions::Expression ^ expression, Type ^ type);" />
      <MemberSignature Language="F#" Value="static member TypeAs : System.Linq.Expressions.Expression * Type -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.TypeAs (expression, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="expression"><span data-ttu-id="7593b-3721">要将 <see cref="T:System.Linq.Expressions.Expression" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-3721">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> property equal to.</span></span></param>
        <param name="type"><span data-ttu-id="7593b-3722">要将 <see cref="T:System.Type" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.Expression.Type" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-3722">A <see cref="T:System.Type" /> to set the <see cref="P:System.Linq.Expressions.Expression.Type" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="7593b-3723">创建一个表示显式引用或装箱转换的 <see cref="T:System.Linq.Expressions.UnaryExpression" />（如果转换失败，则提供 <see langword="null" />）。</span><span class="sxs-lookup"><span data-stu-id="7593b-3723">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents an explicit reference or boxing conversion where <see langword="null" /> is supplied if the conversion fails.</span></span></summary>
        <returns><span data-ttu-id="7593b-3724">一个 <see cref="T:System.Linq.Expressions.UnaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 属性等于 <see cref="F:System.Linq.Expressions.ExpressionType.TypeAs" />，并且其 <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> 和 <see cref="P:System.Linq.Expressions.Expression.Type" /> 属性设置为指定值。</span><span class="sxs-lookup"><span data-stu-id="7593b-3724">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.TypeAs" /> and the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> and <see cref="P:System.Linq.Expressions.Expression.Type" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7593b-3725">生成的 <xref:System.Linq.Expressions.UnaryExpression> 的 <xref:System.Linq.Expressions.UnaryExpression.Method%2A> 属性是 `null`。</span><span class="sxs-lookup"><span data-stu-id="7593b-3725">The <xref:System.Linq.Expressions.UnaryExpression.Method%2A> property of the resulting <xref:System.Linq.Expressions.UnaryExpression> is `null`.</span></span> <span data-ttu-id="7593b-3726"><xref:System.Linq.Expressions.UnaryExpression.IsLifted%2A> 和 <xref:System.Linq.Expressions.UnaryExpression.IsLiftedToNull%2A> 属性均 `false`。</span><span class="sxs-lookup"><span data-stu-id="7593b-3726">The <xref:System.Linq.Expressions.UnaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.UnaryExpression.IsLiftedToNull%2A> properties are both `false`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="7593b-3727">下面的示例演示如何使用 <xref:System.Linq.Expressions.Expression.TypeAs%28System.Linq.Expressions.Expression%2CSystem.Type%29> 方法来创建 <xref:System.Linq.Expressions.UnaryExpression>，该对象表示不可为 null 的整数表达式到可为 null 的整数类型的引用转换。</span><span class="sxs-lookup"><span data-stu-id="7593b-3727">The following example demonstrates how to use the <xref:System.Linq.Expressions.Expression.TypeAs%28System.Linq.Expressions.Expression%2CSystem.Type%29> method to create a <xref:System.Linq.Expressions.UnaryExpression> that represents the reference conversion of a non-nullable integer expression to the nullable integer type.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.Expression#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#11)]
 [!code-vb[System.Linq.Expressions.Expression#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="7593b-3728"><paramref name="expression" /> 或 <paramref name="type" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-3728"><paramref name="expression" /> or <paramref name="type" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="TypeEqual">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.TypeBinaryExpression TypeEqual (System.Linq.Expressions.Expression expression, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.TypeBinaryExpression TypeEqual(class System.Linq.Expressions.Expression expression, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.TypeEqual(System.Linq.Expressions.Expression,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::TypeBinaryExpression ^ TypeEqual(System::Linq::Expressions::Expression ^ expression, Type ^ type);" />
      <MemberSignature Language="F#" Value="static member TypeEqual : System.Linq.Expressions.Expression * Type -&gt; System.Linq.Expressions.TypeBinaryExpression" Usage="System.Linq.Expressions.Expression.TypeEqual (expression, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.TypeBinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="type" Type="System.Type" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="expression"><span data-ttu-id="7593b-3729">要将 <see cref="T:System.Linq.Expressions.Expression" /> 属性设置为与其相等的 <see cref="T:System.Linq.Expressions.Expression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-3729">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="T:System.Linq.Expressions.Expression" /> property equal to.</span></span></param>
        <param name="type"><span data-ttu-id="7593b-3730">要将 <see cref="P:System.Linq.Expressions.Expression.Type" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.TypeBinaryExpression.TypeOperand" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-3730">A <see cref="P:System.Linq.Expressions.Expression.Type" /> to set the <see cref="P:System.Linq.Expressions.TypeBinaryExpression.TypeOperand" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="7593b-3731">创建一个比较运行时类型标识的 <see cref="T:System.Linq.Expressions.TypeBinaryExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-3731">Creates a <see cref="T:System.Linq.Expressions.TypeBinaryExpression" /> that compares run-time type identity.</span></span></summary>
        <returns><span data-ttu-id="7593b-3732">一个 <see cref="T:System.Linq.Expressions.TypeBinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 属性等于 <see cref="M:System.Linq.Expressions.Expression.TypeEqual(System.Linq.Expressions.Expression,System.Type)" /> 并且 <see cref="T:System.Linq.Expressions.Expression" /> 和 <see cref="P:System.Linq.Expressions.TypeBinaryExpression.TypeOperand" /> 属性设置为指定值。</span><span class="sxs-lookup"><span data-stu-id="7593b-3732">A <see cref="T:System.Linq.Expressions.TypeBinaryExpression" /> for which the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property is equal to <see cref="M:System.Linq.Expressions.Expression.TypeEqual(System.Linq.Expressions.Expression,System.Type)" /> and for which the <see cref="T:System.Linq.Expressions.Expression" /> and <see cref="P:System.Linq.Expressions.TypeBinaryExpression.TypeOperand" /> properties are set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TypeIs">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.TypeBinaryExpression TypeIs (System.Linq.Expressions.Expression expression, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.TypeBinaryExpression TypeIs(class System.Linq.Expressions.Expression expression, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.TypeIs(System.Linq.Expressions.Expression,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::TypeBinaryExpression ^ TypeIs(System::Linq::Expressions::Expression ^ expression, Type ^ type);" />
      <MemberSignature Language="F#" Value="static member TypeIs : System.Linq.Expressions.Expression * Type -&gt; System.Linq.Expressions.TypeBinaryExpression" Usage="System.Linq.Expressions.Expression.TypeIs (expression, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.TypeBinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="expression"><span data-ttu-id="7593b-3733">要将 <see cref="T:System.Linq.Expressions.Expression" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.TypeBinaryExpression.Expression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-3733">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.TypeBinaryExpression.Expression" /> property equal to.</span></span></param>
        <param name="type"><span data-ttu-id="7593b-3734">要将 <see cref="P:System.Linq.Expressions.Expression.Type" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.TypeBinaryExpression.TypeOperand" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-3734">A <see cref="P:System.Linq.Expressions.Expression.Type" /> to set the <see cref="P:System.Linq.Expressions.TypeBinaryExpression.TypeOperand" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="7593b-3735">创建一个 <see cref="T:System.Linq.Expressions.TypeBinaryExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-3735">Creates a <see cref="T:System.Linq.Expressions.TypeBinaryExpression" />.</span></span></summary>
        <returns><span data-ttu-id="7593b-3736">一个 <see cref="T:System.Linq.Expressions.TypeBinaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 属性等于 <see cref="F:System.Linq.Expressions.ExpressionType.TypeIs" /> 并且 <see cref="P:System.Linq.Expressions.TypeBinaryExpression.Expression" /> 和 <see cref="P:System.Linq.Expressions.TypeBinaryExpression.TypeOperand" /> 属性设置为指定值。</span><span class="sxs-lookup"><span data-stu-id="7593b-3736">A <see cref="T:System.Linq.Expressions.TypeBinaryExpression" /> for which the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property is equal to <see cref="F:System.Linq.Expressions.ExpressionType.TypeIs" /> and for which the <see cref="P:System.Linq.Expressions.TypeBinaryExpression.Expression" /> and <see cref="P:System.Linq.Expressions.TypeBinaryExpression.TypeOperand" /> properties are set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7593b-3737">生成的 <xref:System.Linq.Expressions.UnaryExpression> 的 <xref:System.Linq.Expressions.Expression.Type%2A> 属性表示 <xref:System.Boolean>。</span><span class="sxs-lookup"><span data-stu-id="7593b-3737">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.UnaryExpression> represents <xref:System.Boolean>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="7593b-3738">下面的示例演示如何使用 <xref:System.Linq.Expressions.Expression.TypeIs%28System.Linq.Expressions.Expression%2CSystem.Type%29> 方法创建一个 <xref:System.Linq.Expressions.TypeBinaryExpression>，该表示针对 <xref:System.Int32> 类型的字符串值的类型测试。</span><span class="sxs-lookup"><span data-stu-id="7593b-3738">The following example demonstrates how to use the <xref:System.Linq.Expressions.Expression.TypeIs%28System.Linq.Expressions.Expression%2CSystem.Type%29> method to create a <xref:System.Linq.Expressions.TypeBinaryExpression> that represents a type test of a string value against the <xref:System.Int32> type.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.Expression#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#12)]
 [!code-vb[System.Linq.Expressions.Expression#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="7593b-3739"><paramref name="expression" /> 或 <paramref name="type" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-3739"><paramref name="expression" /> or <paramref name="type" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="UnaryPlus">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="7593b-3740">创建一个表示一元正运算的 <see cref="T:System.Linq.Expressions.UnaryExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-3740">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents a unary plus operation.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="UnaryPlus">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression UnaryPlus (System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression UnaryPlus(class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.UnaryPlus(System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ UnaryPlus(System::Linq::Expressions::Expression ^ expression);" />
      <MemberSignature Language="F#" Value="static member UnaryPlus : System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.UnaryPlus expression" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="expression"><span data-ttu-id="7593b-3741">要将 <see cref="T:System.Linq.Expressions.Expression" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-3741">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="7593b-3742">创建一个表示一元正运算的 <see cref="T:System.Linq.Expressions.UnaryExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-3742">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents a unary plus operation.</span></span></summary>
        <returns><span data-ttu-id="7593b-3743">一个 <see cref="T:System.Linq.Expressions.UnaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 属性等于 <see cref="F:System.Linq.Expressions.ExpressionType.UnaryPlus" />，并且其 <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> 属性设置为指定值。</span><span class="sxs-lookup"><span data-stu-id="7593b-3743">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.UnaryPlus" /> and the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> property set to the specified value.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7593b-3744">生成的 <xref:System.Linq.Expressions.UnaryExpression> 的 <xref:System.Linq.Expressions.UnaryExpression.Method%2A> 属性被设置为实现方法。</span><span class="sxs-lookup"><span data-stu-id="7593b-3744">The <xref:System.Linq.Expressions.UnaryExpression.Method%2A> property of the resulting <xref:System.Linq.Expressions.UnaryExpression> is set to the implementing method.</span></span> <span data-ttu-id="7593b-3745"><xref:System.Linq.Expressions.Expression.Type%2A> 属性设置为节点的类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-3745">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="7593b-3746">如果节点已提升，则 <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> 和 <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> 属性均 `true`。</span><span class="sxs-lookup"><span data-stu-id="7593b-3746">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="7593b-3747">否则为 false。</span><span class="sxs-lookup"><span data-stu-id="7593b-3747">Otherwise, they are false.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="7593b-3748">实现方法</span><span class="sxs-lookup"><span data-stu-id="7593b-3748">Implementing Method</span></span>  
 <span data-ttu-id="7593b-3749">以下规则确定操作的实现方法：</span><span class="sxs-lookup"><span data-stu-id="7593b-3749">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="7593b-3750">如果 `expression`。类型是定义一元加号运算符的用户定义类型，则表示该运算符的 <xref:System.Reflection.MethodInfo> 是实现方法。</span><span class="sxs-lookup"><span data-stu-id="7593b-3750">If `expression`.Type is a user-defined type that defines the unary plus operator, the <xref:System.Reflection.MethodInfo> that represents that operator is the implementing method.</span></span>  
  
-   <span data-ttu-id="7593b-3751">否则，如果 `expression`。Type 为数值类型，则实现方法为 `null`。</span><span class="sxs-lookup"><span data-stu-id="7593b-3751">Otherwise, if `expression`.Type is a numeric type, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="7593b-3752">节点类型和提升和非提升</span><span class="sxs-lookup"><span data-stu-id="7593b-3752">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="7593b-3753">如果不 `null`实现方法：</span><span class="sxs-lookup"><span data-stu-id="7593b-3753">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="7593b-3754">如果 `expression`。类型可赋给实现方法的参数类型，不会提升节点。</span><span class="sxs-lookup"><span data-stu-id="7593b-3754">If `expression`.Type is assignable to the argument type of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="7593b-3755">节点的类型是实现方法的返回类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-3755">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="7593b-3756">如果满足以下两个条件，则会提升节点，并且该节点的类型为与实现方法的返回类型对应的可以为 null 的类型：</span><span class="sxs-lookup"><span data-stu-id="7593b-3756">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="7593b-3757">`expression`。类型是可以为 null 的值类型，并且相应的不可为 null 的值类型等于实现方法的参数类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-3757">`expression`.Type is a nullable value type and the corresponding non-nullable value type is equal to the argument type of the implementing method.</span></span>  
  
    -   <span data-ttu-id="7593b-3758">实现方法的返回类型是不可为 null 的值类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-3758">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="7593b-3759">如果实现方法为 `null`，则 `expression`节点的类型。类别.</span><span class="sxs-lookup"><span data-stu-id="7593b-3759">If the implementing method is `null`, the type of the node is `expression`.Type.</span></span> <span data-ttu-id="7593b-3760">如果 `expression`。类型不可为 null，则不提升节点。</span><span class="sxs-lookup"><span data-stu-id="7593b-3760">If `expression`.Type is non-nullable, the node is not lifted.</span></span> <span data-ttu-id="7593b-3761">否则，节点会提升。</span><span class="sxs-lookup"><span data-stu-id="7593b-3761">Otherwise, the node is lifted.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="7593b-3762"><paramref name="expression" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-3762"><paramref name="expression" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="7593b-3763">没有为 <paramref name="expression" />.Type 定义一元正运算符。</span><span class="sxs-lookup"><span data-stu-id="7593b-3763">The unary plus operator is not defined for <paramref name="expression" />.Type.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="UnaryPlus">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression UnaryPlus (System.Linq.Expressions.Expression expression, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression UnaryPlus(class System.Linq.Expressions.Expression expression, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.UnaryPlus(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ UnaryPlus(System::Linq::Expressions::Expression ^ expression, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member UnaryPlus : System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.UnaryPlus (expression, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="expression"><span data-ttu-id="7593b-3764">要将 <see cref="T:System.Linq.Expressions.Expression" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-3764">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> property equal to.</span></span></param>
        <param name="method"><span data-ttu-id="7593b-3765">要将 <see cref="T:System.Reflection.MethodInfo" /> 属性设置为与其相等的 <see cref="P:System.Linq.Expressions.UnaryExpression.Method" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-3765">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="7593b-3766">创建一个表示一元正运算的 <see cref="T:System.Linq.Expressions.UnaryExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-3766">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents a unary plus operation.</span></span></summary>
        <returns><span data-ttu-id="7593b-3767">一个 <see cref="T:System.Linq.Expressions.UnaryExpression" />，其 <see cref="P:System.Linq.Expressions.Expression.NodeType" /> 属性等于 <see cref="F:System.Linq.Expressions.ExpressionType.UnaryPlus" />，并且其 <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> 和 <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> 属性设置为指定值。</span><span class="sxs-lookup"><span data-stu-id="7593b-3767">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.UnaryPlus" /> and the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> and <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7593b-3768">生成的 <xref:System.Linq.Expressions.UnaryExpression> 的 <xref:System.Linq.Expressions.UnaryExpression.Method%2A> 属性被设置为实现方法。</span><span class="sxs-lookup"><span data-stu-id="7593b-3768">The <xref:System.Linq.Expressions.UnaryExpression.Method%2A> property of the resulting <xref:System.Linq.Expressions.UnaryExpression> is set to the implementing method.</span></span> <span data-ttu-id="7593b-3769"><xref:System.Linq.Expressions.Expression.Type%2A> 属性设置为节点的类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-3769">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="7593b-3770">如果节点已提升，则 <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> 和 <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> 属性均 `true`。</span><span class="sxs-lookup"><span data-stu-id="7593b-3770">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="7593b-3771">否则为 false。</span><span class="sxs-lookup"><span data-stu-id="7593b-3771">Otherwise, they are false.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="7593b-3772">实现方法</span><span class="sxs-lookup"><span data-stu-id="7593b-3772">Implementing Method</span></span>  
 <span data-ttu-id="7593b-3773">以下规则确定操作的实现方法：</span><span class="sxs-lookup"><span data-stu-id="7593b-3773">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="7593b-3774">如果 `method` 未 `null` 并且它表示采用一个自变量的非 void、`static` （Visual Basic`Shared`）方法，则该方法为节点的实现方法。</span><span class="sxs-lookup"><span data-stu-id="7593b-3774">If `method` is not `null` and it represents a non-void, `static` (`Shared` in Visual Basic) method that takes one argument, it is the implementing method for the node.</span></span>  
  
-   <span data-ttu-id="7593b-3775">如果 `expression`。类型是定义一元加号运算符的用户定义类型，则表示该运算符的 <xref:System.Reflection.MethodInfo> 是实现方法。</span><span class="sxs-lookup"><span data-stu-id="7593b-3775">If `expression`.Type is a user-defined type that defines the unary plus operator, the <xref:System.Reflection.MethodInfo> that represents that operator is the implementing method.</span></span>  
  
-   <span data-ttu-id="7593b-3776">否则，如果 `expression`。Type 为数值类型，则实现方法为 `null`。</span><span class="sxs-lookup"><span data-stu-id="7593b-3776">Otherwise, if `expression`.Type is a numeric type, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="7593b-3777">节点类型和提升和非提升</span><span class="sxs-lookup"><span data-stu-id="7593b-3777">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="7593b-3778">如果不 `null`实现方法：</span><span class="sxs-lookup"><span data-stu-id="7593b-3778">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="7593b-3779">如果 `expression`。类型可赋给实现方法的参数类型，不会提升节点。</span><span class="sxs-lookup"><span data-stu-id="7593b-3779">If `expression`.Type is assignable to the argument type of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="7593b-3780">节点的类型是实现方法的返回类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-3780">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="7593b-3781">如果满足以下两个条件，则会提升节点，并且该节点的类型为与实现方法的返回类型对应的可以为 null 的类型：</span><span class="sxs-lookup"><span data-stu-id="7593b-3781">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="7593b-3782">`expression`。类型是可以为 null 的值类型，并且相应的不可为 null 的值类型等于实现方法的参数类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-3782">`expression`.Type is a nullable value type and the corresponding non-nullable value type is equal to the argument type of the implementing method.</span></span>  
  
    -   <span data-ttu-id="7593b-3783">实现方法的返回类型是不可为 null 的值类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-3783">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="7593b-3784">如果实现方法为 `null`，则 `expression`节点的类型。类别.</span><span class="sxs-lookup"><span data-stu-id="7593b-3784">If the implementing method is `null`, the type of the node is `expression`.Type.</span></span> <span data-ttu-id="7593b-3785">如果 `expression`。类型不可为 null，则不提升节点。</span><span class="sxs-lookup"><span data-stu-id="7593b-3785">If `expression`.Type is non-nullable, the node is not lifted.</span></span> <span data-ttu-id="7593b-3786">否则，节点会提升。</span><span class="sxs-lookup"><span data-stu-id="7593b-3786">Otherwise, the node is lifted.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="7593b-3787"><paramref name="expression" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-3787"><paramref name="expression" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="7593b-3788"><paramref name="method" /> 不为 <see langword="null" /> 且其表示的方法返回 <see langword="void" />；不为 <see langword="static" />（在 Visual Basic 中不为 <see langword="Shared" />）；或者不是正好带一个参数。</span><span class="sxs-lookup"><span data-stu-id="7593b-3788"><paramref name="method" /> is not <see langword="null" /> and the method it represents returns <see langword="void" />, is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic), or does not take exactly one argument.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="7593b-3789"><paramref name="method" /> 为 <see langword="null" />，并且没有为 <paramref name="expression" />.Type 定义一元正运算符。</span><span class="sxs-lookup"><span data-stu-id="7593b-3789"><paramref name="method" /> is <see langword="null" /> and the unary plus operator is not defined for <paramref name="expression" />.Type.</span></span>  
  
<span data-ttu-id="7593b-3790">- 或 -</span><span class="sxs-lookup"><span data-stu-id="7593b-3790">-or-</span></span> 
 <span data-ttu-id="7593b-3791"><paramref name="expression" />.Type（如果它是可以为 null 的值类型，则取其相应的不可以为 null 的类型）不能赋给 <paramref name="method" /> 所表示的方法的参数类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-3791"><paramref name="expression" />.Type (or its corresponding non-nullable type if it is a nullable value type) is not assignable to the argument type of the method represented by <paramref name="method" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Unbox">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression Unbox (System.Linq.Expressions.Expression expression, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression Unbox(class System.Linq.Expressions.Expression expression, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Unbox(System.Linq.Expressions.Expression,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ Unbox(System::Linq::Expressions::Expression ^ expression, Type ^ type);" />
      <MemberSignature Language="F#" Value="static member Unbox : System.Linq.Expressions.Expression * Type -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.Unbox (expression, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="type" Type="System.Type" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="expression"><span data-ttu-id="7593b-3792">要取消装箱的 <see cref="T:System.Linq.Expressions.Expression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-3792">An <see cref="T:System.Linq.Expressions.Expression" /> to unbox.</span></span></param>
        <param name="type"><span data-ttu-id="7593b-3793">表达式的新 <see cref="T:System.Type" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-3793">The new <see cref="T:System.Type" /> of the expression.</span></span></param>
        <summary><span data-ttu-id="7593b-3794">创建一个表示显式取消装箱的 <see cref="T:System.Linq.Expressions.UnaryExpression" />。</span><span class="sxs-lookup"><span data-stu-id="7593b-3794">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents an explicit unboxing.</span></span></summary>
        <returns><span data-ttu-id="7593b-3795"><see cref="T:System.Linq.Expressions.UnaryExpression" /> 的实例。</span><span class="sxs-lookup"><span data-stu-id="7593b-3795">An instance of <see cref="T:System.Linq.Expressions.UnaryExpression" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Variable">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="7593b-3796">创建一个 <see cref="T:System.Linq.Expressions.ParameterExpression" /> 节点，该节点可用于标识表达式树中的参数或变量。</span><span class="sxs-lookup"><span data-stu-id="7593b-3796">Creates a <see cref="T:System.Linq.Expressions.ParameterExpression" /> node that can be used to identify a parameter or a variable in an expression tree.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Variable">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ParameterExpression Variable (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ParameterExpression Variable(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Variable(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::ParameterExpression ^ Variable(Type ^ type);" />
      <MemberSignature Language="F#" Value="static member Variable : Type -&gt; System.Linq.Expressions.ParameterExpression" Usage="System.Linq.Expressions.Expression.Variable type" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ParameterExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="type"><span data-ttu-id="7593b-3797">参数或变量的类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-3797">The type of the parameter or variable.</span></span></param>
        <summary><span data-ttu-id="7593b-3798">创建一个 <see cref="T:System.Linq.Expressions.ParameterExpression" /> 节点，该节点可用于标识表达式树中的参数或变量。</span><span class="sxs-lookup"><span data-stu-id="7593b-3798">Creates a <see cref="T:System.Linq.Expressions.ParameterExpression" /> node that can be used to identify a parameter or a variable in an expression tree.</span></span></summary>
        <returns><span data-ttu-id="7593b-3799">具有指定的名称和类型的 <see cref="T:System.Linq.Expressions.ParameterExpression" /> 节点</span><span class="sxs-lookup"><span data-stu-id="7593b-3799">A <see cref="T:System.Linq.Expressions.ParameterExpression" /> node with the specified name and type</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Variable">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ParameterExpression Variable (Type type, string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ParameterExpression Variable(class System.Type type, string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Variable(System.Type,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::ParameterExpression ^ Variable(Type ^ type, System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member Variable : Type * string -&gt; System.Linq.Expressions.ParameterExpression" Usage="System.Linq.Expressions.Expression.Variable (type, name)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ParameterExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="name" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="type"><span data-ttu-id="7593b-3800">参数或变量的类型。</span><span class="sxs-lookup"><span data-stu-id="7593b-3800">The type of the parameter or variable.</span></span></param>
        <param name="name"><span data-ttu-id="7593b-3801">参数或变量的名称。</span><span class="sxs-lookup"><span data-stu-id="7593b-3801">The name of the parameter or variable.</span></span> <span data-ttu-id="7593b-3802">此名称仅用于调试或打印目的。</span><span class="sxs-lookup"><span data-stu-id="7593b-3802">This name is used for debugging or printing purpose only.</span></span></param>
        <summary><span data-ttu-id="7593b-3803">创建一个 <see cref="T:System.Linq.Expressions.ParameterExpression" /> 节点，该节点可用于标识表达式树中的参数或变量。</span><span class="sxs-lookup"><span data-stu-id="7593b-3803">Creates a <see cref="T:System.Linq.Expressions.ParameterExpression" /> node that can be used to identify a parameter or a variable in an expression tree.</span></span></summary>
        <returns><span data-ttu-id="7593b-3804">具有指定的名称和类型的 <see cref="T:System.Linq.Expressions.ParameterExpression" /> 节点。</span><span class="sxs-lookup"><span data-stu-id="7593b-3804">A <see cref="T:System.Linq.Expressions.ParameterExpression" /> node with the specified name and type.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="VisitChildren">
      <MemberSignature Language="C#" Value="protected internal virtual System.Linq.Expressions.Expression VisitChildren (System.Linq.Expressions.ExpressionVisitor visitor);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance class System.Linq.Expressions.Expression VisitChildren(class System.Linq.Expressions.ExpressionVisitor visitor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.VisitChildren(System.Linq.Expressions.ExpressionVisitor)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Function VisitChildren (visitor As ExpressionVisitor) As Expression" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual System::Linq::Expressions::Expression ^ VisitChildren(System::Linq::Expressions::ExpressionVisitor ^ visitor);" />
      <MemberSignature Language="F#" Value="abstract member VisitChildren : System.Linq.Expressions.ExpressionVisitor -&gt; System.Linq.Expressions.Expression&#xA;override this.VisitChildren : System.Linq.Expressions.ExpressionVisitor -&gt; System.Linq.Expressions.Expression" Usage="expression.VisitChildren visitor" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.Expression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="visitor" Type="System.Linq.Expressions.ExpressionVisitor" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="visitor"><span data-ttu-id="7593b-3805"><see cref="T:System.Func`2" /> 的实例。</span><span class="sxs-lookup"><span data-stu-id="7593b-3805">An instance of <see cref="T:System.Func`2" />.</span></span></param>
        <summary><span data-ttu-id="7593b-3806">简化节点，然后对简化的表达式调用访问者委托。</span><span class="sxs-lookup"><span data-stu-id="7593b-3806">Reduces the node and then calls the visitor delegate on the reduced expression.</span></span> <span data-ttu-id="7593b-3807">该方法在节点不可简化时引发异常。</span><span class="sxs-lookup"><span data-stu-id="7593b-3807">The method throws an exception if the node is not reducible.</span></span></summary>
        <returns><span data-ttu-id="7593b-3808">要访问的表达式，或应在树中替换此表达式的表达式。</span><span class="sxs-lookup"><span data-stu-id="7593b-3808">The expression being visited, or an expression which should replace it in the tree.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7593b-3809">重写此方法可提供逻辑来遍历节点的子节点。</span><span class="sxs-lookup"><span data-stu-id="7593b-3809">Override this method to provide logic to walk the node's children.</span></span> <span data-ttu-id="7593b-3810">典型的实现将调用访问者。访问其每个子项，如果其中任何一个项发生更改，则应使用修改后的子级返回其自身的新副本。</span><span class="sxs-lookup"><span data-stu-id="7593b-3810">A typical implementation will call visitor.Visit on each of its children, and if any of them change, should return a new copy of itself with the modified children.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
