<Type Name="EntityKey" FullName="System.Data.EntityKey">
  <Metadata><Meta Name="ms.openlocfilehash" Value="60abe13561455006af1d4b25fb961a8c1b4c5454" /><Meta Name="ms.sourcegitcommit" Value="9f423345753728e8cad38d4a22663a109e69ea91" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-CN" /><Meta Name="ms.lasthandoff" Value="03/04/2021" /><Meta Name="ms.locfileid" Value="102074011" /></Metadata><TypeSignature Language="C#" Value="public sealed class EntityKey : IEquatable&lt;System.Data.EntityKey&gt;" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable sealed beforefieldinit EntityKey extends System.Object implements class System.IEquatable`1&lt;class System.Data.EntityKey&gt;" />
  <TypeSignature Language="DocId" Value="T:System.Data.EntityKey" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class EntityKey&#xA;Implements IEquatable(Of EntityKey)" />
  <TypeSignature Language="C++ CLI" Value="public ref class EntityKey sealed : IEquatable&lt;System::Data::EntityKey ^&gt;" />
  <TypeSignature Language="F#" Value="type EntityKey = class&#xA;    interface IEquatable&lt;EntityKey&gt;" />
  <AssemblyInfo>
    <AssemblyName>System.Data.Entity</AssemblyName>
    <AssemblyVersion>3.5.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IEquatable&lt;System.Data.EntityKey&gt;</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName Language="C#">[System.Diagnostics.DebuggerDisplay("{ConcatKeyValue()}")]</AttributeName>
      <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerDisplay("{ConcatKeyValue()}")&gt;]</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName Language="C#">[System.Runtime.Serialization.DataContract(IsReference=true)]</AttributeName>
      <AttributeName Language="F#">[&lt;System.Runtime.Serialization.DataContract(IsReference=true)&gt;]</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName Language="C#">[System.Serializable]</AttributeName>
      <AttributeName Language="F#">[&lt;System.Serializable&gt;]</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="93484-101">提供对作为实体类型实例的对象的持久引用。</span><span class="sxs-lookup"><span data-stu-id="93484-101">Provides a durable reference to an object that is an instance of an entity type.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="93484-102"><xref:System.Data.EntityKey> 对象是不可变的，也就是说，这些对象在构造之后不可以修改。</span><span class="sxs-lookup"><span data-stu-id="93484-102">The <xref:System.Data.EntityKey> objects are immutable; that is, after they are constructed they cannot be modified.</span></span>

 <span data-ttu-id="93484-103">有关详细信息，请参阅使用 [实体键](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/dd283139(v=vs.100))。</span><span class="sxs-lookup"><span data-stu-id="93484-103">For more information, see [Working with Entity Keys](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/dd283139(v=vs.100)).</span></span>



## Examples
 <span data-ttu-id="93484-104">这些示例基于 [Microsoft SQL Server 产品示例：数据库](https://archive.codeplex.com/?p=msftdbprodsamples)。</span><span class="sxs-lookup"><span data-stu-id="93484-104">These examples are based on the [Microsoft SQL Server Product Samples: Database](https://archive.codeplex.com/?p=msftdbprodsamples).</span></span> <span data-ttu-id="93484-105">示例演示如何创建和使用 <xref:System.Data.EntityKey> 。</span><span class="sxs-lookup"><span data-stu-id="93484-105">The examples show you how to create and use an <xref:System.Data.EntityKey>.</span></span>

 [!code-csharp[DP ObjectServices Concepts#EntityKeyClass_TryGetObjectByKey](~/samples/snippets/csharp/VS_Snippets_Data/DP ObjectServices Concepts/CS/Source.cs#entitykeyclass_trygetobjectbykey)]
 [!code-vb[DP ObjectServices Concepts#EntityKeyClass_TryGetObjectByKey](~/samples/snippets/visualbasic/VS_Snippets_Data/DP ObjectServices Concepts/VB/Source.vb#entitykeyclass_trygetobjectbykey)]

 [!code-csharp[DP ObjectServices Concepts#AddObjectUsingKey](~/samples/snippets/csharp/VS_Snippets_Data/DP ObjectServices Concepts/CS/Source.cs#addobjectusingkey)]
 [!code-vb[DP ObjectServices Concepts#AddObjectUsingKey](~/samples/snippets/visualbasic/VS_Snippets_Data/DP ObjectServices Concepts/VB/Source.vb#addobjectusingkey)]

 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="93484-106">初始化 <see cref="T:System.Data.EntityKey" /> 类的新实例。</span><span class="sxs-lookup"><span data-stu-id="93484-106">Initializes a new instance of the <see cref="T:System.Data.EntityKey" /> class.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EntityKey ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.EntityKey.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; EntityKey();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="93484-107">初始化 <see cref="T:System.Data.EntityKey" /> 类的新实例。</span><span class="sxs-lookup"><span data-stu-id="93484-107">Initializes a new instance of the <see cref="T:System.Data.EntityKey" /> class.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EntityKey (string qualifiedEntitySetName, System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;string,object&gt;&gt; entityKeyValues);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string qualifiedEntitySetName, class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;string, object&gt;&gt; entityKeyValues) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.EntityKey.#ctor(System.String,System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{System.String,System.Object}})" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (qualifiedEntitySetName As String, entityKeyValues As IEnumerable(Of KeyValuePair(Of String, Object)))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; EntityKey(System::String ^ qualifiedEntitySetName, System::Collections::Generic::IEnumerable&lt;System::Collections::Generic::KeyValuePair&lt;System::String ^, System::Object ^&gt;&gt; ^ entityKeyValues);" />
      <MemberSignature Language="F#" Value="new System.Data.EntityKey : string * seq&lt;System.Collections.Generic.KeyValuePair&lt;string, obj&gt;&gt; -&gt; System.Data.EntityKey" Usage="new System.Data.EntityKey (qualifiedEntitySetName, entityKeyValues)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="qualifiedEntitySetName" Type="System.String" />
        <Parameter Name="entityKeyValues" Type="System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Object&gt;&gt;" />
      </Parameters>
      <Docs>
        <param name="qualifiedEntitySetName"><span data-ttu-id="93484-108">一个 <see cref="T:System.String" />，它是由实体容器名称限定的实体集名称。</span><span class="sxs-lookup"><span data-stu-id="93484-108">A <see cref="T:System.String" /> that is the entity set name qualified by the entity container name.</span></span></param>
        <param name="entityKeyValues"><span data-ttu-id="93484-109">一个泛型 <see cref="T:System.Collections.Generic.KeyValuePair" /> 集合。</span><span class="sxs-lookup"><span data-stu-id="93484-109">A generic <see cref="T:System.Collections.Generic.KeyValuePair" /> collection.</span></span>

<span data-ttu-id="93484-110">每个键/值对中，属性名称作为键，该属性的值作为值。</span><span class="sxs-lookup"><span data-stu-id="93484-110">Each key/value pair has a property name as the key and the value of that property as the value.</span></span> <span data-ttu-id="93484-111">对作为 <see cref="T:System.Data.EntityKey" /> 的一部分的每个属性都应有一个键/值对。</span><span class="sxs-lookup"><span data-stu-id="93484-111">There should be one pair for each property that is part of the <see cref="T:System.Data.EntityKey" />.</span></span> <span data-ttu-id="93484-112">键/值对的顺序并不重要，但是应包括每个键属性。</span><span class="sxs-lookup"><span data-stu-id="93484-112">The order of the key/value pairs is not important, but each key property should be included.</span></span> <span data-ttu-id="93484-113">属性名称是未使用实体类型名称或架构名称限定的简单名称。</span><span class="sxs-lookup"><span data-stu-id="93484-113">The property names are simple names that are not qualified with an entity type name or the schema name.</span></span></param>
        <summary><span data-ttu-id="93484-114">使用实体集名称和泛型 <see cref="T:System.Data.EntityKey" /> 集合初始化 <see cref="T:System.Collections.Generic.KeyValuePair" /> 类的新实例。</span><span class="sxs-lookup"><span data-stu-id="93484-114">Initializes a new instance of the <see cref="T:System.Data.EntityKey" /> class with an entity set name and a generic <see cref="T:System.Collections.Generic.KeyValuePair" /> collection.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Examples
 <span data-ttu-id="93484-115">此示例基于 [Microsoft SQL Server 产品示例：数据库](https://archive.codeplex.com/?p=msftdbprodsamples)。</span><span class="sxs-lookup"><span data-stu-id="93484-115">This example is based on the [Microsoft SQL Server Product Samples: Database](https://archive.codeplex.com/?p=msftdbprodsamples).</span></span> <span data-ttu-id="93484-116">该示例演示如何创建和使用 <xref:System.Data.EntityKey> 。</span><span class="sxs-lookup"><span data-stu-id="93484-116">The example shows you how to create and use an <xref:System.Data.EntityKey>.</span></span>

 [!code-csharp[DP ObjectServices Concepts#AddObjectUsingKey](~/samples/snippets/csharp/VS_Snippets_Data/DP ObjectServices Concepts/CS/Source.cs#addobjectusingkey)]
 [!code-vb[DP ObjectServices Concepts#AddObjectUsingKey](~/samples/snippets/visualbasic/VS_Snippets_Data/DP ObjectServices Concepts/VB/Source.vb#addobjectusingkey)]

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EntityKey (string qualifiedEntitySetName, System.Collections.Generic.IEnumerable&lt;System.Data.EntityKeyMember&gt; entityKeyValues);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string qualifiedEntitySetName, class System.Collections.Generic.IEnumerable`1&lt;class System.Data.EntityKeyMember&gt; entityKeyValues) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.EntityKey.#ctor(System.String,System.Collections.Generic.IEnumerable{System.Data.EntityKeyMember})" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (qualifiedEntitySetName As String, entityKeyValues As IEnumerable(Of EntityKeyMember))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; EntityKey(System::String ^ qualifiedEntitySetName, System::Collections::Generic::IEnumerable&lt;System::Data::EntityKeyMember ^&gt; ^ entityKeyValues);" />
      <MemberSignature Language="F#" Value="new System.Data.EntityKey : string * seq&lt;System.Data.EntityKeyMember&gt; -&gt; System.Data.EntityKey" Usage="new System.Data.EntityKey (qualifiedEntitySetName, entityKeyValues)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="qualifiedEntitySetName" Type="System.String" />
        <Parameter Name="entityKeyValues" Type="System.Collections.Generic.IEnumerable&lt;System.Data.EntityKeyMember&gt;" />
      </Parameters>
      <Docs>
        <param name="qualifiedEntitySetName"><span data-ttu-id="93484-117">一个 <see cref="T:System.String" />，它是由实体容器名称限定的实体集名称。</span><span class="sxs-lookup"><span data-stu-id="93484-117">A <see cref="T:System.String" /> that is the entity set name qualified by the entity container name.</span></span></param>
        <param name="entityKeyValues"><span data-ttu-id="93484-118">用来初始化键的 <see cref="T:System.Collections.Generic.IEnumerable`1" /> 对象的 <see cref="T:System.Data.EntityKeyMember" /> 集合。</span><span class="sxs-lookup"><span data-stu-id="93484-118">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> collection of <see cref="T:System.Data.EntityKeyMember" /> objects with which to initialize the key.</span></span></param>
        <summary><span data-ttu-id="93484-119">使用实体集名称和 <see cref="T:System.Data.EntityKey" /> 对象的 <see cref="T:System.Collections.Generic.IEnumerable`1" /> 集合初始化 <see cref="T:System.Data.EntityKeyMember" /> 类的新实例。</span><span class="sxs-lookup"><span data-stu-id="93484-119">Initializes a new instance of the <see cref="T:System.Data.EntityKey" /> class with an entity set name and an <see cref="T:System.Collections.Generic.IEnumerable`1" /> collection of <see cref="T:System.Data.EntityKeyMember" /> objects.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EntityKey (string qualifiedEntitySetName, string keyName, object keyValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string qualifiedEntitySetName, string keyName, object keyValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.EntityKey.#ctor(System.String,System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (qualifiedEntitySetName As String, keyName As String, keyValue As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; EntityKey(System::String ^ qualifiedEntitySetName, System::String ^ keyName, System::Object ^ keyValue);" />
      <MemberSignature Language="F#" Value="new System.Data.EntityKey : string * string * obj -&gt; System.Data.EntityKey" Usage="new System.Data.EntityKey (qualifiedEntitySetName, keyName, keyValue)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="qualifiedEntitySetName" Type="System.String" />
        <Parameter Name="keyName" Type="System.String" />
        <Parameter Name="keyValue" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="qualifiedEntitySetName"><span data-ttu-id="93484-120">一个 <see cref="T:System.String" />，它是由实体容器名称限定的实体集名称。</span><span class="sxs-lookup"><span data-stu-id="93484-120">A <see cref="T:System.String" /> that is the entity set name qualified by the entity container name.</span></span></param>
        <param name="keyName"><span data-ttu-id="93484-121">表示键名称的 <see cref="T:System.String" />。</span><span class="sxs-lookup"><span data-stu-id="93484-121">A <see cref="T:System.String" /> that is the name of the key.</span></span></param>
        <param name="keyValue"><span data-ttu-id="93484-122">表示键值的 <see cref="T:System.Object" />。</span><span class="sxs-lookup"><span data-stu-id="93484-122">An <see cref="T:System.Object" /> that is the key value.</span></span></param>
        <summary><span data-ttu-id="93484-123">使用实体集名称和特定实体键对初始化 <see cref="T:System.Data.EntityKey" /> 类的新实例。</span><span class="sxs-lookup"><span data-stu-id="93484-123">Initializes a new instance of the <see cref="T:System.Data.EntityKey" /> class with an entity set name and specific entity key pair.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Examples
 <span data-ttu-id="93484-124">此示例基于 [Microsoft SQL Server 产品示例：数据库](https://archive.codeplex.com/?p=msftdbprodsamples)。</span><span class="sxs-lookup"><span data-stu-id="93484-124">This example is based on the [Microsoft SQL Server Product Samples: Database](https://archive.codeplex.com/?p=msftdbprodsamples).</span></span> <span data-ttu-id="93484-125">该示例演示如何创建和使用 <xref:System.Data.EntityKey> 。</span><span class="sxs-lookup"><span data-stu-id="93484-125">The example shows you how to create and use an <xref:System.Data.EntityKey>.</span></span>

 [!code-csharp[DP ObjectServices Concepts#AddObjectUsingKey](~/samples/snippets/csharp/VS_Snippets_Data/DP ObjectServices Concepts/CS/Source.cs#addobjectusingkey)]
 [!code-vb[DP ObjectServices Concepts#AddObjectUsingKey](~/samples/snippets/visualbasic/VS_Snippets_Data/DP ObjectServices Concepts/VB/Source.vb#addobjectusingkey)]

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EntityContainerName">
      <MemberSignature Language="C#" Value="public string EntityContainerName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string EntityContainerName" />
      <MemberSignature Language="DocId" Value="P:System.Data.EntityKey.EntityContainerName" />
      <MemberSignature Language="VB.NET" Value="Public Property EntityContainerName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ EntityContainerName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.EntityContainerName : string with get, set" Usage="System.Data.EntityKey.EntityContainerName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.Serialization.DataMember]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.Serialization.DataMember&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="93484-126">获取或设置实体容器的名称。</span><span class="sxs-lookup"><span data-stu-id="93484-126">Gets or sets the name of the entity container.</span></span></summary>
        <value><span data-ttu-id="93484-127">一个 <see cref="T:System.String" /> 值，表示 <see cref="T:System.Data.EntityKey" /> 所属实体的实体容器的名称。</span><span class="sxs-lookup"><span data-stu-id="93484-127">A <see cref="T:System.String" /> value that is the name of the entity container for the entity to which the <see cref="T:System.Data.EntityKey" /> belongs.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EntityKeyValues">
      <MemberSignature Language="C#" Value="public System.Data.EntityKeyMember[] EntityKeyValues { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.EntityKeyMember[] EntityKeyValues" />
      <MemberSignature Language="DocId" Value="P:System.Data.EntityKey.EntityKeyValues" />
      <MemberSignature Language="VB.NET" Value="Public Property EntityKeyValues As EntityKeyMember()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::Data::EntityKeyMember ^&gt; ^ EntityKeyValues { cli::array &lt;System::Data::EntityKeyMember ^&gt; ^ get(); void set(cli::array &lt;System::Data::EntityKeyMember ^&gt; ^ value); };" />
      <MemberSignature Language="F#" Value="member this.EntityKeyValues : System.Data.EntityKeyMember[] with get, set" Usage="System.Data.EntityKey.EntityKeyValues" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.Serialization.DataMember]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.Serialization.DataMember&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.EntityKeyMember[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="93484-128">获取或设置与此 <see cref="T:System.Data.EntityKey" /> 关联的键值。</span><span class="sxs-lookup"><span data-stu-id="93484-128">Gets or sets the key values associated with this <see cref="T:System.Data.EntityKey" />.</span></span></summary>
        <value><span data-ttu-id="93484-129">此 <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> 的键值的 <see cref="T:System.Data.EntityKey" />。</span><span class="sxs-lookup"><span data-stu-id="93484-129">A <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> of key values for this <see cref="T:System.Data.EntityKey" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="93484-130"><xref:System.Data.EntityKey> 类包含一些值的副本，为此类型实体指定的逻辑键就是由这些值构成的。</span><span class="sxs-lookup"><span data-stu-id="93484-130">The <xref:System.Data.EntityKey> class contains a copy of the values that make up the logical key that is specified for this type of entity.</span></span>

 <span data-ttu-id="93484-131">在 <xref:System.Collections.ObjectModel.ReadOnlyCollection%601> 中，<xref:System.Collections.Generic.KeyValuePair%602> 的成员都具有一个属性名称和一个值，其中键是属性名称，值是对象的该属性的实际值。</span><span class="sxs-lookup"><span data-stu-id="93484-131">The members of the <xref:System.Collections.ObjectModel.ReadOnlyCollection%601> each have a property name and a value in a <xref:System.Collections.Generic.KeyValuePair%602>, where the key is the property name and the value is the actual value of that property on the object.</span></span>

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EntityNotValidKey">
      <MemberSignature Language="C#" Value="public static readonly System.Data.EntityKey EntityNotValidKey;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Data.EntityKey EntityNotValidKey" />
      <MemberSignature Language="DocId" Value="F:System.Data.EntityKey.EntityNotValidKey" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly EntityNotValidKey As EntityKey " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Data::EntityKey ^ EntityNotValidKey;" />
      <MemberSignature Language="F#" Value=" staticval mutable EntityNotValidKey : System.Data.EntityKey" Usage="System.Data.EntityKey.EntityNotValidKey" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.EntityKey</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="93484-132">一个简单的 <see cref="T:System.Data.EntityKey" />，标识由失败的 [TREAT](/dotnet/framework/data/adonet/ef/language-reference/treat-entity-sql) 运算产生的实体。</span><span class="sxs-lookup"><span data-stu-id="93484-132">A simple <see cref="T:System.Data.EntityKey" /> identifying an entity that resulted from a failed [TREAT](/dotnet/framework/data/adonet/ef/language-reference/treat-entity-sql) operation.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="93484-133">有多种方法可获得无效实体。</span><span class="sxs-lookup"><span data-stu-id="93484-133">There are various ways to get an invalid entity.</span></span> <span data-ttu-id="93484-134">最常见的情况是，实体 SQL 查询使用 [TREAT](/dotnet/framework/data/adonet/ef/language-reference/treat-entity-sql) 运算符将多态类型的实例解释为特定类型，而相关的实例不匹配。</span><span class="sxs-lookup"><span data-stu-id="93484-134">The most common scenario is when an Entity SQL query uses the [TREAT](/dotnet/framework/data/adonet/ef/language-reference/treat-entity-sql) operator to interpret an instance of a polymorphic type as a particular type, and the instance in question does not match.</span></span> <span data-ttu-id="93484-135"> ([TREAT](/dotnet/framework/data/adonet/ef/language-reference/treat-entity-sql) 类似于 c # `as` 运算符) 。</span><span class="sxs-lookup"><span data-stu-id="93484-135">([TREAT](/dotnet/framework/data/adonet/ef/language-reference/treat-entity-sql) is similar to the C# `as` operator).</span></span> <span data-ttu-id="93484-136">在这种情况下，查询返回无效实体，该实体的实体键设置为 <xref:System.Data.EntityKey.EntityNotValidKey>。</span><span class="sxs-lookup"><span data-stu-id="93484-136">In this case, the query returns an entity that is not valid, and the entity key of the resulting entity is set to <xref:System.Data.EntityKey.EntityNotValidKey>.</span></span>

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EntitySetName">
      <MemberSignature Language="C#" Value="public string EntitySetName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string EntitySetName" />
      <MemberSignature Language="DocId" Value="P:System.Data.EntityKey.EntitySetName" />
      <MemberSignature Language="VB.NET" Value="Public Property EntitySetName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ EntitySetName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.EntitySetName : string with get, set" Usage="System.Data.EntityKey.EntitySetName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.Serialization.DataMember]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.Serialization.DataMember&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="93484-137">获取或设置实体集的名称。</span><span class="sxs-lookup"><span data-stu-id="93484-137">Gets or sets the name of the entity set.</span></span></summary>
        <value><span data-ttu-id="93484-138">一个 <see cref="T:System.String" /> 值，表示 <see cref="T:System.Data.EntityKey" /> 所属实体的实体集的名称。</span><span class="sxs-lookup"><span data-stu-id="93484-138">A <see cref="T:System.String" /> value that is the name of the entity set for the entity to which the <see cref="T:System.Data.EntityKey" /> belongs.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Equals">
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="93484-139">返回一个值，该值指示此实例是否与指定的对象相等。</span><span class="sxs-lookup"><span data-stu-id="93484-139">Returns a value that indicates whether this instance is equal to a specified object.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (System.Data.EntityKey other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(class System.Data.EntityKey other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.EntityKey.Equals(System.Data.EntityKey)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (other As EntityKey) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Equals(System::Data::EntityKey ^ other);" />
      <MemberSignature Language="F#" Value="override this.Equals : System.Data.EntityKey -&gt; bool" Usage="entityKey.Equals other" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IEquatable`1.Equals(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Data.EntityKey" />
      </Parameters>
      <Docs>
        <param name="other"><span data-ttu-id="93484-140">要与此实例比较的 <see cref="T:System.Data.EntityKey" /> 对象。</span><span class="sxs-lookup"><span data-stu-id="93484-140">An <see cref="T:System.Data.EntityKey" /> object to compare with this instance.</span></span></param>
        <summary><span data-ttu-id="93484-141">返回一个值，该值指示此实例是否与指定的 <see cref="T:System.Data.EntityKey" /> 相等。</span><span class="sxs-lookup"><span data-stu-id="93484-141">Returns a value that indicates whether this instance is equal to a specified <see cref="T:System.Data.EntityKey" />.</span></span></summary>
        <returns><span data-ttu-id="93484-142">如果此实例与 <paramref name="other" /> 具有相等的值，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="93484-142"><see langword="true" /> if this instance and <paramref name="other" /> have equal values; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="93484-143">临时键与永久键的比较语义不同：</span><span class="sxs-lookup"><span data-stu-id="93484-143">Temporary keys have different comparison semantics than permanent keys:</span></span>

-   <span data-ttu-id="93484-144">临时键使用引用相等性。</span><span class="sxs-lookup"><span data-stu-id="93484-144">Temporary keys use reference equality.</span></span> <span data-ttu-id="93484-145">也就是说，对同一个临时 <xref:System.Data.EntityKey> 实例的两个引用是相等的，但其他 <xref:System.Data.EntityKey> 实例不相等。</span><span class="sxs-lookup"><span data-stu-id="93484-145">That is, two references to the exact same temporary <xref:System.Data.EntityKey> instance are equal but no other <xref:System.Data.EntityKey> instances are equal.</span></span>

-   <span data-ttu-id="93484-146">永久键根据所包含的键属性的值和 <xref:System.Data.Metadata.Edm.EntitySet> 来确定相等性。</span><span class="sxs-lookup"><span data-stu-id="93484-146">Permanent keys determine equality based on the values of the contained key properties and the <xref:System.Data.Metadata.Edm.EntitySet>.</span></span> <span data-ttu-id="93484-147">也就是说，对于两个独立的 <xref:System.Data.EntityKey> 实例，如果它们的实体集相同并且键值相等，则这两个实例相等。</span><span class="sxs-lookup"><span data-stu-id="93484-147">That is, you can have two separate <xref:System.Data.EntityKey> instances that are equal if their entity sets are the same and their key values are equal.</span></span>

 <span data-ttu-id="93484-148">此外，临时键没有 <xref:System.Data.Metadata.Edm.EntitySet> 或键值，但永久键有。</span><span class="sxs-lookup"><span data-stu-id="93484-148">In addition, temporary keys have no <xref:System.Data.Metadata.Edm.EntitySet> or key values, but permanent keys do.</span></span>

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.EntityKey.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="entityKey.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj"><span data-ttu-id="93484-149">要与此实例比较的 <see cref="T:System.Object" />。</span><span class="sxs-lookup"><span data-stu-id="93484-149">An <see cref="T:System.Object" /> to compare with this instance.</span></span></param>
        <summary><span data-ttu-id="93484-150">返回一个值，该值指示此实例是否与指定的对象相等。</span><span class="sxs-lookup"><span data-stu-id="93484-150">Returns a value that indicates whether this instance is equal to a specified object.</span></span></summary>
        <returns><span data-ttu-id="93484-151">如果此实例与 <paramref name="obj" /> 具有相等的值，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="93484-151"><see langword="true" /> if this instance and <paramref name="obj" /> have equal values; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="93484-152">临时键与永久键的比较语义不同：</span><span class="sxs-lookup"><span data-stu-id="93484-152">Temporary keys have different comparison semantics than permanent keys:</span></span>

-   <span data-ttu-id="93484-153">临时键使用引用相等性。</span><span class="sxs-lookup"><span data-stu-id="93484-153">Temporary keys use reference equality.</span></span> <span data-ttu-id="93484-154">也就是说，对同一个临时 <xref:System.Data.EntityKey> 实例的两个引用是相等的，但其他 <xref:System.Data.EntityKey> 实例不相等。</span><span class="sxs-lookup"><span data-stu-id="93484-154">That is, two references to the exact same temporary <xref:System.Data.EntityKey> instance are equal but no other <xref:System.Data.EntityKey> instances are equal.</span></span>

-   <span data-ttu-id="93484-155">永久键根据所包含的键属性的值和 <xref:System.Data.Metadata.Edm.EntitySet> 来确定相等性。</span><span class="sxs-lookup"><span data-stu-id="93484-155">Permanent keys determine equality based on the values of the contained key properties and the <xref:System.Data.Metadata.Edm.EntitySet>.</span></span> <span data-ttu-id="93484-156">也就是说，对于两个独立的 <xref:System.Data.EntityKey> 实例，如果它们的 <xref:System.Data.Metadata.Edm.EntitySet> 对象相同并且键值相等，则这两个实例相等。</span><span class="sxs-lookup"><span data-stu-id="93484-156">That is, you can have two separate <xref:System.Data.EntityKey> instances that are equal if their <xref:System.Data.Metadata.Edm.EntitySet> objects are the same and their key values are equal.</span></span>

 <span data-ttu-id="93484-157">此外，临时键没有 <xref:System.Data.Metadata.Edm.EntitySet> 或键值，但永久键有。</span><span class="sxs-lookup"><span data-stu-id="93484-157">In addition, temporary keys have no <xref:System.Data.Metadata.Edm.EntitySet> or key values, but permanent keys do.</span></span>

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetEntitySet">
      <MemberSignature Language="C#" Value="public System.Data.Metadata.Edm.EntitySet GetEntitySet (System.Data.Metadata.Edm.MetadataWorkspace metadataWorkspace);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.Metadata.Edm.EntitySet GetEntitySet(class System.Data.Metadata.Edm.MetadataWorkspace metadataWorkspace) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.EntityKey.GetEntitySet(System.Data.Metadata.Edm.MetadataWorkspace)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEntitySet (metadataWorkspace As MetadataWorkspace) As EntitySet" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::Metadata::Edm::EntitySet ^ GetEntitySet(System::Data::Metadata::Edm::MetadataWorkspace ^ metadataWorkspace);" />
      <MemberSignature Language="F#" Value="member this.GetEntitySet : System.Data.Metadata.Edm.MetadataWorkspace -&gt; System.Data.Metadata.Edm.EntitySet" Usage="entityKey.GetEntitySet metadataWorkspace" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Metadata.Edm.EntitySet</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metadataWorkspace" Type="System.Data.Metadata.Edm.MetadataWorkspace" />
      </Parameters>
      <Docs>
        <param name="metadataWorkspace"><span data-ttu-id="93484-158">包含实体的元数据工作区。</span><span class="sxs-lookup"><span data-stu-id="93484-158">The metadata workspace that contains the entity.</span></span></param>
        <summary><span data-ttu-id="93484-159">从给定的元数据工作区获取此实体键的实体集。</span><span class="sxs-lookup"><span data-stu-id="93484-159">Gets the entity set for this entity key from the given metadata workspace.</span></span></summary>
        <returns><span data-ttu-id="93484-160">实体键的 <see cref="T:System.Data.Metadata.Edm.EntitySet" />。</span><span class="sxs-lookup"><span data-stu-id="93484-160">The <see cref="T:System.Data.Metadata.Edm.EntitySet" /> for the entity key.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="93484-161">实体集是根据键的实体容器名称和实体集名称访问的。</span><span class="sxs-lookup"><span data-stu-id="93484-161">The entity set is accessed based on the entity container name and entity set name of the key.</span></span>

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="93484-162">未能在指定的元数据工作区找到实体集。</span><span class="sxs-lookup"><span data-stu-id="93484-162">The entity set could not be located in the specified metadata workspace.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.EntityKey.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="entityKey.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="93484-163">用作当前 <see cref="T:System.Data.EntityKey" /> 对象的哈希函数。</span><span class="sxs-lookup"><span data-stu-id="93484-163">Serves as a hash function for the current <see cref="T:System.Data.EntityKey" /> object.</span></span> <span data-ttu-id="93484-164"><see cref="M:System.Data.EntityKey.GetHashCode" /> 适用于哈希算法和诸如哈希表之类的数据结构。</span><span class="sxs-lookup"><span data-stu-id="93484-164"><see cref="M:System.Data.EntityKey.GetHashCode" /> is suitable for hashing algorithms and data structures such as a hash table.</span></span></summary>
        <returns><span data-ttu-id="93484-165">当前 <see cref="T:System.Data.EntityKey" /> 的哈希代码。</span><span class="sxs-lookup"><span data-stu-id="93484-165">A hash code for the current <see cref="T:System.Data.EntityKey" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsTemporary">
      <MemberSignature Language="C#" Value="public bool IsTemporary { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsTemporary" />
      <MemberSignature Language="DocId" Value="P:System.Data.EntityKey.IsTemporary" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsTemporary As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsTemporary { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsTemporary : bool" Usage="System.Data.EntityKey.IsTemporary" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="93484-166">获取一个值，该值指示 <see cref="T:System.Data.EntityKey" /> 是否是临时的。</span><span class="sxs-lookup"><span data-stu-id="93484-166">Gets a value that indicates whether the <see cref="T:System.Data.EntityKey" /> is temporary.</span></span></summary>
        <value><span data-ttu-id="93484-167">如果 <see cref="T:System.Data.EntityKey" /> 是临时的，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="93484-167"><see langword="true" /> if the <see cref="T:System.Data.EntityKey" /> is temporary; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="93484-168">创建新实体时，实体框架定义临时密钥并将 <xref:System.Data.EntityKey.IsTemporary%2A> 属性设置为 `true` 。</span><span class="sxs-lookup"><span data-stu-id="93484-168">When a new entity is created, the Entity Framework defines temporary key and sets the <xref:System.Data.EntityKey.IsTemporary%2A> property to `true`.</span></span> <span data-ttu-id="93484-169">调用 <xref:System.Data.Objects.ObjectContext.SaveChanges%2A> 方法时，实体框架会分配一个永久密钥并将 <xref:System.Data.EntityKey.IsTemporary%2A> 属性设置为 `false` 。</span><span class="sxs-lookup"><span data-stu-id="93484-169">When you call the <xref:System.Data.Objects.ObjectContext.SaveChanges%2A> method, the Entity Framework assigns a permanent key and sets the <xref:System.Data.EntityKey.IsTemporary%2A> property to `false`.</span></span>

> [!NOTE]
>  <span data-ttu-id="93484-170">临时键是由框架自动构造的，用户不能直接构造。</span><span class="sxs-lookup"><span data-stu-id="93484-170">Temporary keys are constructed automatically by the framework; they cannot be constructed directly by a user.</span></span>

 <span data-ttu-id="93484-171">临时键与永久键的比较语义不同：</span><span class="sxs-lookup"><span data-stu-id="93484-171">Temporary keys have different comparison semantics than permanent keys:</span></span>

-   <span data-ttu-id="93484-172">临时键使用引用相等性。</span><span class="sxs-lookup"><span data-stu-id="93484-172">Temporary keys use reference equality.</span></span> <span data-ttu-id="93484-173">也就是说，对同一个临时 <xref:System.Data.EntityKey> 实例的两个引用是相等的，但其他 <xref:System.Data.EntityKey> 实例不相等。</span><span class="sxs-lookup"><span data-stu-id="93484-173">That is, two references to the exact same temporary <xref:System.Data.EntityKey> instance are equal but no other <xref:System.Data.EntityKey> instances are equal.</span></span>

-   <span data-ttu-id="93484-174">永久键根据所包含的键属性的值和 <xref:System.Data.Metadata.Edm.EntitySet> 来确定相等性。</span><span class="sxs-lookup"><span data-stu-id="93484-174">Permanent keys determine equality based on the values of the contained key properties and the <xref:System.Data.Metadata.Edm.EntitySet>.</span></span> <span data-ttu-id="93484-175">也就是说，对于两个独立的 <xref:System.Data.EntityKey> 实例，如果它们的实体集相同并且键值相等，则这两个实例相等。</span><span class="sxs-lookup"><span data-stu-id="93484-175">That is, you can have two separate <xref:System.Data.EntityKey> instances that are equal if their entity sets are the same and their key values are equal.</span></span>

 <span data-ttu-id="93484-176">此外，临时键没有 <xref:System.Data.Metadata.Edm.EntitySet> 或键值，但永久键有。</span><span class="sxs-lookup"><span data-stu-id="93484-176">In addition, temporary keys have no <xref:System.Data.Metadata.Edm.EntitySet> or key values, but permanent keys do.</span></span>

 <span data-ttu-id="93484-177">当在 <xref:System.Data.Objects.ObjectStateEntry.AcceptChanges%2A> 实体的上调用方法 <xref:System.Data.Objects.ObjectStateEntry> 并且实体从 <xref:System.Data.EntityState.Added> 状态转换为 <xref:System.Data.EntityState.Unchanged> 状态时，实体框架会自动为实体计算新的永久密钥并同步所有临时键引用。</span><span class="sxs-lookup"><span data-stu-id="93484-177">When the <xref:System.Data.Objects.ObjectStateEntry.AcceptChanges%2A> method is called on an entity's <xref:System.Data.Objects.ObjectStateEntry> and the entity transitions from the <xref:System.Data.EntityState.Added> state to <xref:System.Data.EntityState.Unchanged> state, the Entity Framework automatically computes a new permanent key for the entity and synchronizes all temporary key references.</span></span>

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="NoEntitySetKey">
      <MemberSignature Language="C#" Value="public static readonly System.Data.EntityKey NoEntitySetKey;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Data.EntityKey NoEntitySetKey" />
      <MemberSignature Language="DocId" Value="F:System.Data.EntityKey.NoEntitySetKey" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly NoEntitySetKey As EntityKey " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Data::EntityKey ^ NoEntitySetKey;" />
      <MemberSignature Language="F#" Value=" staticval mutable NoEntitySetKey : System.Data.EntityKey" Usage="System.Data.EntityKey.NoEntitySetKey" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.EntityKey</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="93484-178">一个单独的 <see cref="T:System.Data.EntityKey" />，它标识一个只读实体。</span><span class="sxs-lookup"><span data-stu-id="93484-178">A singleton <see cref="T:System.Data.EntityKey" /> by which a read-only entity is identified.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="93484-179">只读实体标识的实体除了与实际实体集不关联之外，在其他各方面都是有效的。</span><span class="sxs-lookup"><span data-stu-id="93484-179">A read-only entity identifies an entity that is valid in every way, except that it is not associated with an actual entity set.</span></span> <span data-ttu-id="93484-180">这可能会作为实体 SQL 查询的结果的一部分来构造和返回在 (查询文本中指定的实体实例，而不是与从数据库表) 检索到的实体相对应。</span><span class="sxs-lookup"><span data-stu-id="93484-180">This can occur as part of the result of an Entity SQL query that constructs and returns an entity instance specified within the text of the query (as opposed to an entity that was retrieved from a database table).</span></span> <span data-ttu-id="93484-181">与某个实体集关联之前，没有实体集的实体不能保存到数据库中。</span><span class="sxs-lookup"><span data-stu-id="93484-181">An entity that does not have an entity set cannot be persisted to the database until it is associated with some entity set.</span></span> <span data-ttu-id="93484-182">因此，无论指定的实际合并选项是什么，对象具体化程序都以指定了 <xref:System.Data.Objects.MergeOption.NoTracking> 合并选项的方式处理这种实体。</span><span class="sxs-lookup"><span data-stu-id="93484-182">Therefore, the object materializer will treat this kind of entity as if the <xref:System.Data.Objects.MergeOption.NoTracking> merge option was specified, regardless of the actual merge option that was specified.</span></span> <span data-ttu-id="93484-183">将创建一个实体对象，但不解析它的身份，也不将它作为具体化过程的一部分添加到状态管理器中。</span><span class="sxs-lookup"><span data-stu-id="93484-183">An entity object will be created, but its identity will not be resolved and it will not be added to the state manager as part of the materialization process.</span></span>

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnDeserialized">
      <MemberSignature Language="C#" Value="public void OnDeserialized (System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void OnDeserialized(valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.EntityKey.OnDeserialized(System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Public Sub OnDeserialized (context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void OnDeserialized(System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="member this.OnDeserialized : System.Runtime.Serialization.StreamingContext -&gt; unit" Usage="entityKey.OnDeserialized context" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.Serialization.OnDeserialized]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.Serialization.OnDeserialized&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.ComponentModel.Browsable(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.Browsable(false)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="context"><span data-ttu-id="93484-184">说明给定序列化流的源和目标，并提供另一个调用方定义的上下文。</span><span class="sxs-lookup"><span data-stu-id="93484-184">Describes the source and destination of a given serialized stream and provides an additional caller-defined context.</span></span></param>
        <summary><span data-ttu-id="93484-185">用于反序列化 <see cref="T:System.Data.EntityKey" /> 的帮助器方法。</span><span class="sxs-lookup"><span data-stu-id="93484-185">Helper method that is used to deserialize an <see cref="T:System.Data.EntityKey" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="93484-186">在反序列化 <xref:System.Data.EntityKey.OnDeserialized%2A> 时，<xref:System.Data.EntityKey> 由对象服务使用。</span><span class="sxs-lookup"><span data-stu-id="93484-186"><xref:System.Data.EntityKey.OnDeserialized%2A> is used by Object Services when deserializing an <xref:System.Data.EntityKey>.</span></span> <span data-ttu-id="93484-187">有关详细信息，请参阅 [序列化对象](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb738446(v=vs.100))。</span><span class="sxs-lookup"><span data-stu-id="93484-187">For more information, see [Serializing Objects](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb738446(v=vs.100)).</span></span>

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnDeserializing">
      <MemberSignature Language="C#" Value="public void OnDeserializing (System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void OnDeserializing(valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.EntityKey.OnDeserializing(System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Public Sub OnDeserializing (context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void OnDeserializing(System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="member this.OnDeserializing : System.Runtime.Serialization.StreamingContext -&gt; unit" Usage="entityKey.OnDeserializing context" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.Serialization.OnDeserializing]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.Serialization.OnDeserializing&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.ComponentModel.Browsable(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.Browsable(false)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="context"><span data-ttu-id="93484-188">说明给定序列化流的源和目标，并提供另一个调用方定义的上下文。</span><span class="sxs-lookup"><span data-stu-id="93484-188">Describes the source and destination of a given serialized stream, and provides an additional caller-defined context.</span></span></param>
        <summary><span data-ttu-id="93484-189">用于反序列化 <see cref="T:System.Data.EntityKey" /> 的帮助器方法。</span><span class="sxs-lookup"><span data-stu-id="93484-189">Helper method that is used to deserialize an <see cref="T:System.Data.EntityKey" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="93484-190">在反序列化 <xref:System.Data.EntityKey.OnDeserializing%2A> 时，<xref:System.Data.EntityKey> 由对象服务使用。</span><span class="sxs-lookup"><span data-stu-id="93484-190"><xref:System.Data.EntityKey.OnDeserializing%2A> is used by Object Services when deserializing an <xref:System.Data.EntityKey>.</span></span> <span data-ttu-id="93484-191">有关详细信息，请参阅 [序列化对象](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb738446(v=vs.100))。</span><span class="sxs-lookup"><span data-stu-id="93484-191">For more information, see [Serializing Objects](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb738446(v=vs.100)).</span></span>

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (System.Data.EntityKey key1, System.Data.EntityKey key2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(class System.Data.EntityKey key1, class System.Data.EntityKey key2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.EntityKey.op_Equality(System.Data.EntityKey,System.Data.EntityKey)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (key1 As EntityKey, key2 As EntityKey) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::Data::EntityKey ^ key1, System::Data::EntityKey ^ key2);" />
      <MemberSignature Language="F#" Value="static member ( = ) : System.Data.EntityKey * System.Data.EntityKey -&gt; bool" Usage="key1 = key2" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key1" Type="System.Data.EntityKey" />
        <Parameter Name="key2" Type="System.Data.EntityKey" />
      </Parameters>
      <Docs>
        <param name="key1"><span data-ttu-id="93484-192">要比较的 <see cref="T:System.Data.EntityKey" />。</span><span class="sxs-lookup"><span data-stu-id="93484-192">A <see cref="T:System.Data.EntityKey" /> to compare.</span></span></param>
        <param name="key2"><span data-ttu-id="93484-193">要比较的 <see cref="T:System.Data.EntityKey" />。</span><span class="sxs-lookup"><span data-stu-id="93484-193">A <see cref="T:System.Data.EntityKey" /> to compare.</span></span></param>
        <summary><span data-ttu-id="93484-194">比较两个 <see cref="T:System.Data.EntityKey" /> 对象。</span><span class="sxs-lookup"><span data-stu-id="93484-194">Compares two <see cref="T:System.Data.EntityKey" /> objects.</span></span></summary>
        <returns><span data-ttu-id="93484-195">如果 <paramref name="key1" /> 与 <paramref name="key2" /> 值相等，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="93484-195"><see langword="true" /> if the <paramref name="key1" /> and <paramref name="key2" /> values are equal; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="93484-196">临时键与永久键的比较语义不同：</span><span class="sxs-lookup"><span data-stu-id="93484-196">Temporary keys have different comparison semantics than permanent keys:</span></span>

-   <span data-ttu-id="93484-197">临时键使用引用相等性。</span><span class="sxs-lookup"><span data-stu-id="93484-197">Temporary keys use reference equality.</span></span> <span data-ttu-id="93484-198">也就是说，对同一个临时 <xref:System.Data.EntityKey> 实例的两个引用是相等的，但其他 <xref:System.Data.EntityKey> 实例不相等。</span><span class="sxs-lookup"><span data-stu-id="93484-198">That is, two references to the exact same temporary <xref:System.Data.EntityKey> instance are equal but no other <xref:System.Data.EntityKey> instances are equal.</span></span>

-   <span data-ttu-id="93484-199">永久键根据所包含的键属性的值和 <xref:System.Data.Metadata.Edm.EntitySet> 来确定相等性。</span><span class="sxs-lookup"><span data-stu-id="93484-199">Permanent keys determine equality based on the values of the contained key properties and the <xref:System.Data.Metadata.Edm.EntitySet>.</span></span> <span data-ttu-id="93484-200">也就是说，对于两个独立的 <xref:System.Data.EntityKey> 实例，如果它们的实体集相同并且键值相等，则这两个实例相等。</span><span class="sxs-lookup"><span data-stu-id="93484-200">That is, you can have two separate <xref:System.Data.EntityKey> instances that are equal if their entity sets are the same and their key values are equal.</span></span>

 <span data-ttu-id="93484-201">此外，临时键没有 <xref:System.Data.Metadata.Edm.EntitySet> 或键值，但永久键有。</span><span class="sxs-lookup"><span data-stu-id="93484-201">In addition, temporary keys have no <xref:System.Data.Metadata.Edm.EntitySet> or key values, but permanent keys do.</span></span>

 <span data-ttu-id="93484-202">此运算符的等效方法为 <xref:System.Data.EntityKey.Equals%28System.Data.EntityKey%29?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="93484-202">The equivalent method for this operator is <xref:System.Data.EntityKey.Equals%28System.Data.EntityKey%29?displayProperty=nameWithType>.</span></span>]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (System.Data.EntityKey key1, System.Data.EntityKey key2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(class System.Data.EntityKey key1, class System.Data.EntityKey key2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.EntityKey.op_Inequality(System.Data.EntityKey,System.Data.EntityKey)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (key1 As EntityKey, key2 As EntityKey) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::Data::EntityKey ^ key1, System::Data::EntityKey ^ key2);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : System.Data.EntityKey * System.Data.EntityKey -&gt; bool" Usage="System.Data.EntityKey.op_Inequality (key1, key2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key1" Type="System.Data.EntityKey" />
        <Parameter Name="key2" Type="System.Data.EntityKey" />
      </Parameters>
      <Docs>
        <param name="key1"><span data-ttu-id="93484-203">要比较的 <see cref="T:System.Data.EntityKey" />。</span><span class="sxs-lookup"><span data-stu-id="93484-203">A <see cref="T:System.Data.EntityKey" /> to compare.</span></span></param>
        <param name="key2"><span data-ttu-id="93484-204">要比较的 <see cref="T:System.Data.EntityKey" />。</span><span class="sxs-lookup"><span data-stu-id="93484-204">A <see cref="T:System.Data.EntityKey" /> to compare.</span></span></param>
        <summary><span data-ttu-id="93484-205">比较两个 <see cref="T:System.Data.EntityKey" /> 对象。</span><span class="sxs-lookup"><span data-stu-id="93484-205">Compares two <see cref="T:System.Data.EntityKey" /> objects.</span></span></summary>
        <returns><span data-ttu-id="93484-206">如果 <paramref name="key1" /> 与 <paramref name="key2" /> 值不相等，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="93484-206"><see langword="true" /> if the <paramref name="key1" /> and <paramref name="key2" /> values are not equal; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="93484-207">临时键与永久键的比较语义不同：</span><span class="sxs-lookup"><span data-stu-id="93484-207">Temporary keys have different comparison semantics than permanent keys:</span></span>

-   <span data-ttu-id="93484-208">临时键使用引用相等性。</span><span class="sxs-lookup"><span data-stu-id="93484-208">Temporary keys use reference equality.</span></span> <span data-ttu-id="93484-209">也就是说，对同一个临时 <xref:System.Data.EntityKey> 实例的两个引用是相等的，但其他 <xref:System.Data.EntityKey> 实例不相等。</span><span class="sxs-lookup"><span data-stu-id="93484-209">That is, two references to the exact same temporary <xref:System.Data.EntityKey> instance are equal but no other <xref:System.Data.EntityKey> instances are equal.</span></span>

-   <span data-ttu-id="93484-210">永久键根据所包含的键属性的值和 <xref:System.Data.Metadata.Edm.EntitySet> 来确定相等性。</span><span class="sxs-lookup"><span data-stu-id="93484-210">Permanent keys determine equality based on the values of the contained key properties and the <xref:System.Data.Metadata.Edm.EntitySet>.</span></span> <span data-ttu-id="93484-211">也就是说，对于两个独立的 <xref:System.Data.EntityKey> 实例，如果它们的实体集相同并且键值相等，则这两个实例相等。</span><span class="sxs-lookup"><span data-stu-id="93484-211">That is, you can have two separate <xref:System.Data.EntityKey> instances that are equal if their entity sets are the same and their key values are equal.</span></span>

 <span data-ttu-id="93484-212">此外，临时键没有 <xref:System.Data.Metadata.Edm.EntitySet> 或键值，但常规键有。</span><span class="sxs-lookup"><span data-stu-id="93484-212">In addition, temporary keys have no <xref:System.Data.Metadata.Edm.EntitySet> or key values, but regular keys do.</span></span>

 <span data-ttu-id="93484-213">此运算符的等效方法为 <xref:System.Data.EntityKey.Equals%28System.Data.EntityKey%29?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="93484-213">The equivalent method for this operator is <xref:System.Data.EntityKey.Equals%28System.Data.EntityKey%29?displayProperty=nameWithType>.</span></span>]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
