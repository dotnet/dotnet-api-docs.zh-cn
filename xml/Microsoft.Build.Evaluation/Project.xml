<Type Name="Project" FullName="Microsoft.Build.Evaluation.Project">
  <Metadata><Meta Name="ms.openlocfilehash" Value="4a0d9d219cc38b93512fc7bf4d50bf7eea7390ec" /><Meta Name="ms.sourcegitcommit" Value="c982ad9e10a242d90f1e631b5981570f9e5d9f34" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-CN" /><Meta Name="ms.lasthandoff" Value="09/10/2020" /><Meta Name="ms.locfileid" Value="89749077" /></Metadata><TypeSignature Language="C#" Value="public class Project" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit Project extends System.Object" />
  <TypeSignature Language="DocId" Value="T:Microsoft.Build.Evaluation.Project" />
  <TypeSignature Language="VB.NET" Value="Public Class Project" />
  <TypeSignature Language="C++ CLI" Value="public ref class Project" />
  <TypeSignature Language="F#" Value="type Project = class" />
  <AssemblyInfo>
    <AssemblyName>Microsoft.Build</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>15.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="msbuild-15;msbuild-15-netcore;msbuild-16;msbuild-16-netcore">
      <AttributeName Language="C#">[System.Diagnostics.DebuggerDisplay("{FullPath} EffectiveToolsVersion={ToolsVersion} #GlobalProperties={_data.GlobalPropertiesDictionary.Count} #Properties={_data.Properties.Count} #ItemTypes={_data.ItemTypes.Count} #ItemDefinitions={_data.ItemDefinitions.Count} #Items={_data.Items.Count} #Targets={_data.Targets.Count}")]</AttributeName>
      <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerDisplay("{FullPath} EffectiveToolsVersion={ToolsVersion} #GlobalProperties={_data.GlobalPropertiesDictionary.Count} #Properties={_data.Properties.Count} #ItemTypes={_data.ItemTypes.Count} #ItemDefinitions={_data.ItemDefinitions.Count} #Items={_data.Items.Count} #Targets={_data.Targets.Count}")&gt;]</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName Language="C#">[System.Diagnostics.DebuggerDisplay("{FullPath} EffectiveToolsVersion={ToolsVersion} #GlobalProperties={data.globalProperties.Count} #Properties={data.Properties.Count} #ItemTypes={data.ItemTypes.Count} #ItemDefinitions={data.ItemDefinitions.Count} #Items={data.Items.Count} #Targets={data.Targets.Count}")]</AttributeName>
      <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerDisplay("{FullPath} EffectiveToolsVersion={ToolsVersion} #GlobalProperties={data.globalProperties.Count} #Properties={data.Properties.Count} #ItemTypes={data.ItemTypes.Count} #ItemDefinitions={data.ItemDefinitions.Count} #Items={data.Items.Count} #Targets={data.Targets.Count}")&gt;]</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>表示具有设计时语义的计算项目。
始终由 XML 支持；可以直接生成，也可以克隆出一个实例来添加虚拟项/属性和生成。
对此项目的编辑始终更新支持的 XML。</summary>
    <remarks>To be added.</remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>使用全局项目集合的全局属性和默认工具版本构造一个空项目。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Project ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Project();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>构造一个空项目，使用全局项目集合的全局属性和默认工具版本进行计算。
项目命名后，添加到全局项目集合中。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当向全局项目集合提供源项目文件的完整路径（通常通过保存项目）时，此项目将添加到全局项目集合中。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Project (Microsoft.Build.Construction.ProjectRootElement xml);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class Microsoft.Build.Construction.ProjectRootElement xml) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.#ctor(Microsoft.Build.Construction.ProjectRootElement)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (xml As ProjectRootElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Project(Microsoft::Build::Construction::ProjectRootElement ^ xml);" />
      <MemberSignature Language="F#" Value="new Microsoft.Build.Evaluation.Project : Microsoft.Build.Construction.ProjectRootElement -&gt; Microsoft.Build.Evaluation.Project" Usage="new Microsoft.Build.Evaluation.Project xml" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="xml" Type="Microsoft.Build.Construction.ProjectRootElement" />
      </Parameters>
      <Docs>
        <param name="xml">要使用的 ProjectRootElement</param>
        <summary>在 ProjectRootElement 项目上构造，使用全局项目集合的全局属性和默认工具版本进行计算。
如果项目有名称，添加到全局项目集合中，否则在命名后添加。
如果计算失败，将引发 InvalidProjectFileException。
如果已在项目集合中加载了等效项目，则会引发 InvalidOperationException。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当向此项目或给定的项目根提供源项目文件的完整路径时，此项目将添加到全局项目集合中。  
  
 如果计算失败，将引发 InvalidProjectFileException。 如果已在项目集合中加载了等效项目，则会引发 InvalidOperationException。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Project (Microsoft.Build.Evaluation.NewProjectFileOptions newProjectFileOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype Microsoft.Build.Evaluation.NewProjectFileOptions newProjectFileOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.#ctor(Microsoft.Build.Evaluation.NewProjectFileOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (newProjectFileOptions As NewProjectFileOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Project(Microsoft::Build::Evaluation::NewProjectFileOptions newProjectFileOptions);" />
      <MemberSignature Language="F#" Value="new Microsoft.Build.Evaluation.Project : Microsoft.Build.Evaluation.NewProjectFileOptions -&gt; Microsoft.Build.Evaluation.Project" Usage="new Microsoft.Build.Evaluation.Project newProjectFileOptions" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="newProjectFileOptions" Type="Microsoft.Build.Evaluation.NewProjectFileOptions" Index="0" FrameworkAlternate="msbuild-15;msbuild-15-netcore;msbuild-16;msbuild-16-netcore" />
      </Parameters>
      <Docs>
        <param name="newProjectFileOptions">To be added.</param>
        <summary>构造一个空项目，使用全局项目集合的全局属性和默认工具版本进行计算。
项目命名后，添加到全局项目集合中。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Project (Microsoft.Build.Evaluation.ProjectCollection projectCollection);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class Microsoft.Build.Evaluation.ProjectCollection projectCollection) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.#ctor(Microsoft.Build.Evaluation.ProjectCollection)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (projectCollection As ProjectCollection)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Project(Microsoft::Build::Evaluation::ProjectCollection ^ projectCollection);" />
      <MemberSignature Language="F#" Value="new Microsoft.Build.Evaluation.Project : Microsoft.Build.Evaluation.ProjectCollection -&gt; Microsoft.Build.Evaluation.Project" Usage="new Microsoft.Build.Evaluation.Project projectCollection" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="projectCollection" Type="Microsoft.Build.Evaluation.ProjectCollection" />
      </Parameters>
      <Docs>
        <param name="projectCollection">要将新项目添加到的项目集合。</param>
        <summary>构造一个空项目，使用指定项目集合的全局属性和默认工具版本进行计算。
项目命名后，将添加到指定项目集合中。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当向给定的项目集合提供源项目文件的完整路径（通常通过保存项目）时，此项目将添加到该项目集合中。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Project (string projectFile);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string projectFile) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (projectFile As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Project(System::String ^ projectFile);" />
      <MemberSignature Language="F#" Value="new Microsoft.Build.Evaluation.Project : string -&gt; Microsoft.Build.Evaluation.Project" Usage="new Microsoft.Build.Evaluation.Project projectFile" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="projectFile" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="projectFile">要计算的源项目文件。</param>
        <summary>在现有项目文件上构造，使用全局项目集合的全局属性和默认工具版本进行计算。
项目添加到全局项目集合中。
如果计算失败，将引发 InvalidProjectFileException。
如果已在项目集合中加载了等效项目，则会引发 InvalidOperationException。
可能引发与 IO 相关的异常。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 项目将添加到全局项目集合中。  
  
 如果项目集合中已经存在用于计算此源项目文件的项目，则会引发 InvalidOperationException。 可能引发与 IO 相关的异常。  
  
 ]]></format>
        </remarks>
        <exception cref="T:Microsoft.Build.Exceptions.InvalidProjectFileException">如果计算失败。</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Project (System.Xml.XmlReader xmlReader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Xml.XmlReader xmlReader) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.#ctor(System.Xml.XmlReader)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (xmlReader As XmlReader)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Project(System::Xml::XmlReader ^ xmlReader);" />
      <MemberSignature Language="F#" Value="new Microsoft.Build.Evaluation.Project : System.Xml.XmlReader -&gt; Microsoft.Build.Evaluation.Project" Usage="new Microsoft.Build.Evaluation.Project xmlReader" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="xmlReader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="xmlReader">从中读取项目的 Xml 读取器。</param>
        <summary>在项目 xml 的文本读取器上构造，使用全局项目集合的全局属性和默认工具版本进行计算。
项目命名后，添加到全局项目集合中。
如果计算失败，将引发 InvalidProjectFileException。
如果已在项目集合中加载了等效项目，则会引发 InvalidOperationException。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当向全局项目集合提供源项目文件的完整路径（通常通过保存项目）时，此项目将添加到全局项目集合中。  
  
 如果计算失败，将引发 InvalidProjectFileException。 如果已在项目集合中加载了等效项目，则会引发 InvalidOperationException。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Project (Microsoft.Build.Evaluation.ProjectCollection projectCollection, Microsoft.Build.Evaluation.NewProjectFileOptions newProjectFileOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class Microsoft.Build.Evaluation.ProjectCollection projectCollection, valuetype Microsoft.Build.Evaluation.NewProjectFileOptions newProjectFileOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.#ctor(Microsoft.Build.Evaluation.ProjectCollection,Microsoft.Build.Evaluation.NewProjectFileOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (projectCollection As ProjectCollection, newProjectFileOptions As NewProjectFileOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Project(Microsoft::Build::Evaluation::ProjectCollection ^ projectCollection, Microsoft::Build::Evaluation::NewProjectFileOptions newProjectFileOptions);" />
      <MemberSignature Language="F#" Value="new Microsoft.Build.Evaluation.Project : Microsoft.Build.Evaluation.ProjectCollection * Microsoft.Build.Evaluation.NewProjectFileOptions -&gt; Microsoft.Build.Evaluation.Project" Usage="new Microsoft.Build.Evaluation.Project (projectCollection, newProjectFileOptions)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="projectCollection" Type="Microsoft.Build.Evaluation.ProjectCollection" Index="0" FrameworkAlternate="msbuild-15;msbuild-15-netcore;msbuild-16;msbuild-16-netcore" />
        <Parameter Name="newProjectFileOptions" Type="Microsoft.Build.Evaluation.NewProjectFileOptions" Index="1" FrameworkAlternate="msbuild-15;msbuild-15-netcore;msbuild-16;msbuild-16-netcore" />
      </Parameters>
      <Docs>
        <param name="projectCollection">To be added.</param>
        <param name="newProjectFileOptions">To be added.</param>
        <summary>构造一个空项目，使用指定项目集合的全局属性和默认工具版本进行计算。
项目命名后，将添加到指定项目集合中。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Project (Microsoft.Build.Construction.ProjectRootElement xml, System.Collections.Generic.IDictionary&lt;string,string&gt; globalProperties, string toolsVersion);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class Microsoft.Build.Construction.ProjectRootElement xml, class System.Collections.Generic.IDictionary`2&lt;string, string&gt; globalProperties, string toolsVersion) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.#ctor(Microsoft.Build.Construction.ProjectRootElement,System.Collections.Generic.IDictionary{System.String,System.String},System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (xml As ProjectRootElement, globalProperties As IDictionary(Of String, String), toolsVersion As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Project(Microsoft::Build::Construction::ProjectRootElement ^ xml, System::Collections::Generic::IDictionary&lt;System::String ^, System::String ^&gt; ^ globalProperties, System::String ^ toolsVersion);" />
      <MemberSignature Language="F#" Value="new Microsoft.Build.Evaluation.Project : Microsoft.Build.Construction.ProjectRootElement * System.Collections.Generic.IDictionary&lt;string, string&gt; * string -&gt; Microsoft.Build.Evaluation.Project" Usage="new Microsoft.Build.Evaluation.Project (xml, globalProperties, toolsVersion)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="xml" Type="Microsoft.Build.Construction.ProjectRootElement" />
        <Parameter Name="globalProperties" Type="System.Collections.Generic.IDictionary&lt;System.String,System.String&gt;" />
        <Parameter Name="toolsVersion" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="xml">要使用的 ProjectRootElement</param>
        <param name="globalProperties">要计算的全局属性。 可以为 null，在此情况下，将使用包含项目集合的全局属性。</param>
        <param name="toolsVersion">用于计算的工具版本。 可能为 null</param>
        <summary>在 ProjectRootElement 对象上构造，使用指定的全局属性和工具集（可能其中一个为 null，也可能两者都为 null）进行计算。
如果项目有名称，添加到全局项目集合中，否则在命名后添加。
如果计算失败，将引发 InvalidProjectFileException。
如果已在项目集合中加载了等效项目，则会引发 InvalidOperationException。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当向此项目或给定的项目根提供源项目文件的完整路径时，此项目将添加到全局项目集合中。  
  
 如果计算失败，将引发 InvalidProjectFileException。 如果已在项目集合中加载了等效项目，则会引发 InvalidOperationException。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Project (System.Collections.Generic.IDictionary&lt;string,string&gt; globalProperties, string toolsVersion, Microsoft.Build.Evaluation.ProjectCollection projectCollection);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.Generic.IDictionary`2&lt;string, string&gt; globalProperties, string toolsVersion, class Microsoft.Build.Evaluation.ProjectCollection projectCollection) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.#ctor(System.Collections.Generic.IDictionary{System.String,System.String},System.String,Microsoft.Build.Evaluation.ProjectCollection)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (globalProperties As IDictionary(Of String, String), toolsVersion As String, projectCollection As ProjectCollection)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Project(System::Collections::Generic::IDictionary&lt;System::String ^, System::String ^&gt; ^ globalProperties, System::String ^ toolsVersion, Microsoft::Build::Evaluation::ProjectCollection ^ projectCollection);" />
      <MemberSignature Language="F#" Value="new Microsoft.Build.Evaluation.Project : System.Collections.Generic.IDictionary&lt;string, string&gt; * string * Microsoft.Build.Evaluation.ProjectCollection -&gt; Microsoft.Build.Evaluation.Project" Usage="new Microsoft.Build.Evaluation.Project (globalProperties, toolsVersion, projectCollection)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="globalProperties" Type="System.Collections.Generic.IDictionary&lt;System.String,System.String&gt;" />
        <Parameter Name="toolsVersion" Type="System.String" />
        <Parameter Name="projectCollection" Type="Microsoft.Build.Evaluation.ProjectCollection" />
      </Parameters>
      <Docs>
        <param name="globalProperties">要计算的全局属性。 可以为 null，在此情况下，将使用包含项目集合的全局属性。</param>
        <param name="toolsVersion">用于计算的工具版本。 可能为 null</param>
        <param name="projectCollection">项目添加到的 <see cref="P:Microsoft.Build.Evaluation.Project.ProjectCollection" />。</param>
        <summary>构造一个空项目，使用指定项目集合、指定全局属性和默认工具版本（可能其中一个为 null）进行计算。
项目命名后，将添加到指定项目集合中。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当向指定的项目集合提供源项目文件的完整路径（通常通过保存项目）时，该项目将添加到该集合。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Project (string projectFile, System.Collections.Generic.IDictionary&lt;string,string&gt; globalProperties, string toolsVersion);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string projectFile, class System.Collections.Generic.IDictionary`2&lt;string, string&gt; globalProperties, string toolsVersion) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.#ctor(System.String,System.Collections.Generic.IDictionary{System.String,System.String},System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (projectFile As String, globalProperties As IDictionary(Of String, String), toolsVersion As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Project(System::String ^ projectFile, System::Collections::Generic::IDictionary&lt;System::String ^, System::String ^&gt; ^ globalProperties, System::String ^ toolsVersion);" />
      <MemberSignature Language="F#" Value="new Microsoft.Build.Evaluation.Project : string * System.Collections.Generic.IDictionary&lt;string, string&gt; * string -&gt; Microsoft.Build.Evaluation.Project" Usage="new Microsoft.Build.Evaluation.Project (projectFile, globalProperties, toolsVersion)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="projectFile" Type="System.String" />
        <Parameter Name="globalProperties" Type="System.Collections.Generic.IDictionary&lt;System.String,System.String&gt;" />
        <Parameter Name="toolsVersion" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="projectFile">要计算的源项目文件的路径。</param>
        <param name="globalProperties">要计算的全局属性。 可以为 null，在此情况下，将使用包含项目集合的全局属性。</param>
        <param name="toolsVersion">用于计算的工具版本。 可能为 null。</param>
        <summary>在现有项目文件上构造，使用指定的全局属性和工具集（可能其中一个为 null，也可能两者都为 null）进行计算。
项目添加到全局项目集合中。
如果计算失败，将引发 InvalidProjectFileException。
如果已在项目集合中加载了等效项目，则会引发 InvalidOperationException。
可能引发与 IO 相关的异常。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 项目将添加到全局项目集合中。  
  
 如果计算失败，将引发 InvalidProjectFileException。 如果已在项目集合中加载了等效项目，则会引发 InvalidOperationException。 可能引发与 IO 相关的异常。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Project (System.Xml.XmlReader xmlReader, System.Collections.Generic.IDictionary&lt;string,string&gt; globalProperties, string toolsVersion);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Xml.XmlReader xmlReader, class System.Collections.Generic.IDictionary`2&lt;string, string&gt; globalProperties, string toolsVersion) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.#ctor(System.Xml.XmlReader,System.Collections.Generic.IDictionary{System.String,System.String},System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (xmlReader As XmlReader, globalProperties As IDictionary(Of String, String), toolsVersion As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Project(System::Xml::XmlReader ^ xmlReader, System::Collections::Generic::IDictionary&lt;System::String ^, System::String ^&gt; ^ globalProperties, System::String ^ toolsVersion);" />
      <MemberSignature Language="F#" Value="new Microsoft.Build.Evaluation.Project : System.Xml.XmlReader * System.Collections.Generic.IDictionary&lt;string, string&gt; * string -&gt; Microsoft.Build.Evaluation.Project" Usage="new Microsoft.Build.Evaluation.Project (xmlReader, globalProperties, toolsVersion)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="xmlReader" Type="System.Xml.XmlReader" />
        <Parameter Name="globalProperties" Type="System.Collections.Generic.IDictionary&lt;System.String,System.String&gt;" />
        <Parameter Name="toolsVersion" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="xmlReader">从中读取项目的 Xml 读取器。</param>
        <param name="globalProperties">要计算的全局属性。 可以为 null，在此情况下，将使用包含项目集合的全局属性。</param>
        <param name="toolsVersion">用于计算的工具版本。 可能为 null</param>
        <summary>在项目 xml 的文本读取器上构造，使用指定的全局属性和工具集（可能其中一个为 null，也可能两者都为 null）进行计算。
项目命名后，添加到全局项目集合中。
如果计算失败，将引发 InvalidProjectFileException。
如果已在项目集合中加载了等效项目，则会引发 InvalidOperationException。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当向全局项目集合提供源项目文件的完整路径（通常通过保存项目）时，此项目将添加到全局项目集合中。  
  
 如果计算失败，将引发 InvalidProjectFileException。 如果已在项目集合中加载了等效项目，则会引发 InvalidOperationException。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Project (Microsoft.Build.Construction.ProjectRootElement xml, System.Collections.Generic.IDictionary&lt;string,string&gt; globalProperties, string toolsVersion, Microsoft.Build.Evaluation.ProjectCollection projectCollection);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class Microsoft.Build.Construction.ProjectRootElement xml, class System.Collections.Generic.IDictionary`2&lt;string, string&gt; globalProperties, string toolsVersion, class Microsoft.Build.Evaluation.ProjectCollection projectCollection) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.#ctor(Microsoft.Build.Construction.ProjectRootElement,System.Collections.Generic.IDictionary{System.String,System.String},System.String,Microsoft.Build.Evaluation.ProjectCollection)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (xml As ProjectRootElement, globalProperties As IDictionary(Of String, String), toolsVersion As String, projectCollection As ProjectCollection)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Project(Microsoft::Build::Construction::ProjectRootElement ^ xml, System::Collections::Generic::IDictionary&lt;System::String ^, System::String ^&gt; ^ globalProperties, System::String ^ toolsVersion, Microsoft::Build::Evaluation::ProjectCollection ^ projectCollection);" />
      <MemberSignature Language="F#" Value="new Microsoft.Build.Evaluation.Project : Microsoft.Build.Construction.ProjectRootElement * System.Collections.Generic.IDictionary&lt;string, string&gt; * string * Microsoft.Build.Evaluation.ProjectCollection -&gt; Microsoft.Build.Evaluation.Project" Usage="new Microsoft.Build.Evaluation.Project (xml, globalProperties, toolsVersion, projectCollection)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="xml" Type="Microsoft.Build.Construction.ProjectRootElement" />
        <Parameter Name="globalProperties" Type="System.Collections.Generic.IDictionary&lt;System.String,System.String&gt;" />
        <Parameter Name="toolsVersion" Type="System.String" />
        <Parameter Name="projectCollection" Type="Microsoft.Build.Evaluation.ProjectCollection" />
      </Parameters>
      <Docs>
        <param name="xml">要使用的 ProjectRootElement</param>
        <param name="globalProperties">要计算的全局属性。 可以为 null，在此情况下，将使用包含项目集合的全局属性。</param>
        <param name="toolsVersion">用于计算的工具版本。 可能为 null</param>
        <param name="projectCollection">项目添加到的 <see cref="P:Microsoft.Build.Evaluation.Project.ProjectCollection" />。</param>
        <summary>在 ProjectRootElement 对象上构造，使用指定的全局属性和工具集（可能其中一个为 null，也可能两者都为 null）进行计算。
如果项目有名称，添加到全局项目集合中，否则在命名后添加。
如果计算失败，将引发 InvalidProjectFileException。
如果已在项目集合中加载了等效项目，则会引发 InvalidOperationException。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当向此项目或给定的项目根提供源项目文件的完整路径时，此项目将添加到给定的项目集合中。  
  
 如果计算失败，将引发 InvalidProjectFileException。 如果已在项目集合中加载了等效项目，则会引发 InvalidOperationException。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Project (System.Collections.Generic.IDictionary&lt;string,string&gt; globalProperties, string toolsVersion, Microsoft.Build.Evaluation.ProjectCollection projectCollection, Microsoft.Build.Evaluation.NewProjectFileOptions newProjectFileOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.Generic.IDictionary`2&lt;string, string&gt; globalProperties, string toolsVersion, class Microsoft.Build.Evaluation.ProjectCollection projectCollection, valuetype Microsoft.Build.Evaluation.NewProjectFileOptions newProjectFileOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.#ctor(System.Collections.Generic.IDictionary{System.String,System.String},System.String,Microsoft.Build.Evaluation.ProjectCollection,Microsoft.Build.Evaluation.NewProjectFileOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (globalProperties As IDictionary(Of String, String), toolsVersion As String, projectCollection As ProjectCollection, newProjectFileOptions As NewProjectFileOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Project(System::Collections::Generic::IDictionary&lt;System::String ^, System::String ^&gt; ^ globalProperties, System::String ^ toolsVersion, Microsoft::Build::Evaluation::ProjectCollection ^ projectCollection, Microsoft::Build::Evaluation::NewProjectFileOptions newProjectFileOptions);" />
      <MemberSignature Language="F#" Value="new Microsoft.Build.Evaluation.Project : System.Collections.Generic.IDictionary&lt;string, string&gt; * string * Microsoft.Build.Evaluation.ProjectCollection * Microsoft.Build.Evaluation.NewProjectFileOptions -&gt; Microsoft.Build.Evaluation.Project" Usage="new Microsoft.Build.Evaluation.Project (globalProperties, toolsVersion, projectCollection, newProjectFileOptions)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="globalProperties" Type="System.Collections.Generic.IDictionary&lt;System.String,System.String&gt;" Index="0" FrameworkAlternate="msbuild-15;msbuild-15-netcore;msbuild-16;msbuild-16-netcore" />
        <Parameter Name="toolsVersion" Type="System.String" Index="1" FrameworkAlternate="msbuild-15;msbuild-15-netcore;msbuild-16;msbuild-16-netcore" />
        <Parameter Name="projectCollection" Type="Microsoft.Build.Evaluation.ProjectCollection" Index="2" FrameworkAlternate="msbuild-15;msbuild-15-netcore;msbuild-16;msbuild-16-netcore" />
        <Parameter Name="newProjectFileOptions" Type="Microsoft.Build.Evaluation.NewProjectFileOptions" Index="3" FrameworkAlternate="msbuild-15;msbuild-15-netcore;msbuild-16;msbuild-16-netcore" />
      </Parameters>
      <Docs>
        <param name="globalProperties">要计算的全局属性。 可以为 null，在此情况下，将使用包含项目集合的全局属性。</param>
        <param name="toolsVersion">用于计算的工具版本。 可能为 null</param>
        <param name="projectCollection">项目添加到的 <see cref="P:Microsoft.Build.Evaluation.Project.ProjectCollection" />。</param>
        <param name="newProjectFileOptions">要用于新项目的 <see cref="T:Microsoft.Build.Evaluation.NewProjectFileOptions" />。</param>
        <summary>构造一个空项目，使用指定项目集合、指定全局属性和默认工具版本（可能其中一个为 null）进行计算。
项目命名后，将添加到指定项目集合中。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Project (string projectFile, System.Collections.Generic.IDictionary&lt;string,string&gt; globalProperties, string toolsVersion, Microsoft.Build.Evaluation.ProjectCollection projectCollection);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string projectFile, class System.Collections.Generic.IDictionary`2&lt;string, string&gt; globalProperties, string toolsVersion, class Microsoft.Build.Evaluation.ProjectCollection projectCollection) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.#ctor(System.String,System.Collections.Generic.IDictionary{System.String,System.String},System.String,Microsoft.Build.Evaluation.ProjectCollection)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (projectFile As String, globalProperties As IDictionary(Of String, String), toolsVersion As String, projectCollection As ProjectCollection)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Project(System::String ^ projectFile, System::Collections::Generic::IDictionary&lt;System::String ^, System::String ^&gt; ^ globalProperties, System::String ^ toolsVersion, Microsoft::Build::Evaluation::ProjectCollection ^ projectCollection);" />
      <MemberSignature Language="F#" Value="new Microsoft.Build.Evaluation.Project : string * System.Collections.Generic.IDictionary&lt;string, string&gt; * string * Microsoft.Build.Evaluation.ProjectCollection -&gt; Microsoft.Build.Evaluation.Project" Usage="new Microsoft.Build.Evaluation.Project (projectFile, globalProperties, toolsVersion, projectCollection)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="projectFile" Type="System.String" />
        <Parameter Name="globalProperties" Type="System.Collections.Generic.IDictionary&lt;System.String,System.String&gt;" />
        <Parameter Name="toolsVersion" Type="System.String" />
        <Parameter Name="projectCollection" Type="Microsoft.Build.Evaluation.ProjectCollection" />
      </Parameters>
      <Docs>
        <param name="projectFile">项目文件</param>
        <param name="globalProperties">全局属性。 可能为 null。</param>
        <param name="toolsVersion">工具版本。 可能为 null。</param>
        <param name="projectCollection">此项目应与之相关联的集合。 不能为 null。</param>
        <summary>在现有项目文件上构造，使用指定的全局属性并使用提供的工具版本（可能其中一个为 null，也可能两者都为 null）进行计算。
项目添加到全局项目集合中。
如果计算失败，将引发 InvalidProjectFileException。
如果已在项目集合中加载了等效项目，则会引发 InvalidOperationException。
可能引发与 IO 相关的异常。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 项目将添加到给定的项目集合中。  
  
 如果计算失败，将引发 InvalidProjectFileException。 如果已在项目集合中加载了等效项目，则会引发 InvalidOperationException。 可能引发与 IO 相关的异常。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Project (System.Xml.XmlReader xmlReader, System.Collections.Generic.IDictionary&lt;string,string&gt; globalProperties, string toolsVersion, Microsoft.Build.Evaluation.ProjectCollection projectCollection);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Xml.XmlReader xmlReader, class System.Collections.Generic.IDictionary`2&lt;string, string&gt; globalProperties, string toolsVersion, class Microsoft.Build.Evaluation.ProjectCollection projectCollection) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.#ctor(System.Xml.XmlReader,System.Collections.Generic.IDictionary{System.String,System.String},System.String,Microsoft.Build.Evaluation.ProjectCollection)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (xmlReader As XmlReader, globalProperties As IDictionary(Of String, String), toolsVersion As String, projectCollection As ProjectCollection)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Project(System::Xml::XmlReader ^ xmlReader, System::Collections::Generic::IDictionary&lt;System::String ^, System::String ^&gt; ^ globalProperties, System::String ^ toolsVersion, Microsoft::Build::Evaluation::ProjectCollection ^ projectCollection);" />
      <MemberSignature Language="F#" Value="new Microsoft.Build.Evaluation.Project : System.Xml.XmlReader * System.Collections.Generic.IDictionary&lt;string, string&gt; * string * Microsoft.Build.Evaluation.ProjectCollection -&gt; Microsoft.Build.Evaluation.Project" Usage="new Microsoft.Build.Evaluation.Project (xmlReader, globalProperties, toolsVersion, projectCollection)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="xmlReader" Type="System.Xml.XmlReader" />
        <Parameter Name="globalProperties" Type="System.Collections.Generic.IDictionary&lt;System.String,System.String&gt;" />
        <Parameter Name="toolsVersion" Type="System.String" />
        <Parameter Name="projectCollection" Type="Microsoft.Build.Evaluation.ProjectCollection" />
      </Parameters>
      <Docs>
        <param name="xmlReader">从中读取项目的 Xml 读取器。</param>
        <param name="globalProperties">要计算的全局属性。 可以为 null，在此情况下，将使用包含项目集合的全局属性。</param>
        <param name="toolsVersion">用于计算的工具版本。 可能为 null</param>
        <param name="projectCollection">此项目应与之相关联的集合。 不能为 null。</param>
        <summary>在项目 xml 的文本读取器上构造，使用指定的全局属性和工具集（可能其中一个为 null，也可能两者都为 null）进行计算。
项目命名后，将添加到指定项目集合中。
如果计算失败，将引发 InvalidProjectFileException。
如果已在项目集合中加载了等效项目，则会引发 InvalidOperationException。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当向此项目或给定的项目根提供源项目文件的完整路径时，此项目将添加到给定的项目集合中。  
  
 如果计算失败，将引发 InvalidProjectFileException。 如果已在项目集合中加载了等效项目，则会引发 InvalidOperationException。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Project (Microsoft.Build.Construction.ProjectRootElement xml, System.Collections.Generic.IDictionary&lt;string,string&gt; globalProperties, string toolsVersion, Microsoft.Build.Evaluation.ProjectCollection projectCollection, Microsoft.Build.Evaluation.ProjectLoadSettings loadSettings);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class Microsoft.Build.Construction.ProjectRootElement xml, class System.Collections.Generic.IDictionary`2&lt;string, string&gt; globalProperties, string toolsVersion, class Microsoft.Build.Evaluation.ProjectCollection projectCollection, valuetype Microsoft.Build.Evaluation.ProjectLoadSettings loadSettings) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.#ctor(Microsoft.Build.Construction.ProjectRootElement,System.Collections.Generic.IDictionary{System.String,System.String},System.String,Microsoft.Build.Evaluation.ProjectCollection,Microsoft.Build.Evaluation.ProjectLoadSettings)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (xml As ProjectRootElement, globalProperties As IDictionary(Of String, String), toolsVersion As String, projectCollection As ProjectCollection, loadSettings As ProjectLoadSettings)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Project(Microsoft::Build::Construction::ProjectRootElement ^ xml, System::Collections::Generic::IDictionary&lt;System::String ^, System::String ^&gt; ^ globalProperties, System::String ^ toolsVersion, Microsoft::Build::Evaluation::ProjectCollection ^ projectCollection, Microsoft::Build::Evaluation::ProjectLoadSettings loadSettings);" />
      <MemberSignature Language="F#" Value="new Microsoft.Build.Evaluation.Project : Microsoft.Build.Construction.ProjectRootElement * System.Collections.Generic.IDictionary&lt;string, string&gt; * string * Microsoft.Build.Evaluation.ProjectCollection * Microsoft.Build.Evaluation.ProjectLoadSettings -&gt; Microsoft.Build.Evaluation.Project" Usage="new Microsoft.Build.Evaluation.Project (xml, globalProperties, toolsVersion, projectCollection, loadSettings)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="xml" Type="Microsoft.Build.Construction.ProjectRootElement" />
        <Parameter Name="globalProperties" Type="System.Collections.Generic.IDictionary&lt;System.String,System.String&gt;" />
        <Parameter Name="toolsVersion" Type="System.String" />
        <Parameter Name="projectCollection" Type="Microsoft.Build.Evaluation.ProjectCollection" />
        <Parameter Name="loadSettings" Type="Microsoft.Build.Evaluation.ProjectLoadSettings" />
      </Parameters>
      <Docs>
        <param name="xml">要使用的 ProjectRootElement</param>
        <param name="globalProperties">要计算的全局属性。 可以为 null，在此情况下，将使用包含项目集合的全局属性。</param>
        <param name="toolsVersion">用于计算的工具版本。 可能为 null</param>
        <param name="projectCollection">项目添加到的 <see cref="P:Microsoft.Build.Evaluation.Project.ProjectCollection" />。</param>
        <param name="loadSettings">要用于计算的 <see cref="T:Microsoft.Build.Evaluation.ProjectLoadSettings" />。</param>
        <summary>在 ProjectRootElement 对象上构造，使用指定的全局属性和工具集（可能其中一个为 null，也可能两者都为 null）进行计算。
如果项目有名称，添加到全局项目集合中，否则在命名后添加。
如果计算失败，将引发 InvalidProjectFileException。
如果已在项目集合中加载了等效项目，则会引发 InvalidOperationException。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当向此项目或给定的项目根提供源项目文件的完整路径时，此项目将添加到给定的项目集合中。  
  
 如果计算失败，将引发 InvalidProjectFileException。 如果已在项目集合中加载了等效项目，则会引发 InvalidOperationException。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Project (string projectFile, System.Collections.Generic.IDictionary&lt;string,string&gt; globalProperties, string toolsVersion, Microsoft.Build.Evaluation.ProjectCollection projectCollection, Microsoft.Build.Evaluation.ProjectLoadSettings loadSettings);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string projectFile, class System.Collections.Generic.IDictionary`2&lt;string, string&gt; globalProperties, string toolsVersion, class Microsoft.Build.Evaluation.ProjectCollection projectCollection, valuetype Microsoft.Build.Evaluation.ProjectLoadSettings loadSettings) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.#ctor(System.String,System.Collections.Generic.IDictionary{System.String,System.String},System.String,Microsoft.Build.Evaluation.ProjectCollection,Microsoft.Build.Evaluation.ProjectLoadSettings)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (projectFile As String, globalProperties As IDictionary(Of String, String), toolsVersion As String, projectCollection As ProjectCollection, loadSettings As ProjectLoadSettings)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Project(System::String ^ projectFile, System::Collections::Generic::IDictionary&lt;System::String ^, System::String ^&gt; ^ globalProperties, System::String ^ toolsVersion, Microsoft::Build::Evaluation::ProjectCollection ^ projectCollection, Microsoft::Build::Evaluation::ProjectLoadSettings loadSettings);" />
      <MemberSignature Language="F#" Value="new Microsoft.Build.Evaluation.Project : string * System.Collections.Generic.IDictionary&lt;string, string&gt; * string * Microsoft.Build.Evaluation.ProjectCollection * Microsoft.Build.Evaluation.ProjectLoadSettings -&gt; Microsoft.Build.Evaluation.Project" Usage="new Microsoft.Build.Evaluation.Project (projectFile, globalProperties, toolsVersion, projectCollection, loadSettings)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="projectFile" Type="System.String" />
        <Parameter Name="globalProperties" Type="System.Collections.Generic.IDictionary&lt;System.String,System.String&gt;" />
        <Parameter Name="toolsVersion" Type="System.String" />
        <Parameter Name="projectCollection" Type="Microsoft.Build.Evaluation.ProjectCollection" />
        <Parameter Name="loadSettings" Type="Microsoft.Build.Evaluation.ProjectLoadSettings" />
      </Parameters>
      <Docs>
        <param name="projectFile">项目文件</param>
        <param name="globalProperties">全局属性。 可能为 null。</param>
        <param name="toolsVersion">工具版本。 可能为 null。</param>
        <param name="projectCollection">此项目应与之相关联的集合。 不能为 null。</param>
        <param name="loadSettings">此项目的加载设置。</param>
        <summary>在现有项目文件上构造，使用指定的全局属性并使用提供的工具版本（可能其中一个为 null，也可能两者都为 null）进行计算。
项目添加到全局项目集合中。
如果计算失败，将引发 InvalidProjectFileException。
如果已在项目集合中加载了等效项目，则会引发 InvalidOperationException。
可能引发与 IO 相关的异常。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 项目将添加到给定的项目集合中。  
  
 如果计算失败，将引发 InvalidProjectFileException。 如果已在项目集合中加载了等效项目，则会引发 InvalidOperationException。 可能引发与 IO 相关的异常。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Project (System.Xml.XmlReader xmlReader, System.Collections.Generic.IDictionary&lt;string,string&gt; globalProperties, string toolsVersion, Microsoft.Build.Evaluation.ProjectCollection projectCollection, Microsoft.Build.Evaluation.ProjectLoadSettings loadSettings);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Xml.XmlReader xmlReader, class System.Collections.Generic.IDictionary`2&lt;string, string&gt; globalProperties, string toolsVersion, class Microsoft.Build.Evaluation.ProjectCollection projectCollection, valuetype Microsoft.Build.Evaluation.ProjectLoadSettings loadSettings) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.#ctor(System.Xml.XmlReader,System.Collections.Generic.IDictionary{System.String,System.String},System.String,Microsoft.Build.Evaluation.ProjectCollection,Microsoft.Build.Evaluation.ProjectLoadSettings)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (xmlReader As XmlReader, globalProperties As IDictionary(Of String, String), toolsVersion As String, projectCollection As ProjectCollection, loadSettings As ProjectLoadSettings)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Project(System::Xml::XmlReader ^ xmlReader, System::Collections::Generic::IDictionary&lt;System::String ^, System::String ^&gt; ^ globalProperties, System::String ^ toolsVersion, Microsoft::Build::Evaluation::ProjectCollection ^ projectCollection, Microsoft::Build::Evaluation::ProjectLoadSettings loadSettings);" />
      <MemberSignature Language="F#" Value="new Microsoft.Build.Evaluation.Project : System.Xml.XmlReader * System.Collections.Generic.IDictionary&lt;string, string&gt; * string * Microsoft.Build.Evaluation.ProjectCollection * Microsoft.Build.Evaluation.ProjectLoadSettings -&gt; Microsoft.Build.Evaluation.Project" Usage="new Microsoft.Build.Evaluation.Project (xmlReader, globalProperties, toolsVersion, projectCollection, loadSettings)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="xmlReader" Type="System.Xml.XmlReader" />
        <Parameter Name="globalProperties" Type="System.Collections.Generic.IDictionary&lt;System.String,System.String&gt;" />
        <Parameter Name="toolsVersion" Type="System.String" />
        <Parameter Name="projectCollection" Type="Microsoft.Build.Evaluation.ProjectCollection" />
        <Parameter Name="loadSettings" Type="Microsoft.Build.Evaluation.ProjectLoadSettings" />
      </Parameters>
      <Docs>
        <param name="xmlReader">从中读取项目的 Xml 读取器。</param>
        <param name="globalProperties">要计算的全局属性。 可以为 null，在此情况下，将使用包含项目集合的全局属性。</param>
        <param name="toolsVersion">用于计算的工具版本。 可能为 null</param>
        <param name="projectCollection">此项目应与之相关联的集合。 不能为 null。</param>
        <param name="loadSettings">要用于计算的 <see cref="T:Microsoft.Build.Evaluation.ProjectLoadSettings" />。</param>
        <summary>在项目 xml 的文本读取器上构造，使用指定的全局属性和工具集（可能其中一个为 null，也可能两者都为 null）进行计算。
项目命名后，将添加到指定项目集合中。
如果计算失败，将引发 InvalidProjectFileException。
如果已在项目集合中加载了等效项目，则会引发 InvalidOperationException。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当向此项目或给定的项目根提供源项目文件的完整路径时，此项目将添加到给定的项目集合中。  
  
 如果计算失败，将引发 InvalidProjectFileException。 如果已在项目集合中加载了等效项目，则会引发 InvalidOperationException。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Project (Microsoft.Build.Construction.ProjectRootElement xml, System.Collections.Generic.IDictionary&lt;string,string&gt; globalProperties, string toolsVersion, string subToolsetVersion, Microsoft.Build.Evaluation.ProjectCollection projectCollection, Microsoft.Build.Evaluation.ProjectLoadSettings loadSettings);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class Microsoft.Build.Construction.ProjectRootElement xml, class System.Collections.Generic.IDictionary`2&lt;string, string&gt; globalProperties, string toolsVersion, string subToolsetVersion, class Microsoft.Build.Evaluation.ProjectCollection projectCollection, valuetype Microsoft.Build.Evaluation.ProjectLoadSettings loadSettings) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.#ctor(Microsoft.Build.Construction.ProjectRootElement,System.Collections.Generic.IDictionary{System.String,System.String},System.String,System.String,Microsoft.Build.Evaluation.ProjectCollection,Microsoft.Build.Evaluation.ProjectLoadSettings)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (xml As ProjectRootElement, globalProperties As IDictionary(Of String, String), toolsVersion As String, subToolsetVersion As String, projectCollection As ProjectCollection, loadSettings As ProjectLoadSettings)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Project(Microsoft::Build::Construction::ProjectRootElement ^ xml, System::Collections::Generic::IDictionary&lt;System::String ^, System::String ^&gt; ^ globalProperties, System::String ^ toolsVersion, System::String ^ subToolsetVersion, Microsoft::Build::Evaluation::ProjectCollection ^ projectCollection, Microsoft::Build::Evaluation::ProjectLoadSettings loadSettings);" />
      <MemberSignature Language="F#" Value="new Microsoft.Build.Evaluation.Project : Microsoft.Build.Construction.ProjectRootElement * System.Collections.Generic.IDictionary&lt;string, string&gt; * string * string * Microsoft.Build.Evaluation.ProjectCollection * Microsoft.Build.Evaluation.ProjectLoadSettings -&gt; Microsoft.Build.Evaluation.Project" Usage="new Microsoft.Build.Evaluation.Project (xml, globalProperties, toolsVersion, subToolsetVersion, projectCollection, loadSettings)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="xml" Type="Microsoft.Build.Construction.ProjectRootElement" Index="0" FrameworkAlternate="msbuild-15;msbuild-15-netcore;msbuild-16;msbuild-16-netcore;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="globalProperties" Type="System.Collections.Generic.IDictionary&lt;System.String,System.String&gt;" Index="1" FrameworkAlternate="msbuild-15;msbuild-15-netcore;msbuild-16;msbuild-16-netcore;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="toolsVersion" Type="System.String" Index="2" FrameworkAlternate="msbuild-15;msbuild-15-netcore;msbuild-16;msbuild-16-netcore;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="subToolsetVersion" Type="System.String" Index="3" FrameworkAlternate="msbuild-15;msbuild-15-netcore;msbuild-16;msbuild-16-netcore;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="projectCollection" Type="Microsoft.Build.Evaluation.ProjectCollection" Index="4" FrameworkAlternate="msbuild-15;msbuild-15-netcore;msbuild-16;msbuild-16-netcore;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="loadSettings" Type="Microsoft.Build.Evaluation.ProjectLoadSettings" Index="5" FrameworkAlternate="msbuild-15;msbuild-15-netcore;msbuild-16;msbuild-16-netcore;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="xml">要使用的 ProjectRootElement</param>
        <param name="globalProperties">要计算的全局属性。 可以为 null，在此情况下，将使用包含项目集合的全局属性。</param>
        <param name="toolsVersion">用于计算的工具版本。 可能为 null</param>
        <param name="subToolsetVersion">用于显式计算工具集的子工具集版本。  可能为 null。</param>
        <param name="projectCollection">项目添加到的 <see cref="P:Microsoft.Build.Evaluation.Project.ProjectCollection" />。</param>
        <param name="loadSettings">要用于计算的 <see cref="T:Microsoft.Build.Evaluation.ProjectLoadSettings" />。</param>
        <summary>在 ProjectRootElement 对象上构造，使用指定的全局属性和工具集（可能其中一个为 null，也可能两者都为 null）进行计算。
如果项目有名称，添加到全局项目集合中，否则在命名后添加。
如果计算失败，将引发 InvalidProjectFileException。
如果已在项目集合中加载了等效项目，则会引发 InvalidOperationException。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当向此项目或给定的项目根提供源项目文件的完整路径时，此项目将添加到给定的项目集合中。  
  
 如果计算失败，将引发 InvalidProjectFileException。 如果已在项目集合中加载了等效项目，则会引发 InvalidOperationException。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Project (string projectFile, System.Collections.Generic.IDictionary&lt;string,string&gt; globalProperties, string toolsVersion, string subToolsetVersion, Microsoft.Build.Evaluation.ProjectCollection projectCollection, Microsoft.Build.Evaluation.ProjectLoadSettings loadSettings);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string projectFile, class System.Collections.Generic.IDictionary`2&lt;string, string&gt; globalProperties, string toolsVersion, string subToolsetVersion, class Microsoft.Build.Evaluation.ProjectCollection projectCollection, valuetype Microsoft.Build.Evaluation.ProjectLoadSettings loadSettings) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.#ctor(System.String,System.Collections.Generic.IDictionary{System.String,System.String},System.String,System.String,Microsoft.Build.Evaluation.ProjectCollection,Microsoft.Build.Evaluation.ProjectLoadSettings)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (projectFile As String, globalProperties As IDictionary(Of String, String), toolsVersion As String, subToolsetVersion As String, projectCollection As ProjectCollection, loadSettings As ProjectLoadSettings)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Project(System::String ^ projectFile, System::Collections::Generic::IDictionary&lt;System::String ^, System::String ^&gt; ^ globalProperties, System::String ^ toolsVersion, System::String ^ subToolsetVersion, Microsoft::Build::Evaluation::ProjectCollection ^ projectCollection, Microsoft::Build::Evaluation::ProjectLoadSettings loadSettings);" />
      <MemberSignature Language="F#" Value="new Microsoft.Build.Evaluation.Project : string * System.Collections.Generic.IDictionary&lt;string, string&gt; * string * string * Microsoft.Build.Evaluation.ProjectCollection * Microsoft.Build.Evaluation.ProjectLoadSettings -&gt; Microsoft.Build.Evaluation.Project" Usage="new Microsoft.Build.Evaluation.Project (projectFile, globalProperties, toolsVersion, subToolsetVersion, projectCollection, loadSettings)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="projectFile" Type="System.String" Index="0" FrameworkAlternate="msbuild-15;msbuild-15-netcore;msbuild-16;msbuild-16-netcore;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="globalProperties" Type="System.Collections.Generic.IDictionary&lt;System.String,System.String&gt;" Index="1" FrameworkAlternate="msbuild-15;msbuild-15-netcore;msbuild-16;msbuild-16-netcore;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="toolsVersion" Type="System.String" Index="2" FrameworkAlternate="msbuild-15;msbuild-15-netcore;msbuild-16;msbuild-16-netcore;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="subToolsetVersion" Type="System.String" Index="3" FrameworkAlternate="msbuild-15;msbuild-15-netcore;msbuild-16;msbuild-16-netcore;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="projectCollection" Type="Microsoft.Build.Evaluation.ProjectCollection" Index="4" FrameworkAlternate="msbuild-15;msbuild-15-netcore;msbuild-16;msbuild-16-netcore;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="loadSettings" Type="Microsoft.Build.Evaluation.ProjectLoadSettings" Index="5" FrameworkAlternate="msbuild-15;msbuild-15-netcore;msbuild-16;msbuild-16-netcore;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="projectFile">项目文件</param>
        <param name="globalProperties">全局属性。 可能为 null。</param>
        <param name="toolsVersion">工具版本。 可能为 null。</param>
        <param name="subToolsetVersion">用于显式计算工具集的子工具集版本。  可能为 null。</param>
        <param name="projectCollection">此项目应与之相关联的集合。 不能为 null。</param>
        <param name="loadSettings">此项目的加载设置。</param>
        <summary>在现有项目文件上构造，使用指定的全局属性并使用提供的工具版本（可能其中一个为 null，也可能两者都为 null）进行计算。
项目添加到全局项目集合中。
如果计算失败，将引发 InvalidProjectFileException。
如果已在项目集合中加载了等效项目，则会引发 InvalidOperationException。
可能引发与 IO 相关的异常。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 项目将添加到给定的项目集合中。  
  
 如果计算失败，将引发 InvalidProjectFileException。 如果已在项目集合中加载了等效项目，则会引发 InvalidOperationException。 可能引发与 IO 相关的异常。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Project (System.Xml.XmlReader xmlReader, System.Collections.Generic.IDictionary&lt;string,string&gt; globalProperties, string toolsVersion, string subToolsetVersion, Microsoft.Build.Evaluation.ProjectCollection projectCollection, Microsoft.Build.Evaluation.ProjectLoadSettings loadSettings);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Xml.XmlReader xmlReader, class System.Collections.Generic.IDictionary`2&lt;string, string&gt; globalProperties, string toolsVersion, string subToolsetVersion, class Microsoft.Build.Evaluation.ProjectCollection projectCollection, valuetype Microsoft.Build.Evaluation.ProjectLoadSettings loadSettings) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.#ctor(System.Xml.XmlReader,System.Collections.Generic.IDictionary{System.String,System.String},System.String,System.String,Microsoft.Build.Evaluation.ProjectCollection,Microsoft.Build.Evaluation.ProjectLoadSettings)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (xmlReader As XmlReader, globalProperties As IDictionary(Of String, String), toolsVersion As String, subToolsetVersion As String, projectCollection As ProjectCollection, loadSettings As ProjectLoadSettings)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Project(System::Xml::XmlReader ^ xmlReader, System::Collections::Generic::IDictionary&lt;System::String ^, System::String ^&gt; ^ globalProperties, System::String ^ toolsVersion, System::String ^ subToolsetVersion, Microsoft::Build::Evaluation::ProjectCollection ^ projectCollection, Microsoft::Build::Evaluation::ProjectLoadSettings loadSettings);" />
      <MemberSignature Language="F#" Value="new Microsoft.Build.Evaluation.Project : System.Xml.XmlReader * System.Collections.Generic.IDictionary&lt;string, string&gt; * string * string * Microsoft.Build.Evaluation.ProjectCollection * Microsoft.Build.Evaluation.ProjectLoadSettings -&gt; Microsoft.Build.Evaluation.Project" Usage="new Microsoft.Build.Evaluation.Project (xmlReader, globalProperties, toolsVersion, subToolsetVersion, projectCollection, loadSettings)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="xmlReader" Type="System.Xml.XmlReader" Index="0" FrameworkAlternate="msbuild-15;msbuild-15-netcore;msbuild-16;msbuild-16-netcore;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="globalProperties" Type="System.Collections.Generic.IDictionary&lt;System.String,System.String&gt;" Index="1" FrameworkAlternate="msbuild-15;msbuild-15-netcore;msbuild-16;msbuild-16-netcore;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="toolsVersion" Type="System.String" Index="2" FrameworkAlternate="msbuild-15;msbuild-15-netcore;msbuild-16;msbuild-16-netcore;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="subToolsetVersion" Type="System.String" Index="3" FrameworkAlternate="msbuild-15;msbuild-15-netcore;msbuild-16;msbuild-16-netcore;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="projectCollection" Type="Microsoft.Build.Evaluation.ProjectCollection" Index="4" FrameworkAlternate="msbuild-15;msbuild-15-netcore;msbuild-16;msbuild-16-netcore;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="loadSettings" Type="Microsoft.Build.Evaluation.ProjectLoadSettings" Index="5" FrameworkAlternate="msbuild-15;msbuild-15-netcore;msbuild-16;msbuild-16-netcore;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="xmlReader">从中读取项目的 Xml 读取器。</param>
        <param name="globalProperties">要计算的全局属性。 可以为 null，在此情况下，将使用包含项目集合的全局属性。</param>
        <param name="toolsVersion">用于计算的工具版本。 可能为 null</param>
        <param name="subToolsetVersion">用于显式计算工具集的子工具集版本。  可能为 null。</param>
        <param name="projectCollection">此项目应与之相关联的集合。 不能为 null。</param>
        <param name="loadSettings">此项目的加载设置。</param>
        <summary>在项目 xml 的文本读取器上构造，使用指定的全局属性和工具集（可能其中一个为 null，也可能两者都为 null）进行计算。
项目命名后，将添加到指定项目集合中。
如果计算失败，将引发 InvalidProjectFileException。
如果已在项目集合中加载了等效项目，则会引发 InvalidOperationException。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当向此项目或给定的项目根提供源项目文件的完整路径时，此项目将添加到给定的项目集合中。  
  
 如果计算失败，将引发 InvalidProjectFileException。 如果已在项目集合中加载了等效项目，则会引发 InvalidOperationException。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AddItem">
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>添加项。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddItem">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IList&lt;Microsoft.Build.Evaluation.ProjectItem&gt; AddItem (string itemType, string unevaluatedInclude);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IList`1&lt;class Microsoft.Build.Evaluation.ProjectItem&gt; AddItem(string itemType, string unevaluatedInclude) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.AddItem(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function AddItem (itemType As String, unevaluatedInclude As String) As IList(Of ProjectItem)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IList&lt;Microsoft::Build::Evaluation::ProjectItem ^&gt; ^ AddItem(System::String ^ itemType, System::String ^ unevaluatedInclude);" />
      <MemberSignature Language="F#" Value="member this.AddItem : string * string -&gt; System.Collections.Generic.IList&lt;Microsoft.Build.Evaluation.ProjectItem&gt;" Usage="project.AddItem (itemType, unevaluatedInclude)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;Microsoft.Build.Evaluation.ProjectItem&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="itemType" Type="System.String" />
        <Parameter Name="unevaluatedInclude" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="itemType">所添加的项的项类型。</param>
        <param name="unevaluatedInclude">要添加的项的 Include 特性。</param>
        <summary>向项目中添加不包含元数据的项。
任何元数据都可以随后进行添加。
如果通配符表达式已经包含新项，则不会修改 XML。
尽力计算：展开所有项。 可以使用在新项下的 XML 中定义的项，尽管在实际计算中不会使用它们。
- 仅计算此项。 其他可能依赖它的项不受影响。
当然，这是一种很方便的方法，在重新计算之前，它不一定会使项目处于完全一致的状态。</summary>
        <returns>添加的项。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 以后可以添加任何元数据。 如果通配符表达式已包含新项，则不会修改项目源。  
  
 评估会尽力进行。 在新项后面的项目源中定义的项可用于计算。 仅评估此项。 可能依赖于它的其他项不受影响。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddItem">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IList&lt;Microsoft.Build.Evaluation.ProjectItem&gt; AddItem (string itemType, string unevaluatedInclude, System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;string,string&gt;&gt; metadata);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IList`1&lt;class Microsoft.Build.Evaluation.ProjectItem&gt; AddItem(string itemType, string unevaluatedInclude, class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;string, string&gt;&gt; metadata) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.AddItem(System.String,System.String,System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{System.String,System.String}})" />
      <MemberSignature Language="VB.NET" Value="Public Function AddItem (itemType As String, unevaluatedInclude As String, metadata As IEnumerable(Of KeyValuePair(Of String, String))) As IList(Of ProjectItem)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IList&lt;Microsoft::Build::Evaluation::ProjectItem ^&gt; ^ AddItem(System::String ^ itemType, System::String ^ unevaluatedInclude, System::Collections::Generic::IEnumerable&lt;System::Collections::Generic::KeyValuePair&lt;System::String ^, System::String ^&gt;&gt; ^ metadata);" />
      <MemberSignature Language="F#" Value="member this.AddItem : string * string * seq&lt;System.Collections.Generic.KeyValuePair&lt;string, string&gt;&gt; -&gt; System.Collections.Generic.IList&lt;Microsoft.Build.Evaluation.ProjectItem&gt;" Usage="project.AddItem (itemType, unevaluatedInclude, metadata)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;Microsoft.Build.Evaluation.ProjectItem&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="itemType" Type="System.String" />
        <Parameter Name="unevaluatedInclude" Type="System.String" />
        <Parameter Name="metadata" Type="System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.String&gt;&gt;" />
      </Parameters>
      <Docs>
        <param name="itemType">所添加的项的项类型。</param>
        <param name="unevaluatedInclude">要添加的项的 Include 特性。</param>
        <param name="metadata">所添加的项的元数据。</param>
        <summary>向此项目中添加包含元数据的项。
元数据可能为 null，以指示没有元数据。
如果通配符表达式已经包含新项，则不会修改 XML。
尽力计算：展开所有项。 可以使用在新项下的 XML 中定义的项，尽管在实际计算中不会使用它们。
- 仅计算此项。 其他可能依赖它的项不受影响。
当然，这是一种很方便的方法，在重新计算之前，它不一定会使项目处于完全一致的状态。</summary>
        <returns>添加的项。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 元数据可能为 null，表示没有元数据。  
  
 评估会尽力进行。 在新项后面的项目源中定义的项可用于计算。 仅评估此项。 可能依赖于它的其他项不受影响。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AddItemFast">
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>向项目中添加不包含元数据的项。  将不会尝试查看现有的通配符是否已匹配新项，除非它是项组中的第一项。  也不会尝试将新项放置到相似项的附近。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddItemFast">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IList&lt;Microsoft.Build.Evaluation.ProjectItem&gt; AddItemFast (string itemType, string unevaluatedInclude);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IList`1&lt;class Microsoft.Build.Evaluation.ProjectItem&gt; AddItemFast(string itemType, string unevaluatedInclude) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.AddItemFast(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function AddItemFast (itemType As String, unevaluatedInclude As String) As IList(Of ProjectItem)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IList&lt;Microsoft::Build::Evaluation::ProjectItem ^&gt; ^ AddItemFast(System::String ^ itemType, System::String ^ unevaluatedInclude);" />
      <MemberSignature Language="F#" Value="member this.AddItemFast : string * string -&gt; System.Collections.Generic.IList&lt;Microsoft.Build.Evaluation.ProjectItem&gt;" Usage="project.AddItemFast (itemType, unevaluatedInclude)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;Microsoft.Build.Evaluation.ProjectItem&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="itemType" Type="System.String" />
        <Parameter Name="unevaluatedInclude" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="itemType">要添加的项类型。</param>
        <param name="unevaluatedInclude">要添加到该项的未计算 Include 特性。</param>
        <summary>向项目中添加不包含元数据的项。
将不会尝试查看现有的通配符是否已匹配新项，除非它是项组中的第一项。
也不会尝试将新项放置到相似项的附近。
将项追加到不具有条件、没有子级或者其第一个子级为同一类型的项的第一个项组。
尽力计算：展开所有项。 可以使用在新项下的 XML 中定义的项，尽管在实际计算中不会使用它们。
- 仅计算此项。 其他可能依赖它的项不受影响。
当然，这是一种很方便的方法，在重新计算之前，它不一定会使项目处于完全一致的状态。</summary>
        <returns>所添加的项目项的列表。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 将项追加到不具有条件、没有子级或者其第一个子级为同一类型的项的第一个项组。  
  
 尽力计算：展开所有项。 可以使用在新项下的 XML 中定义的项，尽管在实际计算中不会使用它们。  
  
 仅评估此项。 可能依赖于它的其他项不受影响。  
  
 当然，这是一种很方便的方法，在重新计算之前，它不一定会使项目处于完全一致的状态。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddItemFast">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IList&lt;Microsoft.Build.Evaluation.ProjectItem&gt; AddItemFast (string itemType, string unevaluatedInclude, System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;string,string&gt;&gt; metadata);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IList`1&lt;class Microsoft.Build.Evaluation.ProjectItem&gt; AddItemFast(string itemType, string unevaluatedInclude, class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;string, string&gt;&gt; metadata) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.AddItemFast(System.String,System.String,System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{System.String,System.String}})" />
      <MemberSignature Language="VB.NET" Value="Public Function AddItemFast (itemType As String, unevaluatedInclude As String, metadata As IEnumerable(Of KeyValuePair(Of String, String))) As IList(Of ProjectItem)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IList&lt;Microsoft::Build::Evaluation::ProjectItem ^&gt; ^ AddItemFast(System::String ^ itemType, System::String ^ unevaluatedInclude, System::Collections::Generic::IEnumerable&lt;System::Collections::Generic::KeyValuePair&lt;System::String ^, System::String ^&gt;&gt; ^ metadata);" />
      <MemberSignature Language="F#" Value="member this.AddItemFast : string * string * seq&lt;System.Collections.Generic.KeyValuePair&lt;string, string&gt;&gt; -&gt; System.Collections.Generic.IList&lt;Microsoft.Build.Evaluation.ProjectItem&gt;" Usage="project.AddItemFast (itemType, unevaluatedInclude, metadata)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;Microsoft.Build.Evaluation.ProjectItem&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="itemType" Type="System.String" />
        <Parameter Name="unevaluatedInclude" Type="System.String" />
        <Parameter Name="metadata" Type="System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.String&gt;&gt;" />
      </Parameters>
      <Docs>
        <param name="itemType">要添加的项类型。</param>
        <param name="unevaluatedInclude">要添加到该项的未计算 Include 特性。</param>
        <param name="metadata">要添加的元数据。</param>
        <summary>向此项目中添加包含元数据的项。
元数据可能为 null，以指示没有元数据。
将不会尝试查看现有的通配符是否已匹配新项，除非它是项组中的第一项。
也不会尝试将新项放置到相似项的附近。
将项追加到不具有条件、没有子级或者其第一个子级为同一类型的项的第一个项组。
尽力计算：展开所有项。 可以使用在新项下的 XML 中定义的项，尽管在实际计算中不会使用它们。
- 仅计算此项。 其他可能依赖它的项不受影响。
当然，这是一种很方便的方法，在重新计算之前，它不一定会使项目处于完全一致的状态。</summary>
        <returns>所添加的项目项的列表。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 将项追加到不具有条件、没有子级或者其第一个子级为同一类型的项的第一个项组。  
  
 尽力计算：展开所有项。 可以使用在新项下的 XML 中定义的项，尽管在实际计算中不会使用它们。  
  
 仅评估此项。 其他可能依赖它的项不受影响。  
  
 当然，这是一种很方便的方法，在重新计算之前，它不一定会使项目处于完全一致的状态。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AllEvaluatedItemDefinitionMetadata">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.ICollection&lt;Microsoft.Build.Evaluation.ProjectMetadata&gt; AllEvaluatedItemDefinitionMetadata { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.ICollection`1&lt;class Microsoft.Build.Evaluation.ProjectMetadata&gt; AllEvaluatedItemDefinitionMetadata" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Build.Evaluation.Project.AllEvaluatedItemDefinitionMetadata" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AllEvaluatedItemDefinitionMetadata As ICollection(Of ProjectMetadata)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::ICollection&lt;Microsoft::Build::Evaluation::ProjectMetadata ^&gt; ^ AllEvaluatedItemDefinitionMetadata { System::Collections::Generic::ICollection&lt;Microsoft::Build::Evaluation::ProjectMetadata ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AllEvaluatedItemDefinitionMetadata : System.Collections.Generic.ICollection&lt;Microsoft.Build.Evaluation.ProjectMetadata&gt;" Usage="Microsoft.Build.Evaluation.Project.AllEvaluatedItemDefinitionMetadata" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.ICollection&lt;Microsoft.Build.Evaluation.ProjectMetadata&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在计算过程中遇到的项定义元数据。 在进行第二轮计算时读取这些项。
与 ItemDefinitions 属性返回的属性不同，这些属性是有序的，它们包含随后被其他具有相同名称和项类型的内容覆盖的任何元数据。 它不包含条件的计算结果不为 true 的任何元素。
它不包含自上次计算后添加的任何项定义元数据。</summary>
        <value>在计算过程中遇到的所有项定义元数据。 这不包括其条件计算结果不为 true 的任何元素，也不包括自上次计算以后添加的任何项定义元数据。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在第二个计算传递过程中读取项元数据。 不同于 ItemDefinitions 属性返回的元数据，将对此元数据进行排序，并包括随后使用相同的名称和项类型重写的任何元数据。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AllEvaluatedItems">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.ICollection&lt;Microsoft.Build.Evaluation.ProjectItem&gt; AllEvaluatedItems { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.ICollection`1&lt;class Microsoft.Build.Evaluation.ProjectItem&gt; AllEvaluatedItems" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Build.Evaluation.Project.AllEvaluatedItems" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AllEvaluatedItems As ICollection(Of ProjectItem)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::ICollection&lt;Microsoft::Build::Evaluation::ProjectItem ^&gt; ^ AllEvaluatedItems { System::Collections::Generic::ICollection&lt;Microsoft::Build::Evaluation::ProjectItem ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AllEvaluatedItems : System.Collections.Generic.ICollection&lt;Microsoft.Build.Evaluation.ProjectItem&gt;" Usage="Microsoft.Build.Evaluation.Project.AllEvaluatedItems" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.ICollection&lt;Microsoft.Build.Evaluation.ProjectItem&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在计算过程中遇到的项。 在进行第三轮计算时读取这些项。
与 Items 属性返回的项不同，这些项是根据在计算期间遇到的所有其他项进行排序的，而不只是根据相同项类型的项进行排序。
在某些应用程序（如 F# 语言）中，这种完全相互的排序是很重要的，此类主机可以使用此属性。
它不包含条件的计算结果不为 true 的任何元素。
它不包含自上次计算后添加的任何项。</summary>
        <value>计算过程中遇到的所有项的枚举器。 在进行第三轮计算时读取这些项。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 与 Items 属性返回的项不同，这些项与在计算过程中遇到的所有其他项有关，而不只是针对相同项类型的项进行排序。  
  
 在某些应用程序中，这种完整的相互排序非常重要，此类主机可以使用此属性。  
  
 枚举不包括其条件计算结果不为 true 的任何元素，也不包括自上次计算后添加的任何项。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AllEvaluatedProperties">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.ICollection&lt;Microsoft.Build.Evaluation.ProjectProperty&gt; AllEvaluatedProperties { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.ICollection`1&lt;class Microsoft.Build.Evaluation.ProjectProperty&gt; AllEvaluatedProperties" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Build.Evaluation.Project.AllEvaluatedProperties" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AllEvaluatedProperties As ICollection(Of ProjectProperty)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::ICollection&lt;Microsoft::Build::Evaluation::ProjectProperty ^&gt; ^ AllEvaluatedProperties { System::Collections::Generic::ICollection&lt;Microsoft::Build::Evaluation::ProjectProperty ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AllEvaluatedProperties : System.Collections.Generic.ICollection&lt;Microsoft.Build.Evaluation.ProjectProperty&gt;" Usage="Microsoft.Build.Evaluation.Project.AllEvaluatedProperties" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.ICollection&lt;Microsoft.Build.Evaluation.ProjectProperty&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在计算过程中遇到的属性。 在进行第一轮计算时读取这些属性。
与 Properties 属性返回的属性不同，这些属性是有序的，它们包含随后被其他具有相同名称的内容覆盖的任何属性。 它不包含条件的计算结果不为 true 的任何属性。
它不包含自上次计算后添加的任何属性。</summary>
        <value>评估过程中遇到的所有属性。 这不包括其条件计算结果不为 true 的任何属性，也不包括自上次计算以后添加的任何属性。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在第一次计算传递过程中，将读取这些属性。 不同于 Properties 属性返回的属性，这些属性是有序的，并包括随后使用同一名称重写的任何属性。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Build">
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>使用默认目标生成此项目。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Build">
      <MemberSignature Language="C#" Value="public bool Build ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Build() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.Build" />
      <MemberSignature Language="VB.NET" Value="Public Function Build () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Build();" />
      <MemberSignature Language="F#" Value="member this.Build : unit -&gt; bool" Usage="project.Build " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>使用此项目启动生成，生成默认目标。
如果成功，则返回 true；如果失败，则返回 false。
适用于私下克隆的实例。 若要设置或获取虚拟项以用于生成，请显式克隆一个实例并生成它。
不会修改 Project 对象。</summary>
        <returns>如果成功，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要设置或获取用于生成的虚拟项，请显式克隆项目实例并生成它。 此方法不会修改项目对象。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Build">
      <MemberSignature Language="C#" Value="public bool Build (Microsoft.Build.Framework.ILogger logger);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Build(class Microsoft.Build.Framework.ILogger logger) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.Build(Microsoft.Build.Framework.ILogger)" />
      <MemberSignature Language="VB.NET" Value="Public Function Build (logger As ILogger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Build(Microsoft::Build::Framework::ILogger ^ logger);" />
      <MemberSignature Language="F#" Value="member this.Build : Microsoft.Build.Framework.ILogger -&gt; bool" Usage="project.Build logger" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="logger" Type="Microsoft.Build.Framework.ILogger" />
      </Parameters>
      <Docs>
        <param name="logger">要在生成期间使用的记录器。</param>
        <summary>使用此项目启动生成，生成默认目标和指定记录器。
如果成功，则返回 true；如果失败，则返回 false。
适用于私下克隆的实例。 若要设置或获取虚拟项以用于生成，请显式克隆一个实例并生成它。
不会修改 Project 对象。</summary>
        <returns>如果成功，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要设置或获取用于生成的虚拟项，请显式克隆项目实例并生成它。 此方法不会修改项目对象。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Build">
      <MemberSignature Language="C#" Value="public bool Build (System.Collections.Generic.IEnumerable&lt;Microsoft.Build.Framework.ILogger&gt; loggers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Build(class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.Build.Framework.ILogger&gt; loggers) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.Build(System.Collections.Generic.IEnumerable{Microsoft.Build.Framework.ILogger})" />
      <MemberSignature Language="VB.NET" Value="Public Function Build (loggers As IEnumerable(Of ILogger)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Build(System::Collections::Generic::IEnumerable&lt;Microsoft::Build::Framework::ILogger ^&gt; ^ loggers);" />
      <MemberSignature Language="F#" Value="member this.Build : seq&lt;Microsoft.Build.Framework.ILogger&gt; -&gt; bool" Usage="project.Build loggers" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="loggers" Type="System.Collections.Generic.IEnumerable&lt;Microsoft.Build.Framework.ILogger&gt;" />
      </Parameters>
      <Docs>
        <param name="loggers">一个可枚举要在生成过程中使用的所有记录器的枚举器。</param>
        <summary>使用此项目启动生成，生成默认目标和指定记录器。
如果成功，则返回 true；如果失败，则返回 false。
适用于私下克隆的实例。 若要设置或获取虚拟项以用于生成，请显式克隆一个实例并生成它。
不会修改 Project 对象。</summary>
        <returns>如果成功，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要设置或获取用于生成的虚拟项，请显式克隆项目实例并生成它。 此方法不会修改项目对象。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Build">
      <MemberSignature Language="C#" Value="public bool Build (string target);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Build(string target) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.Build(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Build (target As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Build(System::String ^ target);" />
      <MemberSignature Language="F#" Value="member this.Build : string -&gt; bool" Usage="project.Build target" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="target">要生成的目标。</param>
        <summary>使用此项目启动生成，生成指定目标。
如果成功，则返回 true；如果失败，则返回 false。
适用于私下克隆的实例。 若要设置或获取虚拟项以用于生成，请显式克隆一个实例并生成它。
不会修改 Project 对象。</summary>
        <returns>如果成功，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要设置或获取用于生成的虚拟项，请显式克隆项目实例并生成它。 此方法不会修改项目对象。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Build">
      <MemberSignature Language="C#" Value="public bool Build (string[] targets);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Build(string[] targets) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.Build(System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Build (targets As String()) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Build(cli::array &lt;System::String ^&gt; ^ targets);" />
      <MemberSignature Language="F#" Value="member this.Build : string[] -&gt; bool" Usage="project.Build targets" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="targets" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="targets">要生成的目标数组。</param>
        <summary>使用此项目启动生成，生成指定目标。
如果成功，则返回 true；如果失败，则返回 false。
适用于私下克隆的实例。 若要设置或获取虚拟项以用于生成，请显式克隆一个实例并生成它。
不会修改 Project 对象。</summary>
        <returns>如果成功，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要设置或获取用于生成的虚拟项，请显式克隆项目实例并生成它。 此方法不会修改项目对象。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Build">
      <MemberSignature Language="C#" Value="public bool Build (System.Collections.Generic.IEnumerable&lt;Microsoft.Build.Framework.ILogger&gt; loggers, System.Collections.Generic.IEnumerable&lt;Microsoft.Build.Logging.ForwardingLoggerRecord&gt; remoteLoggers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Build(class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.Build.Framework.ILogger&gt; loggers, class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.Build.Logging.ForwardingLoggerRecord&gt; remoteLoggers) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.Build(System.Collections.Generic.IEnumerable{Microsoft.Build.Framework.ILogger},System.Collections.Generic.IEnumerable{Microsoft.Build.Logging.ForwardingLoggerRecord})" />
      <MemberSignature Language="VB.NET" Value="Public Function Build (loggers As IEnumerable(Of ILogger), remoteLoggers As IEnumerable(Of ForwardingLoggerRecord)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Build(System::Collections::Generic::IEnumerable&lt;Microsoft::Build::Framework::ILogger ^&gt; ^ loggers, System::Collections::Generic::IEnumerable&lt;Microsoft::Build::Logging::ForwardingLoggerRecord ^&gt; ^ remoteLoggers);" />
      <MemberSignature Language="F#" Value="member this.Build : seq&lt;Microsoft.Build.Framework.ILogger&gt; * seq&lt;Microsoft.Build.Logging.ForwardingLoggerRecord&gt; -&gt; bool" Usage="project.Build (loggers, remoteLoggers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="loggers" Type="System.Collections.Generic.IEnumerable&lt;Microsoft.Build.Framework.ILogger&gt;" />
        <Parameter Name="remoteLoggers" Type="System.Collections.Generic.IEnumerable&lt;Microsoft.Build.Logging.ForwardingLoggerRecord&gt;" />
      </Parameters>
      <Docs>
        <param name="loggers">要在生成期间使用的记录器。</param>
        <param name="remoteLoggers">要在生成期间使用的远程记录器。</param>
        <summary>使用此项目启动生成，生成默认目标和指定记录器。
如果成功，则返回 true；如果失败，则返回 false。
适用于私下克隆的实例。 若要设置或获取虚拟项以用于生成，请显式克隆一个实例并生成它。
不会修改 Project 对象。</summary>
        <returns>如果成功，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要设置或获取用于生成的虚拟项，请显式克隆项目实例并生成它。 此方法不会修改项目对象。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Build">
      <MemberSignature Language="C#" Value="public bool Build (string target, System.Collections.Generic.IEnumerable&lt;Microsoft.Build.Framework.ILogger&gt; loggers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Build(string target, class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.Build.Framework.ILogger&gt; loggers) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.Build(System.String,System.Collections.Generic.IEnumerable{Microsoft.Build.Framework.ILogger})" />
      <MemberSignature Language="VB.NET" Value="Public Function Build (target As String, loggers As IEnumerable(Of ILogger)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Build(System::String ^ target, System::Collections::Generic::IEnumerable&lt;Microsoft::Build::Framework::ILogger ^&gt; ^ loggers);" />
      <MemberSignature Language="F#" Value="member this.Build : string * seq&lt;Microsoft.Build.Framework.ILogger&gt; -&gt; bool" Usage="project.Build (target, loggers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.String" />
        <Parameter Name="loggers" Type="System.Collections.Generic.IEnumerable&lt;Microsoft.Build.Framework.ILogger&gt;" />
      </Parameters>
      <Docs>
        <param name="target">要生成的目标。</param>
        <param name="loggers">要在生成期间使用的记录器。</param>
        <summary>使用此项目启动生成，生成指定目标和指定记录器。
如果成功，则返回 true；如果失败，则返回 false。
适用于私下克隆的实例。 若要设置或获取虚拟项以用于生成，请显式克隆一个实例并生成它。
不会修改 Project 对象。</summary>
        <returns>如果成功，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要设置或获取用于生成的虚拟项，请显式克隆项目实例并生成它。 此方法不会修改项目对象。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Build">
      <MemberSignature Language="C#" Value="public bool Build (string[] targets, System.Collections.Generic.IEnumerable&lt;Microsoft.Build.Framework.ILogger&gt; loggers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Build(string[] targets, class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.Build.Framework.ILogger&gt; loggers) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.Build(System.String[],System.Collections.Generic.IEnumerable{Microsoft.Build.Framework.ILogger})" />
      <MemberSignature Language="VB.NET" Value="Public Function Build (targets As String(), loggers As IEnumerable(Of ILogger)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Build(cli::array &lt;System::String ^&gt; ^ targets, System::Collections::Generic::IEnumerable&lt;Microsoft::Build::Framework::ILogger ^&gt; ^ loggers);" />
      <MemberSignature Language="F#" Value="member this.Build : string[] * seq&lt;Microsoft.Build.Framework.ILogger&gt; -&gt; bool" Usage="project.Build (targets, loggers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="targets" Type="System.String[]" />
        <Parameter Name="loggers" Type="System.Collections.Generic.IEnumerable&lt;Microsoft.Build.Framework.ILogger&gt;" />
      </Parameters>
      <Docs>
        <param name="targets">要生成的目标。</param>
        <param name="loggers">要在生成期间使用的记录器。</param>
        <summary>使用此项目启动生成，生成指定目标和指定记录器。
如果成功，则返回 true；如果失败，则返回 false。
如果禁用此项目的生成，则不会生成，并返回 false。
适用于私下克隆的实例。 若要设置或获取虚拟项以用于生成，请显式克隆一个实例并生成它。
不会修改 Project 对象。</summary>
        <returns>如果成功，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要设置或获取用于生成的虚拟项，请显式克隆项目实例并生成它。 此方法不会修改项目对象。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Build">
      <MemberSignature Language="C#" Value="public bool Build (string target, System.Collections.Generic.IEnumerable&lt;Microsoft.Build.Framework.ILogger&gt; loggers, System.Collections.Generic.IEnumerable&lt;Microsoft.Build.Logging.ForwardingLoggerRecord&gt; remoteLoggers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Build(string target, class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.Build.Framework.ILogger&gt; loggers, class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.Build.Logging.ForwardingLoggerRecord&gt; remoteLoggers) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.Build(System.String,System.Collections.Generic.IEnumerable{Microsoft.Build.Framework.ILogger},System.Collections.Generic.IEnumerable{Microsoft.Build.Logging.ForwardingLoggerRecord})" />
      <MemberSignature Language="VB.NET" Value="Public Function Build (target As String, loggers As IEnumerable(Of ILogger), remoteLoggers As IEnumerable(Of ForwardingLoggerRecord)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Build(System::String ^ target, System::Collections::Generic::IEnumerable&lt;Microsoft::Build::Framework::ILogger ^&gt; ^ loggers, System::Collections::Generic::IEnumerable&lt;Microsoft::Build::Logging::ForwardingLoggerRecord ^&gt; ^ remoteLoggers);" />
      <MemberSignature Language="F#" Value="member this.Build : string * seq&lt;Microsoft.Build.Framework.ILogger&gt; * seq&lt;Microsoft.Build.Logging.ForwardingLoggerRecord&gt; -&gt; bool" Usage="project.Build (target, loggers, remoteLoggers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.String" />
        <Parameter Name="loggers" Type="System.Collections.Generic.IEnumerable&lt;Microsoft.Build.Framework.ILogger&gt;" />
        <Parameter Name="remoteLoggers" Type="System.Collections.Generic.IEnumerable&lt;Microsoft.Build.Logging.ForwardingLoggerRecord&gt;" />
      </Parameters>
      <Docs>
        <param name="target">要生成的目标。</param>
        <param name="loggers">要在生成期间使用的记录器。</param>
        <param name="remoteLoggers">要在生成期间使用的远程记录器。</param>
        <summary>使用此项目启动生成，生成指定目标和指定记录器。
如果成功，则返回 true；如果失败，则返回 false。
适用于私下克隆的实例。 若要设置或获取虚拟项以用于生成，请显式克隆一个实例并生成它。
不会修改 Project 对象。</summary>
        <returns>如果成功，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要设置或获取用于生成的虚拟项，请显式克隆项目实例并生成它。 此方法不会修改项目对象。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Build">
      <MemberSignature Language="C#" Value="public bool Build (string[] targets, System.Collections.Generic.IEnumerable&lt;Microsoft.Build.Framework.ILogger&gt; loggers, System.Collections.Generic.IEnumerable&lt;Microsoft.Build.Logging.ForwardingLoggerRecord&gt; remoteLoggers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Build(string[] targets, class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.Build.Framework.ILogger&gt; loggers, class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.Build.Logging.ForwardingLoggerRecord&gt; remoteLoggers) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.Build(System.String[],System.Collections.Generic.IEnumerable{Microsoft.Build.Framework.ILogger},System.Collections.Generic.IEnumerable{Microsoft.Build.Logging.ForwardingLoggerRecord})" />
      <MemberSignature Language="VB.NET" Value="Public Function Build (targets As String(), loggers As IEnumerable(Of ILogger), remoteLoggers As IEnumerable(Of ForwardingLoggerRecord)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Build(cli::array &lt;System::String ^&gt; ^ targets, System::Collections::Generic::IEnumerable&lt;Microsoft::Build::Framework::ILogger ^&gt; ^ loggers, System::Collections::Generic::IEnumerable&lt;Microsoft::Build::Logging::ForwardingLoggerRecord ^&gt; ^ remoteLoggers);" />
      <MemberSignature Language="F#" Value="member this.Build : string[] * seq&lt;Microsoft.Build.Framework.ILogger&gt; * seq&lt;Microsoft.Build.Logging.ForwardingLoggerRecord&gt; -&gt; bool" Usage="project.Build (targets, loggers, remoteLoggers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="targets" Type="System.String[]" />
        <Parameter Name="loggers" Type="System.Collections.Generic.IEnumerable&lt;Microsoft.Build.Framework.ILogger&gt;" />
        <Parameter Name="remoteLoggers" Type="System.Collections.Generic.IEnumerable&lt;Microsoft.Build.Logging.ForwardingLoggerRecord&gt;" />
      </Parameters>
      <Docs>
        <param name="targets">要生成的目标。</param>
        <param name="loggers">要在生成期间使用的记录器。</param>
        <param name="remoteLoggers">要在生成期间使用的远程记录器。</param>
        <summary>使用此项目启动生成，生成指定目标和指定记录器。
如果成功，则返回 true；如果失败，则返回 false。
如果禁用此项目的生成，则不会生成，并返回 false。
适用于私下克隆的实例。 若要设置或获取虚拟项以用于生成，请显式克隆一个实例并生成它。
不会修改 Project 对象。</summary>
        <returns>如果成功，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要设置或获取用于生成的虚拟项，请显式克隆项目实例并生成它。 此方法不会修改项目对象。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Build">
      <MemberSignature Language="C#" Value="public bool Build (string[] targets, System.Collections.Generic.IEnumerable&lt;Microsoft.Build.Framework.ILogger&gt; loggers, System.Collections.Generic.IEnumerable&lt;Microsoft.Build.Logging.ForwardingLoggerRecord&gt; remoteLoggers, Microsoft.Build.Evaluation.Context.EvaluationContext evaluationContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Build(string[] targets, class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.Build.Framework.ILogger&gt; loggers, class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.Build.Logging.ForwardingLoggerRecord&gt; remoteLoggers, class Microsoft.Build.Evaluation.Context.EvaluationContext evaluationContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.Build(System.String[],System.Collections.Generic.IEnumerable{Microsoft.Build.Framework.ILogger},System.Collections.Generic.IEnumerable{Microsoft.Build.Logging.ForwardingLoggerRecord},Microsoft.Build.Evaluation.Context.EvaluationContext)" />
      <MemberSignature Language="VB.NET" Value="Public Function Build (targets As String(), loggers As IEnumerable(Of ILogger), remoteLoggers As IEnumerable(Of ForwardingLoggerRecord), evaluationContext As EvaluationContext) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Build(cli::array &lt;System::String ^&gt; ^ targets, System::Collections::Generic::IEnumerable&lt;Microsoft::Build::Framework::ILogger ^&gt; ^ loggers, System::Collections::Generic::IEnumerable&lt;Microsoft::Build::Logging::ForwardingLoggerRecord ^&gt; ^ remoteLoggers, Microsoft::Build::Evaluation::Context::EvaluationContext ^ evaluationContext);" />
      <MemberSignature Language="F#" Value="member this.Build : string[] * seq&lt;Microsoft.Build.Framework.ILogger&gt; * seq&lt;Microsoft.Build.Logging.ForwardingLoggerRecord&gt; * Microsoft.Build.Evaluation.Context.EvaluationContext -&gt; bool" Usage="project.Build (targets, loggers, remoteLoggers, evaluationContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="targets" Type="System.String[]" Index="0" FrameworkAlternate="msbuild-15;msbuild-15-netcore;msbuild-16;msbuild-16-netcore" />
        <Parameter Name="loggers" Type="System.Collections.Generic.IEnumerable&lt;Microsoft.Build.Framework.ILogger&gt;" Index="1" FrameworkAlternate="msbuild-15;msbuild-15-netcore;msbuild-16;msbuild-16-netcore" />
        <Parameter Name="remoteLoggers" Type="System.Collections.Generic.IEnumerable&lt;Microsoft.Build.Logging.ForwardingLoggerRecord&gt;" Index="2" FrameworkAlternate="msbuild-15;msbuild-15-netcore;msbuild-16;msbuild-16-netcore" />
        <Parameter Name="evaluationContext" Type="Microsoft.Build.Evaluation.Context.EvaluationContext" Index="3" FrameworkAlternate="msbuild-15;msbuild-15-netcore;msbuild-16;msbuild-16-netcore" />
      </Parameters>
      <Docs>
        <param name="targets">To be added.</param>
        <param name="loggers">To be added.</param>
        <param name="remoteLoggers">To be added.</param>
        <param name="evaluationContext">在需要重新计算的情况下使用的计算上下文</param>
        <summary>请参见<see cref="M:Microsoft.Build.Evaluation.Project.Build(System.String[],System.Collections.Generic.IEnumerable{Microsoft.Build.Framework.ILogger},System.Collections.Generic.IEnumerable{Microsoft.Build.Logging.ForwardingLoggerRecord})" /></summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ConditionedProperties">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IDictionary&lt;string,System.Collections.Generic.List&lt;string&gt;&gt; ConditionedProperties { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IDictionary`2&lt;string, class System.Collections.Generic.List`1&lt;string&gt;&gt; ConditionedProperties" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Build.Evaluation.Project.ConditionedProperties" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ConditionedProperties As IDictionary(Of String, List(Of String))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::IDictionary&lt;System::String ^, System::Collections::Generic::List&lt;System::String ^&gt; ^&gt; ^ ConditionedProperties { System::Collections::Generic::IDictionary&lt;System::String ^, System::Collections::Generic::List&lt;System::String ^&gt; ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ConditionedProperties : System.Collections.Generic.IDictionary&lt;string, System.Collections.Generic.List&lt;string&gt;&gt;" Usage="Microsoft.Build.Evaluation.Project.ConditionedProperties" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="msbuild-15;msbuild-15-netcore;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[get: System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IDictionary&lt;System.String,System.Collections.Generic.List&lt;System.String&gt;&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>包含在属性、属性组、导入和时间的条件中的属性的可能值的集合。
            
例如，如果项目中的属性存在以下情况： 
Condition="'$(Configuration)|$(Platform)' == 'Debug|x86'" Condition="'$(Configuration)' == 'Release'" 
该表将由以下内容填充 
{ "Configuration", { "Debug", "Release" }} { "Platform", { "x86" }} 
Visual Studio 使用此方法来确定项目中定义的配置。</summary>
        <value>属性的可能属性值的集合，这些属性用于计算在属性、属性组、导入和的时间找到的条件。 该集合采用规范格式。 条目的名称是要计算的属性的名称，值是可能的属性值的列表。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 例如，如果以下条件存在于项目中的属性上： Condition = "' $ (Configuration) # B0 $ (平台) " = = "Debug&#124;x86 '" Condition = "' $ (Configuration) ' = = ' Release '"，则将使用 {"Configuration" 填充表 {"调试"，"发布"}} {"平台"，{"x86"}} Visual Studio 使用此集合来确定项目中定义的配置  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateProjectInstance">
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>基于此项目创建一个项目实例，但将此项目与创建的项目实例完全断开连接。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 可用于单独生成。 在创建实例之前计算原始项目（如有必要），以便将原始项目标记为未修改。  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateProjectInstance">
      <MemberSignature Language="C#" Value="public Microsoft.Build.Execution.ProjectInstance CreateProjectInstance ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Microsoft.Build.Execution.ProjectInstance CreateProjectInstance() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.CreateProjectInstance" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateProjectInstance () As ProjectInstance" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::Build::Execution::ProjectInstance ^ CreateProjectInstance();" />
      <MemberSignature Language="F#" Value="member this.CreateProjectInstance : unit -&gt; Microsoft.Build.Execution.ProjectInstance" Usage="project.CreateProjectInstance " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Build.Execution.ProjectInstance</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>基于此项目返回一个实例，但完全断开连接。
此实例可用于独立生成。
在创建实例之前，如有必要，会对项目进行重新计算，因此它将不会更新。</summary>
        <returns>项目实例。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 可用于单独生成。 在创建实例之前计算原始项目（如有必要），以便将原始项目标记为未修改。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateProjectInstance">
      <MemberSignature Language="C#" Value="public Microsoft.Build.Execution.ProjectInstance CreateProjectInstance (Microsoft.Build.Execution.ProjectInstanceSettings settings);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Microsoft.Build.Execution.ProjectInstance CreateProjectInstance(valuetype Microsoft.Build.Execution.ProjectInstanceSettings settings) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.CreateProjectInstance(Microsoft.Build.Execution.ProjectInstanceSettings)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateProjectInstance (settings As ProjectInstanceSettings) As ProjectInstance" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::Build::Execution::ProjectInstance ^ CreateProjectInstance(Microsoft::Build::Execution::ProjectInstanceSettings settings);" />
      <MemberSignature Language="F#" Value="member this.CreateProjectInstance : Microsoft.Build.Execution.ProjectInstanceSettings -&gt; Microsoft.Build.Execution.ProjectInstance" Usage="project.CreateProjectInstance settings" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Build.Execution.ProjectInstance</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="settings" Type="Microsoft.Build.Execution.ProjectInstanceSettings" Index="0" FrameworkAlternate="msbuild-15;msbuild-15-netcore;msbuild-16;msbuild-16-netcore;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="settings">确定所创建的项目实例是否为不可变的，以及该实例是否包含查找表以提高性能。</param>
        <summary>基于此项目返回一个实例，但完全断开连接。
此实例可用于独立生成。
在创建实例之前，如有必要，会对项目进行重新计算，因此它将不会更新。
实例是不可变的；不能修改构成该示例的任何对象。 这样就可以从多个线程中安全地进行访问。</summary>
        <returns>项目实例。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 可用于单独生成。 在创建实例之前计算原始项目（如有必要），以便将原始项目标记为未修改。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateProjectInstance">
      <MemberSignature Language="C#" Value="public Microsoft.Build.Execution.ProjectInstance CreateProjectInstance (Microsoft.Build.Execution.ProjectInstanceSettings settings, Microsoft.Build.Evaluation.Context.EvaluationContext evaluationContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Microsoft.Build.Execution.ProjectInstance CreateProjectInstance(valuetype Microsoft.Build.Execution.ProjectInstanceSettings settings, class Microsoft.Build.Evaluation.Context.EvaluationContext evaluationContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.CreateProjectInstance(Microsoft.Build.Execution.ProjectInstanceSettings,Microsoft.Build.Evaluation.Context.EvaluationContext)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateProjectInstance (settings As ProjectInstanceSettings, evaluationContext As EvaluationContext) As ProjectInstance" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::Build::Execution::ProjectInstance ^ CreateProjectInstance(Microsoft::Build::Execution::ProjectInstanceSettings settings, Microsoft::Build::Evaluation::Context::EvaluationContext ^ evaluationContext);" />
      <MemberSignature Language="F#" Value="member this.CreateProjectInstance : Microsoft.Build.Execution.ProjectInstanceSettings * Microsoft.Build.Evaluation.Context.EvaluationContext -&gt; Microsoft.Build.Execution.ProjectInstance" Usage="project.CreateProjectInstance (settings, evaluationContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Build.Execution.ProjectInstance</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="settings" Type="Microsoft.Build.Execution.ProjectInstanceSettings" Index="0" FrameworkAlternate="msbuild-15;msbuild-15-netcore;msbuild-16;msbuild-16-netcore" />
        <Parameter Name="evaluationContext" Type="Microsoft.Build.Evaluation.Context.EvaluationContext" Index="1" FrameworkAlternate="msbuild-15;msbuild-15-netcore;msbuild-16;msbuild-16-netcore" />
      </Parameters>
      <Docs>
        <param name="settings">To be added.</param>
        <param name="evaluationContext">在需要重新计算的情况下使用的计算上下文</param>
        <summary>请参见<see cref="M:Microsoft.Build.Evaluation.Project.CreateProjectInstance(Microsoft.Build.Execution.ProjectInstanceSettings)" /></summary>
        <returns />
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DirectoryPath">
      <MemberSignature Language="C#" Value="public string DirectoryPath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string DirectoryPath" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Build.Evaluation.Project.DirectoryPath" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DirectoryPath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ DirectoryPath { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DirectoryPath : string" Usage="Microsoft.Build.Evaluation.Project.DirectoryPath" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[get: System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>此项目的根目录。
根目录从不会是 null；内存中项目使用在加载时的当前目录。</summary>
        <value>此项目的根目录。 根目录从不会是 null；内存中项目使用在项目加载时的当前目录。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DisableMarkDirty">
      <MemberSignature Language="C#" Value="public bool DisableMarkDirty { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DisableMarkDirty" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Build.Evaluation.Project.DisableMarkDirty" />
      <MemberSignature Language="VB.NET" Value="Public Property DisableMarkDirty As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool DisableMarkDirty { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.DisableMarkDirty : bool with get, set" Usage="Microsoft.Build.Evaluation.Project.DisableMarkDirty" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="msbuild-16;msbuild-16-netcore">
          <AttributeName Language="C#">[get: System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="msbuild-16;msbuild-16-netcore">
          <AttributeName Language="C#">[set: System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;set: System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>是否暂时禁用 <see cref="M:Microsoft.Build.Evaluation.Project.MarkDirty">MarkDirty()</see>。
例如，可以通过此标记来设置全局属性，而不必将项目标记为已更新（从而导致重新计算）。</summary>
        <value><see langword="true" /> 如果 <see langword="MarkDirty" /> 已暂时禁用，则为; 否则为 <see langword="false" /> 。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EvaluationCounter">
      <MemberSignature Language="C#" Value="public int EvaluationCounter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 EvaluationCounter" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Build.Evaluation.Project.EvaluationCounter" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property EvaluationCounter As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int EvaluationCounter { int get(); };" />
      <MemberSignature Language="F#" Value="member this.EvaluationCounter : int" Usage="Microsoft.Build.Evaluation.Project.EvaluationCounter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>已过时。 请改用 <see cref="P:Microsoft.Build.Evaluation.Project.LastEvaluationId" />。</summary>
        <value>递增的值。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 应将此值与以前的值进行比较，以查看是否已重新计算项目。 不应使用它来确定重新计算项目的次数，因为对于给定的重新计算，该项目可能会递增多次。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ExpandString">
      <MemberSignature Language="C#" Value="public string ExpandString (string unexpandedValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ExpandString(string unexpandedValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.ExpandString(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ExpandString (unexpandedValue As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ExpandString(System::String ^ unexpandedValue);" />
      <MemberSignature Language="F#" Value="member this.ExpandString : string -&gt; string" Usage="project.ExpandString unexpandedValue" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="unexpandedValue" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="unexpandedValue">要计算的字符串。</param>
        <summary>通过展开项和属性来计算提供的字符串，就像在项目文件的最末尾找到的一样。
这对于一些主机来说是很有用的，因为对它们来说，这种尽力计算已经足够了。
不扩展空的元数据表达式。</summary>
        <returns>计算的字符串。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当尽力评估足够时，可以使用此方法。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FromFile">
      <MemberSignature Language="C#" Value="public static Microsoft.Build.Evaluation.Project FromFile (string file, Microsoft.Build.Definition.ProjectOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.Build.Evaluation.Project FromFile(string file, class Microsoft.Build.Definition.ProjectOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.FromFile(System.String,Microsoft.Build.Definition.ProjectOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FromFile (file As String, options As ProjectOptions) As Project" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Microsoft::Build::Evaluation::Project ^ FromFile(System::String ^ file, Microsoft::Build::Definition::ProjectOptions ^ options);" />
      <MemberSignature Language="F#" Value="static member FromFile : string * Microsoft.Build.Definition.ProjectOptions -&gt; Microsoft.Build.Evaluation.Project" Usage="Microsoft.Build.Evaluation.Project.FromFile (file, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Build.Evaluation.Project</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" Index="0" FrameworkAlternate="msbuild-15;msbuild-15-netcore;msbuild-16;msbuild-16-netcore" />
        <Parameter Name="options" Type="Microsoft.Build.Definition.ProjectOptions" Index="1" FrameworkAlternate="msbuild-15;msbuild-15-netcore;msbuild-16;msbuild-16-netcore" />
      </Parameters>
      <Docs>
        <param name="file">要从中计算项目的文件。</param>
        <param name="options">要使用的 <see cref="T:Microsoft.Build.Definition.ProjectOptions" />。</param>
        <summary>创建基于文件的项目。</summary>
        <returns />
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FromProjectRootElement">
      <MemberSignature Language="C#" Value="public static Microsoft.Build.Evaluation.Project FromProjectRootElement (Microsoft.Build.Construction.ProjectRootElement rootElement, Microsoft.Build.Definition.ProjectOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.Build.Evaluation.Project FromProjectRootElement(class Microsoft.Build.Construction.ProjectRootElement rootElement, class Microsoft.Build.Definition.ProjectOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.FromProjectRootElement(Microsoft.Build.Construction.ProjectRootElement,Microsoft.Build.Definition.ProjectOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FromProjectRootElement (rootElement As ProjectRootElement, options As ProjectOptions) As Project" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Microsoft::Build::Evaluation::Project ^ FromProjectRootElement(Microsoft::Build::Construction::ProjectRootElement ^ rootElement, Microsoft::Build::Definition::ProjectOptions ^ options);" />
      <MemberSignature Language="F#" Value="static member FromProjectRootElement : Microsoft.Build.Construction.ProjectRootElement * Microsoft.Build.Definition.ProjectOptions -&gt; Microsoft.Build.Evaluation.Project" Usage="Microsoft.Build.Evaluation.Project.FromProjectRootElement (rootElement, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Build.Evaluation.Project</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rootElement" Type="Microsoft.Build.Construction.ProjectRootElement" Index="0" FrameworkAlternate="msbuild-15;msbuild-15-netcore;msbuild-16;msbuild-16-netcore" />
        <Parameter Name="options" Type="Microsoft.Build.Definition.ProjectOptions" Index="1" FrameworkAlternate="msbuild-15;msbuild-15-netcore;msbuild-16;msbuild-16-netcore" />
      </Parameters>
      <Docs>
        <param name="rootElement">要从中计算项目的 <see cref="T:Microsoft.Build.Construction.ProjectRootElement" />。</param>
        <param name="options">要使用的 <see cref="T:Microsoft.Build.Definition.ProjectOptions" />。</param>
        <summary>创建基于 <see cref="T:Microsoft.Build.Construction.ProjectRootElement" /> 的项目。</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FromXmlReader">
      <MemberSignature Language="C#" Value="public static Microsoft.Build.Evaluation.Project FromXmlReader (System.Xml.XmlReader reader, Microsoft.Build.Definition.ProjectOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.Build.Evaluation.Project FromXmlReader(class System.Xml.XmlReader reader, class Microsoft.Build.Definition.ProjectOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.FromXmlReader(System.Xml.XmlReader,Microsoft.Build.Definition.ProjectOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FromXmlReader (reader As XmlReader, options As ProjectOptions) As Project" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Microsoft::Build::Evaluation::Project ^ FromXmlReader(System::Xml::XmlReader ^ reader, Microsoft::Build::Definition::ProjectOptions ^ options);" />
      <MemberSignature Language="F#" Value="static member FromXmlReader : System.Xml.XmlReader * Microsoft.Build.Definition.ProjectOptions -&gt; Microsoft.Build.Evaluation.Project" Usage="Microsoft.Build.Evaluation.Project.FromXmlReader (reader, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Build.Evaluation.Project</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" Index="0" FrameworkAlternate="msbuild-15;msbuild-15-netcore;msbuild-16;msbuild-16-netcore" />
        <Parameter Name="options" Type="Microsoft.Build.Definition.ProjectOptions" Index="1" FrameworkAlternate="msbuild-15;msbuild-15-netcore;msbuild-16;msbuild-16-netcore" />
      </Parameters>
      <Docs>
        <param name="reader">要从中计算项目的 <see cref="T:System.Xml.XmlReader" />。</param>
        <param name="options">要使用的 <see cref="T:Microsoft.Build.Definition.ProjectOptions" />。</param>
        <summary>创建基于 <see cref="T:System.Xml.XmlReader" /> 的项目。</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FullPath">
      <MemberSignature Language="C#" Value="public string FullPath { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string FullPath" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Build.Evaluation.Project.FullPath" />
      <MemberSignature Language="VB.NET" Value="Public Property FullPath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ FullPath { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.FullPath : string with get, set" Usage="Microsoft.Build.Evaluation.Project.FullPath" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[get: System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[set: System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;set: System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>项目文件的完整路径。
如果未从磁盘加载项目，则可能为 null。
如果项目已命名，Setter 会重命名该项目。</summary>
        <value>项目源文件的完整路径，如果未从磁盘加载项目，则为空字符串。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 对项目集合中的项目设置此属性会重命名该项目。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetAllGlobs">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.List&lt;Microsoft.Build.Evaluation.GlobResult&gt; GetAllGlobs ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.List`1&lt;class Microsoft.Build.Evaluation.GlobResult&gt; GetAllGlobs() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.GetAllGlobs" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAllGlobs () As List(Of GlobResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::List&lt;Microsoft::Build::Evaluation::GlobResult ^&gt; ^ GetAllGlobs();" />
      <MemberSignature Language="F#" Value="member this.GetAllGlobs : unit -&gt; System.Collections.Generic.List&lt;Microsoft.Build.Evaluation.GlobResult&gt;" Usage="project.GetAllGlobs " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.List&lt;Microsoft.Build.Evaluation.GlobResult&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>查找项 include 中指定的所有 glob。</summary>
        <returns><see cref="T:Microsoft.Build.Evaluation.GlobResult" /> 的列表。</returns>
        <remarks><see cref="P:Microsoft.Build.Evaluation.GlobResult.MsBuildGlob" /> 是一个 <see cref="T:Microsoft.Build.Globbing.IMSBuildGlob" /> ，它合并 include 元素中的所有 glob，并忽略 exclude 属性中的所有片段和所有删除元素中应用于 include 元素的所有片段。
             
用户可以构造合并项目中所有 glob 的复合 glob： <code>
             var uberGlob = new CompositeGlob(project.GetAllGlobs().Select(r =&gt; r.MSBuildGlob).ToArray());
             uberGlob.IsMatch("foo.cs");
             </code></remarks>
        <example><code>
            <P>*.txt</P>
            <Bar Include="bar" /> (both outside and inside project cone)
            <Zar Include="C:\**\*.foo" /> (both outside and inside project cone)
            <Foo Include="*.a;*.b" Exclude="3.a" /><Foo Remove="2.a" /><Foo Include="**\*.b" Exclude="1.b;**\obj\*.b;**\bar\*.b" /><Foo Include="$(P)" /><Foo Include="*.a;@(Bar);3.a" /> (If Bar has globs, they will have been included when querying Bar ProjectItems for globs)
            <Foo Include="*.cs" Exclude="@(Bar)" /></code>
             
示例结果： [GlobResult (glob： "C： \* * \* foo"，排除： [] ) ，GlobResult (glob： ["*. a"，"*. b"]，exclude = [""]，remove = ["2. a"] ) ，GlobResult (glob： "* * \* b."，exclude = ["1. b，* * \obj \* "，**\bar \* "] ) ，GlobResult (glob："*.txt "，exclude = [] ) ，GlobResult (glob："*。 a "，exclude = [] ) ，GlobResult (glob："*.cs "，exclude = [" bar "] ) ]</example>
      </Docs>
    </Member>
    <Member MemberName="GetAllGlobs">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.List&lt;Microsoft.Build.Evaluation.GlobResult&gt; GetAllGlobs (Microsoft.Build.Evaluation.Context.EvaluationContext evaluationContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.List`1&lt;class Microsoft.Build.Evaluation.GlobResult&gt; GetAllGlobs(class Microsoft.Build.Evaluation.Context.EvaluationContext evaluationContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.GetAllGlobs(Microsoft.Build.Evaluation.Context.EvaluationContext)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAllGlobs (evaluationContext As EvaluationContext) As List(Of GlobResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::List&lt;Microsoft::Build::Evaluation::GlobResult ^&gt; ^ GetAllGlobs(Microsoft::Build::Evaluation::Context::EvaluationContext ^ evaluationContext);" />
      <MemberSignature Language="F#" Value="member this.GetAllGlobs : Microsoft.Build.Evaluation.Context.EvaluationContext -&gt; System.Collections.Generic.List&lt;Microsoft.Build.Evaluation.GlobResult&gt;" Usage="project.GetAllGlobs evaluationContext" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.List&lt;Microsoft.Build.Evaluation.GlobResult&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="evaluationContext" Type="Microsoft.Build.Evaluation.Context.EvaluationContext" Index="0" FrameworkAlternate="msbuild-15;msbuild-15-netcore;msbuild-16;msbuild-16-netcore" />
      </Parameters>
      <Docs>
        <param name="evaluationContext">在需要重新计算的情况下使用的计算上下文。
为了避免重新计算，请使用 <see cref="F:Microsoft.Build.Evaluation.ProjectLoadSettings.RecordEvaluatedItemElements" /></param>
        <summary>请参见<see cref="M:Microsoft.Build.Evaluation.Project.GetAllGlobs" /></summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetAllGlobs">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.List&lt;Microsoft.Build.Evaluation.GlobResult&gt; GetAllGlobs (string itemType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.List`1&lt;class Microsoft.Build.Evaluation.GlobResult&gt; GetAllGlobs(string itemType) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.GetAllGlobs(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAllGlobs (itemType As String) As List(Of GlobResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::List&lt;Microsoft::Build::Evaluation::GlobResult ^&gt; ^ GetAllGlobs(System::String ^ itemType);" />
      <MemberSignature Language="F#" Value="member this.GetAllGlobs : string -&gt; System.Collections.Generic.List&lt;Microsoft.Build.Evaluation.GlobResult&gt;" Usage="project.GetAllGlobs itemType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.List&lt;Microsoft.Build.Evaluation.GlobResult&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="itemType" Type="System.String" Index="0" FrameworkAlternate="msbuild-15;msbuild-15-netcore;msbuild-16;msbuild-16-netcore" />
      </Parameters>
      <Docs>
        <param name="itemType">将搜索范围限定为此类型的项元素</param>
        <summary><see cref="M:Microsoft.Build.Evaluation.Project.GetAllGlobs" /> 的重载</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetAllGlobs">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.List&lt;Microsoft.Build.Evaluation.GlobResult&gt; GetAllGlobs (string itemType, Microsoft.Build.Evaluation.Context.EvaluationContext evaluationContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.List`1&lt;class Microsoft.Build.Evaluation.GlobResult&gt; GetAllGlobs(string itemType, class Microsoft.Build.Evaluation.Context.EvaluationContext evaluationContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.GetAllGlobs(System.String,Microsoft.Build.Evaluation.Context.EvaluationContext)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAllGlobs (itemType As String, evaluationContext As EvaluationContext) As List(Of GlobResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::List&lt;Microsoft::Build::Evaluation::GlobResult ^&gt; ^ GetAllGlobs(System::String ^ itemType, Microsoft::Build::Evaluation::Context::EvaluationContext ^ evaluationContext);" />
      <MemberSignature Language="F#" Value="member this.GetAllGlobs : string * Microsoft.Build.Evaluation.Context.EvaluationContext -&gt; System.Collections.Generic.List&lt;Microsoft.Build.Evaluation.GlobResult&gt;" Usage="project.GetAllGlobs (itemType, evaluationContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.List&lt;Microsoft.Build.Evaluation.GlobResult&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="itemType" Type="System.String" Index="0" FrameworkAlternate="msbuild-15;msbuild-15-netcore;msbuild-16;msbuild-16-netcore" />
        <Parameter Name="evaluationContext" Type="Microsoft.Build.Evaluation.Context.EvaluationContext" Index="1" FrameworkAlternate="msbuild-15;msbuild-15-netcore;msbuild-16;msbuild-16-netcore" />
      </Parameters>
      <Docs>
        <param name="itemType">To be added.</param>
        <param name="evaluationContext">在需要重新计算的情况下使用的计算上下文。
为了避免重新计算，请使用 <see cref="F:Microsoft.Build.Evaluation.ProjectLoadSettings.RecordEvaluatedItemElements" /></param>
        <summary>请参见<see cref="M:Microsoft.Build.Evaluation.Project.GetAllGlobs(System.String)" /></summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetEvaluatedItemIncludeEscaped">
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>获取所提供的项的 Include 特性的值，该值是计算得到的且经过了转义。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetEvaluatedItemIncludeEscaped">
      <MemberSignature Language="C#" Value="public static string GetEvaluatedItemIncludeEscaped (Microsoft.Build.Evaluation.ProjectItem item);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetEvaluatedItemIncludeEscaped(class Microsoft.Build.Evaluation.ProjectItem item) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.GetEvaluatedItemIncludeEscaped(Microsoft.Build.Evaluation.ProjectItem)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEvaluatedItemIncludeEscaped (item As ProjectItem) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetEvaluatedItemIncludeEscaped(Microsoft::Build::Evaluation::ProjectItem ^ item);" />
      <MemberSignature Language="F#" Value="static member GetEvaluatedItemIncludeEscaped : Microsoft.Build.Evaluation.ProjectItem -&gt; string" Usage="Microsoft.Build.Evaluation.Project.GetEvaluatedItemIncludeEscaped item" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="Microsoft.Build.Evaluation.ProjectItem" />
      </Parameters>
      <Docs>
        <param name="item">要计算和转义的项。</param>
        <summary>返回所提供的项的 include 的经计算的转义值。</summary>
        <returns>所提供的项的 Include 特性的值，该值是计算得到的且经过了转义。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetEvaluatedItemIncludeEscaped">
      <MemberSignature Language="C#" Value="public static string GetEvaluatedItemIncludeEscaped (Microsoft.Build.Evaluation.ProjectItemDefinition item);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetEvaluatedItemIncludeEscaped(class Microsoft.Build.Evaluation.ProjectItemDefinition item) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.GetEvaluatedItemIncludeEscaped(Microsoft.Build.Evaluation.ProjectItemDefinition)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEvaluatedItemIncludeEscaped (item As ProjectItemDefinition) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetEvaluatedItemIncludeEscaped(Microsoft::Build::Evaluation::ProjectItemDefinition ^ item);" />
      <MemberSignature Language="F#" Value="static member GetEvaluatedItemIncludeEscaped : Microsoft.Build.Evaluation.ProjectItemDefinition -&gt; string" Usage="Microsoft.Build.Evaluation.Project.GetEvaluatedItemIncludeEscaped item" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="Microsoft.Build.Evaluation.ProjectItemDefinition" />
      </Parameters>
      <Docs>
        <param name="item">要计算和转义的项定义。</param>
        <summary>返回所提供的项定义的 include 的经计算的转义值。</summary>
        <returns>Include 特性的值。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetItemProvenance">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.List&lt;Microsoft.Build.Evaluation.ProvenanceResult&gt; GetItemProvenance (Microsoft.Build.Evaluation.ProjectItem item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.List`1&lt;class Microsoft.Build.Evaluation.ProvenanceResult&gt; GetItemProvenance(class Microsoft.Build.Evaluation.ProjectItem item) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.GetItemProvenance(Microsoft.Build.Evaluation.ProjectItem)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetItemProvenance (item As ProjectItem) As List(Of ProvenanceResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::List&lt;Microsoft::Build::Evaluation::ProvenanceResult ^&gt; ^ GetItemProvenance(Microsoft::Build::Evaluation::ProjectItem ^ item);" />
      <MemberSignature Language="F#" Value="member this.GetItemProvenance : Microsoft.Build.Evaluation.ProjectItem -&gt; System.Collections.Generic.List&lt;Microsoft.Build.Evaluation.ProvenanceResult&gt;" Usage="project.GetItemProvenance item" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.List&lt;Microsoft.Build.Evaluation.ProvenanceResult&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="Microsoft.Build.Evaluation.ProjectItem" Index="0" FrameworkAlternate="msbuild-15;msbuild-15-netcore;msbuild-16;msbuild-16-netcore" />
      </Parameters>
      <Docs>
        <param name="item">ProjectItem 对象，指示要匹配的项规范以及要限制搜索范围的项类型。
搜索范围也限于在生成此 <paramref name="item" /> 的项元素之前出现的项元素。
生成此 <paramref name="item" /> 的元素包含在结果中。</param>
        <summary><see cref="M:Microsoft.Build.Evaluation.Project.GetItemProvenance(System.String)" /> 的重载</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetItemProvenance">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.List&lt;Microsoft.Build.Evaluation.ProvenanceResult&gt; GetItemProvenance (string itemToMatch);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.List`1&lt;class Microsoft.Build.Evaluation.ProvenanceResult&gt; GetItemProvenance(string itemToMatch) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.GetItemProvenance(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetItemProvenance (itemToMatch As String) As List(Of ProvenanceResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::List&lt;Microsoft::Build::Evaluation::ProvenanceResult ^&gt; ^ GetItemProvenance(System::String ^ itemToMatch);" />
      <MemberSignature Language="F#" Value="member this.GetItemProvenance : string -&gt; System.Collections.Generic.List&lt;Microsoft.Build.Evaluation.ProvenanceResult&gt;" Usage="project.GetItemProvenance itemToMatch" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.List&lt;Microsoft.Build.Evaluation.ProvenanceResult&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="itemToMatch" Type="System.String" Index="0" FrameworkAlternate="msbuild-15;msbuild-15-netcore;msbuild-16;msbuild-16-netcore" />
      </Parameters>
      <Docs>
        <param name="itemToMatch">要对其执行匹配的字符串</param>
        <summary>查找具有与给定字符串相匹配的项规范的逻辑项目中的所有项元素：- 将包含（或排除）字符串的元素 - 将更新字符串（尚未执行）的元素 - 将删除字符串（尚未执行）的元素</summary>
        <returns>按项目计算顺序排序的 <see cref="T:Microsoft.Build.Evaluation.ProvenanceResult" /> 的列表。</returns>
        <remarks>此方法及其重载适用于需要检查可能引用特定项实例的所有项元素的客户端。 例如，Visual Studio 使用它来检查具有 glob 的项目。 文件系统或 IDE 文件项目发生更改时，VS 将调用此方法来查找可能引用检测到的文件更改的所有项 (例如，"哪些项元素引用" Program.cs "？）) 。
它使用此类信息来了解应编辑哪些元素，以反映用户或文件系统的更改。
             
字符串匹配尝试首先匹配字符串。 如果检查失败，则它会尝试将字符串与它们表示文件一样：将两个字符串作为相对于当前项目目录的文件进行标准化 
GetItemProvenance 受到导致的某些源的影响：-在计算后执行，因此在项引用存在时不区分项数据流 (它在计算结束时看到项)  
此 API 及其返回类型容易发生变化。</remarks>
        <example>以下代码片段显示了哪些 <c>GetItemProvenance ( "a.cs" ) </c> 为各个项元素返回 <code><A Include="a.cs;*.cs" /> // Occurrences:2; Operation: Include; Provenance: StringLiteral | Glob
             <B Include="*.cs" Exclude="a.cs" /> // Occurrences: 1; Operation: Exclude; Provenance: StringLiteral
             <C Include="b.cs" /> // NA
             <D Include="@(A)" /> // Occurrences: 2; Operation: Include; Provenance: Inconclusive (it is an indirect occurrence from a referenced item)
             <E Include="$(P)" /> // Occurrences: 4; Operation: Include; Provenance: FromLiteral (direct reference in $P) | Glob (direct reference in $P) | Inconclusive (it is an indirect occurrence from referenced properties and items)
             <PropertyGroup><P>a.cs;*.cs;@(A)</P></PropertyGroup></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetItemProvenance">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.List&lt;Microsoft.Build.Evaluation.ProvenanceResult&gt; GetItemProvenance (Microsoft.Build.Evaluation.ProjectItem item, Microsoft.Build.Evaluation.Context.EvaluationContext evaluationContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.List`1&lt;class Microsoft.Build.Evaluation.ProvenanceResult&gt; GetItemProvenance(class Microsoft.Build.Evaluation.ProjectItem item, class Microsoft.Build.Evaluation.Context.EvaluationContext evaluationContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.GetItemProvenance(Microsoft.Build.Evaluation.ProjectItem,Microsoft.Build.Evaluation.Context.EvaluationContext)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetItemProvenance (item As ProjectItem, evaluationContext As EvaluationContext) As List(Of ProvenanceResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::List&lt;Microsoft::Build::Evaluation::ProvenanceResult ^&gt; ^ GetItemProvenance(Microsoft::Build::Evaluation::ProjectItem ^ item, Microsoft::Build::Evaluation::Context::EvaluationContext ^ evaluationContext);" />
      <MemberSignature Language="F#" Value="member this.GetItemProvenance : Microsoft.Build.Evaluation.ProjectItem * Microsoft.Build.Evaluation.Context.EvaluationContext -&gt; System.Collections.Generic.List&lt;Microsoft.Build.Evaluation.ProvenanceResult&gt;" Usage="project.GetItemProvenance (item, evaluationContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.List&lt;Microsoft.Build.Evaluation.ProvenanceResult&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="Microsoft.Build.Evaluation.ProjectItem" Index="0" FrameworkAlternate="msbuild-15;msbuild-15-netcore;msbuild-16;msbuild-16-netcore" />
        <Parameter Name="evaluationContext" Type="Microsoft.Build.Evaluation.Context.EvaluationContext" Index="1" FrameworkAlternate="msbuild-15;msbuild-15-netcore;msbuild-16;msbuild-16-netcore" />
      </Parameters>
      <Docs>
        <param name="item">To be added.</param>
        <param name="evaluationContext">在需要重新计算的情况下使用的计算上下文。
为了避免重新计算，请使用 <see cref="F:Microsoft.Build.Evaluation.ProjectLoadSettings.RecordEvaluatedItemElements" /></param>
        <summary>请参见<see cref="M:Microsoft.Build.Evaluation.Project.GetItemProvenance(Microsoft.Build.Evaluation.ProjectItem)" /></summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetItemProvenance">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.List&lt;Microsoft.Build.Evaluation.ProvenanceResult&gt; GetItemProvenance (string itemToMatch, Microsoft.Build.Evaluation.Context.EvaluationContext evaluationContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.List`1&lt;class Microsoft.Build.Evaluation.ProvenanceResult&gt; GetItemProvenance(string itemToMatch, class Microsoft.Build.Evaluation.Context.EvaluationContext evaluationContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.GetItemProvenance(System.String,Microsoft.Build.Evaluation.Context.EvaluationContext)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetItemProvenance (itemToMatch As String, evaluationContext As EvaluationContext) As List(Of ProvenanceResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::List&lt;Microsoft::Build::Evaluation::ProvenanceResult ^&gt; ^ GetItemProvenance(System::String ^ itemToMatch, Microsoft::Build::Evaluation::Context::EvaluationContext ^ evaluationContext);" />
      <MemberSignature Language="F#" Value="member this.GetItemProvenance : string * Microsoft.Build.Evaluation.Context.EvaluationContext -&gt; System.Collections.Generic.List&lt;Microsoft.Build.Evaluation.ProvenanceResult&gt;" Usage="project.GetItemProvenance (itemToMatch, evaluationContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.List&lt;Microsoft.Build.Evaluation.ProvenanceResult&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="itemToMatch" Type="System.String" Index="0" FrameworkAlternate="msbuild-15;msbuild-15-netcore;msbuild-16;msbuild-16-netcore" />
        <Parameter Name="evaluationContext" Type="Microsoft.Build.Evaluation.Context.EvaluationContext" Index="1" FrameworkAlternate="msbuild-15;msbuild-15-netcore;msbuild-16;msbuild-16-netcore" />
      </Parameters>
      <Docs>
        <param name="itemToMatch">To be added.</param>
        <param name="evaluationContext">在需要重新计算的情况下使用的计算上下文。
为了避免重新计算，请使用 <see cref="F:Microsoft.Build.Evaluation.ProjectLoadSettings.RecordEvaluatedItemElements" /></param>
        <summary>请参见<see cref="M:Microsoft.Build.Evaluation.Project.GetItemProvenance(System.String)" /></summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetItemProvenance">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.List&lt;Microsoft.Build.Evaluation.ProvenanceResult&gt; GetItemProvenance (string itemToMatch, string itemType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.List`1&lt;class Microsoft.Build.Evaluation.ProvenanceResult&gt; GetItemProvenance(string itemToMatch, string itemType) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.GetItemProvenance(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetItemProvenance (itemToMatch As String, itemType As String) As List(Of ProvenanceResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::List&lt;Microsoft::Build::Evaluation::ProvenanceResult ^&gt; ^ GetItemProvenance(System::String ^ itemToMatch, System::String ^ itemType);" />
      <MemberSignature Language="F#" Value="member this.GetItemProvenance : string * string -&gt; System.Collections.Generic.List&lt;Microsoft.Build.Evaluation.ProvenanceResult&gt;" Usage="project.GetItemProvenance (itemToMatch, itemType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.List&lt;Microsoft.Build.Evaluation.ProvenanceResult&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="itemToMatch" Type="System.String" Index="0" FrameworkAlternate="msbuild-15;msbuild-15-netcore;msbuild-16;msbuild-16-netcore" />
        <Parameter Name="itemType" Type="System.String" Index="1" FrameworkAlternate="msbuild-15;msbuild-15-netcore;msbuild-16;msbuild-16-netcore" />
      </Parameters>
      <Docs>
        <param name="itemToMatch">要对其执行匹配的字符串</param>
        <param name="itemType">要在其中进行搜索的项类型</param>
        <summary><see cref="M:Microsoft.Build.Evaluation.Project.GetItemProvenance(System.String)" /> 的重载</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetItemProvenance">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.List&lt;Microsoft.Build.Evaluation.ProvenanceResult&gt; GetItemProvenance (string itemToMatch, string itemType, Microsoft.Build.Evaluation.Context.EvaluationContext evaluationContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.List`1&lt;class Microsoft.Build.Evaluation.ProvenanceResult&gt; GetItemProvenance(string itemToMatch, string itemType, class Microsoft.Build.Evaluation.Context.EvaluationContext evaluationContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.GetItemProvenance(System.String,System.String,Microsoft.Build.Evaluation.Context.EvaluationContext)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetItemProvenance (itemToMatch As String, itemType As String, evaluationContext As EvaluationContext) As List(Of ProvenanceResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::List&lt;Microsoft::Build::Evaluation::ProvenanceResult ^&gt; ^ GetItemProvenance(System::String ^ itemToMatch, System::String ^ itemType, Microsoft::Build::Evaluation::Context::EvaluationContext ^ evaluationContext);" />
      <MemberSignature Language="F#" Value="member this.GetItemProvenance : string * string * Microsoft.Build.Evaluation.Context.EvaluationContext -&gt; System.Collections.Generic.List&lt;Microsoft.Build.Evaluation.ProvenanceResult&gt;" Usage="project.GetItemProvenance (itemToMatch, itemType, evaluationContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.List&lt;Microsoft.Build.Evaluation.ProvenanceResult&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="itemToMatch" Type="System.String" Index="0" FrameworkAlternate="msbuild-15;msbuild-15-netcore;msbuild-16;msbuild-16-netcore" />
        <Parameter Name="itemType" Type="System.String" Index="1" FrameworkAlternate="msbuild-15;msbuild-15-netcore;msbuild-16;msbuild-16-netcore" />
        <Parameter Name="evaluationContext" Type="Microsoft.Build.Evaluation.Context.EvaluationContext" Index="2" FrameworkAlternate="msbuild-15;msbuild-15-netcore;msbuild-16;msbuild-16-netcore" />
      </Parameters>
      <Docs>
        <param name="itemToMatch">To be added.</param>
        <param name="itemType">To be added.</param>
        <param name="evaluationContext">在需要重新计算的情况下使用的计算上下文。
为了避免重新计算，请使用 <see cref="F:Microsoft.Build.Evaluation.ProjectLoadSettings.RecordEvaluatedItemElements" /></param>
        <summary>请参见<see cref="M:Microsoft.Build.Evaluation.Project.GetItemProvenance(System.String,System.String)" /></summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetItems">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.ICollection&lt;Microsoft.Build.Evaluation.ProjectItem&gt; GetItems (string itemType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.ICollection`1&lt;class Microsoft.Build.Evaluation.ProjectItem&gt; GetItems(string itemType) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.GetItems(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetItems (itemType As String) As ICollection(Of ProjectItem)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::ICollection&lt;Microsoft::Build::Evaluation::ProjectItem ^&gt; ^ GetItems(System::String ^ itemType);" />
      <MemberSignature Language="F#" Value="member this.GetItems : string -&gt; System.Collections.Generic.ICollection&lt;Microsoft.Build.Evaluation.ProjectItem&gt;" Usage="project.GetItems itemType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.ICollection&lt;Microsoft.Build.Evaluation.ProjectItem&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="itemType" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="itemType">要检索的项类型。</param>
        <summary>指定类型的项目中的所有项。
如果不存在任何给定项类型的项，则返回一个空列表。
使用 AddItem 或 RemoveItem 修改此项目中的项。</summary>
        <returns>项目中的给定项类型的所有项，或者如果没有任何具有给定项名称的项，则为空列表。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用 AddItem 或 RemoveItem 修改此项目中的项。  
  
 ]]></format>
        </remarks>
        <comments>数据.GetItems 返回一个只读集合，因此无需在此处重新包装。</comments>
      </Docs>
    </Member>
    <Member MemberName="GetItemsByEvaluatedInclude">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.ICollection&lt;Microsoft.Build.Evaluation.ProjectItem&gt; GetItemsByEvaluatedInclude (string evaluatedInclude);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.ICollection`1&lt;class Microsoft.Build.Evaluation.ProjectItem&gt; GetItemsByEvaluatedInclude(string evaluatedInclude) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.GetItemsByEvaluatedInclude(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetItemsByEvaluatedInclude (evaluatedInclude As String) As ICollection(Of ProjectItem)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::ICollection&lt;Microsoft::Build::Evaluation::ProjectItem ^&gt; ^ GetItemsByEvaluatedInclude(System::String ^ evaluatedInclude);" />
      <MemberSignature Language="F#" Value="member this.GetItemsByEvaluatedInclude : string -&gt; System.Collections.Generic.ICollection&lt;Microsoft.Build.Evaluation.ProjectItem&gt;" Usage="project.GetItemsByEvaluatedInclude evaluatedInclude" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.ICollection&lt;Microsoft.Build.Evaluation.ProjectItem&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="evaluatedInclude" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="evaluatedInclude">计算的 Include 特性。</param>
        <summary>返回具有指定计算的 Include 的所有项。
例如，具有计算的 Include“bar.cpp”的所有项。
通常会有零个或一个项，但有时会有两个项，它们具有相同的路径和不同的项类型，甚至连项类型都相同。 这会返回全部。</summary>
        <returns>具有给定的计算 Include 特性的所有项。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 例如，此方法可能会返回所有具有已计算的 Include 特性 "component .cpp" 的项。 通常，返回零个或一个项。 但是，可能有多个具有相同路径和不同项类型的项，甚至有相同的项类型。  
  
 ]]></format>
        </remarks>
        <comments>数据.GetItemsByEvaluatedInclude 已经返回一个只读集合，因此不需要进一步包装。</comments>
      </Docs>
    </Member>
    <Member MemberName="GetItemsIgnoringCondition">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.ICollection&lt;Microsoft.Build.Evaluation.ProjectItem&gt; GetItemsIgnoringCondition (string itemType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.ICollection`1&lt;class Microsoft.Build.Evaluation.ProjectItem&gt; GetItemsIgnoringCondition(string itemType) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.GetItemsIgnoringCondition(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetItemsIgnoringCondition (itemType As String) As ICollection(Of ProjectItem)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::ICollection&lt;Microsoft::Build::Evaluation::ProjectItem ^&gt; ^ GetItemsIgnoringCondition(System::String ^ itemType);" />
      <MemberSignature Language="F#" Value="member this.GetItemsIgnoringCondition : string -&gt; System.Collections.Generic.ICollection&lt;Microsoft.Build.Evaluation.ProjectItem&gt;" Usage="project.GetItemsIgnoringCondition itemType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.ICollection&lt;Microsoft.Build.Evaluation.ProjectItem&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="itemType" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="itemType">要检索的项类型。</param>
        <summary>指定类型的项目中的所有项，无论它们的条件计算结果是否为 true。
这是一个只读列表：可使用 AddItem 或 RemoveItem 修改此项目中的项。</summary>
        <returns>项目中的给定类型的所有项（不管其 Condition 特性的计算结果是否为 true）。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 这是一个只读列表。 使用 AddItem 或 RemoveItem 修改此项目中的项。  
  
 ]]></format>
        </remarks>
        <comments>ItemDictionary [] 返回一个只读集合，因此不需要将其包装。</comments>
      </Docs>
    </Member>
    <Member MemberName="GetLogicalProject">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;Microsoft.Build.Construction.ProjectElement&gt; GetLogicalProject ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.Build.Construction.ProjectElement&gt; GetLogicalProject() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.GetLogicalProject" />
      <MemberSignature Language="VB.NET" Value="Public Iterator Function GetLogicalProject () As IEnumerable(Of ProjectElement)" FrameworkAlternate="msbuild-15;msbuild-15-netcore" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IEnumerable&lt;Microsoft::Build::Construction::ProjectElement ^&gt; ^ GetLogicalProject();" />
      <MemberSignature Language="F#" Value="member this.GetLogicalProject : unit -&gt; seq&lt;Microsoft.Build.Construction.ProjectElement&gt;" Usage="project.GetLogicalProject " />
      <MemberSignature Language="VB.NET" Value="Public Function GetLogicalProject () As IEnumerable(Of ProjectElement)" FrameworkAlternate="msbuild-16;msbuild-16-netcore;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="msbuild-15;msbuild-15-netcore">
          <AttributeName Language="C#">[System.Runtime.CompilerServices.IteratorStateMachine(typeof(Microsoft.Build.Evaluation.Project/&lt;GetLogicalProject&gt;d__136))]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IteratorStateMachine(typeof(Microsoft.Build.Evaluation.Project/&lt;GetLogicalProject&gt;d__136))&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.Build.Construction.ProjectElement&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回一个迭代器，该迭代器用于“逻辑项目”。 逻辑项目定义为从单个 MSBuild 文件获得的未计算项目，该 MSBuild 文件是通过将原始 MSBuild 项目清单文件的所有导入的文本内联得到的。</summary>
        <returns>可枚举“逻辑项目”中的所有元素的枚举器。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 逻辑项目定义为从单个 MSBuild 文件获取的未计算的项目，该文件是包含原始 MSBuild 项目清单文件的所有导入的文本内联的结果。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetMetadataValueEscaped">
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>获取所提供的项中具有提供的名称的元数据的转义值。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetMetadataValueEscaped">
      <MemberSignature Language="C#" Value="public static string GetMetadataValueEscaped (Microsoft.Build.Evaluation.ProjectMetadata metadatum);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetMetadataValueEscaped(class Microsoft.Build.Evaluation.ProjectMetadata metadatum) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.GetMetadataValueEscaped(Microsoft.Build.Evaluation.ProjectMetadata)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetMetadataValueEscaped (metadatum As ProjectMetadata) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetMetadataValueEscaped(Microsoft::Build::Evaluation::ProjectMetadata ^ metadatum);" />
      <MemberSignature Language="F#" Value="static member GetMetadataValueEscaped : Microsoft.Build.Evaluation.ProjectMetadata -&gt; string" Usage="Microsoft.Build.Evaluation.Project.GetMetadataValueEscaped metadatum" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metadatum" Type="Microsoft.Build.Evaluation.ProjectMetadata" />
      </Parameters>
      <Docs>
        <param name="metadatum">要转义的元数据。</param>
        <summary>获取所提供的元数据的转义值。</summary>
        <returns>所提供的元数据的转义值。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMetadataValueEscaped">
      <MemberSignature Language="C#" Value="public static string GetMetadataValueEscaped (Microsoft.Build.Evaluation.ProjectItem item, string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetMetadataValueEscaped(class Microsoft.Build.Evaluation.ProjectItem item, string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.GetMetadataValueEscaped(Microsoft.Build.Evaluation.ProjectItem,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetMetadataValueEscaped (item As ProjectItem, name As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetMetadataValueEscaped(Microsoft::Build::Evaluation::ProjectItem ^ item, System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member GetMetadataValueEscaped : Microsoft.Build.Evaluation.ProjectItem * string -&gt; string" Usage="Microsoft.Build.Evaluation.Project.GetMetadataValueEscaped (item, name)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="Microsoft.Build.Evaluation.ProjectItem" />
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="item">要转义其元数据的项。</param>
        <param name="name">要转义的元数据的名称。</param>
        <summary>获取所提供的项中具有提供的名称的元数据的转义值。</summary>
        <returns>所提供的项中具有提供的名称的元数据的转义值。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMetadataValueEscaped">
      <MemberSignature Language="C#" Value="public static string GetMetadataValueEscaped (Microsoft.Build.Evaluation.ProjectItemDefinition item, string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetMetadataValueEscaped(class Microsoft.Build.Evaluation.ProjectItemDefinition item, string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.GetMetadataValueEscaped(Microsoft.Build.Evaluation.ProjectItemDefinition,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetMetadataValueEscaped (item As ProjectItemDefinition, name As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetMetadataValueEscaped(Microsoft::Build::Evaluation::ProjectItemDefinition ^ item, System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member GetMetadataValueEscaped : Microsoft.Build.Evaluation.ProjectItemDefinition * string -&gt; string" Usage="Microsoft.Build.Evaluation.Project.GetMetadataValueEscaped (item, name)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="Microsoft.Build.Evaluation.ProjectItemDefinition" />
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="item">要转义其元数据的项定义。</param>
        <param name="name">要转义的元数据的名称。</param>
        <summary>获取所提供的项定义上具有提供的名称的元数据的转义值。</summary>
        <returns>所提供的项定义上具有提供的名称的元数据的转义值。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public Microsoft.Build.Evaluation.ProjectProperty GetProperty (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Microsoft.Build.Evaluation.ProjectProperty GetProperty(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.GetProperty(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetProperty (name As String) As ProjectProperty" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::Build::Evaluation::ProjectProperty ^ GetProperty(System::String ^ name);" />
      <MemberSignature Language="F#" Value="member this.GetProperty : string -&gt; Microsoft.Build.Evaluation.ProjectProperty" Usage="project.GetProperty name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Build.Evaluation.ProjectProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">要检索的属性的名称。</param>
        <summary>获取具有指定名称的项目中的任何属性；否则返回 null</summary>
        <returns>项目中具有指定名称的任何属性，或如果不存在具有该名称的属性，则为 <see langword="null" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetPropertyValue">
      <MemberSignature Language="C#" Value="public string GetPropertyValue (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetPropertyValue(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.GetPropertyValue(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetPropertyValue (name As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetPropertyValue(System::String ^ name);" />
      <MemberSignature Language="F#" Value="member this.GetPropertyValue : string -&gt; string" Usage="project.GetPropertyValue name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">要检索其值的属性的名称。</param>
        <summary>获取此项目中属性的未转义值，如果属性不存在，则为空字符串。</summary>
        <returns>此项目中的给定属性的值，或如果不存在具有该名称的属性，则为空字符串。 在返回字符串之前将转换转义序列。</returns>
        <remarks>如果属性的值为空字符串，并且根本没有属性，则不能在此方法之间区分。
这样可以更轻松地使用。 若要确定是否在项目中对属性进行了设置，请使用 GetProperty (名称) 。</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetPropertyValueEscaped">
      <MemberSignature Language="C#" Value="public static string GetPropertyValueEscaped (Microsoft.Build.Evaluation.ProjectProperty property);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetPropertyValueEscaped(class Microsoft.Build.Evaluation.ProjectProperty property) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.GetPropertyValueEscaped(Microsoft.Build.Evaluation.ProjectProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetPropertyValueEscaped (property As ProjectProperty) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetPropertyValueEscaped(Microsoft::Build::Evaluation::ProjectProperty ^ property);" />
      <MemberSignature Language="F#" Value="static member GetPropertyValueEscaped : Microsoft.Build.Evaluation.ProjectProperty -&gt; string" Usage="Microsoft.Build.Evaluation.Project.GetPropertyValueEscaped property" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="property" Type="Microsoft.Build.Evaluation.ProjectProperty" />
      </Parameters>
      <Docs>
        <param name="property">要转义的属性。</param>
        <summary>获取所提供的属性的转义值</summary>
        <returns>所提供的属性的转义值。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GlobalProperties">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IDictionary&lt;string,string&gt; GlobalProperties { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IDictionary`2&lt;string, string&gt; GlobalProperties" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Build.Evaluation.Project.GlobalProperties" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property GlobalProperties As IDictionary(Of String, String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::IDictionary&lt;System::String ^, System::String ^&gt; ^ GlobalProperties { System::Collections::Generic::IDictionary&lt;System::String ^, System::String ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.GlobalProperties : System.Collections.Generic.IDictionary&lt;string, string&gt;" Usage="Microsoft.Build.Evaluation.Project.GlobalProperties" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="msbuild-15;msbuild-15-netcore;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[get: System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IDictionary&lt;System.String,System.String&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>仅读取用于计算此项目的全局属性的字典。</summary>
        <value>用于计算此项目的全局属性的字典。</value>
        <remarks>这是公开的 getter，转换为只读停滞 IDictionary &lt; 字符串字符串 &gt; 。
            
为了轻松地判断更新，设置和删除全局属性是通过 <see cref="M:Microsoft.Build.Evaluation.Project.SetGlobalProperty(System.String,System.String)">SetGlobalProperty</see> 和 <see cref="M:Microsoft.Build.Evaluation.Project.RemoveGlobalProperty(System.String)">RemoveGlobalProperty</see>来完成的。</remarks>
      </Docs>
    </Member>
    <Member MemberName="Imports">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IList&lt;Microsoft.Build.Evaluation.ResolvedImport&gt; Imports { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IList`1&lt;valuetype Microsoft.Build.Evaluation.ResolvedImport&gt; Imports" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Build.Evaluation.Project.Imports" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Imports As IList(Of ResolvedImport)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::IList&lt;Microsoft::Build::Evaluation::ResolvedImport&gt; ^ Imports { System::Collections::Generic::IList&lt;Microsoft::Build::Evaluation::ResolvedImport&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Imports : System.Collections.Generic.IList&lt;Microsoft.Build.Evaluation.ResolvedImport&gt;" Usage="Microsoft.Build.Evaluation.Project.Imports" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;Microsoft.Build.Evaluation.ResolvedImport&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在计算过程中参与了此项目的所有文件（如 ProjectRootElements），以及导致它们被导入的 ProjectImportElement。
这不包括从未导入的项目，因为 Import 元素上的条件为 false。
不包含映射到此项目本身的外部 ProjectRootElement。</summary>
        <value>参与此项目计算的所有文件的列表。  
  
 每项的名称是导致导入对应文件的 Import 元素。 每项的值是导入的项目的项目根。 将不包括其 Condition 特性的计算结果为 false 的 Import 元素。</value>
        <remarks>主机可以使用此方法来找出对特定文件的更改可能会影响哪些项目。
例如，还可以使用它来查找 user 文件，并使用其 ProjectRootElement 修改其中的属性。</remarks>
      </Docs>
    </Member>
    <Member MemberName="ImportsIncludingDuplicates">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IList&lt;Microsoft.Build.Evaluation.ResolvedImport&gt; ImportsIncludingDuplicates { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IList`1&lt;valuetype Microsoft.Build.Evaluation.ResolvedImport&gt; ImportsIncludingDuplicates" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Build.Evaluation.Project.ImportsIncludingDuplicates" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ImportsIncludingDuplicates As IList(Of ResolvedImport)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::IList&lt;Microsoft::Build::Evaluation::ResolvedImport&gt; ^ ImportsIncludingDuplicates { System::Collections::Generic::IList&lt;Microsoft::Build::Evaluation::ResolvedImport&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ImportsIncludingDuplicates : System.Collections.Generic.IList&lt;Microsoft.Build.Evaluation.ResolvedImport&gt;" Usage="Microsoft.Build.Evaluation.Project.ImportsIncludingDuplicates" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;Microsoft.Build.Evaluation.ResolvedImport&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>如果多次导入某个导入文件，则此列表将包含重复导入。 但是，在计算中仅使用第一个导入。</summary>
        <value>重复导入的列表。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsBuildEnabled">
      <MemberSignature Language="C#" Value="public bool IsBuildEnabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsBuildEnabled" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Build.Evaluation.Project.IsBuildEnabled" />
      <MemberSignature Language="VB.NET" Value="Public Property IsBuildEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsBuildEnabled { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.IsBuildEnabled : bool with get, set" Usage="Microsoft.Build.Evaluation.Project.IsBuildEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="msbuild-16;msbuild-16-netcore">
          <AttributeName Language="C#">[get: System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="msbuild-16;msbuild-16-netcore">
          <AttributeName Language="C#">[set: System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;set: System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>这会控制是否为此项目启用目标/任务的生成。  这是为了安全起见，主机需要严格控制允许哪些项目运行目标/任务。  默认情况下，对于新创建的项目，我们将使用父项目集合中的任何设置。
当禁用生成时，此类的生成方法将失败。 但是，如果主机已创建 ProjectInstance，它仍可生成。 （可以随时对此过程执行类似检查。）</summary>
        <value><see langword="true" /> 如果可以生成此项目的目标和任务，则为; 否则为。否则为 <see langword="false" /> 。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 可用于安全目的。 默认情况下，新项目具有与包含它的父项目集合相同的 IsBuildEnabled 设置。 当 IsBuildEnabled 为 false 时，此项目上的生成方法将失败。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsDirty">
      <MemberSignature Language="C#" Value="public bool IsDirty { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsDirty" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Build.Evaluation.Project.IsDirty" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsDirty As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsDirty { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsDirty : bool" Usage="Microsoft.Build.Evaluation.Project.IsDirty" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>此项目是否已更新，以至于需要重新计算。
这可能是因为它的基础 XML（由于这个项目或其他项目）更改了主项目的 XML 或导入的文件；或者是因为它的工具集可能发生了变化。</summary>
        <value><see langword="true" /> 如果此项目已修改以便必须重新计算，则为;否则为 <see langword="false" /> 。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 修改项目时，必须在基础项目源代码（包括对导入文件的更改）时重新计算项目。 如果项目工具集发生更改，则还必须重新计算项目的修改。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ItemDefinitions">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IDictionary&lt;string,Microsoft.Build.Evaluation.ProjectItemDefinition&gt; ItemDefinitions { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IDictionary`2&lt;string, class Microsoft.Build.Evaluation.ProjectItemDefinition&gt; ItemDefinitions" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Build.Evaluation.Project.ItemDefinitions" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ItemDefinitions As IDictionary(Of String, ProjectItemDefinition)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::IDictionary&lt;System::String ^, Microsoft::Build::Evaluation::ProjectItemDefinition ^&gt; ^ ItemDefinitions { System::Collections::Generic::IDictionary&lt;System::String ^, Microsoft::Build::Evaluation::ProjectItemDefinition ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ItemDefinitions : System.Collections.Generic.IDictionary&lt;string, Microsoft.Build.Evaluation.ProjectItemDefinition&gt;" Usage="Microsoft.Build.Evaluation.Project.ItemDefinitions" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[get: System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IDictionary&lt;System.String,Microsoft.Build.Evaluation.ProjectItemDefinition&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>此项目中项定义的只读字典。
按项目类型键控</summary>
        <value>此项目中的项定义的字典，按项类型进行键控。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Items">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.ICollection&lt;Microsoft.Build.Evaluation.ProjectItem&gt; Items { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.ICollection`1&lt;class Microsoft.Build.Evaluation.ProjectItem&gt; Items" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Build.Evaluation.Project.Items" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Items As ICollection(Of ProjectItem)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::ICollection&lt;Microsoft::Build::Evaluation::ProjectItem ^&gt; ^ Items { System::Collections::Generic::ICollection&lt;Microsoft::Build::Evaluation::ProjectItem ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Items : System.Collections.Generic.ICollection&lt;Microsoft.Build.Evaluation.ProjectItem&gt;" Usage="Microsoft.Build.Evaluation.Project.Items" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[get: System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.ICollection&lt;Microsoft.Build.Evaluation.ProjectItem&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>此项目中的项，在项类型组内排序</summary>
        <value>针对此项目中的所有项的枚举器，在项类型组中进行排序。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ItemsIgnoringCondition">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.ICollection&lt;Microsoft.Build.Evaluation.ProjectItem&gt; ItemsIgnoringCondition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.ICollection`1&lt;class Microsoft.Build.Evaluation.ProjectItem&gt; ItemsIgnoringCondition" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Build.Evaluation.Project.ItemsIgnoringCondition" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ItemsIgnoringCondition As ICollection(Of ProjectItem)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::ICollection&lt;Microsoft::Build::Evaluation::ProjectItem ^&gt; ^ ItemsIgnoringCondition { System::Collections::Generic::ICollection&lt;Microsoft::Build::Evaluation::ProjectItem ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ItemsIgnoringCondition : System.Collections.Generic.ICollection&lt;Microsoft.Build.Evaluation.ProjectItem&gt;" Usage="Microsoft.Build.Evaluation.Project.ItemsIgnoringCondition" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="msbuild-15;msbuild-15-netcore;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[get: System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.ICollection&lt;Microsoft.Build.Evaluation.ProjectItem&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>此项目中的项（在项类型组内排序），包括条件计算结果为 false 的项，或者包含在本身的条件计算结果为 false 的项组中的项。
这对于想要显示所有项的主机非常有用，即使它们可能不是当前配置中的生成的一部分。</summary>
        <value>此项目中的所有项（在项类型组中排序）的枚举器（包括其条件计算结果为 false 的项），或者包含在其条件计算结果为的项组中 <see langword="false" /> 。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 可用于显示所有项，即使它们不是当前配置中的生成的一部分。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ItemTypes">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.ICollection&lt;string&gt; ItemTypes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.ICollection`1&lt;string&gt; ItemTypes" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Build.Evaluation.Project.ItemTypes" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ItemTypes As ICollection(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::ICollection&lt;System::String ^&gt; ^ ItemTypes { System::Collections::Generic::ICollection&lt;System::String ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ItemTypes : System.Collections.Generic.ICollection&lt;string&gt;" Usage="Microsoft.Build.Evaluation.Project.ItemTypes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[get: System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.ICollection&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>此项目中的项类型。
这是一个有序集合。</summary>
        <value>此项目中的所有项类型的枚举器。 这是一个有序集合。</value>
        <remarks>To be added.</remarks>
        <comments>数据.ItemTypes 是 Tvalue&gt;.keycollection，因此不需要任何额外的只读保护</comments>
      </Docs>
    </Member>
    <Member MemberName="LastEvaluationId">
      <MemberSignature Language="C#" Value="public int LastEvaluationId { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 LastEvaluationId" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Build.Evaluation.Project.LastEvaluationId" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LastEvaluationId As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int LastEvaluationId { int get(); };" />
      <MemberSignature Language="F#" Value="member this.LastEvaluationId : int" Usage="Microsoft.Build.Evaluation.Project.LastEvaluationId" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>此项目的最后一个计算的 ID。
项目始终在构造时进行计算，随后还可以通过 <see cref="M:Microsoft.Build.Evaluation.Project.ReevaluateIfNecessary" /> 进行多次计算
            
它是一个任意的数字，当重新计算此项目时，这个数字会发生变化。
主机不知道某个时间间隔内是否确实发生了某个计算，但它们可以将此数字与以前存储的值进行比较以确定，如果是这样，也许就会决定更新自己的状态。
请注意，数字可能不会单调地增加。
            
此数字对应于 <seealso cref="P:Microsoft.Build.Framework.BuildEventContext.EvaluationId" /> 并可用于将计算日志记录事件连接回项目实例。</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MarkDirty">
      <MemberSignature Language="C#" Value="public void MarkDirty ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void MarkDirty() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.MarkDirty" />
      <MemberSignature Language="VB.NET" Value="Public Sub MarkDirty ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void MarkDirty();" />
      <MemberSignature Language="F#" Value="member this.MarkDirty : unit -&gt; unit" Usage="project.MarkDirty " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>调用它以强制将项目标记为已更新，需要重新计算。 通常情况下，此设置不是必需的；影响此项目的所有编辑内容都将自动将其标记为已更新。 但在某些情况下，有必要将项目直接标记为已更新。 例如，如果项目的导入限于磁盘上的现有文件，并且该文件在计算期间不存在，则当某个用户随后创建该文件时，该项目将无法知道重新计算会起作用。
在这种情况下，主机可以帮助我们，显式设置已更新标志，这样 <see cref="M:Microsoft.Build.Evaluation.Project.ReevaluateIfNecessary">ReevaluateIfNecessary()</see> 就会识别出确实需要进行的计算。
不会将基础项目文件标记为需要保存。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 很少需要显式调用此方法，因为影响项目的所有编辑会自动将其标记为已修改。  
  
 但有时，必须调用此方法。 例如，项目可能有一个导入元素，其条件依赖于磁盘上存在的文件。 如果该文件不存在于计算时，并且在计算后创建，则该项目必须显式标记为已修改。  
  
 <xref:Microsoft.Build.Evaluation.Project.ReevaluateIfNecessary%2A>方法使用此属性来确定是否需要进行评估。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ProjectCollection">
      <MemberSignature Language="C#" Value="public Microsoft.Build.Evaluation.ProjectCollection ProjectCollection { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.Build.Evaluation.ProjectCollection ProjectCollection" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Build.Evaluation.Project.ProjectCollection" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ProjectCollection As ProjectCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Microsoft::Build::Evaluation::ProjectCollection ^ ProjectCollection { Microsoft::Build::Evaluation::ProjectCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ProjectCollection : Microsoft.Build.Evaluation.ProjectCollection" Usage="Microsoft.Build.Evaluation.Project.ProjectCollection" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[get: System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Build.Evaluation.ProjectCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置包含此项目的项目集合。
决不能为 null。
不能修改。</summary>
        <value>包含此项目的项目集合，它绝不会 <see langword="null" /> 。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ProjectFileLocation">
      <MemberSignature Language="C#" Value="public Microsoft.Build.Construction.ElementLocation ProjectFileLocation { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.Build.Construction.ElementLocation ProjectFileLocation" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Build.Evaluation.Project.ProjectFileLocation" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ProjectFileLocation As ElementLocation" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Microsoft::Build::Construction::ElementLocation ^ ProjectFileLocation { Microsoft::Build::Construction::ElementLocation ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ProjectFileLocation : Microsoft.Build.Construction.ElementLocation" Usage="Microsoft.Build.Evaluation.Project.ProjectFileLocation" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Build.Construction.ElementLocation</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>原始文件本身的位置，其中没有任何特定内容。
如果未对文件命名一个名称，则返回空位置。</summary>
        <value>原始文件位置，或者，如果没有为文件指定名称，则为空位置。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Properties">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.ICollection&lt;Microsoft.Build.Evaluation.ProjectProperty&gt; Properties { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.ICollection`1&lt;class Microsoft.Build.Evaluation.ProjectProperty&gt; Properties" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Build.Evaluation.Project.Properties" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Properties As ICollection(Of ProjectProperty)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::ICollection&lt;Microsoft::Build::Evaluation::ProjectProperty ^&gt; ^ Properties { System::Collections::Generic::ICollection&lt;Microsoft::Build::Evaluation::ProjectProperty ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Properties : System.Collections.Generic.ICollection&lt;Microsoft.Build.Evaluation.ProjectProperty&gt;" Usage="Microsoft.Build.Evaluation.Project.Properties" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[get: System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.ICollection&lt;Microsoft.Build.Evaluation.ProjectProperty&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>此项目中的属性。
由于已发生计算，因此这是一个无序集合。</summary>
        <value>此项目中的所有属性的枚举器。 由于属性按其出现的顺序进行计算，因此这是一个无序集合。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReevaluateIfNecessary">
      <MemberSignature Language="C#" Value="public void ReevaluateIfNecessary ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReevaluateIfNecessary() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.ReevaluateIfNecessary" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReevaluateIfNecessary ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ReevaluateIfNecessary();" />
      <MemberSignature Language="F#" Value="member this.ReevaluateIfNecessary : unit -&gt; unit" Usage="project.ReevaluateIfNecessary " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>如果项目已更新，请重新计算项目，使其进入可查询状态。
这合并了之前通过编辑此项目对支持的 XML 进行的所有更改。
如果计算失败，将引发 InvalidProjectFileException。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 仅当项目标记为已修改时才会重新计算。 重新评估合并了对项目源代码所做的所有更改。  
  
 如果计算失败，将引发 InvalidProjectFileException。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReevaluateIfNecessary">
      <MemberSignature Language="C#" Value="public void ReevaluateIfNecessary (Microsoft.Build.Evaluation.Context.EvaluationContext evaluationContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReevaluateIfNecessary(class Microsoft.Build.Evaluation.Context.EvaluationContext evaluationContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.ReevaluateIfNecessary(Microsoft.Build.Evaluation.Context.EvaluationContext)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReevaluateIfNecessary (evaluationContext As EvaluationContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ReevaluateIfNecessary(Microsoft::Build::Evaluation::Context::EvaluationContext ^ evaluationContext);" />
      <MemberSignature Language="F#" Value="member this.ReevaluateIfNecessary : Microsoft.Build.Evaluation.Context.EvaluationContext -&gt; unit" Usage="project.ReevaluateIfNecessary evaluationContext" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="evaluationContext" Type="Microsoft.Build.Evaluation.Context.EvaluationContext" Index="0" FrameworkAlternate="msbuild-15;msbuild-15-netcore;msbuild-16;msbuild-16-netcore" />
      </Parameters>
      <Docs>
        <param name="evaluationContext">要使用的 <see cref="T:Microsoft.Build.Evaluation.Context.EvaluationContext" />。 请参见<see cref="T:Microsoft.Build.Evaluation.Context.EvaluationContext" /></param>
        <summary>请参见<see cref="M:Microsoft.Build.Evaluation.Project.ReevaluateIfNecessary" /></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveGlobalProperty">
      <MemberSignature Language="C#" Value="public bool RemoveGlobalProperty (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool RemoveGlobalProperty(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.RemoveGlobalProperty(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveGlobalProperty (name As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool RemoveGlobalProperty(System::String ^ name);" />
      <MemberSignature Language="F#" Value="member this.RemoveGlobalProperty : string -&gt; bool" Usage="project.RemoveGlobalProperty name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">要移除的全局属性的名称。</param>
        <summary>删除一个全局属性。
如果已设置，则返回 true，并将项目标记为需要重新计算。</summary>
        <returns>如果设置了全局属性的值，则为 <see langword="true" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveItem">
      <MemberSignature Language="C#" Value="public bool RemoveItem (Microsoft.Build.Evaluation.ProjectItem item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool RemoveItem(class Microsoft.Build.Evaluation.ProjectItem item) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.RemoveItem(Microsoft.Build.Evaluation.ProjectItem)" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveItem (item As ProjectItem) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool RemoveItem(Microsoft::Build::Evaluation::ProjectItem ^ item);" />
      <MemberSignature Language="F#" Value="member this.RemoveItem : Microsoft.Build.Evaluation.ProjectItem -&gt; bool" Usage="project.RemoveItem item" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="Microsoft.Build.Evaluation.ProjectItem" />
      </Parameters>
      <Docs>
        <param name="item">要移除的项。</param>
        <summary>从项目中移除一个项。
项必须与此项目相关联。
项不能源自于导入的文件。
如果该项存在于此计算的项目中，则返回 true，否则返回 false。
为方便起见，如果父项组为空，则它也会被删除。
如果项源自通配符或分号分隔的表达式，则先将该表达式扩展为多个项。
更新已计算的项目，但在重新计算之前不会影响项目中的其他内容。 例如，如果删除了一个类型为“i”的项，则在重新计算之前，将不会修改从“@(i)”计算得出的“j”。
当然，这是一种很方便的方法，在重新计算之前，它不一定会使项目处于完全一致的状态。</summary>
        <returns>如果此项存在于此计算的项目中，则为 <see langword="true" />；否则为 <see langword="false" />。 此方法通常会返回 true，原因是，如果请求的项不存在，则此方法会引发异常。 不过，如果该项仅存在于 ItemsIgnoringCondition 集合中，则此方法将返回 <see langword="false" />。</returns>
        <remarks>通常，这将返回 true，因为如果项不在项目中，则会引发。
异常是删除仅在 ItemsIgnoringCondition 中的项。</remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveItems">
      <MemberSignature Language="C#" Value="public void RemoveItems (System.Collections.Generic.IEnumerable&lt;Microsoft.Build.Evaluation.ProjectItem&gt; items);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RemoveItems(class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.Build.Evaluation.ProjectItem&gt; items) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.RemoveItems(System.Collections.Generic.IEnumerable{Microsoft.Build.Evaluation.ProjectItem})" />
      <MemberSignature Language="VB.NET" Value="Public Sub RemoveItems (items As IEnumerable(Of ProjectItem))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RemoveItems(System::Collections::Generic::IEnumerable&lt;Microsoft::Build::Evaluation::ProjectItem ^&gt; ^ items);" />
      <MemberSignature Language="F#" Value="member this.RemoveItems : seq&lt;Microsoft.Build.Evaluation.ProjectItem&gt; -&gt; unit" Usage="project.RemoveItems items" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="items" Type="System.Collections.Generic.IEnumerable&lt;Microsoft.Build.Evaluation.ProjectItem&gt;" />
      </Parameters>
      <Docs>
        <param name="items">要移除的项。</param>
        <summary>从项目中移除所有指定的项。
与此项目无关的项目将被跳过。</summary>
        <remarks>删除一个项目可能会导致对后备 XML 进行扩展，这可能会在下一项)  (解除关联。
为了使调用方可以轻松使用这种情况，如果项未与此项目相关联，则只需跳过它。</remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveProperty">
      <MemberSignature Language="C#" Value="public bool RemoveProperty (Microsoft.Build.Evaluation.ProjectProperty property);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool RemoveProperty(class Microsoft.Build.Evaluation.ProjectProperty property) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.RemoveProperty(Microsoft.Build.Evaluation.ProjectProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveProperty (property As ProjectProperty) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool RemoveProperty(Microsoft::Build::Evaluation::ProjectProperty ^ property);" />
      <MemberSignature Language="F#" Value="member this.RemoveProperty : Microsoft.Build.Evaluation.ProjectProperty -&gt; bool" Usage="project.RemoveProperty property" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="property" Type="Microsoft.Build.Evaluation.ProjectProperty" />
      </Parameters>
      <Docs>
        <param name="property">要删除的属性。</param>
        <summary>删除指定属性。
属性必须与此项目相关联。
属性不能源自于导入的文件。
如果该属性存在于此计算的项目中，则返回 true，否则返回 false。
为方便起见，如果父属性组为空，则它也会被删除。
更新已计算的项目，但在重新计算之前不会影响项目中的其他内容。 例如，如果删除了“p”，则会将其从计算的项目中删除，但在重新计算之前，将不会修改从“$(p)”计算得出的“q”。
当然，这是一种很方便的方法，它不一定会使项目处于完全一致的状态。</summary>
        <returns>如果此属性存在于此计算的项目中，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果包含该属性的属性组为空，则它也将被删除。  
  
 项目已更新，但在重新评估之前不会进行进一步的评估。 例如，如果删除了 "p"，则在重新评估之前，不会修改从 "$ (p) 计算得到的" q "。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Save">
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>使用默认的字符编码将项目保存到文件系统上（如果项目已修改）。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Save">
      <MemberSignature Language="C#" Value="public void Save ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Save() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.Save" />
      <MemberSignature Language="VB.NET" Value="Public Sub Save ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Save();" />
      <MemberSignature Language="F#" Value="member this.Save : unit -&gt; unit" Usage="project.Save " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>将项目保存到文件系统（如果项目被标记为已更新）。
使用默认编码。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Save">
      <MemberSignature Language="C#" Value="public void Save (System.IO.TextWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Save(class System.IO.TextWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.Save(System.IO.TextWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Save (writer As TextWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Save(System::IO::TextWriter ^ writer);" />
      <MemberSignature Language="F#" Value="member this.Save : System.IO.TextWriter -&gt; unit" Usage="project.Save writer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.IO.TextWriter" />
      </Parameters>
      <Docs>
        <param name="writer">要将项目保存到的文本编写器。</param>
        <summary>将项目保存到提供的 TextWriter 中（无论项目是否被标记为已更新）。
使用 TextWriter 的编码。
清除“已更新”标志。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Save">
      <MemberSignature Language="C#" Value="public void Save (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Save(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.Save(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Save (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Save(System::String ^ path);" />
      <MemberSignature Language="F#" Value="member this.Save : string -&gt; unit" Usage="project.Save path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">项目源代码的路径。</param>
        <summary>将项目保存到文件系统（如果项目被标记为已更新，或者路径异常）。
使用默认编码。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Save">
      <MemberSignature Language="C#" Value="public void Save (System.Text.Encoding encoding);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Save(class System.Text.Encoding encoding) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.Save(System.Text.Encoding)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Save (encoding As Encoding)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Save(System::Text::Encoding ^ encoding);" />
      <MemberSignature Language="F#" Value="member this.Save : System.Text.Encoding -&gt; unit" Usage="project.Save encoding" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="encoding" Type="System.Text.Encoding" />
      </Parameters>
      <Docs>
        <param name="encoding">用于保存项目的字符编码。</param>
        <summary>将项目保存到文件系统（如果项目被标记为已更新）。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Save">
      <MemberSignature Language="C#" Value="public void Save (string path, System.Text.Encoding encoding);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Save(string path, class System.Text.Encoding encoding) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.Save(System.String,System.Text.Encoding)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Save (path As String, encoding As Encoding)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Save(System::String ^ path, System::Text::Encoding ^ encoding);" />
      <MemberSignature Language="F#" Value="member this.Save : string * System.Text.Encoding -&gt; unit" Usage="project.Save (path, encoding)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="encoding" Type="System.Text.Encoding" />
      </Parameters>
      <Docs>
        <param name="path">项目源代码的路径。</param>
        <param name="encoding">用于保存项目的字符编码。</param>
        <summary>将项目保存到文件系统（如果项目被标记为已更新，或者路径异常）。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SaveLogicalProject">
      <MemberSignature Language="C#" Value="public void SaveLogicalProject (System.IO.TextWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SaveLogicalProject(class System.IO.TextWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.SaveLogicalProject(System.IO.TextWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SaveLogicalProject (writer As TextWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SaveLogicalProject(System::IO::TextWriter ^ writer);" />
      <MemberSignature Language="F#" Value="member this.SaveLogicalProject : System.IO.TextWriter -&gt; unit" Usage="project.SaveLogicalProject writer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.IO.TextWriter" />
      </Parameters>
      <Docs>
        <param name="writer">用于保存项目文件的编写器。</param>
        <summary>保存“逻辑”或“预处理”项目文件，该文件包括所有导入的文件，就如同这些文件构成了单个文件一样。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetGlobalProperty">
      <MemberSignature Language="C#" Value="public bool SetGlobalProperty (string name, string escapedValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool SetGlobalProperty(string name, string escapedValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.SetGlobalProperty(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function SetGlobalProperty (name As String, escapedValue As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool SetGlobalProperty(System::String ^ name, System::String ^ escapedValue);" />
      <MemberSignature Language="F#" Value="member this.SetGlobalProperty : string * string -&gt; bool" Usage="project.SetGlobalProperty (name, escapedValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="escapedValue" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">要设置的全局属性的名称。</param>
        <param name="escapedValue">全局属性的新值。</param>
        <summary>在计算项目之后更改一个全局属性。
如果值发生更改，则会将项目标记为需要重新计算。
如果值发生更改，则返回 true，否则返回 False。</summary>
        <returns>如果值发生更改，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetProperty">
      <MemberSignature Language="C#" Value="public Microsoft.Build.Evaluation.ProjectProperty SetProperty (string name, string unevaluatedValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Microsoft.Build.Evaluation.ProjectProperty SetProperty(string name, string unevaluatedValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.SetProperty(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function SetProperty (name As String, unevaluatedValue As String) As ProjectProperty" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::Build::Evaluation::ProjectProperty ^ SetProperty(System::String ^ name, System::String ^ unevaluatedValue);" />
      <MemberSignature Language="F#" Value="member this.SetProperty : string * string -&gt; Microsoft.Build.Evaluation.ProjectProperty" Usage="project.SetProperty (name, unevaluatedValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Build.Evaluation.ProjectProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="unevaluatedValue" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">要设置的属性的名称。</param>
        <param name="unevaluatedValue">属性的新的未计算值。</param>
        <summary>设置或添加具有指定名称和值的属性。
如果集合中已存在同名的任何属性，但它不是源自于导入的文件，则覆盖该属性的值。
如果没有这样的现有属性，则使用以下启发式方法：更新最后一个具有指定名称的现有属性，该属性本身或其属性组（如果有的话）没有任何条件，并且位于此项目文件中，而不是位于导入的文件中。
否则，在不含条件的第一个属性组中添加一个新属性，如果需要，在现有的最后一个属性组后或在项目开头创建一个属性组。
返回属性集。
尽力计算：展开所有属性。 可以使用在新属性下的 XML 中定义的属性，尽管在实际计算中不会使用它们。
-仅会计算此属性。 其他依赖于其值的任何内容不受影响。
当然，这是一种很方便的方法，在重新计算之前，它不一定会使项目处于完全一致的状态。</summary>
        <returns>属性。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果没有具有给定名称的属性，将更新具有给定名称的最后一个现有属性，该属性对自身或其属性组没有任何条件，除非该属性源自于导入的文件。  
  
 否则，在不含条件的第一个属性组中添加一个新属性，如果需要，在现有的最后一个属性组后或在项目开头创建一个属性组。  
  
 评估会尽力进行。 使用新属性在项目源中定义的属性可用于计算。 仅计算此属性。 可能依赖于它的其他属性不受影响。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SkipEvaluation">
      <MemberSignature Language="C#" Value="public bool SkipEvaluation { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SkipEvaluation" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Build.Evaluation.Project.SkipEvaluation" />
      <MemberSignature Language="VB.NET" Value="Public Property SkipEvaluation As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool SkipEvaluation { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.SkipEvaluation : bool with get, set" Usage="Microsoft.Build.Evaluation.Project.SkipEvaluation" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="msbuild-16;msbuild-16-netcore">
          <AttributeName Language="C#">[get: System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="msbuild-16;msbuild-16-netcore">
          <AttributeName Language="C#">[set: System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;set: System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>是否临时禁用 ReevaluateIfNecessary。
当宿主希望对项目进行大量读写操作并希望临时牺牲准确性以换取性能，则可以使用此标志。</summary>
        <value>确定是否临时禁用 ReevaluateIfNecessary 的标志。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SubToolsetVersion">
      <MemberSignature Language="C#" Value="public string SubToolsetVersion { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string SubToolsetVersion" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Build.Evaluation.Project.SubToolsetVersion" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SubToolsetVersion As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ SubToolsetVersion { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SubToolsetVersion : string" Usage="Microsoft.Build.Evaluation.Project.SubToolsetVersion" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>与 ToolsVersion 结合使用的子工具集版本用于确定此项目的工具集属性。</summary>
        <value>SubToolsetVersion 属性值，如果该属性不存在，则为空字符串。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Targets">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IDictionary&lt;string,Microsoft.Build.Execution.ProjectTargetInstance&gt; Targets { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IDictionary`2&lt;string, class Microsoft.Build.Execution.ProjectTargetInstance&gt; Targets" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Build.Evaluation.Project.Targets" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Targets As IDictionary(Of String, ProjectTargetInstance)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::IDictionary&lt;System::String ^, Microsoft::Build::Execution::ProjectTargetInstance ^&gt; ^ Targets { System::Collections::Generic::IDictionary&lt;System::String ^, Microsoft::Build::Execution::ProjectTargetInstance ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Targets : System.Collections.Generic.IDictionary&lt;string, Microsoft.Build.Execution.ProjectTargetInstance&gt;" Usage="Microsoft.Build.Evaluation.Project.Targets" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="msbuild-15;msbuild-15-netcore;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[get: System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IDictionary&lt;System.String,Microsoft.Build.Execution.ProjectTargetInstance&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>项目中的目标。 字典的关键是目标的名称。
此集合中不包括重写的目标。
此集合为只读。</summary>
        <value>此项目中所有目标的只读字典，按目标名称进行键控。 此集合中不包括重写的目标。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ThrowInsteadOfSplittingItemElement">
      <MemberSignature Language="C#" Value="public bool ThrowInsteadOfSplittingItemElement { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ThrowInsteadOfSplittingItemElement" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Build.Evaluation.Project.ThrowInsteadOfSplittingItemElement" />
      <MemberSignature Language="VB.NET" Value="Public Property ThrowInsteadOfSplittingItemElement As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ThrowInsteadOfSplittingItemElement { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ThrowInsteadOfSplittingItemElement : bool with get, set" Usage="Microsoft.Build.Evaluation.Project.ThrowInsteadOfSplittingItemElement" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="msbuild-16;msbuild-16-netcore">
          <AttributeName Language="C#">[get: System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="msbuild-16;msbuild-16-netcore">
          <AttributeName Language="C#">[set: System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;set: System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>如果 include 包含 glob、对项或属性的引用或多个项值，则某些项操作会将项元素拆分为多个元素。
            
可以展开项元素的项操作是：- <see cref="M:Microsoft.Build.Evaluation.Project.RemoveItem(Microsoft.Build.Evaluation.ProjectItem)" />
             - <see cref="M:Microsoft.Build.Evaluation.Project.RemoveItems(System.Collections.Generic.IEnumerable{Microsoft.Build.Evaluation.ProjectItem})" />
             - <see cref="M:Microsoft.Build.Evaluation.Project.AddItem(System.String,System.String,System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{System.String,System.String}})" />
             - <see cref="M:Microsoft.Build.Evaluation.Project.AddItemFast(System.String,System.String,System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{System.String,System.String}})" />
             - <see cref="M:Microsoft.Build.Evaluation.ProjectItem.ChangeItemType(System.String)" />
             - <see cref="M:Microsoft.Build.Evaluation.ProjectItem.Rename(System.String)" />
             - <see cref="M:Microsoft.Build.Evaluation.ProjectItem.RemoveMetadata(System.String)" />
             - <see cref="M:Microsoft.Build.Evaluation.ProjectItem.SetMetadataValue(System.String,System.String)" />
             - <see cref="M:Microsoft.Build.Evaluation.ProjectItem.SetMetadataValue(System.String,System.String,System.Boolean)" />
             
如果将此属性设置为 true，则上一个项操作将引发 <exception cref="T:System.InvalidOperationException" /> 而不是展开项元素。</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToolsVersion">
      <MemberSignature Language="C#" Value="public string ToolsVersion { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ToolsVersion" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Build.Evaluation.Project.ToolsVersion" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ToolsVersion As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ToolsVersion { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ToolsVersion : string" Usage="Microsoft.Build.Evaluation.Project.ToolsVersion" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>计算此项目所使用的工具版本（如果有）。
不一定与 Project 标记上的工具版本相同（如果有）；它可能已在外部指定，例如使用 /tv 开关。
Project 标记上的实际工具版本可以从 <see cref="P:Microsoft.Build.Evaluation.Project.Xml">Xml.ToolsVersion</see> 获取。
项目一经创建，就不能更改。</summary>
        <value>计算此项目所用的工具版本（如果有）。</value>
        <remarks>按构造设置。</remarks>
      </Docs>
    </Member>
    <Member MemberName="Xml">
      <MemberSignature Language="C#" Value="public Microsoft.Build.Construction.ProjectRootElement Xml { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.Build.Construction.ProjectRootElement Xml" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Build.Evaluation.Project.Xml" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Xml As ProjectRootElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Microsoft::Build::Construction::ProjectRootElement ^ Xml { Microsoft::Build::Construction::ProjectRootElement ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Xml : Microsoft.Build.Construction.ProjectRootElement" Usage="Microsoft.Build.Evaluation.Project.Xml" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[get: System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Build.Construction.ProjectRootElement</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>支持的 XML 属性。
绝不能为 null</summary>
        <value>与此项目关联的根项目，不能为 <see langword="null" /> 。</value>
        <remarks>此处没有资源库，因为没有任何意义。 如果有新的 ProjectRootElement，请将其评估为新项目。</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
