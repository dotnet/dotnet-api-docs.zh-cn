<Type Name="ProjectMetadata" FullName="Microsoft.Build.Evaluation.ProjectMetadata">
  <Metadata><Meta Name="ms.openlocfilehash" Value="e7b4a6ddee9396923de8e05cdceb73cf543f2dc0" /><Meta Name="ms.sourcegitcommit" Value="c982ad9e10a242d90f1e631b5981570f9e5d9f34" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-CN" /><Meta Name="ms.lasthandoff" Value="09/10/2020" /><Meta Name="ms.locfileid" Value="89813084" /></Metadata><TypeSignature Language="C#" Value="public class ProjectMetadata : IEquatable&lt;Microsoft.Build.Evaluation.ProjectMetadata&gt;" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit ProjectMetadata extends System.Object implements class System.IEquatable`1&lt;class Microsoft.Build.Evaluation.ProjectMetadata&gt;" />
  <TypeSignature Language="DocId" Value="T:Microsoft.Build.Evaluation.ProjectMetadata" />
  <TypeSignature Language="VB.NET" Value="Public Class ProjectMetadata&#xA;Implements IEquatable(Of ProjectMetadata)" />
  <TypeSignature Language="C++ CLI" Value="public ref class ProjectMetadata : IEquatable&lt;Microsoft::Build::Evaluation::ProjectMetadata ^&gt;" />
  <TypeSignature Language="F#" Value="type ProjectMetadata = class&#xA;    interface IEquatable&lt;ProjectMetadata&gt;" />
  <AssemblyInfo>
    <AssemblyName>Microsoft.Build</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>15.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IEquatable&lt;Microsoft.Build.Evaluation.ProjectMetadata&gt;</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="msbuild-15;msbuild-15-netcore;msbuild-16;msbuild-16-netcore">
      <AttributeName Language="C#">[System.Diagnostics.DebuggerDisplay("{Name}={EvaluatedValue} [{_xml.Value}]")]</AttributeName>
      <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerDisplay("{Name}={EvaluatedValue} [{_xml.Value}]")&gt;]</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName Language="C#">[System.Diagnostics.DebuggerDisplay("{Name}={EvaluatedValue} [{xml.Value}]")]</AttributeName>
      <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerDisplay("{Name}={EvaluatedValue} [{xml.Value}]")&gt;]</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="f16ad-101">计算的设计时元数据。</span><span class="sxs-lookup"><span data-stu-id="f16ad-101">An evaluated design-time metadatum.</span></span>
<span data-ttu-id="f16ad-102">ProjectItemDefinition 或 ProjectItem 的父级。</span><span class="sxs-lookup"><span data-stu-id="f16ad-102">Parented either by a ProjectItemDefinition or a ProjectItem.</span></span></summary>
    <remarks><span data-ttu-id="f16ad-103">从不用于表示内置元数据，如% (Filename) 。</span><span class="sxs-lookup"><span data-stu-id="f16ad-103">Never used to represent built-in metadata, like %(Filename).</span></span> <span data-ttu-id="f16ad-104">始终存在一个支持 XML 对象。</span><span class="sxs-lookup"><span data-stu-id="f16ad-104">There is always a backing XML object.</span></span></remarks>
  </Docs>
  <Members>
    <Member MemberName="ConditionLocation">
      <MemberSignature Language="C#" Value="public Microsoft.Build.Construction.ElementLocation ConditionLocation { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.Build.Construction.ElementLocation ConditionLocation" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Build.Evaluation.ProjectMetadata.ConditionLocation" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ConditionLocation As ElementLocation" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Microsoft::Build::Construction::ElementLocation ^ ConditionLocation { Microsoft::Build::Construction::ElementLocation ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ConditionLocation : Microsoft.Build.Construction.ElementLocation" Usage="Microsoft.Build.Evaluation.ProjectMetadata.ConditionLocation" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Build.Construction.ElementLocation</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f16ad-105">Condition 属性的位置</span><span class="sxs-lookup"><span data-stu-id="f16ad-105">Location of the condition attribute</span></span></summary>
        <value><span data-ttu-id="f16ad-106">返回条件特性位置。</span><span class="sxs-lookup"><span data-stu-id="f16ad-106">Returns Condition attribute location.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EvaluatedValue">
      <MemberSignature Language="C#" Value="public string EvaluatedValue { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string EvaluatedValue" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Build.Evaluation.ProjectMetadata.EvaluatedValue" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property EvaluatedValue As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ EvaluatedValue { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.EvaluatedValue : string" Usage="Microsoft.Build.Evaluation.ProjectMetadata.EvaluatedValue" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[get: System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f16ad-107">获取计算的元数据值。</span><span class="sxs-lookup"><span data-stu-id="f16ad-107">Gets the evaluated metadata value.</span></span>
<span data-ttu-id="f16ad-108">不能直接设置：只能设置未计算的值。</span><span class="sxs-lookup"><span data-stu-id="f16ad-108">Cannot be set directly: only the unevaluated value can be set.</span></span>
<span data-ttu-id="f16ad-109">决不会为 null。</span><span class="sxs-lookup"><span data-stu-id="f16ad-109">Is never null.</span></span></summary>
        <value><span data-ttu-id="f16ad-110">计算的元数据值，该值从不 <see langword="null" /> 。</span><span class="sxs-lookup"><span data-stu-id="f16ad-110">The evaluated metadata value, which is never <see langword="null" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f16ad-111">不能直接设置：只能设置未计算的值。</span><span class="sxs-lookup"><span data-stu-id="f16ad-111">Cannot be set directly: only the unevaluated value can be set.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsImported">
      <MemberSignature Language="C#" Value="public bool IsImported { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsImported" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Build.Evaluation.ProjectMetadata.IsImported" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsImported As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsImported { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsImported : bool" Usage="Microsoft.Build.Evaluation.ProjectMetadata.IsImported" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f16ad-112">如果元值源自一个导入的文件，则返回 true。</span><span class="sxs-lookup"><span data-stu-id="f16ad-112">If the metadatum originated in an imported file, returns true.</span></span>
<span data-ttu-id="f16ad-113">否则，返回 False。</span><span class="sxs-lookup"><span data-stu-id="f16ad-113">Otherwise returns false.</span></span></summary>
        <value><span data-ttu-id="f16ad-114"><see langword="true" /> 如果元数据源自于导入的文件，则为;否则为 <see langword="false" /> 。</span><span class="sxs-lookup"><span data-stu-id="f16ad-114"><see langword="true" /> if the metadata originated from an imported file; otherwise, <see langword="false" />.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ItemType">
      <MemberSignature Language="C#" Value="public string ItemType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ItemType" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Build.Evaluation.ProjectMetadata.ItemType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ItemType As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ItemType { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ItemType : string" Usage="Microsoft.Build.Evaluation.ProjectMetadata.ItemType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f16ad-115">父项定义或项的项目类型。</span><span class="sxs-lookup"><span data-stu-id="f16ad-115">The item type of the parent item definition or item.</span></span></summary>
        <value><span data-ttu-id="f16ad-116">包含项定义或项的项类型。</span><span class="sxs-lookup"><span data-stu-id="f16ad-116">The item type of the containing item definition or item.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Location">
      <MemberSignature Language="C#" Value="public Microsoft.Build.Construction.ElementLocation Location { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.Build.Construction.ElementLocation Location" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Build.Evaluation.ProjectMetadata.Location" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Location As ElementLocation" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Microsoft::Build::Construction::ElementLocation ^ Location { Microsoft::Build::Construction::ElementLocation ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Location : Microsoft.Build.Construction.ElementLocation" Usage="Microsoft.Build.Evaluation.ProjectMetadata.Location" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Build.Construction.ElementLocation</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f16ad-117">元素的位置</span><span class="sxs-lookup"><span data-stu-id="f16ad-117">Location of the element</span></span></summary>
        <value><span data-ttu-id="f16ad-118">元素位置。</span><span class="sxs-lookup"><span data-stu-id="f16ad-118">The element location.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Build.Evaluation.ProjectMetadata.Name" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Name { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Name : string" Usage="Microsoft.Build.Evaluation.ProjectMetadata.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[get: System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f16ad-119">元数据的名称</span><span class="sxs-lookup"><span data-stu-id="f16ad-119">Name of the metadata</span></span></summary>
        <value><span data-ttu-id="f16ad-120">元数据的名称。</span><span class="sxs-lookup"><span data-stu-id="f16ad-120">The name of the metadata.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Predecessor">
      <MemberSignature Language="C#" Value="public Microsoft.Build.Evaluation.ProjectMetadata Predecessor { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.Build.Evaluation.ProjectMetadata Predecessor" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Build.Evaluation.ProjectMetadata.Predecessor" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Predecessor As ProjectMetadata" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Microsoft::Build::Evaluation::ProjectMetadata ^ Predecessor { Microsoft::Build::Evaluation::ProjectMetadata ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Predecessor : Microsoft.Build.Evaluation.ProjectMetadata" Usage="Microsoft.Build.Evaluation.ProjectMetadata.Predecessor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[get: System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Build.Evaluation.ProjectMetadata</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f16ad-121">在计算期间由此元数据重写的（项定义或项中的）任何上一个元数据。</span><span class="sxs-lookup"><span data-stu-id="f16ad-121">Any immediately previous metadatum (from item definition or item) that was overridden by this one during evaluation.</span></span>
<span data-ttu-id="f16ad-122">这将包括在逻辑项目文件上具有相同名称的所有元数据，这些元数据属于同一类型的项定义，其条件计算结果为 true。</span><span class="sxs-lookup"><span data-stu-id="f16ad-122">This would include all metadata with the same name that lie above in the logical project file, who are on item definitions of the same type, and whose conditions evaluated to true.</span></span>
<span data-ttu-id="f16ad-123">如果对某一项使用了此元数据，则会在其条件计算结果为 true 的同一项上包含具有相同名称的任何以前的元数据，后跟任何项定义元数据。</span><span class="sxs-lookup"><span data-stu-id="f16ad-123">If this metadatum is on an item, it would include any previous metadatum with the same name on the same item whose condition evaluated to true, and following that any item definition metadata.</span></span>
<span data-ttu-id="f16ad-124">如果上面没有任何值，则为 null。</span><span class="sxs-lookup"><span data-stu-id="f16ad-124">If there are none above this is null.</span></span>
<span data-ttu-id="f16ad-125">如果自上次修改后未重新计算项目，则此值可能不正确。</span><span class="sxs-lookup"><span data-stu-id="f16ad-125">If the project has not been reevaluated since the last modification this value may be incorrect.</span></span></summary>
        <value><span data-ttu-id="f16ad-126">) 项定义或项中的最后一个元数据 (，其值在计算期间由此元数据重写，或 <see langword="null" /> 未重写元数据。</span><span class="sxs-lookup"><span data-stu-id="f16ad-126">The last metadata (from an item definition or item) whose value was overridden by this metadata during evaluation, or <see langword="null" /> if the metadata has not been overridden.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f16ad-127">此方法搜索逻辑项目文件中所有具有相同名称的元数据，这些元数据包含在相同项类型的项定义中，并且其条件的计算结果为 true。</span><span class="sxs-lookup"><span data-stu-id="f16ad-127">This method searches for all metadata with the same name that lie above in the logical project file, and which are contained by item definitions of the same item type, and whose conditions evaluate to true.</span></span> <span data-ttu-id="f16ad-128">如果某个项包含元数据，则此方法将搜索其条件计算结果为 true 的所有以前的元数据。</span><span class="sxs-lookup"><span data-stu-id="f16ad-128">If the metadata is contained by an item, this method searches for any previous metadata with the same name and item whose condition evaluated to true.</span></span> <span data-ttu-id="f16ad-129">在项之前搜索项定义。</span><span class="sxs-lookup"><span data-stu-id="f16ad-129">Item definitions are searched before items.</span></span>  
  
 <span data-ttu-id="f16ad-130">如果自上次修改后项目尚未重新评估，则此值可能不正确。</span><span class="sxs-lookup"><span data-stu-id="f16ad-130">If the project has not been reevaluated since the last modification, this value may be incorrect.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Project">
      <MemberSignature Language="C#" Value="public Microsoft.Build.Evaluation.Project Project { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.Build.Evaluation.Project Project" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Build.Evaluation.ProjectMetadata.Project" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Project As Project" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Microsoft::Build::Evaluation::Project ^ Project { Microsoft::Build::Evaluation::Project ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Project : Microsoft.Build.Evaluation.Project" Usage="Microsoft.Build.Evaluation.ProjectMetadata.Project" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[get: System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Build.Evaluation.Project</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f16ad-131">此元类型所在的项目。</span><span class="sxs-lookup"><span data-stu-id="f16ad-131">Project that this metadatum lives in.</span></span>
<span data-ttu-id="f16ad-132">ProjectMetadata 始终位于项目中。</span><span class="sxs-lookup"><span data-stu-id="f16ad-132">ProjectMetadata's always live in a project.</span></span></summary>
        <value><span data-ttu-id="f16ad-133">包含此元数据的项目，该项目永远不会 <see langword="null" /> 。</span><span class="sxs-lookup"><span data-stu-id="f16ad-133">The project that contains this metadata, which is never <see langword="null" />.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IEquatable&lt;Microsoft.Build.Evaluation.ProjectMetadata&gt;.Equals">
      <MemberSignature Language="C#" Value="bool IEquatable&lt;ProjectMetadata&gt;.Equals (Microsoft.Build.Evaluation.ProjectMetadata other);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.IEquatable&lt;Microsoft.Build.Evaluation.ProjectMetadata&gt;.Equals(class Microsoft.Build.Evaluation.ProjectMetadata other) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.ProjectMetadata.System#IEquatable&lt;Microsoft#Build#Evaluation#ProjectMetadata&gt;#Equals(Microsoft.Build.Evaluation.ProjectMetadata)" />
      <MemberSignature Language="VB.NET" Value="Function Equals (other As ProjectMetadata) As Boolean Implements IEquatable(Of ProjectMetadata).Equals" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.IEquatable&lt;Microsoft.Build.Evaluation.ProjectMetadata&gt;.Equals(Microsoft::Build::Evaluation::ProjectMetadata ^ other) = IEquatable&lt;Microsoft::Build::Evaluation::ProjectMetadata ^&gt;::Equals;" />
      <MemberSignature Language="F#" Value="abstract member System.IEquatable&lt;Microsoft.Build.Evaluation.ProjectMetadata&gt;.Equals : Microsoft.Build.Evaluation.ProjectMetadata -&gt; bool&#xA;override this.System.IEquatable&lt;Microsoft.Build.Evaluation.ProjectMetadata&gt;.Equals : Microsoft.Build.Evaluation.ProjectMetadata -&gt; bool" Usage="projectMetadata.System.IEquatable&lt;Microsoft.Build.Evaluation.ProjectMetadata&gt;.Equals other" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IEquatable`1.Equals(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="Microsoft.Build.Evaluation.ProjectMetadata" />
      </Parameters>
      <Docs>
        <param name="other"><span data-ttu-id="f16ad-134">另一个元数据</span><span class="sxs-lookup"><span data-stu-id="f16ad-134">The other metadata</span></span></param>
        <summary><span data-ttu-id="f16ad-135">将此元数据与另一个元数据进行比较，确定是否相等。</span><span class="sxs-lookup"><span data-stu-id="f16ad-135">Compares this metadata to another for equivalence.</span></span></summary>
        <returns><span data-ttu-id="f16ad-136">如果相等，则为 True，否则为 false。</span><span class="sxs-lookup"><span data-stu-id="f16ad-136">True if they are equivalent, false otherwise.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UnevaluatedValue">
      <MemberSignature Language="C#" Value="public string UnevaluatedValue { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string UnevaluatedValue" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Build.Evaluation.ProjectMetadata.UnevaluatedValue" />
      <MemberSignature Language="VB.NET" Value="Public Property UnevaluatedValue As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ UnevaluatedValue { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.UnevaluatedValue : string with get, set" Usage="Microsoft.Build.Evaluation.ProjectMetadata.UnevaluatedValue" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[get: System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[set: System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;set: System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f16ad-137">获取或设置未计算的元数据值。</span><span class="sxs-lookup"><span data-stu-id="f16ad-137">Gets or sets the unevaluated metadata value.</span></span>
            
<span data-ttu-id="f16ad-138">除了更新未计算的值，资源库还更新已计算的值，但在重新计算之前不会影响项目中的任何其他内容。</span><span class="sxs-lookup"><span data-stu-id="f16ad-138">As well as updating the unevaluated value, the setter updates the evaluated value, but does not affect anything else in the project until reevaluation.</span></span> <span data-ttu-id="f16ad-139">例如，如果对“i”类型的项修改了名为“m”的元数据，则在重新评估之前，它不会影响从“@(j-&gt;'%(m)')”计算出的“j”。</span><span class="sxs-lookup"><span data-stu-id="f16ad-139">For example, --if a piece of metadata named "m" is modified on item of type "i", it does not affect "j" which is evaluated from "@(j-&gt;'%(m)')" until reevaluation.</span></span>
<span data-ttu-id="f16ad-140">如果将“m”的未计算值设置为通过计算修改的内容（如“$(p)”），则在重新评估之前，计算的值将设置为“$(p)”。</span><span class="sxs-lookup"><span data-stu-id="f16ad-140">--if the unevaluated value of "m" is set to something that is modified by evaluation, such as "$(p)", the evaluated value will be set to "$(p)" until reevaluation.</span></span>
<span data-ttu-id="f16ad-141">当然，这是一种很方便的方法，它不一定会使项目处于完全一致的状态。</span><span class="sxs-lookup"><span data-stu-id="f16ad-141">This is a convenience that it is understood does not necessarily leave the project in a perfectly self consistent state.</span></span>
            
<span data-ttu-id="f16ad-142">如果基础 ProjectItemElement 源自项目列表、通配符或分号表达式，则通过 ProjectItem 设置元数据可能会导致基础 ProjectItem 被拆分，因为很明显，调用方只打算影响那个特定的项。</span><span class="sxs-lookup"><span data-stu-id="f16ad-142">Setting metadata through a ProjectItem may cause the underlying ProjectItemElement to be split, if it originated with an itemlist, wildcard, or semicolon expression, because it was clear that the caller intended to only affect that particular item.</span></span>
<span data-ttu-id="f16ad-143">通过 ProjectMetadata 设置元数据不会导致任何拆分，因为我们假定调用方大致预期会影响使用基础 ProjectMetadataElement 的所有项。</span><span class="sxs-lookup"><span data-stu-id="f16ad-143">Setting metadata through a ProjectMetadata does not cause any splitting, because we assume the caller presumably intends to affect all items using the underlying ProjectMetadataElement.</span></span> <span data-ttu-id="f16ad-144">至少这看起来是一个合理的假设，它不需要元数据保存指向其包含项的指针。</span><span class="sxs-lookup"><span data-stu-id="f16ad-144">At least, this seems a reasonable assumption, and it avoids the need for metadata to hold a pointer to their containing items.</span></span></summary>
        <value><span data-ttu-id="f16ad-145">未计算的元数据值。</span><span class="sxs-lookup"><span data-stu-id="f16ad-145">The unevaluated metadata value.</span></span></value>
        <remarks><span data-ttu-id="f16ad-146">将由 XML 修改更新包含项目。</span><span class="sxs-lookup"><span data-stu-id="f16ad-146">The containing project will be dirtied by the XML modification.</span></span>  <span data-ttu-id="f16ad-147">未计算的值假设在必要时传入转义。</span><span class="sxs-lookup"><span data-stu-id="f16ad-147">Unevaluated values are assumed to be passed in escaped as necessary.</span></span></remarks>
      </Docs>
    </Member>
    <Member MemberName="Xml">
      <MemberSignature Language="C#" Value="public Microsoft.Build.Construction.ProjectMetadataElement Xml { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.Build.Construction.ProjectMetadataElement Xml" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Build.Evaluation.ProjectMetadata.Xml" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Xml As ProjectMetadataElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Microsoft::Build::Construction::ProjectMetadataElement ^ Xml { Microsoft::Build::Construction::ProjectMetadataElement ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Xml : Microsoft.Build.Construction.ProjectMetadataElement" Usage="Microsoft.Build.Evaluation.ProjectMetadata.Xml" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[get: System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Build.Construction.ProjectMetadataElement</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f16ad-148">支持 XML 元数据。</span><span class="sxs-lookup"><span data-stu-id="f16ad-148">Backing XML metadata.</span></span>
<span data-ttu-id="f16ad-149">决不能为 null。</span><span class="sxs-lookup"><span data-stu-id="f16ad-149">Can never be null.</span></span></summary>
        <value><span data-ttu-id="f16ad-150">关联的项目元数据元素，该元素永远不能为 <see langword="null" /> 。</span><span class="sxs-lookup"><span data-stu-id="f16ad-150">The associated project metadata element, which can never be <see langword="null" />.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
