<Type Name="FaultContractAttribute" FullName="System.ServiceModel.FaultContractAttribute">
  <Metadata><Meta Name="ms.openlocfilehash" Value="a0136f5b4659456233a2454eae21e99a58be7502" /><Meta Name="ms.sourcegitcommit" Value="b6b9d5f3f9c7eb43f14a8a1a68d044603cb8ed73" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-CN" /><Meta Name="ms.lasthandoff" Value="05/18/2020" /><Meta Name="ms.locfileid" Value="83530445" /></Metadata><TypeSignature Language="C#" Value="public sealed class FaultContractAttribute : Attribute" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit FaultContractAttribute extends System.Attribute" />
  <TypeSignature Language="DocId" Value="T:System.ServiceModel.FaultContractAttribute" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class FaultContractAttribute&#xA;Inherits Attribute" />
  <TypeSignature Language="C++ CLI" Value="public ref class FaultContractAttribute sealed : Attribute" />
  <TypeSignature Language="F#" Value="type FaultContractAttribute = class&#xA;    inherit Attribute" />
  <AssemblyInfo>
    <AssemblyName>System.ServiceModel</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.5.0.1</AssemblyVersion>
    <AssemblyVersion>4.5.0.3</AssemblyVersion>
    <AssemblyVersion>4.6.0.0</AssemblyVersion>
    <AssemblyVersion>4.7.0.0</AssemblyVersion>
    <AssemblyVersion>5.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeForwardingChain>
    <TypeForwarding From="System.ServiceModel" FromVersion="4.0.0.0" To="System.ServiceModel.Primitives" ToVersion="4.6.0.0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0" />
    <TypeForwarding From="System.ServiceModel" FromVersion="4.0.0.0" To="System.ServiceModel.Primitives" ToVersion="4.7.0.0" FrameworkAlternate="dotnet-plat-ext-3.1" />
    <TypeForwarding From="System.ServiceModel" FromVersion="4.0.0.0" To="System.ServiceModel.Primitives" ToVersion="0.0.0.0" FrameworkAlternate="dotnet-uwp-10.0" />
  </TypeForwardingChain>
  <Base>
    <BaseTypeName>System.Attribute</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-uwp-10.0;dotnet-plat-ext-3.0;dotnet-plat-ext-3.1;dotnet-plat-ext-5.0">
      <AttributeName>System.AttributeUsage(System.AttributeTargets.Method, AllowMultiple=true, Inherited=false)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>指定服务操作遇到处理错误时返回的一个或多个 SOAP 错误。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用 <xref:System.ServiceModel.FaultContractAttribute> 特性标记操作，以声明一个或多个特定的异常条件，这些条件已添加到服务操作的 Web 服务描述语言（WSDL）说明，作为操作返回的显式 SOAP 错误消息。  
  
 在所有托管应用程序中，处理错误由 <xref:System.Exception> 对象表示。 在基于 SOAP 的应用程序（例如 Windows Communication Foundation （WCF）应用程序）中，服务方法使用 SOAP 错误消息来传递处理错误信息。 因为 WCF 应用程序在这两种类型的错误系统下执行，所以必须发送到客户端的任何托管异常信息都必须从异常转换为 SOAP 错误。 您可以使用默认的服务异常行为，或者可以显式控制异常是否能被映射到错误消息，以及如何映射到错误消息。 有关 WCF 应用程序中异常和 SOAP 错误的概述，请参阅[在协定和服务中指定和处理错误](~/docs/framework/wcf/specifying-and-handling-faults-in-contracts-and-services.md)。  
  
 建议服务操作使用 <xref:System.ServiceModel.FaultContractAttribute> 来正式指定在正常操作过程中客户端可能期望接收的所有 SOAP 错误。 此外，还建议在 SOAP 错误中仅返回客户端必须了解的信息，以将信息泄露风险降至最低。  
  
-   <xref:System.ServiceModel.FaultContractAttribute.Action%2A> 属性控制错误消息的操作。  
  
-   <xref:System.ServiceModel.FaultContractAttribute.DetailType%2A> 属性获取在错误消息中序列化的详细信息对象的类型。  
  
-   <xref:System.ServiceModel.FaultContractAttribute.Name%2A> 和 <xref:System.ServiceModel.FaultContractAttribute.Namespace%2A> 属性分别控制错误消息的名称和命名空间。  
  
-   <xref:System.ServiceModel.FaultContractAttribute.HasProtectionLevel%2A> 指示错误消息是否指定了保护级别，如果是，则 <xref:System.ServiceModel.FaultContractAttribute.ProtectionLevel%2A> 属性控制该级别的保护。  
  
> [!CAUTION]
>  如果错误消息携带敏感信息或可能导致安全问题，则强烈建议设置 <xref:System.ServiceModel.FaultContractAttribute.ProtectionLevel%2A> 属性。  
  
-   如果将 <xref:System.ServiceModel.FaultContractAttribute.ProtectionLevel%2A> 显式设置为 <xref:System.Net.Security.ProtectionLevel.Sign?displayProperty=nameWithType> 或 <xref:System.Net.Security.ProtectionLevel.EncryptAndSign?displayProperty=nameWithType>，则必须在绑定上使用已 <xref:System.ServiceModel.SecurityMode?displayProperty=nameWithType> 启用安全的绑定，否则将引发异常。  
  
-   如果你选择启用安全的绑定，并且未在协定的任何位置设置 <xref:System.ServiceModel.FaultContractAttribute.ProtectionLevel%2A> 属性，则将对所有的应用程序数据进行加密或签名。  
  
-   如果你选择未启用安全的绑定（例如，默认情况下 <xref:System.ServiceModel.BasicHttpBinding?displayProperty=nameWithType> 禁用安全），并且没有显式设置 <xref:System.ServiceModel.FaultContractAttribute.ProtectionLevel%2A>，则所有应用程序数据都不会受到保护。  
  
 在许多情况下，将 <xref:System.ServiceModel.FaultContractAttribute.ProtectionLevel%2A> 设置为 <xref:System.Net.Security.ProtectionLevel.EncryptAndSign> 错误消息就足够了。 有关更多详细信息，请参阅[了解保护级别](~/docs/framework/wcf/understanding-protection-level.md)。  
  
 若要从标记为 <xref:System.ServiceModel.FaultContractAttribute>的操作返回指定错误，请在操作过程中发生托管异常时引发 <xref:System.ServiceModel.FaultException%601> （其中，类型参数是可序列化的错误信息）。 WCF 客户端应用程序将 SOAP 错误与客户端实现中引发的类型相同，即，作为 <xref:System.ServiceModel.FaultException%601> （其中 typeparameter 是可序列化的错误信息）。 <xref:System.ServiceModel.FaultContractAttribute> 仅可用于为双向服务操作和异步操作对指定 SOAP 错误;单向操作不支持 SOAP 错误，因此不支持 <xref:System.ServiceModel.FaultContractAttribute>。  
  
> [!NOTE]
>  您可以使用任意可序列化的类型来传达错误信息。 在此版本的 WCF 中，唯一的限制是 <xref:System.ServiceModel.FaultContractAttribute> 中指定的类型必须可由 <xref:System.Runtime.Serialization.DataContractSerializer?displayProperty=nameWithType>序列化。 有关 <xref:System.Runtime.Serialization.DataContractSerializer> 提供的序列化支持，请参阅[数据协定序列化程序](~/docs/framework/wcf/feature-details/data-contract-serializer.md)。  
  
 例如，若要指定客户端可能需要包含 <xref:System.Int32>的 SOAP 错误，请将该类型参数置于服务方法的 <xref:System.ServiceModel.FaultContractAttribute> 中。  
  
> [!NOTE]
>  下面的代码示例不设置 <xref:System.ServiceModel.FaultContractAttribute.ProtectionLevel%2A>、<xref:System.ServiceModel.FaultContractAttribute.Name%2A>或 <xref:System.ServiceModel.FaultContractAttribute.Namespace%2A> 属性。  
  
 [!code-csharp[C_FCA#1](~/samples/snippets/csharp/VS_Snippets_CFX/c_fca/cs/fcademo.cs#1)]
 [!code-vb[C_FCA#1](~/samples/snippets/visualbasic/VS_Snippets_CFX/c_fca/vb/fcademo.vb#1)]  
  
 然后，在服务方法中引发新 <xref:System.ServiceModel.FaultException%601>，其中类型参数是包含错误信息的类型（在上面的示例中，<xref:System.Int32>）。 例如：  
  
 [!code-csharp[C_FCA#2](~/samples/snippets/csharp/VS_Snippets_CFX/c_fca/cs/fcademo.cs#2)]
 [!code-vb[C_FCA#2](~/samples/snippets/visualbasic/VS_Snippets_CFX/c_fca/vb/fcademo.vb#2)]  
  
 前面的示例是非常基本的;几乎所有信息都可以使用 <xref:System.Int32?displayProperty=nameWithType> 代码传递，因此此详细信息类型不是最有用的。 通常，WCF 应用程序会指定 SOAP 错误，其中包含特定于客户端错误信息的详细信息类型。 有关更多的完整示例，请参见“示例”部分。  
  
> [!NOTE]
>  如果指定了类型参数为 <xref:System.String?displayProperty=nameWithType>的 <xref:System.ServiceModel.FaultException%601>，则字符串值将分配给客户端应用程序中的 Detail 属性;客户端无法通过调用 <xref:System.ServiceModel.FaultException%601.ToString%2A?displayProperty=nameWithType> 方法来检索该字符串。 若要在客户端应用程序调用 <xref:System.Exception.ToString%2A?displayProperty=nameWithType> 时返回该字符串值，则将在操作内引发 <xref:System.ServiceModel.FaultException?displayProperty=nameWithType> 异常，并将该字符串传递给构造函数。  
  
 若要在引发异常或 <xref:System.ServiceModel.FaultException%601> 时显式控制应用程序的行为，请在 <xref:System.ServiceModel.Description.IServiceBehavior?displayProperty=nameWithType>、<xref:System.ServiceModel.Description.IContractBehavior?displayProperty=nameWithType> 或 <xref:System.ServiceModel.Description.IEndpointBehavior?displayProperty=nameWithType> 上实现 <xref:System.ServiceModel.Dispatcher.IErrorHandler?displayProperty=nameWithType> 接口，并将其分配给 <xref:System.ServiceModel.Dispatcher.ChannelDispatcher.ErrorHandlers%2A?displayProperty=nameWithType> 属性。 <xref:System.ServiceModel.Dispatcher.IErrorHandler> 使你可以显式控制生成的 SOAP 错误，以及是否将其发送回客户端。  
  
 若要简化调试，请将 <xref:System.ServiceModel.ServiceBehaviorAttribute.IncludeExceptionDetailInFaults%2A?displayProperty=nameWithType> 设置为在代码中 `true`，或者可以使用应用程序配置文件中的 <xref:System.ServiceModel.Description.ServiceDebugBehavior.IncludeExceptionDetailInFaults%2A?displayProperty=nameWithType>。 当启用时，服务会自动将异常信息返回到调用方。 这些错误作为 <xref:System.ServiceModel.FaultException> 异常出现在客户端上。  
  
> [!IMPORTANT]
>  由于托管异常可以公开内部应用程序信息，因此将 <xref:System.ServiceModel.ServiceBehaviorAttribute.IncludeExceptionDetailInFaults%2A?displayProperty=nameWithType> 或 <xref:System.ServiceModel.Description.ServiceDebugBehavior.IncludeExceptionDetailInFaults%2A?displayProperty=nameWithType> 设置为 `true` 可允许 WCF 客户端获取有关内部服务操作异常的信息，包括个人身份信息或其他敏感信息。  
>   
>  因此，仅建议将 <xref:System.ServiceModel.ServiceBehaviorAttribute.IncludeExceptionDetailInFaults%2A?displayProperty=nameWithType> 或 <xref:System.ServiceModel.Description.ServiceDebugBehavior.IncludeExceptionDetailInFaults%2A?displayProperty=nameWithType> 设置为 `true` 作为一种临时调试服务应用程序的方法。 此外，以这种方式返回未处理的托管异常的方法的 WSDL 并不包含类型为 <xref:System.ServiceModel.FaultException%601> 的 <xref:System.String> 的协定。 客户端必须预期发生未知 SOAP 错误（返回给 WCF 客户端作为 <xref:System.ServiceModel.FaultException?displayProperty=nameWithType> 对象）才能正确获取调试信息。  
  
   
  
## Examples  
 下面的代码示例演示如何使用 <xref:System.ServiceModel.FaultContractAttribute> 来指定 `SampleMethod` 操作可以使用详细信息类型 `GreetingFault` 返回 SOAP 错误。  
  
 [!code-csharp[FaultContractAttribute#1](~/samples/snippets/csharp/VS_Snippets_CFX/faultcontractattribute/cs/services.cs#1)]
 [!code-vb[FaultContractAttribute#1](~/samples/snippets/visualbasic/VS_Snippets_CFX/faultcontractattribute/vb/services.vb#1)]  
  
 下面的代码示例演示 `ISampleService` 的 WCF 客户端将此 SOAP 错误作为 `GreetingFault`类型的 <xref:System.ServiceModel.FaultException%601>。  
  
 [!code-csharp[FaultContractAttribute#3](~/samples/snippets/csharp/VS_Snippets_CFX/faultcontractattribute/cs/client.cs#3)]
 [!code-vb[FaultContractAttribute#3](~/samples/snippets/visualbasic/VS_Snippets_CFX/faultcontractattribute/vb/client.vb#3)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FaultContractAttribute (Type detailType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Type detailType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.FaultContractAttribute.#ctor(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (detailType As Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FaultContractAttribute(Type ^ detailType);" />
      <MemberSignature Language="F#" Value="new System.ServiceModel.FaultContractAttribute : Type -&gt; System.ServiceModel.FaultContractAttribute" Usage="new System.ServiceModel.FaultContractAttribute detailType" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.5.0.1</AssemblyVersion>
        <AssemblyVersion>4.5.0.3</AssemblyVersion>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.7.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="detailType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="detailType">包含调用方错误信息的可序列化类型。</param>
        <summary>初始化 <see cref="T:System.ServiceModel.FaultContractAttribute" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 通常通过将属性应用到服务方法并指定一个类型作为该属性中的自变量来执行构造函数。  
  
   
  
## Examples  
 下面的代码示例演示如何使用 <xref:System.ServiceModel.FaultContractAttribute> 来指定 `SampleMethod` 操作可以使用详细信息类型 `GreetingFault` 返回 SOAP 错误。  
  
 [!code-csharp[FaultContractAttribute#1](~/samples/snippets/csharp/VS_Snippets_CFX/faultcontractattribute/cs/services.cs#1)]
 [!code-vb[FaultContractAttribute#1](~/samples/snippets/visualbasic/VS_Snippets_CFX/faultcontractattribute/vb/services.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="detailType" /> 参数为 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="Action">
      <MemberSignature Language="C#" Value="public string Action { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Action" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.FaultContractAttribute.Action" />
      <MemberSignature Language="VB.NET" Value="Public Property Action As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Action { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Action : string with get, set" Usage="System.ServiceModel.FaultContractAttribute.Action" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.5.0.1</AssemblyVersion>
        <AssemblyVersion>4.5.0.3</AssemblyVersion>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.7.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置已指定作为操作协定一部分的 SOAP 错误消息的操作。</summary>
        <value>SOAP 错误消息的操作值。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 用于控制 SOAP 错误消息的操作。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DetailType">
      <MemberSignature Language="C#" Value="public Type DetailType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type DetailType" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.FaultContractAttribute.DetailType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DetailType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Type ^ DetailType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DetailType : Type" Usage="System.ServiceModel.FaultContractAttribute.DetailType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.5.0.1</AssemblyVersion>
        <AssemblyVersion>4.5.0.3</AssemblyVersion>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.7.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取包含错误信息的可序列化对象的类型。</summary>
        <value>表示可序列化错误类的类型。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下面的代码示例演示如何使用 <xref:System.ServiceModel.FaultContractAttribute> 来指定 `SampleMethod` 操作可以使用详细信息类型 `GreetingFault` 返回 SOAP 错误。  
  
 [!code-csharp[FaultContractAttribute#1](~/samples/snippets/csharp/VS_Snippets_CFX/faultcontractattribute/cs/services.cs#1)]
 [!code-vb[FaultContractAttribute#1](~/samples/snippets/visualbasic/VS_Snippets_CFX/faultcontractattribute/vb/services.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HasProtectionLevel">
      <MemberSignature Language="C#" Value="public bool HasProtectionLevel { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasProtectionLevel" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.FaultContractAttribute.HasProtectionLevel" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HasProtectionLevel As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HasProtectionLevel { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HasProtectionLevel : bool" Usage="System.ServiceModel.FaultContractAttribute.HasProtectionLevel" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示 SOAP 错误消息是否分配有保护级别。</summary>
        <value>如果错误消息具有保护级别，则为 <see langword="true" />；否则为 <see langword="false" />。 默认为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用 <xref:System.ServiceModel.FaultContractAttribute.HasProtectionLevel%2A> 属性指定是否必须对 SOAP 错误消息进行加密和/或签名。 有关详细信息，请参阅 <xref:System.ServiceModel.FaultContractAttribute.ProtectionLevel%2A> 属性。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.FaultContractAttribute.Name" />
      <MemberSignature Language="VB.NET" Value="Public Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Name { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Name : string with get, set" Usage="System.ServiceModel.FaultContractAttribute.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.5.0.1</AssemblyVersion>
        <AssemblyVersion>4.5.0.3</AssemblyVersion>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.7.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置 Web 服务描述语言 (WSDL) 中的错误消息的名称。</summary>
        <value>错误消息名称。 默认名称是用作错误详细信息类型的名称。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Namespace">
      <MemberSignature Language="C#" Value="public string Namespace { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Namespace" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.FaultContractAttribute.Namespace" />
      <MemberSignature Language="VB.NET" Value="Public Property Namespace As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Namespace { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Namespace : string with get, set" Usage="System.ServiceModel.FaultContractAttribute.Namespace" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.5.0.1</AssemblyVersion>
        <AssemblyVersion>4.5.0.3</AssemblyVersion>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.7.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置 SOAP 错误的命名空间。</summary>
        <value>SOAP 错误的命名空间。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ProtectionLevel">
      <MemberSignature Language="C#" Value="public System.Net.Security.ProtectionLevel ProtectionLevel { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Net.Security.ProtectionLevel ProtectionLevel" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.FaultContractAttribute.ProtectionLevel" />
      <MemberSignature Language="VB.NET" Value="Public Property ProtectionLevel As ProtectionLevel" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Security::ProtectionLevel ProtectionLevel { System::Net::Security::ProtectionLevel get(); void set(System::Net::Security::ProtectionLevel value); };" />
      <MemberSignature Language="F#" Value="member this.ProtectionLevel : System.Net.Security.ProtectionLevel with get, set" Usage="System.ServiceModel.FaultContractAttribute.ProtectionLevel" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.Security.ProtectionLevel</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指定 SOAP 错误要求的绑定的保护级别。</summary>
        <value><see cref="T:System.Net.Security.ProtectionLevel" /> 值之一。 默认为 <see cref="F:System.Net.Security.ProtectionLevel.None" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用 <xref:System.ServiceModel.Description.FaultDescription.ProtectionLevel%2A?displayProperty=nameWithType> 属性指定发送 SOAP 错误时绑定必须加密和/或签名的程度。 强烈建议操作错误显式确定协定上的安全保护级别要求。 默认的保护级别为 <xref:System.Net.Security.ProtectionLevel.None?displayProperty=nameWithType>，这意味着您定义的 SOAP 错误消息不需要加密或数字签名（不过，如果您的绑定配置为这样，则您的绑定可能会提供此支持）。 如果错误消息携带敏感信息或可能导致安全问题，则强烈建议将 <xref:System.ServiceModel.FaultContractAttribute.ProtectionLevel%2A> 属性设置为 <xref:System.Net.Security.ProtectionLevel.EncryptAndSign?displayProperty=nameWithType>。 有关安全问题的详细信息，请参阅[了解保护级别](~/docs/framework/wcf/understanding-protection-level.md)。  
  
 运行时的保护行为是具有层次结构的保护级别属性的组合。 除非已为较窄范围显式设置了某个不同的值，否则设置最外层的值将为所有较窄的范围确定默认设置。 在这种情况下，外层的值将保持所有较窄的范围的默认设置，但特定的设置除外。  
  
 例如，如果 <xref:System.ServiceModel.ServiceContractAttribute.ProtectionLevel%2A?displayProperty=nameWithType> 设置为 "<xref:System.Net.Security.ProtectionLevel.EncryptAndSign?displayProperty=nameWithType>，而且没有其他更窄的范围具有保护级别设置，则操作协定中的所有消息都将进行加密和签名，其中包括错误消息。 但是，如果其中一个操作的 <xref:System.ServiceModel.OperationContractAttribute> 设置为 <xref:System.Net.Security.ProtectionLevel.Sign?displayProperty=nameWithType>，则会对该操作的消息进行签名，但会对该协定中的所有其他消息进行加密和签名，其中包括错误消息。  
  
 这些值的设置范围是：  
  
 <xref:System.ServiceModel.ServiceContractAttribute.ProtectionLevel%2A?displayProperty=nameWithType>  
  
 <xref:System.ServiceModel.OperationContractAttribute.ProtectionLevel%2A?displayProperty=nameWithType>  
  
 <xref:System.ServiceModel.FaultContractAttribute.ProtectionLevel%2A?displayProperty=nameWithType>  
  
 <xref:System.ServiceModel.MessageContractAttribute.ProtectionLevel%2A?displayProperty=nameWithType>  
  
 <xref:System.ServiceModel.MessageContractMemberAttribute.ProtectionLevel%2A?displayProperty=nameWithType> 上的 <xref:System.ServiceModel.MessageHeaderAttribute?displayProperty=nameWithType> 属性。  
  
 <xref:System.ServiceModel.MessageContractMemberAttribute.ProtectionLevel%2A?displayProperty=nameWithType> 上的 <xref:System.ServiceModel.MessageBodyMemberAttribute?displayProperty=nameWithType> 属性。  
  
 当协定上没有显式指定保护级别并且基础绑定支持安全性时（无论处于传输级别还是处于消息级别），整个协定的有效保护级别将为 <xref:System.Net.Security.ProtectionLevel.EncryptAndSign?displayProperty=nameWithType>。 如果绑定不支持安全性（如 <xref:System.ServiceModel.BasicHttpBinding>），则整个协定的有效 <xref:System.Net.Security.ProtectionLevel?displayProperty=nameWithType> 为 <xref:System.Net.Security.ProtectionLevel.None?displayProperty=nameWithType>。 因此，根据终结点绑定，即使协定指定了 <xref:System.Net.Security.ProtectionLevel.None?displayProperty=nameWithType>，客户端也可以要求不同的消息或传输级别安全保护。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
