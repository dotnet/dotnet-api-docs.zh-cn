<Type Name="JavaScriptTypeResolver" FullName="System.Web.Script.Serialization.JavaScriptTypeResolver">
  <Metadata><Meta Name="ms.openlocfilehash" Value="dc4d361a43ced23669530a32d2b8051850a4dd1c" /><Meta Name="ms.sourcegitcommit" Value="0398021c376446770e5d349e60aa72d49fc34f22" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-CN" /><Meta Name="ms.lasthandoff" Value="07/28/2020" /><Meta Name="ms.locfileid" Value="87260288" /></Metadata><TypeSignature Language="C#" Value="public abstract class JavaScriptTypeResolver" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit JavaScriptTypeResolver extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Web.Script.Serialization.JavaScriptTypeResolver" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class JavaScriptTypeResolver" />
  <TypeSignature Language="C++ CLI" Value="public ref class JavaScriptTypeResolver abstract" />
  <TypeSignature Language="F#" Value="type JavaScriptTypeResolver = class" />
  <AssemblyInfo>
    <AssemblyName>System.Web.Extensions</AssemblyName>
    <AssemblyVersion>3.5.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary><span data-ttu-id="194a7-101">提供用于实现自定义类型解析器的抽象基类。</span><span class="sxs-lookup"><span data-stu-id="194a7-101">Provides the abstract base class for implementing a custom type resolver.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="194a7-102"><xref:System.Web.Script.Serialization.JavaScriptTypeResolver>类为提供以下服务：</span><span class="sxs-lookup"><span data-stu-id="194a7-102">The <xref:System.Web.Script.Serialization.JavaScriptTypeResolver> class provides the services for:</span></span>  
  
-   <span data-ttu-id="194a7-103">通过方法将托管类型信息转换为字符串值 <xref:System.Web.Script.Serialization.JavaScriptTypeResolver.ResolveTypeId%2A> 。</span><span class="sxs-lookup"><span data-stu-id="194a7-103">Converting managed type information to a string value through the <xref:System.Web.Script.Serialization.JavaScriptTypeResolver.ResolveTypeId%2A> method.</span></span>  
  
-   <span data-ttu-id="194a7-104">通过方法将字符串值解析回适当的托管类型 <xref:System.Web.Script.Serialization.JavaScriptTypeResolver.ResolveType%2A> 。</span><span class="sxs-lookup"><span data-stu-id="194a7-104">Resolving a string value back to the appropriate managed type through the <xref:System.Web.Script.Serialization.JavaScriptTypeResolver.ResolveType%2A> method.</span></span>  
  
 <span data-ttu-id="194a7-105">当 <xref:System.Web.Script.Serialization.JavaScriptSerializer> 对象序列化自定义类型时，它可以选择性地包括在序列化的 JavaScript 对象表示法 (JSON) string a 包含类型信息的值。</span><span class="sxs-lookup"><span data-stu-id="194a7-105">When the <xref:System.Web.Script.Serialization.JavaScriptSerializer> object serializes custom types, it can optionally include in the serialized JavaScript Object Notation (JSON) string a value that contains type information.</span></span> <span data-ttu-id="194a7-106">在反序列化过程中， <xref:System.Web.Script.Serialization.JavaScriptSerializer> 可以引用此字符串值，以确定要将 JSON 字符串转换成的适当托管类型。</span><span class="sxs-lookup"><span data-stu-id="194a7-106">During deserialization, <xref:System.Web.Script.Serialization.JavaScriptSerializer> can then reference this string value to determine the appropriate managed type to which the JSON string will be converted.</span></span>  
  
 <span data-ttu-id="194a7-107">如果向实例提供类型解析程序 <xref:System.Web.Script.Serialization.JavaScriptSerializer> ，则序列化程序将使用 <xref:System.Web.Script.Serialization.JavaScriptTypeResolver.ResolveTypeId%2A> 和方法在 <xref:System.Web.Script.Serialization.JavaScriptTypeResolver.ResolveType%2A> 序列化和反序列化过程中的托管类型和字符串值之间进行映射。</span><span class="sxs-lookup"><span data-stu-id="194a7-107">If you provide a type resolver to the <xref:System.Web.Script.Serialization.JavaScriptSerializer> instance, the serializer will use the <xref:System.Web.Script.Serialization.JavaScriptTypeResolver.ResolveTypeId%2A> and <xref:System.Web.Script.Serialization.JavaScriptTypeResolver.ResolveType%2A> methods to map between the managed type and the string value during the serialization and deserialization process, respectively.</span></span>  
  
 <span data-ttu-id="194a7-108"><xref:System.Web.Script.Serialization.JavaScriptTypeResolver>类是类的基类 <xref:System.Web.Script.Serialization.SimpleTypeResolver> ，该类提供使用托管类型程序集限定名称的类型解析程序的实现。</span><span class="sxs-lookup"><span data-stu-id="194a7-108">The <xref:System.Web.Script.Serialization.JavaScriptTypeResolver> class is the base class for the <xref:System.Web.Script.Serialization.SimpleTypeResolver> class, which provides an implementation of a type resolver that uses the managed type assembly-qualified name.</span></span>  

> [!NOTE]
> <span data-ttu-id="194a7-109">使用时 `JavaScriptTypeResolver` ，生成的 JSON 负载包含特殊 `__type` 属性。</span><span class="sxs-lookup"><span data-stu-id="194a7-109">When using a `JavaScriptTypeResolver`, the resulting JSON payload contains a special `__type` property.</span></span> <span data-ttu-id="194a7-110">此属性包括目标类型的完整类型名称（包括命名空间）。</span><span class="sxs-lookup"><span data-stu-id="194a7-110">This property includes the full type name, including namespace, of the target type.</span></span> <span data-ttu-id="194a7-111">使用自定义冲突解决程序之前，请验证目标类型的全名不包含敏感或特权信息。</span><span class="sxs-lookup"><span data-stu-id="194a7-111">Before using a custom resolver, verify that the full name of the target type does not contain sensitive or privileged information.</span></span>

## Examples  

<span data-ttu-id="194a7-112">下面的示例演示如何创建自定义 `JavaScriptTypeResolver` 以及如何使用它对对象进行序列化或反序列化。</span><span class="sxs-lookup"><span data-stu-id="194a7-112">The following example shows how to create a custom `JavaScriptTypeResolver` and how to use it to serialize or deserialize an object.</span></span>

```cs
using System;
using System.Linq;
using System.Web.Script.Serialization;

namespace SampleApp
{
    class Program
    {
        static void Main(string[] args)
        {
            // The object array to serialize.
            Person[] people = new Person[]
            {
                new Person()
                {
                    Name = "Kristen Solstad",
                    Age = 15,
                    HomeAddress = new Address()
                    {
                        Street1 = "123 Palm Ave",
                        City = "Some City",
                        StateOrProvince = "ST",
                        Country = "United States",
                        PostalCode = "00000"
                    }
                },
                new Adult()
                {
                    Name = "Alex Johnson",
                    Age = 39,
                    Occupation = "Mechanic",
                    HomeAddress = new Address()
                    {
                        Street1 = "445 Lorry Way",
                        Street2 = "Unit 3A",
                        City = "Some City",
                        Country = "United Kingdom",
                        PostalCode = "AA0 A00"
                    }
                }
            };

            // Serialize the object array, then write it to the console.
            string serializedData = SerializePeopleArray(people);
            Console.WriteLine("Serialized:");
            Console.WriteLine(serializedData);
            Console.WriteLine();

            // Now deserialize the object array.
            Person[] deserializedArray = DeserializePeopleArray(serializedData);
            Console.WriteLine("Deserialized " + deserializedArray.Length + " people.");
            foreach (Person person in deserializedArray)
            {
                Console.WriteLine(person.Name + " (Age " + person.Age + ") [" + person.GetType() + "]");
            }
        }

        static string SerializePeopleArray(Person[] people)
        {
            // The custom type resolver to use.
            // Note: Except for primitives like int and string, *every* type that
            // we might see in the object graph must be listed here.
            CustomTypeResolver resolver = new CustomTypeResolver(
                typeof(Person),
                typeof(Adult),
                typeof(Address));

            // Instantiate the serializer.
            JavaScriptSerializer serializer = new JavaScriptSerializer(resolver);

            // Serialize the object array, then return it.
            string serialized = serializer.Serialize(people);
            return serialized;
        }

        static Person[] DeserializePeopleArray(string serializedData)
        {
            // The custom type resolver to use.
            // Note: This is the same list that was provided to the Serialize routine.
            CustomTypeResolver resolver = new CustomTypeResolver(
                typeof(Person),
                typeof(Adult),
                typeof(Address));

            // Instantiate the serializer.
            JavaScriptSerializer serializer = new JavaScriptSerializer(resolver);

            // Deserialize the object array, then return it.
            Person[] deserialized = serializer.Deserialize<Person[]>(serializedData);
            return deserialized;
        }
    }

    public class Person
    {
        public string Name { get; set; }
        public int Age { get; set; }
        public Address HomeAddress { get; set; }
    }

    public class Adult : Person
    {
        public string Occupation { get; set; }
    }

    public class Address
    {
        public string Street1 { get; set; }
        public string Street2 { get; set; }
        public string City { get; set; }
        public string StateOrProvince { get; set; }
        public string Country { get; set; }
        public string PostalCode { get; set; }
    }

    // A custom JavaScriptTypeResolver that restricts the payload
    // to a set of known good types.
    class CustomTypeResolver : JavaScriptTypeResolver
    {
        private readonly Type[] _allowedTypes;

        public CustomTypeResolver(params Type[] allowedTypes)
        {
            if (allowedTypes == null)
            {
                throw new ArgumentNullException("allowedTypes");
            }

            // Make a copy of the array the caller gave us.
            _allowedTypes = (Type[])allowedTypes.Clone();
        }

        public override Type ResolveType(string id)
        {
            // Iterate over all of the allowed types, looking for a match
            // for the 'id' parameter. Calling Type.GetType(id) is dangerous,
            // so we instead perform a match on the Type.FullName property.
            foreach (Type allowedType in _allowedTypes)
            {
                if (allowedType.FullName == id)
                {
                    return allowedType;
                }
            }

            // The caller provided a type we don't recognize. This could be
            // dangerous, so we'll fail the operation immediately.
            throw new ArgumentException("Unknown type: " + id, "id");
        }

        public override string ResolveTypeId(Type type)
        {
            // Before we serialize data, quickly double-check to make
            // sure we're allowed to deserialize the data. Otherwise it's
            // no good serializing something if we can't deserialize it.
            if (_allowedTypes.Contains(type))
            {
                return type.FullName;
            }

            throw new InvalidOperationException("Cannot serialize an object of type " + type + ". Did you forget to add it to the allow list?");
        }
    }
}
```

<span data-ttu-id="194a7-113">前面的应用程序将以下输出输出到控制台，并为可读性进行了格式化。</span><span class="sxs-lookup"><span data-stu-id="194a7-113">The preceding app outputs the following to the console, formatted for readability.</span></span>

```txt
Serialized:
[
    {
        "__type": "SampleApp.Person",
        "Name": "Kristen Solstad",
        "Age": 15,
        "HomeAddress": {
            "__type": "SampleApp.Address",
            "Street1": "123 Palm Ave",
            "Street2": null,
            "City": "Some City",
            "StateOrProvince": "ST",
            "Country": "United States",
            "PostalCode": "00000"
        }
    },
    {
        "__type": "SampleApp.Adult",
        "Occupation": "Mechanic",
        "Name": "Alex Johnson",
        "Age": 39,
        "HomeAddress": {
            "__type": "SampleApp.Address",
            "Street1": "445 Lorry Way",
            "Street2": "Unit 3A",
            "City": "Some City",
            "StateOrProvince": null,
            "Country": "United Kingdom",
            "PostalCode": "AA0 A00"
        }
    }
]

Deserialized 2 people.
Kristen Solstad (Age 15) [SampleApp.Person]
Alex Johnson (Age 39) [SampleApp.Adult]
```

<span data-ttu-id="194a7-114">在上面的示例中， `Adult` 类型为 `Person` 类型键入子类。</span><span class="sxs-lookup"><span data-stu-id="194a7-114">In the preceding sample, the `Adult` type subclasses the `Person` type.</span></span> <span data-ttu-id="194a7-115">自定义 `JavaScriptTypeResolver` 用于在生成的 JSON 有效负载中包含类型信息。</span><span class="sxs-lookup"><span data-stu-id="194a7-115">A custom `JavaScriptTypeResolver` is used to include the type information as part of the generated JSON payload.</span></span> <span data-ttu-id="194a7-116">这允许在将 JSON 有效负载反序列化为 .NET 对象图时使用多态。</span><span class="sxs-lookup"><span data-stu-id="194a7-116">This allows limited polymorphism when deserializing the JSON payload back into a .NET object graph.</span></span> <span data-ttu-id="194a7-117">负载可以控制是将基 `Person` 实例还是返回派生 `Adult` 实例返回给调用方。</span><span class="sxs-lookup"><span data-stu-id="194a7-117">The payload can control whether to return a base `Person` instance or a derived `Adult` instance back to the caller.</span></span>

<span data-ttu-id="194a7-118">此示例是安全的，因为它使用 `allow-list` 机制来控制反序列化。</span><span class="sxs-lookup"><span data-stu-id="194a7-118">This sample is safe because it uses an `allow-list` mechanism to control deserialization.</span></span> <span data-ttu-id="194a7-119">代码：</span><span class="sxs-lookup"><span data-stu-id="194a7-119">The code:</span></span>

* <span data-ttu-id="194a7-120">`CustomTypeResolver`用允许类型的显式列表初始化。</span><span class="sxs-lookup"><span data-stu-id="194a7-120">Initializes the `CustomTypeResolver` with an explicit list of allowed types.</span></span>
* <span data-ttu-id="194a7-121">将反序列化过程限制为仅限已批准的类型列表。</span><span class="sxs-lookup"><span data-stu-id="194a7-121">Restricts the deserialization process to only approved list of types.</span></span> <span data-ttu-id="194a7-122">此限制可防止 [反序列化攻击](https://owasp.org/www-community/vulnerabilities/Deserialization_of_untrusted_data)，其中远程客户端 `__type` 在 JSON 有效负载中指定恶意并使服务器反序列化危险类型。</span><span class="sxs-lookup"><span data-stu-id="194a7-122">The restriction prevents [deserialization attacks](https://owasp.org/www-community/vulnerabilities/Deserialization_of_untrusted_data), where the remote client specifies a malicious `__type` in the JSON payload and tricks the server into deserializing a dangerous type.</span></span>

<span data-ttu-id="194a7-123">即使应用只 `Person` `Adult` 需作为顶级数组的一部分进行反序列化，但仍需要将其添加 `Address` 到允许列表，因为：</span><span class="sxs-lookup"><span data-stu-id="194a7-123">Even though the app only expects `Person` and `Adult` instances to be deserialized as part of the top-level array, it's still necessary to add `Address` to the allow-list because:</span></span>

* <span data-ttu-id="194a7-124">序列化 `Person` 或 `Adult` 还会将序列化为 `Address` 对象图的一部分。</span><span class="sxs-lookup"><span data-stu-id="194a7-124">Serializing a `Person` or `Adult` also serializes an `Address` as part of the object graph.</span></span>
* <span data-ttu-id="194a7-125">对象图中可能存在的所有类型需要在允许列表中进行考虑。</span><span class="sxs-lookup"><span data-stu-id="194a7-125">All types that might be present in the object graph need to be accounted for in the allow list.</span></span> <span data-ttu-id="194a7-126">和等 `int` 基元 `string` 不需要指定。</span><span class="sxs-lookup"><span data-stu-id="194a7-126">Primitives like `int` and `string` do not need to be specified.</span></span>

> [!WARNING]
>  <span data-ttu-id="194a7-127">不要 `Type.GetType(id)` 在方法中调用 `ResolveType` 。</span><span class="sxs-lookup"><span data-stu-id="194a7-127">Do not call `Type.GetType(id)` within the `ResolveType` method.</span></span> <span data-ttu-id="194a7-128">这可能会在应用中引入安全 vunerability。</span><span class="sxs-lookup"><span data-stu-id="194a7-128">This could introduce a security vunerability into the app.</span></span> <span data-ttu-id="194a7-129">相反，循环访问允许类型的列表，并将其 `Type.FullName` 属性与传入的属性进行比较 `id` ，如前面的示例所示。</span><span class="sxs-lookup"><span data-stu-id="194a7-129">Instead, iterate through the list of allowed types and compare their `Type.FullName` property against the incoming `id`, as shown in the preceding sample.</span></span>
  
 ]]></format>
    </remarks>
    <block subset="none" type="overrides"><para><span data-ttu-id="194a7-130">实现类型解析程序时， <see cref="M:System.Web.Script.Serialization.JavaScriptTypeResolver.ResolveTypeId(System.Type)" /> 当字符串值传递到方法时，该方法返回的字符串必须映射回同一托管类型 <see cref="M:System.Web.Script.Serialization.JavaScriptTypeResolver.ResolveType(System.String)" /> 。</span><span class="sxs-lookup"><span data-stu-id="194a7-130">When you implement a type resolver, the string that is returned by the <see cref="M:System.Web.Script.Serialization.JavaScriptTypeResolver.ResolveTypeId(System.Type)" /> method must map back to the same managed type when the string value is passed to the <see cref="M:System.Web.Script.Serialization.JavaScriptTypeResolver.ResolveType(System.String)" /> method.</span></span></para></block>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected JavaScriptTypeResolver ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Script.Serialization.JavaScriptTypeResolver.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; JavaScriptTypeResolver();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="194a7-131">初始化 <see cref="T:System.Web.Script.Serialization.JavaScriptTypeResolver" /> 类的新实例。</span><span class="sxs-lookup"><span data-stu-id="194a7-131">Initializes a new instance of the <see cref="T:System.Web.Script.Serialization.JavaScriptTypeResolver" /> class.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ResolveType">
      <MemberSignature Language="C#" Value="public abstract Type ResolveType (string id);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type ResolveType(string id) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Script.Serialization.JavaScriptTypeResolver.ResolveType(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function ResolveType (id As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract Type ^ ResolveType(System::String ^ id);" />
      <MemberSignature Language="F#" Value="abstract member ResolveType : string -&gt; Type" Usage="javaScriptTypeResolver.ResolveType id" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="id"><span data-ttu-id="194a7-132">托管类型的名称。</span><span class="sxs-lookup"><span data-stu-id="194a7-132">The name of the managed type.</span></span></param>
        <summary><span data-ttu-id="194a7-133">当在派生类中重写时，返回与指定类型名称相关联的 <see cref="T:System.Type" /> 对象。</span><span class="sxs-lookup"><span data-stu-id="194a7-133">When overridden in a derived class, returns the <see cref="T:System.Type" /> object that is associated with the specified type name.</span></span></summary>
        <returns><span data-ttu-id="194a7-134">与指定类型名称相关联的 <see cref="T:System.Type" /> 对象。</span><span class="sxs-lookup"><span data-stu-id="194a7-134">The <see cref="T:System.Type" /> object that is associated with the specified type name.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="194a7-135">当类型解析程序与实例关联时 <xref:System.Web.Script.Serialization.JavaScriptSerializer> ，序列化程序将 <xref:System.Web.Script.Serialization.JavaScriptTypeResolver.ResolveType%2A> 在循环访问 json 字符串时使用方法，以确定 JSON 类型应转换为的特定托管类型。</span><span class="sxs-lookup"><span data-stu-id="194a7-135">When a type resolver is associated with a <xref:System.Web.Script.Serialization.JavaScriptSerializer> instance, the serializer uses the <xref:System.Web.Script.Serialization.JavaScriptTypeResolver.ResolveType%2A> method when it iterates through a JSON string to determine the specific managed type to which the JSON type should be converted.</span></span>  

 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para><span data-ttu-id="194a7-136">给定一个字符串值，类型解析程序必须返回一个 <see cref="T:System.Type" /> 表示相应托管类型的对象。</span><span class="sxs-lookup"><span data-stu-id="194a7-136">Given a string value, the type resolver must return a <see cref="T:System.Type" /> object that represents the corresponding managed type.</span></span></para></block>
      </Docs>
    </Member>
    <Member MemberName="ResolveTypeId">
      <MemberSignature Language="C#" Value="public abstract string ResolveTypeId (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ResolveTypeId(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Script.Serialization.JavaScriptTypeResolver.ResolveTypeId(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function ResolveTypeId (type As Type) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::String ^ ResolveTypeId(Type ^ type);" />
      <MemberSignature Language="F#" Value="abstract member ResolveTypeId : Type -&gt; string" Usage="javaScriptTypeResolver.ResolveTypeId type" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type"><span data-ttu-id="194a7-137">要解析的托管类型。</span><span class="sxs-lookup"><span data-stu-id="194a7-137">The managed type to be resolved.</span></span></param>
        <summary><span data-ttu-id="194a7-138">当在派生类中重写时，返回指定的 <see cref="T:System.Type" /> 对象的类型名称。</span><span class="sxs-lookup"><span data-stu-id="194a7-138">When overridden in a derived class, returns the type name for the specified <see cref="T:System.Type" /> object.</span></span></summary>
        <returns><span data-ttu-id="194a7-139">指定托管类型的名称。</span><span class="sxs-lookup"><span data-stu-id="194a7-139">The name of the specified managed type.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="194a7-140">如果该 <xref:System.Web.Script.Serialization.JavaScriptTypeResolver.ResolveTypeId%2A> 方法返回 `null` 或 <xref:System.String.Empty> ，则类型解析程序不支持该类型。</span><span class="sxs-lookup"><span data-stu-id="194a7-140">If the <xref:System.Web.Script.Serialization.JavaScriptTypeResolver.ResolveTypeId%2A> method returns either `null` or <xref:System.String.Empty>, then the type resolver does not support the type.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
