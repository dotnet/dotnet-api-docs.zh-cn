<Type Name="BatchedJoinBlock&lt;T1,T2,T3&gt;" FullName="System.Threading.Tasks.Dataflow.BatchedJoinBlock&lt;T1,T2,T3&gt;">
  <Metadata><Meta Name="ms.openlocfilehash" Value="ad626bd976c599af0d0ed3e822b181c61502d741" /><Meta Name="ms.sourcegitcommit" Value="c982ad9e10a242d90f1e631b5981570f9e5d9f34" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-CN" /><Meta Name="ms.lasthandoff" Value="09/10/2020" /><Meta Name="ms.locfileid" Value="89931039" /></Metadata><TypeSignature Language="C#" Value="public sealed class BatchedJoinBlock&lt;T1,T2,T3&gt; : System.Threading.Tasks.Dataflow.IReceivableSourceBlock&lt;Tuple&lt;System.Collections.Generic.IList&lt;T1&gt;,System.Collections.Generic.IList&lt;T2&gt;,System.Collections.Generic.IList&lt;T3&gt;&gt;&gt;, System.Threading.Tasks.Dataflow.ISourceBlock&lt;Tuple&lt;System.Collections.Generic.IList&lt;T1&gt;,System.Collections.Generic.IList&lt;T2&gt;,System.Collections.Generic.IList&lt;T3&gt;&gt;&gt;" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit BatchedJoinBlock`3&lt;T1, T2, T3&gt; extends System.Object implements class System.Threading.Tasks.Dataflow.IDataflowBlock, class System.Threading.Tasks.Dataflow.IReceivableSourceBlock`1&lt;class System.Tuple`3&lt;class System.Collections.Generic.IList`1&lt;!T1&gt;, class System.Collections.Generic.IList`1&lt;!T2&gt;, class System.Collections.Generic.IList`1&lt;!T3&gt;&gt;&gt;, class System.Threading.Tasks.Dataflow.ISourceBlock`1&lt;class System.Tuple`3&lt;class System.Collections.Generic.IList`1&lt;!T1&gt;, class System.Collections.Generic.IList`1&lt;!T2&gt;, class System.Collections.Generic.IList`1&lt;!T3&gt;&gt;&gt;" />
  <TypeSignature Language="DocId" Value="T:System.Threading.Tasks.Dataflow.BatchedJoinBlock`3" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class BatchedJoinBlock(Of T1, T2, T3)&#xA;Implements IReceivableSourceBlock(Of Tuple(Of IList(Of T1), IList(Of T2), IList(Of T3))), ISourceBlock(Of Tuple(Of IList(Of T1), IList(Of T2), IList(Of T3)))" />
  <TypeSignature Language="C++ CLI" Value="generic &lt;typename T1, typename T2, typename T3&gt;&#xA;public ref class BatchedJoinBlock sealed : System::Threading::Tasks::Dataflow::IReceivableSourceBlock&lt;Tuple&lt;System::Collections::Generic::IList&lt;T1&gt; ^, System::Collections::Generic::IList&lt;T2&gt; ^, System::Collections::Generic::IList&lt;T3&gt; ^&gt; ^&gt;, System::Threading::Tasks::Dataflow::ISourceBlock&lt;Tuple&lt;System::Collections::Generic::IList&lt;T1&gt; ^, System::Collections::Generic::IList&lt;T2&gt; ^, System::Collections::Generic::IList&lt;T3&gt; ^&gt; ^&gt;" />
  <TypeSignature Language="F#" Value="type BatchedJoinBlock&lt;'T1, 'T2, 'T3&gt; = class&#xA;    interface IReceivableSourceBlock&lt;IList&lt;'T1&gt; * IList&lt;'T2&gt; * IList&lt;'T3&gt;&gt;&#xA;    interface ISourceBlock&lt;IList&lt;'T1&gt; * IList&lt;'T2&gt; * IList&lt;'T3&gt;&gt;&#xA;    interface IDataflowBlock" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1" />
  <TypeSignature Language="F#" Value="type BatchedJoinBlock&lt;'T1, 'T2, 'T3&gt; = class&#xA;    interface IDataflowBlock&#xA;    interface IReceivableSourceBlock&lt;IList&lt;'T1&gt; * IList&lt;'T2&gt; * IList&lt;'T3&gt;&gt;&#xA;    interface ISourceBlock&lt;IList&lt;'T1&gt; * IList&lt;'T2&gt; * IList&lt;'T3&gt;&gt;" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1" />
  <AssemblyInfo>
    <AssemblyName>System.Threading.Tasks.Dataflow</AssemblyName>
    <AssemblyVersion>4.5.25.0</AssemblyVersion>
    <AssemblyVersion>4.6.0.0</AssemblyVersion>
    <AssemblyVersion>4.6.1.0</AssemblyVersion>
    <AssemblyVersion>4.6.2.0</AssemblyVersion>
    <AssemblyVersion>4.6.3.0</AssemblyVersion>
    <AssemblyVersion>4.6.4.0</AssemblyVersion>
    <AssemblyVersion>4.6.5.0</AssemblyVersion>
    <AssemblyVersion>5.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeParameters>
    <TypeParameter Name="T1" />
    <TypeParameter Name="T2" />
    <TypeParameter Name="T3" />
  </TypeParameters>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Threading.Tasks.Dataflow.IDataflowBlock</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Threading.Tasks.Dataflow.IReceivableSourceBlock&lt;System.Tuple&lt;System.Collections.Generic.IList&lt;T1&gt;,System.Collections.Generic.IList&lt;T2&gt;,System.Collections.Generic.IList&lt;T3&gt;&gt;&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Threading.Tasks.Dataflow.ISourceBlock&lt;System.Tuple&lt;System.Collections.Generic.IList&lt;T1&gt;,System.Collections.Generic.IList&lt;T2&gt;,System.Collections.Generic.IList&lt;T3&gt;&gt;&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Threading.Tasks.Dataflow.ISourceBlock&lt;TOutput&gt;</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1">
      <AttributeName Language="C#">[System.Diagnostics.DebuggerDisplay("{DebuggerDisplayContent,nq}")]</AttributeName>
      <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerDisplay("{DebuggerDisplayContent,nq}")&gt;]</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1">
      <AttributeName Language="C#">[System.Diagnostics.DebuggerTypeProxy(typeof(System.Threading.Tasks.Dataflow.BatchedJoinBlock`3/DebugView))]</AttributeName>
      <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerTypeProxy(typeof(System.Threading.Tasks.Dataflow.BatchedJoinBlock`3/DebugView))&gt;]</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <typeparam name="T1">指定由块的第一个目标接受的数据类型。</typeparam>
    <typeparam name="T2">指定由块的第二个目标接受的数据类型。</typeparam>
    <typeparam name="T3">指定由块的第三个目标接受的数据类型。</typeparam>
    <summary>提供批处理指定数目输入的数据流块，这些输入为提供给目标的潜在不同的类型。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
[!INCLUDE [tpl-install-instructions](~/includes/tpl-install-instructions.md)]
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BatchedJoinBlock (int batchSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 batchSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Dataflow.BatchedJoinBlock`3.#ctor(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (batchSize As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; BatchedJoinBlock(int batchSize);" />
      <MemberSignature Language="F#" Value="new System.Threading.Tasks.Dataflow.BatchedJoinBlock&lt;'T1, 'T2, 'T3&gt; : int -&gt; System.Threading.Tasks.Dataflow.BatchedJoinBlock&lt;'T1, 'T2, 'T3&gt;" Usage="new System.Threading.Tasks.Dataflow.BatchedJoinBlock&lt;'T1, 'T2, 'T3&gt; batchSize" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Dataflow</AssemblyName>
        <AssemblyVersion>4.5.25.0</AssemblyVersion>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.6.1.0</AssemblyVersion>
        <AssemblyVersion>4.6.2.0</AssemblyVersion>
        <AssemblyVersion>4.6.3.0</AssemblyVersion>
        <AssemblyVersion>4.6.4.0</AssemblyVersion>
        <AssemblyVersion>4.6.5.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="batchSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="batchSize">分组为批的项数。</param>
        <summary>初始化指定配置的新 <see cref="T:System.Threading.Tasks.Dataflow.BatchedJoinBlock`3" />。</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="batchSize" /> 必须是正数。</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BatchedJoinBlock (int batchSize, System.Threading.Tasks.Dataflow.GroupingDataflowBlockOptions dataflowBlockOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 batchSize, class System.Threading.Tasks.Dataflow.GroupingDataflowBlockOptions dataflowBlockOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Dataflow.BatchedJoinBlock`3.#ctor(System.Int32,System.Threading.Tasks.Dataflow.GroupingDataflowBlockOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (batchSize As Integer, dataflowBlockOptions As GroupingDataflowBlockOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; BatchedJoinBlock(int batchSize, System::Threading::Tasks::Dataflow::GroupingDataflowBlockOptions ^ dataflowBlockOptions);" />
      <MemberSignature Language="F#" Value="new System.Threading.Tasks.Dataflow.BatchedJoinBlock&lt;'T1, 'T2, 'T3&gt; : int * System.Threading.Tasks.Dataflow.GroupingDataflowBlockOptions -&gt; System.Threading.Tasks.Dataflow.BatchedJoinBlock&lt;'T1, 'T2, 'T3&gt;" Usage="new System.Threading.Tasks.Dataflow.BatchedJoinBlock&lt;'T1, 'T2, 'T3&gt; (batchSize, dataflowBlockOptions)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Dataflow</AssemblyName>
        <AssemblyVersion>4.5.25.0</AssemblyVersion>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.6.1.0</AssemblyVersion>
        <AssemblyVersion>4.6.2.0</AssemblyVersion>
        <AssemblyVersion>4.6.3.0</AssemblyVersion>
        <AssemblyVersion>4.6.4.0</AssemblyVersion>
        <AssemblyVersion>4.6.5.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="batchSize" Type="System.Int32" />
        <Parameter Name="dataflowBlockOptions" Type="System.Threading.Tasks.Dataflow.GroupingDataflowBlockOptions" />
      </Parameters>
      <Docs>
        <param name="batchSize">分组为批的项数。</param>
        <param name="dataflowBlockOptions">用来配置此 <see cref="T:System.Threading.Tasks.Dataflow.BatchedJoinBlock`2" /> 的选项。</param>
        <summary>初始化指定配置的新 <see cref="T:System.Threading.Tasks.Dataflow.BatchedJoinBlock`3" />。</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="batchSize" /> 必须是正数。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="dataflowBlockOptions" /> 为 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="BatchSize">
      <MemberSignature Language="C#" Value="public int BatchSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 BatchSize" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Dataflow.BatchedJoinBlock`3.BatchSize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property BatchSize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int BatchSize { int get(); };" />
      <MemberSignature Language="F#" Value="member this.BatchSize : int" Usage="System.Threading.Tasks.Dataflow.BatchedJoinBlock&lt;'T1, 'T2, 'T3&gt;.BatchSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Dataflow</AssemblyName>
        <AssemblyVersion>4.5.25.0</AssemblyVersion>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.6.1.0</AssemblyVersion>
        <AssemblyVersion>4.6.2.0</AssemblyVersion>
        <AssemblyVersion>4.6.3.0</AssemblyVersion>
        <AssemblyVersion>4.6.4.0</AssemblyVersion>
        <AssemblyVersion>4.6.5.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取生成此 <see cref="T:System.Threading.Tasks.Dataflow.BatchedJoinBlock`3" /> 的批大小。</summary>
        <value>批次大小。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Complete">
      <MemberSignature Language="C#" Value="public void Complete ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Complete() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Dataflow.BatchedJoinBlock`3.Complete" />
      <MemberSignature Language="VB.NET" Value="Public Sub Complete ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Complete();" />
      <MemberSignature Language="F#" Value="abstract member Complete : unit -&gt; unit&#xA;override this.Complete : unit -&gt; unit" Usage="batchedJoinBlock.Complete " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Threading.Tasks.Dataflow.IDataflowBlock.Complete</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Dataflow</AssemblyName>
        <AssemblyVersion>4.5.25.0</AssemblyVersion>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.6.1.0</AssemblyVersion>
        <AssemblyVersion>4.6.2.0</AssemblyVersion>
        <AssemblyVersion>4.6.3.0</AssemblyVersion>
        <AssemblyVersion>4.6.4.0</AssemblyVersion>
        <AssemblyVersion>4.6.5.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>通知 <see cref="T:System.Threading.Tasks.Dataflow.IDataflowBlock" />，告知其不应该生成任何更多的消息也不应使用任何更多的延迟消息。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%603.Complete%2A>在数据流块上调用之后，该块将完成，并且其 <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%603.Completion%2A> 任务在处理所有以前可用的数据后将进入最终状态。 <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%603.Complete%2A> 不会阻止等待完成，而是会启动请求;若要等待完成，可以  <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%603.Completion%2A> 使用任务。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Completion">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task Completion { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Threading.Tasks.Task Completion" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Dataflow.BatchedJoinBlock`3.Completion" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Completion As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::Tasks::Task ^ Completion { System::Threading::Tasks::Task ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Completion : System.Threading.Tasks.Task" Usage="System.Threading.Tasks.Dataflow.BatchedJoinBlock&lt;'T1, 'T2, 'T3&gt;.Completion" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Threading.Tasks.Dataflow.IDataflowBlock.Completion</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Dataflow</AssemblyName>
        <AssemblyVersion>4.5.25.0</AssemblyVersion>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.6.1.0</AssemblyVersion>
        <AssemblyVersion>4.6.2.0</AssemblyVersion>
        <AssemblyVersion>4.6.3.0</AssemblyVersion>
        <AssemblyVersion>4.6.4.0</AssemblyVersion>
        <AssemblyVersion>4.6.5.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取 <see cref="T:System.Threading.Tasks.Task" />，其表示数据流块的操作和完成。</summary>
        <value>任务。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 数据流块在当前未处理消息时，将被视为已完成，并保证其不会再处理其他消息。 <xref:System.Threading.Tasks.Task>完成关联的块后，返回的将转换为已完成状态。 <xref:System.Threading.Tasks.TaskStatus> <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> 当块根据数据流块的定义语义成功完成其处理时，它将转换为状态; <xref:System.Threading.Tasks.TaskStatus> <xref:System.Threading.Tasks.TaskStatus.Faulted> 当数据流块由于未经处理的异常而提前处理时，它将转换为状态，并且 <xref:System.Threading.Tasks.TaskStatus> <xref:System.Threading.Tasks.TaskStatus.Canceled> 当数据流块由于接收取消请求而提前处理结束时，它将转换为状态。 如果任务在状态中完成 <xref:System.Threading.Tasks.TaskStatus.Faulted> ，则其 `Exception` 属性将返回，其中 <xref:System.AggregateException> 包含导致块失败的一个或多个异常。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LinkTo">
      <MemberSignature Language="C#" Value="public IDisposable LinkTo (System.Threading.Tasks.Dataflow.ITargetBlock&lt;Tuple&lt;System.Collections.Generic.IList&lt;T1&gt;,System.Collections.Generic.IList&lt;T2&gt;,System.Collections.Generic.IList&lt;T3&gt;&gt;&gt; target, System.Threading.Tasks.Dataflow.DataflowLinkOptions linkOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IDisposable LinkTo(class System.Threading.Tasks.Dataflow.ITargetBlock`1&lt;class System.Tuple`3&lt;class System.Collections.Generic.IList`1&lt;!T1&gt;, class System.Collections.Generic.IList`1&lt;!T2&gt;, class System.Collections.Generic.IList`1&lt;!T3&gt;&gt;&gt; target, class System.Threading.Tasks.Dataflow.DataflowLinkOptions linkOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Dataflow.BatchedJoinBlock`3.LinkTo(System.Threading.Tasks.Dataflow.ITargetBlock{System.Tuple{System.Collections.Generic.IList{`0},System.Collections.Generic.IList{`1},System.Collections.Generic.IList{`2}}},System.Threading.Tasks.Dataflow.DataflowLinkOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function LinkTo (target As ITargetBlock(Of Tuple(Of IList(Of T1), IList(Of T2), IList(Of T3))), linkOptions As DataflowLinkOptions) As IDisposable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IDisposable ^ LinkTo(System::Threading::Tasks::Dataflow::ITargetBlock&lt;Tuple&lt;System::Collections::Generic::IList&lt;T1&gt; ^, System::Collections::Generic::IList&lt;T2&gt; ^, System::Collections::Generic::IList&lt;T3&gt; ^&gt; ^&gt; ^ target, System::Threading::Tasks::Dataflow::DataflowLinkOptions ^ linkOptions);" />
      <MemberSignature Language="F#" Value="abstract member LinkTo : System.Threading.Tasks.Dataflow.ITargetBlock&lt;System.Collections.Generic.IList&lt;'T1&gt; * System.Collections.Generic.IList&lt;'T2&gt; * System.Collections.Generic.IList&lt;'T3&gt;&gt; * System.Threading.Tasks.Dataflow.DataflowLinkOptions -&gt; IDisposable&#xA;override this.LinkTo : System.Threading.Tasks.Dataflow.ITargetBlock&lt;System.Collections.Generic.IList&lt;'T1&gt; * System.Collections.Generic.IList&lt;'T2&gt; * System.Collections.Generic.IList&lt;'T3&gt;&gt; * System.Threading.Tasks.Dataflow.DataflowLinkOptions -&gt; IDisposable" Usage="batchedJoinBlock.LinkTo (target, linkOptions)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Threading.Tasks.Dataflow.ISourceBlock`1.LinkTo(System.Threading.Tasks.Dataflow.ITargetBlock{`0},System.Threading.Tasks.Dataflow.DataflowLinkOptions)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Dataflow</AssemblyName>
        <AssemblyVersion>4.5.25.0</AssemblyVersion>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.6.1.0</AssemblyVersion>
        <AssemblyVersion>4.6.2.0</AssemblyVersion>
        <AssemblyVersion>4.6.3.0</AssemblyVersion>
        <AssemblyVersion>4.6.4.0</AssemblyVersion>
        <AssemblyVersion>4.6.5.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IDisposable</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Threading.Tasks.Dataflow.ITargetBlock&lt;System.Tuple&lt;System.Collections.Generic.IList&lt;T1&gt;,System.Collections.Generic.IList&lt;T2&gt;,System.Collections.Generic.IList&lt;T3&gt;&gt;&gt;" />
        <Parameter Name="linkOptions" Type="System.Threading.Tasks.Dataflow.DataflowLinkOptions" />
      </Parameters>
      <Docs>
        <param name="target">要将此源连接到的 <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" />。</param>
        <param name="linkOptions">如果源应在成功传播单一消息后取消链接，则为 <see langword="true" />；甚至在单一消息传播后仍将保持连接的 <see langword="false" />。</param>
        <summary>将 <see cref="T:System.Threading.Tasks.Dataflow.ISourceBlock`1" /> 链接到指定的 <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" />。</summary>
        <returns>根据调用 Dispose 将取消与目标中源的链接的 IDisposable。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="target" /> 为 <see langword="null" />（在 Visual Basic 中为 Nothing），或者 <paramref name="linkOptions" /> 为 <see langword="null" />（在 Visual Basic 中为 Nothing）。</exception>
      </Docs>
    </Member>
    <Member MemberName="OutputCount">
      <MemberSignature Language="C#" Value="public int OutputCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 OutputCount" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Dataflow.BatchedJoinBlock`3.OutputCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property OutputCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int OutputCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.OutputCount : int" Usage="System.Threading.Tasks.Dataflow.BatchedJoinBlock&lt;'T1, 'T2, 'T3&gt;.OutputCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Dataflow</AssemblyName>
        <AssemblyVersion>4.5.25.0</AssemblyVersion>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.6.1.0</AssemblyVersion>
        <AssemblyVersion>4.6.2.0</AssemblyVersion>
        <AssemblyVersion>4.6.3.0</AssemblyVersion>
        <AssemblyVersion>4.6.4.0</AssemblyVersion>
        <AssemblyVersion>4.6.5.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取可从此块中接收的输出项的数量。</summary>
        <value>输出项数。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Threading.Tasks.Dataflow.IDataflowBlock.Fault">
      <MemberSignature Language="C#" Value="void IDataflowBlock.Fault (Exception exception);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Threading.Tasks.Dataflow.IDataflowBlock.Fault(class System.Exception exception) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Dataflow.BatchedJoinBlock`3.System#Threading#Tasks#Dataflow#IDataflowBlock#Fault(System.Exception)" />
      <MemberSignature Language="VB.NET" Value="Sub Fault (exception As Exception) Implements IDataflowBlock.Fault" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Threading.Tasks.Dataflow.IDataflowBlock.Fault(Exception ^ exception) = System::Threading::Tasks::Dataflow::IDataflowBlock::Fault;" />
      <MemberSignature Language="F#" Value="abstract member System.Threading.Tasks.Dataflow.IDataflowBlock.Fault : Exception -&gt; unit&#xA;override this.System.Threading.Tasks.Dataflow.IDataflowBlock.Fault : Exception -&gt; unit" Usage="batchedJoinBlock.System.Threading.Tasks.Dataflow.IDataflowBlock.Fault exception" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Threading.Tasks.Dataflow.IDataflowBlock.Fault(System.Exception)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Dataflow</AssemblyName>
        <AssemblyVersion>4.5.25.0</AssemblyVersion>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.6.1.0</AssemblyVersion>
        <AssemblyVersion>4.6.2.0</AssemblyVersion>
        <AssemblyVersion>4.6.3.0</AssemblyVersion>
        <AssemblyVersion>4.6.4.0</AssemblyVersion>
        <AssemblyVersion>4.6.5.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="exception" Type="System.Exception" />
      </Parameters>
      <Docs>
        <param name="exception">导致出错的 <see cref="T:System.Exception" />。</param>
        <summary>导致 <see cref="T:System.Threading.Tasks.Dataflow.IDataflowBlock" /> 在 <see cref="F:System.Threading.Tasks.TaskStatus.Faulted" /> 状态下完成。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Tasks.Dataflow.IDataflowBlock.Fault%2A>在数据流块上调用之后，该块将完成，并且其 <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%603.Completion%2A> 任务将进入最终状态。 如果对块进行错误处理，就像取消块那样，会导致缓冲消息 (未处理的输入消息，并 unoffered 输出消息) 丢失。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="exception" /> 为 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Threading.Tasks.Dataflow.ISourceBlock&lt;System.Tuple&lt;System.Collections.Generic.IList&lt;T1&gt;,System.Collections.Generic.IList&lt;T2&gt;,System.Collections.Generic.IList&lt;T3&gt;&gt;&gt;.ConsumeMessage">
      <MemberSignature Language="C#" Value="(System.Collections.Generic.IList&lt;T1&gt;,System.Collections.Generic.IList&lt;T2&gt;,System.Collections.Generic.IList&lt;T3&gt;) ISourceBlock&lt;Tuple&lt;IList&lt;T1&gt;,IList&lt;T2&gt;,IList&lt;T3&gt;&gt;&gt;.ConsumeMessage (System.Threading.Tasks.Dataflow.DataflowMessageHeader messageHeader, System.Threading.Tasks.Dataflow.ITargetBlock&lt;Tuple&lt;System.Collections.Generic.IList&lt;T1&gt;,System.Collections.Generic.IList&lt;T2&gt;,System.Collections.Generic.IList&lt;T3&gt;&gt;&gt; target, out bool messageConsumed);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Tuple`3&lt;class System.Collections.Generic.IList`1&lt;!T1&gt;, class System.Collections.Generic.IList`1&lt;!T2&gt;, class System.Collections.Generic.IList`1&lt;!T3&gt;&gt; System.Threading.Tasks.Dataflow.ISourceBlock&lt;System.Tuple&lt;System.Collections.Generic.IList&lt;T1&gt;,System.Collections.Generic.IList&lt;T2&gt;,System.Collections.Generic.IList&lt;T3&gt;&gt;&gt;.ConsumeMessage(valuetype System.Threading.Tasks.Dataflow.DataflowMessageHeader messageHeader, class System.Threading.Tasks.Dataflow.ITargetBlock`1&lt;class System.Tuple`3&lt;class System.Collections.Generic.IList`1&lt;!T1&gt;, class System.Collections.Generic.IList`1&lt;!T2&gt;, class System.Collections.Generic.IList`1&lt;!T3&gt;&gt;&gt; target, [out] bool&amp; messageConsumed) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Dataflow.BatchedJoinBlock`3.System#Threading#Tasks#Dataflow#ISourceBlock&lt;System#Tuple&lt;System#Collections#Generic#IList&lt;T1&gt;,System#Collections#Generic#IList&lt;T2&gt;,System#Collections#Generic#IList&lt;T3&gt;&gt;&gt;#ConsumeMessage(System.Threading.Tasks.Dataflow.DataflowMessageHeader,System.Threading.Tasks.Dataflow.ITargetBlock{System.Tuple{System.Collections.Generic.IList{`0},System.Collections.Generic.IList{`1},System.Collections.Generic.IList{`2}}},System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Function ConsumeMessage (messageHeader As DataflowMessageHeader, target As ITargetBlock(Of Tuple(Of IList(Of T1), IList(Of T2), IList(Of T3))), ByRef messageConsumed As Boolean) As Tuple(Of IList(Of T1), IList(Of T2), IList(Of T3)) Implements ISourceBlock(Of Tuple(Of IList(Of T1), IList(Of T2), IList(Of T3))).ConsumeMessage" />
      <MemberSignature Language="C++ CLI" Value=" virtual Tuple&lt;System::Collections::Generic::IList&lt;T1&gt; ^, System::Collections::Generic::IList&lt;T2&gt; ^, System::Collections::Generic::IList&lt;T3&gt; ^&gt; ^ System.Threading.Tasks.Dataflow.ISourceBlock&lt;System.Tuple&lt;System.Collections.Generic.IList&lt;T1&gt;,System.Collections.Generic.IList&lt;T2&gt;,System.Collections.Generic.IList&lt;T3&gt;&gt;&gt;.ConsumeMessage(System::Threading::Tasks::Dataflow::DataflowMessageHeader messageHeader, System::Threading::Tasks::Dataflow::ITargetBlock&lt;Tuple&lt;System::Collections::Generic::IList&lt;T1&gt; ^, System::Collections::Generic::IList&lt;T2&gt; ^, System::Collections::Generic::IList&lt;T3&gt; ^&gt; ^&gt; ^ target, [Runtime::InteropServices::Out] bool % messageConsumed) = System::Threading::Tasks::Dataflow::ISourceBlock&lt;Tuple&lt;System::Collections::Generic::IList&lt;T1&gt; ^, System::Collections::Generic::IList&lt;T2&gt; ^, System::Collections::Generic::IList&lt;T3&gt; ^&gt; ^&gt;::ConsumeMessage;" />
      <MemberSignature Language="F#" Value="abstract member System.Threading.Tasks.Dataflow.ISourceBlock&lt;System.Tuple&lt;System.Collections.Generic.IList&lt;T1&gt;,System.Collections.Generic.IList&lt;T2&gt;,System.Collections.Generic.IList&lt;T3&gt;&gt;&gt;.ConsumeMessage : System.Threading.Tasks.Dataflow.DataflowMessageHeader * System.Threading.Tasks.Dataflow.ITargetBlock&lt;System.Collections.Generic.IList&lt;'T1&gt; * System.Collections.Generic.IList&lt;'T2&gt; * System.Collections.Generic.IList&lt;'T3&gt;&gt; * bool -&gt; System.Collections.Generic.IList&lt;'T1&gt; * System.Collections.Generic.IList&lt;'T2&gt; * System.Collections.Generic.IList&lt;'T3&gt;&#xA;override this.System.Threading.Tasks.Dataflow.ISourceBlock&lt;System.Tuple&lt;System.Collections.Generic.IList&lt;T1&gt;,System.Collections.Generic.IList&lt;T2&gt;,System.Collections.Generic.IList&lt;T3&gt;&gt;&gt;.ConsumeMessage : System.Threading.Tasks.Dataflow.DataflowMessageHeader * System.Threading.Tasks.Dataflow.ITargetBlock&lt;System.Collections.Generic.IList&lt;'T1&gt; * System.Collections.Generic.IList&lt;'T2&gt; * System.Collections.Generic.IList&lt;'T3&gt;&gt; * bool -&gt; System.Collections.Generic.IList&lt;'T1&gt; * System.Collections.Generic.IList&lt;'T2&gt; * System.Collections.Generic.IList&lt;'T3&gt;" Usage="batchedJoinBlock.System.Threading.Tasks.Dataflow.ISourceBlock&lt;System.Tuple&lt;System.Collections.Generic.IList&lt;T1&gt;,System.Collections.Generic.IList&lt;T2&gt;,System.Collections.Generic.IList&lt;T3&gt;&gt;&gt;.ConsumeMessage (messageHeader, target, messageConsumed)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Threading.Tasks.Dataflow.ISourceBlock`1.ConsumeMessage(System.Threading.Tasks.Dataflow.DataflowMessageHeader,System.Threading.Tasks.Dataflow.ITargetBlock{`0},System.Boolean@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Dataflow</AssemblyName>
        <AssemblyVersion>4.5.25.0</AssemblyVersion>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.6.1.0</AssemblyVersion>
        <AssemblyVersion>4.6.2.0</AssemblyVersion>
        <AssemblyVersion>4.6.3.0</AssemblyVersion>
        <AssemblyVersion>4.6.4.0</AssemblyVersion>
        <AssemblyVersion>4.6.5.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Tuple&lt;System.Collections.Generic.IList&lt;T1&gt;,System.Collections.Generic.IList&lt;T2&gt;,System.Collections.Generic.IList&lt;T3&gt;&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="messageHeader" Type="System.Threading.Tasks.Dataflow.DataflowMessageHeader" />
        <Parameter Name="target" Type="System.Threading.Tasks.Dataflow.ITargetBlock&lt;System.Tuple&lt;System.Collections.Generic.IList&lt;T1&gt;,System.Collections.Generic.IList&lt;T2&gt;,System.Collections.Generic.IList&lt;T3&gt;&gt;&gt;" />
        <Parameter Name="messageConsumed" Type="System.Boolean" RefType="out" />
      </Parameters>
      <Docs>
        <param name="messageHeader">要使用的消息的 <see cref="T:System.Threading.Tasks.Dataflow.DataflowMessageHeader" />。</param>
        <param name="target">要为其使用消息的 <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" />。</param>
        <param name="messageConsumed">如果成功使用消息，则为 <see langword="true" />。 否则为 <see langword="false" />。</param>
        <summary>将 <see cref="T:System.Threading.Tasks.Dataflow.DataflowMessageHeader" /> 标识的消息的所有权从此 <see cref="T:System.Threading.Tasks.Dataflow.ISourceBlock`1" /> 实例传递到 <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" />。</summary>
        <returns>所使用的消息的值。 这可能对应于一个 <see cref="T:System.Threading.Tasks.Dataflow.DataflowMessageHeader" /> 实例，该实例不同于之前保留并作为 <paramref name="messageHeader" /> 传递给此方法的实例。 使用的 <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" /> 必须使用返回值而不是作为 <paramref name="messageValue" /> 传递到 <see cref="M:System.Threading.Tasks.Dataflow.ITargetBlock`1.OfferMessage(System.Threading.Tasks.Dataflow.DataflowMessageHeader,`0,System.Threading.Tasks.Dataflow.ISourceBlock{`0},System.Boolean)" /> 的值。 如果所请求的消息不可用，则返回值将是 <see langword="null" />（在 Visual Basic 中为 <see langword="Nothing" />）。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

 <xref:System.Threading.Tasks.Dataflow.ITargetBlock`1>要使用消息的必须与此实例相关联 <xref:System.Threading.Tasks.Dataflow.ISourceBlock`1> 。 此外，此 <xref:System.Threading.Tasks.Dataflow.ISourceBlock`1> 实例可能从未直接向提供消息 <xref:System.Threading.Tasks.Dataflow.ITargetBlock`1> 。  

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="messageHeader" /> 无效。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="target" /> 为 <see langword="null" />（在 Visual Basic 中为 Nothing）。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Threading.Tasks.Dataflow.ISourceBlock&lt;System.Tuple&lt;System.Collections.Generic.IList&lt;T1&gt;,System.Collections.Generic.IList&lt;T2&gt;,System.Collections.Generic.IList&lt;T3&gt;&gt;&gt;.ReleaseReservation">
      <MemberSignature Language="C#" Value="void ISourceBlock&lt;Tuple&lt;IList&lt;T1&gt;,IList&lt;T2&gt;,IList&lt;T3&gt;&gt;&gt;.ReleaseReservation (System.Threading.Tasks.Dataflow.DataflowMessageHeader messageHeader, System.Threading.Tasks.Dataflow.ITargetBlock&lt;Tuple&lt;System.Collections.Generic.IList&lt;T1&gt;,System.Collections.Generic.IList&lt;T2&gt;,System.Collections.Generic.IList&lt;T3&gt;&gt;&gt; target);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Threading.Tasks.Dataflow.ISourceBlock&lt;System.Tuple&lt;System.Collections.Generic.IList&lt;T1&gt;,System.Collections.Generic.IList&lt;T2&gt;,System.Collections.Generic.IList&lt;T3&gt;&gt;&gt;.ReleaseReservation(valuetype System.Threading.Tasks.Dataflow.DataflowMessageHeader messageHeader, class System.Threading.Tasks.Dataflow.ITargetBlock`1&lt;class System.Tuple`3&lt;class System.Collections.Generic.IList`1&lt;!T1&gt;, class System.Collections.Generic.IList`1&lt;!T2&gt;, class System.Collections.Generic.IList`1&lt;!T3&gt;&gt;&gt; target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Dataflow.BatchedJoinBlock`3.System#Threading#Tasks#Dataflow#ISourceBlock&lt;System#Tuple&lt;System#Collections#Generic#IList&lt;T1&gt;,System#Collections#Generic#IList&lt;T2&gt;,System#Collections#Generic#IList&lt;T3&gt;&gt;&gt;#ReleaseReservation(System.Threading.Tasks.Dataflow.DataflowMessageHeader,System.Threading.Tasks.Dataflow.ITargetBlock{System.Tuple{System.Collections.Generic.IList{`0},System.Collections.Generic.IList{`1},System.Collections.Generic.IList{`2}}})" />
      <MemberSignature Language="VB.NET" Value="Sub ReleaseReservation (messageHeader As DataflowMessageHeader, target As ITargetBlock(Of Tuple(Of IList(Of T1), IList(Of T2), IList(Of T3)))) Implements ISourceBlock(Of Tuple(Of IList(Of T1), IList(Of T2), IList(Of T3))).ReleaseReservation" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Threading.Tasks.Dataflow.ISourceBlock&lt;System.Tuple&lt;System.Collections.Generic.IList&lt;T1&gt;,System.Collections.Generic.IList&lt;T2&gt;,System.Collections.Generic.IList&lt;T3&gt;&gt;&gt;.ReleaseReservation(System::Threading::Tasks::Dataflow::DataflowMessageHeader messageHeader, System::Threading::Tasks::Dataflow::ITargetBlock&lt;Tuple&lt;System::Collections::Generic::IList&lt;T1&gt; ^, System::Collections::Generic::IList&lt;T2&gt; ^, System::Collections::Generic::IList&lt;T3&gt; ^&gt; ^&gt; ^ target) = System::Threading::Tasks::Dataflow::ISourceBlock&lt;Tuple&lt;System::Collections::Generic::IList&lt;T1&gt; ^, System::Collections::Generic::IList&lt;T2&gt; ^, System::Collections::Generic::IList&lt;T3&gt; ^&gt; ^&gt;::ReleaseReservation;" />
      <MemberSignature Language="F#" Value="abstract member System.Threading.Tasks.Dataflow.ISourceBlock&lt;System.Tuple&lt;System.Collections.Generic.IList&lt;T1&gt;,System.Collections.Generic.IList&lt;T2&gt;,System.Collections.Generic.IList&lt;T3&gt;&gt;&gt;.ReleaseReservation : System.Threading.Tasks.Dataflow.DataflowMessageHeader * System.Threading.Tasks.Dataflow.ITargetBlock&lt;System.Collections.Generic.IList&lt;'T1&gt; * System.Collections.Generic.IList&lt;'T2&gt; * System.Collections.Generic.IList&lt;'T3&gt;&gt; -&gt; unit&#xA;override this.System.Threading.Tasks.Dataflow.ISourceBlock&lt;System.Tuple&lt;System.Collections.Generic.IList&lt;T1&gt;,System.Collections.Generic.IList&lt;T2&gt;,System.Collections.Generic.IList&lt;T3&gt;&gt;&gt;.ReleaseReservation : System.Threading.Tasks.Dataflow.DataflowMessageHeader * System.Threading.Tasks.Dataflow.ITargetBlock&lt;System.Collections.Generic.IList&lt;'T1&gt; * System.Collections.Generic.IList&lt;'T2&gt; * System.Collections.Generic.IList&lt;'T3&gt;&gt; -&gt; unit" Usage="batchedJoinBlock.System.Threading.Tasks.Dataflow.ISourceBlock&lt;System.Tuple&lt;System.Collections.Generic.IList&lt;T1&gt;,System.Collections.Generic.IList&lt;T2&gt;,System.Collections.Generic.IList&lt;T3&gt;&gt;&gt;.ReleaseReservation (messageHeader, target)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Threading.Tasks.Dataflow.ISourceBlock`1.ReleaseReservation(System.Threading.Tasks.Dataflow.DataflowMessageHeader,System.Threading.Tasks.Dataflow.ITargetBlock{`0})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Dataflow</AssemblyName>
        <AssemblyVersion>4.5.25.0</AssemblyVersion>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.6.1.0</AssemblyVersion>
        <AssemblyVersion>4.6.2.0</AssemblyVersion>
        <AssemblyVersion>4.6.3.0</AssemblyVersion>
        <AssemblyVersion>4.6.4.0</AssemblyVersion>
        <AssemblyVersion>4.6.5.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="messageHeader" Type="System.Threading.Tasks.Dataflow.DataflowMessageHeader" />
        <Parameter Name="target" Type="System.Threading.Tasks.Dataflow.ITargetBlock&lt;System.Tuple&lt;System.Collections.Generic.IList&lt;T1&gt;,System.Collections.Generic.IList&lt;T2&gt;,System.Collections.Generic.IList&lt;T3&gt;&gt;&gt;" />
      </Parameters>
      <Docs>
        <param name="messageHeader">保留的消息的 <see cref="T:System.Threading.Tasks.Dataflow.DataflowMessageHeader" />。</param>
        <param name="target">当前保存保留项的 <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" />。</param>
        <summary>释放将 <see cref="T:System.Threading.Tasks.Dataflow.DataflowMessageHeader" /> 标识的消息的所有权从此 <see cref="T:System.Threading.Tasks.Dataflow.ISourceBlock`1" /> 传递到 <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" /> 的权限。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

 <xref:System.Threading.Tasks.Dataflow.ITargetBlock`1>保留保留的不需要从该 <xref:System.Threading.Tasks.Dataflow.ISourceBlock`1> 实例链接。 此外，此 <xref:System.Threading.Tasks.Dataflow.ISourceBlock`1> 实例可能从未直接向提供消息 <xref:System.Threading.Tasks.Dataflow.ITargetBlock`1> 。
之前，必须为相同的保留此消息 <xref:System.Threading.Tasks.Dataflow.ITargetBlock`1> 。
 

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="messageHeader" /> 无效。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="target" /> 为 <see langword="null" />（在 Visual Basic 中为 Nothing）。</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="target" />未保留消息。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Threading.Tasks.Dataflow.ISourceBlock&lt;System.Tuple&lt;System.Collections.Generic.IList&lt;T1&gt;,System.Collections.Generic.IList&lt;T2&gt;,System.Collections.Generic.IList&lt;T3&gt;&gt;&gt;.ReserveMessage">
      <MemberSignature Language="C#" Value="bool ISourceBlock&lt;Tuple&lt;IList&lt;T1&gt;,IList&lt;T2&gt;,IList&lt;T3&gt;&gt;&gt;.ReserveMessage (System.Threading.Tasks.Dataflow.DataflowMessageHeader messageHeader, System.Threading.Tasks.Dataflow.ITargetBlock&lt;Tuple&lt;System.Collections.Generic.IList&lt;T1&gt;,System.Collections.Generic.IList&lt;T2&gt;,System.Collections.Generic.IList&lt;T3&gt;&gt;&gt; target);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Threading.Tasks.Dataflow.ISourceBlock&lt;System.Tuple&lt;System.Collections.Generic.IList&lt;T1&gt;,System.Collections.Generic.IList&lt;T2&gt;,System.Collections.Generic.IList&lt;T3&gt;&gt;&gt;.ReserveMessage(valuetype System.Threading.Tasks.Dataflow.DataflowMessageHeader messageHeader, class System.Threading.Tasks.Dataflow.ITargetBlock`1&lt;class System.Tuple`3&lt;class System.Collections.Generic.IList`1&lt;!T1&gt;, class System.Collections.Generic.IList`1&lt;!T2&gt;, class System.Collections.Generic.IList`1&lt;!T3&gt;&gt;&gt; target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Dataflow.BatchedJoinBlock`3.System#Threading#Tasks#Dataflow#ISourceBlock&lt;System#Tuple&lt;System#Collections#Generic#IList&lt;T1&gt;,System#Collections#Generic#IList&lt;T2&gt;,System#Collections#Generic#IList&lt;T3&gt;&gt;&gt;#ReserveMessage(System.Threading.Tasks.Dataflow.DataflowMessageHeader,System.Threading.Tasks.Dataflow.ITargetBlock{System.Tuple{System.Collections.Generic.IList{`0},System.Collections.Generic.IList{`1},System.Collections.Generic.IList{`2}}})" />
      <MemberSignature Language="VB.NET" Value="Function ReserveMessage (messageHeader As DataflowMessageHeader, target As ITargetBlock(Of Tuple(Of IList(Of T1), IList(Of T2), IList(Of T3)))) As Boolean Implements ISourceBlock(Of Tuple(Of IList(Of T1), IList(Of T2), IList(Of T3))).ReserveMessage" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Threading.Tasks.Dataflow.ISourceBlock&lt;System.Tuple&lt;System.Collections.Generic.IList&lt;T1&gt;,System.Collections.Generic.IList&lt;T2&gt;,System.Collections.Generic.IList&lt;T3&gt;&gt;&gt;.ReserveMessage(System::Threading::Tasks::Dataflow::DataflowMessageHeader messageHeader, System::Threading::Tasks::Dataflow::ITargetBlock&lt;Tuple&lt;System::Collections::Generic::IList&lt;T1&gt; ^, System::Collections::Generic::IList&lt;T2&gt; ^, System::Collections::Generic::IList&lt;T3&gt; ^&gt; ^&gt; ^ target) = System::Threading::Tasks::Dataflow::ISourceBlock&lt;Tuple&lt;System::Collections::Generic::IList&lt;T1&gt; ^, System::Collections::Generic::IList&lt;T2&gt; ^, System::Collections::Generic::IList&lt;T3&gt; ^&gt; ^&gt;::ReserveMessage;" />
      <MemberSignature Language="F#" Value="abstract member System.Threading.Tasks.Dataflow.ISourceBlock&lt;System.Tuple&lt;System.Collections.Generic.IList&lt;T1&gt;,System.Collections.Generic.IList&lt;T2&gt;,System.Collections.Generic.IList&lt;T3&gt;&gt;&gt;.ReserveMessage : System.Threading.Tasks.Dataflow.DataflowMessageHeader * System.Threading.Tasks.Dataflow.ITargetBlock&lt;System.Collections.Generic.IList&lt;'T1&gt; * System.Collections.Generic.IList&lt;'T2&gt; * System.Collections.Generic.IList&lt;'T3&gt;&gt; -&gt; bool&#xA;override this.System.Threading.Tasks.Dataflow.ISourceBlock&lt;System.Tuple&lt;System.Collections.Generic.IList&lt;T1&gt;,System.Collections.Generic.IList&lt;T2&gt;,System.Collections.Generic.IList&lt;T3&gt;&gt;&gt;.ReserveMessage : System.Threading.Tasks.Dataflow.DataflowMessageHeader * System.Threading.Tasks.Dataflow.ITargetBlock&lt;System.Collections.Generic.IList&lt;'T1&gt; * System.Collections.Generic.IList&lt;'T2&gt; * System.Collections.Generic.IList&lt;'T3&gt;&gt; -&gt; bool" Usage="batchedJoinBlock.System.Threading.Tasks.Dataflow.ISourceBlock&lt;System.Tuple&lt;System.Collections.Generic.IList&lt;T1&gt;,System.Collections.Generic.IList&lt;T2&gt;,System.Collections.Generic.IList&lt;T3&gt;&gt;&gt;.ReserveMessage (messageHeader, target)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Threading.Tasks.Dataflow.ISourceBlock`1.ReserveMessage(System.Threading.Tasks.Dataflow.DataflowMessageHeader,System.Threading.Tasks.Dataflow.ITargetBlock{`0})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Dataflow</AssemblyName>
        <AssemblyVersion>4.5.25.0</AssemblyVersion>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.6.1.0</AssemblyVersion>
        <AssemblyVersion>4.6.2.0</AssemblyVersion>
        <AssemblyVersion>4.6.3.0</AssemblyVersion>
        <AssemblyVersion>4.6.4.0</AssemblyVersion>
        <AssemblyVersion>4.6.5.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="messageHeader" Type="System.Threading.Tasks.Dataflow.DataflowMessageHeader" />
        <Parameter Name="target" Type="System.Threading.Tasks.Dataflow.ITargetBlock&lt;System.Tuple&lt;System.Collections.Generic.IList&lt;T1&gt;,System.Collections.Generic.IList&lt;T2&gt;,System.Collections.Generic.IList&lt;T3&gt;&gt;&gt;" />
      </Parameters>
      <Docs>
        <param name="messageHeader">要保留的消息的 <see cref="T:System.Threading.Tasks.Dataflow.DataflowMessageHeader" />。</param>
        <param name="target">要为其保留消息的 <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" />。</param>
        <summary>保留将 <see cref="T:System.Threading.Tasks.Dataflow.DataflowMessageHeader" /> 标识的消息的所有权从此 <see cref="T:System.Threading.Tasks.Dataflow.ISourceBlock`1" /> 传递到 <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" /> 的权限。</summary>
        <returns>如果已成功保留该消息，则为 <see langword="true" />；否则，为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<xref:System.Threading.Tasks.Dataflow.ITargetBlock`1>要为其保留消息的不需要从该 <xref:System.Threading.Tasks.Dataflow.ISourceBlock`1> 实例链接。 此外，此 <xref:System.Threading.Tasks.Dataflow.ISourceBlock`1> 实例可能从未直接向提供消息 <xref:System.Threading.Tasks.Dataflow.ITargetBlock`1> 。

如果 `true` 返回，则您随后必须对 <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601.ConsumeMessage%2A> <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601.ReleaseReservation%2A> 具有相同和的此消息调用或 <xref:System.Threading.Tasks.Dataflow.DataflowMessageHeader> <xref:System.Threading.Tasks.Dataflow.ITargetBlock`1> 。 如果不这样做，源可能无法向任何目标传播任何进一步的消息。

<xref:System.Threading.Tasks.Dataflow.ISourceBlock%601.ReserveMessage%2A>当目标持有任何内部锁时，请不要调用。 这样做将违反锁层次结构，以避免数据流网络中的死锁。

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="messageHeader" /> 无效。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="target" /> 为 <see langword="null" />（在 Visual Basic 中为 <see langword="Nothing" />）。</exception>
      </Docs>
    </Member>
    <Member MemberName="Target1">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Dataflow.ITargetBlock&lt;T1&gt; Target1 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Threading.Tasks.Dataflow.ITargetBlock`1&lt;!T1&gt; Target1" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Dataflow.BatchedJoinBlock`3.Target1" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Target1 As ITargetBlock(Of T1)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::Tasks::Dataflow::ITargetBlock&lt;T1&gt; ^ Target1 { System::Threading::Tasks::Dataflow::ITargetBlock&lt;T1&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Target1 : System.Threading.Tasks.Dataflow.ITargetBlock&lt;'T1&gt;" Usage="System.Threading.Tasks.Dataflow.BatchedJoinBlock&lt;'T1, 'T2, 'T3&gt;.Target1" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Dataflow</AssemblyName>
        <AssemblyVersion>4.5.25.0</AssemblyVersion>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.6.1.0</AssemblyVersion>
        <AssemblyVersion>4.6.2.0</AssemblyVersion>
        <AssemblyVersion>4.6.3.0</AssemblyVersion>
        <AssemblyVersion>4.6.4.0</AssemblyVersion>
        <AssemblyVersion>4.6.5.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Dataflow.ITargetBlock&lt;T1&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取可用于提供第一种类型的消息的目标。</summary>
        <value>目标。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Target2">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Dataflow.ITargetBlock&lt;T2&gt; Target2 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Threading.Tasks.Dataflow.ITargetBlock`1&lt;!T2&gt; Target2" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Dataflow.BatchedJoinBlock`3.Target2" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Target2 As ITargetBlock(Of T2)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::Tasks::Dataflow::ITargetBlock&lt;T2&gt; ^ Target2 { System::Threading::Tasks::Dataflow::ITargetBlock&lt;T2&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Target2 : System.Threading.Tasks.Dataflow.ITargetBlock&lt;'T2&gt;" Usage="System.Threading.Tasks.Dataflow.BatchedJoinBlock&lt;'T1, 'T2, 'T3&gt;.Target2" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Dataflow</AssemblyName>
        <AssemblyVersion>4.5.25.0</AssemblyVersion>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.6.1.0</AssemblyVersion>
        <AssemblyVersion>4.6.2.0</AssemblyVersion>
        <AssemblyVersion>4.6.3.0</AssemblyVersion>
        <AssemblyVersion>4.6.4.0</AssemblyVersion>
        <AssemblyVersion>4.6.5.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Dataflow.ITargetBlock&lt;T2&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取可用于提供第二种类型的消息的目标。</summary>
        <value>目标。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Target3">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Dataflow.ITargetBlock&lt;T3&gt; Target3 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Threading.Tasks.Dataflow.ITargetBlock`1&lt;!T3&gt; Target3" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Dataflow.BatchedJoinBlock`3.Target3" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Target3 As ITargetBlock(Of T3)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::Tasks::Dataflow::ITargetBlock&lt;T3&gt; ^ Target3 { System::Threading::Tasks::Dataflow::ITargetBlock&lt;T3&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Target3 : System.Threading.Tasks.Dataflow.ITargetBlock&lt;'T3&gt;" Usage="System.Threading.Tasks.Dataflow.BatchedJoinBlock&lt;'T1, 'T2, 'T3&gt;.Target3" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Dataflow</AssemblyName>
        <AssemblyVersion>4.5.25.0</AssemblyVersion>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.6.1.0</AssemblyVersion>
        <AssemblyVersion>4.6.2.0</AssemblyVersion>
        <AssemblyVersion>4.6.3.0</AssemblyVersion>
        <AssemblyVersion>4.6.4.0</AssemblyVersion>
        <AssemblyVersion>4.6.5.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Dataflow.ITargetBlock&lt;T3&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取可用于提供第三种类型消息的目标。</summary>
        <value>目标。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Dataflow.BatchedJoinBlock`3.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="batchedJoinBlock.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Dataflow</AssemblyName>
        <AssemblyVersion>4.5.25.0</AssemblyVersion>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.6.1.0</AssemblyVersion>
        <AssemblyVersion>4.6.2.0</AssemblyVersion>
        <AssemblyVersion>4.6.3.0</AssemblyVersion>
        <AssemblyVersion>4.6.4.0</AssemblyVersion>
        <AssemblyVersion>4.6.5.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回一个字符串，该字符串表示此 <see cref="T:System.Threading.Tasks.Dataflow.IDataflowBlock" /> 实例的格式化名称。</summary>
        <returns>一个字符串，该字符串表示此 <see cref="T:System.Threading.Tasks.Dataflow.IDataflowBlock" /> 实例的格式化名称。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[
          
从 <xref:System.Object> 继承。 使用 <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions.NameFormat?displayProperty=nameWithType> 选项。

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryReceive">
      <MemberSignature Language="C#" Value="public bool TryReceive (Predicate&lt;Tuple&lt;System.Collections.Generic.IList&lt;T1&gt;,System.Collections.Generic.IList&lt;T2&gt;,System.Collections.Generic.IList&lt;T3&gt;&gt;&gt; filter, out Tuple&lt;System.Collections.Generic.IList&lt;T1&gt;,System.Collections.Generic.IList&lt;T2&gt;,System.Collections.Generic.IList&lt;T3&gt;&gt; item);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryReceive(class System.Predicate`1&lt;class System.Tuple`3&lt;class System.Collections.Generic.IList`1&lt;!T1&gt;, class System.Collections.Generic.IList`1&lt;!T2&gt;, class System.Collections.Generic.IList`1&lt;!T3&gt;&gt;&gt; filter, [out] class System.Tuple`3&lt;class System.Collections.Generic.IList`1&lt;!T1&gt;, class System.Collections.Generic.IList`1&lt;!T2&gt;, class System.Collections.Generic.IList`1&lt;!T3&gt;&gt;&amp; item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Dataflow.BatchedJoinBlock`3.TryReceive(System.Predicate{System.Tuple{System.Collections.Generic.IList{`0},System.Collections.Generic.IList{`1},System.Collections.Generic.IList{`2}}},System.Tuple{System.Collections.Generic.IList{`0},System.Collections.Generic.IList{`1},System.Collections.Generic.IList{`2}}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryReceive (filter As Predicate(Of Tuple(Of IList(Of T1), IList(Of T2), IList(Of T3))), ByRef item As Tuple(Of IList(Of T1), IList(Of T2), IList(Of T3))) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool TryReceive(Predicate&lt;Tuple&lt;System::Collections::Generic::IList&lt;T1&gt; ^, System::Collections::Generic::IList&lt;T2&gt; ^, System::Collections::Generic::IList&lt;T3&gt; ^&gt; ^&gt; ^ filter, [Runtime::InteropServices::Out] Tuple&lt;System::Collections::Generic::IList&lt;T1&gt; ^, System::Collections::Generic::IList&lt;T2&gt; ^, System::Collections::Generic::IList&lt;T3&gt; ^&gt; ^ % item);" />
      <MemberSignature Language="F#" Value="abstract member TryReceive : Predicate&lt;System.Collections.Generic.IList&lt;'T1&gt; * System.Collections.Generic.IList&lt;'T2&gt; * System.Collections.Generic.IList&lt;'T3&gt;&gt; * Tuple -&gt; bool&#xA;override this.TryReceive : Predicate&lt;System.Collections.Generic.IList&lt;'T1&gt; * System.Collections.Generic.IList&lt;'T2&gt; * System.Collections.Generic.IList&lt;'T3&gt;&gt; * Tuple -&gt; bool" Usage="batchedJoinBlock.TryReceive (filter, item)" />
      <MemberSignature Language="C#" Value="public bool TryReceive (Predicate&lt;Tuple&lt;System.Collections.Generic.IList&lt;T1&gt;,System.Collections.Generic.IList&lt;T2&gt;,System.Collections.Generic.IList&lt;T3&gt;&gt;&gt;? filter, out Tuple&lt;System.Collections.Generic.IList&lt;T1&gt;,System.Collections.Generic.IList&lt;T2&gt;,System.Collections.Generic.IList&lt;T3&gt;&gt;? item);" FrameworkAlternate="net-5.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Dataflow</AssemblyName>
        <AssemblyVersion>4.5.25.0</AssemblyVersion>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.6.1.0</AssemblyVersion>
        <AssemblyVersion>4.6.2.0</AssemblyVersion>
        <AssemblyVersion>4.6.3.0</AssemblyVersion>
        <AssemblyVersion>4.6.4.0</AssemblyVersion>
        <AssemblyVersion>4.6.5.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filter" Type="System.Predicate&lt;System.Tuple&lt;System.Collections.Generic.IList&lt;T1&gt;,System.Collections.Generic.IList&lt;T2&gt;,System.Collections.Generic.IList&lt;T3&gt;&gt;&gt;" />
        <Parameter Name="item" Type="System.Tuple&lt;System.Collections.Generic.IList&lt;T1&gt;,System.Collections.Generic.IList&lt;T2&gt;,System.Collections.Generic.IList&lt;T3&gt;&gt;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="filter">为使值得到检索，必须成功传递值的谓词。  <paramref name="filter" /> 可能是 <see langword="null" /> ，在此情况下，所有项目均通过。</param>
        <param name="item">从源中检索到的项。</param>
        <summary>从 <see cref="T:System.Threading.Tasks.Dataflow.IReceivableSourceBlock`1" /> 中尝试同步接收可用输出项。</summary>
        <returns>如果可以接收项，则为 <see langword="true" />，否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法不会阻止等待源提供项。  
  
 它将在检查元素后返回，而不管元素是否可用。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryReceiveAll">
      <MemberSignature Language="C#" Value="public bool TryReceiveAll (out System.Collections.Generic.IList&lt;Tuple&lt;System.Collections.Generic.IList&lt;T1&gt;,System.Collections.Generic.IList&lt;T2&gt;,System.Collections.Generic.IList&lt;T3&gt;&gt;&gt; items);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryReceiveAll([out] class System.Collections.Generic.IList`1&lt;class System.Tuple`3&lt;class System.Collections.Generic.IList`1&lt;!T1&gt;, class System.Collections.Generic.IList`1&lt;!T2&gt;, class System.Collections.Generic.IList`1&lt;!T3&gt;&gt;&gt;&amp; items) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Dataflow.BatchedJoinBlock`3.TryReceiveAll(System.Collections.Generic.IList{System.Tuple{System.Collections.Generic.IList{`0},System.Collections.Generic.IList{`1},System.Collections.Generic.IList{`2}}}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryReceiveAll (ByRef items As IList(Of Tuple(Of IList(Of T1), IList(Of T2), IList(Of T3)))) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool TryReceiveAll([Runtime::InteropServices::Out] System::Collections::Generic::IList&lt;Tuple&lt;System::Collections::Generic::IList&lt;T1&gt; ^, System::Collections::Generic::IList&lt;T2&gt; ^, System::Collections::Generic::IList&lt;T3&gt; ^&gt; ^&gt; ^ % items);" />
      <MemberSignature Language="F#" Value="abstract member TryReceiveAll : IList -&gt; bool&#xA;override this.TryReceiveAll : IList -&gt; bool" Usage="batchedJoinBlock.TryReceiveAll items" />
      <MemberSignature Language="C#" Value="public bool TryReceiveAll (out System.Collections.Generic.IList&lt;Tuple&lt;System.Collections.Generic.IList&lt;T1&gt;,System.Collections.Generic.IList&lt;T2&gt;,System.Collections.Generic.IList&lt;T3&gt;&gt;&gt;? items);" FrameworkAlternate="net-5.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Dataflow</AssemblyName>
        <AssemblyVersion>4.5.25.0</AssemblyVersion>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.6.1.0</AssemblyVersion>
        <AssemblyVersion>4.6.2.0</AssemblyVersion>
        <AssemblyVersion>4.6.3.0</AssemblyVersion>
        <AssemblyVersion>4.6.4.0</AssemblyVersion>
        <AssemblyVersion>4.6.5.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="items" Type="System.Collections.Generic.IList&lt;System.Tuple&lt;System.Collections.Generic.IList&lt;T1&gt;,System.Collections.Generic.IList&lt;T2&gt;,System.Collections.Generic.IList&lt;T3&gt;&gt;&gt;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="items">从源中接收的项。</param>
        <summary>从 <see cref="T:System.Threading.Tasks.Dataflow.IReceivableSourceBlock`1" /> 中尝试同步接收所有可用项。</summary>
        <returns>如果可以接收一个或多个项目，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法不会阻止等待源提供项。  
  
 它将在检查元素后返回，而不管元素是否可用。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
