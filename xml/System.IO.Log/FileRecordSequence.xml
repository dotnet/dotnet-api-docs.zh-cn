<Type Name="FileRecordSequence" FullName="System.IO.Log.FileRecordSequence">
  <Metadata><Meta Name="ms.openlocfilehash" Value="7913ddc7e782dabece5d2493ae49f762f445e861" /><Meta Name="ms.sourcegitcommit" Value="b53d35b4a410c949742abd4c6a989d1af5357bca" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-CN" /><Meta Name="ms.lasthandoff" Value="07/21/2020" /><Meta Name="ms.locfileid" Value="86814634" /></Metadata><TypeSignature Language="C#" Value="public sealed class FileRecordSequence : IDisposable, System.IO.Log.IRecordSequence" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit FileRecordSequence extends System.Object implements class System.IDisposable, class System.IO.Log.IRecordSequence" />
  <TypeSignature Language="DocId" Value="T:System.IO.Log.FileRecordSequence" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class FileRecordSequence&#xA;Implements IDisposable, IRecordSequence" />
  <TypeSignature Language="C++ CLI" Value="public ref class FileRecordSequence sealed : IDisposable, System::IO::Log::IRecordSequence" />
  <TypeSignature Language="F#" Value="type FileRecordSequence = class&#xA;    interface IRecordSequence&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.IO.Log</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IO.Log.IRecordSequence</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>在文件上实现 <see cref="T:System.IO.Log.IRecordSequence" />。 此类不能被继承。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Log.FileRecordSequence> 是基于文件系统中的单一日志文件的记录序列。 它是 <xref:System.IO.Log.IRecordSequence> 接口在基于简单文件的日志之上的简单实现。  
  
 若要操作基于文件的日志，运行应用程序时使用的帐户必须具有足够的特权，这与构造 <xref:System.IO.Log.FileRecordSequence> 时文件系统安全性所规定的要求是相同的。 此外，在构造时要发出 FullTrust 请求。 此后，要对权限验证结果进行缓存，以便与 Windows 安全模式保持一致。 应该确保您没有意外地向未授权用户公开记录序列的内容。  
  
   
  
## Examples  
 下面的示例创建一个记录序列，向该序列追加记录，最后读取这些记录。  
  
 [!code-csharp[IRecordSequence#1](~/samples/snippets/csharp/VS_Snippets_CFX/irecordsequence/cs/readrecord.cs#1)]
 [!code-vb[IRecordSequence#1](~/samples/snippets/visualbasic/VS_Snippets_CFX/irecordsequence/vb/readrecord.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>初始化 <see cref="T:System.IO.Log.FileRecordSequence" /> 类的新实例。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileRecordSequence (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.FileRecordSequence.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileRecordSequence(System::String ^ path);" />
      <MemberSignature Language="F#" Value="new System.IO.Log.FileRecordSequence : string -&gt; System.IO.Log.FileRecordSequence" Usage="new System.IO.Log.FileRecordSequence path" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">此 <see cref="T:System.IO.Log.FileRecordSequence" /> 实例将封装的文件的相对路径或绝对路径。</param>
        <summary>使用指定的文件初始化 <see cref="T:System.IO.Log.FileRecordSequence" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此构造函数创建对文件的读/写访问权限，并使用共享读访问权限打开该文件。 这意味着，此进程或另一进程打开文件进行写入的请求将失败，直到已释放此 <xref:System.IO.Log.FileRecordSequence> 实例，但读取尝试将会成功。 如果找不到 `path`，将创建一个大小为 0 字节的新文件。  
  
   
  
## Examples  
 下面的示例创建一个记录序列，向该序列追加记录，读取记录，最后处置序列。  
  
 [!code-csharp[IRecordSequence#1](~/samples/snippets/csharp/VS_Snippets_CFX/irecordsequence/cs/readrecord.cs#1)]
 [!code-vb[IRecordSequence#1](~/samples/snippets/visualbasic/VS_Snippets_CFX/irecordsequence/vb/readrecord.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> 指定的文件无效。</exception>
        <exception cref="T:System.IO.FileNotFoundException">找不到 <paramref name="path" /> 指定的文件。</exception>
        <exception cref="T:System.IO.IOException">由于出现意外的 I/O 异常，因此无法执行该请求。</exception>
        <exception cref="T:System.OutOfMemoryException">没有足够的内存来继续执行该程序。</exception>
        <exception cref="T:System.UnauthorizedAccessException">操作系统拒绝了对指定的日志存储区的访问。</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileRecordSequence (string path, System.IO.FileAccess access);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileAccess access) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.FileRecordSequence.#ctor(System.String,System.IO.FileAccess)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, access As FileAccess)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileRecordSequence(System::String ^ path, System::IO::FileAccess access);" />
      <MemberSignature Language="F#" Value="new System.IO.Log.FileRecordSequence : string * System.IO.FileAccess -&gt; System.IO.Log.FileRecordSequence" Usage="new System.IO.Log.FileRecordSequence (path, access)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
      </Parameters>
      <Docs>
        <param name="path">此 <see cref="T:System.IO.Log.FileRecordSequence" /> 实例将封装的文件的相对路径或绝对路径。</param>
        <param name="access">一个有效的 <see cref="T:System.IO.FileAccess" /> 值，用于控制用户对日志文件的访问类型。</param>
        <summary>使用指定的文件和访问模式初始化 <see cref="T:System.IO.Log.FileRecordSequence" /> 类的新实例。</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> 指定的文件无效。</exception>
        <exception cref="T:System.IO.FileNotFoundException">找不到 <paramref name="path" /> 指定的文件。</exception>
        <exception cref="T:System.IO.IOException">由于出现意外的 I/O 异常，因此无法执行该请求。</exception>
        <exception cref="T:System.OutOfMemoryException">没有足够的内存来继续执行该程序。</exception>
        <exception cref="T:System.UnauthorizedAccessException">操作系统拒绝了对指定的日志存储区的访问。</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileRecordSequence (string path, System.IO.FileAccess access, int size);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileAccess access, int32 size) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.FileRecordSequence.#ctor(System.String,System.IO.FileAccess,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, access As FileAccess, size As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileRecordSequence(System::String ^ path, System::IO::FileAccess access, int size);" />
      <MemberSignature Language="F#" Value="new System.IO.Log.FileRecordSequence : string * System.IO.FileAccess * int -&gt; System.IO.Log.FileRecordSequence" Usage="new System.IO.Log.FileRecordSequence (path, access, size)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="size" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="path">此 <see cref="T:System.IO.Log.FileRecordSequence" /> 实例将封装的文件的相对路径或绝对路径。</param>
        <param name="access">一个有效的 <see cref="T:System.IO.FileAccess" /> 值，用于控制用户对日志文件的访问类型。</param>
        <param name="size">要打开的日志文件的大小。</param>
        <summary>使用指定的文件、访问模式和文件大小初始化 <see cref="T:System.IO.Log.FileRecordSequence" /> 类的新实例。</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">一个或多个参数超出有效范围。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> 指定的文件无效。</exception>
        <exception cref="T:System.IO.FileNotFoundException">找不到 <paramref name="path" /> 指定的文件。</exception>
        <exception cref="T:System.IO.IOException">由于出现意外的 I/O 异常，因此无法执行该请求。</exception>
        <exception cref="T:System.OutOfMemoryException">没有足够的内存来继续执行该程序。</exception>
        <exception cref="T:System.UnauthorizedAccessException">操作系统拒绝了对指定的日志存储区的访问。</exception>
      </Docs>
    </Member>
    <Member MemberName="AdvanceBaseSequenceNumber">
      <MemberSignature Language="C#" Value="public void AdvanceBaseSequenceNumber (System.IO.Log.SequenceNumber newBaseSequenceNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AdvanceBaseSequenceNumber(valuetype System.IO.Log.SequenceNumber newBaseSequenceNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.FileRecordSequence.AdvanceBaseSequenceNumber(System.IO.Log.SequenceNumber)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AdvanceBaseSequenceNumber (newBaseSequenceNumber As SequenceNumber)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void AdvanceBaseSequenceNumber(System::IO::Log::SequenceNumber newBaseSequenceNumber);" />
      <MemberSignature Language="F#" Value="abstract member AdvanceBaseSequenceNumber : System.IO.Log.SequenceNumber -&gt; unit&#xA;override this.AdvanceBaseSequenceNumber : System.IO.Log.SequenceNumber -&gt; unit" Usage="fileRecordSequence.AdvanceBaseSequenceNumber newBaseSequenceNumber" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.AdvanceBaseSequenceNumber(System.IO.Log.SequenceNumber)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="newBaseSequenceNumber" Type="System.IO.Log.SequenceNumber" />
      </Parameters>
      <Docs>
        <param name="newBaseSequenceNumber">记录序列的新的基序列号。</param>
        <summary>前移日志的基序列号。 无法继承此方法。</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException"><paramref name="newBaseSequenceNumber" /> 无效。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="newBaseSequenceNumber" /> 不在此序列的基序列号和最后一个序列号之间。</exception>
        <exception cref="T:System.IO.IOException">修改序列时，发生了 I/O 错误。</exception>
        <exception cref="T:System.ObjectDisposedException">该方法是在序列已释放之后调用的。</exception>
        <exception cref="T:System.OutOfMemoryException">没有足够的内存来继续执行该程序。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Append">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>将日志记录写入 <see cref="T:System.IO.Log.FileRecordSequence" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下面的示例创建一个记录序列，向该序列追加记录，最后读取这些记录。  
  
 [!code-csharp[IRecordSequence#0](~/samples/snippets/csharp/VS_Snippets_CFX/irecordsequence/cs/readrecord.cs#0)]
 [!code-vb[IRecordSequence#0](~/samples/snippets/visualbasic/VS_Snippets_CFX/irecordsequence/vb/readrecord.vb#0)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber Append (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber Append(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.FileRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (data As ArraySegment(Of Byte), nextUndoRecord As SequenceNumber, previousRecord As SequenceNumber, recordAppendOptions As RecordAppendOptions) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber Append(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions);" />
      <MemberSignature Language="F#" Value="abstract member Append : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions -&gt; System.IO.Log.SequenceNumber&#xA;override this.Append : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions -&gt; System.IO.Log.SequenceNumber" Usage="fileRecordSequence.Append (data, nextUndoRecord, previousRecord, recordAppendOptions)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
      </Parameters>
      <Docs>
        <param name="data">将连接在一起并以记录形式追加的字节数组段的列表。</param>
        <param name="nextUndoRecord">用户指定顺序中下一条记录的序列号。</param>
        <param name="previousRecord">“上一个”顺序中下一条记录的序列号。</param>
        <param name="recordAppendOptions"><see cref="T:System.IO.Log.RecordAppendOptions" /> 的一个有效值，用于指定应如何写入数据。</param>
        <summary>将日志记录写入 <see cref="T:System.IO.Log.FileRecordSequence" />。 无法继承此方法。</summary>
        <returns>追加的日志记录的序列号。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 包含在 `data` 参数中的数据将连接成单个字节数组，以便以记录形式追加。 但在读取记录时，无法将数据重新拆分为数组段。  
  
 通常，此方法在写入记录之前完成。 若要确保记录已写入，请使用 <xref:System.IO.Log.RecordAppendOptions.ForceFlush> 参数指定 `recordAppendOptions` 标志，或者调用 <xref:System.IO.Log.FileRecordSequence.Flush%2A> 方法。  
  
   
  
## Examples  
 下面的示例创建一个记录序列，向该序列追加记录，最后读取这些记录。  
  
 [!code-csharp[FileRecordSequence#0](~/samples/snippets/csharp/VS_Snippets_CFX/filerecordsequence/cs/filerecordsequence.cs#0)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">一个或多个参数为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">一个或多个自变量超出范围。</exception>
        <exception cref="T:System.NotSupportedException">由于记录序列是通过只读访问权限打开的，因此无法执行该操作。</exception>
        <exception cref="T:System.IO.IOException">由于出现意外的 I/O 异常，因此无法执行该请求。</exception>
        <exception cref="T:System.ObjectDisposedException">该方法是在序列已释放之后调用的。</exception>
        <exception cref="T:System.OutOfMemoryException">没有足够的内存来继续执行该程序。</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">记录序列已满。</exception>
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber Append (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber Append(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.FileRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (data As IList(Of ArraySegment(Of Byte)), nextUndoRecord As SequenceNumber, previousRecord As SequenceNumber, recordAppendOptions As RecordAppendOptions) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber Append(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions);" />
      <MemberSignature Language="F#" Value="abstract member Append : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions -&gt; System.IO.Log.SequenceNumber&#xA;override this.Append : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions -&gt; System.IO.Log.SequenceNumber" Usage="fileRecordSequence.Append (data, nextUndoRecord, previousRecord, recordAppendOptions)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
      </Parameters>
      <Docs>
        <param name="data">将连接在一起并以记录形式追加的字节数组段的列表。</param>
        <param name="nextUndoRecord">用户指定顺序中下一条记录的序列号。</param>
        <param name="previousRecord">“上一个”顺序中下一条记录的序列号。</param>
        <param name="recordAppendOptions"><see cref="T:System.IO.Log.RecordAppendOptions" /> 的一个有效值，用于指定应如何写入数据。</param>
        <summary>将日志记录写入 <see cref="T:System.IO.Log.FileRecordSequence" />。 无法继承此方法。</summary>
        <returns>追加的日志记录的序列号。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 包含在 `data` 参数中的数据将连接成单个字节数组，以便以记录形式追加。 但在读取记录时，无法将数据重新拆分为数组段。  
  
 通常，此方法在写入记录之前完成。 若要确保记录已写入，请使用 <xref:System.IO.Log.RecordAppendOptions.ForceFlush> 参数指定 `recordAppendOptions` 标志，或者调用 <xref:System.IO.Log.FileRecordSequence.Flush%2A> 方法。  
  
   
  
## Examples  
 下面的示例演示如何使用此方法创建记录序列。  
  
 [!code-csharp[IRecordSequence#3](~/samples/snippets/csharp/VS_Snippets_CFX/irecordsequence/cs/readrecord.cs#3)] 
 [!code-vb[IRecordSequence#3](~/samples/snippets/visualbasic/VS_Snippets_CFX/irecordsequence/vb/readrecord.vb#3)]   
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">一个或多个参数为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">一个或多个自变量超出范围。</exception>
        <exception cref="T:System.NotSupportedException">由于记录序列是通过只读访问权限打开的，因此无法执行该操作。</exception>
        <exception cref="T:System.IO.IOException">由于出现意外的 I/O 异常，因此无法执行该请求。</exception>
        <exception cref="T:System.ObjectDisposedException">该方法是在序列已释放之后调用的。</exception>
        <exception cref="T:System.OutOfMemoryException">没有足够的内存来继续执行该程序。</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">记录序列已满。</exception>
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber Append (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservations);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber Append(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.IO.Log.ReservationCollection reservations) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.FileRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (data As ArraySegment(Of Byte), nextUndoRecord As SequenceNumber, previousRecord As SequenceNumber, recordAppendOptions As RecordAppendOptions, reservations As ReservationCollection) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber Append(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, System::IO::Log::ReservationCollection ^ reservations);" />
      <MemberSignature Language="F#" Value="abstract member Append : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection -&gt; System.IO.Log.SequenceNumber&#xA;override this.Append : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection -&gt; System.IO.Log.SequenceNumber" Usage="fileRecordSequence.Append (data, nextUndoRecord, previousRecord, recordAppendOptions, reservations)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="reservations" Type="System.IO.Log.ReservationCollection" />
      </Parameters>
      <Docs>
        <param name="data">将连接在一起并以记录形式追加的字节数组段的列表。</param>
        <param name="nextUndoRecord">用户指定顺序中下一条记录的序列号。</param>
        <param name="previousRecord">“上一个”顺序中下一条记录的序列号。</param>
        <param name="recordAppendOptions"><see cref="T:System.IO.Log.RecordAppendOptions" /> 的一个有效值，用于指定应如何写入数据。</param>
        <param name="reservations">一个 <see cref="T:System.IO.Log.ReservationCollection" />，它包含应当用于此记录的预留。</param>
        <summary>使用序列中先前保留的空间将日志记录写入 <see cref="T:System.IO.Log.FileRecordSequence" />。 无法继承此方法。</summary>
        <returns>追加的日志记录的序列号。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 包含在 `data` 参数中的数据将连接成单个字节数组，以便以记录形式追加。 但在读取记录时，无法将数据重新拆分为数组段。  
  
 追加的记录将使用 `reservations` 参数指定的预留来占用先前已预留的空间。 如果追加成功，它将占用能容纳数据的最小预留区域，而该预留区域将从集合中移除。  
  
 通常，此方法在写入记录之前完成。 若要确保记录已写入，请使用 <xref:System.IO.Log.RecordAppendOptions.ForceFlush> 参数指定 `recordAppendOptions` 标志，或者调用 <xref:System.IO.Log.FileRecordSequence.Flush%2A> 方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">一个或多个参数为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">一个或多个自变量超出范围。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="reservations" /> 不是由此记录序列创建的。</exception>
        <exception cref="T:System.NotSupportedException">由于记录序列是通过只读访问权限打开的，因此无法执行该操作。</exception>
        <exception cref="T:System.IO.IOException">由于出现意外的 I/O 异常，因此无法执行该请求。</exception>
        <exception cref="T:System.ObjectDisposedException">该方法是在序列已释放之后调用的。</exception>
        <exception cref="T:System.OutOfMemoryException">没有足够的内存来继续执行该程序。</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">记录序列已满。</exception>
        <exception cref="T:System.IO.Log.ReservationNotFoundException">在 <paramref name="data" /> 中找不到足以容纳 <paramref name="reservations" /> 的预留。</exception>
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber Append (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservations);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber Append(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.IO.Log.ReservationCollection reservations) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.FileRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (data As IList(Of ArraySegment(Of Byte)), nextUndoRecord As SequenceNumber, previousRecord As SequenceNumber, recordAppendOptions As RecordAppendOptions, reservations As ReservationCollection) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber Append(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, System::IO::Log::ReservationCollection ^ reservations);" />
      <MemberSignature Language="F#" Value="abstract member Append : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection -&gt; System.IO.Log.SequenceNumber&#xA;override this.Append : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection -&gt; System.IO.Log.SequenceNumber" Usage="fileRecordSequence.Append (data, nextUndoRecord, previousRecord, recordAppendOptions, reservations)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="reservations" Type="System.IO.Log.ReservationCollection" />
      </Parameters>
      <Docs>
        <param name="data">将连接在一起并以记录形式追加的字节数组段的列表。</param>
        <param name="nextUndoRecord">用户指定顺序中下一条记录的序列号。</param>
        <param name="previousRecord">“上一个”顺序中下一条记录的序列号。</param>
        <param name="recordAppendOptions"><see cref="T:System.IO.Log.RecordAppendOptions" /> 的一个有效值，用于指定应如何写入数据。</param>
        <param name="reservations">一个 <see cref="T:System.IO.Log.ReservationCollection" />，它包含应当用于此记录的预留。</param>
        <summary>使用序列中先前保留的空间将日志记录写入 <see cref="T:System.IO.Log.FileRecordSequence" />。 无法继承此方法。</summary>
        <returns>追加的日志记录的序列号。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 包含在 `data` 参数中的数据将连接成单个字节数组，以便以记录形式追加。 但在读取记录时，无法将数据重新拆分为数组段。  
  
 追加的记录将使用 `reservations` 参数指定的预留来占用先前已预留的空间。 如果追加成功，它将占用能容纳数据的最小预留区域，而该预留区域将从集合中移除。  
  
 通常，此方法在写入记录之前完成。 若要确保记录已写入，请使用 <xref:System.IO.Log.RecordAppendOptions.ForceFlush> 参数指定 `recordAppendOptions` 标志，或者调用 <xref:System.IO.Log.FileRecordSequence.Flush%2A> 方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">一个或多个参数为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">一个或多个自变量超出范围。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="reservations" /> 不是由此记录序列创建的。</exception>
        <exception cref="T:System.NotSupportedException">由于记录序列是通过只读访问权限打开的，因此无法执行该操作。</exception>
        <exception cref="T:System.IO.IOException">由于出现意外的 I/O 异常，因此无法执行该请求。</exception>
        <exception cref="T:System.ObjectDisposedException">该方法是在序列已释放之后调用的。</exception>
        <exception cref="T:System.OutOfMemoryException">没有足够的内存来继续执行该程序。</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">记录序列已满。</exception>
        <exception cref="T:System.IO.Log.ReservationNotFoundException">在 <paramref name="data" /> 中找不到足以容纳 <paramref name="reservations" /> 的预留。</exception>
      </Docs>
    </Member>
    <Member MemberName="BaseSequenceNumber">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber BaseSequenceNumber { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.IO.Log.SequenceNumber BaseSequenceNumber" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.FileRecordSequence.BaseSequenceNumber" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property BaseSequenceNumber As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Log::SequenceNumber BaseSequenceNumber { System::IO::Log::SequenceNumber get(); };" />
      <MemberSignature Language="F#" Value="member this.BaseSequenceNumber : System.IO.Log.SequenceNumber" Usage="System.IO.Log.FileRecordSequence.BaseSequenceNumber" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IO.Log.IRecordSequence.BaseSequenceNumber</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取当前 <see cref="T:System.IO.Log.FileRecordSequence" /> 中第一条有效记录的序列号。</summary>
        <value>与 <see cref="T:System.IO.Log.FileRecordSequence" /> 中的有效记录对应的最低序列号。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 有效序列号大于或等于 <xref:System.IO.Log.FileRecordSequence.BaseSequenceNumber%2A> 且小于 <xref:System.IO.Log.FileRecordSequence.LastSequenceNumber%2A>。 所有其他序列号均无效。  
  
 此属性的值可以通过调用 <xref:System.IO.Log.FileRecordSequence.WriteRestartArea%2A> 或 <xref:System.IO.Log.FileRecordSequence.AdvanceBaseSequenceNumber%2A> 方法来更改。  
  
   
  
## Examples  
 下面的示例演示如何在循环中使用 <xref:System.IO.Log.FileRecordSequence.BaseSequenceNumber%2A>：  
  
 [!code-csharp[IRecordSequence#2](~/samples/snippets/csharp/VS_Snippets_CFX/irecordsequence/cs/readrecord.cs#2)]
 [!code-vb[IRecordSequence#2](~/samples/snippets/visualbasic/VS_Snippets_CFX/irecordsequence/vb/readrecord.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">该属性是在序列已释放之后访问的。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginAppend">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>开始异步追加操作。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginAppend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginAppend (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginAppend(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.FileRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginAppend (data As ArraySegment(Of Byte), nextUndoRecord As SequenceNumber, previousRecord As SequenceNumber, recordAppendOptions As RecordAppendOptions, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginAppend(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginAppend : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginAppend : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * AsyncCallback * obj -&gt; IAsyncResult" Usage="fileRecordSequence.BeginAppend (data, nextUndoRecord, previousRecord, recordAppendOptions, callback, state)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="data">将连接在一起并以记录形式追加的字节数组段的列表。</param>
        <param name="nextUndoRecord">用户指定顺序中下一条记录的序列号。</param>
        <param name="previousRecord">“上一个”顺序中下一条记录的序列号。</param>
        <param name="recordAppendOptions"><see cref="T:System.IO.Log.RecordAppendOptions" /> 的一个有效值，用于指定应如何写入数据。</param>
        <param name="callback">可选的异步回调，在追加完成时调用。</param>
        <param name="state">用户提供的对象，用于将此特定异步追加请求与其他请求区别开来。</param>
        <summary>开始异步追加操作。 无法继承此方法。</summary>
        <returns>一个 <see cref="T:System.IAsyncResult" />，它表示可能仍处于挂起状态的异步追加。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 应将此方法返回的 <xref:System.IAsyncResult> 传递给 <xref:System.IO.Log.FileRecordSequence.EndAppend%2A> 方法，以确保追加操作已完成并能够适当释放资源。 如果在异步追加过程中发生错误，则在使用此方法返回的 <xref:System.IO.Log.FileRecordSequence.EndAppend%2A> 调用 <xref:System.IAsyncResult> 方法之前，不会引发异常。  
  
 包含在 `data` 参数中的数据将连接成单个字节数组，以便以记录形式追加。 但在读取记录时，无法将数据重新拆分为数组段。  
  
 通常，此方法在写入记录之前完成。 若要确保记录已写入，请使用 <xref:System.IO.Log.RecordAppendOptions.ForceFlush> 参数指定 `recordAppendOptions` 标志，或者调用 <xref:System.IO.Log.FileRecordSequence.Flush%2A> 方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">一个或多个参数为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">一个或多个自变量超出范围。</exception>
        <exception cref="T:System.NotSupportedException">由于记录序列是通过只读访问权限打开的，因此无法执行该操作。</exception>
        <exception cref="T:System.IO.IOException">由于出现意外的 I/O 异常，因此无法执行该请求。</exception>
        <exception cref="T:System.ObjectDisposedException">该方法是在序列已释放之后调用的。</exception>
        <exception cref="T:System.OutOfMemoryException">没有足够的内存来继续执行该程序。</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">记录序列已满。</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginAppend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginAppend (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginAppend(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.FileRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginAppend (data As IList(Of ArraySegment(Of Byte)), nextUndoRecord As SequenceNumber, previousRecord As SequenceNumber, recordAppendOptions As RecordAppendOptions, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginAppend(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginAppend : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginAppend : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * AsyncCallback * obj -&gt; IAsyncResult" Usage="fileRecordSequence.BeginAppend (data, nextUndoRecord, previousRecord, recordAppendOptions, callback, state)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="data">将连接在一起并以记录形式追加的字节数组段的列表。</param>
        <param name="nextUndoRecord">用户指定顺序中下一条记录的序列号。</param>
        <param name="previousRecord">“上一个”顺序中下一条记录的序列号。</param>
        <param name="recordAppendOptions"><see cref="T:System.IO.Log.RecordAppendOptions" /> 的一个有效值，用于指定应如何写入数据。</param>
        <param name="callback">可选的异步回调，在追加完成时调用。</param>
        <param name="state">用户提供的对象，用于将此特定异步追加请求与其他请求区别开来。</param>
        <summary>开始异步追加操作。 无法继承此方法。</summary>
        <returns>一个 <see cref="T:System.IAsyncResult" />，它表示可能仍处于挂起状态的异步追加。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 应将此方法返回的 <xref:System.IAsyncResult> 传递给 <xref:System.IO.Log.FileRecordSequence.EndAppend%2A> 方法，以确保追加操作已完成并能够适当释放资源。 如果在异步追加过程中发生错误，则在使用此方法返回的 <xref:System.IO.Log.FileRecordSequence.EndAppend%2A> 调用 <xref:System.IAsyncResult> 方法之前，不会引发异常。  
  
 包含在 `data` 参数中的数据将连接成单个字节数组，以便以记录形式追加。 但在读取记录时，无法将数据重新拆分为数组段。  
  
 通常，此方法在写入记录之前完成。 若要确保记录已写入，请使用 <xref:System.IO.Log.RecordAppendOptions.ForceFlush> 参数指定 `recordAppendOptions` 标志，或者调用 <xref:System.IO.Log.FileRecordSequence.Flush%2A> 方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">一个或多个参数为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">一个或多个自变量超出范围。</exception>
        <exception cref="T:System.NotSupportedException">由于记录序列是通过只读访问权限打开的，因此无法执行该操作。</exception>
        <exception cref="T:System.IO.IOException">由于出现意外的 I/O 异常，因此无法执行该请求。</exception>
        <exception cref="T:System.ObjectDisposedException">该方法是在序列已释放之后调用的。</exception>
        <exception cref="T:System.OutOfMemoryException">没有足够的内存来继续执行该程序。</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">记录序列已满。</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginAppend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginAppend (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservations, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginAppend(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.IO.Log.ReservationCollection reservations, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.FileRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginAppend (data As ArraySegment(Of Byte), nextUndoRecord As SequenceNumber, previousRecord As SequenceNumber, recordAppendOptions As RecordAppendOptions, reservations As ReservationCollection, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginAppend(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, System::IO::Log::ReservationCollection ^ reservations, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginAppend : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection * AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginAppend : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection * AsyncCallback * obj -&gt; IAsyncResult" Usage="fileRecordSequence.BeginAppend (data, nextUndoRecord, previousRecord, recordAppendOptions, reservations, callback, state)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="reservations" Type="System.IO.Log.ReservationCollection" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="data">将连接在一起并以记录形式追加的字节数组段的列表。</param>
        <param name="nextUndoRecord">用户指定顺序中下一条记录的序列号。</param>
        <param name="previousRecord">“上一个”顺序中下一条记录的序列号。</param>
        <param name="recordAppendOptions"><see cref="T:System.IO.Log.RecordAppendOptions" /> 的一个有效值，用于指定应如何写入数据。</param>
        <param name="reservations">一个 <see cref="T:System.IO.Log.ReservationCollection" />，它包含应当用于此记录的预留。</param>
        <param name="callback">可选的异步回调，在追加完成时调用。</param>
        <param name="state">用户提供的对象，用于将此特定异步追加请求与其他请求区别开来。</param>
        <summary>使用序列中先前保留的空间开始异步追加操作。 无法继承此方法。</summary>
        <returns>一个 <see cref="T:System.IAsyncResult" />，它表示可能仍处于挂起状态的异步追加。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 应将此方法返回的 <xref:System.IAsyncResult> 传递给 <xref:System.IO.Log.FileRecordSequence.EndAppend%2A> 方法，以确保追加操作已完成并能够适当释放资源。 如果在异步追加过程中发生错误，则在使用此方法返回的 <xref:System.IO.Log.FileRecordSequence.EndAppend%2A> 调用 <xref:System.IAsyncResult> 方法之前，不会引发异常。  
  
 包含在 `data` 参数中的数据将连接成单个字节数组，以便以记录形式追加。 但在读取记录时，无法将数据重新拆分为数组段。  
  
 追加的记录将使用 `reservations` 参数指定的预留来占用先前已预留的空间。 如果追加成功，它将占用能容纳数据的最小预留区域，而该预留区域将从集合中移除。  
  
 通常，此方法在写入记录之前完成。 若要确保记录已写入，请使用 <xref:System.IO.Log.RecordAppendOptions.ForceFlush> 参数指定 `recordAppendOptions` 标志，或者调用 <xref:System.IO.Log.FileRecordSequence.Flush%2A> 方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">一个或多个参数为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">一个或多个自变量超出范围。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="reservations" /> 不是由此记录序列创建的。</exception>
        <exception cref="T:System.NotSupportedException">由于记录序列是通过只读访问权限打开的，因此无法执行该操作。</exception>
        <exception cref="T:System.IO.IOException">由于出现意外的 I/O 异常，因此无法执行该请求。</exception>
        <exception cref="T:System.ObjectDisposedException">该方法是在序列已释放之后调用的。</exception>
        <exception cref="T:System.OutOfMemoryException">没有足够的内存来继续执行该程序。</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">记录序列已满。</exception>
        <exception cref="T:System.IO.Log.ReservationNotFoundException">在 <paramref name="data" /> 中找不到足以容纳 <paramref name="reservations" /> 的预留。</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginAppend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginAppend (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservations, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginAppend(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.IO.Log.ReservationCollection reservations, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.FileRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginAppend (data As IList(Of ArraySegment(Of Byte)), nextUndoRecord As SequenceNumber, previousRecord As SequenceNumber, recordAppendOptions As RecordAppendOptions, reservations As ReservationCollection, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginAppend(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, System::IO::Log::ReservationCollection ^ reservations, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginAppend : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection * AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginAppend : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection * AsyncCallback * obj -&gt; IAsyncResult" Usage="fileRecordSequence.BeginAppend (data, nextUndoRecord, previousRecord, recordAppendOptions, reservations, callback, state)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="reservations" Type="System.IO.Log.ReservationCollection" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="data">将连接在一起并以记录形式追加的字节数组段的列表。</param>
        <param name="nextUndoRecord">用户指定顺序中下一条记录的序列号。</param>
        <param name="previousRecord">“上一个”顺序中下一条记录的序列号。</param>
        <param name="recordAppendOptions"><see cref="T:System.IO.Log.RecordAppendOptions" /> 的一个有效值，用于指定应如何写入数据。</param>
        <param name="reservations">一个 <see cref="T:System.IO.Log.ReservationCollection" />，它包含应当用于此记录的预留。</param>
        <param name="callback">可选的异步回调，在追加完成时调用。</param>
        <param name="state">用户提供的对象，用于将此特定异步追加请求与其他请求区别开来。</param>
        <summary>使用序列中先前保留的空间开始异步追加操作。 无法继承此方法。</summary>
        <returns>一个 <see cref="T:System.IAsyncResult" />，它表示可能仍处于挂起状态的异步追加。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 应将此方法返回的 <xref:System.IAsyncResult> 传递给 <xref:System.IO.Log.FileRecordSequence.EndAppend%2A> 方法，以确保追加操作已完成并能够适当释放资源。 如果在异步追加过程中发生错误，则在使用此方法返回的 <xref:System.IO.Log.FileRecordSequence.EndAppend%2A> 调用 <xref:System.IAsyncResult> 方法之前，不会引发异常。  
  
 包含在 `data` 参数中的数据将连接成单个字节数组，以便以记录形式追加。 但在读取记录时，无法将数据重新拆分为数组段。  
  
 追加的记录将使用 `reservations` 参数指定的预留来占用先前已预留的空间。 如果追加成功，它将占用能容纳数据的最小预留区域，而该预留区域将从集合中移除。  
  
 通常，此方法在写入记录之前完成。 若要确保记录已写入，请使用 <xref:System.IO.Log.RecordAppendOptions.ForceFlush> 参数指定 `recordAppendOptions` 标志，或者调用 <xref:System.IO.Log.FileRecordSequence.Flush%2A> 方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">一个或多个参数为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">一个或多个自变量超出范围。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="reservations" /> 不是由此记录序列创建的。</exception>
        <exception cref="T:System.NotSupportedException">由于记录序列是通过只读访问权限打开的，因此无法执行该操作。</exception>
        <exception cref="T:System.IO.IOException">由于出现意外的 I/O 异常，因此无法执行该请求。</exception>
        <exception cref="T:System.ObjectDisposedException">该方法是在序列已释放之后调用的。</exception>
        <exception cref="T:System.OutOfMemoryException">没有足够的内存来继续执行该程序。</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">记录序列已满。</exception>
        <exception cref="T:System.IO.Log.ReservationNotFoundException">在 <paramref name="data" /> 中找不到足以容纳 <paramref name="reservations" /> 的预留。</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginFlush">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginFlush (System.IO.Log.SequenceNumber sequenceNumber, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginFlush(valuetype System.IO.Log.SequenceNumber sequenceNumber, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.FileRecordSequence.BeginFlush(System.IO.Log.SequenceNumber,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginFlush (sequenceNumber As SequenceNumber, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginFlush(System::IO::Log::SequenceNumber sequenceNumber, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginFlush : System.IO.Log.SequenceNumber * AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginFlush : System.IO.Log.SequenceNumber * AsyncCallback * obj -&gt; IAsyncResult" Usage="fileRecordSequence.BeginFlush (sequenceNumber, callback, state)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.BeginFlush(System.IO.Log.SequenceNumber,System.AsyncCallback,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sequenceNumber" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="sequenceNumber">必须写入的最新记录的序列号。 如果 <see cref="T:System.IO.Log.SequenceNumber" /> 无效，则必须写入所有记录。</param>
        <param name="callback">可选的异步回调，在刷新完成时调用。</param>
        <param name="state">用户提供的对象，用于将此特定异步刷新请求与其他请求区别开来。</param>
        <summary>使用序列中先前保留的空间开始异步刷新操作。 无法继承此方法。</summary>
        <returns>一个 <see cref="T:System.IAsyncResult" />，表示可能仍处于挂起状态的异步刷新操作。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 应将当前方法返回的 <xref:System.IAsyncResult> 传递给 <xref:System.IO.Log.FileRecordSequence.EndFlush%2A> 方法，以确保刷新完成并适当释放资源。 如果在异步刷新过程中发生错误，则在使用此方法返回的 <xref:System.IO.Log.FileRecordSequence.EndFlush%2A> 调用 <xref:System.IAsyncResult> 方法之前，不会引发异常。  
  
 调用此方法可以确保已追加到 <xref:System.IO.Log.FileRecordSequence> 的所有记录都是持久写入的。  
  
 如果记录序列已经释放，或者如果传递了无效自变量，此操作内将立即引发异常。 异步刷新请求过程中发生的错误（例如，I/O 请求过程中的磁盘故障）将导致在调用 <xref:System.IO.Log.FileRecordSequence.EndFlush%2A> 方法时引发异常。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">一个或多个自变量无效。  
  
 <paramref name="sequenceNumber" /> 对此序列无效。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="sequenceNumber" /> 不在此序列的基序列号和最后一个序列号之间。</exception>
        <exception cref="T:System.IO.IOException">刷新数据时，发生了 I/O 错误。</exception>
        <exception cref="T:System.ObjectDisposedException">该方法是在序列已释放之后调用的。</exception>
        <exception cref="T:System.OutOfMemoryException">没有足够的内存来继续执行该程序。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginReserveAndAppend">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>开始异步保留和追加操作。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginReserveAndAppend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReserveAndAppend (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservationCollection, long[] reservations, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginReserveAndAppend(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.IO.Log.ReservationCollection reservationCollection, int64[] reservations, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.FileRecordSequence.BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginReserveAndAppend (data As ArraySegment(Of Byte), nextUndoRecord As SequenceNumber, previousRecord As SequenceNumber, recordAppendOptions As RecordAppendOptions, reservationCollection As ReservationCollection, reservations As Long(), callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginReserveAndAppend(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, System::IO::Log::ReservationCollection ^ reservationCollection, cli::array &lt;long&gt; ^ reservations, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginReserveAndAppend : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection * int64[] * AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginReserveAndAppend : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection * int64[] * AsyncCallback * obj -&gt; IAsyncResult" Usage="fileRecordSequence.BeginReserveAndAppend (data, nextUndoRecord, previousRecord, recordAppendOptions, reservationCollection, reservations, callback, state)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="reservationCollection" Type="System.IO.Log.ReservationCollection" />
        <Parameter Name="reservations" Type="System.Int64[]" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="data">将连接在一起并以记录形式追加的字节数组段的列表。</param>
        <param name="nextUndoRecord">用户指定顺序中下一条记录的序列号。</param>
        <param name="previousRecord">“上一个”顺序中下一条记录的序列号。</param>
        <param name="recordAppendOptions"><see cref="T:System.IO.Log.RecordAppendOptions" /> 的一个有效值，用于指定应如何写入数据。</param>
        <param name="reservationCollection">要在其中生成预留的预留集合。</param>
        <param name="reservations">要生成的预留（以字节为单位）。</param>
        <param name="callback">可选的异步回调，在追加完成时调用。</param>
        <param name="state">用户提供的对象，用于将此特定异步追加请求与其他请求区别开来。</param>
        <summary>开始异步保留和追加操作。 无法继承此方法。</summary>
        <returns>一个 <see cref="T:System.IAsyncResult" />，它表示可能仍处于挂起状态的当前异步操作。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 应将此方法返回的 <xref:System.IAsyncResult> 传递给 <xref:System.IO.Log.FileRecordSequence.EndReserveAndAppend%2A> 方法，以确保追加操作已完成并能够适当释放资源。 如果在异步追加过程中发生错误，则在使用此方法返回的 <xref:System.IO.Log.FileRecordSequence.EndReserveAndAppend%2A> 调用 <xref:System.IAsyncResult> 方法之前，不会引发异常。  
  
 包含在 `data` 参数中的数据将连接成单个字节数组，以便以记录形式追加。 但在读取记录时，无法将数据重新拆分为数组段。  
  
 在原子操作中，使用记录追加操作将指定的预留添加到所提供的预留集合。 如果追加失败，将不保留任何空间。  
  
 通常，此方法可以在写入记录之前完成。 若要确保记录已写入，请使用 <xref:System.IO.Log.RecordAppendOptions.ForceFlush> 参数指定 `recordAppendOptions` 标志，或者调用 <xref:System.IO.Log.FileRecordSequence.Flush%2A> 方法。  
  
 如果记录序列已经释放，或者如果传递了无效自变量，此操作内将立即引发异常。 异步追加请求过程中发生的错误（例如，I/O 请求过程中的磁盘故障）将导致在调用 <xref:System.IO.Log.FileRecordSequence.EndReserveAndAppend%2A> 方法时引发异常。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">一个或多个参数为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">一个或多个自变量超出范围。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="reservations" /> 不是由此记录序列创建的。</exception>
        <exception cref="T:System.NotSupportedException">由于记录序列是通过只读访问权限打开的，因此无法执行该操作。</exception>
        <exception cref="T:System.IO.IOException">由于出现意外的 I/O 异常，因此无法执行该请求。</exception>
        <exception cref="T:System.ObjectDisposedException">该方法是在序列已释放之后调用的。</exception>
        <exception cref="T:System.OutOfMemoryException">没有足够的内存来继续执行该程序。</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">记录序列已满。</exception>
        <exception cref="T:System.IO.Log.ReservationNotFoundException">在 <paramref name="data" /> 中找不到足以容纳 <paramref name="reservations" /> 的预留。</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginReserveAndAppend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReserveAndAppend (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservationCollection, long[] reservations, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginReserveAndAppend(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.IO.Log.ReservationCollection reservationCollection, int64[] reservations, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.FileRecordSequence.BeginReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginReserveAndAppend (data As IList(Of ArraySegment(Of Byte)), nextUndoRecord As SequenceNumber, previousRecord As SequenceNumber, recordAppendOptions As RecordAppendOptions, reservationCollection As ReservationCollection, reservations As Long(), callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginReserveAndAppend(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, System::IO::Log::ReservationCollection ^ reservationCollection, cli::array &lt;long&gt; ^ reservations, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginReserveAndAppend : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection * int64[] * AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginReserveAndAppend : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection * int64[] * AsyncCallback * obj -&gt; IAsyncResult" Usage="fileRecordSequence.BeginReserveAndAppend (data, nextUndoRecord, previousRecord, recordAppendOptions, reservationCollection, reservations, callback, state)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.BeginReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="reservationCollection" Type="System.IO.Log.ReservationCollection" />
        <Parameter Name="reservations" Type="System.Int64[]" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="data">将连接在一起并以记录形式追加的字节数组段的列表。</param>
        <param name="nextUndoRecord">用户指定顺序中下一条记录的序列号。</param>
        <param name="previousRecord">“上一个”顺序中下一条记录的序列号。</param>
        <param name="recordAppendOptions"><see cref="T:System.IO.Log.RecordAppendOptions" /> 的一个有效值，用于指定应如何写入数据。</param>
        <param name="reservationCollection">要在其中生成预留的预留集合。</param>
        <param name="reservations">要生成的预留（以字节为单位）。</param>
        <param name="callback">可选的异步回调，在追加完成时调用。</param>
        <param name="state">用户提供的对象，用于将此特定异步追加请求与其他请求区别开来。</param>
        <summary>开始异步保留和追加操作。 无法继承此方法。</summary>
        <returns>一个 <see cref="T:System.IAsyncResult" />，它表示可能仍处于挂起状态的当前异步操作。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 应将此方法返回的 <xref:System.IAsyncResult> 传递给 <xref:System.IO.Log.FileRecordSequence.EndReserveAndAppend%2A> 方法，以确保追加操作已完成并能够适当释放资源。 如果在异步追加过程中发生错误，则在使用此方法返回的 <xref:System.IO.Log.FileRecordSequence.EndReserveAndAppend%2A> 调用 <xref:System.IAsyncResult> 方法之前，不会引发异常。  
  
 包含在 `data` 参数中的数据将连接成单个字节数组，以便以记录形式追加。 但在读取记录时，无法将数据重新拆分为数组段。  
  
 在原子操作中，使用记录追加操作将指定的预留添加到所提供的预留集合。 如果追加失败，将不保留任何空间。  
  
 通常，此方法可以在写入记录之前完成。 若要确保记录已写入，请使用 <xref:System.IO.Log.RecordAppendOptions.ForceFlush> 参数指定 `recordAppendOptions` 标志，或者调用 <xref:System.IO.Log.FileRecordSequence.Flush%2A> 方法。  
  
 如果记录序列已经释放，或者如果传递了无效自变量，此操作内将立即引发异常。 异步追加请求过程中发生的错误（例如，I/O 请求过程中的磁盘故障）将导致在调用 <xref:System.IO.Log.FileRecordSequence.EndReserveAndAppend%2A> 方法时引发异常。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">一个或多个参数为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">一个或多个自变量超出范围。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="reservations" /> 不是由此记录序列创建的。</exception>
        <exception cref="T:System.NotSupportedException">由于记录序列是通过只读访问权限打开的，因此无法执行该操作。</exception>
        <exception cref="T:System.IO.IOException">由于出现意外的 I/O 异常，因此无法执行该请求。</exception>
        <exception cref="T:System.ObjectDisposedException">该方法是在序列已释放之后调用的。</exception>
        <exception cref="T:System.OutOfMemoryException">没有足够的内存来继续执行该程序。</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">记录序列已满。</exception>
        <exception cref="T:System.IO.Log.ReservationNotFoundException">在 <paramref name="data" /> 中找不到足以容纳 <paramref name="reservations" /> 的预留。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginWriteRestartArea">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>开始异步重新开始区域写入操作。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginWriteRestartArea">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginWriteRestartArea (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber newBaseSeqNum, System.IO.Log.ReservationCollection reservation, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginWriteRestartArea(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber newBaseSeqNum, class System.IO.Log.ReservationCollection reservation, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.FileRecordSequence.BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginWriteRestartArea (data As ArraySegment(Of Byte), newBaseSeqNum As SequenceNumber, reservation As ReservationCollection, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginWriteRestartArea(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber newBaseSeqNum, System::IO::Log::ReservationCollection ^ reservation, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginWriteRestartArea : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.ReservationCollection * AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginWriteRestartArea : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.ReservationCollection * AsyncCallback * obj -&gt; IAsyncResult" Usage="fileRecordSequence.BeginWriteRestartArea (data, newBaseSeqNum, reservation, callback, state)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="newBaseSeqNum" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="reservation" Type="System.IO.Log.ReservationCollection" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="data">将连接在一起并以记录形式追加的字节数组段的列表。</param>
        <param name="newBaseSeqNum">新的基序列号。 指定的序列号必须大于或等于当前基序列号。</param>
        <param name="reservation">一个 <see cref="T:System.IO.Log.ReservationCollection" />，它包含应当用于此重新开始区域的预留。</param>
        <param name="callback">可选的异步回调，在重新开始区域写入完成时调用。</param>
        <param name="state">用户提供的对象，用于将此特定异步重新开始区域写入请求与其他请求区别开来。</param>
        <summary>使用序列中先前保留的空间开始异步重新开始区域写入操作。 无法继承此方法。</summary>
        <returns>一个 <see cref="T:System.IAsyncResult" />，它表示可能仍处于挂起状态的异步重新开始区域写入操作。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 应将此方法返回的 <xref:System.IAsyncResult> 传递给 <xref:System.IO.Log.FileRecordSequence.EndWriteRestartArea%2A> 方法，以确保重新开始区域写入操作完成并能够适当释放资源。 如果在异步重新开始区域写入操作过程中发生错误，则在使用此方法返回的 <xref:System.IO.Log.FileRecordSequence.EndWriteRestartArea%2A> 调用 <xref:System.IAsyncResult> 方法之前，不会引发异常。  
  
 包含在 `data` 参数中的数据将连接成单个字节数组，以便以记录形式追加。 但在读取记录时，无法将数据重新拆分为数组段。  
  
 操作成功完成时，基序列号已更新。 其序列号小于新的基序列号的所有日志记录都不可访问。  
  
 如果指定了 <xref:System.IO.Log.ReservationCollection>，写入的重新开始区域将使用集合中包含的预留来占用先前已预留的空间。 如果该方法成功，它将占用能容纳数据的最小预留，而该预留将从集合中移除。  
  
 如果记录序列已经释放，或者如果传递了无效自变量，此操作内将立即引发异常。 异步追加请求过程中发生的错误（例如，I/O 请求过程中的磁盘故障）将导致在调用 <xref:System.IO.Log.FileRecordSequence.EndWriteRestartArea%2A> 方法时引发异常。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">一个或多个参数为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="newBaseSeqNum" /> 不在此序列的基序列号和最后一个序列号之间。  
  
- 或 - 
活动日志新存档或现有存档的尾数据或基数据无效。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="reservations" /> 不是由此记录序列创建的。  
  
- 或 - 
 <paramref name="newBaseSeqNum" /> 对此序列无效。</exception>
        <exception cref="T:System.NotSupportedException">由于记录序列是通过只读访问权限打开的，因此无法执行该操作。</exception>
        <exception cref="T:System.IO.IOException">由于出现意外的 I/O 异常，因此无法执行该请求。</exception>
        <exception cref="T:System.ObjectDisposedException">该方法是在序列已释放之后调用的。</exception>
        <exception cref="T:System.OutOfMemoryException">没有足够的内存来继续执行该程序。</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">记录序列已满。</exception>
        <exception cref="T:System.IO.Log.ReservationNotFoundException">在 <paramref name="data" /> 中找不到足以容纳 <paramref name="reservations" /> 的预留。</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginWriteRestartArea">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginWriteRestartArea (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber newBaseSeqNum, System.IO.Log.ReservationCollection reservation, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginWriteRestartArea(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber newBaseSeqNum, class System.IO.Log.ReservationCollection reservation, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.FileRecordSequence.BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginWriteRestartArea (data As IList(Of ArraySegment(Of Byte)), newBaseSeqNum As SequenceNumber, reservation As ReservationCollection, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginWriteRestartArea(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber newBaseSeqNum, System::IO::Log::ReservationCollection ^ reservation, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginWriteRestartArea : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.ReservationCollection * AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginWriteRestartArea : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.ReservationCollection * AsyncCallback * obj -&gt; IAsyncResult" Usage="fileRecordSequence.BeginWriteRestartArea (data, newBaseSeqNum, reservation, callback, state)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="newBaseSeqNum" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="reservation" Type="System.IO.Log.ReservationCollection" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="data">将连接在一起并以记录形式追加的字节数组段的列表。</param>
        <param name="newBaseSeqNum">新的基序列号。 指定的序列号必须大于或等于当前基序列号。</param>
        <param name="reservation">一个 <see cref="T:System.IO.Log.ReservationCollection" />，它包含应当用于此重新开始区域的预留。</param>
        <param name="callback">可选的异步回调，在重新开始区域写入完成时调用。</param>
        <param name="state">用户提供的对象，用于将此特定异步重新开始区域写入请求与其他请求区别开来。</param>
        <summary>使用序列中先前保留的空间开始异步重新开始区域写入操作。 无法继承此方法。</summary>
        <returns>一个 <see cref="T:System.IAsyncResult" />，它表示可能仍处于挂起状态的异步重新开始区域写入操作。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 应将此方法返回的 <xref:System.IAsyncResult> 传递给 <xref:System.IO.Log.FileRecordSequence.EndWriteRestartArea%2A> 方法，以确保重新开始区域写入操作完成并能够适当释放资源。 如果在异步重新开始区域写入操作过程中发生错误，则在使用此方法返回的 <xref:System.IO.Log.FileRecordSequence.EndWriteRestartArea%2A> 调用 <xref:System.IAsyncResult> 方法之前，不会引发异常。  
  
 包含在 `data` 参数中的数据将连接成单个字节数组，以便以记录形式追加。 但在读取记录时，无法将数据重新拆分为数组段。  
  
 操作成功完成时，基序列号已更新。 其序列号小于新的基序列号的所有日志记录都不可访问。  
  
 如果指定了 <xref:System.IO.Log.ReservationCollection>，写入的重新开始区域将使用集合中包含的预留来占用先前已预留的空间。 如果该方法成功，它将占用能容纳数据的最小预留，而该预留将从集合中移除。  
  
 如果记录序列已经释放，或者如果传递了无效自变量，此操作内将立即引发异常。 异步追加请求过程中发生的错误（例如，I/O 请求过程中的磁盘故障）将导致在调用 <xref:System.IO.Log.FileRecordSequence.EndWriteRestartArea%2A> 方法时引发异常。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">一个或多个参数为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="newBaseSeqNum" /> 不在此序列的基序列号和最后一个序列号之间。  
  
- 或 - 
活动日志新存档或现有存档的尾数据或基数据无效。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="reservations" /> 不是由此记录序列创建的。  
  
- 或 - 
 <paramref name="newBaseSeqNum" /> 对此序列无效。</exception>
        <exception cref="T:System.NotSupportedException">由于记录序列是通过只读访问权限打开的，因此无法执行该操作。</exception>
        <exception cref="T:System.IO.IOException">由于出现意外的 I/O 异常，因此无法执行该请求。</exception>
        <exception cref="T:System.ObjectDisposedException">该方法是在序列已释放之后调用的。</exception>
        <exception cref="T:System.OutOfMemoryException">没有足够的内存来继续执行该程序。</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">记录序列已满。</exception>
        <exception cref="T:System.IO.Log.ReservationNotFoundException">在 <paramref name="data" /> 中找不到足以容纳 <paramref name="reservations" /> 的预留。</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateReservationCollection">
      <MemberSignature Language="C#" Value="public System.IO.Log.ReservationCollection CreateReservationCollection ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IO.Log.ReservationCollection CreateReservationCollection() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.FileRecordSequence.CreateReservationCollection" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateReservationCollection () As ReservationCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::ReservationCollection ^ CreateReservationCollection();" />
      <MemberSignature Language="F#" Value="abstract member CreateReservationCollection : unit -&gt; System.IO.Log.ReservationCollection&#xA;override this.CreateReservationCollection : unit -&gt; System.IO.Log.ReservationCollection" Usage="fileRecordSequence.CreateReservationCollection " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.CreateReservationCollection</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.ReservationCollection</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>创建一个新的 <see cref="T:System.IO.Log.ReservationCollection" />。 无法继承此方法。</summary>
        <returns>新创建的 <see cref="T:System.IO.Log.ReservationCollection" />。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OutOfMemoryException">没有足够的内存来继续执行该程序。</exception>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.FileRecordSequence.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="fileRecordSequence.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>立即释放对象使用的非托管资源。</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.IO.IOException">刷新数据时，发生了 I/O 错误。</exception>
        <exception cref="T:System.ObjectDisposedException">该方法是在序列已释放之后调用的。</exception>
        <exception cref="T:System.OutOfMemoryException">没有足够的内存来继续执行该程序。</exception>
      </Docs>
    </Member>
    <Member MemberName="EndAppend">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber EndAppend (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber EndAppend(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.FileRecordSequence.EndAppend(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndAppend (result As IAsyncResult) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber EndAppend(IAsyncResult ^ result);" />
      <MemberSignature Language="F#" Value="abstract member EndAppend : IAsyncResult -&gt; System.IO.Log.SequenceNumber&#xA;override this.EndAppend : IAsyncResult -&gt; System.IO.Log.SequenceNumber" Usage="fileRecordSequence.EndAppend result" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.EndAppend(System.IAsyncResult)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">对未完成的异步 I/O 请求的引用。</param>
        <summary>结束异步追加操作。 无法继承此方法。</summary>
        <returns>追加的日志记录的序列号。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法将一直阻塞，直到 I/O 操作已完成。 调用 <xref:System.IO.Log.FileRecordSequence.EndAppend%2A> 时，异步写入请求过程中发生的错误（例如，I/O 请求过程中的磁盘故障）将变得可见。  
  
 必须对 <xref:System.IAsyncResult> 方法返回的每个 <xref:System.IO.Log.FileRecordSequence.BeginAppend%2A> 调用此方法且只能调用一次。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="result" /> 无效。</exception>
        <exception cref="T:System.InvalidOperationException">已对此异步操作调用了 <see langword="End" />。</exception>
        <exception cref="T:System.IO.IOException">由于出现意外的 I/O 异常，因此无法执行该请求。</exception>
        <exception cref="T:System.ObjectDisposedException">该方法是在序列已释放之后调用的。</exception>
        <exception cref="T:System.OutOfMemoryException">没有足够的内存来继续执行该程序。</exception>
      </Docs>
    </Member>
    <Member MemberName="EndFlush">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber EndFlush (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber EndFlush(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.FileRecordSequence.EndFlush(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndFlush (result As IAsyncResult) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber EndFlush(IAsyncResult ^ result);" />
      <MemberSignature Language="F#" Value="abstract member EndFlush : IAsyncResult -&gt; System.IO.Log.SequenceNumber&#xA;override this.EndFlush : IAsyncResult -&gt; System.IO.Log.SequenceNumber" Usage="fileRecordSequence.EndFlush result" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.EndFlush(System.IAsyncResult)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">对未完成的异步 I/O 请求的引用。</param>
        <summary>结束异步刷新操作。 无法继承此方法。</summary>
        <returns>写入的最新记录的序列号。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法将一直阻塞，直到 I/O 操作已完成。 调用 <xref:System.IO.Log.FileRecordSequence.EndFlush%2A> 时，异步刷新请求过程中发生的错误（例如，I/O 请求过程中的磁盘故障）将变得可见。  
  
 必须对 <xref:System.IAsyncResult> 方法返回的每个 <xref:System.IO.Log.FileRecordSequence.BeginFlush%2A> 调用此方法且只能调用一次。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="result" /> 无效。</exception>
        <exception cref="T:System.InvalidOperationException">已对此异步操作调用了 <see langword="End" />。</exception>
        <exception cref="T:System.IO.IOException">由于出现意外的 I/O 异常，因此无法执行该请求。</exception>
        <exception cref="T:System.ObjectDisposedException">该方法是在序列已释放之后调用的。</exception>
        <exception cref="T:System.OutOfMemoryException">没有足够的内存来继续执行该程序。</exception>
      </Docs>
    </Member>
    <Member MemberName="EndReserveAndAppend">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber EndReserveAndAppend (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber EndReserveAndAppend(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.FileRecordSequence.EndReserveAndAppend(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReserveAndAppend (result As IAsyncResult) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber EndReserveAndAppend(IAsyncResult ^ result);" />
      <MemberSignature Language="F#" Value="abstract member EndReserveAndAppend : IAsyncResult -&gt; System.IO.Log.SequenceNumber&#xA;override this.EndReserveAndAppend : IAsyncResult -&gt; System.IO.Log.SequenceNumber" Usage="fileRecordSequence.EndReserveAndAppend result" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.EndReserveAndAppend(System.IAsyncResult)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">对未完成的异步 I/O 请求的引用。</param>
        <summary>结束异步保留和追加操作。 无法继承此方法。</summary>
        <returns>追加的日志记录的序列号。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法将一直阻塞，直到 I/O 操作已完成。 调用 <xref:System.IO.Log.FileRecordSequence.EndReserveAndAppend%2A> 时，异步写入请求过程中发生的错误（例如，I/O 请求过程中的磁盘故障）将变得可见。  
  
 必须对 <xref:System.IAsyncResult> 方法返回的每个 <xref:System.IO.Log.FileRecordSequence.BeginReserveAndAppend%2A> 调用此方法且只能调用一次。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="result" /> 无效。</exception>
        <exception cref="T:System.InvalidOperationException">已对此异步操作调用了 <see langword="End" />。</exception>
        <exception cref="T:System.IO.IOException">由于出现意外的 I/O 异常，因此无法执行该请求。</exception>
        <exception cref="T:System.ObjectDisposedException">该方法是在序列已释放之后调用的。</exception>
        <exception cref="T:System.OutOfMemoryException">没有足够的内存来继续执行该程序。</exception>
      </Docs>
    </Member>
    <Member MemberName="EndWriteRestartArea">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber EndWriteRestartArea (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber EndWriteRestartArea(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.FileRecordSequence.EndWriteRestartArea(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndWriteRestartArea (result As IAsyncResult) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber EndWriteRestartArea(IAsyncResult ^ result);" />
      <MemberSignature Language="F#" Value="abstract member EndWriteRestartArea : IAsyncResult -&gt; System.IO.Log.SequenceNumber&#xA;override this.EndWriteRestartArea : IAsyncResult -&gt; System.IO.Log.SequenceNumber" Usage="fileRecordSequence.EndWriteRestartArea result" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.EndWriteRestartArea(System.IAsyncResult)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">对未完成的异步 I/O 请求的引用。</param>
        <summary>结束异步重新开始区域写入操作。 无法继承此方法。</summary>
        <returns>写入的日志记录的序列号。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法将一直阻塞，直到 I/O 操作已完成。 调用 <xref:System.IO.Log.FileRecordSequence.EndWriteRestartArea%2A> 时，异步写入请求过程中发生的错误（例如，I/O 请求过程中的磁盘故障）将变得可见。  
  
 必须对 <xref:System.IAsyncResult> 方法返回的每个 <xref:System.IO.Log.FileRecordSequence.BeginWriteRestartArea%2A> 调用此方法且只能调用一次。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="result" /> 无效。</exception>
        <exception cref="T:System.InvalidOperationException">已对此异步操作调用了 <see langword="End" />。</exception>
        <exception cref="T:System.IO.IOException">由于出现意外的 I/O 异常，因此无法执行该请求。</exception>
        <exception cref="T:System.ObjectDisposedException">该方法是在序列已释放之后调用的。</exception>
        <exception cref="T:System.OutOfMemoryException">没有足够的内存来继续执行该程序。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Flush">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>导致持久写入追加的记录。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber Flush ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber Flush() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.FileRecordSequence.Flush" />
      <MemberSignature Language="VB.NET" Value="Public Function Flush () As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber Flush();" />
      <MemberSignature Language="F#" Value="abstract member Flush : unit -&gt; System.IO.Log.SequenceNumber&#xA;override this.Flush : unit -&gt; System.IO.Log.SequenceNumber" Usage="fileRecordSequence.Flush " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.Flush</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>确保所有追加的记录都已写入。 无法继承此方法。</summary>
        <returns>写入的最新记录的序列号。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 调用此方法可以确保已追加到 <xref:System.IO.Log.FileRecordSequence> 的所有记录都已持久写入。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">刷新数据时，发生了 I/O 错误。</exception>
        <exception cref="T:System.ObjectDisposedException">该方法是在序列已释放之后调用的。</exception>
        <exception cref="T:System.OutOfMemoryException">没有足够的内存来继续执行该程序。</exception>
      </Docs>
    </Member>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber Flush (System.IO.Log.SequenceNumber sequenceNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber Flush(valuetype System.IO.Log.SequenceNumber sequenceNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.FileRecordSequence.Flush(System.IO.Log.SequenceNumber)" />
      <MemberSignature Language="VB.NET" Value="Public Function Flush (sequenceNumber As SequenceNumber) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber Flush(System::IO::Log::SequenceNumber sequenceNumber);" />
      <MemberSignature Language="F#" Value="abstract member Flush : System.IO.Log.SequenceNumber -&gt; System.IO.Log.SequenceNumber&#xA;override this.Flush : System.IO.Log.SequenceNumber -&gt; System.IO.Log.SequenceNumber" Usage="fileRecordSequence.Flush sequenceNumber" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.Flush(System.IO.Log.SequenceNumber)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sequenceNumber" Type="System.IO.Log.SequenceNumber" />
      </Parameters>
      <Docs>
        <param name="sequenceNumber">必须写入的最新记录的序列号。 如果此 <see cref="T:System.IO.Log.SequenceNumber" /> 无效，则必须写入所有记录。</param>
        <summary>确保所有追加的记录都已写入。 无法继承此方法。</summary>
        <returns>写入的最新记录的序列号。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 调用此方法可以确保序列号不高于指定序列号的所有记录都已持久写入。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="sequenceNumber" /> 不在此序列的基序列号和最后一个序列号之间。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="sequenceNumber" /> 对此序列无效。</exception>
        <exception cref="T:System.IO.IOException">刷新数据时，发生了 I/O 错误。</exception>
        <exception cref="T:System.ObjectDisposedException">该方法是在序列已释放之后调用的。</exception>
        <exception cref="T:System.OutOfMemoryException">没有足够的内存来继续执行该程序。</exception>
      </Docs>
    </Member>
    <Member MemberName="LastSequenceNumber">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber LastSequenceNumber { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.IO.Log.SequenceNumber LastSequenceNumber" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.FileRecordSequence.LastSequenceNumber" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LastSequenceNumber As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Log::SequenceNumber LastSequenceNumber { System::IO::Log::SequenceNumber get(); };" />
      <MemberSignature Language="F#" Value="member this.LastSequenceNumber : System.IO.Log.SequenceNumber" Usage="System.IO.Log.FileRecordSequence.LastSequenceNumber" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IO.Log.IRecordSequence.LastSequenceNumber</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取比追加的最新记录大的序列号。</summary>
        <value>比追加的最新记录大的序列号。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此属性包含一个序列号，并且保证它大于最后追加的记录的序列号。 有效序列号大于或等于 <xref:System.IO.Log.FileRecordSequence.BaseSequenceNumber%2A> 且小于 <xref:System.IO.Log.FileRecordSequence.LastSequenceNumber%2A>。 所有其他序列号均无效。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">该属性是在序列已释放之后访问的。</exception>
      </Docs>
    </Member>
    <Member MemberName="MaximumRecordLength">
      <MemberSignature Language="C#" Value="public long MaximumRecordLength { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 MaximumRecordLength" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.FileRecordSequence.MaximumRecordLength" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MaximumRecordLength As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long MaximumRecordLength { long get(); };" />
      <MemberSignature Language="F#" Value="member this.MaximumRecordLength : int64" Usage="System.IO.Log.FileRecordSequence.MaximumRecordLength" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IO.Log.IRecordSequence.MaximumRecordLength</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取可以追加到此序列或者从此序列中读取的最大记录的大小（以字节为单位）。</summary>
        <value>可以追加到此序列或者从此序列中读取的最大记录的大小（以字节为单位）。</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">该属性是在序列已释放之后访问的。</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadLogRecords">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.IO.Log.LogRecord&gt; ReadLogRecords (System.IO.Log.SequenceNumber start, System.IO.Log.LogRecordEnumeratorType logRecordEnum);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class System.IO.Log.LogRecord&gt; ReadLogRecords(valuetype System.IO.Log.SequenceNumber start, valuetype System.IO.Log.LogRecordEnumeratorType logRecordEnum) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.FileRecordSequence.ReadLogRecords(System.IO.Log.SequenceNumber,System.IO.Log.LogRecordEnumeratorType)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadLogRecords (start As SequenceNumber, logRecordEnum As LogRecordEnumeratorType) As IEnumerable(Of LogRecord)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::Generic::IEnumerable&lt;System::IO::Log::LogRecord ^&gt; ^ ReadLogRecords(System::IO::Log::SequenceNumber start, System::IO::Log::LogRecordEnumeratorType logRecordEnum);" />
      <MemberSignature Language="F#" Value="abstract member ReadLogRecords : System.IO.Log.SequenceNumber * System.IO.Log.LogRecordEnumeratorType -&gt; seq&lt;System.IO.Log.LogRecord&gt;&#xA;override this.ReadLogRecords : System.IO.Log.SequenceNumber * System.IO.Log.LogRecordEnumeratorType -&gt; seq&lt;System.IO.Log.LogRecord&gt;" Usage="fileRecordSequence.ReadLogRecords (start, logRecordEnum)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.ReadLogRecords(System.IO.Log.SequenceNumber,System.IO.Log.LogRecordEnumeratorType)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.IO.Log.LogRecord&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="start" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="logRecordEnum" Type="System.IO.Log.LogRecordEnumeratorType" />
      </Parameters>
      <Docs>
        <param name="start">读取操作开始处的第一条记录的序列号。</param>
        <param name="logRecordEnum">一个有效的 <see cref="T:System.IO.Log.LogRecordEnumeratorType" /> 值，该值指定从 <see cref="T:System.IO.Log.LogRecordSequence" /> 中读取记录的方式（即，向前或向后）。</param>
        <summary>返回序列中记录的可枚举集合。 无法继承此方法。</summary>
        <returns>序列中记录的可枚举集合。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法返回序列中记录的可枚举集合。 所枚举记录的顺序取决于 `logRecordEnum` 参数的值。  
  
   
  
## Examples  
 下面的示例演示如何使用此方法来读取日志序列中的记录。  
  
 [!code-csharp[IRecordSequence#2](~/samples/snippets/csharp/VS_Snippets_CFX/irecordsequence/cs/readrecord.cs#2)]
 [!code-vb[IRecordSequence#2](~/samples/snippets/visualbasic/VS_Snippets_CFX/irecordsequence/vb/readrecord.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">一个或多个自变量超出范围。</exception>
        <exception cref="T:System.NotSupportedException">由于记录序列是通过只写访问权限打开的，因此无法执行该操作。</exception>
        <exception cref="T:System.IO.IOException">记录序列已损坏。  
  
 - 或 -  
  
 记录是使用不兼容的记录序列版本写入的。</exception>
        <exception cref="T:System.InvalidOperationException">枚举已经终止。  
  
- 或 - 
枚举尚未开始。 必须调用 <see cref="M:System.Collections.IEnumerator.MoveNext" />。</exception>
        <exception cref="T:System.ObjectDisposedException">该方法是在序列已释放之后调用的。</exception>
        <exception cref="T:System.OutOfMemoryException">没有足够的内存来继续执行该程序。</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadRestartAreas">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.IO.Log.LogRecord&gt; ReadRestartAreas ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class System.IO.Log.LogRecord&gt; ReadRestartAreas() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.FileRecordSequence.ReadRestartAreas" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadRestartAreas () As IEnumerable(Of LogRecord)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::Generic::IEnumerable&lt;System::IO::Log::LogRecord ^&gt; ^ ReadRestartAreas();" />
      <MemberSignature Language="F#" Value="abstract member ReadRestartAreas : unit -&gt; seq&lt;System.IO.Log.LogRecord&gt;&#xA;override this.ReadRestartAreas : unit -&gt; seq&lt;System.IO.Log.LogRecord&gt;" Usage="fileRecordSequence.ReadRestartAreas " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.ReadRestartAreas</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.IO.Log.LogRecord&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回序列中重新开始区域的可枚举集合。 无法继承此方法。</summary>
        <returns>序列中重新开始区域的可枚举集合。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 重新开始区域按序列号的倒序枚举，即从最高序列号到最低序列号枚举。 仅枚举序列号介于最后一个序列号和基序列号之间的重新开始区域。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">由于记录序列是通过只写访问权限打开的，因此无法执行该操作。</exception>
        <exception cref="T:System.IO.IOException">记录序列已损坏。  
  
 - 或 -  
  
 记录是使用不兼容的记录序列版本写入的。</exception>
        <exception cref="T:System.InvalidOperationException">枚举已经终止。  
  
- 或 - 
枚举尚未开始。 必须调用 <see cref="M:System.Collections.IEnumerator.MoveNext" />。</exception>
        <exception cref="T:System.ObjectDisposedException">该方法是在序列已释放之后调用的。</exception>
        <exception cref="T:System.OutOfMemoryException">没有足够的内存来继续执行该程序。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReserveAndAppend">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>自动生成一个预留，并向序列中追加一条记录。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReserveAndAppend">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber ReserveAndAppend (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservationCollection, params long[] reservations);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber ReserveAndAppend(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.IO.Log.ReservationCollection reservationCollection, int64[] reservations) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.FileRecordSequence.ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])" />
      <MemberSignature Language="VB.NET" Value="Public Function ReserveAndAppend (data As ArraySegment(Of Byte), nextUndoRecord As SequenceNumber, previousRecord As SequenceNumber, recordAppendOptions As RecordAppendOptions, reservationCollection As ReservationCollection, ParamArray reservations As Long()) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber ReserveAndAppend(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, System::IO::Log::ReservationCollection ^ reservationCollection, ... cli::array &lt;long&gt; ^ reservations);" />
      <MemberSignature Language="F#" Value="abstract member ReserveAndAppend : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection * int64[] -&gt; System.IO.Log.SequenceNumber&#xA;override this.ReserveAndAppend : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection * int64[] -&gt; System.IO.Log.SequenceNumber" Usage="fileRecordSequence.ReserveAndAppend (data, nextUndoRecord, previousRecord, recordAppendOptions, reservationCollection, reservations)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="reservationCollection" Type="System.IO.Log.ReservationCollection" />
        <Parameter Name="reservations" Type="System.Int64[]">
          <Attributes>
            <Attribute FrameworkAlternate="netframework-3.0">
              <AttributeName Language="C#">[System.ParamArray]</AttributeName>
              <AttributeName Language="F#">[&lt;System.ParamArray&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="data">将连接在一起并以记录形式追加的字节数组段的列表。</param>
        <param name="nextUndoRecord">用户指定顺序中下一条记录的序列号。</param>
        <param name="previousRecord">“上一个”顺序中下一条记录的序列号。</param>
        <param name="recordAppendOptions"><see cref="T:System.IO.Log.RecordAppendOptions" /> 的一个有效值，用于指定应如何写入数据。</param>
        <param name="reservationCollection">一个 <see cref="T:System.IO.Log.ReservationCollection" />，它包含要在其中生成预留的集合。</param>
        <param name="reservations">要生成的预留（以字节为单位）。</param>
        <summary>自动生成一个预留，并向序列中追加一条记录。 无法继承此方法。</summary>
        <returns>追加的日志记录的序列号。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 包含在 `data` 参数中的数据将连接成单个字节数组，以便以记录形式追加。 但在读取记录时，无法将数据重新拆分为数组段。  
  
 在原子操作中，使用记录追加操作将指定的预留添加到所提供的预留集合。 如果追加失败，将不保留任何空间。  
  
 通常，此方法可以在写入记录之前完成。 若要确保记录已写入，请使用 <xref:System.IO.Log.RecordAppendOptions.ForceFlush> 参数指定 `recordAppendOptions` 标志，或者调用 <xref:System.IO.Log.FileRecordSequence.Flush%2A> 方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">一个或多个参数为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">一个或多个自变量超出范围。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="reservations" /> 不是由此记录序列创建的。</exception>
        <exception cref="T:System.NotSupportedException">由于记录序列是通过只读访问权限打开的，因此无法执行该操作。</exception>
        <exception cref="T:System.IO.IOException">由于出现意外的 I/O 异常，因此无法执行该请求。</exception>
        <exception cref="T:System.ObjectDisposedException">该方法是在序列已释放之后调用的。</exception>
        <exception cref="T:System.OutOfMemoryException">没有足够的内存来继续执行该程序。</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">记录序列已满。</exception>
      </Docs>
    </Member>
    <Member MemberName="ReserveAndAppend">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber ReserveAndAppend (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservationCollection, params long[] reservations);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber ReserveAndAppend(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.IO.Log.ReservationCollection reservationCollection, int64[] reservations) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.FileRecordSequence.ReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])" />
      <MemberSignature Language="VB.NET" Value="Public Function ReserveAndAppend (data As IList(Of ArraySegment(Of Byte)), nextUndoRecord As SequenceNumber, previousRecord As SequenceNumber, recordAppendOptions As RecordAppendOptions, reservationCollection As ReservationCollection, ParamArray reservations As Long()) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber ReserveAndAppend(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, System::IO::Log::ReservationCollection ^ reservationCollection, ... cli::array &lt;long&gt; ^ reservations);" />
      <MemberSignature Language="F#" Value="abstract member ReserveAndAppend : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection * int64[] -&gt; System.IO.Log.SequenceNumber&#xA;override this.ReserveAndAppend : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection * int64[] -&gt; System.IO.Log.SequenceNumber" Usage="fileRecordSequence.ReserveAndAppend (data, nextUndoRecord, previousRecord, recordAppendOptions, reservationCollection, reservations)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.ReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="reservationCollection" Type="System.IO.Log.ReservationCollection" />
        <Parameter Name="reservations" Type="System.Int64[]">
          <Attributes>
            <Attribute FrameworkAlternate="netframework-3.0">
              <AttributeName Language="C#">[System.ParamArray]</AttributeName>
              <AttributeName Language="F#">[&lt;System.ParamArray&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="data">将连接在一起并以记录形式追加的字节数组段的列表。</param>
        <param name="nextUndoRecord">用户指定顺序中下一条记录的序列号。</param>
        <param name="previousRecord">“上一个”顺序中下一条记录的序列号。</param>
        <param name="recordAppendOptions"><see cref="T:System.IO.Log.RecordAppendOptions" /> 的一个有效值，用于指定应如何写入数据。</param>
        <param name="reservationCollection">要在其中生成预留的预留集合。</param>
        <param name="reservations">要生成的预留（以字节为单位）。</param>
        <summary>自动生成一个预留，并向序列中追加一条记录。 无法继承此方法。</summary>
        <returns>追加的日志记录的序列号。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 包含在 `data` 参数中的数据将连接成单个字节数组，以便以记录形式追加。 但在读取记录时，无法将数据重新拆分为数组段。  
  
 在原子操作中，使用记录追加操作将指定的预留添加到所提供的预留集合。 如果追加失败，将不保留任何空间。  
  
 通常，此方法可以在写入记录之前完成。 若要确保记录已写入，请使用 <xref:System.IO.Log.RecordAppendOptions.ForceFlush> 参数指定 `recordAppendOptions` 标志，或者调用 <xref:System.IO.Log.FileRecordSequence.Flush%2A> 方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">一个或多个参数为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">一个或多个自变量超出范围。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="reservations" /> 不是由此记录序列创建的。</exception>
        <exception cref="T:System.NotSupportedException">由于记录序列是通过只读访问权限打开的，因此无法执行该操作。</exception>
        <exception cref="T:System.IO.IOException">由于出现意外的 I/O 异常，因此无法执行该请求。</exception>
        <exception cref="T:System.ObjectDisposedException">该方法是在序列已释放之后调用的。</exception>
        <exception cref="T:System.OutOfMemoryException">没有足够的内存来继续执行该程序。</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">记录序列已满。</exception>
      </Docs>
    </Member>
    <Member MemberName="ReservedBytes">
      <MemberSignature Language="C#" Value="public long ReservedBytes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 ReservedBytes" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.FileRecordSequence.ReservedBytes" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ReservedBytes As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long ReservedBytes { long get(); };" />
      <MemberSignature Language="F#" Value="member this.ReservedBytes : int64" Usage="System.IO.Log.FileRecordSequence.ReservedBytes" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IO.Log.IRecordSequence.ReservedBytes</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取已保留的字节总数。</summary>
        <value>此记录序列中做出的所有预留的总大小。</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">该属性是在序列已释放之后访问的。</exception>
      </Docs>
    </Member>
    <Member MemberName="RestartSequenceNumber">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber RestartSequenceNumber { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.IO.Log.SequenceNumber RestartSequenceNumber" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.FileRecordSequence.RestartSequenceNumber" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RestartSequenceNumber As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Log::SequenceNumber RestartSequenceNumber { System::IO::Log::SequenceNumber get(); };" />
      <MemberSignature Language="F#" Value="member this.RestartSequenceNumber : System.IO.Log.SequenceNumber" Usage="System.IO.Log.FileRecordSequence.RestartSequenceNumber" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IO.Log.IRecordSequence.RestartSequenceNumber</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取最近写入的重新开始区域的序列号。</summary>
        <value>最近写入的重新开始区域的序列号。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 重新开始区域用于临时存储包含客户端最后一次检查点操作的信息。 公用日志文件系统 (CLFS) 维护两个重新开始区域，以确保至少有一个有效区域总是可用。 需要恢复时，CLFS 读取自己的重新开始区域和最后一个检查点操作中的所有数据。 这些数据将初始化事务表、脏页表和打开文件表，以便它们能够用于恢复过程。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">该属性是在序列已释放之后访问的。</exception>
      </Docs>
    </Member>
    <Member MemberName="RetryAppend">
      <MemberSignature Language="C#" Value="public bool RetryAppend { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool RetryAppend" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.FileRecordSequence.RetryAppend" />
      <MemberSignature Language="VB.NET" Value="Public Property RetryAppend As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool RetryAppend { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.RetryAppend : bool with get, set" Usage="System.IO.Log.FileRecordSequence.RetryAppend" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IO.Log.IRecordSequence.RetryAppend</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，指示在日志已满时是否自动重试追加操作。</summary>
        <value>如果在日志已满时自动重试追加操作，则为 <see langword="true" />；否则为 <see langword="false" />。 默认为 <see langword="true" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果此属性的值为 `true`，且 <xref:System.IO.Log.FileRecordSequence.Append%2A> 调用因为序列中没有足够的空间而失败，则记录序列将尝试释放空间，然后重试追加操作。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">该属性是在序列已释放之后访问的。</exception>
      </Docs>
    </Member>
    <Member MemberName="TailPinned">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.IO.Log.TailPinnedEventArgs&gt; TailPinned;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.IO.Log.TailPinnedEventArgs&gt; TailPinned" />
      <MemberSignature Language="DocId" Value="E:System.IO.Log.FileRecordSequence.TailPinned" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event TailPinned As EventHandler(Of TailPinnedEventArgs) " FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event EventHandler&lt;System::IO::Log::TailPinnedEventArgs ^&gt; ^ TailPinned;" />
      <MemberSignature Language="F#" Value="member this.TailPinned : EventHandler&lt;System.IO.Log.TailPinnedEventArgs&gt; " Usage="member this.TailPinned : System.EventHandler&lt;System.IO.Log.TailPinnedEventArgs&gt; " />
      <MemberSignature Language="VB.NET" Value="Public Event TailPinned As EventHandler(Of TailPinnedEventArgs) " FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.IO.Log.IRecordSequence.TailPinned</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.IO.Log.TailPinnedEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当记录序列确定必须前移尾数据时发生。 无法继承此方法。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 可以在记录序列空间不足时激发此事件。 此事件激发时，序列的尾数据（即基序列号）将前移以释放空间。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteRestartArea">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>将重新开始区域写入 <see cref="T:System.IO.Log.FileRecordSequence" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 重新开始区域可用于临时存储包含客户端最后一次检查点操作的信息。 需要恢复时，可以读取重新开始区域，并检索最后一次检查点操作中的所有数据。 这些数据将初始化事务表、脏页表和打开文件表，以便它们能够用于恢复过程。  
  
 可以使用 <xref:System.IO.Log.FileRecordSequence.ReadRestartAreas%2A> 方法来读取重新开始区域。  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteRestartArea">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber WriteRestartArea (ArraySegment&lt;byte&gt; data);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber WriteRestartArea(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.FileRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Function WriteRestartArea (data As ArraySegment(Of Byte)) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber WriteRestartArea(ArraySegment&lt;System::Byte&gt; data);" />
      <MemberSignature Language="F#" Value="abstract member WriteRestartArea : ArraySegment&lt;byte&gt; -&gt; System.IO.Log.SequenceNumber&#xA;override this.WriteRestartArea : ArraySegment&lt;byte&gt; -&gt; System.IO.Log.SequenceNumber" Usage="fileRecordSequence.WriteRestartArea data" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
      </Parameters>
      <Docs>
        <param name="data">将连接在一起并以记录形式追加的字节数组段的列表。</param>
        <summary>将重新开始区域写入 <see cref="T:System.IO.Log.FileRecordSequence" />。 无法继承此方法。</summary>
        <returns>写入的重新开始区域的序列号。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 重新开始区域可用于临时存储包含客户端最后一次检查点操作的信息。 需要恢复时，可以读取重新开始区域，并检索最后一次检查点操作中的所有数据。 这些数据将初始化事务表、脏页表和打开文件表，以便它们能够用于恢复过程。  
  
 可以使用 <xref:System.IO.Log.FileRecordSequence.ReadRestartAreas%2A> 方法来读取重新开始区域。  
  
 字节数组段中的数据将连接成单个字节数组，以便以记录形式追加。 在读取重新开始区域时，无法将数据重新拆分为数组段。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">一个或多个参数为 <see langword="null" />。</exception>
        <exception cref="T:System.NotSupportedException">由于记录序列是通过只读访问权限打开的，因此无法执行该操作。</exception>
        <exception cref="T:System.IO.IOException">由于出现意外的 I/O 异常，因此无法执行该请求。</exception>
        <exception cref="T:System.ObjectDisposedException">该方法是在序列已释放之后调用的。</exception>
        <exception cref="T:System.OutOfMemoryException">没有足够的内存来继续执行该程序。</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">记录序列已满。</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteRestartArea">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber WriteRestartArea (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber WriteRestartArea(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.FileRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})" />
      <MemberSignature Language="VB.NET" Value="Public Function WriteRestartArea (data As IList(Of ArraySegment(Of Byte))) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber WriteRestartArea(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data);" />
      <MemberSignature Language="F#" Value="abstract member WriteRestartArea : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; -&gt; System.IO.Log.SequenceNumber&#xA;override this.WriteRestartArea : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; -&gt; System.IO.Log.SequenceNumber" Usage="fileRecordSequence.WriteRestartArea data" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
      </Parameters>
      <Docs>
        <param name="data">将连接在一起并以记录形式追加的字节数组段的列表。</param>
        <summary>将重新开始区域写入 <see cref="T:System.IO.Log.FileRecordSequence" />。 无法继承此方法。</summary>
        <returns>写入的重新开始区域的序列号。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 重新开始区域可用于临时存储包含客户端最后一次检查点操作的信息。 需要恢复时，可以读取重新开始区域，并检索最后一次检查点操作中的所有数据。 这些数据将初始化事务表、脏页表和打开文件表，以便它们能够用于恢复过程。  
  
 可以使用 <xref:System.IO.Log.FileRecordSequence.ReadRestartAreas%2A> 方法来读取重新开始区域。  
  
 字节数组段中的数据将连接成单个字节数组，以便以记录形式追加。 在读取重新开始区域时，无法将数据重新拆分为数组段。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">一个或多个参数为 <see langword="null" />。</exception>
        <exception cref="T:System.NotSupportedException">由于记录序列是通过只读访问权限打开的，因此无法执行该操作。</exception>
        <exception cref="T:System.IO.IOException">由于出现意外的 I/O 异常，因此无法执行该请求。</exception>
        <exception cref="T:System.ObjectDisposedException">该方法是在序列已释放之后调用的。</exception>
        <exception cref="T:System.OutOfMemoryException">没有足够的内存来继续执行该程序。</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">记录序列已满。</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteRestartArea">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber WriteRestartArea (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber newBaseSeqNum);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber WriteRestartArea(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber newBaseSeqNum) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.FileRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber)" />
      <MemberSignature Language="VB.NET" Value="Public Function WriteRestartArea (data As ArraySegment(Of Byte), newBaseSeqNum As SequenceNumber) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber WriteRestartArea(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber newBaseSeqNum);" />
      <MemberSignature Language="F#" Value="abstract member WriteRestartArea : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber -&gt; System.IO.Log.SequenceNumber&#xA;override this.WriteRestartArea : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber -&gt; System.IO.Log.SequenceNumber" Usage="fileRecordSequence.WriteRestartArea (data, newBaseSeqNum)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="newBaseSeqNum" Type="System.IO.Log.SequenceNumber" />
      </Parameters>
      <Docs>
        <param name="data">将连接在一起并以记录形式追加的字节数组段的列表。</param>
        <param name="newBaseSeqNum">新的基序列号。 指定的序列号必须大于或等于当前基序列号。</param>
        <summary>将重新开始区域写入 <see cref="T:System.IO.Log.FileRecordSequence" />。 无法继承此方法。</summary>
        <returns>写入的重新开始区域的序列号。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 重新开始区域可用于临时存储包含客户端最后一次检查点操作的信息。 需要恢复时，可以读取重新开始区域，并检索最后一次检查点操作中的所有数据。 这些数据将初始化事务表、脏页表和打开文件表，以便它们能够用于恢复过程。  
  
 可以使用 <xref:System.IO.Log.FileRecordSequence.ReadRestartAreas%2A> 方法来读取重新开始区域。  
  
 写入重新开始区域时，字节数组段中的数据将连接成单个字节数组，以便以记录形式追加。 在读取重新开始区域时，无法将数据重新拆分为数组段。  
  
 此方法成功完成时，基序列号已更新。 其序列号小于新的基序列号的所有日志记录都不可访问。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">一个或多个参数为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="newBaseSeqNum" /> 不在此序列的基序列号和最后一个序列号之间。  
  
- 或 - 
活动日志新存档或现有存档的尾数据或基数据无效。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="newBaseSeqNum" /> 对此序列无效。</exception>
        <exception cref="T:System.NotSupportedException">由于记录序列是通过只读访问权限打开的，因此无法执行该操作。</exception>
        <exception cref="T:System.IO.IOException">由于出现意外的 I/O 异常，因此无法执行该请求。</exception>
        <exception cref="T:System.ObjectDisposedException">该方法是在序列已释放之后调用的。</exception>
        <exception cref="T:System.OutOfMemoryException">没有足够的内存来继续执行该程序。</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">记录序列已满。</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteRestartArea">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber WriteRestartArea (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber newBaseSeqNum);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber WriteRestartArea(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber newBaseSeqNum) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.FileRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber)" />
      <MemberSignature Language="VB.NET" Value="Public Function WriteRestartArea (data As IList(Of ArraySegment(Of Byte)), newBaseSeqNum As SequenceNumber) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber WriteRestartArea(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber newBaseSeqNum);" />
      <MemberSignature Language="F#" Value="abstract member WriteRestartArea : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber -&gt; System.IO.Log.SequenceNumber&#xA;override this.WriteRestartArea : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber -&gt; System.IO.Log.SequenceNumber" Usage="fileRecordSequence.WriteRestartArea (data, newBaseSeqNum)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="newBaseSeqNum" Type="System.IO.Log.SequenceNumber" />
      </Parameters>
      <Docs>
        <param name="data">将连接在一起并以记录形式追加的字节数组段的列表。</param>
        <param name="newBaseSeqNum">新的基序列号。 指定的序列号必须大于或等于当前基序列号。</param>
        <summary>将重新开始区域写入 <see cref="T:System.IO.Log.FileRecordSequence" />。 无法继承此方法。</summary>
        <returns>写入的重新开始区域的序列号。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 重新开始区域可用于临时存储包含客户端最后一次检查点操作的信息。 需要恢复时，可以读取重新开始区域，并检索最后一次检查点操作中的所有数据。 这些数据将初始化事务表、脏页表和打开文件表，以便它们能够用于恢复过程。  
  
 可以使用 <xref:System.IO.Log.FileRecordSequence.ReadRestartAreas%2A> 方法来读取重新开始区域。  
  
 写入重新开始区域时，字节数组段中的数据将连接成单个字节数组，以便以记录形式追加。 在读取重新开始区域时，无法将数据重新拆分为数组段。  
  
 此方法成功完成时，基序列号已更新。 其序列号小于新的基序列号的所有日志记录都不可访问。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">一个或多个参数为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="newBaseSeqNum" /> 不在此序列的基序列号和最后一个序列号之间。  
  
- 或 - 
活动日志新存档或现有存档的尾数据或基数据无效。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="newBaseSeqNum" /> 对此序列无效。</exception>
        <exception cref="T:System.NotSupportedException">由于记录序列是通过只读访问权限打开的，因此无法执行该操作。</exception>
        <exception cref="T:System.IO.IOException">由于出现意外的 I/O 异常，因此无法执行该请求。</exception>
        <exception cref="T:System.ObjectDisposedException">该方法是在序列已释放之后调用的。</exception>
        <exception cref="T:System.OutOfMemoryException">没有足够的内存来继续执行该程序。</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">记录序列已满。</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteRestartArea">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber WriteRestartArea (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber newBaseSeqNum, System.IO.Log.ReservationCollection reservations);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber WriteRestartArea(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber newBaseSeqNum, class System.IO.Log.ReservationCollection reservations) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.FileRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)" />
      <MemberSignature Language="VB.NET" Value="Public Function WriteRestartArea (data As ArraySegment(Of Byte), newBaseSeqNum As SequenceNumber, reservations As ReservationCollection) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber WriteRestartArea(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber newBaseSeqNum, System::IO::Log::ReservationCollection ^ reservations);" />
      <MemberSignature Language="F#" Value="abstract member WriteRestartArea : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.ReservationCollection -&gt; System.IO.Log.SequenceNumber&#xA;override this.WriteRestartArea : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.ReservationCollection -&gt; System.IO.Log.SequenceNumber" Usage="fileRecordSequence.WriteRestartArea (data, newBaseSeqNum, reservations)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="newBaseSeqNum" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="reservations" Type="System.IO.Log.ReservationCollection" />
      </Parameters>
      <Docs>
        <param name="data">将连接在一起并以记录形式追加的字节数组段的列表。</param>
        <param name="newBaseSeqNum">新的基序列号。 指定的序列号必须大于或等于当前基序列号。</param>
        <param name="reservations">一个 <see cref="T:System.IO.Log.ReservationCollection" />，它包含应当用于此重新开始区域的预留。</param>
        <summary>将重新开始区域写入 <see cref="T:System.IO.Log.FileRecordSequence" />。 无法继承此方法。</summary>
        <returns>写入的重新开始区域的序列号。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 重新开始区域可用于临时存储包含客户端最后一次检查点操作的信息。 需要恢复时，可以读取重新开始区域，并检索最后一次检查点操作中的所有数据。 这些数据将初始化事务表、脏页表和打开文件表，以便它们能够用于恢复过程。  
  
 可以使用 <xref:System.IO.Log.FileRecordSequence.ReadRestartAreas%2A> 方法来读取重新开始区域。  
  
 写入重新开始区域时，字节数组段中的数据将连接成单个字节数组，以便以记录形式追加。 在读取重新开始区域时，无法将数据重新拆分为数组段。  
  
 如果指定了预留，写入的重新开始区域将使用集合中包含的预留来占用先前已预留的空间。 如果该方法成功，它将占用能容纳数据的最小预留，而该预留将从集合中移除。  
  
 此方法成功完成时，基序列号已更新。 其序列号小于新的基序列号的所有日志记录都不可访问。  
  
 如果记录序列已经释放，或者如果传递了无效自变量，此操作内将立即引发异常。 异步追加请求过程中发生的错误（例如，I/O 请求过程中的磁盘故障）将导致在调用 <xref:System.IO.Log.FileRecordSequence.EndReserveAndAppend%2A> 方法时引发异常。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">一个或多个参数为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="newBaseSeqNum" /> 不在此序列的基序列号和最后一个序列号之间。  
  
- 或 - 
活动日志新存档或现有存档的尾数据或基数据无效。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="reservations" /> 不是由此记录序列创建的。  
  
- 或 - 
 <paramref name="newBaseSeqNum" /> 对此序列无效。</exception>
        <exception cref="T:System.NotSupportedException">由于记录序列是通过只读访问权限打开的，因此无法执行该操作。</exception>
        <exception cref="T:System.IO.IOException">由于出现意外的 I/O 异常，因此无法执行该请求。</exception>
        <exception cref="T:System.ObjectDisposedException">该方法是在序列已释放之后调用的。</exception>
        <exception cref="T:System.OutOfMemoryException">没有足够的内存来继续执行该程序。</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">记录序列已满。</exception>
        <exception cref="T:System.IO.Log.ReservationNotFoundException">在 <paramref name="data" /> 中找不到足以容纳 <paramref name="reservations" /> 的预留。</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteRestartArea">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber WriteRestartArea (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber newBaseSeqNum, System.IO.Log.ReservationCollection reservations);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber WriteRestartArea(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber newBaseSeqNum, class System.IO.Log.ReservationCollection reservations) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.FileRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)" />
      <MemberSignature Language="VB.NET" Value="Public Function WriteRestartArea (data As IList(Of ArraySegment(Of Byte)), newBaseSeqNum As SequenceNumber, reservations As ReservationCollection) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber WriteRestartArea(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber newBaseSeqNum, System::IO::Log::ReservationCollection ^ reservations);" />
      <MemberSignature Language="F#" Value="abstract member WriteRestartArea : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.ReservationCollection -&gt; System.IO.Log.SequenceNumber&#xA;override this.WriteRestartArea : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.ReservationCollection -&gt; System.IO.Log.SequenceNumber" Usage="fileRecordSequence.WriteRestartArea (data, newBaseSeqNum, reservations)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="newBaseSeqNum" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="reservations" Type="System.IO.Log.ReservationCollection" />
      </Parameters>
      <Docs>
        <param name="data">将连接在一起并以记录形式追加的字节数组段的列表。</param>
        <param name="newBaseSeqNum">新的基序列号。 指定的序列号必须大于或等于当前基序列号。</param>
        <param name="reservations">一个 <see cref="T:System.IO.Log.ReservationCollection" />，它包含应当用于此重新开始区域的预留。</param>
        <summary>将重新开始区域写入 <see cref="T:System.IO.Log.FileRecordSequence" />。 无法继承此方法。</summary>
        <returns>写入的重新开始区域的序列号。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 重新开始区域可用于临时存储包含客户端最后一次检查点操作的信息。 需要恢复时，可以读取重新开始区域，并检索最后一次检查点操作中的所有数据。 这些数据将初始化事务表、脏页表和打开文件表，以便它们能够用于恢复过程。  
  
 可以使用 <xref:System.IO.Log.FileRecordSequence.ReadRestartAreas%2A> 方法来读取重新开始区域。  
  
 写入重新开始区域时，字节数组段中的数据将连接成单个字节数组，以便以记录形式追加。 在读取重新开始区域时，无法将数据重新拆分为数组段。  
  
 如果指定了预留，写入的重新开始区域将使用集合中包含的预留来占用先前已预留的空间。 如果该方法成功，它将占用能容纳数据的最小预留，而该预留将从集合中移除。  
  
 此方法成功完成时，基序列号已更新。 其序列号小于新的基序列号的所有日志记录都不可访问。  
  
 如果记录序列已经释放，或者如果传递了无效自变量，此操作内将立即引发异常。 异步追加请求过程中发生的错误（例如，I/O 请求过程中的磁盘故障）将导致在调用 <xref:System.IO.Log.FileRecordSequence.EndReserveAndAppend%2A> 方法时引发异常。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">一个或多个参数为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="newBaseSeqNum" /> 不在此序列的基序列号和最后一个序列号之间。  
  
- 或 - 
活动日志新存档或现有存档的尾数据或基数据无效。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="reservations" /> 不是由此记录序列创建的。  
  
- 或 - 
 <paramref name="newBaseSeqNum" /> 对此序列无效。</exception>
        <exception cref="T:System.NotSupportedException">由于记录序列是通过只读访问权限打开的，因此无法执行该操作。</exception>
        <exception cref="T:System.IO.IOException">由于出现意外的 I/O 异常，因此无法执行该请求。</exception>
        <exception cref="T:System.ObjectDisposedException">该方法是在序列已释放之后调用的。</exception>
        <exception cref="T:System.OutOfMemoryException">没有足够的内存来继续执行该程序。</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">记录序列已满。</exception>
        <exception cref="T:System.IO.Log.ReservationNotFoundException">在 <paramref name="data" /> 中找不到足以容纳 <paramref name="reservations" /> 的预留。</exception>
      </Docs>
    </Member>
  </Members>
</Type>
