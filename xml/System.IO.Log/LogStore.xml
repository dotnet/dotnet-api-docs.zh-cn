<Type Name="LogStore" FullName="System.IO.Log.LogStore">
  <Metadata><Meta Name="ms.openlocfilehash" Value="6738e76ff796796ee4d843a1a06b0995334ebd2c" /><Meta Name="ms.sourcegitcommit" Value="b53d35b4a410c949742abd4c6a989d1af5357bca" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-CN" /><Meta Name="ms.lasthandoff" Value="07/21/2020" /><Meta Name="ms.locfileid" Value="78824517" /></Metadata><TypeSignature Language="C#" Value="public sealed class LogStore : IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit LogStore extends System.Object implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.IO.Log.LogStore" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class LogStore&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class LogStore sealed : IDisposable" />
  <TypeSignature Language="F#" Value="type LogStore = class&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.IO.Log</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>表示日志结构化的存储区。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Log.LogRecordSequence> 类提供记录序列接口在公用日志文件系统 (CLFS) 日志之上的实现。 它与 <xref:System.IO.Log.LogStore> 类一起使用，该类提供了直接操作和管理 CLFS 日志文件的接口。 日志存储区提供跨一组磁盘范围的仅追加存储区。 <xref:System.IO.Log.LogStore> 类表示此存储区，并提供了添加和移除容器、设置策略以及创建存档的方法。 它不提供从存储区中读取和写入存储区的方法；这些方法是由 <xref:System.IO.Log.LogRecordSequence> 类提供的。  
  
 <xref:System.IO.Log.LogStore> 类和 <xref:System.IO.Log.LogRecordSequence> 类之间的关系类似于磁盘文件和 <xref:System.IO.FileStream> 对象之间的关系。 磁盘文件提供实际存储区，并具有诸如长度和上次访问时间这样的属性，而 <xref:System.IO.FileStream> 对象提供文件的视图，利用该视图可以从实际存储区中读取以及向其中写入数据。 与之类似，<xref:System.IO.Log.LogStore> 类具有诸如策略和磁盘范围集合这样的属性，<xref:System.IO.Log.LogRecordSequence> 类提供面向记录的机制，用于读取和写入数据。  
  
 与 <xref:System.IO.Log.FileRecordSequence> 类表示的文件记录序列不同，<xref:System.IO.Log.LogStore> 实例将其数据存储在 <xref:System.IO.Log.LogExtent> 实例表示的磁盘范围的集合中。 给定 <xref:System.IO.Log.LogStore> 实例中的所有范围都具有统一的大小，空间以范围增量的形式添加到 <xref:System.IO.Log.LogStore> 实例中及从其中移除。 若要添加和移除日志范围，请使用可由 <xref:System.IO.Log.LogExtentCollection.Add%2A> 属性返回的 <xref:System.IO.Log.LogExtentCollection.Remove%2A> 对象的 <xref:System.IO.Log.LogExtentCollection> 和 <xref:System.IO.Log.LogStore.Extents%2A> 方法。  
  
 <xref:System.IO.Log.LogStore> 实例可以具有与自己关联的策略。 这些策略由 <xref:System.IO.Log.LogPolicy> 实例表示，这些实例可由 <xref:System.IO.Log.LogStore.Policy%2A> 属性返回。 策略定义日志应遵循的规则（例如最大范围数和最小大小），以及对在特定条件下扩大或缩小 <xref:System.IO.Log.LogStore> 的指令。 此外，还可以指定是否能够存档 <xref:System.IO.Log.LogStore> 实例。 策略针对每个日志设置，而且是可变的。这表示，一旦日志的每个句柄都关闭了，策略也就不再存在了。  
  
   
  
## Examples  
 下面的示例演示如何将 <xref:System.IO.Log.LogStore> 存档到 XML 文档。  
  
 [!code-csharp[logarchievesnapshot#0](~/samples/snippets/csharp/VS_Snippets_CFX/logarchievesnapshot/cs/logarchievesnapshot.cs#0)]
 [!code-vb[logarchievesnapshot#0](~/samples/snippets/visualbasic/VS_Snippets_CFX/logarchievesnapshot/vb/logarchievesnapshot.vb#0)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>初始化 <see cref="T:System.IO.Log.LogStore" /> 类的新实例。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public LogStore (Microsoft.Win32.SafeHandles.SafeFileHandle handle);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class Microsoft.Win32.SafeHandles.SafeFileHandle handle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogStore.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (handle As SafeFileHandle)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; LogStore(Microsoft::Win32::SafeHandles::SafeFileHandle ^ handle);" />
      <MemberSignature Language="F#" Value="new System.IO.Log.LogStore : Microsoft.Win32.SafeHandles.SafeFileHandle -&gt; System.IO.Log.LogStore" Usage="new System.IO.Log.LogStore handle" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="handle" Type="Microsoft.Win32.SafeHandles.SafeFileHandle" />
      </Parameters>
      <Docs>
        <param name="handle">当前 <see cref="T:System.IO.Log.LogStore" /> 对象包装的日志文件的文件句柄。</param>
        <summary>为指定的句柄初始化 <see cref="T:System.IO.Log.LogStore" /> 类的新实例。</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="handle" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.IO.IOException">日志句柄无法绑定到线程池。</exception>
        <exception cref="T:System.UnauthorizedAccessException">操作系统拒绝了对指定的日志存储区的访问。</exception>
        <exception cref="T:System.ObjectDisposedException">该方法是在序列已释放之后调用的。</exception>
        <exception cref="T:System.OutOfMemoryException">没有足够的内存来继续执行程序。</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public LogStore (string path, System.IO.FileMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogStore.#ctor(System.String,System.IO.FileMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, mode As FileMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; LogStore(System::String ^ path, System::IO::FileMode mode);" />
      <MemberSignature Language="F#" Value="new System.IO.Log.LogStore : string * System.IO.FileMode -&gt; System.IO.Log.LogStore" Usage="new System.IO.Log.LogStore (path, mode)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
      </Parameters>
      <Docs>
        <param name="path">要打开的日志存储区的基文件的相对或绝对路径。</param>
        <param name="mode">用于确定如何打开或创建存储区的 <see cref="T:System.IO.FileMode" /> 值之一。</param>
        <summary>使用指定的路径和模式初始化 <see cref="T:System.IO.Log.LogStore" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此构造函数打开具有指定路径和模式的日志存储区。 存储区以读/写访问权限打开，并共享读访问权限。  
  
 `path` 参数应使用以下语法：  
  
 `log:<physical log name>[::<log client name>]`  
  
 其中 `<physical log name>` 是日志文件的有效路径，`<log client name>` 是唯一客户端标识符。 日志存储区应是物理日志存储区或虚拟日志存储区，但不能同时为两者。 以物理或虚拟方式创建日志存储区后，它在整个生命周期中都将保持该形态。 物理日志存储区是通过仅指定物理日志名称来创建的。 虚拟日志存储区是通过指定物理日志名称和日志客户端名称来创建的。  
  
 共享同一个物理日志名称的客户端将共享相同的范围集合与策略。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> 为空字符串 ("")。  
  
- 或 - 
 <paramref name="path" /> 仅包含空白。  
  
- 或 - 
 <paramref name="path" /> 包含一个或多个无效字符。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="mode" /> 包含无效值。</exception>
        <exception cref="T:System.IO.FileNotFoundException">无法找到该文件。</exception>
        <exception cref="T:System.IO.IOException">打开日志存储区时发生了 I/O 错误。</exception>
        <exception cref="T:System.UnauthorizedAccessException">操作系统拒绝了对指定的日志存储区的访问。</exception>
        <exception cref="T:System.PlatformNotSupportedException">无法使用 <see cref="T:System.IO.Log.LogStore" />，因为没有安装所需的公用日志文件系统 (CLFS) 组件。 如果可行，请为您的平台安装 CLFS 组件，或者改用 <see cref="T:System.IO.Log.FileRecordSequence" /> 类。</exception>
        <exception cref="T:System.OutOfMemoryException">没有足够的内存来继续执行程序。</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public LogStore (string path, System.IO.FileMode mode, System.IO.FileAccess access);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogStore.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, mode As FileMode, access As FileAccess)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; LogStore(System::String ^ path, System::IO::FileMode mode, System::IO::FileAccess access);" />
      <MemberSignature Language="F#" Value="new System.IO.Log.LogStore : string * System.IO.FileMode * System.IO.FileAccess -&gt; System.IO.Log.LogStore" Usage="new System.IO.Log.LogStore (path, mode, access)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
      </Parameters>
      <Docs>
        <param name="path">要打开的日志存储区的基文件的相对或绝对路径。</param>
        <param name="mode">用于确定如何打开或创建存储区的 <see cref="T:System.IO.FileMode" /> 值之一。</param>
        <param name="access">用于确定 <see cref="T:System.IO.FileAccess" /> 可以如何访问文件的 <see cref="T:System.IO.Log.LogStore" /> 值之一。</param>
        <summary>使用指定的路径、模式和访问权限初始化 <see cref="T:System.IO.Log.LogStore" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此构造函数打开具有指定的路径、模式和访问权限的新日志存储区。 并打开了存储区以共享读访问权限。  
  
 `path` 参数应使用以下语法：  
  
 `log:<physical log name>[::<log client name>]`  
  
 其中 `<physical log name>` 是日志文件的有效路径，`<log client name>` 是唯一客户端标识符。 日志存储区应是物理日志存储区或虚拟日志存储区，但不能同时为两者。 以物理或虚拟方式创建日志存储区后，它在整个生命周期中都将保持该形态。 物理日志存储区是通过仅指定物理日志名称来创建的。 虚拟日志存储区是通过指定物理日志名称和日志客户端名称来创建的。  
  
 共享同一个物理日志名称的客户端将共享相同的范围集合与策略。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> 为空字符串 ("")。  
  
- 或 - 
 <paramref name="path" /> 仅包含空白。  
  
- 或 - 
 <paramref name="path" /> 包含一个或多个无效字符。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="mode" /> 包含无效值。  
  
- 或 - 
 <paramref name="access" /> 包含无效值。</exception>
        <exception cref="T:System.IO.FileNotFoundException">无法找到该文件。</exception>
        <exception cref="T:System.IO.IOException">打开日志存储区时发生了 I/O 错误。</exception>
        <exception cref="T:System.UnauthorizedAccessException">操作系统拒绝了对指定的日志存储区的访问。</exception>
        <exception cref="T:System.PlatformNotSupportedException">无法使用 <see cref="T:System.IO.Log.LogStore" />，因为没有安装所需的公用日志文件系统 (CLFS) 组件。 如果可行，请为您的平台安装 CLFS 组件，或者改用 <see cref="T:System.IO.Log.FileRecordSequence" /> 类。</exception>
        <exception cref="T:System.OutOfMemoryException">没有足够的内存来继续执行程序。</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public LogStore (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access, valuetype System.IO.FileShare share) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogStore.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, mode As FileMode, access As FileAccess, share As FileShare)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; LogStore(System::String ^ path, System::IO::FileMode mode, System::IO::FileAccess access, System::IO::FileShare share);" />
      <MemberSignature Language="F#" Value="new System.IO.Log.LogStore : string * System.IO.FileMode * System.IO.FileAccess * System.IO.FileShare -&gt; System.IO.Log.LogStore" Usage="new System.IO.Log.LogStore (path, mode, access, share)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="share" Type="System.IO.FileShare" />
      </Parameters>
      <Docs>
        <param name="path">要打开的日志存储区的基文件的相对或绝对路径。</param>
        <param name="mode">用于确定如何打开或创建存储区的 <see cref="T:System.IO.FileMode" /> 值之一。</param>
        <param name="access">用于确定 <see cref="T:System.IO.FileAccess" /> 可以如何访问文件的 <see cref="T:System.IO.Log.LogStore" /> 值之一。</param>
        <param name="share">用于确定日志存储区将如何在进程之间共享的 <see cref="T:System.IO.FileShare" /> 值之一。</param>
        <summary>初始化 <see cref="T:System.IO.Log.LogStore" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此构造函数初始化它以指定的路径、模式和访问权限打开的新 <xref:System.IO.Log.LogStore> 对象。 并打开了存储区以共享指定的访问权限。  
  
 `path` 参数应使用以下语法：  
  
 `log:<physical log name>[::<log client name>]`  
  
 其中 `<physical log name>` 是日志文件的有效路径，`<log client name>` 是唯一客户端标识符。 日志存储区应是物理日志存储区或虚拟日志存储区，但不能同时为两者。 以物理或虚拟方式创建日志存储区后，它在整个生命周期中都将保持该形态。 物理日志存储区是通过仅指定物理日志名称来创建的。 虚拟日志存储区是通过指定物理日志名称和日志客户端名称来创建的。  
  
 共享同一个物理日志名称的客户端将共享相同的范围集合与策略。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> 为空字符串 ("")。  
  
- 或 - 
 <paramref name="path" /> 仅包含空白。  
  
- 或 - 
 <paramref name="path" /> 包含一个或多个无效字符。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="mode" /> 包含无效值。  
  
- 或 - 
 <paramref name="access" /> 包含无效值。  
  
- 或 - 
 <paramref name="share" /> 包含无效值。</exception>
        <exception cref="T:System.IO.FileNotFoundException">无法找到该文件。</exception>
        <exception cref="T:System.IO.IOException">打开日志存储区时发生了 I/O 错误。</exception>
        <exception cref="T:System.UnauthorizedAccessException">操作系统拒绝了对指定的日志存储区的访问。</exception>
        <exception cref="T:System.PlatformNotSupportedException">无法使用 <see cref="T:System.IO.Log.LogStore" />，因为没有安装所需的公用日志文件系统 (CLFS) 组件。 如果可行，请为您的平台安装 CLFS 组件，或者改用 <see cref="T:System.IO.Log.FileRecordSequence" /> 类。</exception>
        <exception cref="T:System.OutOfMemoryException">没有足够的内存来继续执行程序。</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public LogStore (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share, System.Security.AccessControl.FileSecurity fileSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access, valuetype System.IO.FileShare share, class System.Security.AccessControl.FileSecurity fileSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogStore.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Security.AccessControl.FileSecurity)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, mode As FileMode, access As FileAccess, share As FileShare, fileSecurity As FileSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; LogStore(System::String ^ path, System::IO::FileMode mode, System::IO::FileAccess access, System::IO::FileShare share, System::Security::AccessControl::FileSecurity ^ fileSecurity);" />
      <MemberSignature Language="F#" Value="new System.IO.Log.LogStore : string * System.IO.FileMode * System.IO.FileAccess * System.IO.FileShare * System.Security.AccessControl.FileSecurity -&gt; System.IO.Log.LogStore" Usage="new System.IO.Log.LogStore (path, mode, access, share, fileSecurity)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="share" Type="System.IO.FileShare" />
        <Parameter Name="fileSecurity" Type="System.Security.AccessControl.FileSecurity" />
      </Parameters>
      <Docs>
        <param name="path">要打开的日志存储区的基文件的相对或绝对路径。</param>
        <param name="mode">用于确定如何打开或创建存储区的 <see cref="T:System.IO.FileMode" /> 值之一。</param>
        <param name="access">用于确定 <see cref="T:System.IO.FileAccess" /> 可以如何访问文件的 <see cref="T:System.IO.Log.LogStore" /> 值之一。</param>
        <param name="share">用于确定日志存储区将如何在进程之间共享的 <see cref="T:System.IO.FileShare" /> 值之一。</param>
        <param name="fileSecurity"><see cref="T:System.Security.AccessControl.FileSecurity" /> 值之一，指定在必须创建存储区的情况下，要为新创建的存储区设置的安全性。</param>
        <summary>初始化 <see cref="T:System.IO.Log.LogStore" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此构造函数初始化它以指定的路径、模式和访问权限打开的新 <xref:System.IO.Log.LogStore> 对象。 并打开了存储区以共享指定的访问权限。 `path` 参数应遵循以下语法：  
  
 `log:<physical log name>[::<log client name>]`  
  
 其中 `<physical log name>` 是日志文件的有效路径，`<log client name>` 是唯一客户端标识符。 日志存储区应是物理日志存储区或虚拟日志存储区，但不能同时为两者。 以物理或虚拟方式创建日志存储区后，它在整个生命周期中都将保持该形态。 物理日志存储区是通过仅指定物理日志名称来创建的。 虚拟日志存储区是通过指定物理日志名称和日志客户端名称来创建的。  
  
 共享同一个物理日志名称的客户端将共享相同的范围集合与策略。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> 指定的日志存储区文件名无效。  
  
- 或 - 
 <paramref name="Mode" /> 为 <see langword="CreateNew" />，在没有写访问权限的情况下无法使用它。  
  
- 或 - 
 <paramref name="Mode" /> 为 <see langword="OpenOrCreate" />，在没有写访问权限的情况下无法使用它。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="mode" /> 包含无效值。  
  
- 或 - 
 <paramref name="access" /> 包含无效值。  
  
- 或 - 
 <paramref name="share" /> 包含无效值。</exception>
        <exception cref="T:System.IO.FileNotFoundException">无法找到该文件。</exception>
        <exception cref="T:System.IO.IOException">打开日志存储区时发生了 I/O 错误。  
  
无法访问 <paramref name="path" /> 指定的文件，因为另一个进程正在使用该文件。  
  
- 或 - 
无法创建 <paramref name="path" /> 指定的文件，因为该文件或目录已存在。  
  
- 或 - 
日志句柄无法绑定到线程池。  
  
- 或 - 
指定的日志文件格式或版本无效。</exception>
        <exception cref="T:System.PlatformNotSupportedException">无法使用 <see cref="T:System.IO.Log.LogStore" />，因为没有安装所需的公用日志文件系统 (CLFS) 组件。 如果可行，请为您的平台安装 CLFS 组件，或者改用 <see cref="T:System.IO.Log.FileRecordSequence" /> 类。</exception>
        <exception cref="T:System.ObjectDisposedException">该方法是在序列已释放之后调用的。</exception>
        <exception cref="T:System.OutOfMemoryException">没有足够的内存来继续执行程序。</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">记录序列已满。</exception>
        <exception cref="T:System.UnauthorizedAccessException">操作系统拒绝了对指定的日志存储区的访问。</exception>
      </Docs>
    </Member>
    <Member MemberName="Archivable">
      <MemberSignature Language="C#" Value="public bool Archivable { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Archivable" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.LogStore.Archivable" />
      <MemberSignature Language="VB.NET" Value="Public Property Archivable As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Archivable { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Archivable : bool with get, set" Usage="System.IO.Log.LogStore.Archivable" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取指示是否可对 <see cref="T:System.IO.Log.LogStore" /> 实例进行存档的值。</summary>
        <value>如果此 <see langword="true" /> 实例可以存档，则为 <see cref="T:System.IO.Log.LogStore" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果 <xref:System.IO.Log.LogStore> 是不可存档的，则对 <xref:System.IO.Log.LogStore.CreateLogArchiveSnapshot%2A> 和 <xref:System.IO.Log.LogStore.SetArchiveTail%2A> 方法的调用会导致引发 <xref:System.NotSupportedException>。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">该属性是在序列已释放之后访问的。</exception>
      </Docs>
    </Member>
    <Member MemberName="BaseSequenceNumber">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber BaseSequenceNumber { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.IO.Log.SequenceNumber BaseSequenceNumber" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.LogStore.BaseSequenceNumber" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property BaseSequenceNumber As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Log::SequenceNumber BaseSequenceNumber { System::IO::Log::SequenceNumber get(); };" />
      <MemberSignature Language="F#" Value="member this.BaseSequenceNumber : System.IO.Log.SequenceNumber" Usage="System.IO.Log.LogStore.BaseSequenceNumber" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取与此 <see cref="T:System.IO.Log.LogStore" /> 实例中有效记录对应的最低序列号。</summary>
        <value>与此 <see cref="T:System.IO.Log.LogStore" /> 实例中有效记录对应的最低序列号。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 有效序列号大于或等于 <xref:System.IO.Log.LogStore.BaseSequenceNumber%2A> 且小于 <xref:System.IO.Log.LogStore.LastSequenceNumber%2A>。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">该属性是在序列已释放之后访问的。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateLogArchiveSnapshot">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>拍摄制作备份所需的日志存储区状态的快照。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateLogArchiveSnapshot">
      <MemberSignature Language="C#" Value="public System.IO.Log.LogArchiveSnapshot CreateLogArchiveSnapshot ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Log.LogArchiveSnapshot CreateLogArchiveSnapshot() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogStore.CreateLogArchiveSnapshot" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateLogArchiveSnapshot () As LogArchiveSnapshot" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::LogArchiveSnapshot ^ CreateLogArchiveSnapshot();" />
      <MemberSignature Language="F#" Value="member this.CreateLogArchiveSnapshot : unit -&gt; System.IO.Log.LogArchiveSnapshot" Usage="logStore.CreateLogArchiveSnapshot " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.LogArchiveSnapshot</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>拍摄日志存储区状态的快照，以制作备份。</summary>
        <returns>一个包含制作存档所需状态的 <see cref="T:System.IO.Log.LogArchiveSnapshot" /> 对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下面的示例演示如何将 <xref:System.IO.Log.LogStore> 存档到 XML 文档。  
  
 [!code-csharp[logarchievesnapshot#0](~/samples/snippets/csharp/VS_Snippets_CFX/logarchievesnapshot/cs/logarchievesnapshot.cs#0)]
 [!code-vb[logarchievesnapshot#0](~/samples/snippets/visualbasic/VS_Snippets_CFX/logarchievesnapshot/vb/logarchievesnapshot.vb#0)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">日志存储区不可存档。</exception>
        <exception cref="T:System.ObjectDisposedException">该方法是在序列已释放之后调用的。</exception>
        <exception cref="T:System.IO.IOException">创建存档快照时发生 I/O 错误。</exception>
        <exception cref="T:System.ArgumentException">自变量无效。</exception>
        <exception cref="T:System.InvalidOperationException">执行了无效的操作。</exception>
        <exception cref="T:System.OutOfMemoryException">没有足够的内存来继续执行程序。</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">记录序列已满。</exception>
        <exception cref="T:System.UnauthorizedAccessException">操作系统拒绝了对指定的日志存储区的访问。</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateLogArchiveSnapshot">
      <MemberSignature Language="C#" Value="public System.IO.Log.LogArchiveSnapshot CreateLogArchiveSnapshot (System.IO.Log.SequenceNumber first, System.IO.Log.SequenceNumber last);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Log.LogArchiveSnapshot CreateLogArchiveSnapshot(valuetype System.IO.Log.SequenceNumber first, valuetype System.IO.Log.SequenceNumber last) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogStore.CreateLogArchiveSnapshot(System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateLogArchiveSnapshot (first As SequenceNumber, last As SequenceNumber) As LogArchiveSnapshot" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::LogArchiveSnapshot ^ CreateLogArchiveSnapshot(System::IO::Log::SequenceNumber first, System::IO::Log::SequenceNumber last);" />
      <MemberSignature Language="F#" Value="member this.CreateLogArchiveSnapshot : System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber -&gt; System.IO.Log.LogArchiveSnapshot" Usage="logStore.CreateLogArchiveSnapshot (first, last)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.LogArchiveSnapshot</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="first" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="last" Type="System.IO.Log.SequenceNumber" />
      </Parameters>
      <Docs>
        <param name="first">要存档的范围中的起始序列号。</param>
        <param name="last">要存档的范围中的结束序列号。</param>
        <summary>拍摄指定序列号之间的日志存储区状态的快照，以制作备份。</summary>
        <returns>一个包含制作存档所需状态的 <see cref="T:System.IO.Log.LogArchiveSnapshot" /> 对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法返回的存档快照包含从基序列号或存档序列号（两者的较低者）到最新序列号之间的信息。 其中不包含最新序列号，这表示，存档仅包含截至但不包括最后一条的记录。 此外，使用此方法时，起始 SequenceNumber 必须等于 BaseSequenceNumber，以保证存档的一致性。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="first" /> 或 <paramref name="last" /> 不在此序列的基序列号和最新序列号之间。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="first" /> 大于 <paramref name="last" />。</exception>
        <exception cref="T:System.InvalidOperationException">执行了无效的操作。</exception>
        <exception cref="T:System.IO.IOException">创建存档快照时发生 I/O 错误。</exception>
        <exception cref="T:System.NotSupportedException">日志存储区不可存档。</exception>
        <exception cref="T:System.ObjectDisposedException">该方法是在序列已释放之后调用的。</exception>
        <exception cref="T:System.OutOfMemoryException">没有足够的内存来继续执行程序。</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">记录序列已满。</exception>
        <exception cref="T:System.UnauthorizedAccessException">操作系统拒绝了对指定的日志存储区的访问。</exception>
      </Docs>
    </Member>
    <Member MemberName="Delete">
      <MemberSignature Language="C#" Value="public static void Delete (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Delete(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogStore.Delete(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Delete (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Delete(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member Delete : string -&gt; unit" Usage="System.IO.Log.LogStore.Delete path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">要移除的日志存储区的基文件的相对或绝对路径。</param>
        <summary>移除日志存储区。</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> 为空字符串 ("")。  
  
- 或 - 
 <paramref name="path" /> 仅包含空白。  
  
- 或 - 
 <paramref name="path" /> 包含一个或多个无效字符。</exception>
        <exception cref="T:System.IO.FileNotFoundException">无法找到该文件。</exception>
        <exception cref="T:System.IO.IOException">打开日志存储区时发生了 I/O 错误。</exception>
        <exception cref="T:System.UnauthorizedAccessException">操作系统拒绝了对指定的日志存储区的访问。</exception>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogStore.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="logStore.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>释放由 <see cref="T:System.IO.Log.LogStore" /> 使用的所有资源。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用完 <xref:System.IO.Log.LogStore.Dispose%2A> 之后，调用 <xref:System.IO.Log.LogStore>。 <xref:System.IO.Log.LogStore.Dispose%2A> 方法使 <xref:System.IO.Log.LogStore> 处于不可用状态。 调用 <xref:System.IO.Log.LogStore.Dispose%2A> 之后，必须释放对 <xref:System.IO.Log.LogStore> 的所有引用，以便垃圾回收器能够回收 <xref:System.IO.Log.LogStore> 占用的内存。  
  
> [!NOTE]
>  每次释放对 <xref:System.IO.Log.LogStore.Dispose%2A> 的最后一个引用前，均应调用 <xref:System.IO.Log.LogStore>。 否则，在垃圾回收器调用 <xref:System.IO.Log.LogStore> 对象的 `Finalize` 方法之前，该对象正在使用的资源不会被释放。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">该方法是在序列已释放之后调用的。</exception>
      </Docs>
    </Member>
    <Member MemberName="Extents">
      <MemberSignature Language="C#" Value="public System.IO.Log.LogExtentCollection Extents { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.Log.LogExtentCollection Extents" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.LogStore.Extents" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Extents As LogExtentCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Log::LogExtentCollection ^ Extents { System::IO::Log::LogExtentCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Extents : System.IO.Log.LogExtentCollection" Usage="System.IO.Log.LogStore.Extents" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.LogExtentCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个日志范围集合，这些日志范围包含此日志存储区的数据。</summary>
        <value>一个包含日志范围集合的 <see cref="T:System.IO.Log.LogExtentCollection" /> 实例，该集合中封装了此日志存储区的数据。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Log.LogStore> 实例将其数据存储在磁盘范围的集合中，这些范围由 <xref:System.IO.Log.LogExtent> 实例表示。 给定 <xref:System.IO.Log.LogStore> 实例中的所有范围都具有统一的大小，空间以范围增量的形式添加到 <xref:System.IO.Log.LogStore> 实例中及从其中移除。 若要添加和移除日志范围，请使用由此属性返回的 <xref:System.IO.Log.LogExtentCollection.Add%2A> 对象的 <xref:System.IO.Log.LogExtentCollection.Remove%2A> 和 <xref:System.IO.Log.LogExtentCollection> 方法。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FreeBytes">
      <MemberSignature Language="C#" Value="public long FreeBytes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 FreeBytes" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.LogStore.FreeBytes" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property FreeBytes As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long FreeBytes { long get(); };" />
      <MemberSignature Language="F#" Value="member this.FreeBytes : int64" Usage="System.IO.Log.LogStore.FreeBytes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取日志存储区中的可用字节数。</summary>
        <value>日志存储区中的可用字节数。</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">该属性是在序列已释放之后访问的。</exception>
      </Docs>
    </Member>
    <Member MemberName="Handle">
      <MemberSignature Language="C#" Value="public Microsoft.Win32.SafeHandles.SafeFileHandle Handle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.Win32.SafeHandles.SafeFileHandle Handle" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.LogStore.Handle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Handle As SafeFileHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Microsoft::Win32::SafeHandles::SafeFileHandle ^ Handle { Microsoft::Win32::SafeHandles::SafeFileHandle ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Handle : Microsoft.Win32.SafeHandles.SafeFileHandle" Usage="System.IO.Log.LogStore.Handle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.SafeHandles.SafeFileHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取当前 <see cref="T:System.IO.Log.LogStore" /> 实例封装的日志文件的操作系统文件句柄。</summary>
        <value>当前 <see cref="T:System.IO.Log.LogStore" /> 实例封装的日志文件的操作系统文件句柄。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LastSequenceNumber">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber LastSequenceNumber { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.IO.Log.SequenceNumber LastSequenceNumber" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.LogStore.LastSequenceNumber" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LastSequenceNumber As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Log::SequenceNumber LastSequenceNumber { System::IO::Log::SequenceNumber get(); };" />
      <MemberSignature Language="F#" Value="member this.LastSequenceNumber : System.IO.Log.SequenceNumber" Usage="System.IO.Log.LogStore.LastSequenceNumber" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在派生类中被重写时，获取要追加到日志存储区中的下一条记录的序列号。</summary>
        <value>要追加到日志存储区中的下一条记录的序列号。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 有效序列号大于或等于 <xref:System.IO.Log.LogStore.BaseSequenceNumber%2A> 且小于 <xref:System.IO.Log.LogStore.LastSequenceNumber%2A>。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">该属性是在序列已释放之后访问的。</exception>
      </Docs>
    </Member>
    <Member MemberName="Length">
      <MemberSignature Language="C#" Value="public long Length { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Length" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.LogStore.Length" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Length As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long Length { long get(); };" />
      <MemberSignature Language="F#" Value="member this.Length : int64" Usage="System.IO.Log.LogStore.Length" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取日志存储区的大小（以字节为单位）。</summary>
        <value>日志存储区的大小（以字节为单位）。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 日志存储区的大小是日志范围的大小之和。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">该属性是在序列已释放之后访问的。</exception>
      </Docs>
    </Member>
    <Member MemberName="Policy">
      <MemberSignature Language="C#" Value="public System.IO.Log.LogPolicy Policy { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.Log.LogPolicy Policy" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.LogStore.Policy" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Policy As LogPolicy" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Log::LogPolicy ^ Policy { System::IO::Log::LogPolicy ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Policy : System.IO.Log.LogPolicy" Usage="System.IO.Log.LogStore.Policy" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.LogPolicy</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取与此日志存储区关联的策略。</summary>
        <value>一个 <see cref="T:System.IO.Log.LogPolicy" /> 实例，表示与此日志存储区关联的策略。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此属性返回的 <xref:System.IO.Log.LogPolicy> 实例可以检验和操作与此 <xref:System.IO.Log.LogStore> 关联的日志策略。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetArchiveTail">
      <MemberSignature Language="C#" Value="public void SetArchiveTail (System.IO.Log.SequenceNumber archiveTail);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetArchiveTail(valuetype System.IO.Log.SequenceNumber archiveTail) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogStore.SetArchiveTail(System.IO.Log.SequenceNumber)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetArchiveTail (archiveTail As SequenceNumber)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetArchiveTail(System::IO::Log::SequenceNumber archiveTail);" />
      <MemberSignature Language="F#" Value="member this.SetArchiveTail : System.IO.Log.SequenceNumber -&gt; unit" Usage="logStore.SetArchiveTail archiveTail" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="archiveTail" Type="System.IO.Log.SequenceNumber" />
      </Parameters>
      <Docs>
        <param name="archiveTail">存档尾数据的序列号。</param>
        <summary>设置存档尾数据的序列号。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 基序列号和存档尾数据中的较小者决定日志的尾数据。  
  
   
  
## Examples  
 下面的示例演示如何将 <xref:System.IO.Log.LogStore> 存档到 XML 文档。  
  
 [!code-csharp[logarchievesnapshot#0](~/samples/snippets/csharp/VS_Snippets_CFX/logarchievesnapshot/cs/logarchievesnapshot.cs#0)]
 [!code-vb[logarchievesnapshot#0](~/samples/snippets/visualbasic/VS_Snippets_CFX/logarchievesnapshot/vb/logarchievesnapshot.vb#0)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="archiveTail" /> 不在此序列的基序列号和最后一个序列号之间。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="archiveTail" /> 对此序列无效。</exception>
        <exception cref="T:System.InvalidOperationException">执行了无效的操作。</exception>
        <exception cref="T:System.IO.IOException">创建存档快照时发生 I/O 错误。</exception>
        <exception cref="T:System.NotSupportedException">日志存储区不可存档。</exception>
        <exception cref="T:System.ObjectDisposedException">该方法是在序列已释放之后调用的。</exception>
        <exception cref="T:System.OutOfMemoryException">没有足够的内存来继续执行程序。</exception>
        <exception cref="T:System.UnauthorizedAccessException">操作系统拒绝了对指定的日志存储区的访问。</exception>
      </Docs>
    </Member>
    <Member MemberName="StreamCount">
      <MemberSignature Language="C#" Value="public int StreamCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 StreamCount" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.LogStore.StreamCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property StreamCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int StreamCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.StreamCount : int" Usage="System.IO.Log.LogStore.StreamCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取此日志存储区中日志流的数量。</summary>
        <value>此日志存储区中日志流的数量。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
