<Type Name="IRecordSequence" FullName="System.IO.Log.IRecordSequence">
  <Metadata><Meta Name="ms.openlocfilehash" Value="7248fe2c35a5e7fd9474a60f86d8f13d2de89e3c" /><Meta Name="ms.sourcegitcommit" Value="c982ad9e10a242d90f1e631b5981570f9e5d9f34" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-CN" /><Meta Name="ms.lasthandoff" Value="09/10/2020" /><Meta Name="ms.locfileid" Value="89943855" /></Metadata><TypeSignature Language="C#" Value="public interface IRecordSequence : IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public interface auto ansi abstract IRecordSequence implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.IO.Log.IRecordSequence" />
  <TypeSignature Language="VB.NET" Value="Public Interface IRecordSequence&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public interface class IRecordSequence : IDisposable" />
  <TypeSignature Language="F#" Value="type IRecordSequence = interface&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.IO.Log</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>提供一系列记录的泛型接口。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Log.IRecordSequence> 接口提供了面向记录的流的抽象接口。 <xref:System.IO.Log.IRecordSequence> 实例可用于读取和写入日志记录。  
  
 <xref:System.IO.Log.IRecordSequence> 接口提供以下功能：  
  
-   使用 <xref:System.IO.Log.IRecordSequence.Append%2A> 方法追加日志记录。  
  
-   使用 <xref:System.IO.Log.IRecordSequence.ReadLogRecords%2A> 方法读取追加的记录。  
  
-   使用 <xref:System.IO.Log.IRecordSequence.WriteRestartArea%2A> 方法写入特殊的重新开始记录。  
  
-   使用 <xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A> 方法从最近写入的重新开始记录中读取重新开始记录。  
  
-   使用 <xref:System.IO.Log.IRecordSequence.Flush%2A> 方法将记录刷新到持久存储区。  
  
-   为要追加的记录保留空间。  
  
-   通过前调日志基数来释放日志空间。  
  
-   接收 <xref:System.IO.Log.IRecordSequence.TailPinned> 事件通知，移动日志的基数以释放空间。  
  
 日志记录被追加到 <xref:System.IO.Log.IRecordSequence> 实例，每条日志记录都分配有一个唯一的序号。 在给定的记录序列中，序号是严格递增的。 日志记录由不透明数据组成，它们以字节数组段的 <xref:System.IO.Log.IRecordSequence> 的形式提供给 <xref:System.Collections.IList> 实例。  
  
 <xref:System.IO.Log.IRecordSequence> 接口还公开一些基本属性，这些属性提供有关日志边界的信息。  
  
-   <xref:System.IO.Log.IRecordSequence.BaseSequenceNumber%2A> 属性包含记录序列中第一条有效记录的序列号。  
  
-   <xref:System.IO.Log.IRecordSequence.LastSequenceNumber%2A> 属性包含一个序列号，并且保证它大于最后追加的记录的序列号。  
  
-   <xref:System.IO.Log.IRecordSequence.RestartSequenceNumber%2A> 属性包含最后写入的重新开始区域的序列号。  
  
-   <xref:System.IO.Log.IRecordSequence.MaximumRecordLength%2A> 属性包含可以追加到序列或从序列中读取的最大记录的大小。  
  
-   <xref:System.IO.Log.IRecordSequence.ReservedBytes%2A> 属性包含在此记录序列中做出的所有预留的总大小。  
  
-   如果将 <xref:System.IO.Log.IRecordSequence.RetryAppend%2A> 属性设置为 `true`，且 <xref:System.IO.Log.IRecordSequence.Append%2A> 操作因为序列中没有空间而失败，则记录序列将尝试释放空间，然后重试追加操作。  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="AdvanceBaseSequenceNumber">
      <MemberSignature Language="C#" Value="public void AdvanceBaseSequenceNumber (System.IO.Log.SequenceNumber newBaseSequenceNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AdvanceBaseSequenceNumber(valuetype System.IO.Log.SequenceNumber newBaseSequenceNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.AdvanceBaseSequenceNumber(System.IO.Log.SequenceNumber)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AdvanceBaseSequenceNumber (newBaseSequenceNumber As SequenceNumber)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AdvanceBaseSequenceNumber(System::IO::Log::SequenceNumber newBaseSequenceNumber);" />
      <MemberSignature Language="F#" Value="abstract member AdvanceBaseSequenceNumber : System.IO.Log.SequenceNumber -&gt; unit" Usage="iRecordSequence.AdvanceBaseSequenceNumber newBaseSequenceNumber" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="newBaseSequenceNumber" Type="System.IO.Log.SequenceNumber" />
      </Parameters>
      <Docs>
        <param name="newBaseSequenceNumber">记录序列的新的基序列号。</param>
        <summary>前移日志的基序列号。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在使用 <xref:System.IO.Log.LogRecordSequence> 实例并尝试前移序列号以释放日志中的空间时，新的基序列号必须位于不同的日志范围中，以便将前一个范围标记为空。 不支持部分释放范围。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="newBaseSequenceNumber" /> 无效。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="newBaseSequenceNumber" /> 没有在日志中激活。</exception>
        <exception cref="T:System.IO.IOException">修改序列时，发生了 I/O 错误。</exception>
        <exception cref="T:System.ObjectDisposedException">该方法是在序列已释放之后调用的。</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">记录序列已满。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Append">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>在派生类中重写时，向 <see cref="T:System.IO.Log.IRecordSequence" /> 写入一条日志记录。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber Append (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber Append(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (data As ArraySegment(Of Byte), nextUndoRecord As SequenceNumber, previousRecord As SequenceNumber, recordAppendOptions As RecordAppendOptions) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::SequenceNumber Append(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions);" />
      <MemberSignature Language="F#" Value="abstract member Append : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions -&gt; System.IO.Log.SequenceNumber" Usage="iRecordSequence.Append (data, nextUndoRecord, previousRecord, recordAppendOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
      </Parameters>
      <Docs>
        <param name="data">将连接在一起并以记录形式追加的字节数组段的列表。</param>
        <param name="nextUndoRecord">用户指定顺序中下一条记录的序列号。</param>
        <param name="previousRecord">“上一个”顺序中下一条记录的序列号。</param>
        <param name="recordAppendOptions"><see cref="T:System.IO.Log.RecordAppendOptions" /> 的一个有效值，用于指定应如何写入数据。</param>
        <summary>在派生类中重写时，向 <see cref="T:System.IO.Log.IRecordSequence" /> 写入一条日志记录。</summary>
        <returns>追加的日志记录的序列号。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 包含在 `data` 参数中的数据将连接成单个字节数组，以便以记录形式追加。 但在读取记录时，无法将数据重新拆分为数组段。  
  
 通常，此方法在写入记录之前完成。 若要确保记录已写入，请使用 <xref:System.IO.Log.RecordAppendOptions.ForceFlush> 参数指定 `recordAppendOptions` 标志，或者调用 <xref:System.IO.Log.IRecordSequence.Flush%2A> 方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">一个或多个自变量无效。</exception>
        <exception cref="T:System.IO.IOException">追加记录时，发生了 I/O 错误。</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">记录序列无法获得足够的可用空间来容纳新记录。</exception>
        <exception cref="T:System.ObjectDisposedException">该方法是在序列已释放之后调用的。</exception>
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber Append (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber Append(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (data As IList(Of ArraySegment(Of Byte)), nextUndoRecord As SequenceNumber, previousRecord As SequenceNumber, recordAppendOptions As RecordAppendOptions) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::SequenceNumber Append(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions);" />
      <MemberSignature Language="F#" Value="abstract member Append : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions -&gt; System.IO.Log.SequenceNumber" Usage="iRecordSequence.Append (data, nextUndoRecord, previousRecord, recordAppendOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
      </Parameters>
      <Docs>
        <param name="data">将连接在一起并以记录形式追加的字节数组段的列表。</param>
        <param name="nextUndoRecord">用户指定顺序中下一条记录的序列号。</param>
        <param name="previousRecord">“上一个”顺序中下一条记录的序列号。</param>
        <param name="recordAppendOptions"><see cref="T:System.IO.Log.RecordAppendOptions" /> 的一个有效值，用于指定应如何写入数据。</param>
        <summary>在派生类中重写时，向 <see cref="T:System.IO.Log.IRecordSequence" /> 中追加一条日志记录。</summary>
        <returns>追加的日志记录的序列号。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 包含在 `data` 参数中的数据将连接成单个字节数组，以便以记录形式追加。 但在读取记录时，无法将数据重新拆分为数组段。  
  
 通常，此方法在写入记录之前完成。 若要确保记录已写入，请使用 <xref:System.IO.Log.RecordAppendOptions.ForceFlush> 参数指定 `recordAppendOptions` 标志，或者调用 <xref:System.IO.Log.IRecordSequence.Flush%2A> 方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">一个或多个自变量无效。</exception>
        <exception cref="T:System.IO.IOException">追加记录时，发生了 I/O 错误。</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">记录序列无法获得足够的可用空间来容纳新记录。</exception>
        <exception cref="T:System.ObjectDisposedException">该方法是在序列已释放之后调用的。</exception>
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber Append (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservations);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber Append(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.IO.Log.ReservationCollection reservations) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (data As ArraySegment(Of Byte), nextUndoRecord As SequenceNumber, previousRecord As SequenceNumber, recordAppendOptions As RecordAppendOptions, reservations As ReservationCollection) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::SequenceNumber Append(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, System::IO::Log::ReservationCollection ^ reservations);" />
      <MemberSignature Language="F#" Value="abstract member Append : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection -&gt; System.IO.Log.SequenceNumber" Usage="iRecordSequence.Append (data, nextUndoRecord, previousRecord, recordAppendOptions, reservations)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="reservations" Type="System.IO.Log.ReservationCollection" />
      </Parameters>
      <Docs>
        <param name="data">将连接在一起并以记录形式追加的字节数组段的列表。</param>
        <param name="nextUndoRecord">用户指定顺序中下一条记录的序列号。</param>
        <param name="previousRecord">“上一个”顺序中下一条记录的序列号。</param>
        <param name="recordAppendOptions"><see cref="T:System.IO.Log.RecordAppendOptions" /> 的一个有效值，用于指定应如何写入数据。</param>
        <param name="reservations">一个 <see cref="T:System.IO.Log.ReservationCollection" />，它包含应当用于此记录的预留。</param>
        <summary>在派生类中重写时，将使用序列中先前保留的空间向 <see cref="T:System.IO.Log.IRecordSequence" /> 中追加一条日志记录。</summary>
        <returns>追加的日志记录的序列号。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 包含在 `data` 参数中的数据将连接成单个字节数组，以便以记录形式追加。 但在读取记录时，无法将数据重新拆分为数组段。  
  
 追加的记录将使用 `reservations` 参数指定的预留来占用先前已预留的空间。 如果追加成功，它将占用能容纳数据的最小预留区域，而该预留区域将从集合中移除。  
  
 通常，此方法在写入记录之前完成。 若要确保记录已写入，请使用 <xref:System.IO.Log.RecordAppendOptions.ForceFlush> 参数指定 `recordAppendOptions` 标志，或者调用 <xref:System.IO.Log.IRecordSequence.Flush%2A> 方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">一个或多个自变量无效。</exception>
        <exception cref="T:System.IO.IOException">追加记录时，发生了 I/O 错误。</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">记录序列无法获得足够的可用空间来容纳新记录。</exception>
        <exception cref="T:System.ObjectDisposedException">该方法是在序列已释放之后调用的。</exception>
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber Append (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservations);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber Append(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.IO.Log.ReservationCollection reservations) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (data As IList(Of ArraySegment(Of Byte)), nextUndoRecord As SequenceNumber, previousRecord As SequenceNumber, recordAppendOptions As RecordAppendOptions, reservations As ReservationCollection) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::SequenceNumber Append(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, System::IO::Log::ReservationCollection ^ reservations);" />
      <MemberSignature Language="F#" Value="abstract member Append : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection -&gt; System.IO.Log.SequenceNumber" Usage="iRecordSequence.Append (data, nextUndoRecord, previousRecord, recordAppendOptions, reservations)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="reservations" Type="System.IO.Log.ReservationCollection" />
      </Parameters>
      <Docs>
        <param name="data">将连接在一起并以记录形式追加的字节数组段的列表。</param>
        <param name="nextUndoRecord">用户指定顺序中下一条记录的序列号。</param>
        <param name="previousRecord">“上一个”顺序中下一条记录的序列号。</param>
        <param name="recordAppendOptions"><see cref="T:System.IO.Log.RecordAppendOptions" /> 的一个有效值，用于指定应如何写入数据。</param>
        <param name="reservations">一个 <see cref="T:System.IO.Log.ReservationCollection" />，它包含应当用于此记录的预留。</param>
        <summary>在派生类中重写时，将使用序列中先前保留的空间向 <see cref="T:System.IO.Log.IRecordSequence" /> 中追加一条日志记录。</summary>
        <returns>追加的日志记录的序列号。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 包含在 `data` 参数中的数据将连接成单个字节数组，以便以记录形式追加。 但在读取记录时，无法将数据重新拆分为数组段。  
  
 追加的记录将使用 `reservations` 参数指定的预留来占用先前已预留的空间。 如果追加成功，它将占用能容纳数据的最小预留区域，而该预留区域将从集合中移除。  
  
 通常，此方法在写入记录之前完成。 若要确保记录已写入，请使用 <xref:System.IO.Log.RecordAppendOptions.ForceFlush> 参数指定 `recordAppendOptions` 标志，或者调用 <xref:System.IO.Log.IRecordSequence.Flush%2A> 方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">一个或多个自变量无效。</exception>
        <exception cref="T:System.IO.IOException">追加记录时，发生了 I/O 错误。</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">记录序列无法获得足够的可用空间来容纳新记录。</exception>
        <exception cref="T:System.ObjectDisposedException">该方法是在序列已释放之后调用的。</exception>
      </Docs>
    </Member>
    <Member MemberName="BaseSequenceNumber">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber BaseSequenceNumber { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.IO.Log.SequenceNumber BaseSequenceNumber" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.IRecordSequence.BaseSequenceNumber" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property BaseSequenceNumber As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Log::SequenceNumber BaseSequenceNumber { System::IO::Log::SequenceNumber get(); };" />
      <MemberSignature Language="F#" Value="member this.BaseSequenceNumber : System.IO.Log.SequenceNumber" Usage="System.IO.Log.IRecordSequence.BaseSequenceNumber" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在派生类中重写时，获取当前 <see cref="T:System.IO.Log.IRecordSequence" /> 中第一条有效记录的序列号。</summary>
        <value>与 <see cref="T:System.IO.Log.IRecordSequence" /> 中的有效记录对应的最低序列号。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 有效序列号大于或等于 <xref:System.IO.Log.IRecordSequence.BaseSequenceNumber%2A> 且小于 <xref:System.IO.Log.IRecordSequence.LastSequenceNumber%2A>。  
  
 此属性的值可以通过调用 <xref:System.IO.Log.IRecordSequence.AdvanceBaseSequenceNumber%2A> 或 <xref:System.IO.Log.IRecordSequence.WriteRestartArea%2A> 方法来更改。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">该属性是在序列已释放之后访问的。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginAppend">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>在派生类中重写时，开始异步追加操作。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginAppend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginAppend (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginAppend(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginAppend (data As ArraySegment(Of Byte), nextUndoRecord As SequenceNumber, previousRecord As SequenceNumber, recordAppendOptions As RecordAppendOptions, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginAppend(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginAppend : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * AsyncCallback * obj -&gt; IAsyncResult" Usage="iRecordSequence.BeginAppend (data, nextUndoRecord, previousRecord, recordAppendOptions, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="data">将连接在一起并以记录形式追加的字节数组段的列表。</param>
        <param name="nextUndoRecord">用户指定顺序中下一条记录的序列号。</param>
        <param name="previousRecord">“上一个”顺序中下一条记录的序列号。</param>
        <param name="recordAppendOptions"><see cref="T:System.IO.Log.RecordAppendOptions" /> 的一个有效值，用于指定应如何写入数据。</param>
        <param name="callback">可选的异步回调，在追加完成时调用。</param>
        <param name="state">用户提供的对象，用于将此特定异步追加请求与其他请求区别开来。</param>
        <summary>在派生类中重写时，开始异步追加操作。</summary>
        <returns>一个 <see cref="T:System.IAsyncResult" />，它表示可能仍处于挂起状态的异步追加。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 应将此方法返回的 <xref:System.IAsyncResult> 传递给 <xref:System.IO.Log.IRecordSequence.EndAppend%2A> 方法，以确保追加操作完成并能够适当释放资源。 如果在异步追加过程中发生错误，则在使用此方法返回的 <xref:System.IO.Log.IRecordSequence.EndAppend%2A> 调用 <xref:System.IAsyncResult> 方法之前，不会引发异常。  
  
 包含在 `data` 参数中的数据将连接成单个字节数组，以便以记录形式追加。 但在读取记录时，无法将数据重新拆分为数组段。  
  
 通常，此方法在写入记录之前完成。 若要确保记录已写入，请使用 <xref:System.IO.Log.RecordAppendOptions.ForceFlush> 参数指定 `recordAppendOptions` 标志，或者调用 <xref:System.IO.Log.IRecordSequence.Flush%2A> 方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">一个或多个自变量无效。</exception>
        <exception cref="T:System.IO.IOException">追加记录时，发生了 I/O 错误。</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">记录序列无法获得足够的可用空间来容纳新记录。</exception>
        <exception cref="T:System.ObjectDisposedException">该方法是在序列已释放之后调用的。</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginAppend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginAppend (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginAppend(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginAppend (data As IList(Of ArraySegment(Of Byte)), nextUndoRecord As SequenceNumber, previousRecord As SequenceNumber, recordAppendOptions As RecordAppendOptions, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginAppend(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginAppend : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * AsyncCallback * obj -&gt; IAsyncResult" Usage="iRecordSequence.BeginAppend (data, nextUndoRecord, previousRecord, recordAppendOptions, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="data">将连接在一起并以记录形式追加的字节数组段的列表。</param>
        <param name="nextUndoRecord">用户指定顺序中下一条记录的序列号。</param>
        <param name="previousRecord">“上一个”顺序中下一条记录的序列号。</param>
        <param name="recordAppendOptions"><see cref="T:System.IO.Log.RecordAppendOptions" /> 的一个有效值，用于指定应如何写入数据。</param>
        <param name="callback">可选的异步回调，在追加完成时调用。</param>
        <param name="state">用户提供的对象，用于将此特定异步追加请求与其他请求区别开来。</param>
        <summary>在派生类中重写时，将使用序列中先前保留的空间来开始异步追加操作。</summary>
        <returns>一个 <see cref="T:System.IAsyncResult" />，它表示可能仍处于挂起状态的异步追加。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 应将此方法返回的 <xref:System.IAsyncResult> 传递给 <xref:System.IO.Log.IRecordSequence.EndAppend%2A> 方法，以确保追加操作完成并能够适当释放资源。 如果在异步追加过程中发生错误，则在使用此方法返回的 <xref:System.IO.Log.IRecordSequence.EndAppend%2A> 调用 <xref:System.IAsyncResult> 方法之前，不会引发异常。  
  
 包含在 `data` 参数中的数据将连接成单个字节数组，以便以记录形式追加。 但在读取记录时，无法将数据重新拆分为数组段。  
  
 通常，此方法在写入记录之前完成。 若要确保记录已写入，请使用 <xref:System.IO.Log.RecordAppendOptions.ForceFlush> 参数指定 `recordAppendOptions` 标志，或者调用 <xref:System.IO.Log.IRecordSequence.Flush%2A> 方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">一个或多个自变量无效。</exception>
        <exception cref="T:System.IO.IOException">追加记录时，发生了 I/O 错误。</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">记录序列无法获得足够的可用空间来容纳新记录。</exception>
        <exception cref="T:System.ObjectDisposedException">该方法是在序列已释放之后调用的。</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginAppend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginAppend (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservations, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginAppend(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.IO.Log.ReservationCollection reservations, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginAppend (data As ArraySegment(Of Byte), nextUndoRecord As SequenceNumber, previousRecord As SequenceNumber, recordAppendOptions As RecordAppendOptions, reservations As ReservationCollection, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginAppend(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, System::IO::Log::ReservationCollection ^ reservations, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginAppend : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection * AsyncCallback * obj -&gt; IAsyncResult" Usage="iRecordSequence.BeginAppend (data, nextUndoRecord, previousRecord, recordAppendOptions, reservations, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="reservations" Type="System.IO.Log.ReservationCollection" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="data">将连接在一起并以记录形式追加的字节数组段的列表。</param>
        <param name="nextUndoRecord">用户指定顺序中下一条记录的序列号。</param>
        <param name="previousRecord">“上一个”顺序中下一条记录的序列号。</param>
        <param name="recordAppendOptions"><see cref="T:System.IO.Log.RecordAppendOptions" /> 的一个有效值，用于指定应如何写入数据。</param>
        <param name="reservations">一个 <see cref="T:System.IO.Log.ReservationCollection" />，它包含应当用于此记录的预留。</param>
        <param name="callback">可选的异步回调，在追加完成时调用。</param>
        <param name="state">用户提供的对象，用于将此特定异步追加请求与其他请求区别开来。</param>
        <summary>在派生类中重写时，将使用序列中先前保留的空间来开始异步追加操作。</summary>
        <returns>一个 <see cref="T:System.IAsyncResult" />，它表示可能仍处于挂起状态的异步追加。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 应将此方法返回的 <xref:System.IAsyncResult> 传递给 <xref:System.IO.Log.IRecordSequence.EndAppend%2A> 方法，以确保追加操作完成并能够适当释放资源。 如果在异步追加过程中发生错误，则在使用此方法返回的 <xref:System.IO.Log.IRecordSequence.EndAppend%2A> 调用 <xref:System.IAsyncResult> 方法之前，不会引发异常。  
  
 包含在 `data` 参数中的数据将连接成单个字节数组，以便以记录形式追加。 但在读取记录时，无法将数据重新拆分为数组段。  
  
 追加的记录将使用 `reservations` 参数指定的预留来占用先前已预留的空间。 如果追加成功，它将占用能容纳数据的最小预留区域，而该预留区域将从集合中移除。  
  
 通常，此方法在写入记录之前完成。 若要确保记录已写入，请使用 <xref:System.IO.Log.RecordAppendOptions.ForceFlush> 参数指定 `recordAppendOptions` 标志，或者调用 <xref:System.IO.Log.IRecordSequence.Flush%2A> 方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">一个或多个自变量无效。</exception>
        <exception cref="T:System.IO.IOException">追加记录时，发生了 I/O 错误。</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">记录序列无法获得足够的可用空间来容纳新记录。</exception>
        <exception cref="T:System.ObjectDisposedException">该方法是在序列已释放之后调用的。</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginAppend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginAppend (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousUndoRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservations, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginAppend(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousUndoRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.IO.Log.ReservationCollection reservations, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginAppend (data As IList(Of ArraySegment(Of Byte)), nextUndoRecord As SequenceNumber, previousUndoRecord As SequenceNumber, recordAppendOptions As RecordAppendOptions, reservations As ReservationCollection, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginAppend(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousUndoRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, System::IO::Log::ReservationCollection ^ reservations, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginAppend : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection * AsyncCallback * obj -&gt; IAsyncResult" Usage="iRecordSequence.BeginAppend (data, nextUndoRecord, previousUndoRecord, recordAppendOptions, reservations, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="reservations" Type="System.IO.Log.ReservationCollection" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="data">将连接在一起并以记录形式追加的字节数组段的列表。</param>
        <param name="nextUndoRecord">用户指定顺序中下一条记录的序列号。</param>
        <param name="previousUndoRecord">“上一个”顺序中下一条记录的序列号。</param>
        <param name="recordAppendOptions"><see cref="T:System.IO.Log.RecordAppendOptions" /> 的一个有效值，用于指定应如何写入数据。</param>
        <param name="reservations">一个 <see cref="T:System.IO.Log.ReservationCollection" />，它包含应当用于此记录的预留。</param>
        <param name="callback">可选的异步回调，在追加完成时调用。</param>
        <param name="state">用户提供的对象，用于将此特定异步追加请求与其他请求区别开来。</param>
        <summary>在派生类中重写时，将使用序列中先前保留的空间来开始异步追加操作。</summary>
        <returns>一个 <see cref="T:System.IAsyncResult" />，它表示可能仍处于挂起状态的异步追加。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 应将此方法返回的 <xref:System.IAsyncResult> 传递给 <xref:System.IO.Log.IRecordSequence.EndAppend%2A> 方法，以确保追加操作完成并能够适当释放资源。 如果在异步追加过程中发生错误，则在使用此方法返回的 <xref:System.IO.Log.IRecordSequence.EndAppend%2A> 调用 <xref:System.IAsyncResult> 方法之前，不会引发异常。  
  
 包含在 `data` 参数中的数据将连接成单个字节数组，以便以记录形式追加。 但在读取记录时，无法将数据重新拆分为数组段。  
  
 追加的记录将使用 `reservations` 参数指定的预留来占用先前已预留的空间。 如果追加成功，它将占用能容纳数据的最小预留区域，而该预留区域将从集合中移除。  
  
 通常，此方法在写入记录之前完成。 若要确保记录已写入，请使用 <xref:System.IO.Log.RecordAppendOptions.ForceFlush> 参数指定 `recordAppendOptions` 标志，或者调用 <xref:System.IO.Log.IRecordSequence.Flush%2A> 方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">一个或多个自变量无效。</exception>
        <exception cref="T:System.IO.IOException">追加记录时，发生了 I/O 错误。</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">记录序列无法获得足够的可用空间来容纳新记录。</exception>
        <exception cref="T:System.ObjectDisposedException">该方法是在序列已释放之后调用的。</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginFlush">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginFlush (System.IO.Log.SequenceNumber sequenceNumber, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginFlush(valuetype System.IO.Log.SequenceNumber sequenceNumber, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.BeginFlush(System.IO.Log.SequenceNumber,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginFlush (sequenceNumber As SequenceNumber, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginFlush(System::IO::Log::SequenceNumber sequenceNumber, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginFlush : System.IO.Log.SequenceNumber * AsyncCallback * obj -&gt; IAsyncResult" Usage="iRecordSequence.BeginFlush (sequenceNumber, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sequenceNumber" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="sequenceNumber">必须写入的最新记录的序列号。 如果此 <see cref="T:System.IO.Log.SequenceNumber" /> 无效，则必须写入所有记录。</param>
        <param name="callback">可选的异步回调，在刷新完成时调用。</param>
        <param name="state">用户提供的对象，用于将此特定异步刷新请求与其他请求区别开来。</param>
        <summary>在派生类中重写时，将使用序列中先前保留的空间来开始异步刷新操作。</summary>
        <returns>一个 <see cref="T:System.IAsyncResult" />，表示可能仍处于挂起状态的异步刷新操作。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 应将当前方法返回的 <xref:System.IAsyncResult> 传递给 <xref:System.IO.Log.IRecordSequence.EndFlush%2A> 方法，以确保刷新完成并适当释放资源。 如果在异步刷新过程中发生错误，则在使用此方法返回的 <xref:System.IO.Log.IRecordSequence.EndFlush%2A> 调用 <xref:System.IAsyncResult> 方法之前，不会引发异常。  
  
 调用此方法可以确保已追加到 <xref:System.IO.Log.IRecordSequence> 的所有记录都是持久写入的。  
  
 如果记录序列已经释放，或者如果传递了无效自变量，此操作内将立即引发异常。 异步刷新请求过程中发生的错误（例如，I/O 请求过程中的磁盘故障）将导致在调用 <xref:System.IO.Log.IRecordSequence.EndFlush%2A> 方法时引发异常。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">一个或多个自变量无效。</exception>
        <exception cref="T:System.IO.IOException">刷新数据时，发生了 I/O 错误。</exception>
        <exception cref="T:System.ObjectDisposedException">该方法是在序列已释放之后调用的。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginReserveAndAppend">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>在派生类中重写时，开始异步保留和追加操作。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginReserveAndAppend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReserveAndAppend (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservationCollection, long[] reservations, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginReserveAndAppend(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.IO.Log.ReservationCollection reservationCollection, int64[] reservations, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginReserveAndAppend (data As ArraySegment(Of Byte), nextUndoRecord As SequenceNumber, previousRecord As SequenceNumber, recordAppendOptions As RecordAppendOptions, reservationCollection As ReservationCollection, reservations As Long(), callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReserveAndAppend(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, System::IO::Log::ReservationCollection ^ reservationCollection, cli::array &lt;long&gt; ^ reservations, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginReserveAndAppend : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection * int64[] * AsyncCallback * obj -&gt; IAsyncResult" Usage="iRecordSequence.BeginReserveAndAppend (data, nextUndoRecord, previousRecord, recordAppendOptions, reservationCollection, reservations, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="reservationCollection" Type="System.IO.Log.ReservationCollection" />
        <Parameter Name="reservations" Type="System.Int64[]" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="data">将连接在一起并以记录形式追加的字节数组段的列表。</param>
        <param name="nextUndoRecord">用户指定顺序中下一条记录的序列号。</param>
        <param name="previousRecord">“上一个”顺序中下一条记录的序列号。</param>
        <param name="recordAppendOptions"><see cref="T:System.IO.Log.RecordAppendOptions" /> 的一个有效值，用于指定应如何写入数据。</param>
        <param name="reservationCollection">要在其中生成预留的预留集合。</param>
        <param name="reservations">要生成的预留（以字节为单位）。</param>
        <param name="callback">可选的异步回调，在追加完成时调用。</param>
        <param name="state">用户提供的对象，用于将此特定异步追加请求与其他请求区别开来。</param>
        <summary>在派生类中重写时，开始异步保留和追加操作。</summary>
        <returns>一个 <see cref="T:System.IAsyncResult" />，它表示可能仍处于挂起状态的当前异步操作。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 应将此方法返回的 <xref:System.IAsyncResult> 传递给 <xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A> 方法，以确保追加操作完成并能够适当释放资源。 如果在异步追加过程中发生错误，则在使用此方法返回的 <xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A> 调用 <xref:System.IAsyncResult> 方法之前，不会引发异常。  
  
 包含在 `data` 参数中的数据将连接成单个字节数组，以便以记录形式追加。 但在读取记录时，无法将数据重新拆分为数组段。  
  
 在原子操作中，使用记录追加操作将指定的预留添加到所提供的预留集合。 如果追加失败，将不保留任何空间。  
  
 通常，此方法可以在写入记录之前完成。 若要确保记录已写入，请使用 <xref:System.IO.Log.RecordAppendOptions.ForceFlush> 参数指定 `recordAppendOptions` 标志，或者调用 <xref:System.IO.Log.IRecordSequence.Flush%2A> 方法。  
  
 如果记录序列已经释放，或者如果传递了无效自变量，此操作内将立即引发异常。 异步追加请求过程中发生的错误（例如，I/O 请求过程中的磁盘故障）将导致在调用 <xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A> 方法时引发异常。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">一个或多个自变量无效。</exception>
        <exception cref="T:System.IO.IOException">追加记录时，发生了 I/O 错误。</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">记录序列无法获得足够的可用空间来容纳新记录或生成预留。</exception>
        <exception cref="T:System.ObjectDisposedException">该方法是在序列已释放之后调用的。</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginReserveAndAppend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReserveAndAppend (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservationCollection, long[] reservations, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginReserveAndAppend(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.IO.Log.ReservationCollection reservationCollection, int64[] reservations, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.BeginReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginReserveAndAppend (data As IList(Of ArraySegment(Of Byte)), nextUndoRecord As SequenceNumber, previousRecord As SequenceNumber, recordAppendOptions As RecordAppendOptions, reservationCollection As ReservationCollection, reservations As Long(), callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReserveAndAppend(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, System::IO::Log::ReservationCollection ^ reservationCollection, cli::array &lt;long&gt; ^ reservations, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginReserveAndAppend : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection * int64[] * AsyncCallback * obj -&gt; IAsyncResult" Usage="iRecordSequence.BeginReserveAndAppend (data, nextUndoRecord, previousRecord, recordAppendOptions, reservationCollection, reservations, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="reservationCollection" Type="System.IO.Log.ReservationCollection" />
        <Parameter Name="reservations" Type="System.Int64[]" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="data">将连接在一起并以记录形式追加的字节数组段的列表。</param>
        <param name="nextUndoRecord">用户指定顺序中下一条记录的序列号。</param>
        <param name="previousRecord">“上一个”顺序中下一条记录的序列号。</param>
        <param name="recordAppendOptions"><see cref="T:System.IO.Log.RecordAppendOptions" /> 的一个有效值，用于指定应如何写入数据。</param>
        <param name="reservationCollection">要在其中生成预留的预留集合。</param>
        <param name="reservations">要生成的预留（以字节为单位）。</param>
        <param name="callback">可选的异步回调，在追加完成时调用。</param>
        <param name="state">用户提供的对象，用于将此特定异步追加请求与其他请求区别开来。</param>
        <summary>在派生类中重写时，开始异步保留和追加操作。</summary>
        <returns>一个 <see cref="T:System.IAsyncResult" />，它表示可能仍处于挂起状态的当前异步操作。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 应将此方法返回的 <xref:System.IAsyncResult> 传递给 <xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A> 方法，以确保追加操作完成并能够适当释放资源。 如果在异步追加过程中发生错误，则在使用此方法返回的 <xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A> 调用 <xref:System.IAsyncResult> 方法之前，不会引发异常。  
  
 包含在 `data` 参数中的数据将连接成单个字节数组，以便以记录形式追加。 但在读取记录时，无法将数据重新拆分为数组段。  
  
 在原子操作中，使用记录追加操作将指定的预留添加到所提供的预留集合。 如果追加失败，将不保留任何空间。  
  
 通常，此方法可以在写入记录之前完成。 若要确保记录已写入，请使用 <xref:System.IO.Log.RecordAppendOptions.ForceFlush> 参数指定 `recordAppendOptions` 标志，或者调用 <xref:System.IO.Log.IRecordSequence.Flush%2A> 方法。  
  
 如果记录序列已经释放，或者如果传递了无效自变量，此操作内将立即引发异常。 异步追加请求过程中发生的错误（例如，I/O 请求过程中的磁盘故障）将导致在调用 <xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A> 方法时引发异常。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">一个或多个自变量无效。</exception>
        <exception cref="T:System.IO.IOException">追加记录时，发生了 I/O 错误。</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">记录序列无法获得足够的可用空间来容纳新记录或生成预留。</exception>
        <exception cref="T:System.ObjectDisposedException">该方法是在序列已释放之后调用的。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginWriteRestartArea">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>在派生类中重写时，开始异步重新开始区域写入操作。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginWriteRestartArea">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginWriteRestartArea (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber newBaseSequenceNumber, System.IO.Log.ReservationCollection reservation, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginWriteRestartArea(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber newBaseSequenceNumber, class System.IO.Log.ReservationCollection reservation, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginWriteRestartArea (data As ArraySegment(Of Byte), newBaseSequenceNumber As SequenceNumber, reservation As ReservationCollection, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginWriteRestartArea(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber newBaseSequenceNumber, System::IO::Log::ReservationCollection ^ reservation, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginWriteRestartArea : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.ReservationCollection * AsyncCallback * obj -&gt; IAsyncResult" Usage="iRecordSequence.BeginWriteRestartArea (data, newBaseSequenceNumber, reservation, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="newBaseSequenceNumber" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="reservation" Type="System.IO.Log.ReservationCollection" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="data">将连接在一起并以记录形式追加的字节数组段的列表。</param>
        <param name="newBaseSequenceNumber">新的基序列号。 指定的序列号必须大于或等于当前基序列号。</param>
        <param name="reservation">一个 <see cref="T:System.IO.Log.ReservationCollection" />，它包含应当用于此重新开始区域的预留。</param>
        <param name="callback">可选的异步回调，在重新开始区域写入完成时调用。</param>
        <param name="state">用户提供的对象，用于将此特定异步重新开始区域写入请求与其他请求区别开来。</param>
        <summary>在派生类中重写时，将使用序列中先前保留的空间来开始异步重新开始区域写入操作。</summary>
        <returns>一个 <see cref="T:System.IAsyncResult" />，它表示可能仍处于挂起状态的异步重新开始区域写入操作。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 应将此方法返回的 <xref:System.IAsyncResult> 传递给 <xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A> 方法，以确保重新开始区域写入操作完成并能够适当释放资源。 如果在异步重新开始区域写入操作过程中发生错误，则在使用此方法返回的 <xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A> 调用 <xref:System.IAsyncResult> 方法之前，不会引发异常。  
  
 包含在 `data` 参数中的数据将连接成单个字节数组，以便以记录形式追加。 但在读取记录时，无法将数据重新拆分为数组段。  
  
 操作成功完成时，基序列号已更新。 其序列号小于新的基序列号的所有日志记录都不可访问。  
  
 如果指定了 <xref:System.IO.Log.ReservationCollection>，写入的重新开始区域将使用集合中包含的预留来占用先前已预留的空间。 如果该方法成功，它将占用能容纳数据的最小预留，而该预留将从集合中移除。  
  
 如果记录序列已经释放，或者如果传递了无效自变量，此操作内将立即引发异常。 异步追加请求过程中发生的错误（例如，I/O 请求过程中的磁盘故障）将导致在调用 <xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A> 方法时引发异常。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginWriteRestartArea">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginWriteRestartArea (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber newBaseSequenceNumber, System.IO.Log.ReservationCollection reservation, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginWriteRestartArea(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber newBaseSequenceNumber, class System.IO.Log.ReservationCollection reservation, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginWriteRestartArea (data As IList(Of ArraySegment(Of Byte)), newBaseSequenceNumber As SequenceNumber, reservation As ReservationCollection, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginWriteRestartArea(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber newBaseSequenceNumber, System::IO::Log::ReservationCollection ^ reservation, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginWriteRestartArea : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.ReservationCollection * AsyncCallback * obj -&gt; IAsyncResult" Usage="iRecordSequence.BeginWriteRestartArea (data, newBaseSequenceNumber, reservation, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="newBaseSequenceNumber" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="reservation" Type="System.IO.Log.ReservationCollection" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="data">将连接在一起并以记录形式追加的字节数组段的列表。</param>
        <param name="newBaseSequenceNumber">新的基序列号。 指定的序列号必须大于或等于当前基序列号。</param>
        <param name="reservation">一个 <see cref="T:System.IO.Log.ReservationCollection" />，它包含应当用于此重新开始区域的预留。</param>
        <param name="callback">可选的异步回调，在重新开始区域写入完成时调用。</param>
        <param name="state">用户提供的对象，用于将此特定异步重新开始区域写入请求与其他请求区别开来。</param>
        <summary>在派生类中重写时，将使用序列中先前保留的空间来开始异步重新开始区域写入操作。</summary>
        <returns>一个 <see cref="T:System.IAsyncResult" />，它表示可能仍处于挂起状态的异步重新开始区域写入操作。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 应将此方法返回的 <xref:System.IAsyncResult> 传递给 <xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A> 方法，以确保重新开始区域写入操作完成并能够适当释放资源。 如果在异步重新开始区域写入操作过程中发生错误，则在使用此方法返回的 <xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A> 调用 <xref:System.IAsyncResult> 方法之前，不会引发异常。  
  
 包含在 `data` 参数中的数据将连接成单个字节数组，以便以记录形式追加。 但在读取记录时，无法将数据重新拆分为数组段。  
  
 操作成功完成时，基序列号已更新。 其序列号小于新的基序列号的所有日志记录都不可访问。  
  
 如果指定了 <xref:System.IO.Log.ReservationCollection>，写入的重新开始区域将使用集合中包含的预留来占用先前已预留的空间。 如果该方法成功，它将占用能容纳数据的最小预留，而该预留将从集合中移除。  
  
 如果记录序列已经释放，或者如果传递了无效自变量，此操作内将立即引发异常。 异步追加请求过程中发生的错误（例如，I/O 请求过程中的磁盘故障）将导致在调用 <xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A> 方法时引发异常。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">一个或多个自变量无效。</exception>
        <exception cref="T:System.IO.IOException">写入重新开始区域时，发生了 I/O 错误。</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">记录序列无法获得足够的可用空间来容纳新记录。</exception>
        <exception cref="T:System.ObjectDisposedException">该方法是在序列已释放之后调用的。</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateReservationCollection">
      <MemberSignature Language="C#" Value="public System.IO.Log.ReservationCollection CreateReservationCollection ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IO.Log.ReservationCollection CreateReservationCollection() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.CreateReservationCollection" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateReservationCollection () As ReservationCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::ReservationCollection ^ CreateReservationCollection();" />
      <MemberSignature Language="F#" Value="abstract member CreateReservationCollection : unit -&gt; System.IO.Log.ReservationCollection" Usage="iRecordSequence.CreateReservationCollection " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.ReservationCollection</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>在派生的类中重写时，创建一个新的 <see cref="T:System.IO.Log.ReservationCollection" />。</summary>
        <returns>新创建的 <see cref="T:System.IO.Log.ReservationCollection" />。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">该方法是在序列已释放之后调用的。</exception>
      </Docs>
    </Member>
    <Member MemberName="EndAppend">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber EndAppend (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber EndAppend(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.EndAppend(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndAppend (result As IAsyncResult) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::SequenceNumber EndAppend(IAsyncResult ^ result);" />
      <MemberSignature Language="F#" Value="abstract member EndAppend : IAsyncResult -&gt; System.IO.Log.SequenceNumber" Usage="iRecordSequence.EndAppend result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">对未完成的异步 I/O 请求的引用。</param>
        <summary>在派生类中重写时，结束异步追加操作。</summary>
        <returns>追加的日志记录的序列号。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法将一直阻塞，直到 I/O 操作已完成。 调用 <xref:System.IO.Log.IRecordSequence.EndAppend%2A> 时，异步写入请求过程中发生的错误（例如，I/O 请求过程中的磁盘故障）将变得可见。  
  
 必须对 <xref:System.IAsyncResult> 方法返回的每个 <xref:System.IO.Log.IRecordSequence.BeginAppend%2A> 调用此方法且只能调用一次。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">一个或多个自变量无效。</exception>
        <exception cref="T:System.ObjectDisposedException">该方法是在序列已释放之后调用的。</exception>
      </Docs>
    </Member>
    <Member MemberName="EndFlush">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber EndFlush (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber EndFlush(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.EndFlush(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndFlush (result As IAsyncResult) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::SequenceNumber EndFlush(IAsyncResult ^ result);" />
      <MemberSignature Language="F#" Value="abstract member EndFlush : IAsyncResult -&gt; System.IO.Log.SequenceNumber" Usage="iRecordSequence.EndFlush result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">对未完成的异步 I/O 请求的引用。</param>
        <summary>在派生类中重写时，结束异步刷新操作。</summary>
        <returns>写入的最新记录的序列号。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法将一直阻塞，直到 I/O 操作已完成。 调用 <xref:System.IO.Log.IRecordSequence.EndFlush%2A> 时，异步刷新请求过程中发生的错误（例如，I/O 请求过程中的磁盘故障）将变得可见。  
  
 必须对 <xref:System.IAsyncResult> 方法返回的每个 <xref:System.IO.Log.IRecordSequence.BeginFlush%2A> 调用此方法且只能调用一次。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">一个或多个自变量无效。</exception>
        <exception cref="T:System.ObjectDisposedException">该方法是在序列已释放之后调用的。</exception>
      </Docs>
    </Member>
    <Member MemberName="EndReserveAndAppend">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber EndReserveAndAppend (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber EndReserveAndAppend(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.EndReserveAndAppend(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReserveAndAppend (result As IAsyncResult) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::SequenceNumber EndReserveAndAppend(IAsyncResult ^ result);" />
      <MemberSignature Language="F#" Value="abstract member EndReserveAndAppend : IAsyncResult -&gt; System.IO.Log.SequenceNumber" Usage="iRecordSequence.EndReserveAndAppend result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">对未完成的异步 I/O 请求的引用。</param>
        <summary>在派生类中重写时，结束异步保留和追加操作。</summary>
        <returns>追加的日志记录的序列号。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法将一直阻塞，直到 I/O 操作已完成。 调用 <xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A> 时，异步写入请求过程中发生的错误（例如，I/O 请求过程中的磁盘故障）将变得可见。  
  
 必须对 <xref:System.IAsyncResult> 方法返回的每个 <xref:System.IO.Log.IRecordSequence.BeginReserveAndAppend%2A> 调用此方法且只能调用一次。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">一个或多个自变量无效。</exception>
        <exception cref="T:System.ObjectDisposedException">该方法是在序列已释放之后调用的。</exception>
      </Docs>
    </Member>
    <Member MemberName="EndWriteRestartArea">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber EndWriteRestartArea (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber EndWriteRestartArea(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.EndWriteRestartArea(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndWriteRestartArea (result As IAsyncResult) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::SequenceNumber EndWriteRestartArea(IAsyncResult ^ result);" />
      <MemberSignature Language="F#" Value="abstract member EndWriteRestartArea : IAsyncResult -&gt; System.IO.Log.SequenceNumber" Usage="iRecordSequence.EndWriteRestartArea result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">对未完成的异步 I/O 请求的引用。</param>
        <summary>在派生类中重写时，结束异步重新开始区域写入操作。</summary>
        <returns>写入的日志记录的序列号。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法将一直阻塞，直到 I/O 操作已完成。 调用 <xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A> 时，异步写入请求过程中发生的错误（例如，I/O 请求过程中的磁盘故障）将变得可见。  
  
 必须对 <xref:System.IAsyncResult> 方法返回的每个 <xref:System.IO.Log.IRecordSequence.BeginWriteRestartArea%2A> 调用此方法且只能调用一次。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">一个或多个自变量无效。</exception>
        <exception cref="T:System.ObjectDisposedException">该方法是在序列已释放之后调用的。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Flush">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>在派生类中重写时，导致写入追加的记录。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber Flush ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber Flush() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.Flush" />
      <MemberSignature Language="VB.NET" Value="Public Function Flush () As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::SequenceNumber Flush();" />
      <MemberSignature Language="F#" Value="abstract member Flush : unit -&gt; System.IO.Log.SequenceNumber" Usage="iRecordSequence.Flush " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>在派生类中重写时，确保所有追加的记录都已写入。</summary>
        <returns>写入的最新记录的序列号。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 调用此方法可以确保已追加到 <xref:System.IO.Log.IRecordSequence> 的所有记录都已持久写入。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">刷新数据时，发生了 I/O 错误。</exception>
        <exception cref="T:System.ObjectDisposedException">该方法是在序列已释放之后调用的。</exception>
      </Docs>
    </Member>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber Flush (System.IO.Log.SequenceNumber sequenceNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber Flush(valuetype System.IO.Log.SequenceNumber sequenceNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.Flush(System.IO.Log.SequenceNumber)" />
      <MemberSignature Language="VB.NET" Value="Public Function Flush (sequenceNumber As SequenceNumber) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::SequenceNumber Flush(System::IO::Log::SequenceNumber sequenceNumber);" />
      <MemberSignature Language="F#" Value="abstract member Flush : System.IO.Log.SequenceNumber -&gt; System.IO.Log.SequenceNumber" Usage="iRecordSequence.Flush sequenceNumber" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sequenceNumber" Type="System.IO.Log.SequenceNumber" />
      </Parameters>
      <Docs>
        <param name="sequenceNumber">必须写入的最新记录的序列号。 如果此 <see cref="T:System.IO.Log.SequenceNumber" /> 无效，则必须写入所有记录。</param>
        <summary>在派生类中重写时，确保其序列号不高于指定序列号的所有记录都已持久写入。</summary>
        <returns>写入的最新记录的序列号。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 调用此方法可以确保序列号不高于指定序列号的所有记录都已持久写入。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">一个或多个自变量无效。</exception>
        <exception cref="T:System.IO.IOException">刷新数据时，发生了 I/O 错误。</exception>
        <exception cref="T:System.ObjectDisposedException">该方法是在序列已释放之后调用的。</exception>
      </Docs>
    </Member>
    <Member MemberName="LastSequenceNumber">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber LastSequenceNumber { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.IO.Log.SequenceNumber LastSequenceNumber" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.IRecordSequence.LastSequenceNumber" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LastSequenceNumber As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Log::SequenceNumber LastSequenceNumber { System::IO::Log::SequenceNumber get(); };" />
      <MemberSignature Language="F#" Value="member this.LastSequenceNumber : System.IO.Log.SequenceNumber" Usage="System.IO.Log.IRecordSequence.LastSequenceNumber" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在派生类中重写时，获取比追加的最新记录大的序列号。</summary>
        <value>比追加的最新记录大的序列号。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此属性包含一个序列号，并且保证它大于最后追加的记录的序列号。 有效序列号大于或等于 <xref:System.IO.Log.IRecordSequence.BaseSequenceNumber%2A> 且小于 <xref:System.IO.Log.IRecordSequence.LastSequenceNumber%2A>。  
  
> [!NOTE]
>  使用 <xref:System.IO.Log.LogRecordSequence> 实例时，在将记录刷新到日志之前，<xref:System.IO.Log.LogRecordSequence.LastSequenceNumber%2A> 值可能会过期。 <xref:System.IO.Log.IRecordSequence.Flush%2A> <xref:System.IO.Log.RecordAppendOptions> 有关刷新记录的详细信息，请参阅和。 
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">该属性是在序列已释放之后访问的。</exception>
      </Docs>
    </Member>
    <Member MemberName="MaximumRecordLength">
      <MemberSignature Language="C#" Value="public long MaximumRecordLength { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 MaximumRecordLength" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.IRecordSequence.MaximumRecordLength" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MaximumRecordLength As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long MaximumRecordLength { long get(); };" />
      <MemberSignature Language="F#" Value="member this.MaximumRecordLength : int64" Usage="System.IO.Log.IRecordSequence.MaximumRecordLength" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在派生类中重写时，获取可以追加到此序列或者从此序列中读取的最大记录的大小（以字节为单位）。</summary>
        <value>可以追加到此序列或者从此序列中读取的最大记录的大小（以字节为单位）。</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">该属性是在序列已释放之后访问的。</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadLogRecords">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.IO.Log.LogRecord&gt; ReadLogRecords (System.IO.Log.SequenceNumber start, System.IO.Log.LogRecordEnumeratorType logRecordEnum);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class System.IO.Log.LogRecord&gt; ReadLogRecords(valuetype System.IO.Log.SequenceNumber start, valuetype System.IO.Log.LogRecordEnumeratorType logRecordEnum) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.ReadLogRecords(System.IO.Log.SequenceNumber,System.IO.Log.LogRecordEnumeratorType)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadLogRecords (start As SequenceNumber, logRecordEnum As LogRecordEnumeratorType) As IEnumerable(Of LogRecord)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IEnumerable&lt;System::IO::Log::LogRecord ^&gt; ^ ReadLogRecords(System::IO::Log::SequenceNumber start, System::IO::Log::LogRecordEnumeratorType logRecordEnum);" />
      <MemberSignature Language="F#" Value="abstract member ReadLogRecords : System.IO.Log.SequenceNumber * System.IO.Log.LogRecordEnumeratorType -&gt; seq&lt;System.IO.Log.LogRecord&gt;" Usage="iRecordSequence.ReadLogRecords (start, logRecordEnum)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.IO.Log.LogRecord&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="start" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="logRecordEnum" Type="System.IO.Log.LogRecordEnumeratorType" />
      </Parameters>
      <Docs>
        <param name="start">读取操作开始处的第一条记录的序列号。</param>
        <param name="logRecordEnum">一个有效的 <see cref="T:System.IO.Log.LogRecordEnumeratorType" /> 值，该值指定从 <see cref="T:System.IO.Log.LogRecordSequence" /> 中读取记录的方式（即，向前或向后）。</param>
        <summary>在派生类中重写时，返回序列中记录的可枚举集合。</summary>
        <returns>序列中记录的可枚举集合。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在派生类中重写时，返回序列中记录的可枚举集合。 所枚举记录的顺序取决于 `logRecordEnum` 参数的值。  
  
   
  
## Examples  
 以下示例演示了 <xref:System.IO.Log.IRecordSequence.ReadLogRecords%2A> 方法的用法。  
  
```csharp  
using System;  
 using System.IO;  
 using System.IO.Log;  
  
 class ReadRecordsSample  
 {  
     static SequenceNumber AppendRecord(IRecordSequence sequence,  
                                        string message,  
                                        SequenceNumber user,  
                                        SequenceNumber previous)  
     {  
         MemoryStream data = new MemoryStream();  
         BinaryWriter writer = new BinaryWriter(data);  
         writer.Write(message);  
  
         ArraySegment<byte>[] segments;  
         segments = new ArraySegment<byte>[1];  
         segments[0] = new ArraySegment(data.GetBuffer(),  
                                        0,  
                                        Data.Length);  
  
         return sequence.Append(segments,  
                                user,  
                                previous,  
                                WriteFlags.None);  
     }  
  
     public static void Main(string[] args)  
     {  
         IRecordSequence sequence;  
         sequence = new FileIRecordSequence(args[0]);  
  
         SequenceNumber a, b, c, d;  
  
         a = AppendRecord(sequence,  
                          "This is record A",  
                          SequenceNumber.Invalid,  
                          SequenceNumber.Invalid);  
         Console.WriteLine($"Record A has sequence number {a}");  
  
         b = AppendRecord(sequence,  
                          "This is record B",  
                          a,  
                          a);  
         Console.WriteLine($"Record B has sequence number {b}");  
  
         c = AppendRecord(sequence,  
                          "This is record C",  
                          a,  
                          a);  
         Console.WriteLine($"Record C has sequence number {c}");  
  
         d = AppendRecord(sequence,  
                          "This is record D",  
                          b,  
                          c);  
         Console.WriteLine($"Record D has sequence number {d}");  
  
         foreach(LogRecord record in  
                 sequence.ReadLogRecords(a, ReadDirection.Forward))  
         {  
             BinaryReader reader = new BinaryReader(record.Data);  
             Console.WriteLine($"{record.SequenceNumber}: {reader.ReadString()}");  
         }  
  
         foreach(LogRecord record in  
                 sequence.ReadLogRecords(d, ReadDirection.User))  
         {  
             BinaryReader reader = new BinaryReader(record.Data);  
             Console.WriteLine($"{record.SequenceNumber}: {reader.ReadString()}");  
         }  
  
         foreach(LogRecord record in  
                 sequence.ReadLogRecords(d, ReadDirection.Previous))  
         {  
             BinaryReader reader = new BinaryReader(record.Data);  
             Console.WriteLine($"{record.SequenceNumber}: {reader.ReadString()}");  
         }  
     }  
       }  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">一个或多个自变量无效。</exception>
        <exception cref="T:System.IO.IOException">读取记录时，发生了 I/O 错误。</exception>
        <exception cref="T:System.ObjectDisposedException">该方法是在序列已释放之后调用的。</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadRestartAreas">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.IO.Log.LogRecord&gt; ReadRestartAreas ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class System.IO.Log.LogRecord&gt; ReadRestartAreas() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.ReadRestartAreas" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadRestartAreas () As IEnumerable(Of LogRecord)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IEnumerable&lt;System::IO::Log::LogRecord ^&gt; ^ ReadRestartAreas();" />
      <MemberSignature Language="F#" Value="abstract member ReadRestartAreas : unit -&gt; seq&lt;System.IO.Log.LogRecord&gt;" Usage="iRecordSequence.ReadRestartAreas " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.IO.Log.LogRecord&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>在派生类中重写时，返回序列中重新开始区域的可枚举集合。</summary>
        <returns>序列中重新开始区域的可枚举集合。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 重新开始区域按序列号的倒序枚举，即从最高序列号到最低序列号枚举。 仅枚举序列号介于最后一个序列号和基序列号之间的重新开始区域。  
  
> [!NOTE]
>  如果包含 <xref:System.IO.Log.IRecordSequence.BaseSequenceNumber%2A> 的日志范围损坏，此方法会引发 <xref:System.IO.IOException>，且显示错误消息“由于意外的 I/O 异常，无法执行请求。 返回以下错误代码:‘80070026’”。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">一个或多个自变量无效。</exception>
        <exception cref="T:System.IO.IOException">读取记录时，发生了 I/O 错误。</exception>
        <exception cref="T:System.ObjectDisposedException">该方法是在序列已释放之后调用的。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReserveAndAppend">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>在派生类中重写时，自动生成一个预留，并向序列中追加一条记录。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReserveAndAppend">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber ReserveAndAppend (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservationCollection, params long[] reservations);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber ReserveAndAppend(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.IO.Log.ReservationCollection reservationCollection, int64[] reservations) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])" />
      <MemberSignature Language="VB.NET" Value="Public Function ReserveAndAppend (data As ArraySegment(Of Byte), nextUndoRecord As SequenceNumber, previousRecord As SequenceNumber, recordAppendOptions As RecordAppendOptions, reservationCollection As ReservationCollection, ParamArray reservations As Long()) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::SequenceNumber ReserveAndAppend(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, System::IO::Log::ReservationCollection ^ reservationCollection, ... cli::array &lt;long&gt; ^ reservations);" />
      <MemberSignature Language="F#" Value="abstract member ReserveAndAppend : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection * int64[] -&gt; System.IO.Log.SequenceNumber" Usage="iRecordSequence.ReserveAndAppend (data, nextUndoRecord, previousRecord, recordAppendOptions, reservationCollection, reservations)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="reservationCollection" Type="System.IO.Log.ReservationCollection" />
        <Parameter Name="reservations" Type="System.Int64[]">
          <Attributes>
            <Attribute FrameworkAlternate="netframework-3.0">
              <AttributeName Language="C#">[System.ParamArray]</AttributeName>
              <AttributeName Language="F#">[&lt;System.ParamArray&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="data">将连接在一起并以记录形式追加的字节数组段的列表。</param>
        <param name="nextUndoRecord">用户指定顺序中下一条记录的序列号。</param>
        <param name="previousRecord">“上一个”顺序中下一条记录的序列号。</param>
        <param name="recordAppendOptions"><see cref="T:System.IO.Log.RecordAppendOptions" /> 的一个有效值，用于指定应如何写入数据。</param>
        <param name="reservationCollection">一个 <see cref="T:System.IO.Log.ReservationCollection" />，它包含要在其中生成预留的集合。</param>
        <param name="reservations">要生成的预留（以字节为单位）。</param>
        <summary>在派生类中重写时，自动生成一个预留，并向序列中追加一条记录。</summary>
        <returns>追加的日志记录的序列号。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 包含在 `data` 参数中的数据将连接成单个字节数组，以便以记录形式追加。 但在读取记录时，无法将数据重新拆分为数组段。  
  
 在原子操作中，使用记录追加操作将指定的预留添加到所提供的预留集合。 如果追加失败，将不保留任何空间。  
  
 通常，此方法可以在写入记录之前完成。 若要确保记录已写入，请使用 <xref:System.IO.Log.RecordAppendOptions.ForceFlush> 参数指定 `recordAppendOptions` 标志，或者调用 <xref:System.IO.Log.IRecordSequence.Flush%2A> 方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">一个或多个自变量无效。</exception>
        <exception cref="T:System.IO.IOException">追加记录时，发生了 I/O 错误。</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">记录序列无法获得足够的可用空间来容纳新记录或生成预留。</exception>
        <exception cref="T:System.ObjectDisposedException">该方法是在序列已释放之后调用的。</exception>
      </Docs>
    </Member>
    <Member MemberName="ReserveAndAppend">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber ReserveAndAppend (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservationCollection, params long[] reservations);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber ReserveAndAppend(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.IO.Log.ReservationCollection reservationCollection, int64[] reservations) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.ReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])" />
      <MemberSignature Language="VB.NET" Value="Public Function ReserveAndAppend (data As IList(Of ArraySegment(Of Byte)), nextUndoRecord As SequenceNumber, previousRecord As SequenceNumber, recordAppendOptions As RecordAppendOptions, reservationCollection As ReservationCollection, ParamArray reservations As Long()) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::SequenceNumber ReserveAndAppend(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, System::IO::Log::ReservationCollection ^ reservationCollection, ... cli::array &lt;long&gt; ^ reservations);" />
      <MemberSignature Language="F#" Value="abstract member ReserveAndAppend : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection * int64[] -&gt; System.IO.Log.SequenceNumber" Usage="iRecordSequence.ReserveAndAppend (data, nextUndoRecord, previousRecord, recordAppendOptions, reservationCollection, reservations)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="reservationCollection" Type="System.IO.Log.ReservationCollection" />
        <Parameter Name="reservations" Type="System.Int64[]">
          <Attributes>
            <Attribute FrameworkAlternate="netframework-3.0">
              <AttributeName Language="C#">[System.ParamArray]</AttributeName>
              <AttributeName Language="F#">[&lt;System.ParamArray&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="data">将连接在一起并以记录形式追加的字节数组段的列表。</param>
        <param name="nextUndoRecord">用户指定顺序中下一条记录的序列号。</param>
        <param name="previousRecord">“上一个”顺序中下一条记录的序列号。</param>
        <param name="recordAppendOptions"><see cref="T:System.IO.Log.RecordAppendOptions" /> 的一个有效值，用于指定应如何写入数据。</param>
        <param name="reservationCollection">要在其中生成预留的预留集合。</param>
        <param name="reservations">要生成的预留（以字节为单位）。</param>
        <summary>在派生类中重写时，自动生成一个预留，并向序列中追加一条记录。</summary>
        <returns>追加的日志记录的序列号。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 包含在 `data` 参数中的数据将连接成单个字节数组，以便以记录形式追加。 但在读取记录时，无法将数据重新拆分为数组段。  
  
 在原子操作中，使用记录追加操作将指定的预留添加到所提供的预留集合。 如果追加失败，将不保留任何空间。  
  
 通常，此方法可以在写入记录之前完成。 若要确保记录已写入，请使用 <xref:System.IO.Log.RecordAppendOptions.ForceFlush> 参数指定 `recordAppendOptions` 标志，或者调用 <xref:System.IO.Log.IRecordSequence.Flush%2A> 方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">一个或多个自变量无效。</exception>
        <exception cref="T:System.IO.IOException">追加记录时，发生了 I/O 错误。</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">记录序列无法获得足够的可用空间来容纳新记录或生成预留。</exception>
        <exception cref="T:System.ObjectDisposedException">该方法是在序列已释放之后调用的。</exception>
      </Docs>
    </Member>
    <Member MemberName="ReservedBytes">
      <MemberSignature Language="C#" Value="public long ReservedBytes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 ReservedBytes" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.IRecordSequence.ReservedBytes" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ReservedBytes As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long ReservedBytes { long get(); };" />
      <MemberSignature Language="F#" Value="member this.ReservedBytes : int64" Usage="System.IO.Log.IRecordSequence.ReservedBytes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在派生类中重写时，获取已保留的总字节数。</summary>
        <value>此记录序列中做出的所有预留的总大小。</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">该属性是在序列已释放之后访问的。</exception>
      </Docs>
    </Member>
    <Member MemberName="RestartSequenceNumber">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber RestartSequenceNumber { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.IO.Log.SequenceNumber RestartSequenceNumber" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.IRecordSequence.RestartSequenceNumber" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RestartSequenceNumber As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Log::SequenceNumber RestartSequenceNumber { System::IO::Log::SequenceNumber get(); };" />
      <MemberSignature Language="F#" Value="member this.RestartSequenceNumber : System.IO.Log.SequenceNumber" Usage="System.IO.Log.IRecordSequence.RestartSequenceNumber" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在派生类中重写时，获取最近写入的重新开始区域的序列号。</summary>
        <value>最近写入的重新开始区域的序列号。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 重新开始区域用于临时存储包含客户端最后一次检查点操作的信息。 需要恢复时，可以分析重新开始区域，以检索最后一次检查点操作中的所有数据。 这些数据将初始化事务表、脏页表和打开文件表，以便它们能够用于恢复过程。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">该属性是在序列已释放之后访问的。</exception>
      </Docs>
    </Member>
    <Member MemberName="RetryAppend">
      <MemberSignature Language="C#" Value="public bool RetryAppend { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool RetryAppend" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.IRecordSequence.RetryAppend" />
      <MemberSignature Language="VB.NET" Value="Public Property RetryAppend As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool RetryAppend { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.RetryAppend : bool with get, set" Usage="System.IO.Log.IRecordSequence.RetryAppend" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指示如果日志已满，是否自动重试追加操作。</summary>
        <value>如果在日志已满时自动重试追加操作，则为 <see langword="true" />；否则为 <see langword="false" />。 默认值为 <see langword="true" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果此属性的值为 `true`，且 <xref:System.IO.Log.IRecordSequence.Append%2A> 调用因为序列中没有足够的空间而失败，则记录序列将尝试释放空间，然后重试追加操作。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">该属性是在序列已释放之后访问的。</exception>
      </Docs>
    </Member>
    <Member MemberName="TailPinned">
      <MemberSignature Language="C#" Value="event EventHandler&lt;System.IO.Log.TailPinnedEventArgs&gt; TailPinned;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.IO.Log.TailPinnedEventArgs&gt; TailPinned" />
      <MemberSignature Language="DocId" Value="E:System.IO.Log.IRecordSequence.TailPinned" />
      <MemberSignature Language="VB.NET" Value="Event TailPinned As EventHandler(Of TailPinnedEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::IO::Log::TailPinnedEventArgs ^&gt; ^ TailPinned;" />
      <MemberSignature Language="F#" Value="member this.TailPinned : EventHandler&lt;System.IO.Log.TailPinnedEventArgs&gt; " Usage="member this.TailPinned : System.EventHandler&lt;System.IO.Log.TailPinnedEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.IO.Log.TailPinnedEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当记录序列确定必须前移尾数据时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 可以在记录序列空间不足时激发此事件。 此事件激发时，序列的尾数据（即基序列号）将前移以释放空间。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteRestartArea">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>在派生类中重写时，向 <see cref="T:System.IO.Log.IRecordSequence" /> 中写入一个重新开始区域。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 重新开始区域用于临时存储包含客户端最后一次检查点操作的信息。 需要恢复时，可以分析重新开始区域，以检索最后一次检查点操作中的所有数据。 这些数据将初始化事务表、脏页表和打开文件表，以便它们能够用于恢复过程。 可以使用 <xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A> 方法来读取重新开始区域。  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteRestartArea">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber WriteRestartArea (ArraySegment&lt;byte&gt; data);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber WriteRestartArea(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Function WriteRestartArea (data As ArraySegment(Of Byte)) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::SequenceNumber WriteRestartArea(ArraySegment&lt;System::Byte&gt; data);" />
      <MemberSignature Language="F#" Value="abstract member WriteRestartArea : ArraySegment&lt;byte&gt; -&gt; System.IO.Log.SequenceNumber" Usage="iRecordSequence.WriteRestartArea data" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
      </Parameters>
      <Docs>
        <param name="data">将连接在一起并以记录形式追加的字节数组段的列表。</param>
        <summary>在派生类中重写时，向 <see cref="T:System.IO.Log.IRecordSequence" /> 中写入一个重新开始区域。</summary>
        <returns>写入的重新开始区域的序列号。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 重新开始区域用于临时存储包含客户端最后一次检查点操作的信息。 公用日志文件系统 (CLFS) 维护两个重新开始区域，以确保至少有一个有效区域总是可用。 需要恢复时，CLFS 读取自己的重新开始区域和最后一个检查点操作中的所有数据。 这些数据将初始化事务表、脏页表和打开文件表，以便它们能够用于恢复过程。  
  
 可以使用 <xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A> 方法来读取重新开始区域。  
  
 字节数组段中的数据将连接成单个字节数组，以便以记录形式追加。 在读取重新开始区域时，无法将数据重新拆分为数组段。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">一个或多个自变量无效。</exception>
        <exception cref="T:System.IO.IOException">写入重新开始区域时，发生了 I/O 错误。</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">记录序列无法获得足够的可用空间来容纳新的重新开始区域。</exception>
        <exception cref="T:System.ObjectDisposedException">该方法是在序列已释放之后调用的。</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteRestartArea">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber WriteRestartArea (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber WriteRestartArea(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})" />
      <MemberSignature Language="VB.NET" Value="Public Function WriteRestartArea (data As IList(Of ArraySegment(Of Byte))) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::SequenceNumber WriteRestartArea(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data);" />
      <MemberSignature Language="F#" Value="abstract member WriteRestartArea : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; -&gt; System.IO.Log.SequenceNumber" Usage="iRecordSequence.WriteRestartArea data" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
      </Parameters>
      <Docs>
        <param name="data">将连接在一起并以记录形式追加的字节数组段的列表。</param>
        <summary>在派生类中重写时，向 <see cref="T:System.IO.Log.IRecordSequence" /> 中写入一个重新开始区域。</summary>
        <returns>写入的重新开始区域的序列号。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 重新开始区域用于临时存储包含客户端最后一次检查点操作的信息。 需要恢复时，可以分析重新开始区域，以检索最后一次检查点操作中的所有数据。 这些数据将初始化事务表、脏页表和打开文件表，以便它们能够用于恢复过程。 可以使用 <xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A> 方法来读取重新开始区域。  
  
 字节数组段中的数据将连接成单个字节数组，以便以记录形式追加。 在读取重新开始区域时，无法将数据重新拆分为数组段。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">一个或多个自变量无效。</exception>
        <exception cref="T:System.IO.IOException">写入重新开始区域时，发生了 I/O 错误。</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">记录序列无法获得足够的可用空间来容纳新的重新开始区域。</exception>
        <exception cref="T:System.ObjectDisposedException">该方法是在序列已释放之后调用的。</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteRestartArea">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber WriteRestartArea (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber newBaseSequenceNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber WriteRestartArea(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber newBaseSequenceNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber)" />
      <MemberSignature Language="VB.NET" Value="Public Function WriteRestartArea (data As ArraySegment(Of Byte), newBaseSequenceNumber As SequenceNumber) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::SequenceNumber WriteRestartArea(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber newBaseSequenceNumber);" />
      <MemberSignature Language="F#" Value="abstract member WriteRestartArea : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber -&gt; System.IO.Log.SequenceNumber" Usage="iRecordSequence.WriteRestartArea (data, newBaseSequenceNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="newBaseSequenceNumber" Type="System.IO.Log.SequenceNumber" />
      </Parameters>
      <Docs>
        <param name="data">将连接在一起并以记录形式追加的字节数组段的列表。</param>
        <param name="newBaseSequenceNumber">新的基序列号。 指定的序列号必须大于或等于当前基序列号。</param>
        <summary>在派生类中重写时，向 <see cref="T:System.IO.Log.IRecordSequence" /> 中写入一个重新开始区域，并更新基序列号。</summary>
        <returns>写入的重新开始区域的序列号。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 重新开始区域用于临时存储包含客户端最后一次检查点操作的信息。 需要恢复时，可以分析重新开始区域，以检索最后一次检查点操作中的所有数据。 这些数据将初始化事务表、脏页表和打开文件表，以便它们能够用于恢复过程。 可以使用 <xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A> 方法来读取重新开始区域。  
  
 写入重新开始区域时，字节数组段中的数据将连接成单个字节数组，以便以记录形式追加。 在读取重新开始区域时，无法将数据重新拆分为数组段。  
  
 此方法成功完成时，基序列号已更新。 其序列号小于新的基序列号的所有日志记录都不可访问。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">一个或多个自变量无效。</exception>
        <exception cref="T:System.IO.IOException">写入重新开始区域时，发生了 I/O 错误。</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">记录序列无法获得足够的可用空间来容纳新的重新开始区域。</exception>
        <exception cref="T:System.ObjectDisposedException">该方法是在序列已释放之后调用的。</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteRestartArea">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber WriteRestartArea (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber newBaseSequenceNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber WriteRestartArea(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber newBaseSequenceNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber)" />
      <MemberSignature Language="VB.NET" Value="Public Function WriteRestartArea (data As IList(Of ArraySegment(Of Byte)), newBaseSequenceNumber As SequenceNumber) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::SequenceNumber WriteRestartArea(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber newBaseSequenceNumber);" />
      <MemberSignature Language="F#" Value="abstract member WriteRestartArea : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber -&gt; System.IO.Log.SequenceNumber" Usage="iRecordSequence.WriteRestartArea (data, newBaseSequenceNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="newBaseSequenceNumber" Type="System.IO.Log.SequenceNumber" />
      </Parameters>
      <Docs>
        <param name="data">将连接在一起并以记录形式追加的字节数组段的列表。</param>
        <param name="newBaseSequenceNumber">新的基序列号。 指定的序列号必须大于或等于当前基序列号。</param>
        <summary>在派生类中重写时，向 <see cref="T:System.IO.Log.IRecordSequence" /> 中写入一个重新开始区域，并更新基序列号。</summary>
        <returns>写入的重新开始区域的序列号。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 重新开始区域用于临时存储包含客户端最后一次检查点操作的信息。 需要恢复时，可以分析重新开始区域，以检索最后一次检查点操作中的所有数据。 这些数据将初始化事务表、脏页表和打开文件表，以便它们能够用于恢复过程。 可以使用 <xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A> 方法来读取重新开始区域。  
  
 写入重新开始区域时，字节数组段中的数据将连接成单个字节数组，以便以记录形式追加。 在读取重新开始区域时，无法将数据重新拆分为数组段。  
  
 此方法成功完成时，基序列号已更新。 其序列号小于新的基序列号的所有日志记录都不可访问。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">一个或多个自变量无效。</exception>
        <exception cref="T:System.IO.IOException">写入重新开始区域时，发生了 I/O 错误。</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">记录序列无法获得足够的可用空间来容纳新的重新开始区域。</exception>
        <exception cref="T:System.ObjectDisposedException">该方法是在序列已释放之后调用的。</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteRestartArea">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber WriteRestartArea (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber newBaseSequenceNumber, System.IO.Log.ReservationCollection reservation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber WriteRestartArea(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber newBaseSequenceNumber, class System.IO.Log.ReservationCollection reservation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)" />
      <MemberSignature Language="VB.NET" Value="Public Function WriteRestartArea (data As ArraySegment(Of Byte), newBaseSequenceNumber As SequenceNumber, reservation As ReservationCollection) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::SequenceNumber WriteRestartArea(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber newBaseSequenceNumber, System::IO::Log::ReservationCollection ^ reservation);" />
      <MemberSignature Language="F#" Value="abstract member WriteRestartArea : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.ReservationCollection -&gt; System.IO.Log.SequenceNumber" Usage="iRecordSequence.WriteRestartArea (data, newBaseSequenceNumber, reservation)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="newBaseSequenceNumber" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="reservation" Type="System.IO.Log.ReservationCollection" />
      </Parameters>
      <Docs>
        <param name="data">将连接在一起并以记录形式追加的字节数组段的列表。</param>
        <param name="newBaseSequenceNumber">新的基序列号。 指定的序列号必须大于或等于当前基序列号。</param>
        <param name="reservation">一个 <see cref="T:System.IO.Log.ReservationCollection" />，它包含应当用于此重新开始区域的预留。</param>
        <summary>在派生类中重写时，利用预留向 <see cref="T:System.IO.Log.IRecordSequence" /> 中写入一个重新开始区域，并更新基序列号。</summary>
        <returns>写入的重新开始区域的序列号。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 重新开始区域用于临时存储包含客户端最后一次检查点操作的信息。 需要恢复时，可以分析重新开始区域，以检索最后一次检查点操作中的所有数据。 这些数据将初始化事务表、脏页表和打开文件表，以便它们能够用于恢复过程。 可以使用 <xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A> 方法来读取重新开始区域。  
  
 写入重新开始区域时，字节数组段中的数据将连接成单个字节数组，以便以记录形式追加。 在读取重新开始区域时，无法将数据重新拆分为数组段。  
  
 如果指定了预留，写入的重新开始区域将使用集合中包含的预留来占用先前已预留的空间。 如果该方法成功，它将占用能容纳数据的最小预留，而该预留将从集合中移除。  
  
 此方法成功完成时，基序列号已更新。 其序列号小于新的基序列号的所有日志记录都不可访问。  
  
 如果记录序列已经释放，或者如果传递了无效自变量，此操作内将立即引发异常。 异步追加请求过程中发生的错误（例如，I/O 请求过程中的磁盘故障）将导致在调用 <xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A> 方法时引发异常。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">一个或多个自变量无效。</exception>
        <exception cref="T:System.IO.IOException">写入重新开始区域时，发生了 I/O 错误。</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">记录序列无法获得足够的可用空间来容纳新的重新开始区域。</exception>
        <exception cref="T:System.ObjectDisposedException">该方法是在序列已释放之后调用的。</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteRestartArea">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber WriteRestartArea (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber newBaseSequenceNumber, System.IO.Log.ReservationCollection reservation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber WriteRestartArea(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber newBaseSequenceNumber, class System.IO.Log.ReservationCollection reservation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)" />
      <MemberSignature Language="VB.NET" Value="Public Function WriteRestartArea (data As IList(Of ArraySegment(Of Byte)), newBaseSequenceNumber As SequenceNumber, reservation As ReservationCollection) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::SequenceNumber WriteRestartArea(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber newBaseSequenceNumber, System::IO::Log::ReservationCollection ^ reservation);" />
      <MemberSignature Language="F#" Value="abstract member WriteRestartArea : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.ReservationCollection -&gt; System.IO.Log.SequenceNumber" Usage="iRecordSequence.WriteRestartArea (data, newBaseSequenceNumber, reservation)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="newBaseSequenceNumber" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="reservation" Type="System.IO.Log.ReservationCollection" />
      </Parameters>
      <Docs>
        <param name="data">将连接在一起并以记录形式追加的字节数组段的列表。</param>
        <param name="newBaseSequenceNumber">新的基序列号。 指定的序列号必须大于或等于当前基序列号。</param>
        <param name="reservation">一个 <see cref="T:System.IO.Log.ReservationCollection" />，它包含应当用于此重新开始区域的预留。</param>
        <summary>在派生类中重写时，利用预留向 <see cref="T:System.IO.Log.IRecordSequence" /> 中写入一个重新开始区域，并更新基序列号。</summary>
        <returns>写入的重新开始区域的序列号。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 重新开始区域用于临时存储包含客户端最后一次检查点操作的信息。 需要恢复时，可以分析重新开始区域，以检索最后一次检查点操作中的所有数据。 这些数据将初始化事务表、脏页表和打开文件表，以便它们能够用于恢复过程。 可以使用 <xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A> 方法来读取重新开始区域。  
  
 写入重新开始区域时，字节数组段中的数据将连接成单个字节数组，以便以记录形式追加。 在读取重新开始区域时，无法将数据重新拆分为数组段。  
  
 如果指定了预留，写入的重新开始区域将使用集合中包含的预留来占用先前已预留的空间。 如果该方法成功，它将占用能容纳数据的最小预留，而该预留将从集合中移除。  
  
 此方法成功完成时，基序列号已更新。 其序列号小于新的基序列号的所有日志记录都不可访问。  
  
 如果记录序列已经释放，或者如果传递了无效自变量，此操作内将立即引发异常。 异步追加请求过程中发生的错误（例如，I/O 请求过程中的磁盘故障）将导致在调用 <xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A> 方法时引发异常。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">一个或多个自变量无效。</exception>
        <exception cref="T:System.IO.IOException">写入重新开始区域时，发生了 I/O 错误。</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">记录序列无法获得足够的可用空间来容纳新的重新开始区域。</exception>
        <exception cref="T:System.ObjectDisposedException">该方法是在序列已释放之后调用的。</exception>
      </Docs>
    </Member>
  </Members>
</Type>
