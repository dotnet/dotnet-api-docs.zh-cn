<Type Name="ImmutableInterlocked" FullName="System.Collections.Immutable.ImmutableInterlocked">
  <Metadata><Meta Name="ms.openlocfilehash" Value="5d2d0a43af328ebd31127df9750dc91548435531" /><Meta Name="ms.sourcegitcommit" Value="b53d35b4a410c949742abd4c6a989d1af5357bca" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-CN" /><Meta Name="ms.lasthandoff" Value="07/21/2020" /><Meta Name="ms.locfileid" Value="86737825" /></Metadata><TypeSignature Language="C#" Value="public static class ImmutableInterlocked" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit ImmutableInterlocked extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Collections.Immutable.ImmutableInterlocked" />
  <TypeSignature Language="VB.NET" Value="Public Class ImmutableInterlocked" />
  <TypeSignature Language="C++ CLI" Value="public ref class ImmutableInterlocked abstract sealed" />
  <TypeSignature Language="F#" Value="type ImmutableInterlocked = class" />
  <AssemblyInfo>
    <AssemblyName>System.Collections.Immutable</AssemblyName>
    <AssemblyVersion>1.1.37.0</AssemblyVersion>
    <AssemblyVersion>1.2.0.0</AssemblyVersion>
    <AssemblyVersion>1.2.1.0</AssemblyVersion>
    <AssemblyVersion>1.2.2.0</AssemblyVersion>
    <AssemblyVersion>1.2.3.0</AssemblyVersion>
    <AssemblyVersion>1.2.4.0</AssemblyVersion>
    <AssemblyVersion>1.2.5.0</AssemblyVersion>
    <AssemblyVersion>5.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary><span data-ttu-id="80baa-101">包含不可变集合的联锁交换机制。</span><span class="sxs-lookup"><span data-stu-id="80baa-101">Contains interlocked exchange mechanisms for immutable collections.</span></span>  
  
 <span data-ttu-id="80baa-102">**NuGet package**: <see href="https://www.nuget.org/packages/System.Collections.Immutable/">System.Collections.Immutable</see>（<see href="https://docs.microsoft.com/dotnet/api/system.collections.immutable?#remarks">关于不可变集合和安装方法</see>）</span><span class="sxs-lookup"><span data-stu-id="80baa-102">**NuGet package**: <see href="https://www.nuget.org/packages/System.Collections.Immutable/">System.Collections.Immutable</see> (<see href="https://docs.microsoft.com/dotnet/api/system.collections.immutable?#remarks">about immutable collections and how to install</see>)</span></span></summary>
    <remarks>To be added.</remarks>
    <threadsafe><span data-ttu-id="80baa-103">此类型是线程安全的。</span><span class="sxs-lookup"><span data-stu-id="80baa-103">This type is thread safe.</span></span></threadsafe>
  </Docs>
  <Members>
    <Member MemberName="AddOrUpdate&lt;TKey,TValue&gt;">
      <MemberSignature Language="C#" Value="public static TValue AddOrUpdate&lt;TKey,TValue&gt; (ref System.Collections.Immutable.ImmutableDictionary&lt;TKey,TValue&gt; location, TKey key, Func&lt;TKey,TValue&gt; addValueFactory, Func&lt;TKey,TValue,TValue&gt; updateValueFactory);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TValue AddOrUpdate&lt;TKey, TValue&gt;(class System.Collections.Immutable.ImmutableDictionary`2&lt;!!TKey, !!TValue&gt;&amp; location, !!TKey key, class System.Func`2&lt;!!TKey, !!TValue&gt; addValueFactory, class System.Func`3&lt;!!TKey, !!TValue, !!TValue&gt; updateValueFactory) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Immutable.ImmutableInterlocked.AddOrUpdate``2(System.Collections.Immutable.ImmutableDictionary{``0,``1}@,``0,System.Func{``0,``1},System.Func{``0,``1,``1})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AddOrUpdate(Of TKey, TValue) (ByRef location As ImmutableDictionary(Of TKey, TValue), key As TKey, addValueFactory As Func(Of TKey, TValue), updateValueFactory As Func(Of TKey, TValue, TValue)) As TValue" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TKey, typename TValue&gt;&#xA; static TValue AddOrUpdate(System::Collections::Immutable::ImmutableDictionary&lt;TKey, TValue&gt; ^ % location, TKey key, Func&lt;TKey, TValue&gt; ^ addValueFactory, Func&lt;TKey, TValue, TValue&gt; ^ updateValueFactory);" />
      <MemberSignature Language="F#" Value="static member AddOrUpdate : ImmutableDictionary * 'Key * Func&lt;'Key, 'Value&gt; * Func&lt;'Key, 'Value, 'Value&gt; -&gt; 'Value" Usage="System.Collections.Immutable.ImmutableInterlocked.AddOrUpdate (location, key, addValueFactory, updateValueFactory)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Immutable</AssemblyName>
        <AssemblyVersion>1.1.37.0</AssemblyVersion>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
        <AssemblyVersion>1.2.1.0</AssemblyVersion>
        <AssemblyVersion>1.2.2.0</AssemblyVersion>
        <AssemblyVersion>1.2.3.0</AssemblyVersion>
        <AssemblyVersion>1.2.4.0</AssemblyVersion>
        <AssemblyVersion>1.2.5.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TValue</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TValue" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="location" Type="System.Collections.Immutable.ImmutableDictionary&lt;TKey,TValue&gt;" RefType="ref" />
        <Parameter Name="key" Type="TKey" />
        <Parameter Name="addValueFactory" Type="System.Func&lt;TKey,TValue&gt;" />
        <Parameter Name="updateValueFactory" Type="System.Func&lt;TKey,TValue,TValue&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TKey"><span data-ttu-id="80baa-104">字典存储的键的类型。</span><span class="sxs-lookup"><span data-stu-id="80baa-104">The type of key stored by the dictionary.</span></span></typeparam>
        <typeparam name="TValue"><span data-ttu-id="80baa-105">字典存储的值的类型。</span><span class="sxs-lookup"><span data-stu-id="80baa-105">The type of value stored by the dictionary.</span></span></typeparam>
        <param name="location"><span data-ttu-id="80baa-106">当指定的值不在字典中时以原子方式更新的变量或字段。</span><span class="sxs-lookup"><span data-stu-id="80baa-106">The variable or field to atomically update if the specified  is not in the dictionary.</span></span></param>
        <param name="key"><span data-ttu-id="80baa-107">要添加或更新的值的键。</span><span class="sxs-lookup"><span data-stu-id="80baa-107">The key for the value to add or update.</span></span></param>
        <param name="addValueFactory"><span data-ttu-id="80baa-108">用于接收键，并在以前不存在任何值时返回要添加到字典中的新值的函数。</span><span class="sxs-lookup"><span data-stu-id="80baa-108">The function that receives the key and returns a new value to add to the dictionary when no value previously exists.</span></span></param>
        <param name="updateValueFactory"><span data-ttu-id="80baa-109">用于接收键和先前值，并返回用于更新字典的新值的函数。</span><span class="sxs-lookup"><span data-stu-id="80baa-109">The function that receives the key and prior value and returns the new value with which to update the dictionary.</span></span></param>
        <summary><span data-ttu-id="80baa-110">从添加值或更新现有条目后从字典中获取该值。</span><span class="sxs-lookup"><span data-stu-id="80baa-110">Obtains the value from a dictionary after having added it or updated an existing entry.</span></span></summary>
        <returns><span data-ttu-id="80baa-111">添加或更新的值。</span><span class="sxs-lookup"><span data-stu-id="80baa-111">The added or updated value.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddOrUpdate&lt;TKey,TValue&gt;">
      <MemberSignature Language="C#" Value="public static TValue AddOrUpdate&lt;TKey,TValue&gt; (ref System.Collections.Immutable.ImmutableDictionary&lt;TKey,TValue&gt; location, TKey key, TValue addValue, Func&lt;TKey,TValue,TValue&gt; updateValueFactory);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TValue AddOrUpdate&lt;TKey, TValue&gt;(class System.Collections.Immutable.ImmutableDictionary`2&lt;!!TKey, !!TValue&gt;&amp; location, !!TKey key, !!TValue addValue, class System.Func`3&lt;!!TKey, !!TValue, !!TValue&gt; updateValueFactory) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Immutable.ImmutableInterlocked.AddOrUpdate``2(System.Collections.Immutable.ImmutableDictionary{``0,``1}@,``0,``1,System.Func{``0,``1,``1})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AddOrUpdate(Of TKey, TValue) (ByRef location As ImmutableDictionary(Of TKey, TValue), key As TKey, addValue As TValue, updateValueFactory As Func(Of TKey, TValue, TValue)) As TValue" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TKey, typename TValue&gt;&#xA; static TValue AddOrUpdate(System::Collections::Immutable::ImmutableDictionary&lt;TKey, TValue&gt; ^ % location, TKey key, TValue addValue, Func&lt;TKey, TValue, TValue&gt; ^ updateValueFactory);" />
      <MemberSignature Language="F#" Value="static member AddOrUpdate : ImmutableDictionary * 'Key * 'Value * Func&lt;'Key, 'Value, 'Value&gt; -&gt; 'Value" Usage="System.Collections.Immutable.ImmutableInterlocked.AddOrUpdate (location, key, addValue, updateValueFactory)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Immutable</AssemblyName>
        <AssemblyVersion>1.1.37.0</AssemblyVersion>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
        <AssemblyVersion>1.2.1.0</AssemblyVersion>
        <AssemblyVersion>1.2.2.0</AssemblyVersion>
        <AssemblyVersion>1.2.3.0</AssemblyVersion>
        <AssemblyVersion>1.2.4.0</AssemblyVersion>
        <AssemblyVersion>1.2.5.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TValue</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TValue" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="location" Type="System.Collections.Immutable.ImmutableDictionary&lt;TKey,TValue&gt;" RefType="ref" />
        <Parameter Name="key" Type="TKey" />
        <Parameter Name="addValue" Type="TValue" />
        <Parameter Name="updateValueFactory" Type="System.Func&lt;TKey,TValue,TValue&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TKey"><span data-ttu-id="80baa-112">字典存储的键的类型。</span><span class="sxs-lookup"><span data-stu-id="80baa-112">The type of key stored by the dictionary.</span></span></typeparam>
        <typeparam name="TValue"><span data-ttu-id="80baa-113">字典存储的值的类型。</span><span class="sxs-lookup"><span data-stu-id="80baa-113">The type of value stored by the dictionary.</span></span></typeparam>
        <param name="location"><span data-ttu-id="80baa-114">当指定的值不在字典中时以原子方式更新的变量或字段。</span><span class="sxs-lookup"><span data-stu-id="80baa-114">The variable or field to atomically update if the specified  is not in the dictionary.</span></span></param>
        <param name="key"><span data-ttu-id="80baa-115">要添加或更新的值的键。</span><span class="sxs-lookup"><span data-stu-id="80baa-115">The key for the value to add or update.</span></span></param>
        <param name="addValue"><span data-ttu-id="80baa-116">以前的值不存在时要使用的值。</span><span class="sxs-lookup"><span data-stu-id="80baa-116">The value to use if no previous value exists.</span></span></param>
        <param name="updateValueFactory"><span data-ttu-id="80baa-117">用于接收键和先前值，并返回用于更新字典的新值的函数。</span><span class="sxs-lookup"><span data-stu-id="80baa-117">The function that receives the key and prior value and returns the new value with which to update the dictionary.</span></span></param>
        <summary><span data-ttu-id="80baa-118">从添加值或更新现有条目后从字典中获取该值。</span><span class="sxs-lookup"><span data-stu-id="80baa-118">Obtains the value from a dictionary after having added it or updated an existing entry.</span></span></summary>
        <returns><span data-ttu-id="80baa-119">添加或更新的值。</span><span class="sxs-lookup"><span data-stu-id="80baa-119">The added or updated value.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Enqueue&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Enqueue&lt;T&gt; (ref System.Collections.Immutable.ImmutableQueue&lt;T&gt; location, T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Enqueue&lt;T&gt;(class System.Collections.Immutable.ImmutableQueue`1&lt;!!T&gt;&amp; location, !!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Immutable.ImmutableInterlocked.Enqueue``1(System.Collections.Immutable.ImmutableQueue{``0}@,``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Enqueue(Of T) (ByRef location As ImmutableQueue(Of T), value As T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void Enqueue(System::Collections::Immutable::ImmutableQueue&lt;T&gt; ^ % location, T value);" />
      <MemberSignature Language="F#" Value="static member Enqueue : ImmutableQueue * 'T -&gt; unit" Usage="System.Collections.Immutable.ImmutableInterlocked.Enqueue (location, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Immutable</AssemblyName>
        <AssemblyVersion>1.1.37.0</AssemblyVersion>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
        <AssemblyVersion>1.2.1.0</AssemblyVersion>
        <AssemblyVersion>1.2.2.0</AssemblyVersion>
        <AssemblyVersion>1.2.3.0</AssemblyVersion>
        <AssemblyVersion>1.2.4.0</AssemblyVersion>
        <AssemblyVersion>1.2.5.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="location" Type="System.Collections.Immutable.ImmutableQueue&lt;T&gt;" RefType="ref" />
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="80baa-120">集合中包含的项的类型</span><span class="sxs-lookup"><span data-stu-id="80baa-120">The type of items contained in the collection</span></span></typeparam>
        <param name="location"><span data-ttu-id="80baa-121">以原子方式更新的变量或字段。</span><span class="sxs-lookup"><span data-stu-id="80baa-121">The variable or field to atomically update.</span></span></param>
        <param name="value"><span data-ttu-id="80baa-122">要排队的值。</span><span class="sxs-lookup"><span data-stu-id="80baa-122">The value to enqueue.</span></span></param>
        <summary><span data-ttu-id="80baa-123">以原子方式将某个元素排到队列的末尾。</span><span class="sxs-lookup"><span data-stu-id="80baa-123">Atomically enqueues an element to the end of a queue.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetOrAdd&lt;TKey,TValue&gt;">
      <MemberSignature Language="C#" Value="public static TValue GetOrAdd&lt;TKey,TValue&gt; (ref System.Collections.Immutable.ImmutableDictionary&lt;TKey,TValue&gt; location, TKey key, Func&lt;TKey,TValue&gt; valueFactory);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TValue GetOrAdd&lt;TKey, TValue&gt;(class System.Collections.Immutable.ImmutableDictionary`2&lt;!!TKey, !!TValue&gt;&amp; location, !!TKey key, class System.Func`2&lt;!!TKey, !!TValue&gt; valueFactory) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Immutable.ImmutableInterlocked.GetOrAdd``2(System.Collections.Immutable.ImmutableDictionary{``0,``1}@,``0,System.Func{``0,``1})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetOrAdd(Of TKey, TValue) (ByRef location As ImmutableDictionary(Of TKey, TValue), key As TKey, valueFactory As Func(Of TKey, TValue)) As TValue" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TKey, typename TValue&gt;&#xA; static TValue GetOrAdd(System::Collections::Immutable::ImmutableDictionary&lt;TKey, TValue&gt; ^ % location, TKey key, Func&lt;TKey, TValue&gt; ^ valueFactory);" />
      <MemberSignature Language="F#" Value="static member GetOrAdd : ImmutableDictionary * 'Key * Func&lt;'Key, 'Value&gt; -&gt; 'Value" Usage="System.Collections.Immutable.ImmutableInterlocked.GetOrAdd (location, key, valueFactory)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Immutable</AssemblyName>
        <AssemblyVersion>1.1.37.0</AssemblyVersion>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
        <AssemblyVersion>1.2.1.0</AssemblyVersion>
        <AssemblyVersion>1.2.2.0</AssemblyVersion>
        <AssemblyVersion>1.2.3.0</AssemblyVersion>
        <AssemblyVersion>1.2.4.0</AssemblyVersion>
        <AssemblyVersion>1.2.5.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TValue</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TValue" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="location" Type="System.Collections.Immutable.ImmutableDictionary&lt;TKey,TValue&gt;" RefType="ref" />
        <Parameter Name="key" Type="TKey" />
        <Parameter Name="valueFactory" Type="System.Func&lt;TKey,TValue&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TKey"><span data-ttu-id="80baa-124">集合中包含的键的类型。</span><span class="sxs-lookup"><span data-stu-id="80baa-124">The type of the keys contained in the collection.</span></span></typeparam>
        <typeparam name="TValue"><span data-ttu-id="80baa-125">集合中包含的值的类型。</span><span class="sxs-lookup"><span data-stu-id="80baa-125">The type of the values contained in the collection.</span></span></typeparam>
        <param name="location"><span data-ttu-id="80baa-126">当指定的值不在字典中时以原子方式更新的变量或字段。</span><span class="sxs-lookup"><span data-stu-id="80baa-126">The variable or field to atomically update if the specified  is not in the dictionary.</span></span></param>
        <param name="key"><span data-ttu-id="80baa-127">要检索或添加的值的键。</span><span class="sxs-lookup"><span data-stu-id="80baa-127">The key for the value to retrieve or add.</span></span></param>
        <param name="valueFactory"><span data-ttu-id="80baa-128">在未找到键时，为了获取要插入到字典中的值而要执行的函数。</span><span class="sxs-lookup"><span data-stu-id="80baa-128">The function to execute to obtain the value to insert into the dictionary if the key is not found.</span></span> <span data-ttu-id="80baa-129">将不会多次调用此委托。</span><span class="sxs-lookup"><span data-stu-id="80baa-129">This delegate will not be invoked more than once.</span></span></param>
        <summary><span data-ttu-id="80baa-130">从字典中获取指定键的值；如果未找到该键，则向字典中添加新值。</span><span class="sxs-lookup"><span data-stu-id="80baa-130">Gets the value for the specified key from the dictionary, or if the key was not found, adds a new value to the dictionary.</span></span></summary>
        <returns><span data-ttu-id="80baa-131">位于指定键处的值；如果该键不存在，则为 <paramref name="valueFactory" />。</span><span class="sxs-lookup"><span data-stu-id="80baa-131">The value at the specified key or <paramref name="valueFactory" /> if the key was not present.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetOrAdd&lt;TKey,TValue&gt;">
      <MemberSignature Language="C#" Value="public static TValue GetOrAdd&lt;TKey,TValue&gt; (ref System.Collections.Immutable.ImmutableDictionary&lt;TKey,TValue&gt; location, TKey key, TValue value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TValue GetOrAdd&lt;TKey, TValue&gt;(class System.Collections.Immutable.ImmutableDictionary`2&lt;!!TKey, !!TValue&gt;&amp; location, !!TKey key, !!TValue value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Immutable.ImmutableInterlocked.GetOrAdd``2(System.Collections.Immutable.ImmutableDictionary{``0,``1}@,``0,``1)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetOrAdd(Of TKey, TValue) (ByRef location As ImmutableDictionary(Of TKey, TValue), key As TKey, value As TValue) As TValue" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TKey, typename TValue&gt;&#xA; static TValue GetOrAdd(System::Collections::Immutable::ImmutableDictionary&lt;TKey, TValue&gt; ^ % location, TKey key, TValue value);" />
      <MemberSignature Language="F#" Value="static member GetOrAdd : ImmutableDictionary * 'Key * 'Value -&gt; 'Value" Usage="System.Collections.Immutable.ImmutableInterlocked.GetOrAdd (location, key, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Immutable</AssemblyName>
        <AssemblyVersion>1.1.37.0</AssemblyVersion>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
        <AssemblyVersion>1.2.1.0</AssemblyVersion>
        <AssemblyVersion>1.2.2.0</AssemblyVersion>
        <AssemblyVersion>1.2.3.0</AssemblyVersion>
        <AssemblyVersion>1.2.4.0</AssemblyVersion>
        <AssemblyVersion>1.2.5.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TValue</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TValue" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="location" Type="System.Collections.Immutable.ImmutableDictionary&lt;TKey,TValue&gt;" RefType="ref" />
        <Parameter Name="key" Type="TKey" />
        <Parameter Name="value" Type="TValue" />
      </Parameters>
      <Docs>
        <typeparam name="TKey"><span data-ttu-id="80baa-132">集合中包含的键的类型。</span><span class="sxs-lookup"><span data-stu-id="80baa-132">The type of the keys contained in the collection.</span></span></typeparam>
        <typeparam name="TValue"><span data-ttu-id="80baa-133">集合中包含的值的类型。</span><span class="sxs-lookup"><span data-stu-id="80baa-133">The type of the values contained in the collection.</span></span></typeparam>
        <param name="location"><span data-ttu-id="80baa-134">当指定的键不在字典中时以原子方式更新的变量或字段。</span><span class="sxs-lookup"><span data-stu-id="80baa-134">The variable or field to atomically update if the specified key is not in the dictionary.</span></span></param>
        <param name="key"><span data-ttu-id="80baa-135">要获取或添加的值的键。</span><span class="sxs-lookup"><span data-stu-id="80baa-135">The key for the value to get or add.</span></span></param>
        <param name="value"><span data-ttu-id="80baa-136">未找到键时要添加到字典中的值。</span><span class="sxs-lookup"><span data-stu-id="80baa-136">The value to add to the dictionary the key is not found.</span></span></param>
        <summary><span data-ttu-id="80baa-137">从字典中获取指定键的值；如果未找到该键，则向字典中添加新值。</span><span class="sxs-lookup"><span data-stu-id="80baa-137">Gets the value for the specified key from the dictionary, or if the key was not found, adds a new value to the dictionary.</span></span></summary>
        <returns><span data-ttu-id="80baa-138">位于指定键处的值；如果该键不存在，则为 <paramref name="valueFactory" />。</span><span class="sxs-lookup"><span data-stu-id="80baa-138">The value at the specified key or <paramref name="valueFactory" /> if the key was not present.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetOrAdd&lt;TKey,TValue,TArg&gt;">
      <MemberSignature Language="C#" Value="public static TValue GetOrAdd&lt;TKey,TValue,TArg&gt; (ref System.Collections.Immutable.ImmutableDictionary&lt;TKey,TValue&gt; location, TKey key, Func&lt;TKey,TArg,TValue&gt; valueFactory, TArg factoryArgument);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TValue GetOrAdd&lt;TKey, TValue, TArg&gt;(class System.Collections.Immutable.ImmutableDictionary`2&lt;!!TKey, !!TValue&gt;&amp; location, !!TKey key, class System.Func`3&lt;!!TKey, !!TArg, !!TValue&gt; valueFactory, !!TArg factoryArgument) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Immutable.ImmutableInterlocked.GetOrAdd``3(System.Collections.Immutable.ImmutableDictionary{``0,``1}@,``0,System.Func{``0,``2,``1},``2)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetOrAdd(Of TKey, TValue, TArg) (ByRef location As ImmutableDictionary(Of TKey, TValue), key As TKey, valueFactory As Func(Of TKey, TArg, TValue), factoryArgument As TArg) As TValue" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TKey, typename TValue, typename TArg&gt;&#xA; static TValue GetOrAdd(System::Collections::Immutable::ImmutableDictionary&lt;TKey, TValue&gt; ^ % location, TKey key, Func&lt;TKey, TArg, TValue&gt; ^ valueFactory, TArg factoryArgument);" />
      <MemberSignature Language="F#" Value="static member GetOrAdd : ImmutableDictionary * 'Key * Func&lt;'Key, 'Arg, 'Value&gt; * 'Arg -&gt; 'Value" Usage="System.Collections.Immutable.ImmutableInterlocked.GetOrAdd (location, key, valueFactory, factoryArgument)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Immutable</AssemblyName>
        <AssemblyVersion>1.1.37.0</AssemblyVersion>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
        <AssemblyVersion>1.2.1.0</AssemblyVersion>
        <AssemblyVersion>1.2.2.0</AssemblyVersion>
        <AssemblyVersion>1.2.3.0</AssemblyVersion>
        <AssemblyVersion>1.2.4.0</AssemblyVersion>
        <AssemblyVersion>1.2.5.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TValue</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TValue" />
        <TypeParameter Name="TArg" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="location" Type="System.Collections.Immutable.ImmutableDictionary&lt;TKey,TValue&gt;" RefType="ref" />
        <Parameter Name="key" Type="TKey" />
        <Parameter Name="valueFactory" Type="System.Func&lt;TKey,TArg,TValue&gt;" />
        <Parameter Name="factoryArgument" Type="TArg" />
      </Parameters>
      <Docs>
        <typeparam name="TKey"><span data-ttu-id="80baa-139">集合中包含的键的类型。</span><span class="sxs-lookup"><span data-stu-id="80baa-139">The type of the keys contained in the collection.</span></span></typeparam>
        <typeparam name="TValue"><span data-ttu-id="80baa-140">集合中包含的值的类型。</span><span class="sxs-lookup"><span data-stu-id="80baa-140">The type of the values contained in the collection.</span></span></typeparam>
        <typeparam name="TArg"><span data-ttu-id="80baa-141">提供给值工厂的自变量的类型。</span><span class="sxs-lookup"><span data-stu-id="80baa-141">The type of the argument supplied to the value factory.</span></span></typeparam>
        <param name="location"><span data-ttu-id="80baa-142">当指定的值不在字典中时要更新的变量或字段。</span><span class="sxs-lookup"><span data-stu-id="80baa-142">The variable or field to update if the specified is not in the dictionary.</span></span></param>
        <param name="key"><span data-ttu-id="80baa-143">要检索或添加的值的键。</span><span class="sxs-lookup"><span data-stu-id="80baa-143">The key for the value to retrieve or add.</span></span></param>
        <param name="valueFactory"><span data-ttu-id="80baa-144">在未找到键时，为了获取要插入到字典中的值而要执行的函数。</span><span class="sxs-lookup"><span data-stu-id="80baa-144">The function to execute to obtain the value to insert into the dictionary if the key is not found.</span></span></param>
        <param name="factoryArgument"><span data-ttu-id="80baa-145">要传递给值工厂的参数。</span><span class="sxs-lookup"><span data-stu-id="80baa-145">The argument to pass to the value factory.</span></span></param>
        <summary><span data-ttu-id="80baa-146">从字典中获取指定键的值；如果未找到该键，则向字典中添加新值。</span><span class="sxs-lookup"><span data-stu-id="80baa-146">Gets the value for the specified key from the dictionary, or if the key was not found, adds a new value to the dictionary.</span></span></summary>
        <returns><span data-ttu-id="80baa-147">位于指定键处的值；如果该键不存在，则为 <paramref name="valueFactory" />。</span><span class="sxs-lookup"><span data-stu-id="80baa-147">The value at the specified key or <paramref name="valueFactory" /> if the key was not present.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="InterlockedCompareExchange&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Immutable.ImmutableArray&lt;T&gt; InterlockedCompareExchange&lt;T&gt; (ref System.Collections.Immutable.ImmutableArray&lt;T&gt; location, System.Collections.Immutable.ImmutableArray&lt;T&gt; value, System.Collections.Immutable.ImmutableArray&lt;T&gt; comparand);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Collections.Immutable.ImmutableArray`1&lt;!!T&gt; InterlockedCompareExchange&lt;T&gt;(valuetype System.Collections.Immutable.ImmutableArray`1&lt;!!T&gt;&amp; location, valuetype System.Collections.Immutable.ImmutableArray`1&lt;!!T&gt; value, valuetype System.Collections.Immutable.ImmutableArray`1&lt;!!T&gt; comparand) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Immutable.ImmutableInterlocked.InterlockedCompareExchange``1(System.Collections.Immutable.ImmutableArray{``0}@,System.Collections.Immutable.ImmutableArray{``0},System.Collections.Immutable.ImmutableArray{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function InterlockedCompareExchange(Of T) (ByRef location As ImmutableArray(Of T), value As ImmutableArray(Of T), comparand As ImmutableArray(Of T)) As ImmutableArray(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static System::Collections::Immutable::ImmutableArray&lt;T&gt; InterlockedCompareExchange(System::Collections::Immutable::ImmutableArray&lt;T&gt; % location, System::Collections::Immutable::ImmutableArray&lt;T&gt; value, System::Collections::Immutable::ImmutableArray&lt;T&gt; comparand);" />
      <MemberSignature Language="F#" Value="static member InterlockedCompareExchange : ImmutableArray * System.Collections.Immutable.ImmutableArray&lt;'T&gt; * System.Collections.Immutable.ImmutableArray&lt;'T&gt; -&gt; System.Collections.Immutable.ImmutableArray&lt;'T&gt;" Usage="System.Collections.Immutable.ImmutableInterlocked.InterlockedCompareExchange (location, value, comparand)" />
      <MemberSignature Language="C#" Value="public static System.Collections.Immutable.ImmutableArray&lt;T&gt;? InterlockedCompareExchange&lt;T&gt; (ref System.Collections.Immutable.ImmutableArray&lt;T&gt;? location, System.Collections.Immutable.ImmutableArray&lt;T&gt;? value, System.Collections.Immutable.ImmutableArray&lt;T&gt;? comparand);" FrameworkAlternate="net-5.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Immutable</AssemblyName>
        <AssemblyVersion>1.1.37.0</AssemblyVersion>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
        <AssemblyVersion>1.2.1.0</AssemblyVersion>
        <AssemblyVersion>1.2.2.0</AssemblyVersion>
        <AssemblyVersion>1.2.3.0</AssemblyVersion>
        <AssemblyVersion>1.2.4.0</AssemblyVersion>
        <AssemblyVersion>1.2.5.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Immutable.ImmutableArray&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="location" Type="System.Collections.Immutable.ImmutableArray&lt;T&gt;" RefType="ref" />
        <Parameter Name="value" Type="System.Collections.Immutable.ImmutableArray&lt;T&gt;" />
        <Parameter Name="comparand" Type="System.Collections.Immutable.ImmutableArray&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="80baa-148">数组存储的元素的类型。</span><span class="sxs-lookup"><span data-stu-id="80baa-148">The type of element stored by the array.</span></span></typeparam>
        <param name="location"><span data-ttu-id="80baa-149">其值将与 <paramref name="comparand" /> 进行比较并且可能被替换的目标。</span><span class="sxs-lookup"><span data-stu-id="80baa-149">The destination, whose value is compared with <paramref name="comparand" /> and possibly replaced.</span></span></param>
        <param name="value"><span data-ttu-id="80baa-150">比较结果相等时替换目标值的值。</span><span class="sxs-lookup"><span data-stu-id="80baa-150">The value that replaces the destination value if the comparison results in equality.</span></span></param>
        <param name="comparand"><span data-ttu-id="80baa-151">与位于 <paramref name="location" /> 处的值进行比较的值。</span><span class="sxs-lookup"><span data-stu-id="80baa-151">The value that is compared to the value at <paramref name="location" />.</span></span></param>
        <summary><span data-ttu-id="80baa-152">比较两个不可变数组是否相等，如果相等，则替换其中一个数组。</span><span class="sxs-lookup"><span data-stu-id="80baa-152">Compares two immutable arrays for equality and, if they are equal, replaces one of the arrays.</span></span></summary>
        <returns><span data-ttu-id="80baa-153"><paramref name="location" /> 中的原始值。</span><span class="sxs-lookup"><span data-stu-id="80baa-153">The original value in <paramref name="location" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="InterlockedExchange&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Immutable.ImmutableArray&lt;T&gt; InterlockedExchange&lt;T&gt; (ref System.Collections.Immutable.ImmutableArray&lt;T&gt; location, System.Collections.Immutable.ImmutableArray&lt;T&gt; value);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Collections.Immutable.ImmutableArray`1&lt;!!T&gt; InterlockedExchange&lt;T&gt;(valuetype System.Collections.Immutable.ImmutableArray`1&lt;!!T&gt;&amp; location, valuetype System.Collections.Immutable.ImmutableArray`1&lt;!!T&gt; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Immutable.ImmutableInterlocked.InterlockedExchange``1(System.Collections.Immutable.ImmutableArray{``0}@,System.Collections.Immutable.ImmutableArray{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function InterlockedExchange(Of T) (ByRef location As ImmutableArray(Of T), value As ImmutableArray(Of T)) As ImmutableArray(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static System::Collections::Immutable::ImmutableArray&lt;T&gt; InterlockedExchange(System::Collections::Immutable::ImmutableArray&lt;T&gt; % location, System::Collections::Immutable::ImmutableArray&lt;T&gt; value);" />
      <MemberSignature Language="F#" Value="static member InterlockedExchange : ImmutableArray * System.Collections.Immutable.ImmutableArray&lt;'T&gt; -&gt; System.Collections.Immutable.ImmutableArray&lt;'T&gt;" Usage="System.Collections.Immutable.ImmutableInterlocked.InterlockedExchange (location, value)" />
      <MemberSignature Language="C#" Value="public static System.Collections.Immutable.ImmutableArray&lt;T&gt;? InterlockedExchange&lt;T&gt; (ref System.Collections.Immutable.ImmutableArray&lt;T&gt;? location, System.Collections.Immutable.ImmutableArray&lt;T&gt;? value);" FrameworkAlternate="net-5.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Immutable</AssemblyName>
        <AssemblyVersion>1.1.37.0</AssemblyVersion>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
        <AssemblyVersion>1.2.1.0</AssemblyVersion>
        <AssemblyVersion>1.2.2.0</AssemblyVersion>
        <AssemblyVersion>1.2.3.0</AssemblyVersion>
        <AssemblyVersion>1.2.4.0</AssemblyVersion>
        <AssemblyVersion>1.2.5.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Immutable.ImmutableArray&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="location" Type="System.Collections.Immutable.ImmutableArray&lt;T&gt;" RefType="ref" />
        <Parameter Name="value" Type="System.Collections.Immutable.ImmutableArray&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="80baa-154">数组存储的元素的类型。</span><span class="sxs-lookup"><span data-stu-id="80baa-154">The type of element stored by the array.</span></span></typeparam>
        <param name="location"><span data-ttu-id="80baa-155">要设置为指定值的数组。</span><span class="sxs-lookup"><span data-stu-id="80baa-155">The array to set to the specified value.</span></span></param>
        <param name="value"><span data-ttu-id="80baa-156"><paramref name="location" /> 参数要设置成的值。</span><span class="sxs-lookup"><span data-stu-id="80baa-156">The value to which the <paramref name="location" /> parameter is set.</span></span></param>
        <summary><span data-ttu-id="80baa-157">以原子操作的形式将某个数组设置为指定的数组，并返回对原始数组的引用。</span><span class="sxs-lookup"><span data-stu-id="80baa-157">Sets an array to the specified array and returns a reference to the original array, as an atomic operation.</span></span></summary>
        <returns><span data-ttu-id="80baa-158"><paramref name="location" /> 的原始值。</span><span class="sxs-lookup"><span data-stu-id="80baa-158">The original value of <paramref name="location" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="InterlockedInitialize&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool InterlockedInitialize&lt;T&gt; (ref System.Collections.Immutable.ImmutableArray&lt;T&gt; location, System.Collections.Immutable.ImmutableArray&lt;T&gt; value);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool InterlockedInitialize&lt;T&gt;(valuetype System.Collections.Immutable.ImmutableArray`1&lt;!!T&gt;&amp; location, valuetype System.Collections.Immutable.ImmutableArray`1&lt;!!T&gt; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Immutable.ImmutableInterlocked.InterlockedInitialize``1(System.Collections.Immutable.ImmutableArray{``0}@,System.Collections.Immutable.ImmutableArray{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function InterlockedInitialize(Of T) (ByRef location As ImmutableArray(Of T), value As ImmutableArray(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static bool InterlockedInitialize(System::Collections::Immutable::ImmutableArray&lt;T&gt; % location, System::Collections::Immutable::ImmutableArray&lt;T&gt; value);" />
      <MemberSignature Language="F#" Value="static member InterlockedInitialize : ImmutableArray * System.Collections.Immutable.ImmutableArray&lt;'T&gt; -&gt; bool" Usage="System.Collections.Immutable.ImmutableInterlocked.InterlockedInitialize (location, value)" />
      <MemberSignature Language="C#" Value="public static bool InterlockedInitialize&lt;T&gt; (ref System.Collections.Immutable.ImmutableArray&lt;T&gt;? location, System.Collections.Immutable.ImmutableArray&lt;T&gt;? value);" FrameworkAlternate="net-5.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Immutable</AssemblyName>
        <AssemblyVersion>1.1.37.0</AssemblyVersion>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
        <AssemblyVersion>1.2.1.0</AssemblyVersion>
        <AssemblyVersion>1.2.2.0</AssemblyVersion>
        <AssemblyVersion>1.2.3.0</AssemblyVersion>
        <AssemblyVersion>1.2.4.0</AssemblyVersion>
        <AssemblyVersion>1.2.5.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="location" Type="System.Collections.Immutable.ImmutableArray&lt;T&gt;" RefType="ref" />
        <Parameter Name="value" Type="System.Collections.Immutable.ImmutableArray&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="80baa-159">数组存储的元素的类型。</span><span class="sxs-lookup"><span data-stu-id="80baa-159">The type of element stored by the array.</span></span></typeparam>
        <param name="location"><span data-ttu-id="80baa-160">要设置为指定值的数组。</span><span class="sxs-lookup"><span data-stu-id="80baa-160">The array to set to the specified value.</span></span></param>
        <param name="value"><span data-ttu-id="80baa-161"><paramref name="location" /> 参数要设置成的值（如果该参数尚未初始化）。</span><span class="sxs-lookup"><span data-stu-id="80baa-161">The value to which the <paramref name="location" /> parameter is set, if it's not initialized.</span></span></param>
        <summary><span data-ttu-id="80baa-162">如果某个数组尚未初始化，则将该数组设置为指定的数组。</span><span class="sxs-lookup"><span data-stu-id="80baa-162">Sets an array to the specified array if the array has not been initialized.</span></span></summary>
        <returns><span data-ttu-id="80baa-163">如果为数组分配了指定的值，则为 <see langword="true" />； 否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="80baa-163"><see langword="true" /> if the array was assigned the specified value;  otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Push&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Push&lt;T&gt; (ref System.Collections.Immutable.ImmutableStack&lt;T&gt; location, T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Push&lt;T&gt;(class System.Collections.Immutable.ImmutableStack`1&lt;!!T&gt;&amp; location, !!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Immutable.ImmutableInterlocked.Push``1(System.Collections.Immutable.ImmutableStack{``0}@,``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Push(Of T) (ByRef location As ImmutableStack(Of T), value As T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void Push(System::Collections::Immutable::ImmutableStack&lt;T&gt; ^ % location, T value);" />
      <MemberSignature Language="F#" Value="static member Push : ImmutableStack * 'T -&gt; unit" Usage="System.Collections.Immutable.ImmutableInterlocked.Push (location, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Immutable</AssemblyName>
        <AssemblyVersion>1.1.37.0</AssemblyVersion>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
        <AssemblyVersion>1.2.1.0</AssemblyVersion>
        <AssemblyVersion>1.2.2.0</AssemblyVersion>
        <AssemblyVersion>1.2.3.0</AssemblyVersion>
        <AssemblyVersion>1.2.4.0</AssemblyVersion>
        <AssemblyVersion>1.2.5.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="location" Type="System.Collections.Immutable.ImmutableStack&lt;T&gt;" RefType="ref" />
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="80baa-164">堆栈中项的类型。</span><span class="sxs-lookup"><span data-stu-id="80baa-164">The type of items in the stack.</span></span></typeparam>
        <param name="location"><span data-ttu-id="80baa-165">要更新的堆栈。</span><span class="sxs-lookup"><span data-stu-id="80baa-165">The stack to update.</span></span></param>
        <param name="value"><span data-ttu-id="80baa-166">要推送到堆栈的值。</span><span class="sxs-lookup"><span data-stu-id="80baa-166">The value to push on the stack.</span></span></param>
        <summary><span data-ttu-id="80baa-167">将新元素推送到堆栈。</span><span class="sxs-lookup"><span data-stu-id="80baa-167">Pushes a new element onto the stack.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryAdd&lt;TKey,TValue&gt;">
      <MemberSignature Language="C#" Value="public static bool TryAdd&lt;TKey,TValue&gt; (ref System.Collections.Immutable.ImmutableDictionary&lt;TKey,TValue&gt; location, TKey key, TValue value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryAdd&lt;TKey, TValue&gt;(class System.Collections.Immutable.ImmutableDictionary`2&lt;!!TKey, !!TValue&gt;&amp; location, !!TKey key, !!TValue value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Immutable.ImmutableInterlocked.TryAdd``2(System.Collections.Immutable.ImmutableDictionary{``0,``1}@,``0,``1)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryAdd(Of TKey, TValue) (ByRef location As ImmutableDictionary(Of TKey, TValue), key As TKey, value As TValue) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TKey, typename TValue&gt;&#xA; static bool TryAdd(System::Collections::Immutable::ImmutableDictionary&lt;TKey, TValue&gt; ^ % location, TKey key, TValue value);" />
      <MemberSignature Language="F#" Value="static member TryAdd : ImmutableDictionary * 'Key * 'Value -&gt; bool" Usage="System.Collections.Immutable.ImmutableInterlocked.TryAdd (location, key, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Immutable</AssemblyName>
        <AssemblyVersion>1.1.37.0</AssemblyVersion>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
        <AssemblyVersion>1.2.1.0</AssemblyVersion>
        <AssemblyVersion>1.2.2.0</AssemblyVersion>
        <AssemblyVersion>1.2.3.0</AssemblyVersion>
        <AssemblyVersion>1.2.4.0</AssemblyVersion>
        <AssemblyVersion>1.2.5.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TValue" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="location" Type="System.Collections.Immutable.ImmutableDictionary&lt;TKey,TValue&gt;" RefType="ref" />
        <Parameter Name="key" Type="TKey" />
        <Parameter Name="value" Type="TValue" />
      </Parameters>
      <Docs>
        <typeparam name="TKey"><span data-ttu-id="80baa-168">集合中包含的键的类型。</span><span class="sxs-lookup"><span data-stu-id="80baa-168">The type of the keys contained in the collection.</span></span></typeparam>
        <typeparam name="TValue"><span data-ttu-id="80baa-169">集合中包含的值的类型。</span><span class="sxs-lookup"><span data-stu-id="80baa-169">The type of the values contained in the collection.</span></span></typeparam>
        <param name="location"><span data-ttu-id="80baa-170">要使用指定的键和值更新的字典。</span><span class="sxs-lookup"><span data-stu-id="80baa-170">The dictionary to update with the specified key and value.</span></span></param>
        <param name="key"><span data-ttu-id="80baa-171">要添加的键（如果字典中尚未定义该键）。</span><span class="sxs-lookup"><span data-stu-id="80baa-171">The key to add, if is not already defined in the dictionary.</span></span></param>
        <param name="value"><span data-ttu-id="80baa-172">要相加的值。</span><span class="sxs-lookup"><span data-stu-id="80baa-172">The value to add.</span></span></param>
        <summary><span data-ttu-id="80baa-173">将指定的键和值添加到字典（如果该键不在字典中）。</span><span class="sxs-lookup"><span data-stu-id="80baa-173">Adds the specified key and value to the dictionary if the key is not in the dictionary.</span></span></summary>
        <returns><span data-ttu-id="80baa-174">如果该键不在字典中，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="80baa-174"><see langword="true" /> if the key is not in the dictionary; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryDequeue&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool TryDequeue&lt;T&gt; (ref System.Collections.Immutable.ImmutableQueue&lt;T&gt; location, out T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryDequeue&lt;T&gt;(class System.Collections.Immutable.ImmutableQueue`1&lt;!!T&gt;&amp; location, [out] !!T&amp; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Immutable.ImmutableInterlocked.TryDequeue``1(System.Collections.Immutable.ImmutableQueue{``0}@,``0@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryDequeue(Of T) (ByRef location As ImmutableQueue(Of T), ByRef value As T) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static bool TryDequeue(System::Collections::Immutable::ImmutableQueue&lt;T&gt; ^ % location, [Runtime::InteropServices::Out] T % value);" />
      <MemberSignature Language="F#" Value="static member TryDequeue : ImmutableQueue * 'T -&gt; bool" Usage="System.Collections.Immutable.ImmutableInterlocked.TryDequeue (location, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Immutable</AssemblyName>
        <AssemblyVersion>1.1.37.0</AssemblyVersion>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
        <AssemblyVersion>1.2.1.0</AssemblyVersion>
        <AssemblyVersion>1.2.2.0</AssemblyVersion>
        <AssemblyVersion>1.2.3.0</AssemblyVersion>
        <AssemblyVersion>1.2.4.0</AssemblyVersion>
        <AssemblyVersion>1.2.5.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="location" Type="System.Collections.Immutable.ImmutableQueue&lt;T&gt;" RefType="ref" />
        <Parameter Name="value" Type="T" RefType="out" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="80baa-175">队列中项的类型。</span><span class="sxs-lookup"><span data-stu-id="80baa-175">The type of items in the queue.</span></span></typeparam>
        <param name="location"><span data-ttu-id="80baa-176">以原子方式更新的变量或字段。</span><span class="sxs-lookup"><span data-stu-id="80baa-176">The variable or field to atomically update.</span></span></param>
        <param name="value"><span data-ttu-id="80baa-177">设置为队列开头位置的值（如果队列不为空）。</span><span class="sxs-lookup"><span data-stu-id="80baa-177">Set to the value from the head of the queue, if the queue not empty.</span></span></param>
        <summary><span data-ttu-id="80baa-178">以原子方式移除和返回位于队列开头处的指定元素（如果队列不为空）。</span><span class="sxs-lookup"><span data-stu-id="80baa-178">Atomically removes and returns the specified element at the head of the queue, if the queue is not empty.</span></span></summary>
        <returns><span data-ttu-id="80baa-179">如果队列不为空并且已移除头元素，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="80baa-179"><see langword="true" /> if the queue is not empty and the head element is removed; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryPop&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool TryPop&lt;T&gt; (ref System.Collections.Immutable.ImmutableStack&lt;T&gt; location, out T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryPop&lt;T&gt;(class System.Collections.Immutable.ImmutableStack`1&lt;!!T&gt;&amp; location, [out] !!T&amp; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Immutable.ImmutableInterlocked.TryPop``1(System.Collections.Immutable.ImmutableStack{``0}@,``0@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryPop(Of T) (ByRef location As ImmutableStack(Of T), ByRef value As T) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static bool TryPop(System::Collections::Immutable::ImmutableStack&lt;T&gt; ^ % location, [Runtime::InteropServices::Out] T % value);" />
      <MemberSignature Language="F#" Value="static member TryPop : ImmutableStack * 'T -&gt; bool" Usage="System.Collections.Immutable.ImmutableInterlocked.TryPop (location, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Immutable</AssemblyName>
        <AssemblyVersion>1.1.37.0</AssemblyVersion>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
        <AssemblyVersion>1.2.1.0</AssemblyVersion>
        <AssemblyVersion>1.2.2.0</AssemblyVersion>
        <AssemblyVersion>1.2.3.0</AssemblyVersion>
        <AssemblyVersion>1.2.4.0</AssemblyVersion>
        <AssemblyVersion>1.2.5.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="location" Type="System.Collections.Immutable.ImmutableStack&lt;T&gt;" RefType="ref" />
        <Parameter Name="value" Type="T" RefType="out" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="80baa-180">堆栈中项的类型。</span><span class="sxs-lookup"><span data-stu-id="80baa-180">The type of items in the stack.</span></span></typeparam>
        <param name="location"><span data-ttu-id="80baa-181">要更新的堆栈。</span><span class="sxs-lookup"><span data-stu-id="80baa-181">The stack to update.</span></span></param>
        <param name="value"><span data-ttu-id="80baa-182">如果堆栈不为空，则接收已从堆栈中移除的值。</span><span class="sxs-lookup"><span data-stu-id="80baa-182">Receives the value removed from the stack, if the stack is not empty.</span></span></param>
        <summary><span data-ttu-id="80baa-183">如果有要移除的元素，则从堆栈顶部移除一个元素。</span><span class="sxs-lookup"><span data-stu-id="80baa-183">Removes an element from the top of the stack, if there is an element to remove.</span></span></summary>
        <returns><span data-ttu-id="80baa-184">如果从堆栈中移除了一个元素，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="80baa-184"><see langword="true" /> if an element is removed from the stack; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryRemove&lt;TKey,TValue&gt;">
      <MemberSignature Language="C#" Value="public static bool TryRemove&lt;TKey,TValue&gt; (ref System.Collections.Immutable.ImmutableDictionary&lt;TKey,TValue&gt; location, TKey key, out TValue value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryRemove&lt;TKey, TValue&gt;(class System.Collections.Immutable.ImmutableDictionary`2&lt;!!TKey, !!TValue&gt;&amp; location, !!TKey key, [out] !!TValue&amp; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Immutable.ImmutableInterlocked.TryRemove``2(System.Collections.Immutable.ImmutableDictionary{``0,``1}@,``0,``1@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryRemove(Of TKey, TValue) (ByRef location As ImmutableDictionary(Of TKey, TValue), key As TKey, ByRef value As TValue) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TKey, typename TValue&gt;&#xA; static bool TryRemove(System::Collections::Immutable::ImmutableDictionary&lt;TKey, TValue&gt; ^ % location, TKey key, [Runtime::InteropServices::Out] TValue % value);" />
      <MemberSignature Language="F#" Value="static member TryRemove : ImmutableDictionary * 'Key * 'Value -&gt; bool" Usage="System.Collections.Immutable.ImmutableInterlocked.TryRemove (location, key, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Immutable</AssemblyName>
        <AssemblyVersion>1.1.37.0</AssemblyVersion>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
        <AssemblyVersion>1.2.1.0</AssemblyVersion>
        <AssemblyVersion>1.2.2.0</AssemblyVersion>
        <AssemblyVersion>1.2.3.0</AssemblyVersion>
        <AssemblyVersion>1.2.4.0</AssemblyVersion>
        <AssemblyVersion>1.2.5.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TValue" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="location" Type="System.Collections.Immutable.ImmutableDictionary&lt;TKey,TValue&gt;" RefType="ref" />
        <Parameter Name="key" Type="TKey" />
        <Parameter Name="value" Type="TValue" RefType="out" />
      </Parameters>
      <Docs>
        <typeparam name="TKey"><span data-ttu-id="80baa-185">集合中包含的键的类型。</span><span class="sxs-lookup"><span data-stu-id="80baa-185">The type of the keys contained in the collection.</span></span></typeparam>
        <typeparam name="TValue"><span data-ttu-id="80baa-186">集合中包含的值的类型。</span><span class="sxs-lookup"><span data-stu-id="80baa-186">The type of the values contained in the collection.</span></span></typeparam>
        <param name="location"><span data-ttu-id="80baa-187">要更新的字典。</span><span class="sxs-lookup"><span data-stu-id="80baa-187">The dictionary to update.</span></span></param>
        <param name="key"><span data-ttu-id="80baa-188">要移除的键。</span><span class="sxs-lookup"><span data-stu-id="80baa-188">The key to remove.</span></span></param>
        <param name="value"><span data-ttu-id="80baa-189">如果字典不为空，则接收已移除项的值。</span><span class="sxs-lookup"><span data-stu-id="80baa-189">Receives the value of the removed item, if the dictionary is not empty.</span></span></param>
        <summary><span data-ttu-id="80baa-190">移除具有指定键的元素（如果该键存在）。</span><span class="sxs-lookup"><span data-stu-id="80baa-190">Removes the element with the specified key, if the key exists.</span></span></summary>
        <returns><span data-ttu-id="80baa-191">如果找到并移除了该键，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="80baa-191"><see langword="true" /> if the key was found and removed; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryUpdate&lt;TKey,TValue&gt;">
      <MemberSignature Language="C#" Value="public static bool TryUpdate&lt;TKey,TValue&gt; (ref System.Collections.Immutable.ImmutableDictionary&lt;TKey,TValue&gt; location, TKey key, TValue newValue, TValue comparisonValue);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryUpdate&lt;TKey, TValue&gt;(class System.Collections.Immutable.ImmutableDictionary`2&lt;!!TKey, !!TValue&gt;&amp; location, !!TKey key, !!TValue newValue, !!TValue comparisonValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Immutable.ImmutableInterlocked.TryUpdate``2(System.Collections.Immutable.ImmutableDictionary{``0,``1}@,``0,``1,``1)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryUpdate(Of TKey, TValue) (ByRef location As ImmutableDictionary(Of TKey, TValue), key As TKey, newValue As TValue, comparisonValue As TValue) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TKey, typename TValue&gt;&#xA; static bool TryUpdate(System::Collections::Immutable::ImmutableDictionary&lt;TKey, TValue&gt; ^ % location, TKey key, TValue newValue, TValue comparisonValue);" />
      <MemberSignature Language="F#" Value="static member TryUpdate : ImmutableDictionary * 'Key * 'Value * 'Value -&gt; bool" Usage="System.Collections.Immutable.ImmutableInterlocked.TryUpdate (location, key, newValue, comparisonValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Immutable</AssemblyName>
        <AssemblyVersion>1.1.37.0</AssemblyVersion>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
        <AssemblyVersion>1.2.1.0</AssemblyVersion>
        <AssemblyVersion>1.2.2.0</AssemblyVersion>
        <AssemblyVersion>1.2.3.0</AssemblyVersion>
        <AssemblyVersion>1.2.4.0</AssemblyVersion>
        <AssemblyVersion>1.2.5.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TValue" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="location" Type="System.Collections.Immutable.ImmutableDictionary&lt;TKey,TValue&gt;" RefType="ref" />
        <Parameter Name="key" Type="TKey" />
        <Parameter Name="newValue" Type="TValue" />
        <Parameter Name="comparisonValue" Type="TValue" />
      </Parameters>
      <Docs>
        <typeparam name="TKey"><span data-ttu-id="80baa-192">集合中包含的键的类型。</span><span class="sxs-lookup"><span data-stu-id="80baa-192">The type of the keys contained in the collection.</span></span></typeparam>
        <typeparam name="TValue"><span data-ttu-id="80baa-193">集合中包含的值的类型。</span><span class="sxs-lookup"><span data-stu-id="80baa-193">The type of the values contained in the collection.</span></span></typeparam>
        <param name="location"><span data-ttu-id="80baa-194">要更新的字典。</span><span class="sxs-lookup"><span data-stu-id="80baa-194">The dictionary to update.</span></span></param>
        <param name="key"><span data-ttu-id="80baa-195">要更新的键。</span><span class="sxs-lookup"><span data-stu-id="80baa-195">The key to update.</span></span></param>
        <param name="newValue"><span data-ttu-id="80baa-196">要设置的新值。</span><span class="sxs-lookup"><span data-stu-id="80baa-196">The new value to set.</span></span></param>
        <param name="comparisonValue"><span data-ttu-id="80baa-197">返回 <paramref name="key" /> 的当前值，以便更新能够成功。</span><span class="sxs-lookup"><span data-stu-id="80baa-197">The current value for <paramref name="key" /> in order for the update to succeed.</span></span></param>
        <summary><span data-ttu-id="80baa-198">如果指定的键已设置为特定值，则将指定的键设置为指定的值。</span><span class="sxs-lookup"><span data-stu-id="80baa-198">Sets the specified key to the specified value if the specified key already is set to a specific value.</span></span></summary>
        <returns><span data-ttu-id="80baa-199">如果 <paramref name="key" /> 和 <paramref name="comparisonValue" /> 在字典中存在并且比较已更新为 <paramref name="newValue" />，则为 <see langword="true" />； 否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="80baa-199"><see langword="true" /> if <paramref name="key" /> and <paramref name="comparisonValue" /> are present in the dictionary and comparison was updated to <paramref name="newValue" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Update&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool Update&lt;T&gt; (ref System.Collections.Immutable.ImmutableArray&lt;T&gt;? location, Func&lt;System.Collections.Immutable.ImmutableArray&lt;T&gt;,System.Collections.Immutable.ImmutableArray&lt;T&gt;&gt;? transformer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Update&lt;T&gt;(valuetype System.Collections.Immutable.ImmutableArray`1&lt;!!T&gt;&amp; location, class System.Func`2&lt;valuetype System.Collections.Immutable.ImmutableArray`1&lt;!!T&gt;, valuetype System.Collections.Immutable.ImmutableArray`1&lt;!!T&gt;&gt; transformer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Immutable.ImmutableInterlocked.Update``1(System.Collections.Immutable.ImmutableArray{``0}@,System.Func{System.Collections.Immutable.ImmutableArray{``0},System.Collections.Immutable.ImmutableArray{``0}})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Update(Of T) (ByRef location As ImmutableArray(Of T), transformer As Func(Of ImmutableArray(Of T), ImmutableArray(Of T))) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static bool Update(System::Collections::Immutable::ImmutableArray&lt;T&gt; % location, Func&lt;System::Collections::Immutable::ImmutableArray&lt;T&gt;, System::Collections::Immutable::ImmutableArray&lt;T&gt;&gt; ^ transformer);" />
      <MemberSignature Language="F#" Value="static member Update : ImmutableArray * Func&lt;System.Collections.Immutable.ImmutableArray&lt;'T&gt;, System.Collections.Immutable.ImmutableArray&lt;'T&gt;&gt; -&gt; bool" Usage="System.Collections.Immutable.ImmutableInterlocked.Update (location, transformer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Immutable</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="location" Type="System.Collections.Immutable.ImmutableArray&lt;T&gt;" RefType="ref" Index="0" FrameworkAlternate="net-5.0" />
        <Parameter Name="transformer" Type="System.Func&lt;System.Collections.Immutable.ImmutableArray&lt;T&gt;,System.Collections.Immutable.ImmutableArray&lt;T&gt;&gt;" Index="1" FrameworkAlternate="net-5.0" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="80baa-200">不可变数组中的数据类型。</span><span class="sxs-lookup"><span data-stu-id="80baa-200">The type of data in the immutable array.</span></span></typeparam>
        <param name="location"><span data-ttu-id="80baa-201">要更改的不可变数组。</span><span class="sxs-lookup"><span data-stu-id="80baa-201">The immutable array to be changed.</span></span></param>
        <param name="transformer"><span data-ttu-id="80baa-202">从旧的生成新数组的函数。</span><span class="sxs-lookup"><span data-stu-id="80baa-202">A function that produces the new array from the old.</span></span> <span data-ttu-id="80baa-203">此函数应为 "副作用"，因为它可能会在与其他线程发生争用时运行多次。</span><span class="sxs-lookup"><span data-stu-id="80baa-203">This function should be side-effect free, as it may run multiple times when races occur with other threads.</span></span></param>
        <summary><span data-ttu-id="80baa-204">通过指定的转换函数使用开放式锁定事务语义就地改变不可变数组。</span><span class="sxs-lookup"><span data-stu-id="80baa-204">Mutates an immutable array in-place with optimistic locking transaction semantics via a specified transformation function.</span></span>
<span data-ttu-id="80baa-205">可根据需要多次重试转换，以赢取乐观锁定争用。</span><span class="sxs-lookup"><span data-stu-id="80baa-205">The transformation is retried as many times as necessary to win the optimistic locking race.</span></span></summary>
        <returns><span data-ttu-id="80baa-206">如果位置值是通过应用 <paramref name="transformer" /> 函数的结果而更改，则为 <see langword="true" />；如果位置值因上次调用 <paramref name="transformer" /> 返回的现有值而保持不变，则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="80baa-206"><see langword="true" /> if the location's value is changed by applying the result of the <paramref name="transformer" /> function; <see langword="false" /> if the location's value remained the same because the last invocation of <paramref name="transformer" /> returned the existing value.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Update&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool Update&lt;T&gt; (ref T location, Func&lt;T,T&gt; transformer) where T : class;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Update&lt;class T&gt;(!!T&amp; location, class System.Func`2&lt;!!T, !!T&gt; transformer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Immutable.ImmutableInterlocked.Update``1(``0@,System.Func{``0,``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Update(Of T As Class) (ByRef location As T, transformer As Func(Of T, T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : class static bool Update(T % location, Func&lt;T, T&gt; ^ transformer);" />
      <MemberSignature Language="F#" Value="static member Update : 'T * Func&lt;'T, 'T (requires 'T : null and 'T : null)&gt; -&gt; bool (requires 'T : null)" Usage="System.Collections.Immutable.ImmutableInterlocked.Update (location, transformer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Immutable</AssemblyName>
        <AssemblyVersion>1.1.37.0</AssemblyVersion>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
        <AssemblyVersion>1.2.1.0</AssemblyVersion>
        <AssemblyVersion>1.2.2.0</AssemblyVersion>
        <AssemblyVersion>1.2.3.0</AssemblyVersion>
        <AssemblyVersion>1.2.4.0</AssemblyVersion>
        <AssemblyVersion>1.2.5.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="location" Type="T" RefType="ref" />
        <Parameter Name="transformer" Type="System.Func&lt;T,T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="80baa-207">数据类型。</span><span class="sxs-lookup"><span data-stu-id="80baa-207">The type of data.</span></span></typeparam>
        <param name="location"><span data-ttu-id="80baa-208">要更改的变量或字段，可通过多个线程进行访问。</span><span class="sxs-lookup"><span data-stu-id="80baa-208">The variable or field to be changed, which may be accessed by multiple threads.</span></span></param>
        <param name="transformer"><span data-ttu-id="80baa-209">可改变值的函数。</span><span class="sxs-lookup"><span data-stu-id="80baa-209">A function that mutates the value.</span></span> <span data-ttu-id="80baa-210">此函数应无任何副作用，因为在与其他线程发生争用时，该函数可能运行多次。</span><span class="sxs-lookup"><span data-stu-id="80baa-210">This function should be side-effect free,              as it may run multiple times when races occur with other threads.</span></span></param>
        <summary><span data-ttu-id="80baa-211">通过指定转换函数使用乐观锁定事务语义就地改变值。</span><span class="sxs-lookup"><span data-stu-id="80baa-211">Mutates a value in-place with optimistic locking transaction semantics             via a specified transformation function.</span></span>             <span data-ttu-id="80baa-212">可根据需要多次重试转换，以赢取乐观锁定争用。</span><span class="sxs-lookup"><span data-stu-id="80baa-212">The transformation is retried as many times as necessary to win the optimistic locking race.</span></span></summary>
        <returns><span data-ttu-id="80baa-213">如果位置值是通过应用 <paramref name="transformer" /> 函数的结果而更改，则为 <see langword="true" />；如果位置值因上次调用 <paramref name="transformer" /> 返回的现有值而保持不变，则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="80baa-213"><see langword="true" /> if the location's value is changed by applying the result of the <paramref name="transformer" /> function; <see langword="false" /> if the location's value remained the same because the last invocation of <paramref name="transformer" /> returned the existing value.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Update&lt;T,TArg&gt;">
      <MemberSignature Language="C#" Value="public static bool Update&lt;T,TArg&gt; (ref System.Collections.Immutable.ImmutableArray&lt;T&gt;? location, Func&lt;System.Collections.Immutable.ImmutableArray&lt;T&gt;,TArg,System.Collections.Immutable.ImmutableArray&lt;T&gt;&gt;? transformer, TArg? transformerArgument);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Update&lt;T, TArg&gt;(valuetype System.Collections.Immutable.ImmutableArray`1&lt;!!T&gt;&amp; location, class System.Func`3&lt;valuetype System.Collections.Immutable.ImmutableArray`1&lt;!!T&gt;, !!TArg, valuetype System.Collections.Immutable.ImmutableArray`1&lt;!!T&gt;&gt; transformer, !!TArg transformerArgument) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Immutable.ImmutableInterlocked.Update``2(System.Collections.Immutable.ImmutableArray{``0}@,System.Func{System.Collections.Immutable.ImmutableArray{``0},``1,System.Collections.Immutable.ImmutableArray{``0}},``1)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Update(Of T, TArg) (ByRef location As ImmutableArray(Of T), transformer As Func(Of ImmutableArray(Of T), TArg, ImmutableArray(Of T)), transformerArgument As TArg) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T, typename TArg&gt;&#xA; static bool Update(System::Collections::Immutable::ImmutableArray&lt;T&gt; % location, Func&lt;System::Collections::Immutable::ImmutableArray&lt;T&gt;, TArg, System::Collections::Immutable::ImmutableArray&lt;T&gt;&gt; ^ transformer, TArg transformerArgument);" />
      <MemberSignature Language="F#" Value="static member Update : ImmutableArray * Func&lt;System.Collections.Immutable.ImmutableArray&lt;'T&gt;, 'Arg, System.Collections.Immutable.ImmutableArray&lt;'T&gt;&gt; * 'Arg -&gt; bool" Usage="System.Collections.Immutable.ImmutableInterlocked.Update (location, transformer, transformerArgument)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Immutable</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
        <TypeParameter Name="TArg" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="location" Type="System.Collections.Immutable.ImmutableArray&lt;T&gt;" RefType="ref" Index="0" FrameworkAlternate="net-5.0" />
        <Parameter Name="transformer" Type="System.Func&lt;System.Collections.Immutable.ImmutableArray&lt;T&gt;,TArg,System.Collections.Immutable.ImmutableArray&lt;T&gt;&gt;" Index="1" FrameworkAlternate="net-5.0" />
        <Parameter Name="transformerArgument" Type="TArg" Index="2" FrameworkAlternate="net-5.0" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="80baa-214">不可变数组中的数据类型。</span><span class="sxs-lookup"><span data-stu-id="80baa-214">The type of data in the immutable array.</span></span></typeparam>
        <typeparam name="TArg"><span data-ttu-id="80baa-215">传递到的参数的类型 <paramref name="transformer" /> 。</span><span class="sxs-lookup"><span data-stu-id="80baa-215">The type of argument passed to the <paramref name="transformer" />.</span></span></typeparam>
        <param name="location"><span data-ttu-id="80baa-216">要更改的不可变数组。</span><span class="sxs-lookup"><span data-stu-id="80baa-216">The immutable array to be changed.</span></span></param>
        <param name="transformer"><span data-ttu-id="80baa-217">从旧的生成新数组的函数。</span><span class="sxs-lookup"><span data-stu-id="80baa-217">A function that produces the new array from the old.</span></span> <span data-ttu-id="80baa-218">此函数应为 "副作用"，因为它可能会在与其他线程发生争用时运行多次。</span><span class="sxs-lookup"><span data-stu-id="80baa-218">This function should be side-effect free, as it may run multiple times when races occur with other threads.</span></span></param>
        <param name="transformerArgument"><span data-ttu-id="80baa-219">要传递给 <paramref name="transformer" /> 的参数。</span><span class="sxs-lookup"><span data-stu-id="80baa-219">The argument to pass to <paramref name="transformer" />.</span></span></param>
        <summary><span data-ttu-id="80baa-220">通过指定的转换函数使用开放式锁定事务语义就地改变不可变数组。</span><span class="sxs-lookup"><span data-stu-id="80baa-220">Mutates an immutable array in-place with optimistic locking transaction semantics via a specified transformation function.</span></span>
<span data-ttu-id="80baa-221">可根据需要多次重试转换，以赢取乐观锁定争用。</span><span class="sxs-lookup"><span data-stu-id="80baa-221">The transformation is retried as many times as necessary to win the optimistic locking race.</span></span></summary>
        <returns><span data-ttu-id="80baa-222">如果位置值是通过应用 <paramref name="transformer" /> 函数的结果而更改，则为 <see langword="true" />；如果位置值因上次调用 <paramref name="transformer" /> 返回的现有值而保持不变，则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="80baa-222"><see langword="true" /> if the location's value is changed by applying the result of the <paramref name="transformer" /> function; <see langword="false" /> if the location's value remained the same because the last invocation of <paramref name="transformer" /> returned the existing value.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Update&lt;T,TArg&gt;">
      <MemberSignature Language="C#" Value="public static bool Update&lt;T,TArg&gt; (ref T location, Func&lt;T,TArg,T&gt; transformer, TArg transformerArgument) where T : class;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Update&lt;class T, TArg&gt;(!!T&amp; location, class System.Func`3&lt;!!T, !!TArg, !!T&gt; transformer, !!TArg transformerArgument) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Immutable.ImmutableInterlocked.Update``2(``0@,System.Func{``0,``1,``0},``1)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Update(Of T As Class, TArg As Class) (ByRef location As T, transformer As Func(Of T, TArg, T), transformerArgument As TArg) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T, typename TArg&gt;&#xA; where T : class static bool Update(T % location, Func&lt;T, TArg, T&gt; ^ transformer, TArg transformerArgument);" />
      <MemberSignature Language="F#" Value="static member Update : 'T * Func&lt;'T, 'Arg, 'T (requires 'T : null and 'T : null)&gt; * 'Arg -&gt; bool (requires 'T : null)" Usage="System.Collections.Immutable.ImmutableInterlocked.Update (location, transformer, transformerArgument)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Immutable</AssemblyName>
        <AssemblyVersion>1.1.37.0</AssemblyVersion>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
        <AssemblyVersion>1.2.1.0</AssemblyVersion>
        <AssemblyVersion>1.2.2.0</AssemblyVersion>
        <AssemblyVersion>1.2.3.0</AssemblyVersion>
        <AssemblyVersion>1.2.4.0</AssemblyVersion>
        <AssemblyVersion>1.2.5.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
          </Constraints>
        </TypeParameter>
        <TypeParameter Name="TArg" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="location" Type="T" RefType="ref" />
        <Parameter Name="transformer" Type="System.Func&lt;T,TArg,T&gt;" />
        <Parameter Name="transformerArgument" Type="TArg" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="80baa-223">数据类型。</span><span class="sxs-lookup"><span data-stu-id="80baa-223">The type of data.</span></span></typeparam>
        <typeparam name="TArg"><span data-ttu-id="80baa-224">传递到的参数的类型 <paramref name="transformer" /> 。</span><span class="sxs-lookup"><span data-stu-id="80baa-224">The type of argument passed to the <paramref name="transformer" />.</span></span></typeparam>
        <param name="location"><span data-ttu-id="80baa-225">要更改的变量或字段，可通过多个线程进行访问。</span><span class="sxs-lookup"><span data-stu-id="80baa-225">The variable or field to be changed, which may be accessed by multiple threads.</span></span></param>
        <param name="transformer"><span data-ttu-id="80baa-226">可改变值的函数。</span><span class="sxs-lookup"><span data-stu-id="80baa-226">A function that mutates the value.</span></span> <span data-ttu-id="80baa-227">此函数应无任何副作用，因为在与其他线程发生争用时，该函数可能运行多次。</span><span class="sxs-lookup"><span data-stu-id="80baa-227">This function should be side-effect free,              as it may run multiple times when races occur with other threads.</span></span></param>
        <param name="transformerArgument"><span data-ttu-id="80baa-228">要传递给 <paramref name="transformer" /> 的参数。</span><span class="sxs-lookup"><span data-stu-id="80baa-228">The argument to pass to <paramref name="transformer" />.</span></span></param>
        <summary><span data-ttu-id="80baa-229">通过指定转换函数使用乐观锁定事务语义就地改变值。</span><span class="sxs-lookup"><span data-stu-id="80baa-229">Mutates a value in-place with optimistic locking transaction semantics             via a specified transformation function.</span></span>             <span data-ttu-id="80baa-230">可根据需要多次重试转换，以赢取乐观锁定争用。</span><span class="sxs-lookup"><span data-stu-id="80baa-230">The transformation is retried as many times as necessary to win the optimistic locking race.</span></span></summary>
        <returns><span data-ttu-id="80baa-231">如果位置值是通过应用 <paramref name="transformer" /> 函数的结果而更改，则为 <see langword="true" />；如果位置值因上次调用 <paramref name="transformer" /> 返回的现有值而保持不变，则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="80baa-231"><see langword="true" /> if the location's value is changed by applying the result of the <paramref name="transformer" /> function; <see langword="false" /> if the location's value remained the same because the last invocation of <paramref name="transformer" /> returned the existing value.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
