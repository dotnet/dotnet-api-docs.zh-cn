<Type Name="IComSoapPublisher" FullName="System.EnterpriseServices.Internal.IComSoapPublisher">
  <Metadata><Meta Name="ms.openlocfilehash" Value="8ee31ae94ca771ae1f20d6c6ce78ba465b0c0fe1" /><Meta Name="ms.sourcegitcommit" Value="b53d35b4a410c949742abd4c6a989d1af5357bca" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-CN" /><Meta Name="ms.lasthandoff" Value="07/21/2020" /><Meta Name="ms.locfileid" Value="86818236" /></Metadata><TypeSignature Language="C#" Value="public interface IComSoapPublisher" />
  <TypeSignature Language="ILAsm" Value=".class public interface auto ansi abstract IComSoapPublisher" />
  <TypeSignature Language="DocId" Value="T:System.EnterpriseServices.Internal.IComSoapPublisher" />
  <TypeSignature Language="VB.NET" Value="Public Interface IComSoapPublisher" />
  <TypeSignature Language="C++ CLI" Value="public interface class IComSoapPublisher" />
  <TypeSignature Language="F#" Value="type IComSoapPublisher = interface" />
  <AssemblyInfo>
    <AssemblyName>System.EnterpriseServices</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName Language="C#">[System.Runtime.InteropServices.Guid("d8013eee-730b-45e2-ba24-874b7242c425")]</AttributeName>
      <AttributeName Language="F#">[&lt;System.Runtime.InteropServices.Guid("d8013eee-730b-45e2-ba24-874b7242c425")&gt;]</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>为启用 SOAP 的 COM+ 应用程序发布 COM 接口。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 的实现 <xref:System.EnterpriseServices.Internal.IComSoapPublisher> 是 <xref:System.EnterpriseServices.Internal.Publish> ; 有关详细信息，请参阅该主题。  
  
 <xref:System.EnterpriseServices.Internal.IComSoapPublisher>由 .NET Framework 在内部使用。 不需要直接在代码中使用它。  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="CreateMailBox">
      <MemberSignature Language="C#" Value="public void CreateMailBox (string RootMailServer, string MailBox, out string SmtpName, out string Domain, out string PhysicalPath, out string Error);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void CreateMailBox(string RootMailServer, string MailBox, [out] string&amp; SmtpName, [out] string&amp; Domain, [out] string&amp; PhysicalPath, [out] string&amp; Error) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.EnterpriseServices.Internal.IComSoapPublisher.CreateMailBox(System.String,System.String,System.String@,System.String@,System.String@,System.String@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CreateMailBox (RootMailServer As String, MailBox As String, ByRef SmtpName As String, ByRef Domain As String, ByRef PhysicalPath As String, ByRef Error As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CreateMailBox(System::String ^ RootMailServer, System::String ^ MailBox, [Runtime::InteropServices::Out] System::String ^ % SmtpName, [Runtime::InteropServices::Out] System::String ^ % Domain, [Runtime::InteropServices::Out] System::String ^ % PhysicalPath, [Runtime::InteropServices::Out] System::String ^ % Error);" />
      <MemberSignature Language="F#" Value="abstract member CreateMailBox : string * string * string * string * string * string -&gt; unit" Usage="iComSoapPublisher.CreateMailBox (RootMailServer, MailBox, SmtpName, Domain, PhysicalPath, Error)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.EnterpriseServices</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.InteropServices.DispId(6)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.InteropServices.DispId(6)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="RootMailServer" Type="System.String" />
        <Parameter Name="MailBox" Type="System.String" />
        <Parameter Name="SmtpName" Type="System.String" RefType="out" />
        <Parameter Name="Domain" Type="System.String" RefType="out" />
        <Parameter Name="PhysicalPath" Type="System.String" RefType="out" />
        <Parameter Name="Error" Type="System.String" RefType="out" />
      </Parameters>
      <Docs>
        <param name="RootMailServer">根邮件服务器的 URL。</param>
        <param name="MailBox">要创建的邮箱。</param>
        <param name="SmtpName">此方法返回时，此参数包含该邮箱所在的简单邮件传输协议 (SMTP) 服务器的名称。</param>
        <param name="Domain">此方法返回时，此参数包含 SMTP 服务器的域。</param>
        <param name="PhysicalPath">此方法返回时，此参数包含邮箱的文件系统路径。</param>
        <param name="Error">此方法返回时，此参数包含错误信息（如果遇到了问题）。</param>
        <summary>在指定的 URL 处，创建启用 SOAP 的 COM+ 应用程序邮箱。 没有完全实现。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 未完全实现;当前不创建邮箱。 返回错误消息 "不支持 COM + SOAP 服务 SMTP 发布。"  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">调用链中的调用方无权访问非托管代码。</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateVirtualRoot">
      <MemberSignature Language="C#" Value="public void CreateVirtualRoot (string Operation, string FullUrl, out string BaseUrl, out string VirtualRoot, out string PhysicalPath, out string Error);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void CreateVirtualRoot(string Operation, string FullUrl, [out] string&amp; BaseUrl, [out] string&amp; VirtualRoot, [out] string&amp; PhysicalPath, [out] string&amp; Error) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.EnterpriseServices.Internal.IComSoapPublisher.CreateVirtualRoot(System.String,System.String,System.String@,System.String@,System.String@,System.String@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CreateVirtualRoot (Operation As String, FullUrl As String, ByRef BaseUrl As String, ByRef VirtualRoot As String, ByRef PhysicalPath As String, ByRef Error As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CreateVirtualRoot(System::String ^ Operation, System::String ^ FullUrl, [Runtime::InteropServices::Out] System::String ^ % BaseUrl, [Runtime::InteropServices::Out] System::String ^ % VirtualRoot, [Runtime::InteropServices::Out] System::String ^ % PhysicalPath, [Runtime::InteropServices::Out] System::String ^ % Error);" />
      <MemberSignature Language="F#" Value="abstract member CreateVirtualRoot : string * string * string * string * string * string -&gt; unit" Usage="iComSoapPublisher.CreateVirtualRoot (Operation, FullUrl, BaseUrl, VirtualRoot, PhysicalPath, Error)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.EnterpriseServices</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.InteropServices.DispId(4)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.InteropServices.DispId(4)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Operation" Type="System.String" />
        <Parameter Name="FullUrl" Type="System.String" />
        <Parameter Name="BaseUrl" Type="System.String" RefType="out" />
        <Parameter Name="VirtualRoot" Type="System.String" RefType="out" />
        <Parameter Name="PhysicalPath" Type="System.String" RefType="out" />
        <Parameter Name="Error" Type="System.String" RefType="out" />
      </Parameters>
      <Docs>
        <param name="Operation">要执行的操作。</param>
        <param name="FullUrl">虚拟根目录的完整 URL 地址。</param>
        <param name="BaseUrl">此方法返回时，此参数包含基 URL 地址。</param>
        <param name="VirtualRoot">此方法返回时，此参数包含虚拟根目录的名称。</param>
        <param name="PhysicalPath">此方法返回时，此参数包含虚拟根目录的文件路径。</param>
        <param name="Error">此方法返回时，此参数包含错误信息（如果遇到了问题）。</param>
        <summary>创建启用 SOAP 的 COM+ 应用程序虚拟根目录。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 建议 <xref:System.EnterpriseServices.Internal.ISoapServerVRoot.CreateVirtualRootEx%2A> 使用而不是 <xref:System.EnterpriseServices.Internal.IComSoapPublisher.CreateVirtualRoot%2A> 。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">调用链中的调用方无权访问非托管代码。  
  
 -或-  
  
 调用方没有访问域名系统 (DNS) 信息的权限。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="FullUrl" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">解析本地主机名时遇到错误。</exception>
        <exception cref="T:System.UriFormatException"><paramref name="FullUrl" /> 为空。  
  
- 或 - 
<paramref name="FullUrl" /> 中指定的方案无效。  
  
-或- 
 <paramref name="FullUrl" /> 包含两个以上的连续斜杠。  
  
-或- 
<paramref name="FullUrl" /> 中指定的密码无效。  
  
-或- 
<paramref name="FullUrl" /> 中指定的主机名无效。  
  
-或- 
<paramref name="FullUrl" /> 中指定的文件名无效。</exception>
      </Docs>
    </Member>
    <Member MemberName="DeleteMailBox">
      <MemberSignature Language="C#" Value="public void DeleteMailBox (string RootMailServer, string MailBox, out string Error);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void DeleteMailBox(string RootMailServer, string MailBox, [out] string&amp; Error) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.EnterpriseServices.Internal.IComSoapPublisher.DeleteMailBox(System.String,System.String,System.String@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DeleteMailBox (RootMailServer As String, MailBox As String, ByRef Error As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DeleteMailBox(System::String ^ RootMailServer, System::String ^ MailBox, [Runtime::InteropServices::Out] System::String ^ % Error);" />
      <MemberSignature Language="F#" Value="abstract member DeleteMailBox : string * string * string -&gt; unit" Usage="iComSoapPublisher.DeleteMailBox (RootMailServer, MailBox, Error)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.EnterpriseServices</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.InteropServices.DispId(7)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.InteropServices.DispId(7)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="RootMailServer" Type="System.String" />
        <Parameter Name="MailBox" Type="System.String" />
        <Parameter Name="Error" Type="System.String" RefType="out" />
      </Parameters>
      <Docs>
        <param name="RootMailServer">根邮件服务器的 URL。</param>
        <param name="MailBox">要删除的邮箱。</param>
        <param name="Error">此方法返回时，此参数包含错误信息（如果遇到了问题）。</param>
        <summary>删除指定 URL 上启用 SOAP 的 COM+ 应用程序邮箱。 没有完全实现。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 未完全实现;不会删除邮箱。 返回错误消息 "不支持 COM + SOAP 服务 SMTP 发布。"  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">调用链中的调用方无权访问非托管代码。</exception>
      </Docs>
    </Member>
    <Member MemberName="DeleteVirtualRoot">
      <MemberSignature Language="C#" Value="public void DeleteVirtualRoot (string RootWebServer, string FullUrl, out string Error);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void DeleteVirtualRoot(string RootWebServer, string FullUrl, [out] string&amp; Error) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.EnterpriseServices.Internal.IComSoapPublisher.DeleteVirtualRoot(System.String,System.String,System.String@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DeleteVirtualRoot (RootWebServer As String, FullUrl As String, ByRef Error As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DeleteVirtualRoot(System::String ^ RootWebServer, System::String ^ FullUrl, [Runtime::InteropServices::Out] System::String ^ % Error);" />
      <MemberSignature Language="F#" Value="abstract member DeleteVirtualRoot : string * string * string -&gt; unit" Usage="iComSoapPublisher.DeleteVirtualRoot (RootWebServer, FullUrl, Error)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.EnterpriseServices</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.InteropServices.DispId(5)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.InteropServices.DispId(5)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="RootWebServer" Type="System.String" />
        <Parameter Name="FullUrl" Type="System.String" />
        <Parameter Name="Error" Type="System.String" RefType="out" />
      </Parameters>
      <Docs>
        <param name="RootWebServer">根 Web 服务器。</param>
        <param name="FullUrl">虚拟根目录的完整 URL 地址。</param>
        <param name="Error">此方法返回时，此参数包含错误信息（如果遇到了问题）。</param>
        <summary>删除启用 SOAP 的 COM+ 应用程序虚拟根目录。 没有完全实现。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 的功能 <xref:System.EnterpriseServices.Internal.Publish.DeleteVirtualRoot%2A> 尚不可用。  
  
> [!CAUTION]
>  此方法当前返回错误，但未删除虚拟根目录。  
  
 当功能可用时，推荐的方法是 <xref:System.EnterpriseServices.Internal.SoapServerVRoot.DeleteVirtualRootEx%2A> 。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">调用链中的调用方无权访问非托管代码。</exception>
      </Docs>
    </Member>
    <Member MemberName="GacInstall">
      <MemberSignature Language="C#" Value="public void GacInstall (string AssemblyPath);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GacInstall(string AssemblyPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.EnterpriseServices.Internal.IComSoapPublisher.GacInstall(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub GacInstall (AssemblyPath As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void GacInstall(System::String ^ AssemblyPath);" />
      <MemberSignature Language="F#" Value="abstract member GacInstall : string -&gt; unit" Usage="iComSoapPublisher.GacInstall AssemblyPath" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.EnterpriseServices</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.InteropServices.DispId(13)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.InteropServices.DispId(13)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="AssemblyPath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="AssemblyPath">程序集的文件系统路径。</param>
        <summary>将程序集安装在全局程序集缓存中。</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Security.SecurityException">调用链中的调用方无权访问非托管代码。</exception>
      </Docs>
    </Member>
    <Member MemberName="GacRemove">
      <MemberSignature Language="C#" Value="public void GacRemove (string AssemblyPath);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GacRemove(string AssemblyPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.EnterpriseServices.Internal.IComSoapPublisher.GacRemove(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub GacRemove (AssemblyPath As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void GacRemove(System::String ^ AssemblyPath);" />
      <MemberSignature Language="F#" Value="abstract member GacRemove : string -&gt; unit" Usage="iComSoapPublisher.GacRemove AssemblyPath" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.EnterpriseServices</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.InteropServices.DispId(14)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.InteropServices.DispId(14)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="AssemblyPath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="AssemblyPath">程序集的文件系统路径。</param>
        <summary>从全局程序集缓存中移除程序集。</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="AssemblyPath" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="AssemblyPath" /> 为空。</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="AssemblyPath" /> 未找到。</exception>
        <exception cref="T:System.IO.FileLoadException">一个程序集或模块用两个不同的证据加载了两次。</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="AssemblyPath" /> 不是有效的程序集。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetAssemblyNameForCache">
      <MemberSignature Language="C#" Value="public void GetAssemblyNameForCache (string TypeLibPath, out string CachePath);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GetAssemblyNameForCache(string TypeLibPath, [out] string&amp; CachePath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.EnterpriseServices.Internal.IComSoapPublisher.GetAssemblyNameForCache(System.String,System.String@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub GetAssemblyNameForCache (TypeLibPath As String, ByRef CachePath As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void GetAssemblyNameForCache(System::String ^ TypeLibPath, [Runtime::InteropServices::Out] System::String ^ % CachePath);" />
      <MemberSignature Language="F#" Value="abstract member GetAssemblyNameForCache : string * string -&gt; unit" Usage="iComSoapPublisher.GetAssemblyNameForCache (TypeLibPath, CachePath)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.EnterpriseServices</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.InteropServices.DispId(15)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.InteropServices.DispId(15)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="TypeLibPath" Type="System.String" />
        <Parameter Name="CachePath" Type="System.String" RefType="out" />
      </Parameters>
      <Docs>
        <param name="TypeLibPath">包含类型库的文件的路径。</param>
        <param name="CachePath">此方法返回时，此参数包含 SoapCache 目录中的代理程序集的完整路径。</param>
        <summary>返回 SoapCache 目录中生成的强名称签名程序集的完整路径。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 对于要通过 .NET 远程处理作为 SOAP 终结点发布的非托管 COM + 组件，需要生成代理以使非托管组件可用于 .NET Framework。 这是通过以编程方式执行与类型库导入程序相同的步骤来实现 ( # A0) ，这是用于将非托管 COM + 类型库转换为代理元数据程序集的 Windows SDK 工具。 但是，若要使通过 SOAP 的客户端激活成功，客户端和服务器计算机必须共享相同的强名称签名元数据代理。 出于此原因，为非托管 COM + 组件生成了托管代理程序集时，还会生成一个强名称密钥并用于对代理程序集进行签名。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="TypeLibPath" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.Security.SecurityException">调用方没有所要求的权限。</exception>
        <exception cref="T:System.ArgumentException">文件名为空，仅包含空格，或包含无效字符。</exception>
        <exception cref="T:System.UnauthorizedAccessException">拒绝访问 <paramref name="TypeLibPath" />。</exception>
        <exception cref="T:System.IO.PathTooLongException">指定的路径和/或文件名超过了系统定义的最大长度。</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="TypeLibPath" /> 在字符串中间包含一个冒号 (:)。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetTypeNameFromProgId">
      <MemberSignature Language="C#" Value="public string GetTypeNameFromProgId (string AssemblyPath, string ProgId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string GetTypeNameFromProgId(string AssemblyPath, string ProgId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.EnterpriseServices.Internal.IComSoapPublisher.GetTypeNameFromProgId(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetTypeNameFromProgId (AssemblyPath As String, ProgId As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetTypeNameFromProgId(System::String ^ AssemblyPath, System::String ^ ProgId);" />
      <MemberSignature Language="F#" Value="abstract member GetTypeNameFromProgId : string * string -&gt; string" Usage="iComSoapPublisher.GetTypeNameFromProgId (AssemblyPath, ProgId)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.EnterpriseServices</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.InteropServices.DispId(10)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.InteropServices.DispId(10)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="AssemblyPath" Type="System.String" />
        <Parameter Name="ProgId" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="AssemblyPath">程序集的文件系统路径。</param>
        <param name="ProgId">类的编程标识符。</param>
        <summary>在程序集上反射，并返回与 ProgID 匹配的类型名。</summary>
        <returns>与 ProgID 匹配的类型名。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Security.SecurityException">调用链中的调用方无权访问非托管代码。</exception>
      </Docs>
    </Member>
    <Member MemberName="ProcessClientTlb">
      <MemberSignature Language="C#" Value="public void ProcessClientTlb (string ProgId, string SrcTlbPath, string PhysicalPath, string VRoot, string BaseUrl, string Mode, string Transport, out string AssemblyName, out string TypeName, out string Error);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ProcessClientTlb(string ProgId, string SrcTlbPath, string PhysicalPath, string VRoot, string BaseUrl, string Mode, string Transport, [out] string&amp; AssemblyName, [out] string&amp; TypeName, [out] string&amp; Error) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.EnterpriseServices.Internal.IComSoapPublisher.ProcessClientTlb(System.String,System.String,System.String,System.String,System.String,System.String,System.String,System.String@,System.String@,System.String@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ProcessClientTlb (ProgId As String, SrcTlbPath As String, PhysicalPath As String, VRoot As String, BaseUrl As String, Mode As String, Transport As String, ByRef AssemblyName As String, ByRef TypeName As String, ByRef Error As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ProcessClientTlb(System::String ^ ProgId, System::String ^ SrcTlbPath, System::String ^ PhysicalPath, System::String ^ VRoot, System::String ^ BaseUrl, System::String ^ Mode, System::String ^ Transport, [Runtime::InteropServices::Out] System::String ^ % AssemblyName, [Runtime::InteropServices::Out] System::String ^ % TypeName, [Runtime::InteropServices::Out] System::String ^ % Error);" />
      <MemberSignature Language="F#" Value="abstract member ProcessClientTlb : string * string * string * string * string * string * string * string * string * string -&gt; unit" Usage="iComSoapPublisher.ProcessClientTlb (ProgId, SrcTlbPath, PhysicalPath, VRoot, BaseUrl, Mode, Transport, AssemblyName, TypeName, Error)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.EnterpriseServices</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.InteropServices.DispId(9)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.InteropServices.DispId(9)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ProgId" Type="System.String" />
        <Parameter Name="SrcTlbPath" Type="System.String" />
        <Parameter Name="PhysicalPath" Type="System.String" />
        <Parameter Name="VRoot" Type="System.String" />
        <Parameter Name="BaseUrl" Type="System.String" />
        <Parameter Name="Mode" Type="System.String" />
        <Parameter Name="Transport" Type="System.String" />
        <Parameter Name="AssemblyName" Type="System.String" RefType="out" />
        <Parameter Name="TypeName" Type="System.String" RefType="out" />
        <Parameter Name="Error" Type="System.String" RefType="out" />
      </Parameters>
      <Docs>
        <param name="ProgId">类的编程标识符。</param>
        <param name="SrcTlbPath">包含类型库的文件的路径。</param>
        <param name="PhysicalPath">Web 应用程序目录。</param>
        <param name="VRoot">虚拟根目录的名称。</param>
        <param name="BaseUrl">包含虚拟根目录的基 URL。</param>
        <param name="Mode">激活模式。</param>
        <param name="Transport">未使用。 为此参数指定 <see langword="null" />。</param>
        <param name="AssemblyName">此方法返回时，此参数包含程序集的显示名称。</param>
        <param name="TypeName">此方法返回时，此参数包含程序集的完全限定类型名称。</param>
        <param name="Error">此方法返回时，此参数包含错误信息（如果遇到了问题）。</param>
        <summary>处理客户端类型库，在客户端上创建配置文件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法用于客户端代理导入，以生成远程处理配置文件。  
  
 在实现中，如果 `Mode` 参数为 "wellknownobject" 或空字符串 ( "" ) ，则假定为已知对象; 否则，将采用客户端激活。  
  
 建议 <xref:System.EnterpriseServices.Internal.ISoapClientImport.ProcessClientTlbEx%2A> 使用而不是 <xref:System.EnterpriseServices.Internal.IComSoapPublisher.ProcessClientTlb%2A> 。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">调用链中的调用方无权访问非托管代码。</exception>
      </Docs>
    </Member>
    <Member MemberName="ProcessServerTlb">
      <MemberSignature Language="C#" Value="public void ProcessServerTlb (string ProgId, string SrcTlbPath, string PhysicalPath, string Operation, out string AssemblyName, out string TypeName, out string Error);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ProcessServerTlb(string ProgId, string SrcTlbPath, string PhysicalPath, string Operation, [out] string&amp; AssemblyName, [out] string&amp; TypeName, [out] string&amp; Error) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.EnterpriseServices.Internal.IComSoapPublisher.ProcessServerTlb(System.String,System.String,System.String,System.String,System.String@,System.String@,System.String@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ProcessServerTlb (ProgId As String, SrcTlbPath As String, PhysicalPath As String, Operation As String, ByRef AssemblyName As String, ByRef TypeName As String, ByRef Error As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ProcessServerTlb(System::String ^ ProgId, System::String ^ SrcTlbPath, System::String ^ PhysicalPath, System::String ^ Operation, [Runtime::InteropServices::Out] System::String ^ % AssemblyName, [Runtime::InteropServices::Out] System::String ^ % TypeName, [Runtime::InteropServices::Out] System::String ^ % Error);" />
      <MemberSignature Language="F#" Value="abstract member ProcessServerTlb : string * string * string * string * string * string * string -&gt; unit" Usage="iComSoapPublisher.ProcessServerTlb (ProgId, SrcTlbPath, PhysicalPath, Operation, AssemblyName, TypeName, Error)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.EnterpriseServices</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.InteropServices.DispId(8)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.InteropServices.DispId(8)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ProgId" Type="System.String" />
        <Parameter Name="SrcTlbPath" Type="System.String" />
        <Parameter Name="PhysicalPath" Type="System.String" />
        <Parameter Name="Operation" Type="System.String" />
        <Parameter Name="AssemblyName" Type="System.String" RefType="out" />
        <Parameter Name="TypeName" Type="System.String" RefType="out" />
        <Parameter Name="Error" Type="System.String" RefType="out" />
      </Parameters>
      <Docs>
        <param name="ProgId">类的编程标识符。</param>
        <param name="SrcTlbPath">包含类型库的文件的路径。</param>
        <param name="PhysicalPath">Web 应用程序目录。</param>
        <param name="Operation">要执行的操作。</param>
        <param name="AssemblyName">此方法返回时，此参数包含程序集的显示名称。</param>
        <param name="TypeName">此方法返回时，此参数包含程序集的完全限定类型名称。</param>
        <param name="Error">此方法返回时，此参数包含错误信息（如果遇到了问题）。</param>
        <summary>处理服务器类型库，从而向 Web.config 和 Default.disco 文件中添加或删除组件项。 必要时生成代理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 生成 COM + 组件的 Web.config 和默认 .disco 文件项。 必要时生成代理。  
  
 建议 <xref:System.EnterpriseServices.Internal.ISoapServerTlb.AddServerTlb%2A> <xref:System.EnterpriseServices.Internal.ISoapServerTlb.DeleteServerTlb%2A> 使用，而不是 <xref:System.EnterpriseServices.Internal.IComSoapPublisher.ProcessServerTlb%2A> 。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">调用链中的调用方无权访问非托管代码。</exception>
        <exception cref="T:System.EnterpriseServices.ServicedComponentException"><paramref name="SrcTlbPath" /> 参数引用了 scrobj.dll；因此，不支持通过 SOAP 发布脚本组件。</exception>
      </Docs>
    </Member>
    <Member MemberName="RegisterAssembly">
      <MemberSignature Language="C#" Value="public void RegisterAssembly (string AssemblyPath);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RegisterAssembly(string AssemblyPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.EnterpriseServices.Internal.IComSoapPublisher.RegisterAssembly(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterAssembly (AssemblyPath As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterAssembly(System::String ^ AssemblyPath);" />
      <MemberSignature Language="F#" Value="abstract member RegisterAssembly : string -&gt; unit" Usage="iComSoapPublisher.RegisterAssembly AssemblyPath" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.EnterpriseServices</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.InteropServices.DispId(11)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.InteropServices.DispId(11)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="AssemblyPath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="AssemblyPath">程序集的文件系统路径。</param>
        <summary>为 COM 互操作注册程序集。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 的实现 <xref:System.EnterpriseServices.Internal.IComSoapPublisher.RegisterAssembly%2A> 使用程序集注册工具 ( # A0) 来注册程序集中的可创建类。 有关详细信息，请参阅[)Regasm.exe (程序集注册工具](/dotnet/framework/tools/regasm-exe-assembly-registration-tool)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.EnterpriseServices.RegistrationException">输入程序集没有强名称。</exception>
        <exception cref="T:System.Security.SecurityException">调用链中的调用方无权访问非托管代码。  
  
-或- 
指定了不以“file://”开头的基本代码，且没有所需的 <see cref="T:System.Net.WebPermission" />。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="AssemblyPath" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.IO.FileNotFoundException">找不到 <paramref name="AssemblyPath" /> 或者未指定文件扩展名。</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="AssemblyPath" /> 不是有效的程序集。</exception>
        <exception cref="T:System.IO.FileLoadException">用两个不同的证据将一个程序集或模块加载了两次，或程序集名称超过系统指定的最大长度。</exception>
        <exception cref="T:System.InvalidOperationException">使用 <see cref="T:System.Runtime.InteropServices.ComUnregisterFunctionAttribute" /> 标记的方法不是 <see langword="static" /> 方法。  
  
-或- 
在层次结构的给定级别有多个用 <see cref="T:System.Runtime.InteropServices.ComUnregisterFunctionAttribute" /> 标记的方法。  
  
-或- 
用 <see cref="T:System.Runtime.InteropServices.ComUnregisterFunctionAttribute" /> 标记的方法的签名无效。</exception>
      </Docs>
    </Member>
    <Member MemberName="UnRegisterAssembly">
      <MemberSignature Language="C#" Value="public void UnRegisterAssembly (string AssemblyPath);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void UnRegisterAssembly(string AssemblyPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.EnterpriseServices.Internal.IComSoapPublisher.UnRegisterAssembly(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub UnRegisterAssembly (AssemblyPath As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void UnRegisterAssembly(System::String ^ AssemblyPath);" />
      <MemberSignature Language="F#" Value="abstract member UnRegisterAssembly : string -&gt; unit" Usage="iComSoapPublisher.UnRegisterAssembly AssemblyPath" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.EnterpriseServices</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.InteropServices.DispId(12)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.InteropServices.DispId(12)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="AssemblyPath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="AssemblyPath">程序集的文件系统路径。</param>
        <summary>注销 COM 互操作程序集。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 的实现 <xref:System.EnterpriseServices.Internal.IComSoapPublisher.UnRegisterAssembly%2A> 使用 Regasm.exe 取消注册程序集中的可创建类。 有关详细信息，请参阅[)Regasm.exe (程序集注册工具](/dotnet/framework/tools/regasm-exe-assembly-registration-tool)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">调用链中的调用方无权访问非托管代码。  
  
-或- 
指定了不以“file://”开头的基本代码，且没有所需的 <see cref="T:System.Net.WebPermission" />。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="AssemblyPath" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.IO.FileNotFoundException">找不到 <paramref name="AssemblyPath" /> 或者未指定文件扩展名。</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="AssemblyPath" /> 不是有效的程序集。</exception>
        <exception cref="T:System.IO.FileLoadException">用两个不同的证据将一个程序集或模块加载了两次，或程序集名称超过系统指定的最大长度。</exception>
        <exception cref="T:System.InvalidOperationException">使用 <see cref="T:System.Runtime.InteropServices.ComUnregisterFunctionAttribute" /> 标记的方法不是 <see langword="static" /> 方法。  
  
-或- 
在层次结构的给定级别有多个用 <see cref="T:System.Runtime.InteropServices.ComUnregisterFunctionAttribute" /> 标记的方法。  
  
-或- 
用 <see cref="T:System.Runtime.InteropServices.ComUnregisterFunctionAttribute" /> 标记的方法的签名无效。</exception>
      </Docs>
    </Member>
  </Members>
</Type>
