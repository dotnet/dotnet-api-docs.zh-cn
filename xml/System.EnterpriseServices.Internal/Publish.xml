<Type Name="Publish" FullName="System.EnterpriseServices.Internal.Publish">
  <Metadata><Meta Name="ms.openlocfilehash" Value="564c5e5ca00bb788f2cb416599b445a21df987bd" /><Meta Name="ms.sourcegitcommit" Value="b53d35b4a410c949742abd4c6a989d1af5357bca" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-CN" /><Meta Name="ms.lasthandoff" Value="07/21/2020" /><Meta Name="ms.locfileid" Value="86818136" /></Metadata><TypeSignature Language="C#" Value="public class Publish : System.EnterpriseServices.Internal.IComSoapPublisher" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit Publish extends System.Object implements class System.EnterpriseServices.Internal.IComSoapPublisher" />
  <TypeSignature Language="DocId" Value="T:System.EnterpriseServices.Internal.Publish" />
  <TypeSignature Language="VB.NET" Value="Public Class Publish&#xA;Implements IComSoapPublisher" />
  <TypeSignature Language="C++ CLI" Value="public ref class Publish : System::EnterpriseServices::Internal::IComSoapPublisher" />
  <TypeSignature Language="F#" Value="type Publish = class&#xA;    interface IComSoapPublisher" />
  <AssemblyInfo>
    <AssemblyName>System.EnterpriseServices</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.EnterpriseServices.Internal.IComSoapPublisher</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName Language="C#">[System.Runtime.InteropServices.Guid("d8013eef-730b-45e2-ba24-874b7242c425")]</AttributeName>
      <AttributeName Language="F#">[&lt;System.Runtime.InteropServices.Guid("d8013eef-730b-45e2-ba24-874b7242c425")&gt;]</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>为启用 SOAP 的 COM+ 应用程序发布 COM 接口。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.EnterpriseServices.Internal.Publish> 由 .NET Framework 在内部使用。 不需要直接在代码中使用它。  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Publish ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.EnterpriseServices.Internal.Publish.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Publish();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.EnterpriseServices</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>初始化 <see cref="T:System.EnterpriseServices.Internal.Publish" /> 类的新实例。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateMailBox">
      <MemberSignature Language="C#" Value="public void CreateMailBox (string RootMailServer, string MailBox, out string SmtpName, out string Domain, out string PhysicalPath, out string Error);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void CreateMailBox(string RootMailServer, string MailBox, [out] string&amp; SmtpName, [out] string&amp; Domain, [out] string&amp; PhysicalPath, [out] string&amp; Error) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.EnterpriseServices.Internal.Publish.CreateMailBox(System.String,System.String,System.String@,System.String@,System.String@,System.String@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CreateMailBox (RootMailServer As String, MailBox As String, ByRef SmtpName As String, ByRef Domain As String, ByRef PhysicalPath As String, ByRef Error As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void CreateMailBox(System::String ^ RootMailServer, System::String ^ MailBox, [Runtime::InteropServices::Out] System::String ^ % SmtpName, [Runtime::InteropServices::Out] System::String ^ % Domain, [Runtime::InteropServices::Out] System::String ^ % PhysicalPath, [Runtime::InteropServices::Out] System::String ^ % Error);" />
      <MemberSignature Language="F#" Value="abstract member CreateMailBox : string * string * string * string * string * string -&gt; unit&#xA;override this.CreateMailBox : string * string * string * string * string * string -&gt; unit" Usage="publish.CreateMailBox (RootMailServer, MailBox, SmtpName, Domain, PhysicalPath, Error)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.EnterpriseServices.Internal.IComSoapPublisher.CreateMailBox(System.String,System.String,System.String@,System.String@,System.String@,System.String@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.EnterpriseServices</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="RootMailServer" Type="System.String" />
        <Parameter Name="MailBox" Type="System.String" />
        <Parameter Name="SmtpName" Type="System.String" RefType="out" />
        <Parameter Name="Domain" Type="System.String" RefType="out" />
        <Parameter Name="PhysicalPath" Type="System.String" RefType="out" />
        <Parameter Name="Error" Type="System.String" RefType="out" />
      </Parameters>
      <Docs>
        <param name="RootMailServer">根邮件服务器的 URL。</param>
        <param name="MailBox">要创建的邮箱。</param>
        <param name="SmtpName">此方法返回时，此参数包含该邮箱所在的简单邮件传输协议 (SMTP) 服务器的名称。</param>
        <param name="Domain">此方法返回时，此参数包含 SMTP 服务器的域。</param>
        <param name="PhysicalPath">此方法返回时，此参数包含邮箱的文件系统路径。</param>
        <param name="Error">此方法返回时，此参数包含错误信息（如果遇到了问题）。</param>
        <summary>在指定的 URL 处，创建启用 SOAP 的 COM+ 应用程序邮箱。 没有完全实现。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 未完全实现;不创建邮箱。 返回错误消息 "不支持 COM + SOAP 服务 SMTP 发布。"  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">调用链中的调用方无权访问非托管代码。</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateVirtualRoot">
      <MemberSignature Language="C#" Value="public void CreateVirtualRoot (string Operation, string FullUrl, out string BaseUrl, out string VirtualRoot, out string PhysicalPath, out string Error);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void CreateVirtualRoot(string Operation, string FullUrl, [out] string&amp; BaseUrl, [out] string&amp; VirtualRoot, [out] string&amp; PhysicalPath, [out] string&amp; Error) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.EnterpriseServices.Internal.Publish.CreateVirtualRoot(System.String,System.String,System.String@,System.String@,System.String@,System.String@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CreateVirtualRoot (Operation As String, FullUrl As String, ByRef BaseUrl As String, ByRef VirtualRoot As String, ByRef PhysicalPath As String, ByRef Error As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void CreateVirtualRoot(System::String ^ Operation, System::String ^ FullUrl, [Runtime::InteropServices::Out] System::String ^ % BaseUrl, [Runtime::InteropServices::Out] System::String ^ % VirtualRoot, [Runtime::InteropServices::Out] System::String ^ % PhysicalPath, [Runtime::InteropServices::Out] System::String ^ % Error);" />
      <MemberSignature Language="F#" Value="abstract member CreateVirtualRoot : string * string * string * string * string * string -&gt; unit&#xA;override this.CreateVirtualRoot : string * string * string * string * string * string -&gt; unit" Usage="publish.CreateVirtualRoot (Operation, FullUrl, BaseUrl, VirtualRoot, PhysicalPath, Error)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.EnterpriseServices.Internal.IComSoapPublisher.CreateVirtualRoot(System.String,System.String,System.String@,System.String@,System.String@,System.String@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.EnterpriseServices</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Operation" Type="System.String" />
        <Parameter Name="FullUrl" Type="System.String" />
        <Parameter Name="BaseUrl" Type="System.String" RefType="out" />
        <Parameter Name="VirtualRoot" Type="System.String" RefType="out" />
        <Parameter Name="PhysicalPath" Type="System.String" RefType="out" />
        <Parameter Name="Error" Type="System.String" RefType="out" />
      </Parameters>
      <Docs>
        <param name="Operation">要执行的操作。</param>
        <param name="FullUrl">虚拟根目录的完整 URL 地址。</param>
        <param name="BaseUrl">此方法返回时，此参数包含基 URL 地址。</param>
        <param name="VirtualRoot">此方法返回时，此参数包含虚拟根目录的名称。</param>
        <param name="PhysicalPath">此方法返回时，此参数包含虚拟根目录的文件路径。</param>
        <param name="Error">此方法返回时，此参数包含错误信息（如果遇到了问题）。</param>
        <summary>创建启用 SOAP 的 COM+ 应用程序虚拟根目录。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 建议 <xref:System.EnterpriseServices.Internal.SoapServerVRoot.CreateVirtualRootEx%2A> 使用而不是 <xref:System.EnterpriseServices.Internal.Publish.CreateVirtualRoot%2A> 。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">调用链中的调用方无权访问非托管代码。  
  
 - 或 -  
  
 调用方没有访问 DNS 信息的权限。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="FullUrl" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">解析本地主机名时遇到错误。</exception>
        <exception cref="T:System.UriFormatException"><paramref name="FullUrl" /> 为空。  
  
- 或 - 
<paramref name="FullUrl" /> 中指定的方案无效。  
  
- 或 - 
 <paramref name="FullUrl" /> 包含两个以上的连续斜杠。  
  
- 或 - 
<paramref name="FullUrl" /> 中指定的密码无效。  
  
- 或 - 
<paramref name="FullUrl" /> 中指定的主机名无效。  
  
- 或 - 
<paramref name="FullUrl" /> 中指定的文件名无效。</exception>
      </Docs>
    </Member>
    <Member MemberName="DeleteMailBox">
      <MemberSignature Language="C#" Value="public void DeleteMailBox (string RootMailServer, string MailBox, out string Error);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void DeleteMailBox(string RootMailServer, string MailBox, [out] string&amp; Error) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.EnterpriseServices.Internal.Publish.DeleteMailBox(System.String,System.String,System.String@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DeleteMailBox (RootMailServer As String, MailBox As String, ByRef Error As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void DeleteMailBox(System::String ^ RootMailServer, System::String ^ MailBox, [Runtime::InteropServices::Out] System::String ^ % Error);" />
      <MemberSignature Language="F#" Value="abstract member DeleteMailBox : string * string * string -&gt; unit&#xA;override this.DeleteMailBox : string * string * string -&gt; unit" Usage="publish.DeleteMailBox (RootMailServer, MailBox, Error)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.EnterpriseServices.Internal.IComSoapPublisher.DeleteMailBox(System.String,System.String,System.String@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.EnterpriseServices</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="RootMailServer" Type="System.String" />
        <Parameter Name="MailBox" Type="System.String" />
        <Parameter Name="Error" Type="System.String" RefType="out" />
      </Parameters>
      <Docs>
        <param name="RootMailServer">根邮件服务器的 URL。</param>
        <param name="MailBox">要删除的邮箱。</param>
        <param name="Error">此方法返回时，此参数包含错误信息（如果遇到了问题）。</param>
        <summary>删除指定 URL 上启用 SOAP 的 COM+ 应用程序邮箱。 没有完全实现。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 未完全实现，不会删除邮箱。 返回错误消息 "不支持 COM + SOAP 服务 SMTP 发布。"  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">调用链中的调用方无权访问非托管代码。</exception>
      </Docs>
    </Member>
    <Member MemberName="DeleteVirtualRoot">
      <MemberSignature Language="C#" Value="public void DeleteVirtualRoot (string RootWebServer, string FullUrl, out string Error);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void DeleteVirtualRoot(string RootWebServer, string FullUrl, [out] string&amp; Error) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.EnterpriseServices.Internal.Publish.DeleteVirtualRoot(System.String,System.String,System.String@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DeleteVirtualRoot (RootWebServer As String, FullUrl As String, ByRef Error As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void DeleteVirtualRoot(System::String ^ RootWebServer, System::String ^ FullUrl, [Runtime::InteropServices::Out] System::String ^ % Error);" />
      <MemberSignature Language="F#" Value="abstract member DeleteVirtualRoot : string * string * string -&gt; unit&#xA;override this.DeleteVirtualRoot : string * string * string -&gt; unit" Usage="publish.DeleteVirtualRoot (RootWebServer, FullUrl, Error)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.EnterpriseServices.Internal.IComSoapPublisher.DeleteVirtualRoot(System.String,System.String,System.String@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.EnterpriseServices</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="RootWebServer" Type="System.String" />
        <Parameter Name="FullUrl" Type="System.String" />
        <Parameter Name="Error" Type="System.String" RefType="out" />
      </Parameters>
      <Docs>
        <param name="RootWebServer">根 Web 服务器。</param>
        <param name="FullUrl">虚拟根目录的完整 URL 地址。</param>
        <param name="Error">此方法返回时，此参数包含错误信息（如果遇到了问题）。</param>
        <summary>删除启用 SOAP 的 COM+ 应用程序虚拟根目录。 没有完全实现。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 的功能 <xref:System.EnterpriseServices.Internal.Publish.DeleteVirtualRoot%2A> 尚不可用。  
  
> [!CAUTION]
>  此方法当前返回错误，但未删除虚拟根目录。  
  
 当功能可用时，推荐的方法是 <xref:System.EnterpriseServices.Internal.SoapServerVRoot.DeleteVirtualRootEx%2A> 。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">调用链中的调用方无权访问非托管代码。</exception>
      </Docs>
    </Member>
    <Member MemberName="GacInstall">
      <MemberSignature Language="C#" Value="public void GacInstall (string AssemblyPath);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GacInstall(string AssemblyPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.EnterpriseServices.Internal.Publish.GacInstall(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub GacInstall (AssemblyPath As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void GacInstall(System::String ^ AssemblyPath);" />
      <MemberSignature Language="F#" Value="abstract member GacInstall : string -&gt; unit&#xA;override this.GacInstall : string -&gt; unit" Usage="publish.GacInstall AssemblyPath" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.EnterpriseServices.Internal.IComSoapPublisher.GacInstall(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.EnterpriseServices</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="AssemblyPath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="AssemblyPath">程序集的文件系统路径。</param>
        <summary>将程序集安装在全局程序集缓存中。</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Security.SecurityException">调用链中的调用方无权访问非托管代码。</exception>
      </Docs>
    </Member>
    <Member MemberName="GacRemove">
      <MemberSignature Language="C#" Value="public void GacRemove (string AssemblyPath);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GacRemove(string AssemblyPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.EnterpriseServices.Internal.Publish.GacRemove(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub GacRemove (AssemblyPath As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void GacRemove(System::String ^ AssemblyPath);" />
      <MemberSignature Language="F#" Value="abstract member GacRemove : string -&gt; unit&#xA;override this.GacRemove : string -&gt; unit" Usage="publish.GacRemove AssemblyPath" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.EnterpriseServices.Internal.IComSoapPublisher.GacRemove(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.EnterpriseServices</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="AssemblyPath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="AssemblyPath">程序集的文件系统路径。</param>
        <summary>从全局程序集缓存中移除程序集。</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Security.SecurityException">调用链中的调用方无权访问非托管代码。  
  
 - 或 -  
  
 调用方没有路径发现权限。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="AssemblyPath" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="AssemblyPath" /> 为空。</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="AssemblyPath" /> 未找到。</exception>
        <exception cref="T:System.IO.FileLoadException">一个程序集或模块用两个不同的证据加载了两次。</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="AssemblyPath" /> 不是有效的程序集。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetAssemblyNameForCache">
      <MemberSignature Language="C#" Value="public void GetAssemblyNameForCache (string TypeLibPath, out string CachePath);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GetAssemblyNameForCache(string TypeLibPath, [out] string&amp; CachePath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.EnterpriseServices.Internal.Publish.GetAssemblyNameForCache(System.String,System.String@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub GetAssemblyNameForCache (TypeLibPath As String, ByRef CachePath As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void GetAssemblyNameForCache(System::String ^ TypeLibPath, [Runtime::InteropServices::Out] System::String ^ % CachePath);" />
      <MemberSignature Language="F#" Value="abstract member GetAssemblyNameForCache : string * string -&gt; unit&#xA;override this.GetAssemblyNameForCache : string * string -&gt; unit" Usage="publish.GetAssemblyNameForCache (TypeLibPath, CachePath)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.EnterpriseServices.Internal.IComSoapPublisher.GetAssemblyNameForCache(System.String,System.String@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.EnterpriseServices</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="TypeLibPath" Type="System.String" />
        <Parameter Name="CachePath" Type="System.String" RefType="out" />
      </Parameters>
      <Docs>
        <param name="TypeLibPath">包含类型库的文件的路径。</param>
        <param name="CachePath">此方法返回时，此参数包含 SoapCache 目录的名称。</param>
        <summary>返回 SoapCache 目录中生成的强名称签名程序集的完整路径。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 对于要通过 .NET 远程处理作为 SOAP 终结点发布的非托管 COM + 组件，需要生成代理以使非托管组件可用于 .NET Framework。 这是通过以编程方式执行与类型库导入程序相同的步骤来实现 ( # A0) ，这是用于将非托管 COM + 类型库转换为代理元数据程序集的 Windows SDK 工具。 但是，若要使通过 SOAP 的客户端激活成功，客户端和服务器计算机必须共享相同的强名称签名元数据代理。 出于此原因，为非托管 COM + 组件生成了托管代理程序集时，还会生成一个强名称密钥并用于对代理程序集进行签名。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="TypeLibPath" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.Security.SecurityException">调用方没有所要求的权限。</exception>
        <exception cref="T:System.ArgumentException">文件名为空，仅包含空格，或包含无效字符。</exception>
        <exception cref="T:System.UnauthorizedAccessException">拒绝访问 <paramref name="TypeLibPath" />。</exception>
        <exception cref="T:System.IO.PathTooLongException">指定的路径和/或文件名超过了系统定义的最大长度。</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="TypeLibPath" /> 在字符串中间包含一个冒号 (:)。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetClientPhysicalPath">
      <MemberSignature Language="C#" Value="public static string GetClientPhysicalPath (bool CreateDir);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetClientPhysicalPath(bool CreateDir) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.EnterpriseServices.Internal.Publish.GetClientPhysicalPath(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetClientPhysicalPath (CreateDir As Boolean) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetClientPhysicalPath(bool CreateDir);" />
      <MemberSignature Language="F#" Value="static member GetClientPhysicalPath : bool -&gt; string" Usage="System.EnterpriseServices.Internal.Publish.GetClientPhysicalPath CreateDir" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.EnterpriseServices</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="CreateDir" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="CreateDir">如果要创建目录，应设置为 <see langword="true" />；如果只返回路径但不创建目录，则应设置为 <see langword="false" />。</param>
        <summary>返回存储客户端配置文件的目录的路径。</summary>
        <returns>包含配置文件的目录的路径。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 \\在系统目录下创建目录 "\com\SOAPAssembly"。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">调用方没有所要求的权限。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetTypeNameFromProgId">
      <MemberSignature Language="C#" Value="public string GetTypeNameFromProgId (string AssemblyPath, string ProgId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string GetTypeNameFromProgId(string AssemblyPath, string ProgId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.EnterpriseServices.Internal.Publish.GetTypeNameFromProgId(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetTypeNameFromProgId (AssemblyPath As String, ProgId As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ GetTypeNameFromProgId(System::String ^ AssemblyPath, System::String ^ ProgId);" />
      <MemberSignature Language="F#" Value="abstract member GetTypeNameFromProgId : string * string -&gt; string&#xA;override this.GetTypeNameFromProgId : string * string -&gt; string" Usage="publish.GetTypeNameFromProgId (AssemblyPath, ProgId)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.EnterpriseServices.Internal.IComSoapPublisher.GetTypeNameFromProgId(System.String,System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.EnterpriseServices</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="AssemblyPath" Type="System.String" />
        <Parameter Name="ProgId" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="AssemblyPath">程序集的文件系统路径。</param>
        <param name="ProgId">类的编程标识符。</param>
        <summary>在程序集上反射，并返回与 ProgID 匹配的类型名。</summary>
        <returns>与 ProgID 匹配的类型名。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Security.SecurityException">调用链中的调用方无权访问非托管代码。</exception>
      </Docs>
    </Member>
    <Member MemberName="ParseUrl">
      <MemberSignature Language="C#" Value="public static void ParseUrl (string FullUrl, out string BaseUrl, out string VirtualRoot);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ParseUrl(string FullUrl, [out] string&amp; BaseUrl, [out] string&amp; VirtualRoot) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.EnterpriseServices.Internal.Publish.ParseUrl(System.String,System.String@,System.String@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ParseUrl (FullUrl As String, ByRef BaseUrl As String, ByRef VirtualRoot As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ParseUrl(System::String ^ FullUrl, [Runtime::InteropServices::Out] System::String ^ % BaseUrl, [Runtime::InteropServices::Out] System::String ^ % VirtualRoot);" />
      <MemberSignature Language="F#" Value="static member ParseUrl : string * string * string -&gt; unit" Usage="System.EnterpriseServices.Internal.Publish.ParseUrl (FullUrl, BaseUrl, VirtualRoot)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.EnterpriseServices</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FullUrl" Type="System.String" />
        <Parameter Name="BaseUrl" Type="System.String" RefType="out" />
        <Parameter Name="VirtualRoot" Type="System.String" RefType="out" />
      </Parameters>
      <Docs>
        <param name="FullUrl">虚拟根目录的完整 URL 地址。</param>
        <param name="BaseUrl">此方法返回时，此参数包含基 URL 地址。</param>
        <param name="VirtualRoot">此方法返回时，此参数包含虚拟根目录的名称。</param>
        <summary>分析 URL 并返回基 URL 和虚拟根目录部分。</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="FullUrl" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">解析本地主机名时遇到错误。</exception>
        <exception cref="T:System.Security.SecurityException">调用方没有访问 DNS 信息的权限。</exception>
        <exception cref="T:System.UriFormatException"><paramref name="FullUrl" /> 为空。  
  
- 或 - 
<paramref name="FullUrl" /> 中指定的方案无效。  
  
- 或 - 
 <paramref name="FullUrl" /> 包含过多斜杠。  
  
- 或 - 
<paramref name="FullUrl" /> 中指定的密码无效。  
  
- 或 - 
<paramref name="FullUrl" /> 中指定的主机名无效。  
  
- 或 - 
<paramref name="FullUrl" /> 中指定的文件名无效。</exception>
      </Docs>
    </Member>
    <Member MemberName="ProcessClientTlb">
      <MemberSignature Language="C#" Value="public void ProcessClientTlb (string ProgId, string SrcTlbPath, string PhysicalPath, string VRoot, string BaseUrl, string Mode, string Transport, out string AssemblyName, out string TypeName, out string Error);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ProcessClientTlb(string ProgId, string SrcTlbPath, string PhysicalPath, string VRoot, string BaseUrl, string Mode, string Transport, [out] string&amp; AssemblyName, [out] string&amp; TypeName, [out] string&amp; Error) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.EnterpriseServices.Internal.Publish.ProcessClientTlb(System.String,System.String,System.String,System.String,System.String,System.String,System.String,System.String@,System.String@,System.String@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ProcessClientTlb (ProgId As String, SrcTlbPath As String, PhysicalPath As String, VRoot As String, BaseUrl As String, Mode As String, Transport As String, ByRef AssemblyName As String, ByRef TypeName As String, ByRef Error As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ProcessClientTlb(System::String ^ ProgId, System::String ^ SrcTlbPath, System::String ^ PhysicalPath, System::String ^ VRoot, System::String ^ BaseUrl, System::String ^ Mode, System::String ^ Transport, [Runtime::InteropServices::Out] System::String ^ % AssemblyName, [Runtime::InteropServices::Out] System::String ^ % TypeName, [Runtime::InteropServices::Out] System::String ^ % Error);" />
      <MemberSignature Language="F#" Value="abstract member ProcessClientTlb : string * string * string * string * string * string * string * string * string * string -&gt; unit&#xA;override this.ProcessClientTlb : string * string * string * string * string * string * string * string * string * string -&gt; unit" Usage="publish.ProcessClientTlb (ProgId, SrcTlbPath, PhysicalPath, VRoot, BaseUrl, Mode, Transport, AssemblyName, TypeName, Error)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.EnterpriseServices.Internal.IComSoapPublisher.ProcessClientTlb(System.String,System.String,System.String,System.String,System.String,System.String,System.String,System.String@,System.String@,System.String@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.EnterpriseServices</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ProgId" Type="System.String" />
        <Parameter Name="SrcTlbPath" Type="System.String" />
        <Parameter Name="PhysicalPath" Type="System.String" />
        <Parameter Name="VRoot" Type="System.String" />
        <Parameter Name="BaseUrl" Type="System.String" />
        <Parameter Name="Mode" Type="System.String" />
        <Parameter Name="Transport" Type="System.String" />
        <Parameter Name="AssemblyName" Type="System.String" RefType="out" />
        <Parameter Name="TypeName" Type="System.String" RefType="out" />
        <Parameter Name="Error" Type="System.String" RefType="out" />
      </Parameters>
      <Docs>
        <param name="ProgId">类的编程标识符。</param>
        <param name="SrcTlbPath">包含类型库的文件的路径。</param>
        <param name="PhysicalPath">Web 应用程序目录。</param>
        <param name="VRoot">虚拟根目录的名称。</param>
        <param name="BaseUrl">包含虚拟根目录的基 URL。</param>
        <param name="Mode">激活模式。</param>
        <param name="Transport">未使用。 为此参数指定 <see langword="null" />。</param>
        <param name="AssemblyName">此方法返回时，此参数包含程序集的显示名称。</param>
        <param name="TypeName">此方法返回时，此参数包含程序集的完全限定类型名称。</param>
        <param name="Error">此方法返回时，此参数包含错误信息（如果遇到了问题）。</param>
        <summary>处理客户端类型库，在客户端上创建配置文件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法用于客户端代理导入，以生成远程处理配置文件。  
  
 如果 `Mode` 参数为 "wellknownobject" 或空字符串 ( "" ) ，则假定为已知对象; 否则，将假定客户端激活。  
  
 建议 <xref:System.EnterpriseServices.Internal.SoapClientImport.ProcessClientTlbEx%2A> 使用而不是 <xref:System.EnterpriseServices.Internal.Publish.ProcessClientTlb%2A> 。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">调用链中的调用方无权访问非托管代码。</exception>
      </Docs>
    </Member>
    <Member MemberName="ProcessServerTlb">
      <MemberSignature Language="C#" Value="public void ProcessServerTlb (string ProgId, string SrcTlbPath, string PhysicalPath, string Operation, out string strAssemblyName, out string TypeName, out string Error);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ProcessServerTlb(string ProgId, string SrcTlbPath, string PhysicalPath, string Operation, [out] string&amp; strAssemblyName, [out] string&amp; TypeName, [out] string&amp; Error) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.EnterpriseServices.Internal.Publish.ProcessServerTlb(System.String,System.String,System.String,System.String,System.String@,System.String@,System.String@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ProcessServerTlb (ProgId As String, SrcTlbPath As String, PhysicalPath As String, Operation As String, ByRef strAssemblyName As String, ByRef TypeName As String, ByRef Error As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ProcessServerTlb(System::String ^ ProgId, System::String ^ SrcTlbPath, System::String ^ PhysicalPath, System::String ^ Operation, [Runtime::InteropServices::Out] System::String ^ % strAssemblyName, [Runtime::InteropServices::Out] System::String ^ % TypeName, [Runtime::InteropServices::Out] System::String ^ % Error);" />
      <MemberSignature Language="F#" Value="abstract member ProcessServerTlb : string * string * string * string * string * string * string -&gt; unit&#xA;override this.ProcessServerTlb : string * string * string * string * string * string * string -&gt; unit" Usage="publish.ProcessServerTlb (ProgId, SrcTlbPath, PhysicalPath, Operation, strAssemblyName, TypeName, Error)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.EnterpriseServices.Internal.IComSoapPublisher.ProcessServerTlb(System.String,System.String,System.String,System.String,System.String@,System.String@,System.String@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.EnterpriseServices</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ProgId" Type="System.String" />
        <Parameter Name="SrcTlbPath" Type="System.String" />
        <Parameter Name="PhysicalPath" Type="System.String" />
        <Parameter Name="Operation" Type="System.String" />
        <Parameter Name="strAssemblyName" Type="System.String" RefType="out" />
        <Parameter Name="TypeName" Type="System.String" RefType="out" />
        <Parameter Name="Error" Type="System.String" RefType="out" />
      </Parameters>
      <Docs>
        <param name="ProgId">类的编程标识符。</param>
        <param name="SrcTlbPath">包含类型库的文件的路径。</param>
        <param name="PhysicalPath">Web 应用程序目录。</param>
        <param name="Operation">要执行的操作。</param>
        <param name="strAssemblyName">此方法返回时，此参数包含程序集的显示名称。</param>
        <param name="TypeName">此方法返回时，此参数包含程序集的完全限定类型名称。</param>
        <param name="Error">此方法返回时，此参数包含错误信息（如果遇到了问题）。</param>
        <summary>处理服务器类型库，从而向 Web.config 和 Default.disco 文件中添加或删除组件项。 必要时生成代理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.EnterpriseServices.Internal.Publish.ProcessServerTlb%2A> 为 typelib 中的组件添加发现文件和 web.config 文件中的条目，并为非托管组件生成或复制到 bin 目录的代理。 如果 `Operation` 等于 "delete"，则从 Web.config 和默认 .disco 文件中删除组件项。  
  
 建议 <xref:System.EnterpriseServices.Internal.SoapServerTlb.AddServerTlb%2A> <xref:System.EnterpriseServices.Internal.SoapServerTlb.DeleteServerTlb%2A> 使用，而不是 <xref:System.EnterpriseServices.Internal.Publish.ProcessServerTlb%2A> 。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">调用链中的调用方无权访问非托管代码。</exception>
        <exception cref="T:System.EnterpriseServices.ServicedComponentException"><paramref name="SrcTlbPath" /> 参数引用了 scrobj.dll；因此，不支持通过 SOAP 发布脚本组件。</exception>
      </Docs>
    </Member>
    <Member MemberName="RegisterAssembly">
      <MemberSignature Language="C#" Value="public void RegisterAssembly (string AssemblyPath);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RegisterAssembly(string AssemblyPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.EnterpriseServices.Internal.Publish.RegisterAssembly(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterAssembly (AssemblyPath As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void RegisterAssembly(System::String ^ AssemblyPath);" />
      <MemberSignature Language="F#" Value="abstract member RegisterAssembly : string -&gt; unit&#xA;override this.RegisterAssembly : string -&gt; unit" Usage="publish.RegisterAssembly AssemblyPath" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.EnterpriseServices.Internal.IComSoapPublisher.RegisterAssembly(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.EnterpriseServices</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="AssemblyPath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="AssemblyPath">程序集的文件系统路径。</param>
        <summary>为 COM 互操作注册程序集。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.EnterpriseServices.Internal.Publish.RegisterAssembly%2A> 使用程序集注册工具 ( # A0) 来注册程序集中的可创建类。 有关详细信息，请参阅 [)Regasm.exe (程序集注册工具 ](/dotnet/framework/tools/regasm-exe-assembly-registration-tool)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.EnterpriseServices.RegistrationException">输入程序集没有强名称。</exception>
        <exception cref="T:System.Security.SecurityException">调用链中的调用方无权访问非托管代码。  
  
- 或 - 
指定了不以“file://”开头的基本代码，且没有所需的 <see cref="T:System.Net.WebPermission" />。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="AssemblyPath" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.IO.FileNotFoundException">未找到 <paramref name="AssemblyPath" />，或者未指定文件扩展名。</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="AssemblyPath" /> 不是有效的程序集。</exception>
        <exception cref="T:System.IO.FileLoadException">用两个不同的证据将一个程序集或模块加载了两次，或程序集名称超过系统指定的最大长度。</exception>
        <exception cref="T:System.InvalidOperationException">使用 <see cref="T:System.Runtime.InteropServices.ComUnregisterFunctionAttribute" /> 标记的方法不是 <see langword="static" /> 方法。  
  
- 或 - 
在层次结构的给定级别有多个用 <see cref="T:System.Runtime.InteropServices.ComUnregisterFunctionAttribute" /> 标记的方法。  
  
- 或 - 
用 <see cref="T:System.Runtime.InteropServices.ComUnregisterFunctionAttribute" /> 标记的方法的签名无效。</exception>
      </Docs>
    </Member>
    <Member MemberName="UnRegisterAssembly">
      <MemberSignature Language="C#" Value="public void UnRegisterAssembly (string AssemblyPath);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void UnRegisterAssembly(string AssemblyPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.EnterpriseServices.Internal.Publish.UnRegisterAssembly(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub UnRegisterAssembly (AssemblyPath As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void UnRegisterAssembly(System::String ^ AssemblyPath);" />
      <MemberSignature Language="F#" Value="abstract member UnRegisterAssembly : string -&gt; unit&#xA;override this.UnRegisterAssembly : string -&gt; unit" Usage="publish.UnRegisterAssembly AssemblyPath" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.EnterpriseServices.Internal.IComSoapPublisher.UnRegisterAssembly(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.EnterpriseServices</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="AssemblyPath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="AssemblyPath">程序集的文件系统路径。</param>
        <summary>注销 COM 互操作程序集。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.EnterpriseServices.Internal.Publish.UnRegisterAssembly%2A> 使用 Regasm.exe 取消注册程序集中的可创建类。 有关详细信息，请参阅 [)Regasm.exe (程序集注册工具 ](/dotnet/framework/tools/regasm-exe-assembly-registration-tool)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">调用链中的调用方无权访问非托管代码。  
  
- 或 - 
指定了不以“file://”开头的基本代码，且没有所需的 <see cref="T:System.Net.WebPermission" />。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="AssemblyPath" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.IO.FileNotFoundException">找不到 <paramref name="AssemblyPath" /> 或者未指定文件扩展名。</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="AssemblyPath" /> 不是有效的程序集。</exception>
        <exception cref="T:System.IO.FileLoadException">用两个不同的证据将一个程序集或模块加载了两次，或程序集名称超过系统指定的最大长度。</exception>
        <exception cref="T:System.InvalidOperationException">使用 <see cref="T:System.Runtime.InteropServices.ComUnregisterFunctionAttribute" /> 标记的方法不是 <see langword="static" /> 方法。  
  
- 或 - 
在层次结构的给定级别有多个用 <see cref="T:System.Runtime.InteropServices.ComUnregisterFunctionAttribute" /> 标记的方法。  
  
- 或 - 
用 <see cref="T:System.Runtime.InteropServices.ComUnregisterFunctionAttribute" /> 标记的方法的签名无效。</exception>
      </Docs>
    </Member>
  </Members>
</Type>
