<Type Name="HttpResponse" FullName="System.Web.HttpResponse">
  <Metadata><Meta Name="ms.openlocfilehash" Value="10b2de1ffdcd89ee42c794ca776e5f17bb2f443c" /><Meta Name="ms.sourcegitcommit" Value="614d294c141edd72eaf0657186a7c9d4fd6e3110" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-CN" /><Meta Name="ms.lasthandoff" Value="10/22/2020" /><Meta Name="ms.locfileid" Value="92434413" /></Metadata><TypeSignature Language="C#" Value="public sealed class HttpResponse" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit HttpResponse extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Web.HttpResponse" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class HttpResponse" />
  <TypeSignature Language="C++ CLI" Value="public ref class HttpResponse sealed" />
  <TypeSignature Language="F#" Value="type HttpResponse = class" />
  <AssemblyInfo>
    <AssemblyName>System.Web</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>封装来自 ASP.NET 操作的 HTTP 响应信息。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[

## Remarks
 类的方法和属性 <xref:System.Web.HttpResponse> 通过 <xref:System.Web.HttpApplication.Response%2A> <xref:System.Web.HttpApplication> 、 <xref:System.Web.HttpContext> 、 <xref:System.Web.UI.Page> 和类的属性公开 <xref:System.Web.UI.UserControl> 。

 <xref:System.Web.HttpResponse>仅在回发方案（而不是异步回发方案）中支持类的以下方法：

-   <xref:System.Web.HttpResponse.BinaryWrite%2A>

-   <xref:System.Web.HttpResponse.Clear%2A>

-   <xref:System.Web.HttpResponse.ClearContent%2A>

-   <xref:System.Web.HttpResponse.ClearHeaders%2A>

-   <xref:System.Web.HttpResponse.Close%2A>

-   <xref:System.Web.HttpResponse.End%2A>

-   <xref:System.Web.HttpResponse.Flush%2A>

-   <xref:System.Web.HttpResponse.TransmitFile%2A>

-   <xref:System.Web.HttpResponse.Write%2A>

-   <xref:System.Web.HttpResponse.WriteFile%2A>

-   <xref:System.Web.HttpResponse.WriteSubstitution%2A>

 当您使用 <xref:System.Web.UI.UpdatePanel> 控件更新页面的选定区域，而不是使用回发更新整个页面时，会启用部分页面更新。 有关详细信息，请参阅 [UpdatePanel 控件概述](https://docs.microsoft.com/previous-versions/aspnet/bb386454(v=vs.100)) 和 [部分页呈现概述](https://docs.microsoft.com/previous-versions/aspnet/bb386573(v=vs.100))。



## Examples
 下面的示例在请求页时绘制三个重叠矩形。 代码首先将 <xref:System.Web.HttpResponse.ContentType%2A> 属性设置为 image/jpeg，使整个页面呈现为 jpeg 图像。 然后，该代码调用 <xref:System.Web.HttpResponse.Clear%2A> 方法，以确保不会随此响应发送无关的内容。 接下来，代码将 <xref:System.Web.HttpResponse.BufferOutput%2A> 属性设置为 true，以便在将页发送到请求客户端之前对其进行完全处理。 然后创建两个用于绘制矩形的对象：一个 <xref:System.Drawing.Bitmap> 和一个 <xref:System.Drawing.Graphics> 对象。 在页中创建的变量用作绘制矩形的坐标和出现在最大矩形内的字符串。

 绘制三个矩形和其中显示的字符串时，将 <xref:System.Drawing.Bitmap> 保存到 <xref:System.IO.Stream> 与属性相关联的对象， <xref:System.Web.HttpResponse.OutputStream%2A> 并将其格式设置为 "JPEG"。 此代码调用 <xref:System.Drawing.Image.Dispose%2A> 和 <xref:System.Drawing.Graphics.Dispose%2A> 方法以释放由两个图形对象使用的资源。 最后，该代码调用 <xref:System.Web.HttpResponse.Flush%2A> 方法将缓冲响应发送到请求客户端。

> [!NOTE]
>  在代码中， <xref:System.Web.HttpResponse> 由关键字引用对象 `Response` 。 例如， `Response.Clear()` 表示 <xref:System.Web.HttpResponse.Clear%2A?displayProperty=nameWithType> 方法。 <xref:System.Web.UI.Page>类具有一个名为的属性，该属性 <xref:System.Web.UI.Page.Response%2A> 公开的当前实例 <xref:System.Web.HttpResponse> 。

 [!code-aspx-csharp[System.Web.HttpResponse_Samples1#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Samples1/CS/responsesamplescs.aspx#1)]
 [!code-aspx-vb[System.Web.HttpResponse_Samples1#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Samples1/VB/responsesamplesvb.aspx#1)]

 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public HttpResponse (System.IO.TextWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.TextWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.#ctor(System.IO.TextWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (writer As TextWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; HttpResponse(System::IO::TextWriter ^ writer);" />
      <MemberSignature Language="F#" Value="new System.Web.HttpResponse : System.IO.TextWriter -&gt; System.Web.HttpResponse" Usage="new System.Web.HttpResponse writer" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="writer" Type="System.IO.TextWriter" />
      </Parameters>
      <Docs>
        <param name="writer">实现自定义 HTTP 输出的 <see cref="T:System.IO.TextWriter" /> 对象。</param>
        <summary>初始化 <see cref="T:System.Web.HttpResponse" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 此成员支持 .NET Framework 结构，不能在代码中直接使用。

 类的方法和属性 <xref:System.Web.HttpResponse> 通过 ASP.NET 中的内部对象公开 <xref:System.Web.HttpContext.Response%2A> 。

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddCacheDependency">
      <MemberSignature Language="C#" Value="public void AddCacheDependency (params System.Web.Caching.CacheDependency[] dependencies);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddCacheDependency(class System.Web.Caching.CacheDependency[] dependencies) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.AddCacheDependency(System.Web.Caching.CacheDependency[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddCacheDependency (ParamArray dependencies As CacheDependency())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddCacheDependency(... cli::array &lt;System::Web::Caching::CacheDependency ^&gt; ^ dependencies);" />
      <MemberSignature Language="F#" Value="member this.AddCacheDependency : System.Web.Caching.CacheDependency[] -&gt; unit" Usage="httpResponse.AddCacheDependency dependencies" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dependencies" Type="System.Web.Caching.CacheDependency[]" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="dependencies">要添加到应用程序依赖项列表的文件、缓存键或 <see cref="T:System.Web.Caching.CacheDependency" />。</param>
        <summary>将一组缓存依赖项与响应关联，这样，如果响应存储在输出缓存中并且指定的依赖项发生变化，就可以使该响应失效。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.Web.HttpResponse.AddCacheDependency%2A>方法允许在缓存的响应和对象之间创建依赖关系 <xref:System.Web.Caching.CacheDependency> 。



## Examples
 下面的示例演示如何使用方法和对象创建缓存依赖项 <xref:System.Web.HttpResponse.AddCacheDependency%2A> <xref:System.Web.Caching.CacheDependency> 。

 [!code-aspx-csharp[HttpResponse.AddCacheDependency#1](~/samples/snippets/csharp/VS_Snippets_WebNet/HttpResponse.AddCacheDependency/CS/httpresponse.addcachedependency_cs.aspx#1)]
 [!code-aspx-vb[HttpResponse.AddCacheDependency#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/HttpResponse.AddCacheDependency/VB/httpresponse.addcachedependency_vb.aspx#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="dependencies" /> 参数为 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">在缓存处理管线中调用此方法太迟，已经在创建了缓存响应之后。</exception>
        <altmember cref="T:System.Web.Caching.CacheDependency" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/06bh14hk(v=vs.100)">缓存 ASP.NET 页</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="AddCacheItemDependencies">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>使缓存响应的有效性依赖于缓存中的其他项。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddCacheItemDependencies">
      <MemberSignature Language="C#" Value="public void AddCacheItemDependencies (System.Collections.ArrayList cacheKeys);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddCacheItemDependencies(class System.Collections.ArrayList cacheKeys) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.AddCacheItemDependencies(System.Collections.ArrayList)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddCacheItemDependencies (cacheKeys As ArrayList)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddCacheItemDependencies(System::Collections::ArrayList ^ cacheKeys);" />
      <MemberSignature Language="F#" Value="member this.AddCacheItemDependencies : System.Collections.ArrayList -&gt; unit" Usage="httpResponse.AddCacheItemDependencies cacheKeys" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cacheKeys" Type="System.Collections.ArrayList" />
      </Parameters>
      <Docs>
        <param name="cacheKeys"><see cref="T:System.Collections.ArrayList" />，其中包含当前缓存的响应所依赖的项的键。</param>
        <summary>使缓存响应的有效性依赖于缓存中的其他项。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 如果从缓存中删除了参数中引用的项 `cacheKeys` ，则当前项的缓存响应无效。



## Examples
 下面的示例演示如何使用缓存输出的 ASP.NET 页。 页面的代码将创建 <xref:System.Collections.ArrayList> 与对象中存储的项关联的键的对象 <xref:System.Web.Caching.Cache> 。 接下来，代码在对 <xref:System.Collections.ArrayList> 方法的调用中将作为参数传递 <xref:System.Web.HttpResponse.AddCacheItemDependencies%2A> 。 如果在更改中指定的任何文件，这会使输出缓存的响应无效 <xref:System.Collections.ArrayList> 。

 [!code-aspx-csharp[System.Web.HttpResponse_Samples2#5](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Samples2/CS/cacheitemsdepscs.aspx#5)]
 [!code-aspx-vb[System.Web.HttpResponse_Samples2#5](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Samples2/VB/cacheitemsdepsvb.aspx#5)]

 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.Caching.CacheDependency" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/06bh14hk(v=vs.100)">缓存 ASP.NET 页</related>
      </Docs>
    </Member>
    <Member MemberName="AddCacheItemDependencies">
      <MemberSignature Language="C#" Value="public void AddCacheItemDependencies (string[] cacheKeys);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddCacheItemDependencies(string[] cacheKeys) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.AddCacheItemDependencies(System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddCacheItemDependencies (cacheKeys As String())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddCacheItemDependencies(cli::array &lt;System::String ^&gt; ^ cacheKeys);" />
      <MemberSignature Language="F#" Value="member this.AddCacheItemDependencies : string[] -&gt; unit" Usage="httpResponse.AddCacheItemDependencies cacheKeys" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cacheKeys" Type="System.String[]" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="cacheKeys">一个项键的数组，缓存响应依赖于这些项键。</param>
        <summary>使缓存项的有效性依赖于缓存中的另一项。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 如果从缓存中删除了任何一个 `cacheKey` ，则当前项的缓存响应将无效。

 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.Caching.CacheDependency" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/06bh14hk(v=vs.100)">缓存 ASP.NET 页</related>
      </Docs>
    </Member>
    <Member MemberName="AddCacheItemDependency">
      <MemberSignature Language="C#" Value="public void AddCacheItemDependency (string cacheKey);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddCacheItemDependency(string cacheKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.AddCacheItemDependency(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddCacheItemDependency (cacheKey As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddCacheItemDependency(System::String ^ cacheKey);" />
      <MemberSignature Language="F#" Value="member this.AddCacheItemDependency : string -&gt; unit" Usage="httpResponse.AddCacheItemDependency cacheKey" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cacheKey" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="cacheKey">缓存的响应所依赖的项的键。</param>
        <summary>使缓存响应的有效性依赖于缓存中的其他项。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 如果 `cacheKey` 从缓存中删除与该参数对应的项，则当前项的缓存响应将无效。



## Examples
 下面的示例是一个 ASP.NET 用户控件，该控件是已缓存的输出。 控件的代码 <xref:System.Web.HttpResponse.AddCacheItemDependency%2A> 使用 <xref:System.Web.Caching.Cache> 作为参数传递的对象中存储的项的键调用方法。 如果缓存中不存在该项，则存储在输出缓存中的控件响应会失效。 这意味着，在后续请求中，会将新版本的控件响应添加到输出缓存。

 接下来，该代码将检查与某个键关联的项是否 `bookData` 存储在该 `Cache` 对象中，并根据结果显示两行文本之一。 然后，该代码 <xref:System.Web.UI.WebControls.BaseDataList.DataSource%2A> <xref:System.Web.UI.WebControls.DataGrid> 使用调用自定义类的共享方法设置名为的控件的属性， `dgBooks` `DataHelper` `GetBookData` 并 <xref:System.Web.UI.WebControls.DataGrid> 使用 <xref:System.Web.UI.Control.DataBind%2A> 方法填充。

 [!code-aspx-csharp[System.Web.HttpResponse_Samples2#3](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Samples2/CS/bookscs.ascx#3)]
 [!code-aspx-vb[System.Web.HttpResponse_Samples2#3](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Samples2/VB/booksvb.ascx#3)]

 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.HttpResponse.AddCacheItemDependency(System.String)" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/06bh14hk(v=vs.100)">缓存 ASP.NET 页</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="AddFileDependencies">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>将一组文件名添加到文件名集合中，当前响应依赖于该集合。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddFileDependencies">
      <MemberSignature Language="C#" Value="public void AddFileDependencies (System.Collections.ArrayList filenames);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddFileDependencies(class System.Collections.ArrayList filenames) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.AddFileDependencies(System.Collections.ArrayList)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddFileDependencies (filenames As ArrayList)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddFileDependencies(System::Collections::ArrayList ^ filenames);" />
      <MemberSignature Language="F#" Value="member this.AddFileDependencies : System.Collections.ArrayList -&gt; unit" Usage="httpResponse.AddFileDependencies filenames" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filenames" Type="System.Collections.ArrayList" />
      </Parameters>
      <Docs>
        <param name="filenames">要添加的文件集合。</param>
        <summary>将一组文件名添加到文件名集合中，当前响应依赖于该集合。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Examples
 下面的示例是缓存输出的 ASP.NET 页面。 页面的代码将创建一个 <xref:System.Collections.ArrayList> 文件路径，然后 <xref:System.Collections.ArrayList> 在对方法的调用中将作为参数传递 <xref:System.Web.HttpResponse.AddFileDependencies%2A> 。 如果在更改中指定的任何文件，这会使输出缓存的响应无效 <xref:System.Collections.ArrayList> 。

 [!code-aspx-csharp[System.Web.HttpResponse_Samples2#6](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Samples2/CS/responsefiledepscs.aspx#6)]
 [!code-aspx-vb[System.Web.HttpResponse_Samples2#6](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Samples2/VB/responsefiledepsvb.aspx#6)]

 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.Caching.CacheDependency" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/06bh14hk(v=vs.100)">缓存 ASP.NET 页</related>
      </Docs>
    </Member>
    <Member MemberName="AddFileDependencies">
      <MemberSignature Language="C#" Value="public void AddFileDependencies (string[] filenames);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddFileDependencies(string[] filenames) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.AddFileDependencies(System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddFileDependencies (filenames As String())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddFileDependencies(cli::array &lt;System::String ^&gt; ^ filenames);" />
      <MemberSignature Language="F#" Value="member this.AddFileDependencies : string[] -&gt; unit" Usage="httpResponse.AddFileDependencies filenames" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filenames" Type="System.String[]" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="filenames">要添加的文件数组。</param>
        <summary>将文件名数组添加到当前响应依赖的文件名集合中。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Examples
 下面的示例将文件名的数组添加到 <xref:System.Web.HttpResponse.AddFileDependencies%2A> 文件依赖项列表。 如果文件发生更改，则会使缓存的响应失效。

 [!code-aspx-csharp[Response.AddFileDependency#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Response.AddFileDependency/CS/addfiledependency_cs.aspx#1)]
 [!code-aspx-vb[Response.AddFileDependency#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Response.AddFileDependency/VB/addfiledependency_vb.aspx#1)]

 ]]></format>
        </remarks>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/06bh14hk(v=vs.100)">缓存 ASP.NET 页</related>
      </Docs>
    </Member>
    <Member MemberName="AddFileDependency">
      <MemberSignature Language="C#" Value="public void AddFileDependency (string filename);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddFileDependency(string filename) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.AddFileDependency(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddFileDependency (filename As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddFileDependency(System::String ^ filename);" />
      <MemberSignature Language="F#" Value="member this.AddFileDependency : string -&gt; unit" Usage="httpResponse.AddFileDependency filename" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filename" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="filename">要添加的文件名。</param>
        <summary>将单个文件名添加到文件名集合中，当前响应依赖于该集合。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 使用 <xref:System.Web.HttpResponse.AddFileDependency%2A> 方法添加文件依赖项时，还必须以编程方式或声明方式指定输出缓存。 例如，若要以声明方式指定输出缓存，请使用 [@ OutputCache](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/hdxfb6cy(v=vs.100)) 指令。 有关详细信息，请参阅 [如何：缓存具有文件依赖项的页输出](https://docs.microsoft.com/previous-versions/aspnet/67z4z916(v=vs.100))。



## Examples
 下面的示例演示如何将单个文件名添加到 <xref:System.Web.HttpResponse.AddFileDependency%2A> 文件依赖项列表。 如果文件发生更改，则会使缓存的响应失效。

 [!code-csharp[Classic HttpResponse.AddFileDependency Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.AddFileDependency Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.AddFileDependency Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.AddFileDependency Example/VB/source.vb#1)]

 ]]></format>
        </remarks>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/06bh14hk(v=vs.100)">缓存 ASP.NET 页</related>
      </Docs>
    </Member>
    <Member MemberName="AddHeader">
      <MemberSignature Language="C#" Value="public void AddHeader (string name, string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddHeader(string name, string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.AddHeader(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddHeader (name As String, value As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddHeader(System::String ^ name, System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.AddHeader : string * string -&gt; unit" Usage="httpResponse.AddHeader (name, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">要将 <paramref name="value" /> 添加到其中的 HTTP 标头的名称。</param>
        <param name="value">要添加到头中的字符串。</param>
        <summary>将 HTTP 头添加到输出流。 提供 <see cref="M:System.Web.HttpResponse.AddHeader(System.String,System.String)" />，以便兼容 ASP 的早期版本。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.Web.HttpResponse.AddHeader%2A> 与相同 <xref:System.Web.HttpResponse.AppendHeader%2A> ，只是为了与 ASP 的早期版本兼容。 使用 ASP.NET，请使用 <xref:System.Web.HttpResponse.AppendHeader%2A> 。

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddOnSendingHeaders">
      <MemberSignature Language="C#" Value="public System.Web.ISubscriptionToken AddOnSendingHeaders (Action&lt;System.Web.HttpContext&gt; callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Web.ISubscriptionToken AddOnSendingHeaders(class System.Action`1&lt;class System.Web.HttpContext&gt; callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.AddOnSendingHeaders(System.Action{System.Web.HttpContext})" />
      <MemberSignature Language="VB.NET" Value="Public Function AddOnSendingHeaders (callback As Action(Of HttpContext)) As ISubscriptionToken" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Web::ISubscriptionToken ^ AddOnSendingHeaders(Action&lt;System::Web::HttpContext ^&gt; ^ callback);" />
      <MemberSignature Language="F#" Value="member this.AddOnSendingHeaders : Action&lt;System.Web.HttpContext&gt; -&gt; System.Web.ISubscriptionToken" Usage="httpResponse.AddOnSendingHeaders callback" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.ISubscriptionToken</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.Action&lt;System.Web.HttpContext&gt;" Index="0" FrameworkAlternate="netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="callback">回调方法。</param>
        <summary>注册一个回调，在即将为此请求发送响应标头之前，ASP.NET 运行时将会调用此回调。</summary>
        <returns>表示对 OnSendingHeaders 伪事件的订阅的 <see cref="T:System.Web.ISubscriptionToken" /> 对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

> [!IMPORTANT]
>  如果本机模块首先刷新响应，则不会调用 AddOnSendingHeaders 方法。

 伪事件对 onsendingheaders 与 IHttpModule 管道事件的不同之处在于，它是一个每个请求订阅，而不是按应用程序订阅。 目的是回调可以修改响应状态代码，也可以设置响应 cookie 或标头。 其他使用注意事项和注意事项：

-   此方法仅在以下情况下有效： IIS 在集成管道模式管道中运行，并且仅在当前请求尚未发送响应标头时有效。

-   ASP.NET 运行时不保证调用回调的线程的任何内容。 例如，如果正在执行后台刷新，则可在后台线程中同步调用回调。 <xref:System.Web.HttpContext.Current%2A> 不保证在此类线程中可用。

-   回调不得调用任何操作响应实体正文或导致刷新的方法。 例如，回调不得调用 <xref:System.Web.HttpResponse.Redirect%2A> ，因为该方法可以操作响应实体正文。

-   回调必须只包含短时间运行的同步代码。 尝试调用异步操作或等待这样的操作可能会导致死锁。

-   回调不得引发异常;否则，行为是不确定的。

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AppendCookie">
      <MemberSignature Language="C#" Value="public void AppendCookie (System.Web.HttpCookie cookie);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AppendCookie(class System.Web.HttpCookie cookie) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.AppendCookie(System.Web.HttpCookie)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AppendCookie (cookie As HttpCookie)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AppendCookie(System::Web::HttpCookie ^ cookie);" />
      <MemberSignature Language="F#" Value="member this.AppendCookie : System.Web.HttpCookie -&gt; unit" Usage="httpResponse.AppendCookie cookie" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cookie" Type="System.Web.HttpCookie" />
      </Parameters>
      <Docs>
        <param name="cookie">要添加到输出流的 <see cref="T:System.Web.HttpCookie" />。</param>
        <summary>将一个 HTTP Cookie 添加到内部 Cookie 集合。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Examples
 下面的示例创建一个名为的新 cookie，将该 cookie 的 `LastVisit` 值设置为当前日期和时间，并将该 cookie 追加到当前 cookie 集合中。 Cookie 集合中的所有 cookie 都 `Set-Cookie` 通过 HTTP 输出流发送到标头中的客户端。

 [!code-csharp[Classic HttpResponse.AppendCookie Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.AppendCookie Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.AppendCookie Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.AppendCookie Example/VB/source.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">在发送了 HTTP 标头之后会追加一个 Cookie。</exception>
      </Docs>
    </Member>
    <Member MemberName="AppendHeader">
      <MemberSignature Language="C#" Value="public void AppendHeader (string name, string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AppendHeader(string name, string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.AppendHeader(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AppendHeader (name As String, value As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AppendHeader(System::String ^ name, System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.AppendHeader : string * string -&gt; unit" Usage="httpResponse.AppendHeader (name, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">要添加到输出流的 HTTP 头的名称。</param>
        <param name="value">要追加到头中的字符串。</param>
        <summary>将 HTTP 头添加到输出流。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 如果使用 <xref:System.Web.HttpResponse.AppendHeader%2A> 方法发送缓存特定的标头，并同时使用缓存对象模型 (<xref:System.Web.HttpResponse.Cache%2A>) 设置缓存策略，则在 `Cache-Control` `Expires` `Last-Modified` `Pragma` `Vary` 使用缓存对象模型时，可能会删除与缓存 (、、、和) 相关的 HTTP 响应标头。 此行为可使 ASP.NET 保持最严格的设置。 例如，请考虑一个包括用户控件的页面。 如果这些控件具有冲突的缓存策略，则将使用限制性最强的缓存策略。 如果一个用户控件设置标头 " `Cache-Control: Public` "，而另一个用户控件通过调用来设置限制性更强的标头 "" `Cache-Control: Private` <xref:System.Web.HttpCachePolicy.SetCacheability%2A> ，则 " `Cache-Control: Private` " 标头将与响应一起发送。

 有关标准 HTTP/1.1 标头的列表，请参阅 [标头字段定义](https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14)。

## Examples
 下面的示例调用 <xref:System.Web.HttpResponse.AppendHeader%2A> 方法，将自定义标头添加到 <xref:System.Web.HttpResponse> 发送给发出请求的客户端的对象。

 [!code-csharp[System.Web.HttpResponse.AppendHeader_Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse.AppendHeader_Example/CS/responseappendheader.cs.aspx#1)]
 [!code-vb[System.Web.HttpResponse.AppendHeader_Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse.AppendHeader_Example/VB/responseappendheader.vb.aspx#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">发送 HTTP 标头后追加该标头。</exception>
      </Docs>
    </Member>
    <Member MemberName="AppendToLog">
      <MemberSignature Language="C#" Value="public void AppendToLog (string param);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AppendToLog(string param) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.AppendToLog(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AppendToLog (param As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AppendToLog(System::String ^ param);" />
      <MemberSignature Language="F#" Value="member this.AppendToLog : string -&gt; unit" Usage="httpResponse.AppendToLog param" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="param" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="param">要添加到日志文件的文本。</param>
        <summary>将自定义日志信息添加到 Internet Information Services (IIS)日志文件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 若要允许在日志文件中记录指定的字符串，首先必须为要在 IIS 中记录其活动的站点启用 " **扩展日志记录属性** " 对话框的 " **URI 查询** " 选项。

 若要在 IIS 6.0 中自定义扩展日志记录，请执行以下步骤：

1.  在 IIS 管理器中，展开 "本地计算机" 节点，展开 "Web" 或 "FTP 站点" 文件夹，右键单击 Web 或 FTP 站点，然后单击 " **属性** "。

2.  单击 " **Web" 或 "FTP 站点** " 选项卡，然后选中 " **启用日志记录** " 复选框， (如果尚未选择此选项) 。

3.  在 " **活动日志格式** " 框中，单击 " **W3C 扩展日志文件格式** "。

4.  单击 **“属性”** 。

5.  单击 " **高级** " 选项卡，选择要记录的属性，然后单击 **"确定"** 。



## Examples
 下面的示例演示如何将字符串追加到日志中。

 [!code-csharp[Classic HttpResponse.AppendToLog Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.AppendToLog Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.AppendToLog Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.AppendToLog Example/VB/source.vb#1)]

 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="/previous-versions/windows/it-pro/windows-server-2003/cc776284(v=ws.10)">Windows Server 2003 产品帮助</related>
      </Docs>
    </Member>
    <Member MemberName="ApplyAppPathModifier">
      <MemberSignature Language="C#" Value="public string ApplyAppPathModifier (string virtualPath);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ApplyAppPathModifier(string virtualPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.ApplyAppPathModifier(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ApplyAppPathModifier (virtualPath As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ApplyAppPathModifier(System::String ^ virtualPath);" />
      <MemberSignature Language="F#" Value="member this.ApplyAppPathModifier : string -&gt; string" Usage="httpResponse.ApplyAppPathModifier virtualPath" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="virtualPath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="virtualPath">资源的虚拟路径。</param>
        <summary>如果会话使用 <see cref="P:System.Web.Configuration.SessionStateSection.Cookieless" /> 会话状态，则将该会话 ID 添加到虚拟路径中，并返回组合路径。 如果不使用 <see cref="P:System.Web.Configuration.SessionStateSection.Cookieless" /> 会话状态，则 <see cref="M:System.Web.HttpResponse.ApplyAppPathModifier(System.String)" /> 返回原始的虚拟路径。</summary>
        <returns>已插入会话 ID 的 <paramref name="virtualPath" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.Web.HttpResponse.ApplyAppPathModifier%2A> 仅用于无 cookie 会话来构造绝对 Href。



## Examples
 下面的示例声明一个名为的字符串变量 `urlConverted` ，并将其设置为 <xref:System.Web.HttpResponse.ApplyAppPathModifier%2A> 方法调用的结果。 然后，代码将变量的值传递到 <xref:System.Web.UI.WebControls.HyperLink> 控件的 <xref:System.Web.UI.WebControls.HyperLink.NavigateUrl%2A> 属性。

 [!code-csharp[System.Web.HttpResponse_Sample5#5](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Sample5/CS/responseapppathmodifiercs.aspx#5)]
 [!code-vb[System.Web.HttpResponse_Sample5#5](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Sample5/VB/responseapppathmodifiervb.aspx#5)]

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginFlush">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginFlush (AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginFlush(class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.BeginFlush(System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginFlush (callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginFlush(AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginFlush : AsyncCallback * obj -&gt; IAsyncResult" Usage="httpResponse.BeginFlush (callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.AsyncCallback" Index="0" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="state" Type="System.Object" Index="1" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="callback">回调对象。</param>
        <param name="state">响应状态。</param>
        <summary>向客户端发送当前所有缓冲的响应。</summary>
        <returns>异步结果对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 如果基础 <xref:System.Web.HttpWorkerRequest> 对象支持异步刷新操作，并且从异步模块事件或异步处理程序中调用此方法，则会以异步方式执行刷新操作。 否则，将同步执行刷新操作。 IIS 6.0 和更高版本支持异步刷新。

 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">响应已完成。</exception>
      </Docs>
    </Member>
    <Member MemberName="BinaryWrite">
      <MemberSignature Language="C#" Value="public void BinaryWrite (byte[] buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BinaryWrite(unsigned int8[] buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.BinaryWrite(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub BinaryWrite (buffer As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BinaryWrite(cli::array &lt;System::Byte&gt; ^ buffer);" />
      <MemberSignature Language="F#" Value="member this.BinaryWrite : byte[] -&gt; unit" Usage="httpResponse.BinaryWrite buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="buffer">要写入输出流的字节。</param>
        <summary>将二进制字符串写入 HTTP 输出流。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Examples
 下面的示例将文本文件读入缓冲区，并将缓冲区写入 HTTP 输出流。

 [!code-csharp[Classic HttpResponse.BinaryWrite Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.BinaryWrite Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.BinaryWrite Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.BinaryWrite Example/VB/source.vb#1)]

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Buffer">
      <MemberSignature Language="C#" Value="public bool Buffer { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Buffer" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.Buffer" />
      <MemberSignature Language="VB.NET" Value="Public Property Buffer As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Buffer { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Buffer : bool with get, set" Usage="System.Web.HttpResponse.Buffer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指示是否缓冲输出并在处理完整个响应之后发送它。</summary>
        <value>如果缓冲了发送到客户端的输出，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.Web.HttpResponse.Buffer%2A>属性已不推荐使用 <xref:System.Web.HttpResponse.BufferOutput%2A> 属性，只是为了与 ASP 的早期版本兼容而提供。 使用 ASP.NET，请使用 <xref:System.Web.HttpResponse.BufferOutput%2A> 。

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BufferOutput">
      <MemberSignature Language="C#" Value="public bool BufferOutput { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool BufferOutput" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.BufferOutput" />
      <MemberSignature Language="VB.NET" Value="Public Property BufferOutput As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool BufferOutput { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.BufferOutput : bool with get, set" Usage="System.Web.HttpResponse.BufferOutput" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指示是否缓冲输出并在处理完整个页之后发送它。</summary>
        <value>如果缓冲了发送到客户端的输出，则为 <see langword="true" />；否则为 <see langword="false" />。 默认值为 <see langword="true" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Examples
 下面的示例设置对 <xref:System.Web.HttpResponse.ContentType%2A> image/jpeg 的响应的属性，调用 <xref:System.Web.HttpResponse.Clear%2A> 方法以删除可能附加到响应的其他内容，然后将 <xref:System.Web.HttpResponse.BufferOutput%2A> 属性设置为 true，以便在将任何内容发送到请求客户端之前处理整个页面。

 有关完整示例，请参阅 <xref:System.Web.HttpResponse> 类。

 [!code-csharp[System.Web.HttpResponse_Samples1#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Samples1/CS/responsesamplescs.aspx#2)]
 [!code-vb[System.Web.HttpResponse_Samples1#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Samples1/VB/responsesamplesvb.aspx#2)]

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cache">
      <MemberSignature Language="C#" Value="public System.Web.HttpCachePolicy Cache { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpCachePolicy Cache" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.Cache" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Cache As HttpCachePolicy" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::HttpCachePolicy ^ Cache { System::Web::HttpCachePolicy ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Cache : System.Web.HttpCachePolicy" Usage="System.Web.HttpResponse.Cache" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.HttpCachePolicy</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取网页的缓存策略(例如，过期时间、保密性设置和变化条款)。</summary>
        <value>包含当前响应的缓存策略相关信息的 <see cref="T:System.Web.HttpCachePolicy" /> 对象。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Examples
 下面的示例将当前缓存策略的属性写入 HTTP 输出流。

 [!code-csharp[Classic HttpResponse.Cache Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.Cache Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.Cache Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.Cache Example/VB/source.vb#1)]

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CacheControl">
      <MemberSignature Language="C#" Value="public string CacheControl { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string CacheControl" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.CacheControl" />
      <MemberSignature Language="VB.NET" Value="Public Property CacheControl As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ CacheControl { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CacheControl : string with get, set" Usage="System.Web.HttpResponse.CacheControl" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置与 <see cref="T:System.Web.HttpCacheability" /> 枚举值之一匹配的 <see langword="Cache-Control" /> HTTP 标头。</summary>
        <value><see cref="T:System.Web.HttpCacheability" /> 枚举值的字符串表示形式。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 `Private`、和的值 `Public` `No-Cache` 是字符串，必须用引号引起来 ( "" ) 。 如果 <xref:System.Web.HttpResponse.CacheControl%2A> 将属性设置为与枚举值之一不匹配的值，则 <xref:System.Web.HttpCacheability> <xref:System.ArgumentException> 会引发。 如果 <xref:System.Web.HttpResponse.CacheControl%2A> 未设置该属性，则将响应的可缓存性设置为 <xref:System.Web.HttpCacheability.NoCache> 。

 `CacheControl`、 <xref:System.Web.HttpResponse.Expires%2A> 和属性已 <xref:System.Web.HttpResponse.ExpiresAbsolute%2A> 弃用。 相反，类的方法 <xref:System.Web.HttpCachePolicy> 可通过内部对象使用， <xref:System.Web.HttpResponse.Cache%2A> 以控制 IIS) 输出缓存和客户端缓存 (的 Internet Information Services。

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">设置的字符串值与 <see cref="T:System.Web.HttpCacheability" /> 枚举值之一不匹配。</exception>
      </Docs>
    </Member>
    <Member MemberName="Charset">
      <MemberSignature Language="C#" Value="public string Charset { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Charset" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.Charset" />
      <MemberSignature Language="VB.NET" Value="Public Property Charset As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Charset { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Charset : string with get, set" Usage="System.Web.HttpResponse.Charset" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置输出流的 HTTP 字符集。</summary>
        <value>输出流的 HTTP 字符集。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 `Charset`属性可以设置为 `null` 以禁止显示 HTTP `Content-Type` 标头。



## Examples
 下面的示例检查输出流的字符集是否为中欧 (ISO) 。

 [!code-csharp[System.Web.HttpResponse.Charset#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse.Charset/cs/default.aspx#1)]
 [!code-vb[System.Web.HttpResponse.Charset#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse.Charset/vb/default.aspx#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">发送标头后设置 <see langword="Charset" /> 属性。</exception>
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Sub Clear ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Clear();" />
      <MemberSignature Language="F#" Value="member this.Clear : unit -&gt; unit" Usage="httpResponse.Clear " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>清除缓冲区流中的所有内容输出。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.Web.HttpResponse.Clear%2A>方法不清除标头信息。



## Examples
 下面的示例设置对 <xref:System.Web.HttpResponse.ContentType%2A> image/jpeg 的响应的属性，调用 <xref:System.Web.HttpResponse.Clear%2A> 方法以删除可能附加到响应的其他内容，然后将 <xref:System.Web.HttpResponse.BufferOutput%2A> 属性设置为 true，以便在将任何内容发送到请求客户端之前处理整个页面。

 有关完整示例，请参阅 <xref:System.Web.HttpResponse> 类。

 [!code-csharp[System.Web.HttpResponse_Samples1#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Samples1/CS/responsesamplescs.aspx#2)]
 [!code-vb[System.Web.HttpResponse_Samples1#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Samples1/VB/responsesamplesvb.aspx#2)]

 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.HttpResponse.ClearHeaders" />
      </Docs>
    </Member>
    <Member MemberName="ClearContent">
      <MemberSignature Language="C#" Value="public void ClearContent ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ClearContent() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.ClearContent" />
      <MemberSignature Language="VB.NET" Value="Public Sub ClearContent ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ClearContent();" />
      <MemberSignature Language="F#" Value="member this.ClearContent : unit -&gt; unit" Usage="httpResponse.ClearContent " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>清除缓冲区流中的所有内容输出。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.Web.HttpResponse.ClearContent%2A>方法不清除标头信息。



## Examples
 下面的示例将清除缓冲区流中的所有内容。

 [!code-csharp[Classic HttpResponse.ClearContent Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.ClearContent Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.ClearContent Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.ClearContent Example/VB/source.vb#1)]

 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.HttpResponse.ClearHeaders" />
      </Docs>
    </Member>
    <Member MemberName="ClearHeaders">
      <MemberSignature Language="C#" Value="public void ClearHeaders ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ClearHeaders() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.ClearHeaders" />
      <MemberSignature Language="VB.NET" Value="Public Sub ClearHeaders ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ClearHeaders();" />
      <MemberSignature Language="F#" Value="member this.ClearHeaders : unit -&gt; unit" Usage="httpResponse.ClearHeaders " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>清除缓冲区流中的所有头。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Examples
 下面的示例调用 <xref:System.Web.HttpResponse.ClearHeaders%2A> 方法，以确保不会与当前响应一起发送任何标头。 如果 ASP.NET 响应正在生成图像（如 JPEG 文件），则此方法可能特别重要。 在此示例中，将 <xref:System.Web.HttpResponse.ContentType%2A> 属性设置为 image/jpeg。

 [!code-csharp[System.Web.HttpResponse_Sample5#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Sample5/CS/httpresponseclearheaderscs.aspx#2)]
 [!code-vb[System.Web.HttpResponse_Sample5#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Sample5/VB/httpresponseclearheadersvb.aspx#2)]

 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">发送 HTTP 标头后清除标头。</exception>
        <altmember cref="M:System.Web.HttpResponse.ClearContent" />
      </Docs>
    </Member>
    <Member MemberName="ClientDisconnectedToken">
      <MemberSignature Language="C#" Value="public System.Threading.CancellationToken ClientDisconnectedToken { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Threading.CancellationToken ClientDisconnectedToken" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.ClientDisconnectedToken" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ClientDisconnectedToken As CancellationToken" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::CancellationToken ClientDisconnectedToken { System::Threading::CancellationToken get(); };" />
      <MemberSignature Language="F#" Value="member this.ClientDisconnectedToken : System.Threading.CancellationToken" Usage="System.Web.HttpResponse.ClientDisconnectedToken" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.CancellationToken</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取客户端断开连接时触发的 <see cref="T:System.Threading.CancellationToken" /> 对象。</summary>
        <value>取消标记。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 此 API 是线程安全的。 但对于应使用取消令牌的方式有一些限制。 如果使用不当，可能会导致争用条件、死锁或其他意外行为。 请记住以下准则：

-   确保不在单个请求的边界之外调用此 API，因为 ASP.NET 将在请求结束时释放取消标记。 不保证令牌在被释放之前将转换为已取消状态。 例如，如果请求在客户端没有断开连接的情况下完成，则会在未事先取消的情况下释放令牌。

-   不要等待 <xref:System.Threading.CancellationToken.WaitHandle%2A?displayProperty=nameWithType> ，因为这违背了异步通知的目的，并可能导致死锁。

-   不要调用对 <xref:System.Threading.CancellationToken.Register%2A?displayProperty=nameWithType> 原始对象调用回调的重载 <xref:System.Threading.SynchronizationContext> 。

-   不要在 <xref:System.Web.HttpContext> 提供给方法的回调中使用对象或其他非线程安全的 ASP.NET 内部对象 <xref:System.Threading.CancellationToken.Register%2A?displayProperty=nameWithType> 。 回调可能与其他 ASP.NET 或应用程序代码同时运行。

-   保留回调方法简短运行和非阻塞。

-   请尽力避免从回调方法中引发异常。

 此属性仅在集成模式下 (IIS) 7.5 或更高版本的 Internet 信息服务中受支持。 如果在没有正确的 IIS 版本或管道模式的情况下调用它，则 <xref:System.PlatformNotSupportedException> 会引发。 若要确定 IIS 版本，请使用 <xref:System.Web.HttpRuntime.IISVersion%2A> 。 若要确定管道模式，请使用 <xref:System.Web.HttpRuntime.UsingIntegratedPipeline%2A> 。

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberSignature Language="F#" Value="member this.Close : unit -&gt; unit" Usage="httpResponse.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>关闭到客户端的套接字连接。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 此方法会以突然的方式终止与客户端的连接，而不是用于正常的 HTTP 请求处理。 方法将重置数据包发送到客户端，这可能会导致在服务器上、客户端或之间的某个位置缓冲的响应数据被删除。

 但是， <xref:System.Web.HttpApplication.CompleteRequest%2A> 如果要跳转到 <xref:System.Web.HttpApplication.EndRequest> 事件并向客户端发送响应，则通常应调用。

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContentEncoding">
      <MemberSignature Language="C#" Value="public System.Text.Encoding ContentEncoding { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Text.Encoding ContentEncoding" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.ContentEncoding" />
      <MemberSignature Language="VB.NET" Value="Public Property ContentEncoding As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Text::Encoding ^ ContentEncoding { System::Text::Encoding ^ get(); void set(System::Text::Encoding ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ContentEncoding : System.Text.Encoding with get, set" Usage="System.Web.HttpResponse.ContentEncoding" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置输出流的 HTTP 字符集。</summary>
        <value>包含当前响应的字符集相关信息的 <see cref="T:System.Text.Encoding" /> 对象。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 `ContentEncoding`可以在 ASP.NET 配置文件中的配置文件中指定 Default， [ (ASP.NET Settings Schema) ](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/hy4kkhe0(v=vs.100))部分。 如果 <xref:System.Web.HttpResponse.ContentEncoding%2A> 客户端指定了，则将重写默认配置设置。



## Examples
 下面的示例将字符集编码的可读说明写入输出流。

 [!code-csharp[Classic HttpResponse.ContentEncoding Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.ContentEncoding Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.ContentEncoding Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.ContentEncoding Example/VB/source.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">尝试将 <see cref="P:System.Web.HttpResponse.ContentEncoding" /> 设置为 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="ContentType">
      <MemberSignature Language="C#" Value="public string ContentType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ContentType" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.ContentType" />
      <MemberSignature Language="VB.NET" Value="Public Property ContentType As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ContentType { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ContentType : string with get, set" Usage="System.Web.HttpResponse.ContentType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置输出流的 HTTP MIME 类型。</summary>
        <value>输出流的 HTTP MIME 类型。 默认值为“<see langword="text/html" />”。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Examples
 下面的示例设置对 <xref:System.Web.HttpResponse.ContentType%2A> image/jpeg 的响应的属性，调用 <xref:System.Web.HttpResponse.Clear%2A> 方法以删除可能附加到响应的其他内容，然后将 <xref:System.Web.HttpResponse.BufferOutput%2A> 属性设置为 true，以便在将任何内容发送到请求客户端之前处理整个页面。

 有关完整示例，请参阅 <xref:System.Web.HttpResponse> 类。

 [!code-csharp[System.Web.HttpResponse_Samples1#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Samples1/CS/responsesamplescs.aspx#2)]
 [!code-vb[System.Web.HttpResponse_Samples1#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Samples1/VB/responsesamplesvb.aspx#2)]

 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException"><see cref="P:System.Web.HttpResponse.ContentType" /> 属性设置为 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="Cookies">
      <MemberSignature Language="C#" Value="public System.Web.HttpCookieCollection Cookies { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpCookieCollection Cookies" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.Cookies" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Cookies As HttpCookieCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::HttpCookieCollection ^ Cookies { System::Web::HttpCookieCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Cookies : System.Web.HttpCookieCollection" Usage="System.Web.HttpResponse.Cookies" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.HttpCookieCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取响应 cookie 集合。</summary>
        <value>响应 cookie 集合。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 ASP.NET 包括两个内部 cookie 集合。 通过的集合访问的集合 <xref:System.Web.HttpRequest.Cookies%2A> <xref:System.Web.HttpRequest> 包含客户端向标头中的服务器传输的 cookie `Cookie` 。 通过的集合访问的集合 <xref:System.Web.HttpResponse.Cookies%2A> <xref:System.Web.HttpResponse> 包含在服务器上创建并在标头中传输到客户端的新 cookie `Set-Cookie` 。

 使用集合添加 cookie 后 <xref:System.Web.HttpResponse.Cookies%2A?displayProperty=nameWithType> ，cookie 会立即出现在 <xref:System.Web.HttpRequest.Cookies%2A?displayProperty=nameWithType> 集合中，即使尚未将响应发送到客户端也是如此。



## Examples
 下面的示例创建一个名为的新 cookie，将该 cookie 的 `LastVisit` 值设置为当前日期和时间，并将该 cookie 添加到当前 cookie 集合中。 Cookie 集合中的所有 cookie 都 `Set-Cookie` 通过 HTTP 输出流发送到标头中的客户端。

 [!code-csharp[Classic HttpResponse.Cookies Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.Cookies Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.Cookies Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.Cookies Example/VB/source.vb#1)]

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DisableKernelCache">
      <MemberSignature Language="C#" Value="public void DisableKernelCache ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DisableKernelCache() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.DisableKernelCache" />
      <MemberSignature Language="VB.NET" Value="Public Sub DisableKernelCache ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DisableKernelCache();" />
      <MemberSignature Language="F#" Value="member this.DisableKernelCache : unit -&gt; unit" Usage="httpResponse.DisableKernelCache " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>禁用当前响应的内核缓存。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 如果不支持内核缓存，则此方法不起作用。

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DisableUserCache">
      <MemberSignature Language="C#" Value="public void DisableUserCache ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DisableUserCache() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.DisableUserCache" />
      <MemberSignature Language="VB.NET" Value="Public Sub DisableUserCache ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DisableUserCache();" />
      <MemberSignature Language="F#" Value="member this.DisableUserCache : unit -&gt; unit" Usage="httpResponse.DisableUserCache " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>禁用 IIS 用户-方式来缓存反映。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 如果不支持 IIS 用户模式缓存，则此方法返回，而不执行任何操作。

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="End">
      <MemberSignature Language="C#" Value="public void End ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void End() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.End" />
      <MemberSignature Language="VB.NET" Value="Public Sub End ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void End();" />
      <MemberSignature Language="F#" Value="member this.End : unit -&gt; unit" Usage="httpResponse.End " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>将当前所有缓冲的输出发送到客户端，停止该页的执行，并引发 <see cref="E:System.Web.HttpApplication.EndRequest" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 提供此方法只是为了与 ASP 兼容-这就是与前面 ASP.NET 的基于 COM 的 Web 编程技术的兼容性。 如果你想要跳转到 <xref:System.Web.HttpApplication.EndRequest> 事件并向客户端发送响应，通常最好改为调用 <xref:System.Web.HttpApplication.CompleteRequest%2A> 。

 若要模仿 `End` asp.net 中的方法的行为，此方法会尝试引发 <xref:System.Threading.ThreadAbortException> 异常。 如果此尝试成功，则调用线程将中止，这会对你的站点性能产生不利后果。 在这种情况下，不会执行调用方法之后的任何代码 <xref:System.Web.HttpResponse.End%2A> 。

 如果该 <xref:System.Web.HttpResponse.End%2A> 方法无法引发 <xref:System.Threading.ThreadAbortException> ，则它会将响应字节刷新到客户端。 它会以同步方式执行此工作，这也可能会对站点性能产生不利后果。

 在任一情况下 (是否 <xref:System.Threading.ThreadAbortException> 已成功引发异常) ，响应管道将向前跳到 <xref:System.Web.HttpApplication.EndRequest> 事件。

 <xref:System.Web.HttpApplication.CompleteRequest%2A>方法不会引发异常，并且可能会执行对方法的调用后的代码 <xref:System.Web.HttpApplication.CompleteRequest%2A> 。 如果你的目的是避免执行后面的代码，并且可以接受的性能损失 <xref:System.Web.HttpResponse.End%2A> ，则可以调用 <xref:System.Web.HttpResponse.End%2A> 而不是 <xref:System.Web.HttpApplication.CompleteRequest%2A> 。

 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.ThreadAbortException">对 <see cref="M:System.Web.HttpResponse.End" /> 的调用已终止当前请求。</exception>
      </Docs>
    </Member>
    <Member MemberName="EndFlush">
      <MemberSignature Language="C#" Value="public void EndFlush (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EndFlush(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.EndFlush(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndFlush (asyncResult As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EndFlush(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="member this.EndFlush : IAsyncResult -&gt; unit" Usage="httpResponse.EndFlush asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="asyncResult">异步结果对象。</param>
        <summary>完成异步刷新操作。</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">不支持异步刷新，且 <paramref name="asyncResult" /> 参数为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">不支持异步刷新，且 <paramref name="asyncResult" /> 参数不能转换到 FlushAsyncResult<c></c> 对象。</exception>
      </Docs>
    </Member>
    <Member MemberName="Expires">
      <MemberSignature Language="C#" Value="public int Expires { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Expires" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.Expires" />
      <MemberSignature Language="VB.NET" Value="Public Property Expires As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Expires { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.Expires : int with get, set" Usage="System.Web.HttpResponse.Expires" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置在浏览器上缓存的页过期之前的分钟数。 如果用户在页面过期之前返回到该页，则显示缓存的版本。 提供 <see cref="P:System.Web.HttpResponse.Expires" />，以便兼容 ASP 的早期版本。</summary>
        <value>在页过期之前的分钟数。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 `Expires` <xref:System.Web.HttpResponse.ExpiresAbsolute%2A> <xref:System.Web.HttpResponse.CacheControl%2A> 通过内部对象获取的、和属性已弃用， <xref:System.Web.HttpCachePolicy> <xref:System.Web.HttpResponse.Cache%2A> 可用于控制 IIS) 输出缓存和客户端缓存 (Internet Information Services。

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ExpiresAbsolute">
      <MemberSignature Language="C#" Value="public DateTime ExpiresAbsolute { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime ExpiresAbsolute" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.ExpiresAbsolute" />
      <MemberSignature Language="VB.NET" Value="Public Property ExpiresAbsolute As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime ExpiresAbsolute { DateTime get(); void set(DateTime value); };" />
      <MemberSignature Language="F#" Value="member this.ExpiresAbsolute : DateTime with get, set" Usage="System.Web.HttpResponse.ExpiresAbsolute" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置从缓存中移删除缓存信息的绝对日期和时间。 提供 <see cref="P:System.Web.HttpResponse.ExpiresAbsolute" />，以便兼容 ASP 的早期版本。</summary>
        <value>该页过期时的日期和时间。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 `ExpiresAbsolute` <xref:System.Web.HttpResponse.Expires%2A> <xref:System.Web.HttpResponse.CacheControl%2A> 通过内部对象获取的、和属性已弃用， <xref:System.Web.HttpCachePolicy> <xref:System.Web.HttpResponse.Cache%2A> 可用于控制 IIS) 输出缓存和客户端缓存 (Internet Information Services。

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Filter">
      <MemberSignature Language="C#" Value="public System.IO.Stream Filter { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.Stream Filter" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.Filter" />
      <MemberSignature Language="VB.NET" Value="Public Property Filter As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Stream ^ Filter { System::IO::Stream ^ get(); void set(System::IO::Stream ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Filter : System.IO.Stream with get, set" Usage="System.Web.HttpResponse.Filter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个包装筛选器对象，该对象用于在传输之前修改 HTTP 实体主体。</summary>
        <value>作为输出筛选器的 <see cref="T:System.IO.Stream" /> 对象。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 创建 `Stream` 对象并将 <xref:System.Web.HttpResponse.Filter%2A> 属性设置为 `Stream` 对象时，通过筛选器发送的所有 HTTP 输出都将通过 <xref:System.Web.HttpResponse.Write%2A> 筛选器。



## Examples
 下面的示例是一个 ASP.NET 页，它将 <xref:System.Web.HttpResponse.Filter%2A> 属性设置为类的新实例 `UpperCaseFilter` ，这是一个自定义类，它 <xref:System.IO.Stream> 将通过其传递的所有文本转换为大写。 有关请求的信息保存到文本文件中，然后 <xref:System.Web.HttpResponse.Filter%2A> 设置属性。 响应筛选器就绪后，代码会调用 <xref:System.Web.HttpRequest.MapPath%2A> 方法来获取名为的文本文件的绝对路径，该文本文件用作 `TestFile.txt` 响应内容的源。 然后，该代码创建一个新的 <xref:System.IO.StreamReader> 对象来读取文本文件，然后调用 <xref:System.Web.HttpResponse.Write%2A> 方法以在页面上显示该文件的内容。

 [!code-aspx-csharp[System.Web.HttpRequest_Samples2#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest_Samples2/CS/requestsamples2cs.aspx#1)]
 [!code-aspx-vb[System.Web.HttpRequest_Samples2#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest_Samples2/VB/requestsamples2vb.aspx#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">不允许对实体进行筛选。</exception>
      </Docs>
    </Member>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public void Flush ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Flush() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.Flush" />
      <MemberSignature Language="VB.NET" Value="Public Sub Flush ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Flush();" />
      <MemberSignature Language="F#" Value="member this.Flush : unit -&gt; unit" Usage="httpResponse.Flush " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>向客户端发送当前所有缓冲的输出。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 强制将所有当前缓冲的输出发送到客户端。 在 <xref:System.Web.HttpResponse.Flush%2A> 请求处理过程中，可以多次调用方法。



## Examples
 下面的示例调用 <xref:System.Drawing.Graphics.Save%2A> 方法将 <xref:System.Drawing.Bitmap> 对象保存到 <xref:System.Web.HttpResponse.OutputStream%2A> 属性，并将图像转换为 JPEG 格式。 然后，该代码对 `Dispose` <xref:System.Drawing.Bitmap> 对象和对象调用方法 <xref:System.Drawing.Graphics> ，释放正在使用的资源。 然后，它调用 <xref:System.Web.HttpResponse.Flush%2A> 方法，将响应内容发送给请求的客户端。

 有关完整示例，请参阅 <xref:System.Web.HttpResponse> 类。

 [!code-aspx-csharp[System.Web.HttpResponse_Samples1#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Samples1/CS/responsesamplescs.aspx#1)]
 [!code-aspx-vb[System.Web.HttpResponse_Samples1#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Samples1/VB/responsesamplesvb.aspx#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">发送响应后刷新缓存。</exception>
      </Docs>
    </Member>
    <Member MemberName="FlushAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task FlushAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task FlushAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.FlushAsync" />
      <MemberSignature Language="VB.NET" Value="Public Function FlushAsync () As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ FlushAsync();" />
      <MemberSignature Language="F#" Value="member this.FlushAsync : unit -&gt; System.Threading.Tasks.Task" Usage="httpResponse.FlushAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>向客户端异步发送当前缓冲的所有输出。</summary>
        <returns>表示异步操作的 <see cref="T:System.Threading.Tasks.Task" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HeaderEncoding">
      <MemberSignature Language="C#" Value="public System.Text.Encoding HeaderEncoding { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Text.Encoding HeaderEncoding" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.HeaderEncoding" />
      <MemberSignature Language="VB.NET" Value="Public Property HeaderEncoding As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Text::Encoding ^ HeaderEncoding { System::Text::Encoding ^ get(); void set(System::Text::Encoding ^ value); };" />
      <MemberSignature Language="F#" Value="member this.HeaderEncoding : System.Text.Encoding with get, set" Usage="System.Web.HttpResponse.HeaderEncoding" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个 <see cref="T:System.Text.Encoding" /> 对象，该对象表示当前标头输出流的编码。</summary>
        <value>包含当前标头的字符集相关信息的 <see cref="T:System.Text.Encoding" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.Web.HttpResponse.HeaderEncoding%2A>属性使您能够 <xref:System.Text.Encoding> 通过使用 <xref:System.Text.ASCIIEncoding> 、 <xref:System.Text.UnicodeEncoding> 、 <xref:System.Text.UTF7Encoding> 或对象来禁用或更改响应标头上的对象 <xref:System.Text.UTF8Encoding> 。 默认编码值为 <xref:System.Text.UTF8Encoding> 类。

 通过更改属性的类型 <xref:System.Web.HttpResponse.HeaderEncoding%2A> ，可能会增加某些恶意攻击的风险，或导致通过响应标头发送敏感数据。 在部分中，可以通过将 <xref:System.Web.HttpResponse.HeaderEncoding%2A> 响应的属性保留为默认设置来避免标头注入攻击。 对易受攻击的应用程序的攻击可能会回显受保护的数据，作为响应标头的一部分。 如果 <xref:System.Web.HttpResponse.HeaderEncoding%2A> 因为标头中的延续行要求而禁用，或者根据不受信任的数据的结果构造了任何标头，则应在发送到响应流之前验证标头数据。

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">编码值为 <see langword="null" />。</exception>
        <exception cref="T:System.Web.HttpException">编码值为 <see cref="P:System.Text.Encoding.Unicode" />。

或

已发送标头。</exception>
      </Docs>
    </Member>
    <Member MemberName="Headers">
      <MemberSignature Language="C#" Value="public System.Collections.Specialized.NameValueCollection Headers { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Specialized.NameValueCollection Headers" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.Headers" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Headers As NameValueCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Specialized::NameValueCollection ^ Headers { System::Collections::Specialized::NameValueCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Headers : System.Collections.Specialized.NameValueCollection" Usage="System.Web.HttpResponse.Headers" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Specialized.NameValueCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取响应标头的集合。</summary>
        <value>响应标头的 <see cref="T:System.Collections.Specialized.NameValueCollection" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.Web.HttpResponse.Headers%2A>仅 [!INCLUDE[iisver](~/includes/iisver-md.md)] 集成管道模式支持属性，且至少支持 .NET Framework 3.0。 当你尝试访问该属性时，如果 <xref:System.Web.HttpResponse.Headers%2A> 不满足这两个条件中的任何一个，则 <xref:System.PlatformNotSupportedException> 会引发。

 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">该操作要求使用 [!INCLUDE[iisver](~/includes/iisver-md.md)] 中的集成管道模式，并且 .NET Framework 至少为 3.0 版本。</exception>
        <related type="ExternalDocumentation" href="/previous-versions/bb515251(v=vs.140)">将 ASP.NET 应用程序升级到 IIS 7。0</related>
      </Docs>
    </Member>
    <Member MemberName="HeadersWritten">
      <MemberSignature Language="C#" Value="public bool HeadersWritten { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HeadersWritten" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.HeadersWritten" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HeadersWritten As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HeadersWritten { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HeadersWritten : bool" Usage="System.Web.HttpResponse.HeadersWritten" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取指示是否已写入响应标头的值。</summary>
        <value>如果已写入响应标头，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsClientConnected">
      <MemberSignature Language="C#" Value="public bool IsClientConnected { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsClientConnected" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.IsClientConnected" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsClientConnected As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsClientConnected { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsClientConnected : bool" Usage="System.Web.HttpResponse.IsClientConnected" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，通过该值指示客户端是否仍连接在服务器上。</summary>
        <value>如果客户端当前仍在连接，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.Web.HttpResponse.IsClientConnected%2A> `false` 当满足以下条件时，属性将返回：

-   与客户端的连接已终止。 如果 <xref:System.Web.HttpResponse.Close%2A> 调用了方法，或者客户端停止了 Web 页的执行或浏览到其他页，则会发生这种情况。

-   <xref:System.Web.HttpWorkerRequest>处理请求的对象是 `null` 或 <xref:System.Web.HttpWorkerRequest.IsClientConnected%2A?displayProperty=nameWithType> 方法返回 `false` 。 如果自定义 <xref:System.Web.HttpWorkerRequest> 对象处理请求，则 <xref:System.Web.HttpWorkerRequest.IsClientConnected%2A?displayProperty=nameWithType> 可能会根据自定义条件设置方法。 例如，自定义工作请求可能会在一段时间后强制超时。



## Examples
 下面的示例使用 <xref:System.Web.HttpResponse.IsClientConnected%2A> 属性来检查请求该页的客户端是否仍连接到服务器。 如果 <xref:System.Web.HttpResponse.IsClientConnected%2A> 为 true，则代码将调用 <xref:System.Web.HttpResponse.Redirect%2A> 方法，并且客户端将查看另一页。 如果 <xref:System.Web.HttpResponse.IsClientConnected%2A> 为 false，则代码调用 <xref:System.Web.HttpResponse.End%2A> 方法并且终止所有页面处理。

 [!code-aspx-csharp[System.Web.HttpResponse_Sample4#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Sample4/CS/page1cs.aspx#1)]
 [!code-aspx-vb[System.Web.HttpResponse_Sample4#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Sample4/VB/page1vb.aspx#1)]

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsRequestBeingRedirected">
      <MemberSignature Language="C#" Value="public bool IsRequestBeingRedirected { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsRequestBeingRedirected" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.IsRequestBeingRedirected" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsRequestBeingRedirected As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsRequestBeingRedirected { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsRequestBeingRedirected : bool" Usage="System.Web.HttpResponse.IsRequestBeingRedirected" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取指示客户端是否正在被传输到新位置的布尔值。</summary>
        <value>如果位置响应标头的值与当前位置不同，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 将 <xref:System.Web.HttpResponse.IsRequestBeingRedirected%2A> 属性与属性结合使用， <xref:System.Web.HttpResponse.RedirectLocation%2A> 以测试和确定传输到 HTTP 标头中的客户端的绝对 uri 是否与 `Location` 当前 uri 不同，以及要传输到的新目标 URI。

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Output">
      <MemberSignature Language="C#" Value="public System.IO.TextWriter Output { get; }" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.TextWriter Output" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.Output" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Output As TextWriter" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::TextWriter ^ Output { System::IO::TextWriter ^ get(); };" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5" />
      <MemberSignature Language="F#" Value="member this.Output : System.IO.TextWriter" Usage="System.Web.HttpResponse.Output" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5" />
      <MemberSignature Language="C#" Value="public System.IO.TextWriter Output { get; set; }" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="VB.NET" Value="Public Property Output As TextWriter" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::TextWriter ^ Output { System::IO::TextWriter ^ get(); void set(System::IO::TextWriter ^ value); };" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="F#" Value="member this.Output : System.IO.TextWriter with get, set" Usage="System.Web.HttpResponse.Output" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.TextWriter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>实现到传出 HTTP 响应流的文本输出。</summary>
        <value>实现到客户端的自定义输出的 <see cref="T:System.IO.TextWriter" /> 对象。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Examples
 下面的示例是一个 ASP.NET 页，其中包含 <xref:System.Web.UI.WebControls.TextBox> 其 <xref:System.Web.UI.WebControls.TextBox.TextMode%2A> 属性设置为的控件 <xref:System.Web.UI.WebControls.TextBoxMode.MultiLine> 。 该页的代码使用用户在中输入的文本 <xref:System.Web.UI.WebControls.TextBox.TextMode%2A> ，使用 <xref:System.Web.HttpServerUtility.HtmlEncode%2A> 方法对其进行 HTML 编码，并使用 <xref:System.Web.HttpResponse.Output%2A> 属性将编码的字符串显示到页面。

 [!code-aspx-csharp[System.Web.HttpResponse.Output_Sample#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse.Output_Sample/CS/responseoutputcs.aspx#1)]
 [!code-aspx-vb[System.Web.HttpResponse.Output_Sample#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse.Output_Sample/VB/responseoutputvb.aspx#1)]

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OutputStream">
      <MemberSignature Language="C#" Value="public System.IO.Stream OutputStream { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.Stream OutputStream" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.OutputStream" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property OutputStream As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Stream ^ OutputStream { System::IO::Stream ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.OutputStream : System.IO.Stream" Usage="System.Web.HttpResponse.OutputStream" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>实现到传出 HTTP 内容主体的二进制输出。</summary>
        <value>表示传出 HTTP 内容主体的原始内容的 IO <see cref="T:System.IO.Stream" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 从 .NET Framework 版本2.0 开始，当你使用 <xref:System.IO.Stream.Write%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType> 属性返回的 IO 流的方法时 <xref:System.Web.HttpResponse.OutputStream%2A> ，可能会引发以下异常：

-   <xref:System.ArgumentOutOfRangeException>如果 `offset` 或 `count` 参数为负，或者 `buffer` 参数的长度减去 `offset` 参数小于或等于零，则为。

-   <xref:System.ArgumentNullException>如果 `buffer` 参数为，则为 `null` 。



## Examples
 下面的示例调用 <xref:System.Drawing.Image.Save%2A> 方法将 <xref:System.Drawing.Bitmap> 对象保存到 <xref:System.Web.HttpResponse.OutputStream%2A> 属性，并将图像转换为 JPEG 格式。 然后，该代码对 <xref:System.Drawing.Bitmap> 对象和对象调用 Dispose 方法 <xref:System.Drawing.Graphics> ，释放正在使用的资源。 最后，该代码调用 <xref:System.Web.HttpResponse.Flush%2A> 方法以将响应内容发送给请求的客户端。

 有关完整示例，请参阅 <xref:System.Web.HttpResponse> 类。

 [!code-aspx-csharp[System.Web.HttpResponse_Samples1#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Samples1/CS/responsesamplescs.aspx#1)]
 [!code-aspx-vb[System.Web.HttpResponse_Samples1#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Samples1/VB/responsesamplesvb.aspx#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException"><paramref name="OutputStream" /> 不可用。</exception>
      </Docs>
    </Member>
    <Member MemberName="Pics">
      <MemberSignature Language="C#" Value="public void Pics (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Pics(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.Pics(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Pics (value As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Pics(System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.Pics : string -&gt; unit" Usage="httpResponse.Pics value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">要添加到 <see langword="PICS-Label" /> 标头的字符串。</param>
        <summary>将 HTTP <see langword="PICS-Label" /> 标头追加到输出流。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 用于 Internet 内容选择的平台 (图片) 是万维网联合会 (W3C) 标准来标记内容。 图片实质上是一种用于创建分级系统的语言。

 任何值都可以是图片标签;ASP.NET 不会验证标签。 字符串的最大长度为255个字符。 有关图片标准和语法的详细信息，请参阅 [万维网联合会](https://www.w3.org/) 网站。

## Examples
 下面的示例是一个显示图像的 ASP.NET 页面。 页面代码会调用 <xref:System.Web.HttpResponse.Pics%2A> 方法，以设置响应的 HTTP `PICS-Label` 标头。 作为参数传递给方法的字符串 <xref:System.Web.HttpResponse.Pics%2A> 表示从 Internet 内容分级关联 (ICRA) 网站生成的评级标签。

 [!code-aspx-csharp[System.Web.HttpResponse_Sample4#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Sample4/CS/page2cs.aspx#2)]
 [!code-aspx-vb[System.Web.HttpResponse_Sample4#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Sample4/VB/page2vb.aspx#2)]

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="PushPromise">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>提升承诺的对象。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="PushPromise">
      <MemberSignature Language="C#" Value="public void PushPromise (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void PushPromise(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.PushPromise(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub PushPromise (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void PushPromise(System::String ^ path);" />
      <MemberSignature Language="F#" Value="member this.PushPromise : string -&gt; unit" Usage="httpResponse.PushPromise path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="path">推送请求的 URL。 它应为服务器想要推送到客户端的相对资源的虚拟路径。</param>
        <summary>支持将推送承诺发送到 HTTP 2.0 客户端的应用程序。 有关详细信息，请参阅 <see href="https://httpwg.org/specs/rfc7540.html#PushResources">HTTP/2 规范 8.2 节：服务器推送</see>。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 PushPromise 是不确定性的，应用程序不应具有依赖于它的逻辑。 在某些情况下，其唯一用途是性能优势。 存在许多 (协议和实现) 的条件，这可能会导致推送请求被忽略。 预期的基于火灾。

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PushPromise">
      <MemberSignature Language="C#" Value="public void PushPromise (string path, string method, System.Collections.Specialized.NameValueCollection headers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void PushPromise(string path, string method, class System.Collections.Specialized.NameValueCollection headers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.PushPromise(System.String,System.String,System.Collections.Specialized.NameValueCollection)" />
      <MemberSignature Language="VB.NET" Value="Public Sub PushPromise (path As String, method As String, headers As NameValueCollection)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void PushPromise(System::String ^ path, System::String ^ method, System::Collections::Specialized::NameValueCollection ^ headers);" />
      <MemberSignature Language="F#" Value="member this.PushPromise : string * string * System.Collections.Specialized.NameValueCollection -&gt; unit" Usage="httpResponse.PushPromise (path, method, headers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="method" Type="System.String" Index="1" FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="headers" Type="System.Collections.Specialized.NameValueCollection" Index="2" FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="path">推送请求的 URL。 它应为服务器想要推送到客户端的相对资源的虚拟路径。</param>
        <param name="method">将由推送请求使用的 http 请求方法。</param>
        <param name="headers">将由推送请求使用的 http 请求头。</param>
        <summary>支持将推送承诺发送到 HTTP 2.0 客户端的应用程序。 有关详细信息，请参阅 <see href="https://httpwg.org/specs/rfc7540.html#PushResources">HTTP/2 规范 8.2 节：服务器推送</see>。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 PushPromise 是不确定性的，应用程序不应具有依赖于它的逻辑。 在某些情况下，其唯一用途是性能优势。 存在许多 (协议和实现) 的条件，这可能会导致推送请求被忽略。 预期的基于火灾。

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Redirect">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>将客户端重定向到新的 URL。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Redirect">
      <MemberSignature Language="C#" Value="public void Redirect (string url);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Redirect(string url) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.Redirect(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Redirect (url As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Redirect(System::String ^ url);" />
      <MemberSignature Language="F#" Value="member this.Redirect : string -&gt; unit" Usage="httpResponse.Redirect url" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="url" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="url">目标位置。 这可能是相对于应用程序的虚拟路径。</param>
        <summary>将请求重定向到新 URL 并指定该新 URL。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 调用 <xref:System.Web.HttpResponse.Redirect%2A> 等效于 <xref:System.Web.HttpResponse.Redirect%2A> 在第二个参数设置为的情况调用 `true` 。

 <xref:System.Web.HttpResponse.Redirect%2A><xref:System.Web.HttpResponse.End%2A> <xref:System.Threading.ThreadAbortException> 完成后引发异常的调用。 此例外会对 Web 应用程序性能产生不利影响。 因此，建议不要使用此重载，而是使用 <xref:System.Web.HttpResponse.Redirect%28System.String%2CSystem.Boolean%29?displayProperty=nameWithType> 重载并传递 `false` `endResponse` 参数，然后调用 <xref:System.Web.HttpApplication.CompleteRequest%2A> 方法。 有关更多信息，请参见 <xref:System.Web.HttpResponse.End%2A> 方法。

> [!NOTE]
> 仅对于移动页面，如果你的应用程序依赖于无 cookie 会话，或可能接收到需要无 cookie 会话的移动设备发出的请求，则在路径中使用波形符 (\~) 会导致创建新的会话，可能会丢失会话数据。 若要使用路径（如 "/path"）设置移动控件上的属性 \~ ，请在将路径 <xref:System.Web.UI.MobileControls.MobileControl.ResolveUrl%2A> \~ 分配给属性之前使用 "/path" 解析该路径。

 ASP.NET 通过返回 302 HTTP 状态代码来执行重定向。 将控制转移到另一页的另一种方法是 <xref:System.Web.HttpServerUtility.Transfer%2A> 方法。 <xref:System.Web.HttpServerUtility.Transfer%2A>方法通常更高效，因为它不会导致到客户端的往返。 有关详细信息，请参阅 [如何：将用户重定向到另一页](https://docs.microsoft.com/previous-versions/aspnet/540y83hx(v=vs.100))。

## Examples
 以下示例强制将无条件重定向到另一个网站。

 [!code-csharp[Classic HttpResponse.Redirect Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.Redirect Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.Redirect Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.Redirect Example/VB/source.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">发送 HTTP 标头之后尝试重定向。</exception>
      </Docs>
    </Member>
    <Member MemberName="Redirect">
      <MemberSignature Language="C#" Value="public void Redirect (string url, bool endResponse);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Redirect(string url, bool endResponse) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.Redirect(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Redirect (url As String, endResponse As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Redirect(System::String ^ url, bool endResponse);" />
      <MemberSignature Language="F#" Value="member this.Redirect : string * bool -&gt; unit" Usage="httpResponse.Redirect (url, endResponse)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="url" Type="System.String" />
        <Parameter Name="endResponse" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="url">目标的位置。</param>
        <param name="endResponse">指示当前页的执行是否应终止。</param>
        <summary>将客户端重定向到新的 URL。 指定新的 URL 并指定当前页的执行是否应终止。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 绝对 URL (例如 `http://www.contoso.com/default.aspx`) 或相对 URL (例如，可为目标位置指定 default.aspx) ，但某些浏览器可能会拒绝相对 url。

 当你在页面处理程序中使用此方法终止一个页面请求并为另一个页面启动新请求时，将设置 `endResponse` 为， `false` 然后调用 <xref:System.Web.HttpApplication.CompleteRequest%2A> 方法。 如果 `true` 为 `endResponse` 参数指定，则此方法将 <xref:System.Web.HttpResponse.End%2A> 为原始请求调用方法，该方法在 <xref:System.Threading.ThreadAbortException> 完成时将引发异常。 此例外会对 Web 应用程序性能产生不利影响，这就是为什么建议为参数传递的原因 `false` `endResponse` 。 有关更多信息，请参见 <xref:System.Web.HttpResponse.End%2A> 方法。

> [!NOTE]
> 对于移动页面，如果你的应用程序依赖于无 cookie 会话，或者可能接收到需要无 cookie 会话的移动设备发出的请求，则使用路径中的波形符 (\~) 可以创建新的会话，并可能丢失会话数据。 若要使用路径（如 "/path"）设置移动控件上的属性 \~ ，请在将路径 <xref:System.Web.UI.MobileControls.MobileControl.ResolveUrl%2A> \~ 分配给属性之前使用 "/path" 解析该路径。

 ASP.NET 通过返回 302 HTTP 状态代码来执行重定向。 将控制转移到另一页的另一种方法是 <xref:System.Web.HttpServerUtility.Transfer%2A> 方法。 <xref:System.Web.HttpServerUtility.Transfer%2A>方法通常更高效，因为它不会导致到客户端的往返。 有关详细信息，请参阅 [如何：将用户重定向到另一页](https://docs.microsoft.com/previous-versions/aspnet/540y83hx(v=vs.100))。

## Examples
 下面的示例使用 <xref:System.Web.HttpResponse.IsClientConnected%2A> 属性来检查请求该页的客户端是否仍连接到服务器。 如果 <xref:System.Web.HttpResponse.IsClientConnected%2A> 为 true，则代码将调用 <xref:System.Web.HttpResponse.Redirect%2A> 方法，并且客户端将查看另一页。 如果 <xref:System.Web.HttpResponse.IsClientConnected%2A> 为 false，则代码调用 <xref:System.Web.HttpResponse.End%2A> 方法并且终止所有页面处理。

 [!code-aspx-csharp[System.Web.HttpResponse_Sample4#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Sample4/CS/page1cs.aspx#1)]
 [!code-aspx-vb[System.Web.HttpResponse_Sample4#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Sample4/VB/page1vb.aspx#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="url" /> 上声明的默认值为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="url" /> 包含换行符。</exception>
        <exception cref="T:System.Web.HttpException">发送 HTTP 标头之后尝试重定向。</exception>
        <exception cref="T:System.ApplicationException">该页面请求是回调的结果。</exception>
      </Docs>
    </Member>
    <Member MemberName="RedirectLocation">
      <MemberSignature Language="C#" Value="public string RedirectLocation { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string RedirectLocation" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.RedirectLocation" />
      <MemberSignature Language="VB.NET" Value="Public Property RedirectLocation As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ RedirectLocation { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.RedirectLocation : string with get, set" Usage="System.Web.HttpResponse.RedirectLocation" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置 HTTP <see langword="Location" /> 标头的值。</summary>
        <value>通过 HTTP <see langword="Location" /> 标头传输到客户端的绝对 URI。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Examples
 下面的示例演示如何使用此属性来指定在通过使用 HTTP 301 响应代码对永久重定向进行编码时的重定向 URL。

```csharp
Response.StatusCode = 301;
Response.Status = "301 Moved Permanently";
Response.RedirectLocation = "http://www.newurl.com ";
Response.End();
```

 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">已编写 HTTP 标头。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="RedirectPermanent">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>执行从所请求 URL 到所指定 URL 的永久重定向。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RedirectPermanent">
      <MemberSignature Language="C#" Value="public void RedirectPermanent (string url);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RedirectPermanent(string url) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RedirectPermanent(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RedirectPermanent (url As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RedirectPermanent(System::String ^ url);" />
      <MemberSignature Language="F#" Value="member this.RedirectPermanent : string -&gt; unit" Usage="httpResponse.RedirectPermanent url" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="url" Type="System.String" Index="0" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="url">要将请求重定向至的位置。</param>
        <summary>执行从所请求 URL 到所指定 URL 的永久重定向。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.Web.HttpResponse.RedirectPermanent%28System.String%29>方法重载在响应中提供 301 HTTP 状态代码，并包含用于将请求重定向到的 URL。 301 HTTP 状态代码是 HTTP 响应中的标准代码。 它指示存在永久重定向，并且它提供重定向位置。

 调用 <xref:System.Web.HttpResponse.RedirectPermanent%28System.String%29> 方法重载会终止响应。

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="url" /> 上声明的默认值为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="url" /> 包括一个换行符 (<c>\n</c>)。</exception>
      </Docs>
    </Member>
    <Member MemberName="RedirectPermanent">
      <MemberSignature Language="C#" Value="public void RedirectPermanent (string url, bool endResponse);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RedirectPermanent(string url, bool endResponse) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RedirectPermanent(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RedirectPermanent (url As String, endResponse As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RedirectPermanent(System::String ^ url, bool endResponse);" />
      <MemberSignature Language="F#" Value="member this.RedirectPermanent : string * bool -&gt; unit" Usage="httpResponse.RedirectPermanent (url, endResponse)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="url" Type="System.String" Index="0" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="endResponse" Type="System.Boolean" Index="1" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="url">要将请求重定向到其中的位置。</param>
        <param name="endResponse">若要终止响应，则为 <see langword="true" />；否则为 <see langword="false" />。 默认值为 <see langword="false" />。</param>
        <summary>执行从所请求 URL 到所指定 URL 的永久重定向，并提供用于完成响应的选项。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.Web.HttpResponse.RedirectPermanent%28System.String%2CSystem.Boolean%29>方法重载在响应中提供 301 HTTP 状态代码，并包含用于将请求重定向到的 URL。 此方法重载还提供了用于指定是否在执行重定向后终止或完成响应的选项。 301 HTTP 状态代码是 HTTP 响应中的标准代码。 它指示存在永久重定向，并且它提供重定向位置。

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="url" /> 上声明的默认值为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="url" /> 包括一个换行符 (<c>\n</c>)。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="RedirectToRoute">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>使用路由参数值和/或路由名称将请求重定向到新 URL。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RedirectToRoute">
      <MemberSignature Language="C#" Value="public void RedirectToRoute (object routeValues);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RedirectToRoute(object routeValues) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RedirectToRoute(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RedirectToRoute (routeValues As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RedirectToRoute(System::Object ^ routeValues);" />
      <MemberSignature Language="F#" Value="member this.RedirectToRoute : obj -&gt; unit" Usage="httpResponse.RedirectToRoute routeValues" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeValues" Type="System.Object" Index="0" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="routeValues">路由参数值。</param>
        <summary>使用路由参数值将请求重定向到新 URL。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 提供此方法是为了便于编码。 它等效于调用 <xref:System.Web.HttpResponse.Redirect%28System.String%2CSystem.Boolean%29> 方法，并将第二个参数设置为 `false` 。

 此方法使用构造函数将传入的对象转换 `routeValues` 为 <xref:System.Web.Routing.RouteValueDictionary?displayProperty=nameWithType> 对象 <xref:System.Web.Routing.RouteValueDictionary.%23ctor%28System.Object%29?displayProperty=nameWithType> 。 <xref:System.Web.Routing.RouteCollection.GetVirtualPath%2A?displayProperty=nameWithType>然后调用方法来确定 URL。

 ASP.NET 通过返回 302 HTTP 状态代码来执行重定向。

## Examples
 下面的示例演示如何调用此方法以重定向到具有名为和的参数的路由 `productid` `category` 。

```vb
Response.RedirectToRoute(
  New With {.productid = "1", .category = "widgets"})
```

```csharp
Response.RedirectToRoute(
  new { productid = "1", category = "widgets" });
```

 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">没有与指定路由参数对应的路由。</exception>
        <exception cref="T:System.Web.HttpException">在发送 HTTP 标头之后尝试进行重定向。</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/cc668201(v=vs.100)">ASP.NET 路由</related>
      </Docs>
    </Member>
    <Member MemberName="RedirectToRoute">
      <MemberSignature Language="C#" Value="public void RedirectToRoute (string routeName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RedirectToRoute(string routeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RedirectToRoute(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RedirectToRoute (routeName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RedirectToRoute(System::String ^ routeName);" />
      <MemberSignature Language="F#" Value="member this.RedirectToRoute : string -&gt; unit" Usage="httpResponse.RedirectToRoute routeName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeName" Type="System.String" Index="0" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="routeName">路由的名称。</param>
        <summary>使用路由名称将请求重定向到新 URL。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 提供此方法是为了便于编码。 它等效于调用 <xref:System.Web.HttpResponse.Redirect%28System.String%2CSystem.Boolean%29> 方法，并将第二个参数设置为 `false` 。

 此方法使用方法将传入的路由名称转换 `routeName` 为 URL <xref:System.Web.Routing.RouteCollection.GetVirtualPath%2A?displayProperty=nameWithType> 。

 ASP.NET 通过返回 302 HTTP 状态代码来执行重定向。

## Examples
 下面的示例演示如何调用此方法以重定向到名为的路由 `Products` 。

```vb
Response.RedirectToRoute("Products")
```

```csharp
Response.RedirectToRoute("Products");
```

 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">没有与指定路由参数对应的路由。</exception>
        <exception cref="T:System.Web.HttpException">在发送 HTTP 标头之后尝试进行重定向。</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/cc668201(v=vs.100)">ASP.NET 路由</related>
      </Docs>
    </Member>
    <Member MemberName="RedirectToRoute">
      <MemberSignature Language="C#" Value="public void RedirectToRoute (System.Web.Routing.RouteValueDictionary routeValues);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RedirectToRoute(class System.Web.Routing.RouteValueDictionary routeValues) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RedirectToRoute(System.Web.Routing.RouteValueDictionary)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RedirectToRoute (routeValues As RouteValueDictionary)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RedirectToRoute(System::Web::Routing::RouteValueDictionary ^ routeValues);" />
      <MemberSignature Language="F#" Value="member this.RedirectToRoute : System.Web.Routing.RouteValueDictionary -&gt; unit" Usage="httpResponse.RedirectToRoute routeValues" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeValues" Type="System.Web.Routing.RouteValueDictionary" Index="0" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="routeValues">路由参数值。</param>
        <summary>使用路由参数值将请求重定向到新 URL。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 提供此方法是为了便于编码。 它等效于调用 <xref:System.Web.HttpResponse.Redirect%28System.String%2CSystem.Boolean%29> 方法，并将第二个参数设置为 `false` 。

 此方法调用 <xref:System.Web.Routing.RouteCollection.GetVirtualPath%2A?displayProperty=nameWithType> 方法来确定 URL。

 ASP.NET 通过返回 302 HTTP 状态代码来执行重定向。

## Examples
 下面的示例演示如何调用此方法以重定向到具有名为和的参数的路由 `productid` `category` 。

```vb
Response.RedirectToRoute(
  new RouteValueDictionary {productId="1", category="widgets"})
```

```csharp
Response.RedirectToRoute(
  (new RouteValueDictionary {productId="1", category="widgets"});
```

 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">没有与指定路由参数对应的路由。</exception>
        <exception cref="T:System.Web.HttpException">在发送 HTTP 标头之后尝试进行重定向。</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/cc668201(v=vs.100)">ASP.NET 路由</related>
      </Docs>
    </Member>
    <Member MemberName="RedirectToRoute">
      <MemberSignature Language="C#" Value="public void RedirectToRoute (string routeName, object routeValues);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RedirectToRoute(string routeName, object routeValues) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RedirectToRoute(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RedirectToRoute (routeName As String, routeValues As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RedirectToRoute(System::String ^ routeName, System::Object ^ routeValues);" />
      <MemberSignature Language="F#" Value="member this.RedirectToRoute : string * obj -&gt; unit" Usage="httpResponse.RedirectToRoute (routeName, routeValues)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeName" Type="System.String" Index="0" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="routeValues" Type="System.Object" Index="1" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="routeName">路由的名称。</param>
        <param name="routeValues">路由参数值。</param>
        <summary>使用路由参数值和路由名称将请求重定向到新 URL。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 提供此方法是为了便于编码。 它等效于调用 <xref:System.Web.HttpResponse.Redirect%28System.String%2CSystem.Boolean%29> 方法，并将第二个参数设置为 `false` 。

 此方法使用构造函数将传入的对象转换 `routeValues` 为 <xref:System.Web.Routing.RouteValueDictionary?displayProperty=nameWithType> 对象 <xref:System.Web.Routing.RouteValueDictionary.%23ctor%28System.Object%29?displayProperty=nameWithType> 。 <xref:System.Web.Routing.RouteCollection.GetVirtualPath%2A?displayProperty=nameWithType>然后调用方法来确定 URL。

 ASP.NET 通过返回 302 HTTP 状态代码来执行重定向。

## Examples
 下面的示例演示如何调用此方法以重定向到名为 `Product` 且具有名为和的参数的路由 `productid` `category` 。

```vb
Response.RedirectToRoute("Product",
  New With {.productid = "1", .category = "widgets"})
```

```csharp
Response.RedirectToRoute("Product",
  new { productid = "1", category = "widgets" });
```

 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">没有与指定路由参数对应的路由。</exception>
        <exception cref="T:System.Web.HttpException">在发送 HTTP 标头之后尝试进行重定向。</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/cc668201(v=vs.100)">ASP.NET 路由</related>
      </Docs>
    </Member>
    <Member MemberName="RedirectToRoute">
      <MemberSignature Language="C#" Value="public void RedirectToRoute (string routeName, System.Web.Routing.RouteValueDictionary routeValues);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RedirectToRoute(string routeName, class System.Web.Routing.RouteValueDictionary routeValues) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RedirectToRoute(System.String,System.Web.Routing.RouteValueDictionary)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RedirectToRoute (routeName As String, routeValues As RouteValueDictionary)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RedirectToRoute(System::String ^ routeName, System::Web::Routing::RouteValueDictionary ^ routeValues);" />
      <MemberSignature Language="F#" Value="member this.RedirectToRoute : string * System.Web.Routing.RouteValueDictionary -&gt; unit" Usage="httpResponse.RedirectToRoute (routeName, routeValues)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeName" Type="System.String" Index="0" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="routeValues" Type="System.Web.Routing.RouteValueDictionary" Index="1" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="routeName">路由的名称。</param>
        <param name="routeValues">路由参数值。</param>
        <summary>使用路由参数值和路由名称将请求重定向到新 URL。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 提供此方法是为了便于编码。 它等效于调用 <xref:System.Web.HttpResponse.Redirect%28System.String%2CSystem.Boolean%29> 方法，并将第二个参数设置为 `false` 。

 <xref:System.Web.Routing.RouteCollection.GetVirtualPath%2A?displayProperty=nameWithType>调用方法来确定 URL。

 ASP.NET 通过返回 302 HTTP 状态代码来执行重定向。

## Examples
 下面的示例演示如何调用此方法以重定向到名为 `Product` 且具有名为和的参数的路由 `productid` `category` 。

```vb
Response.RedirectToRoute("Product",
  new RouteValueDictionary {productId="1", category="widgets"})
```

```csharp
Response.RedirectToRoute("Product",
  (new RouteValueDictionary {productId="1", category="widgets"});
```

 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">没有与指定路由参数对应的路由。</exception>
        <exception cref="T:System.Web.HttpException">在发送 HTTP 标头之后尝试进行重定向。</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/cc668201(v=vs.100)">ASP.NET 路由</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="RedirectToRoutePermanent">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>使用路由参数值和/或路由名称执行从所请求 URL 到新 URL 的永久重定向。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RedirectToRoutePermanent">
      <MemberSignature Language="C#" Value="public void RedirectToRoutePermanent (object routeValues);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RedirectToRoutePermanent(object routeValues) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RedirectToRoutePermanent(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RedirectToRoutePermanent (routeValues As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RedirectToRoutePermanent(System::Object ^ routeValues);" />
      <MemberSignature Language="F#" Value="member this.RedirectToRoutePermanent : obj -&gt; unit" Usage="httpResponse.RedirectToRoutePermanent routeValues" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeValues" Type="System.Object" Index="0" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="routeValues">路由参数值。</param>
        <summary>使用路由参数值执行从所请求 URL 到新 URL 的永久重定向。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 提供此方法是为了便于编码。 它等效于调用 <xref:System.Web.HttpResponse.RedirectPermanent%28System.String%2CSystem.Boolean%29> 方法，并将第二个参数设置为 `false` 。

 此方法使用构造函数将传入的对象转换 `routeValues` 为 <xref:System.Web.Routing.RouteValueDictionary?displayProperty=nameWithType> 对象 <xref:System.Web.Routing.RouteValueDictionary.%23ctor%28System.Object%29?displayProperty=nameWithType> 。 <xref:System.Web.Routing.RouteCollection.GetVirtualPath%2A?displayProperty=nameWithType>然后调用方法来确定 URL。

 ASP.NET 通过返回 301 HTTP 状态代码来执行重定向。

## Examples
 下面的示例演示如何调用此方法以重定向到具有名为和的参数的路由 `productid` `category` 。

```vb
Response.RedirectToRoutePermanent(
  New With {.productid = "1", .category = "widgets"})
```

```csharp
Response.RedirectToRoutePermanent(
  new { productid = "1", category = "widgets" });
```

 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">没有与指定路由参数对应的路由。</exception>
        <exception cref="T:System.Web.HttpException">在发送 HTTP 标头之后尝试进行重定向。</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/cc668201(v=vs.100)">ASP.NET 路由</related>
      </Docs>
    </Member>
    <Member MemberName="RedirectToRoutePermanent">
      <MemberSignature Language="C#" Value="public void RedirectToRoutePermanent (string routeName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RedirectToRoutePermanent(string routeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RedirectToRoutePermanent(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RedirectToRoutePermanent (routeName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RedirectToRoutePermanent(System::String ^ routeName);" />
      <MemberSignature Language="F#" Value="member this.RedirectToRoutePermanent : string -&gt; unit" Usage="httpResponse.RedirectToRoutePermanent routeName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeName" Type="System.String" Index="0" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="routeName">路由的名称。</param>
        <summary>使用路由名称执行从所请求 URL 到新 URL 的永久重定向。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 提供此方法是为了便于编码。 它等效于调用 <xref:System.Web.HttpResponse.RedirectPermanent%28System.String%2CSystem.Boolean%29> 方法，并将第二个参数设置为 `false` 。

 此方法使用方法将传入的路由名称转换 `routeName` 为 URL <xref:System.Web.Routing.RouteCollection.GetVirtualPath%2A?displayProperty=nameWithType> 。

 ASP.NET 通过返回 301 HTTP 状态代码来执行重定向。

## Examples
 下面的示例演示如何调用此方法以重定向到名为的路由 `Products` 。

```vb
Response.RedirectToRoutePermanent("Products")
```

```csharp
Response.RedirectToRoutePermanent("Products");
```

 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">没有与指定路由参数对应的路由。</exception>
        <exception cref="T:System.Web.HttpException">在发送 HTTP 标头之后尝试进行重定向。</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/cc668201(v=vs.100)">ASP.NET 路由</related>
      </Docs>
    </Member>
    <Member MemberName="RedirectToRoutePermanent">
      <MemberSignature Language="C#" Value="public void RedirectToRoutePermanent (System.Web.Routing.RouteValueDictionary routeValues);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RedirectToRoutePermanent(class System.Web.Routing.RouteValueDictionary routeValues) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RedirectToRoutePermanent(System.Web.Routing.RouteValueDictionary)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RedirectToRoutePermanent (routeValues As RouteValueDictionary)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RedirectToRoutePermanent(System::Web::Routing::RouteValueDictionary ^ routeValues);" />
      <MemberSignature Language="F#" Value="member this.RedirectToRoutePermanent : System.Web.Routing.RouteValueDictionary -&gt; unit" Usage="httpResponse.RedirectToRoutePermanent routeValues" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeValues" Type="System.Web.Routing.RouteValueDictionary" Index="0" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="routeValues">路由参数值。</param>
        <summary>使用路由参数值执行从所请求 URL 到新 URL 的永久重定向。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 提供此方法是为了便于编码。 它等效于调用 <xref:System.Web.HttpResponse.Redirect%28System.String%2CSystem.Boolean%29> 方法，并将第二个参数设置为 `false` 。

 此方法调用 <xref:System.Web.Routing.RouteCollection.GetVirtualPath%2A?displayProperty=nameWithType> 方法来确定 URL。

 ASP.NET 通过返回 301 HTTP 状态代码来执行重定向。

## Examples
 下面的示例演示如何调用此方法以重定向到具有名为和的参数的路由 `productid` `category` 。

```vb
Response.RedirectToRoutePermanent(
  new RouteValueDictionary {productId="1", category="widgets"})
```

```csharp
Response.RedirectToRoutePermanent(
  new RouteValueDictionary {productId="1", category="widgets"});
```

 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">没有与指定路由参数对应的路由。</exception>
        <exception cref="T:System.Web.HttpException">在发送 HTTP 标头之后尝试进行重定向。</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/cc668201(v=vs.100)">ASP.NET 路由</related>
      </Docs>
    </Member>
    <Member MemberName="RedirectToRoutePermanent">
      <MemberSignature Language="C#" Value="public void RedirectToRoutePermanent (string routeName, object routeValues);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RedirectToRoutePermanent(string routeName, object routeValues) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RedirectToRoutePermanent(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RedirectToRoutePermanent (routeName As String, routeValues As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RedirectToRoutePermanent(System::String ^ routeName, System::Object ^ routeValues);" />
      <MemberSignature Language="F#" Value="member this.RedirectToRoutePermanent : string * obj -&gt; unit" Usage="httpResponse.RedirectToRoutePermanent (routeName, routeValues)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeName" Type="System.String" Index="0" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="routeValues" Type="System.Object" Index="1" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="routeName">路由的名称。</param>
        <param name="routeValues">路由参数值。</param>
        <summary>使用路由参数值以及与新 URL 对应的路由的名称执行从所请求 URL 到新 URL 的永久重定向。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 提供此方法是为了便于编码。 它等效于调用 <xref:System.Web.HttpResponse.RedirectPermanent%2A> 方法，并将第二个参数设置为 `false` 。

 此方法使用构造函数将传入的对象转换 `routeValues` 为 <xref:System.Web.Routing.RouteValueDictionary?displayProperty=nameWithType> 对象 <xref:System.Web.Routing.RouteValueDictionary.%23ctor%28System.Object%29?displayProperty=nameWithType> 。 <xref:System.Web.Routing.RouteCollection.GetVirtualPath%2A?displayProperty=nameWithType>然后调用方法来确定 URL。

 ASP.NET 通过返回 301 HTTP 状态代码来执行重定向。

## Examples
 下面的示例演示如何调用此方法以重定向到名为 `Product` 且具有名为和的参数的路由 `productid` `category` 。

```vb
Response.RedirectToRoutePermanent("Product",
  New With {.productid = "1", .category = "widgets"})
```

```csharp
Response.RedirectToRoutePermanent("Product",
  new { productid = "1", category = "widgets" });
```

 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">没有与指定路由参数对应的路由。</exception>
        <exception cref="T:System.Web.HttpException">在发送 HTTP 标头之后尝试进行重定向。</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/cc668201(v=vs.100)">ASP.NET 路由</related>
      </Docs>
    </Member>
    <Member MemberName="RedirectToRoutePermanent">
      <MemberSignature Language="C#" Value="public void RedirectToRoutePermanent (string routeName, System.Web.Routing.RouteValueDictionary routeValues);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RedirectToRoutePermanent(string routeName, class System.Web.Routing.RouteValueDictionary routeValues) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RedirectToRoutePermanent(System.String,System.Web.Routing.RouteValueDictionary)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RedirectToRoutePermanent (routeName As String, routeValues As RouteValueDictionary)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RedirectToRoutePermanent(System::String ^ routeName, System::Web::Routing::RouteValueDictionary ^ routeValues);" />
      <MemberSignature Language="F#" Value="member this.RedirectToRoutePermanent : string * System.Web.Routing.RouteValueDictionary -&gt; unit" Usage="httpResponse.RedirectToRoutePermanent (routeName, routeValues)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeName" Type="System.String" Index="0" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="routeValues" Type="System.Web.Routing.RouteValueDictionary" Index="1" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="routeName">路由的名称。</param>
        <param name="routeValues">路由参数值。</param>
        <summary>使用路由参数值和路由名称执行从所请求 URL 到新 URL 的永久重定向。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 提供此方法是为了便于编码。 它等效于调用 <xref:System.Web.HttpResponse.Redirect%28System.String%2CSystem.Boolean%29> 方法，并将第二个参数设置为 `false` 。

 此方法调用 <xref:System.Web.Routing.RouteCollection.GetVirtualPath%2A?displayProperty=nameWithType> 方法来确定 URL。

 ASP.NET 通过返回 301 HTTP 状态代码来执行重定向。

## Examples
 下面的示例演示如何调用此方法以重定向到名为 `Product` 且具有名为和的参数的路由 `productid` `category` 。

```vb
Response.RedirectToRoutePermanent("Product",
  new RouteValueDictionary {productId="1", category="widgets"})
```

```csharp
Response.RedirectToRoutePermanent("Product",
  new RouteValueDictionary {productId="1", category="widgets"});
```

 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">没有与指定路由参数对应的路由。</exception>
        <exception cref="T:System.Web.HttpException">在发送 HTTP 标头之后尝试进行重定向。</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/cc668201(v=vs.100)">ASP.NET 路由</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="RemoveOutputCacheItem">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>使用默认的输出缓存提供程序从输出缓存中删除缓存项。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RemoveOutputCacheItem">
      <MemberSignature Language="C#" Value="public static void RemoveOutputCacheItem (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemoveOutputCacheItem(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RemoveOutputCacheItem(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RemoveOutputCacheItem (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RemoveOutputCacheItem(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member RemoveOutputCacheItem : string -&gt; unit" Usage="System.Web.HttpResponse.RemoveOutputCacheItem path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">已从缓存中移除的项的虚拟绝对路径。</param>
        <summary>从缓存中移除与默认输出缓存提供程序关联的所有缓存项。 此方法是静态的。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 调用此方法可移除与默认输出缓存提供程序关联的输出缓存项。 调用 <xref:System.Web.HttpResponse.RemoveOutputCacheItem%2A> 方法以删除与在网站配置文件中指定的自定义输出缓存提供程序关联的输出缓存项。

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> 上声明的默认值为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> 并非绝对虚拟路径。</exception>
      </Docs>
    </Member>
    <Member MemberName="RemoveOutputCacheItem">
      <MemberSignature Language="C#" Value="public static void RemoveOutputCacheItem (string path, string providerName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemoveOutputCacheItem(string path, string providerName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RemoveOutputCacheItem(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RemoveOutputCacheItem (path As String, providerName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RemoveOutputCacheItem(System::String ^ path, System::String ^ providerName);" />
      <MemberSignature Language="F#" Value="static member RemoveOutputCacheItem : string * string -&gt; unit" Usage="System.Web.HttpResponse.RemoveOutputCacheItem (path, providerName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="providerName" Type="System.String" Index="1" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="path">从缓存中删除的项的虚拟绝对路径。</param>
        <param name="providerName">用于删除与指定路径关联的输出缓存项的提供程序。</param>
        <summary>使用指定的输出缓存提供程序删除所有与指定路径关联的输出缓存项。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 调用此方法可删除与网站配置文件中指定的自定义输出缓存提供程序关联的输出缓存项。 若要删除与默认输出缓存提供程序关联的输出缓存项，请调用 <xref:System.Web.HttpResponse.RemoveOutputCacheItem%28System.String%29> 方法重载。

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> 为 null。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> 是无效路径。</exception>
      </Docs>
    </Member>
    <Member MemberName="SetCookie">
      <MemberSignature Language="C#" Value="public void SetCookie (System.Web.HttpCookie cookie);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetCookie(class System.Web.HttpCookie cookie) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.SetCookie(System.Web.HttpCookie)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetCookie (cookie As HttpCookie)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetCookie(System::Web::HttpCookie ^ cookie);" />
      <MemberSignature Language="F#" Value="member this.SetCookie : System.Web.HttpCookie -&gt; unit" Usage="httpResponse.SetCookie cookie" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cookie" Type="System.Web.HttpCookie" />
      </Parameters>
      <Docs>
        <param name="cookie">集合中要更新的 Cookie。</param>
        <summary>因为 HttpResponse.SetCookie<b></b> 方法仅供内部使用，所以不应在代码中调用该方法。 可以改为调用 HttpResponse.Cookies.Set<b></b> 方法，如以下示例所示。<br /> 更新 cookie 集合中的现有 cookie。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Examples
 下面的示例更新现有 cookie 的值。

 [!code-csharp[Classic HttpResponse.SetCookie Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.SetCookie Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.SetCookie Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.SetCookie Example/VB/source.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">已尝试在发送 HTTP 标头之后设置 Cookie。</exception>
        <altmember cref="F:System.Net.HttpRequestHeader.Cookie" />
        <altmember cref="T:System.Web.HttpCookie" />
        <altmember cref="T:System.Web.HttpCookieMode" />
      </Docs>
    </Member>
    <Member MemberName="Status">
      <MemberSignature Language="C#" Value="public string Status { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Status" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.Status" />
      <MemberSignature Language="VB.NET" Value="Public Property Status As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Status { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Status : string with get, set" Usage="System.Web.HttpResponse.Status" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>设置返回到客户端的 <see langword="Status" /> 栏。</summary>
        <value>设置状态代码会使描述 HTTP 输出状态的字符串返回到客户端。 默认值为 200 (OK)。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.Web.HttpResponse.Status%2A> 已不推荐使用 <xref:System.Web.HttpResponse.StatusDescription%2A> ，提供它仅是为了与 ASP 的早期版本兼容。 对于 ASP.NET，请 <xref:System.Web.HttpResponse.StatusDescription%2A> 改用。

 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">状态设置为无效的状态代码。</exception>
      </Docs>
    </Member>
    <Member MemberName="StatusCode">
      <MemberSignature Language="C#" Value="public int StatusCode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 StatusCode" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.StatusCode" />
      <MemberSignature Language="VB.NET" Value="Public Property StatusCode As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int StatusCode { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.StatusCode : int with get, set" Usage="System.Web.HttpResponse.StatusCode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置返回给客户端的输出的 HTTP 状态代码。</summary>
        <value>表示返回到客户端的 HTTP 输出状态的整数。 默认值为 200 (OK)。 有关有效状态代码的列表，请参阅 <see href="/windows/win32/winhttp/http-status-codes">HTTP 状态代码</see>。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Examples
 下面的示例检查输出流的状态代码。 如果状态代码不等于200，则执行其他代码。

 [!code-csharp[System.Web.HttpResponse.StatusCode#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse.StatusCode/cs/default.aspx#1)]
 [!code-vb[System.Web.HttpResponse.StatusCode#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse.StatusCode/vb/default.aspx#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">发送 HTTP 标头后设置 <see cref="P:System.Web.HttpResponse.StatusCode" />。</exception>
        <altmember cref="P:System.Web.HttpResponse.SubStatusCode" />
      </Docs>
    </Member>
    <Member MemberName="StatusDescription">
      <MemberSignature Language="C#" Value="public string StatusDescription { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string StatusDescription" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.StatusDescription" />
      <MemberSignature Language="VB.NET" Value="Public Property StatusDescription As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ StatusDescription { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.StatusDescription : string with get, set" Usage="System.Web.HttpResponse.StatusDescription" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置返回给客户端的输出的 HTTP 状态字符串。</summary>
        <value>一个字符串，描述返回给客户端的 HTTP 输出的状态。 默认值为 "OK"。 有关有效状态代码的列表，请参阅 <see href="/windows/win32/winhttp/http-status-codes">HTTP 状态代码</see>。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Examples
 下面的示例检查输出流的状态字符串。 如果状态不等于 "确定"，则执行其他代码。

 [!code-csharp[System.Web.HttpResponse.StatusDescription#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse.StatusDescription/cs/default.aspx#1)]
 [!code-vb[System.Web.HttpResponse.StatusDescription#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse.StatusDescription/vb/default.aspx#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">发送 HTTP 标头后设置 <paramref name="StatusDescription" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">所选值的长度大于 512。</exception>
      </Docs>
    </Member>
    <Member MemberName="SubStatusCode">
      <MemberSignature Language="C#" Value="public int SubStatusCode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 SubStatusCode" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.SubStatusCode" />
      <MemberSignature Language="VB.NET" Value="Public Property SubStatusCode As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int SubStatusCode { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.SubStatusCode : int with get, set" Usage="System.Web.HttpResponse.SubStatusCode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个限定响应的状态代码的值。</summary>
        <value>表示 [!INCLUDE[iisver](~/includes/iisver-md.md)] 子状态代码的整数值。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 此 <xref:System.Web.HttpResponse.SubStatusCode%2A> 属性仅支持中的集成管道模式 [!INCLUDE[iisver](~/includes/iisver-md.md)] ，并且至少支持 .NET Framework 版本3.0。 设置 <xref:System.Web.HttpResponse.SubStatusCode%2A> 属性时， [!INCLUDE[iisver](~/includes/iisver-md.md)] 如果配置了 failed-请求跟踪，状态将为 "已登录"。 不管是否配置了跟踪，都不会将代码作为最终响应的一部分发送到请求。 有关详细信息，请参阅 [IIS 7.0 中的使用失败请求跟踪对失败请求进行故障排除](http://www.iis.net/default.aspx?tabid=2&subtabid=25&i=969&p=1)。

## Examples
 下面的示例在事件的事件 <xref:System.Web.HttpResponse.SubStatusCode%2A> 处理程序中设置属性 <xref:System.Web.HttpApplication> <xref:System.Web.HttpApplication.PostAuthenticateRequest> 。 将代码文件放在 Web 应用程序的 App_Code 文件夹中，并将 Web.config 文件配置为注册该模块。 有关详细信息，请参阅 [演练：创建和注册自定义 HTTP 模块](https://docs.microsoft.com/previous-versions/aspnet/ms227673(v=vs.100))。

 [!code-csharp[System.Web.HttpResponse.SubStatusCode#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse.SubStatusCode/CS/App_Code/TestModule.cs#1)]
 [!code-vb[System.Web.HttpResponse.SubStatusCode#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse.SubStatusCode/VB/App_Code/TestModule.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">该操作要求使用 [!INCLUDE[iisver](~/includes/iisver-md.md)] 中的集成管道模式，并且 .NET Framework 至少为 3.0 版本。</exception>
        <exception cref="T:System.Web.HttpException">状态代码在发送完所有 HTTP 标头之后设置。</exception>
        <altmember cref="P:System.Web.HttpResponse.StatusCode" />
      </Docs>
    </Member>
    <Member MemberName="SupportsAsyncFlush">
      <MemberSignature Language="C#" Value="public bool SupportsAsyncFlush { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SupportsAsyncFlush" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.SupportsAsyncFlush" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SupportsAsyncFlush As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool SupportsAsyncFlush { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.SupportsAsyncFlush : bool" Usage="System.Web.HttpResponse.SupportsAsyncFlush" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示集合是否支持异步刷新操作。</summary>
        <value>如果连接支持异步刷新操作，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 此属性返回属性的值 <xref:System.Web.HttpWorkerRequest.SupportsAsyncFlush%2A?displayProperty=nameWithType> 。

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SuppressContent">
      <MemberSignature Language="C#" Value="public bool SuppressContent { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SuppressContent" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.SuppressContent" />
      <MemberSignature Language="VB.NET" Value="Public Property SuppressContent As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool SuppressContent { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.SuppressContent : bool with get, set" Usage="System.Web.HttpResponse.SuppressContent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指示是否将 HTTP 内容发送到客户端。</summary>
        <value>若要取消输出，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Examples
 下面的示例检查属性是否 <xref:System.Web.HttpRequest.IsSecureConnection%2A> 设置为 false。 如果是，则将 <xref:System.Web.HttpResponse.SuppressContent%2A> 属性设置为 true 以停止发送响应。

 [!code-csharp[System.Web.HttpResponse_Sample5#3](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Sample5/CS/httpresponsesuppresscontentcs.aspx#3)]
 [!code-vb[System.Web.HttpResponse_Sample5#3](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Sample5/VB/httpresponsesuppresscontentvb.aspx#3)]

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SuppressDefaultCacheControlHeader">
      <MemberSignature Language="C#" Value="public bool SuppressDefaultCacheControlHeader { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SuppressDefaultCacheControlHeader" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.SuppressDefaultCacheControlHeader" />
      <MemberSignature Language="VB.NET" Value="Public Property SuppressDefaultCacheControlHeader As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool SuppressDefaultCacheControlHeader { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.SuppressDefaultCacheControlHeader : bool with get, set" Usage="System.Web.HttpResponse.SuppressDefaultCacheControlHeader" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指示是否取消默认缓存控件：当前 HTTP 响应的专用<c></c>标头。</summary>
        <value><see langword="true" /> 若要取消默认 <c>缓存控件：</c> 当前 HTTP 响应的专用标头;否则为 <see langword="false" /> 。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 默认情况下， `Cache-Control: private` 除非已为此响应指定了显式缓存策略，否则 ASP.NET 将发送响应标头。 此属性允许基于每个请求禁止显示此默认响应标头。 对于整个应用程序，仍可以通过 <xref:System.Web.Configuration.HttpRuntimeSection.SendCacheControlHeader%2A> 在 HttpRuntime 元素中设置 [ (ASP.NET settings schema) ](/previous-versions/dotnet/netframework-4.0/e1f13641(v=vs.100)) 或 [outputCache 元素进行缓存 (ASP.NET 设置架构) ](/previous-versions/dotnet/netframework-4.0/ms228124(v=vs.100))来禁止显示该标头。

 取消默认标头时要格外小心 `Cache-Control: private` ，因为代理和其他中介可以在默认情况下将没有此标头的响应视为可缓存。 此处理可能导致无意中缓存敏感信息。 有关详细信息，请参阅[RFC 2616，秒13.4。](https://tools.ietf.org/html/rfc2616)

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SuppressFormsAuthenticationRedirect">
      <MemberSignature Language="C#" Value="public bool SuppressFormsAuthenticationRedirect { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SuppressFormsAuthenticationRedirect" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.SuppressFormsAuthenticationRedirect" />
      <MemberSignature Language="VB.NET" Value="Public Property SuppressFormsAuthenticationRedirect As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool SuppressFormsAuthenticationRedirect { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.SuppressFormsAuthenticationRedirect : bool with get, set" Usage="System.Web.HttpResponse.SuppressFormsAuthenticationRedirect" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置指定重定向至登录页的 forms 身份验证是否应取消的值。</summary>
        <value>如果应取消窗体身份认证重定向，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 默认情况下，forms 身份验证将 HTTP 401 状态代码转换为302，以便重定向到登录页。 这并不适用于某些错误类，例如当身份验证成功但授权失败，或者当前请求是 AJAX 或 web 服务请求时。 此属性提供了一种方式来禁止重定向行为，并将原始状态代码发送到客户端。

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="TransmitFile">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>将指定的文件直接写入 HTTP 响应输出流，而不在内存中缓冲该文件。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TransmitFile">
      <MemberSignature Language="C#" Value="public void TransmitFile (string filename);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void TransmitFile(string filename) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.TransmitFile(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub TransmitFile (filename As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void TransmitFile(System::String ^ filename);" />
      <MemberSignature Language="F#" Value="member this.TransmitFile : string -&gt; unit" Usage="httpResponse.TransmitFile filename" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filename" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="filename">要写入 HTTP 输出的文件名。</param>
        <summary>将指定的文件直接写入 HTTP 响应输出流，而不在内存中缓冲该文件。</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="filename" /> 参数为 <see langword="null" /></exception>
      </Docs>
    </Member>
    <Member MemberName="TransmitFile">
      <MemberSignature Language="C#" Value="public void TransmitFile (string filename, long offset, long length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void TransmitFile(string filename, int64 offset, int64 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.TransmitFile(System.String,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub TransmitFile (filename As String, offset As Long, length As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void TransmitFile(System::String ^ filename, long offset, long length);" />
      <MemberSignature Language="F#" Value="member this.TransmitFile : string * int64 * int64 -&gt; unit" Usage="httpResponse.TransmitFile (filename, offset, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filename" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="offset" Type="System.Int64" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="length" Type="System.Int64" Index="2" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="filename">要写入 HTTP 输出的文件名。</param>
        <param name="offset">文件中的位置，将从该位置开始将内容写入到 HTTP 输出中。</param>
        <param name="length">要传输的字节数。</param>
        <summary>将文件的指定部分直接写入 HTTP 响应输出流，而不在内存中缓冲它。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 如果将0指定为 `offset` 参数，并将-1 指定为 `length` 参数，则将发送整个文件。

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="offset" /> 参数小于零。

或

<paramref name="length" /> 参数小于 -1。

或

<paramref name="length" /> 参数指定的字节数大于文件包含的字节数减去偏移值得到的数值。</exception>
        <exception cref="T:System.PlatformNotSupportedException">不支持进程外辅助请求。

或

响应不使用 <see cref="T:System.Web.HttpWriter" /> 对象。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="offset" /> 参数小于零或大于文件大小。

或

<paramref name="length" /> 参数小于 -1 或大于 <paramref name="offset" /> 参数加上文件大小的值。</exception>
      </Docs>
    </Member>
    <Member MemberName="TrySkipIisCustomErrors">
      <MemberSignature Language="C#" Value="public bool TrySkipIisCustomErrors { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool TrySkipIisCustomErrors" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.TrySkipIisCustomErrors" />
      <MemberSignature Language="VB.NET" Value="Public Property TrySkipIisCustomErrors As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool TrySkipIisCustomErrors { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.TrySkipIisCustomErrors : bool with get, set" Usage="System.Web.HttpResponse.TrySkipIisCustomErrors" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置指定是否禁用 [!INCLUDE[iisver](~/includes/iisver-md.md)] 自定义错误的值。</summary>
        <value>若要禁用 IIS 自定义错误，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.Web.HttpResponse.TrySkipIisCustomErrors%2A>仅当你的应用程序托管在 IIS 7.0 和更高版本中时，才使用此属性。 在经典模式下运行时， <xref:System.Web.HttpResponse.TrySkipIisCustomErrors%2A> 属性的默认值为 `true` 。 在集成模式下运行时， <xref:System.Web.HttpResponse.TrySkipIisCustomErrors%2A> 属性的默认值为 `false` 。

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Write">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>将信息写入 HTTP 响应输出流。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public void Write (char ch);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Write(char ch) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.Write(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Write (ch As Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Write(char ch);" />
      <MemberSignature Language="F#" Value="member this.Write : char -&gt; unit" Usage="httpResponse.Write ch" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ch" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="ch">要写入 HTTP 输出流的字符。</param>
        <summary>将一个字符写入 HTTP 响应输出流。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Examples
 下面的示例创建一系列使用 Write 方法写入到 ASP.NET 页的常量。 此代码将调用此写入方法版本，以将单个字符常量写入页面。

 [!code-aspx-csharp[System.Web.HttpResponse_Sample5#4](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Sample5/CS/httpresponsewritecharscs.aspx#4)]
 [!code-aspx-vb[System.Web.HttpResponse_Sample5#4](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Sample5/VB/httpresponsewritecharsvb.aspx#4)]

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public void Write (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Write(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.Write(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Write (obj As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Write(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="member this.Write : obj -&gt; unit" Usage="httpResponse.Write obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">要写入 HTTP 输出流的 <see cref="T:System.Object" />。</param>
        <summary>将 <see cref="T:System.Object" /> 写入 HTTP 响应流。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public void Write (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Write(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.Write(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Write (s As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Write(System::String ^ s);" />
      <MemberSignature Language="F#" Value="member this.Write : string -&gt; unit" Usage="httpResponse.Write s" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">要写入 HTTP 输出流的字符串。</param>
        <summary>将字符串写入 HTTP 响应输出流。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 如果从 Web 客户端接收到从客户端接收的输入或将其传输回客户端，则动态生成的 HTML 页面可能会带来安全风险。 嵌入到输入网站并稍后写回客户端的输入中的恶意脚本可能看似来自受信任的源。 此安全风险称为跨站点脚本攻击。 应始终验证从客户端传输到客户端浏览器时从客户端收到的数据。

 而且，无论何时以 HTML 形式写出作为输入接收的任何数据，都应使用一种技术（如或）对其进行编码， <xref:System.Web.HttpServerUtility.HtmlEncode%2A> <xref:System.Web.HttpServerUtility.UrlEncode%2A> 以防止恶意脚本执行。 此方法适用于接收时未验证的数据。

 编码或筛选数据时，必须为网页指定字符集，以便筛选器可以识别并删除任何不属于该集的字节序列 (如非字母数字序列) 并且可能会嵌入恶意脚本。

## Examples
 下面的示例将客户端的名称回显到客户端的浏览器。 <xref:System.Web.HttpServerUtility.HtmlEncode%2A>方法去除了可能在输入字段中提交的任何恶意脚本和无效字符 `UserName` 。

 [!code-csharp[System.Web.HttpResponse.Write#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse.Write/CS/systemwebhttpresponsewrite.cs#1)]
 [!code-vb[System.Web.HttpResponse.Write#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse.Write/vb/systemwebhttpresponsewrite.vb#1)]

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public void Write (char[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Write(char[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.Write(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Write (buffer As Char(), index As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Write(cli::array &lt;char&gt; ^ buffer, int index, int count);" />
      <MemberSignature Language="F#" Value="member this.Write : char[] * int * int -&gt; unit" Usage="httpResponse.Write (buffer, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Char[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">要写入的字符数组。</param>
        <param name="index">字符数组中开始进行写入的位置。</param>
        <param name="count">从 <paramref name="index" /> 开始写入的字符数。</param>
        <summary>将字符数组写入 HTTP 响应输出流。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Examples
 下面的示例创建一系列使用 Write 方法写入到 ASP.NET 页的常量。 此代码将调用此写入方法版本，以将单个字符常量写入页面。

 [!code-aspx-csharp[System.Web.HttpResponse_Sample5#4](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Sample5/CS/httpresponsewritecharscs.aspx#4)]
 [!code-aspx-vb[System.Web.HttpResponse_Sample5#4](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Sample5/VB/httpresponsewritecharsvb.aspx#4)]

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteFile">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>将指定的文件直接写入 HTTP 响应输出流。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteFile">
      <MemberSignature Language="C#" Value="public void WriteFile (string filename);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteFile(string filename) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.WriteFile(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteFile (filename As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteFile(System::String ^ filename);" />
      <MemberSignature Language="F#" Value="member this.WriteFile : string -&gt; unit" Usage="httpResponse.WriteFile filename" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filename" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="filename">要写入 HTTP 输出的文件名。</param>
        <summary>将指定文件的内容作为文件块直接写入 HTTP 响应输出流。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 将此方法用于大型文件时，调用方法可能会引发异常。 可与此方法一起使用的文件的大小取决于 Web 服务器的硬件配置。

## Examples
 下面的示例将名为 (的文本文件的所有内容写入 `Login.txt` 到输出流，该文件可能包含文字 HTML 文本和输入控件) 。

 [!code-csharp[Classic HttpResponse.WriteFile Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.WriteFile Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.WriteFile Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.WriteFile Example/VB/source.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="filename" /> 参数为 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteFile">
      <MemberSignature Language="C#" Value="public void WriteFile (string filename, bool readIntoMemory);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteFile(string filename, bool readIntoMemory) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.WriteFile(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteFile (filename As String, readIntoMemory As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteFile(System::String ^ filename, bool readIntoMemory);" />
      <MemberSignature Language="F#" Value="member this.WriteFile : string * bool -&gt; unit" Usage="httpResponse.WriteFile (filename, readIntoMemory)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filename" Type="System.String" />
        <Parameter Name="readIntoMemory" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="filename">要写入内存块的文件名。</param>
        <param name="readIntoMemory">指示是否将把文件写入内存块。</param>
        <summary>将指定文件的内容作为内存块直接写入 HTTP 响应输出流。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 将此方法用于大型文件时，调用方法可能会引发异常。 可与此方法一起使用的文件的大小取决于 Web 服务器的硬件配置。

## Examples
 下面的示例将文件写入内存。

 [!code-csharp[Classic HttpResponse.WriteFile1 Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.WriteFile1 Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.WriteFile1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.WriteFile1 Example/VB/source.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="filename" /> 参数为 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteFile">
      <MemberSignature Language="C#" Value="public void WriteFile (IntPtr fileHandle, long offset, long size);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteFile(native int fileHandle, int64 offset, int64 size) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.WriteFile(System.IntPtr,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteFile (fileHandle As IntPtr, offset As Long, size As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteFile(IntPtr fileHandle, long offset, long size);" />
      <MemberSignature Language="F#" Value="member this.WriteFile : nativeint * int64 * int64 -&gt; unit" Usage="httpResponse.WriteFile (fileHandle, offset, size)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileHandle" Type="System.IntPtr" />
        <Parameter Name="offset" Type="System.Int64" />
        <Parameter Name="size" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="fileHandle">要写入 HTTP 输出流的文件的文件句柄。</param>
        <param name="offset">文件中将开始进行写入的字节位置。</param>
        <param name="size">要写入输出流的字节数。</param>
        <summary>将指定的文件直接写入 HTTP 响应输出流。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 将此方法用于大型文件时，调用方法可能会引发异常。 可与此方法一起使用的文件的大小取决于 Web 服务器的硬件配置。

## Examples
 下面的示例将名为 (的文本文件的所有内容写入 `Login.txt` 到输出流，该文件可能包含文字 HTML 文本和输入控件) 。

 [!code-csharp[Classic HttpResponse.WriteFile3 Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.WriteFile3 Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.WriteFile3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.WriteFile3 Example/VB/source.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="fileHandler" /> 上声明的默认值为 <see langword="null" />。</exception>
        <exception cref="T:System.Web.HttpException"><paramref name="offset" /> 小于 0。

或

 <paramref name="size" /> 大于文件大小与 <paramref name="offset" /> 之差。</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteFile">
      <MemberSignature Language="C#" Value="public void WriteFile (string filename, long offset, long size);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteFile(string filename, int64 offset, int64 size) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.WriteFile(System.String,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteFile (filename As String, offset As Long, size As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteFile(System::String ^ filename, long offset, long size);" />
      <MemberSignature Language="F#" Value="member this.WriteFile : string * int64 * int64 -&gt; unit" Usage="httpResponse.WriteFile (filename, offset, size)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filename" Type="System.String" />
        <Parameter Name="offset" Type="System.Int64" />
        <Parameter Name="size" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="filename">要写入 HTTP 输出流的文件名。</param>
        <param name="offset">文件中将开始进行写入的字节位置。</param>
        <param name="size">要写入输出流的字节数。</param>
        <summary>将指定的文件直接写入 HTTP 响应输出流。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 将此方法用于大型文件时，调用方法可能会引发异常。 可与此方法一起使用的文件的大小取决于 Web 服务器的硬件配置。

## Examples
 下面的示例将名为 (的文本文件的所有内容 `Login.txt` （可能包含文本文本和 HTML 输入控件) 直接写入输出流）。

 [!code-csharp[Classic HttpResponse.WriteFile2 Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.WriteFile2 Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.WriteFile2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.WriteFile2 Example/VB/source.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException"><paramref name="offset" /> 小于 0。

或

 <paramref name="size" /> 大于文件大小与 <paramref name="offset" /> 之差。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="filename" /> 参数为 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteSubstitution">
      <MemberSignature Language="C#" Value="public void WriteSubstitution (System.Web.HttpResponseSubstitutionCallback callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteSubstitution(class System.Web.HttpResponseSubstitutionCallback callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.WriteSubstitution(System.Web.HttpResponseSubstitutionCallback)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteSubstitution (callback As HttpResponseSubstitutionCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteSubstitution(System::Web::HttpResponseSubstitutionCallback ^ callback);" />
      <MemberSignature Language="F#" Value="member this.WriteSubstitution : System.Web.HttpResponseSubstitutionCallback -&gt; unit" Usage="httpResponse.WriteSubstitution callback" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.Web.HttpResponseSubstitutionCallback" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="callback">要替换的方法、用户控件或对象。</param>
        <summary>允许将响应替换块插入响应，从而允许为缓存的输出响应动态生成指定的响应区域。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 可以 <xref:System.Web.HttpResponse.WriteSubstitution%2A> 在输出缓存的页中将方法用于缓存后替换。 通过将 <xref:System.Web.HttpContext> 对象传递给具有规定签名的回调方法 <xref:System.Web.HttpResponseSubstitutionCallback> ，你可以将输出缓存内容替换到页面缓存中的任何给定位置。 若要启动替换，请调用 <xref:System.Web.HttpResponse.WriteSubstitution%2A> 方法，并向其传递回调方法，该方法必须是线程安全的，并且可以是以下两种方法之一：

-   容器页或用户控件上的静态方法。

-   其他任意对象上的静态方法或实例方法。

 在第一次请求页面时，将 <xref:System.Web.HttpResponse.WriteSubstitution%2A> 调用 <xref:System.Web.HttpResponseSubstitutionCallback> 委托以生成输出。 然后，它会将替换缓冲区添加到响应中，这将保留委托以便在将来的请求时调用。 最后，它将客户端可缓存性从公共降级到仅服务器，确保以后向页面发出的请求不会在客户端上缓存的情况下重新调用委托。

> [!NOTE]
>  对于在用户控件级别应用输出缓存的缓存用户控件，不支持缓存后替换。 这也称为片段缓存。 有关详细信息，请参阅 [缓存部分 ASP.NET 页面](https://docs.microsoft.com/previous-versions/aspnet/h30h475z(v=vs.100))。

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="callback" /> 参数的目标的为 <see cref="T:System.Web.UI.Control" /> 类型。</exception>
        <altmember cref="T:System.Web.HttpResponseSubstitutionCallback" />
        <altmember cref="T:System.Web.UI.WebControls.Substitution" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/w9s3a17d(v=vs.100)">设置页面的可缓存性</related>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/h30h475z(v=vs.100)">缓存 ASP.NET 页面的部分</related>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/ms227429(v=vs.100)">动态更新缓存页面的部分</related>
      </Docs>
    </Member>
  </Members>
</Type>
