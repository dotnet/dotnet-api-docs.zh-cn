<Type Name="HttpContext" FullName="System.Web.HttpContext">
  <Metadata><Meta Name="ms.openlocfilehash" Value="052d0da6863451bb5199e80b6da4a038f9b242c6" /><Meta Name="ms.sourcegitcommit" Value="9f423345753728e8cad38d4a22663a109e69ea91" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-CN" /><Meta Name="ms.lasthandoff" Value="03/04/2021" /><Meta Name="ms.locfileid" Value="102089429" /></Metadata><TypeSignature Language="C#" Value="public sealed class HttpContext : IServiceProvider" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit HttpContext extends System.Object implements class System.IServiceProvider" />
  <TypeSignature Language="DocId" Value="T:System.Web.HttpContext" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class HttpContext&#xA;Implements IServiceProvider" />
  <TypeSignature Language="C++ CLI" Value="public ref class HttpContext sealed : IServiceProvider" />
  <TypeSignature Language="F#" Value="type HttpContext = class&#xA;    interface IServiceProvider" />
  <AssemblyInfo>
    <AssemblyName>System.Web</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IServiceProvider</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>封装有关个别 HTTP 请求的所有 HTTP 特定的信息。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[

## Remarks
 继承 <xref:System.Web.IHttpModule> 和接口的类 <xref:System.Web.IHttpHandler> 提供 <xref:System.Web.HttpContext> 当前 HTTP 请求的对象的引用。 对象提供对请求的内部 <xref:System.Web.HttpContext.Request%2A> 、 <xref:System.Web.HttpContext.Response%2A> 和属性的访问 <xref:System.Web.HttpContext.Server%2A> 。

> [!IMPORTANT]
> 完成后，此对象可用于垃圾回收 <xref:System.Web.HttpRequest> 。 请求完成后，其使用可能导致未定义的行为，例如 <xref:System.NullReferenceException> 。
>
> 此对象仅在由 ASP.NET 控制的线程中可用。 后台线程中的使用情况可能导致未定义的行为。

## Examples
 下面的示例演示如何访问和显示对象的属性 <xref:System.Web.HttpContext> 。 使用对象的属性访问当前 HTTP 请求的上下文 <xref:System.Web.UI.Page.Context%2A> <xref:System.Web.UI.Page> 。

 [!code-aspx-csharp[System.Web.HttpContext#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpContext/cs/httpcontextcs.aspx#1)]
 [!code-aspx-vb[System.Web.HttpContext#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpContext/vb/httpcontextvb.aspx#1)]

 ]]></format>
    </remarks>
    <altmember cref="T:System.Web.IHttpModule" />
    <altmember cref="T:System.Web.IHttpHandler" />
    <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkId=196730">上下文问题</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>初始化 <see cref="T:System.Web.HttpContext" /> 类的新实例。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public HttpContext (System.Web.HttpWorkerRequest wr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Web.HttpWorkerRequest wr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.#ctor(System.Web.HttpWorkerRequest)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (wr As HttpWorkerRequest)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; HttpContext(System::Web::HttpWorkerRequest ^ wr);" />
      <MemberSignature Language="F#" Value="new System.Web.HttpContext : System.Web.HttpWorkerRequest -&gt; System.Web.HttpContext" Usage="new System.Web.HttpContext wr" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="wr" Type="System.Web.HttpWorkerRequest" />
      </Parameters>
      <Docs>
        <param name="wr">当前 HTTP 请求的 <see cref="T:System.Web.HttpWorkerRequest" /> 对象。</param>
        <summary>使用指定的辅助请求对象初始化 <see cref="T:System.Web.HttpContext" /> 类的新实例。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public HttpContext (System.Web.HttpRequest request, System.Web.HttpResponse response);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Web.HttpRequest request, class System.Web.HttpResponse response) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.#ctor(System.Web.HttpRequest,System.Web.HttpResponse)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (request As HttpRequest, response As HttpResponse)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; HttpContext(System::Web::HttpRequest ^ request, System::Web::HttpResponse ^ response);" />
      <MemberSignature Language="F#" Value="new System.Web.HttpContext : System.Web.HttpRequest * System.Web.HttpResponse -&gt; System.Web.HttpContext" Usage="new System.Web.HttpContext (request, response)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="request" Type="System.Web.HttpRequest" />
        <Parameter Name="response" Type="System.Web.HttpResponse" />
      </Parameters>
      <Docs>
        <param name="request">当前 HTTP 请求的 <see cref="T:System.Web.HttpRequest" /> 对象。</param>
        <param name="response">当前 HTTP 请求的 <see cref="T:System.Web.HttpResponse" /> 对象。</param>
        <summary>使用指定的请求和响应对象初始化 <see cref="T:System.Web.HttpContext" /> 类的新实例。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AcceptWebSocketRequest">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>接受 <see cref="T:System.Web.WebSockets.AspNetWebSocket" /> 请求。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AcceptWebSocketRequest">
      <MemberSignature Language="C#" Value="public void AcceptWebSocketRequest (Func&lt;System.Web.WebSockets.AspNetWebSocketContext,System.Threading.Tasks.Task&gt; userFunc);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AcceptWebSocketRequest(class System.Func`2&lt;class System.Web.WebSockets.AspNetWebSocketContext, class System.Threading.Tasks.Task&gt; userFunc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.AcceptWebSocketRequest(System.Func{System.Web.WebSockets.AspNetWebSocketContext,System.Threading.Tasks.Task})" />
      <MemberSignature Language="VB.NET" Value="Public Sub AcceptWebSocketRequest (userFunc As Func(Of AspNetWebSocketContext, Task))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AcceptWebSocketRequest(Func&lt;System::Web::WebSockets::AspNetWebSocketContext ^, System::Threading::Tasks::Task ^&gt; ^ userFunc);" />
      <MemberSignature Language="F#" Value="member this.AcceptWebSocketRequest : Func&lt;System.Web.WebSockets.AspNetWebSocketContext, System.Threading.Tasks.Task&gt; -&gt; unit" Usage="httpContext.AcceptWebSocketRequest userFunc" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="userFunc" Type="System.Func&lt;System.Web.WebSockets.AspNetWebSocketContext,System.Threading.Tasks.Task&gt;" Index="0" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="userFunc">用户函数。</param>
        <summary>接受一个使用指定用户函数的 <see cref="T:System.Web.WebSockets.AspNetWebSocket" /> 请求。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 调用此方法等效于调用 <xref:System.Web.HttpContext.AcceptWebSocketRequest%2A> 方法重载并 `null` 为 `options` 参数传递。

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="userFunc" /> 参数为 <see langword="null" />。</exception>
        <exception cref="T:System.NotSupportedException">该请求不是一个<see cref="T:System.Web.WebSockets.AspNetWebSocket" /> 请求。</exception>
      </Docs>
    </Member>
    <Member MemberName="AcceptWebSocketRequest">
      <MemberSignature Language="C#" Value="public void AcceptWebSocketRequest (Func&lt;System.Web.WebSockets.AspNetWebSocketContext,System.Threading.Tasks.Task&gt; userFunc, System.Web.WebSockets.AspNetWebSocketOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AcceptWebSocketRequest(class System.Func`2&lt;class System.Web.WebSockets.AspNetWebSocketContext, class System.Threading.Tasks.Task&gt; userFunc, class System.Web.WebSockets.AspNetWebSocketOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.AcceptWebSocketRequest(System.Func{System.Web.WebSockets.AspNetWebSocketContext,System.Threading.Tasks.Task},System.Web.WebSockets.AspNetWebSocketOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AcceptWebSocketRequest (userFunc As Func(Of AspNetWebSocketContext, Task), options As AspNetWebSocketOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AcceptWebSocketRequest(Func&lt;System::Web::WebSockets::AspNetWebSocketContext ^, System::Threading::Tasks::Task ^&gt; ^ userFunc, System::Web::WebSockets::AspNetWebSocketOptions ^ options);" />
      <MemberSignature Language="F#" Value="member this.AcceptWebSocketRequest : Func&lt;System.Web.WebSockets.AspNetWebSocketContext, System.Threading.Tasks.Task&gt; * System.Web.WebSockets.AspNetWebSocketOptions -&gt; unit" Usage="httpContext.AcceptWebSocketRequest (userFunc, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="userFunc" Type="System.Func&lt;System.Web.WebSockets.AspNetWebSocketContext,System.Threading.Tasks.Task&gt;" Index="0" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="options" Type="System.Web.WebSockets.AspNetWebSocketOptions" Index="1" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="userFunc">用户函数。</param>
        <param name="options">选项对象。</param>
        <summary>接受一个使用指定用户函数和选项对象 <see cref="T:System.Web.WebSockets.AspNetWebSocket" /> 请求。</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="userFunc" /> 参数为 <see langword="null" />。</exception>
        <exception cref="T:System.NotSupportedException">该请求不是一个<see cref="T:System.Web.WebSockets.AspNetWebSocket" /> 请求。</exception>
      </Docs>
    </Member>
    <Member MemberName="AddError">
      <MemberSignature Language="C#" Value="public void AddError (Exception errorInfo);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddError(class System.Exception errorInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.AddError(System.Exception)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddError (errorInfo As Exception)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddError(Exception ^ errorInfo);" />
      <MemberSignature Language="F#" Value="member this.AddError : Exception -&gt; unit" Usage="httpContext.AddError errorInfo" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="errorInfo" Type="System.Exception" />
      </Parameters>
      <Docs>
        <param name="errorInfo">要添加到异常集合中的 <see cref="T:System.Exception" />。</param>
        <summary>将异常添加到当前 HTTP 请求的异常集合中。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddOnRequestCompleted">
      <MemberSignature Language="C#" Value="public System.Web.ISubscriptionToken AddOnRequestCompleted (Action&lt;System.Web.HttpContext&gt; callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Web.ISubscriptionToken AddOnRequestCompleted(class System.Action`1&lt;class System.Web.HttpContext&gt; callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.AddOnRequestCompleted(System.Action{System.Web.HttpContext})" />
      <MemberSignature Language="VB.NET" Value="Public Function AddOnRequestCompleted (callback As Action(Of HttpContext)) As ISubscriptionToken" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Web::ISubscriptionToken ^ AddOnRequestCompleted(Action&lt;System::Web::HttpContext ^&gt; ^ callback);" />
      <MemberSignature Language="F#" Value="member this.AddOnRequestCompleted : Action&lt;System.Web.HttpContext&gt; -&gt; System.Web.ISubscriptionToken" Usage="httpContext.AddOnRequestCompleted callback" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.ISubscriptionToken</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.Action&lt;System.Web.HttpContext&gt;" Index="0" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="callback">HTTP 上下文对象。</param>
        <summary>引发在请求的 HTTP 部分结束时发生的虚拟事件。</summary>
        <returns>订阅标记。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 此事件在 <xref:System.Web.WebSockets.AspNetWebSocket> 连接开始之前发生。

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="callback" /> 参数为 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="AllErrors">
      <MemberSignature Language="C#" Value="public Exception[] AllErrors { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Exception[] AllErrors" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.AllErrors" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AllErrors As Exception()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;Exception ^&gt; ^ AllErrors { cli::array &lt;Exception ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AllErrors : Exception[]" Usage="System.Web.HttpContext.AllErrors" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Exception[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取在处理 HTTP 请求的过程中累积的错误数组。</summary>
        <value>当前 HTTP 请求的 <see cref="T:System.Exception" /> 对象数组。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AllowAsyncDuringSyncStages">
      <MemberSignature Language="C#" Value="public bool AllowAsyncDuringSyncStages { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AllowAsyncDuringSyncStages" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.AllowAsyncDuringSyncStages" />
      <MemberSignature Language="VB.NET" Value="Public Property AllowAsyncDuringSyncStages As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AllowAsyncDuringSyncStages { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AllowAsyncDuringSyncStages : bool with get, set" Usage="System.Web.HttpContext.AllowAsyncDuringSyncStages" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，此值指示 ASP.NET 请求处理过程中是否允许非预期的异步操作。</summary>
        <value>当异步 API 在不是预期的时间使用时 ASP.NET 将引发异常，则为 <see langword="false" />，否则为 <see langword="true" />。 默认值是 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 如果此标志未设置为 `true` ，则当 ASP.NET 检测到应用程序滥用异步 API 时，将引发异常。 如果尝试在请求处理管道的一部分中调用异步方法，但异步操作不是预期的，或者异步模块或处理程序信号完成时仍未完成的异步工作，则可能会发生这种情况。 此行为旨在作为一种安全网络，让您在编写不适合预期模式并可能产生负面影响的异步代码时提前了解。

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Application">
      <MemberSignature Language="C#" Value="public System.Web.HttpApplicationState Application { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpApplicationState Application" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.Application" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Application As HttpApplicationState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::HttpApplicationState ^ Application { System::Web::HttpApplicationState ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Application : System.Web.HttpApplicationState" Usage="System.Web.HttpContext.Application" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.HttpApplicationState</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>为当前 HTTP 请求获取 <see cref="T:System.Web.HttpApplicationState" /> 对象。</summary>
        <value>当前 HTTP 请求的 <see cref="T:System.Web.HttpApplicationState" />。

若要获取当前 HTTP 请求的 <see cref="T:System.Web.HttpApplication" /> 对象，请使用 <see cref="P:System.Web.HttpContext.ApplicationInstance" />。 （ASP.NET 使用 <see langword="ApplicationInstance" /> 代替 <see langword="Application" /> 作为属性名来引用当前的 <see cref="T:System.Web.HttpApplication" /> 实例，以避免 ASP.NET 与经典 ASP 之间产生混淆。 在经典 ASP 中，<see langword="Application" /> 引用全局应用程序状态字典。）</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Web.HttpContext.ApplicationInstance" />
      </Docs>
    </Member>
    <Member MemberName="ApplicationInstance">
      <MemberSignature Language="C#" Value="public System.Web.HttpApplication ApplicationInstance { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpApplication ApplicationInstance" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.ApplicationInstance" />
      <MemberSignature Language="VB.NET" Value="Public Property ApplicationInstance As HttpApplication" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::HttpApplication ^ ApplicationInstance { System::Web::HttpApplication ^ get(); void set(System::Web::HttpApplication ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ApplicationInstance : System.Web.HttpApplication with get, set" Usage="System.Web.HttpContext.ApplicationInstance" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.HttpApplication</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>为当前 HTTP 请求获取或设置 <see cref="T:System.Web.HttpApplication" /> 对象。</summary>
        <value>当前 HTTP 请求的 <see cref="T:System.Web.HttpApplication" />。

ASP.NET 使用 <see langword="ApplicationInstance" /> 代替 <see langword="Application" /> 作为属性名来引用当前的 <see cref="T:System.Web.HttpApplication" /> 实例，以避免 ASP.NET 与经典 ASP 之间产生混淆。 在经典 ASP 中，<see langword="Application" /> 引用全局应用程序状态字典。</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">Web 应用程序正在 IIS 7.0 集成模式下运行，并且已尝试将属性值从非 NULL 值更改为 <see langword="null" />。</exception>
        <altmember cref="P:System.Web.HttpContext.Application" />
      </Docs>
    </Member>
    <Member MemberName="AsyncPreloadMode">
      <MemberSignature Language="C#" Value="public System.Web.Configuration.AsyncPreloadModeFlags AsyncPreloadMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Web.Configuration.AsyncPreloadModeFlags AsyncPreloadMode" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.AsyncPreloadMode" />
      <MemberSignature Language="VB.NET" Value="Public Property AsyncPreloadMode As AsyncPreloadModeFlags" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::Configuration::AsyncPreloadModeFlags AsyncPreloadMode { System::Web::Configuration::AsyncPreloadModeFlags get(); void set(System::Web::Configuration::AsyncPreloadModeFlags value); };" />
      <MemberSignature Language="F#" Value="member this.AsyncPreloadMode : System.Web.Configuration.AsyncPreloadModeFlags with get, set" Usage="System.Web.HttpContext.AsyncPreloadMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.Configuration.AsyncPreloadModeFlags</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置包含适用于异步预加载模式的标志的对象。</summary>
        <value>包含适用于异步预加载模式的标志的对象。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 第一次访问此属性时，将从配置文件中的设置加载包含异步预加载模式的标志的对象 <xref:System.Web.Configuration.HttpRuntimeSection.AsyncPreloadMode%2A> 。

 尽管可以以编程方式设置此属性，只有该属性在 ASP.NET 请求管道中的 `ExecuteRequestHandler` 步骤之前设置，更改属性值才起作用。

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cache">
      <MemberSignature Language="C#" Value="public System.Web.Caching.Cache Cache { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.Caching.Cache Cache" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.Cache" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Cache As Cache" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::Caching::Cache ^ Cache { System::Web::Caching::Cache ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Cache : System.Web.Caching.Cache" Usage="System.Web.HttpContext.Cache" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.Caching.Cache</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取当前应用程序域的 <see cref="T:System.Web.Caching.Cache" /> 对象。</summary>
        <value>当前应用程序域的 <see cref="T:System.Web.Caching.Cache" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.Web.Caching.Cache>每个应用程序域都有一个类的实例。 因此， <xref:System.Web.Caching.Cache> 属性返回的对象 <xref:System.Web.HttpContext.Cache%2A> 是 <xref:System.Web.Caching.Cache> 应用程序域中所有请求的对象。

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ClearError">
      <MemberSignature Language="C#" Value="public void ClearError ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ClearError() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.ClearError" />
      <MemberSignature Language="VB.NET" Value="Public Sub ClearError ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ClearError();" />
      <MemberSignature Language="F#" Value="member this.ClearError : unit -&gt; unit" Usage="httpContext.ClearError " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>清除当前 HTTP 请求的所有错误。</summary>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Web.HttpContext.Error" />
      </Docs>
    </Member>
    <Member MemberName="Current">
      <MemberSignature Language="C#" Value="public static System.Web.HttpContext Current { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Web.HttpContext Current" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.Current" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property Current As HttpContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Web::HttpContext ^ Current { System::Web::HttpContext ^ get(); void set(System::Web::HttpContext ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Current : System.Web.HttpContext with get, set" Usage="System.Web.HttpContext.Current" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.HttpContext</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>为当前 HTTP 请求获取或设置 <see cref="T:System.Web.HttpContext" /> 对象。</summary>
        <value>当前 HTTP 请求的 <see cref="T:System.Web.HttpContext" /> 实例。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 此属性是类的静态属性 <xref:System.Web.HttpContext> 。 属性存储应用于 <xref:System.Web.HttpContext> 当前请求的实例。 此实例的属性为类的非静态属性 <xref:System.Web.HttpContext> 。

 你还可以使用 <xref:System.Web.UI.Page.Context%2A?displayProperty=nameWithType> 属性来访问 <xref:System.Web.HttpContext> 当前 HTTP 请求的对象。



## Examples
 下面的代码示例使用 <xref:System.Web.HttpContext.Current%2A> 属性访问 <xref:System.Web.HttpContext.AddError%2A?displayProperty=nameWithType> 和 <xref:System.Web.HttpContext.ClearError%2A?displayProperty=nameWithType> 方法以及 <xref:System.Web.HttpContext.AllErrors%2A?displayProperty=nameWithType> 属性。 该示例使用方法创建三个自定义异常 <xref:System.Web.HttpContext.AddError%2A> ，并使用 <xref:System.Web.HttpContext.AllErrors%2A> 属性将这些异常加载到数组中。 然后，它将数组写入包含页，并使用 <xref:System.Web.HttpContext.ClearError%2A> 方法清除属性中的所有错误 <xref:System.Web.UI.Page.Context%2A> 。

```csharp
protected void Page_Load(object sender, EventArgs e)
{
    HttpContext context = HttpContext.Current;
    Response.Write("<p>HttpContext.Current Example:</p>");

    // Add three custom exceptions.
    context.AddError(new Exception("New Exception #1"));
    context.AddError(new Exception("New Exception #2"));
    context.AddError(new Exception("New Exception #3"));

    // Capture all the new Exceptions in an array.
    Exception[] errs = context.AllErrors;

    foreach (Exception ex in errs)
    {
        Response.Write("<p>" + Server.HtmlEncode(ex.ToString()) + "</p>");
    }

    // Clear the exceptions so ASP.NET won't handle them.
    context.ClearError();
}
```

```vb
Protected Sub Page_Load(sender As Object, e As EventArgs)
Dim context As HttpContext = HttpContext.Current
Response.Write("<p>HttpContext.Current Example:</p>")

' Add three custom exceptions.
context.AddError(New Exception("New Exception #1"))
context.AddError(New Exception("New Exception #2"))
context.AddError(New Exception("New Exception #3"))

' Capture all the new Exceptions in an array.
Dim errs As Exception() = context.AllErrors

For Each ex As Exception In errs
Response.Write("<p>" & Server.HtmlEncode(ex.ToString()) & "</p>")
Next

' Clear the exceptions so ASP.NET won't handle them.
context.ClearError()
End Sub

```

 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.HttpContext.Response" />
        <altmember cref="P:System.Web.HttpContext.Request" />
      </Docs>
    </Member>
    <Member MemberName="CurrentHandler">
      <MemberSignature Language="C#" Value="public System.Web.IHttpHandler CurrentHandler { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.IHttpHandler CurrentHandler" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.CurrentHandler" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CurrentHandler As IHttpHandler" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::IHttpHandler ^ CurrentHandler { System::Web::IHttpHandler ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CurrentHandler : System.Web.IHttpHandler" Usage="System.Web.HttpContext.CurrentHandler" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.IHttpHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取表示当前正在执行的处理程序的 <see cref="T:System.Web.IHttpHandler" /> 对象。</summary>
        <value>一个 <see cref="T:System.Web.IHttpHandler" />，表示当前正在执行的处理程序。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 属性引用的当前正在执行的处理程序 <xref:System.Web.HttpContext.CurrentHandler%2A> 可能不同于属性所引用的处理程序 <xref:System.Web.HttpContext.Handler%2A> 。 如果通过使用方法或方法请求其他处理程序，则可能会发生这种情况 <xref:System.Web.HttpServerUtility.Execute%2A> <xref:System.Web.HttpServerUtility.Transfer%2A> 。 当当前正在执行的处理程序完成处理时，将还原以前确定的处理程序。

 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.HttpContext.Handler" />
        <altmember cref="P:System.Web.HttpContext.PreviousHandler" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/bb398986(v=vs.100)">HTTP 处理程序和 HTTP 模块概述</related>
      </Docs>
    </Member>
    <Member MemberName="CurrentNotification">
      <MemberSignature Language="C#" Value="public System.Web.RequestNotification CurrentNotification { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Web.RequestNotification CurrentNotification" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.CurrentNotification" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CurrentNotification As RequestNotification" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::RequestNotification CurrentNotification { System::Web::RequestNotification get(); };" />
      <MemberSignature Language="F#" Value="member this.CurrentNotification : System.Web.RequestNotification" Usage="System.Web.HttpContext.CurrentNotification" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.RequestNotification</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个 <see cref="T:System.Web.RequestNotification" /> 值，该值指示当前正在处理的 <see cref="T:System.Web.HttpApplication" /> 事件。</summary>
        <value><see cref="T:System.Web.RequestNotification" /> 值之一。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.Web.HttpContext.CurrentNotification%2A>属性需要 IIS 7.0 中的集成管道模式，并且至少 .NET Framework 版本3.0。 如果可用，属性将返回一个 <xref:System.Web.RequestNotification> 值。 属性的值 <xref:System.Web.HttpContext.CurrentNotification%2A> 指示 <xref:System.Web.HttpApplication> 实例中当前正在处理请求的事件。

 <xref:System.Web.HttpContext.CurrentNotification%2A>不应设置属性。 相反，它是由 IIS 7.0 在 ASP.NET 管道中处理请求的过程中设置的。 设置 <xref:System.Web.HttpContext.CurrentNotification%2A> 属性将导致编译错误。

 <xref:System.Web.HttpContext.CurrentNotification%2A> .NET Framework 版本3.5 中引入。  有关详细信息，请参见[版本和依赖关系](/dotnet/framework/migration-guide/versions-and-dependencies)。



## Examples
 下面的示例演示如何使用 <xref:System.Web.HttpContext.CurrentNotification%2A> 属性来确定处理当前请求的对象的哪个事件正在 <xref:System.Web.HttpApplication> 处理。 在此示例中，事件处理程序处理对象的多个事件 <xref:System.Web.HttpApplication> ， <xref:System.Web.HttpContext.CurrentNotification%2A> 属性决定为正在处理的每个事件调用的代码。

 [!code-csharp[System.Web.HttpResponse.IsPostNotification#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse.IsPostNotification/CS/App_Code/TestModule.cs#1)]
 [!code-vb[System.Web.HttpResponse.IsPostNotification#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse.IsPostNotification/VB/App_Code/TestModule.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">此操作要求在 IIS 7.0 中集成管道模式，并且至少 .NET Framework 3.0 版本。</exception>
        <altmember cref="P:System.Web.HttpContext.IsPostNotification" />
        <altmember cref="T:System.Web.RequestNotification" />
      </Docs>
    </Member>
    <Member MemberName="DisposeOnPipelineCompleted">
      <MemberSignature Language="C#" Value="public System.Web.ISubscriptionToken DisposeOnPipelineCompleted (IDisposable target);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Web.ISubscriptionToken DisposeOnPipelineCompleted(class System.IDisposable target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.DisposeOnPipelineCompleted(System.IDisposable)" />
      <MemberSignature Language="VB.NET" Value="Public Function DisposeOnPipelineCompleted (target As IDisposable) As ISubscriptionToken" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Web::ISubscriptionToken ^ DisposeOnPipelineCompleted(IDisposable ^ target);" />
      <MemberSignature Language="F#" Value="member this.DisposeOnPipelineCompleted : IDisposable -&gt; System.Web.ISubscriptionToken" Usage="httpContext.DisposeOnPipelineCompleted target" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.ISubscriptionToken</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.IDisposable" Index="0" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="target">在请求的 <see cref="M:System.IDisposable.Dispose" /> 连接部分完成时必须调动用其 <see cref="T:System.Web.WebSockets.AspNetWebSocket" /> 方法的对象。</param>
        <summary>使对象的 <see cref="M:System.IDisposable.Dispose" /> 方法可以在此请求的 <see cref="T:System.Web.WebSockets.AspNetWebSocket" /> 连接部分完成时进行调用。</summary>
        <returns>订阅标记。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 在 <xref:System.IDisposable.Dispose%2A> 请求的 HTTP 部分和连接结束后，将调用目标对象的方法 <xref:System.Web.WebSockets.AspNetWebSocket> 。 <xref:System.Web.HttpContext>对象不可用于检查。

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Error">
      <MemberSignature Language="C#" Value="public Exception Error { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Exception Error" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.Error" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Error As Exception" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Exception ^ Error { Exception ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Error : Exception" Usage="System.Web.HttpContext.Error" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Exception</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取在处理 HTTP 请求的过程中累积的第一个错误（如果有）。</summary>
        <value>当前 HTTP 请求/响应过程的第一个 <see cref="T:System.Exception" />；如果在处理 HTTP 请求期间没有发生任何错误，则为 <see langword="null" />。 默认值为 <see langword="null" />。</value>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Web.HttpContext.ClearError" />
      </Docs>
    </Member>
    <Member MemberName="GetAppConfig">
      <MemberSignature Language="C#" Value="public static object GetAppConfig (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetAppConfig(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.GetAppConfig(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetAppConfig (name As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ GetAppConfig(System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member GetAppConfig : string -&gt; obj" Usage="System.Web.HttpContext.GetAppConfig name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.Obsolete("The recommended alternative is System.Web.Configuration.WebConfigurationManager.GetWebApplicationSection in System.Web.dll. http://go.microsoft.com/fwlink/?linkid=14202")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Obsolete("The recommended alternative is System.Web.Configuration.WebConfigurationManager.GetWebApplicationSection in System.Web.dll. http://go.microsoft.com/fwlink/?linkid=14202")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">为其请求信息的应用程序配置标记。</param>
        <summary>为当前应用程序返回请求的配置信息。</summary>
        <returns>包含配置信息的对象。 （在使用之前，将返回的配置节强制转换为适当的配置类型。）</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.Web.HttpContext.GetAppConfig%2A> 方法已弃用。 使用 <xref:System.Web.Configuration.WebConfigurationManager.GetWebApplicationSection%2A> 类的方法 <xref:System.Web.Configuration.WebConfigurationManager> 可获取当前应用程序的配置信息。

 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.Configuration.WebConfigurationManager" />
      </Docs>
    </Member>
    <Member MemberName="GetConfig">
      <MemberSignature Language="C#" Value="public object GetConfig (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetConfig(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.GetConfig(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetConfig (name As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetConfig(System::String ^ name);" />
      <MemberSignature Language="F#" Value="member this.GetConfig : string -&gt; obj" Usage="httpContext.GetConfig name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.Obsolete("The recommended alternative is System.Web.HttpContext.GetSection in System.Web.dll. http://go.microsoft.com/fwlink/?linkid=14202")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Obsolete("The recommended alternative is System.Web.HttpContext.GetSection in System.Web.dll. http://go.microsoft.com/fwlink/?linkid=14202")&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">为其请求信息的配置标记。</param>
        <summary>为当前 HTTP 请求返回所请求的配置信息。</summary>
        <returns>指定的 <see cref="T:System.Configuration.ConfigurationSection" />，如果该节不存在，则为 <see langword="null" />，或是如果该节不能在运行时访问，则为一个内部对象。 （在使用之前，将返回的对象强制转换为适当的配置类型。）</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.Web.HttpContext.GetConfig%2A> 方法已弃用。 使用 <xref:System.Web.HttpContext.GetSection%2A> 方法获取当前 HTTP 请求的配置信息。

 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.HttpContext.GetSection(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetGlobalResourceObject">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>获取应用程序级别的资源。</summary>
        <related type="Article" href="/dotnet/framework/resources/">应用程序中的资源</related>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/ex526337(v=vs.100)">ASP.NET 网站布局</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetGlobalResourceObject">
      <MemberSignature Language="C#" Value="public static object GetGlobalResourceObject (string classKey, string resourceKey);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetGlobalResourceObject(string classKey, string resourceKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.GetGlobalResourceObject(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetGlobalResourceObject (classKey As String, resourceKey As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ GetGlobalResourceObject(System::String ^ classKey, System::String ^ resourceKey);" />
      <MemberSignature Language="F#" Value="static member GetGlobalResourceObject : string * string -&gt; obj" Usage="System.Web.HttpContext.GetGlobalResourceObject (classKey, resourceKey)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="classKey" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="resourceKey" Type="System.String" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="classKey">一个字符串，表示所请求资源对象的 <see cref="P:System.Web.Compilation.ResourceExpressionFields.ClassKey" /> 属性。</param>
        <param name="resourceKey">一个字符串，表示所请求资源对象的 <see cref="P:System.Web.Compilation.ResourceExpressionFields.ResourceKey" /> 属性。</param>
        <summary>根据指定的 <see cref="P:System.Web.Compilation.ResourceExpressionFields.ClassKey" /> 和 <see cref="P:System.Web.Compilation.ResourceExpressionFields.ResourceKey" /> 属性，获取应用程序级别资源对象。</summary>
        <returns>一个 <see cref="T:System.Object" />，表示请求的应用程序级别资源对象；否则，如果未找到资源对象，或找到了资源对象但其没有请求的属性，则为 null。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.Web.HttpContext.GetGlobalResourceObject%2A>方法使用属性中指定的区域性返回全局资源 <xref:System.Globalization.CultureInfo.CurrentUICulture%2A> 。

> [!NOTE]
>  在某些编辑环境（如 Visual Web Developer）中， <xref:System.Resources.MissingManifestResourceException> 如果在全局资源键名称中使用句点 ( ) ，编辑器可能引发设计时异常。 但是，这不会影响你编辑或保存文件的能力，你可以忽略此错误。

 ]]></format>
        </remarks>
        <exception cref="T:System.Resources.MissingManifestResourceException">未找到具有指定 <paramref name="classKey" /> 参数的资源对象。

- 或 -

主程序集不包含非特定区域性的资源，但由于缺少适当的附属程序集，又需要这些资源。</exception>
        <altmember cref="T:System.Web.Compilation.ResourceExpressionBuilder" />
        <related type="Article" href="/dotnet/framework/resources/">应用程序中的资源</related>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/ex526337(v=vs.100)">ASP.NET 网站布局</related>
        <related type="Article" href="/dotnet/framework/resources/packaging-and-deploying-resources-in-desktop-apps">打包和部署资源</related>
      </Docs>
    </Member>
    <Member MemberName="GetGlobalResourceObject">
      <MemberSignature Language="C#" Value="public static object GetGlobalResourceObject (string classKey, string resourceKey, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetGlobalResourceObject(string classKey, string resourceKey, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.GetGlobalResourceObject(System.String,System.String,System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetGlobalResourceObject (classKey As String, resourceKey As String, culture As CultureInfo) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ GetGlobalResourceObject(System::String ^ classKey, System::String ^ resourceKey, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="static member GetGlobalResourceObject : string * string * System.Globalization.CultureInfo -&gt; obj" Usage="System.Web.HttpContext.GetGlobalResourceObject (classKey, resourceKey, culture)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="classKey" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="resourceKey" Type="System.String" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="2" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="classKey">一个字符串，表示所请求资源对象的 <see cref="P:System.Web.Compilation.ResourceExpressionFields.ClassKey" /> 属性。</param>
        <param name="resourceKey">一个表示所请求资源对象的 <see cref="P:System.Web.Compilation.ResourceExpressionFields.ResourceKey" /> 属性的字符串。</param>
        <param name="culture">一个字符串，表示所请求资源的 <see cref="T:System.Globalization.CultureInfo" /> 对象。</param>
        <summary>根据指定的 <see cref="P:System.Web.Compilation.ResourceExpressionFields.ClassKey" /> 和 <see cref="P:System.Web.Compilation.ResourceExpressionFields.ResourceKey" /> 属性以及 <see cref="T:System.Globalization.CultureInfo" /> 对象，获取一个应用程序级别资源对象。</summary>
        <returns>一个 <see cref="T:System.Object" />，表示请求的应用程序级别资源对象（对指定区域性对其进行了本地化）；否则，如果未找到资源对象，或找到了资源对象但其没有请求的属性，则为 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.Globalization.CultureInfo>对象表示为其本地化资源的区域性。 如果没有为此区域性本地化该资源，则查找将遵循回退过程来定位相应的资源。 有关详细信息，请参阅[打包和部署资源](/dotnet/framework/resources/packaging-and-deploying-resources-in-desktop-apps)。

> [!NOTE]
>  在某些编辑环境（如 Visual Web Developer）中， <xref:System.Resources.MissingManifestResourceException> 如果在全局资源键名称中使用句点 ( ) ，编辑器可能引发设计时异常。 但是，这不会影响你编辑或保存文件的能力，你可以忽略此错误。

 ]]></format>
        </remarks>
        <exception cref="T:System.Resources.MissingManifestResourceException">未找到具有指定 <paramref name="classKey" /> 参数的资源对象。

- 或 -

主程序集不包含非特定区域性的资源，但由于缺少适当的附属程序集，又需要这些资源。</exception>
        <altmember cref="T:System.Web.Compilation.ResourceExpressionBuilder" />
        <related type="Article" href="/dotnet/framework/resources/">应用程序中的资源</related>
        <related type="Article" href="/dotnet/framework/resources/packaging-and-deploying-resources-in-desktop-apps">打包和部署资源</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetLocalResourceObject">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>获取页级别的资源。</summary>
        <altmember cref="T:System.Web.Compilation.ResourceExpressionBuilder" />
        <related type="Article" href="/dotnet/framework/resources/">应用程序中的资源</related>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/ex526337(v=vs.100)">ASP.NET 网站布局</related>
        <related type="Article" href="/dotnet/framework/resources/packaging-and-deploying-resources-in-desktop-apps">打包和部署资源</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetLocalResourceObject">
      <MemberSignature Language="C#" Value="public static object GetLocalResourceObject (string virtualPath, string resourceKey);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetLocalResourceObject(string virtualPath, string resourceKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.GetLocalResourceObject(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetLocalResourceObject (virtualPath As String, resourceKey As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ GetLocalResourceObject(System::String ^ virtualPath, System::String ^ resourceKey);" />
      <MemberSignature Language="F#" Value="static member GetLocalResourceObject : string * string -&gt; obj" Usage="System.Web.HttpContext.GetLocalResourceObject (virtualPath, resourceKey)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="virtualPath" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="resourceKey" Type="System.String" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="virtualPath">本地资源对象的 <see cref="P:System.Web.Compilation.ExpressionBuilderContext.VirtualPath" /> 属性。</param>
        <param name="resourceKey">一个字符串，表示所请求资源对象的 <see cref="P:System.Web.Compilation.ResourceExpressionFields.ResourceKey" /> 属性</param>
        <summary>根据指定的 <see cref="P:System.Web.Compilation.ExpressionBuilderContext.VirtualPath" /> 和 <see cref="P:System.Web.Compilation.ResourceExpressionFields.ResourceKey" /> 属性，获取页级别资源对象。</summary>
        <returns><see cref="T:System.Object" />，表示请求的页级别资源对象；否则，如果找到了匹配的资源对象但不是 <paramref name="resourceKey" /> 参数，则为 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.Web.HttpContext.GetLocalResourceObject%2A>方法使用属性中指定的区域性返回本地资源 <xref:System.Globalization.CultureInfo.CurrentUICulture%2A> 。

 ]]></format>
        </remarks>
        <exception cref="T:System.Resources.MissingManifestResourceException">未找到具有指定 <paramref name="virtualPath" /> 参数的资源对象。</exception>
        <exception cref="T:System.ArgumentException">指定的 <paramref name="virtualPath" /> 参数不在当前应用程序的根目录中。</exception>
        <exception cref="T:System.InvalidOperationException">未找到页的资源类。</exception>
        <altmember cref="T:System.Web.Compilation.ResourceExpressionBuilder" />
        <related type="Article" href="/dotnet/framework/resources/">应用程序中的资源</related>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/ex526337(v=vs.100)">ASP.NET 网站布局</related>
        <related type="Article" href="/dotnet/framework/resources/packaging-and-deploying-resources-in-desktop-apps">打包和部署资源</related>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/ms227982(v=vs.100)">如何：以编程方式检索资源值</related>
      </Docs>
    </Member>
    <Member MemberName="GetLocalResourceObject">
      <MemberSignature Language="C#" Value="public static object GetLocalResourceObject (string virtualPath, string resourceKey, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetLocalResourceObject(string virtualPath, string resourceKey, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.GetLocalResourceObject(System.String,System.String,System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetLocalResourceObject (virtualPath As String, resourceKey As String, culture As CultureInfo) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ GetLocalResourceObject(System::String ^ virtualPath, System::String ^ resourceKey, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="static member GetLocalResourceObject : string * string * System.Globalization.CultureInfo -&gt; obj" Usage="System.Web.HttpContext.GetLocalResourceObject (virtualPath, resourceKey, culture)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="virtualPath" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="resourceKey" Type="System.String" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="2" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="virtualPath">本地资源对象的 <see cref="P:System.Web.Compilation.ExpressionBuilderContext.VirtualPath" /> 属性。</param>
        <param name="resourceKey">一个表示所请求资源对象的 <see cref="P:System.Web.Compilation.ResourceExpressionFields.ResourceKey" /> 属性的字符串。</param>
        <param name="culture">一个字符串，表示所请求资源对象的 <see cref="T:System.Globalization.CultureInfo" /> 对象。</param>
        <summary>根据指定的 <see cref="P:System.Web.Compilation.ExpressionBuilderContext.VirtualPath" /> 和 <see cref="P:System.Web.Compilation.ResourceExpressionFields.ResourceKey" /> 属性以及 <see cref="T:System.Globalization.CultureInfo" /> 对象，获取一个页级别资源对象。</summary>
        <returns><see cref="T:System.Object" />，表示请求的本地资源对象（针对指定区域性进行了本地化的对象）；否则，如果找到了匹配的资源对象但不是 <see langword="null" /> 参数，则为 <paramref name="resourceKey" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 如果没有为此区域性本地化该资源，则查找将遵循回退过程来定位相应的资源。 有关详细信息，请参阅[打包和部署资源](/dotnet/framework/resources/packaging-and-deploying-resources-in-desktop-apps)。

 ]]></format>
        </remarks>
        <exception cref="T:System.Resources.MissingManifestResourceException">未找到具有指定 <paramref name="virtualPath" /> 参数的资源对象。</exception>
        <exception cref="T:System.ArgumentException">指定的 <paramref name="virtualPath" /> 参数不在当前应用程序的根目录中。</exception>
        <exception cref="T:System.InvalidOperationException">未找到页的资源类。</exception>
        <altmember cref="T:System.Web.Compilation.ResourceExpressionBuilder" />
        <related type="Article" href="/dotnet/framework/resources/">应用程序中的资源</related>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/ex526337(v=vs.100)">ASP.NET 网站布局</related>
        <related type="Article" href="/dotnet/framework/resources/packaging-and-deploying-resources-in-desktop-apps">打包和部署资源</related>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/ms227982(v=vs.100)">如何：以编程方式检索资源值</related>
      </Docs>
    </Member>
    <Member MemberName="GetSection">
      <MemberSignature Language="C#" Value="public object GetSection (string sectionName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetSection(string sectionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.GetSection(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetSection (sectionName As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetSection(System::String ^ sectionName);" />
      <MemberSignature Language="F#" Value="member this.GetSection : string -&gt; obj" Usage="httpContext.GetSection sectionName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sectionName" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="sectionName">配置节路径（使用 XPath 格式）和配置元素名称。</param>
        <summary>获取当前应用程序的默认配置的指定配置节。</summary>
        <returns>指定的 <see cref="T:System.Configuration.ConfigurationSection" />，如果该节不存在，则为 <see langword="null" />，或是如果该节不能在运行时访问，则为一个内部对象。</returns>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Configuration.ConfigurationManager.GetSection(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Handler">
      <MemberSignature Language="C#" Value="public System.Web.IHttpHandler Handler { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.IHttpHandler Handler" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.Handler" />
      <MemberSignature Language="VB.NET" Value="Public Property Handler As IHttpHandler" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::IHttpHandler ^ Handler { System::Web::IHttpHandler ^ get(); void set(System::Web::IHttpHandler ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Handler : System.Web.IHttpHandler with get, set" Usage="System.Web.HttpContext.Handler" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.IHttpHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置负责处理 HTTP 请求的 <see cref="T:System.Web.IHttpHandler" /> 对象。</summary>
        <value>负责处理 HTTP 请求的 <see cref="T:System.Web.IHttpHandler" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.Web.HttpContext.Handler%2A>属性包含对处理 HTTP 请求的处理程序的引用。 可以使用 [httpHandlers](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bya7fh0a(v=vs.100)) 元素或在用户代码中定义的自定义处理程序来指定处理程序。 有关处理程序的详细信息，请参阅 [Http 处理程序和 Http 模块概述](https://docs.microsoft.com/previous-versions/aspnet/bb398986(v=vs.100))。

 <xref:System.Web.HttpContext.Handler%2A>即使在服务器端方法（如 <xref:System.Web.HttpServerUtility.Execute%2A> 方法或方法）更改了当前页后，对属性的引用也将保持不变 <xref:System.Web.HttpServerUtility.Transfer%2A> 。

 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.HttpContext.CurrentHandler" />
        <altmember cref="P:System.Web.HttpContext.PreviousHandler" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/bb398986(v=vs.100)">HTTP 处理程序和 HTTP 模块概述</related>
      </Docs>
    </Member>
    <Member MemberName="IsCustomErrorEnabled">
      <MemberSignature Language="C#" Value="public bool IsCustomErrorEnabled { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsCustomErrorEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.IsCustomErrorEnabled" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsCustomErrorEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsCustomErrorEnabled { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsCustomErrorEnabled : bool" Usage="System.Web.HttpContext.IsCustomErrorEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示是否已为当前 HTTP 请求启用自定义错误。</summary>
        <value>如果启用了自定义错误，则为 <see langword="true" />；否则，为 <see langword="false" />。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsDebuggingEnabled">
      <MemberSignature Language="C#" Value="public bool IsDebuggingEnabled { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsDebuggingEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.IsDebuggingEnabled" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsDebuggingEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsDebuggingEnabled { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsDebuggingEnabled : bool" Usage="System.Web.HttpContext.IsDebuggingEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示当前 HTTP 请求是否处于调试模式。</summary>
        <value>如果请求处于调试模式，则为 <see langword="true" />；否则，为 <see langword="false" />。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsPostNotification">
      <MemberSignature Language="C#" Value="public bool IsPostNotification { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsPostNotification" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.IsPostNotification" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsPostNotification As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsPostNotification { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsPostNotification : bool" Usage="System.Web.HttpContext.IsPostNotification" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在 <see cref="T:System.Web.HttpApplication" /> 事件完成处理之后获取 ASP.NET 管道的当前进程点的值。</summary>
        <value>如果启用了自定义错误，则为 <see langword="true" />；否则，为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.Web.HttpContext.IsPostNotification%2A>仅在 IIS 7.0 的集成模式下支持属性，且至少支持 .NET Framework 3.0。 如果可用，属性将返回一个布尔值，该值指示对象中的事件是否 <xref:System.Web.HttpApplication> 已完成处理。

 <xref:System.Web.HttpContext.IsPostNotification%2A>不应设置属性。 而是由 IIS 7.0 提供给每个通知的 ASP.NET 运行时。 设置 <xref:System.Web.HttpContext.IsPostNotification%2A> 属性将导致编译错误。

 在一个事件处理程序处理对象的多个事件的方案中 <xref:System.Web.HttpApplication> ，可以将 <xref:System.Web.HttpContext.IsPostNotification%2A> 属性与枚举结合使用 <xref:System.Web.RequestNotification> 来准确确定当前请求在应用程序生命周期中的位置。

 <xref:System.Web.HttpContext.IsPostNotification%2A> .NET Framework 版本3.5 中引入。  有关详细信息，请参见[版本和依赖关系](/dotnet/framework/migration-guide/versions-and-dependencies)。



## Examples
 下面的示例演示如何使用 <xref:System.Web.HttpContext.IsPostNotification%2A> 属性来确定对象的事件何时 <xref:System.Web.HttpApplication> 处理完所有关联的事件处理程序。 此示例中的自定义事件处理程序处理对象的多个事件 <xref:System.Web.HttpApplication> ，而 <xref:System.Web.HttpContext.IsPostNotification%2A> 属性用于确定在处理特定事件之后调用的代码。

 [!code-csharp[System.Web.HttpResponse.IsPostNotification#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse.IsPostNotification/CS/App_Code/TestModule.cs#1)]
 [!code-vb[System.Web.HttpResponse.IsPostNotification#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse.IsPostNotification/VB/App_Code/TestModule.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">操作需要 IIS 7.0 中的集成管道模式，并且至少 .NET Framework 3.0。</exception>
        <altmember cref="P:System.Web.HttpContext.CurrentNotification" />
        <altmember cref="T:System.Web.RequestNotification" />
      </Docs>
    </Member>
    <Member MemberName="IsWebSocketRequest">
      <MemberSignature Language="C#" Value="public bool IsWebSocketRequest { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsWebSocketRequest" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.IsWebSocketRequest" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsWebSocketRequest As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsWebSocketRequest { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsWebSocketRequest : bool" Usage="System.Web.HttpContext.IsWebSocketRequest" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示此请求是否是一个 <see cref="T:System.Web.WebSockets.AspNetWebSocket" /> 请求。</summary>
        <value>如果该请求是一个 <see cref="T:System.Web.WebSockets.AspNetWebSocket" /> 请求，则为 <see langword="true" />，否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 `true`如果请求包含初始 <xref:System.Web.WebSockets.AspNetWebSocket> 握手并且 IIS 的模块处于活动状态，则此方法返回 `WebSocket` 。

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsWebSocketRequestUpgrading">
      <MemberSignature Language="C#" Value="public bool IsWebSocketRequestUpgrading { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsWebSocketRequestUpgrading" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.IsWebSocketRequestUpgrading" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsWebSocketRequestUpgrading As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsWebSocketRequestUpgrading { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsWebSocketRequestUpgrading : bool" Usage="System.Web.HttpContext.IsWebSocketRequestUpgrading" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取指示连接是否从 HTTP 连接升级到 <see cref="T:System.Web.WebSockets.AspNetWebSocket" /> 连接的值。</summary>
        <value>如果连接正在升级，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Items">
      <MemberSignature Language="C#" Value="public System.Collections.IDictionary Items { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IDictionary Items" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.Items" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Items As IDictionary" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::IDictionary ^ Items { System::Collections::IDictionary ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Items : System.Collections.IDictionary" Usage="System.Web.HttpContext.Items" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionary</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取可用于在 HTTP 请求过程中在 <see cref="T:System.Web.IHttpModule" /> 接口和 <see cref="T:System.Web.IHttpHandler" /> 接口之间组织和共享数据的键/值集合。</summary>
        <value><see cref="T:System.Collections.IDictionary" /> 键/值集合，按指定的键提供对集合中个别值的访问。</value>
        <remarks>To be added.</remarks>
        <related type="ExternalDocumentation" href="https://docs.microsoft.com/previous-versions/dotnet/articles/ms972109(v=msdn.10)">上下文问题</related>
      </Docs>
    </Member>
    <Member MemberName="PageInstrumentation">
      <MemberSignature Language="C#" Value="public System.Web.Instrumentation.PageInstrumentationService PageInstrumentation { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.Instrumentation.PageInstrumentationService PageInstrumentation" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.PageInstrumentation" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PageInstrumentation As PageInstrumentationService" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::Instrumentation::PageInstrumentationService ^ PageInstrumentation { System::Web::Instrumentation::PageInstrumentationService ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.PageInstrumentation : System.Web.Instrumentation.PageInstrumentationService" Usage="System.Web.HttpContext.PageInstrumentation" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.Instrumentation.PageInstrumentationService</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取此要求的页检测服务实例的引用。</summary>
        <value>此请求的页检测服务实例。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviousHandler">
      <MemberSignature Language="C#" Value="public System.Web.IHttpHandler PreviousHandler { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.IHttpHandler PreviousHandler" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.PreviousHandler" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PreviousHandler As IHttpHandler" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::IHttpHandler ^ PreviousHandler { System::Web::IHttpHandler ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.PreviousHandler : System.Web.IHttpHandler" Usage="System.Web.HttpContext.PreviousHandler" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.IHttpHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取父处理程序的 <see cref="T:System.Web.IHttpHandler" /> 对象。</summary>
        <value><see cref="T:System.Web.IHttpHandler" /> 实例，如果未找到上一个处理程序，则为 <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 在 <xref:System.Web.HttpContext.PreviousHandler%2A> 执行当前请求之前，属性对应于最后一个处理程序。

 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.HttpContext.Handler" />
        <altmember cref="P:System.Web.HttpContext.CurrentHandler" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/bb398986(v=vs.100)">HTTP 处理程序和 HTTP 模块概述</related>
      </Docs>
    </Member>
    <Member MemberName="Profile">
      <MemberSignature Language="C#" Value="public System.Web.Profile.ProfileBase Profile { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.Profile.ProfileBase Profile" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.Profile" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Profile As ProfileBase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::Profile::ProfileBase ^ Profile { System::Web::Profile::ProfileBase ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Profile : System.Web.Profile.ProfileBase" Usage="System.Web.HttpContext.Profile" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.Profile.ProfileBase</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取当前用户配置文件的 <see cref="T:System.Web.Profile.ProfileBase" /> 对象。</summary>
        <value>如果应用程序配置文件包含配置文件的属性的定义，则为 <see cref="T:System.Web.Profile.ProfileBase" />；否则为 <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.Web.HttpContext.Profile%2A>属性用于使用类型安全 API 持久存储结构化数据。 当 <xref:System.Web.HttpContext.Profile%2A> 访问属性但不存在值时，将返回空实例; `null` 不返回。

 ]]></format>
        </remarks>
        <altmember cref="N:System.Web.Profile" />
      </Docs>
    </Member>
    <Member MemberName="RemapHandler">
      <MemberSignature Language="C#" Value="public void RemapHandler (System.Web.IHttpHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RemapHandler(class System.Web.IHttpHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.RemapHandler(System.Web.IHttpHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RemapHandler (handler As IHttpHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RemapHandler(System::Web::IHttpHandler ^ handler);" />
      <MemberSignature Language="F#" Value="member this.RemapHandler : System.Web.IHttpHandler -&gt; unit" Usage="httpContext.RemapHandler handler" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="handler" Type="System.Web.IHttpHandler" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="handler">应处理请求的对象。</param>
        <summary>用于为请求指定处理程序。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 如果将设置 `handler` 为 `null` ，则使用默认处理程序来处理请求。 可以将设置 `handler` 为异步处理程序或同步处理程序。 处理程序必须实现 <xref:System.Web.IHttpHandler> 接口。

 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="M:System.Web.HttpContext.RemapHandler(System.Web.IHttpHandler)" /> 方法是在发生 <see cref="E:System.Web.HttpApplication.MapRequestHandler" /> 事件之后调用的。</exception>
      </Docs>
    </Member>
    <Member MemberName="Request">
      <MemberSignature Language="C#" Value="public System.Web.HttpRequest Request { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpRequest Request" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.Request" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Request As HttpRequest" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::HttpRequest ^ Request { System::Web::HttpRequest ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Request : System.Web.HttpRequest" Usage="System.Web.HttpContext.Request" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName Language="C#">[get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.HttpRequest</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>为当前 HTTP 请求获取 <see cref="T:System.Web.HttpRequest" /> 对象。</summary>
        <value>当前 HTTP 请求的 <see cref="T:System.Web.HttpRequest" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.Web.HttpContext.Request%2A>属性提供对类的属性和方法的编程访问 <xref:System.Web.HttpRequest> 。 由于 ASP.NET 页包含对 <xref:System.Web> 包含) 类 (命名空间的默认引用 <xref:System.Web.HttpContext> ，因此可以 <xref:System.Web.HttpRequest> 在不使用对的完全限定类引用的情况下引用 .aspx 页上的成员 <xref:System.Web.HttpContext> 。 例如，你可以使用 `Request.Browser` 获取客户端浏览器的功能。 但是，如果你想要 <xref:System.Web.HttpRequest> 从 ASP.NET 代码隐藏模块使用的成员，则必须 <xref:System.Web> 在模块中包括对命名空间的引用，以及对当前活动的请求/响应上下文和 <xref:System.Web> 你要使用的中的类的完全限定引用。 例如，在代码隐藏页中，必须指定完全限定的名称 `HttpContext.Current.Request.Browser` 。

> [!NOTE]
>  如果在对象不可用时尝试使用此属性，ASP.NET 将引发异常 <xref:System.Web.HttpRequest> 。 例如，在 global.asax 文件的 Application_Start 方法中，或从 Application_Start 方法调用的方法中，这种情况都是如此。 此时，尚未创建 HTTP 请求。

 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Web 应用程序正在 IIS 7 的“集成”模式下运行。</exception>
      </Docs>
    </Member>
    <Member MemberName="Response">
      <MemberSignature Language="C#" Value="public System.Web.HttpResponse Response { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpResponse Response" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.Response" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Response As HttpResponse" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::HttpResponse ^ Response { System::Web::HttpResponse ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Response : System.Web.HttpResponse" Usage="System.Web.HttpContext.Response" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName Language="C#">[get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.HttpResponse</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取当前 HTTP 响应的 <see cref="T:System.Web.HttpResponse" /> 对象。</summary>
        <value>当前 HTTP 响应的 <see cref="T:System.Web.HttpResponse" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.Web.HttpContext.Response%2A>属性提供对类的属性和方法的编程访问 <xref:System.Web.HttpResponse> 。 由于 ASP.NET 页包含对 <xref:System.Web> 包含) 类 (命名空间的默认引用 <xref:System.Web.HttpContext> ，因此可以 <xref:System.Web.HttpContext> 在不使用对的完全限定类引用的情况下引用 .aspx 页上的成员 <xref:System.Web.HttpContext> 。 例如，可以使用 `Response.Write("some output")` 将输出写入 HTTP 输出流。 但是，如果要 <xref:System.Web.HttpResponse> 从 ASP.NET 代码隐藏模块使用的成员，则必须在模块中包括对命名空间的引用， <xref:System.Web> 并包含对当前活动的请求/响应上下文以及要使用的类的完全限定引用 <xref:System.Web> 。 例如，在代码隐藏页中，必须指定完全限定的名称 `HttpContext.Current.Response.Write("some output")` 。

 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Web 应用程序正在 IIS 7 的“集成”模式下运行。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="RewritePath">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>将对资源的请求重定向到另一路径，使其不同于所请求 URL 指示的路径。 <see cref="Overload:System.Web.HttpContext.RewritePath" /> 用于无 Cookie 会话状态中，作用是从 URL 中剥离会话 ID。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RewritePath">
      <MemberSignature Language="C#" Value="public void RewritePath (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RewritePath(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.RewritePath(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RewritePath (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RewritePath(System::String ^ path);" />
      <MemberSignature Language="F#" Value="member this.RewritePath : string -&gt; unit" Usage="httpContext.RewritePath path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">内部重写路径。</param>
        <summary>使用给定路径重写 URL。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 方法将对 <xref:System.Web.HttpContext.RewritePath%28System.String%29> 资源的请求重定向到的路径不同于所请求 URL 指示的路径。 如果必须重置虚拟路径，以便服务器资源的客户端请求正确解析，请使用此方法的重载，该重载采用 `rebaseClientPath` 参数并将参数设置为 `false` 。

 如果要在 Web 应用程序中重构页面，并且想要确保具有书签的旧 Url 的用户仍可以在移动页面后使用这些页面，则 URL 重写非常有用。 URL 重写使你能够以透明方式将请求转发到新的页面位置。

 如果要使站点能够使用更易于用户理解并经过优化搜索引擎的 Url，更可靠的替代方法是使用 ASP.NET 路由。 有关详细信息，请参阅 [ASP.NET 路由](https://docs.microsoft.com/previous-versions/aspnet/cc668201(v=vs.100))。



## Examples
 下面的示例演示如何使用方法来 <xref:System.Web.HttpContext.RewritePath%2A> 允许网站响应不反映网站中的文件结构的 url。 第一个代码块是名为 RewritePath 的 ASP.NET 网页。 它需要查询字符串。 如果你的网站的名称为 WebSite1，则 URL 会 `http://localhost/WebSite1/RewritePath.aspx?page=1` 在浏览器中显示 "第1页"。 Web 页面后的代码块是 `Application_BeginRequest` global.asax 文件中的事件处理程序。 此代码会截获对 Url （如）的请求 `http://localhost/WebSite1/page1` ，并将它们转换为 RewritePath 在处理之前所需的形式。 因此，该 URL 将 `http://localhost/WebSite1/page1` 调用 RewritePath，并在浏览器中显示 "第1页"。 如果收到 URL （如） `http://localhost/WebSite1/page1` ，则会调用的重载，以便 <xref:System.Web.HttpContext.RewritePath%2A> 提供属性的值 <xref:System.Web.HttpRequest.PathInfo%2A> 和查询字符串参数。

 [!code-aspx-csharp[HttpContext_RewritePath#2](~/samples/snippets/csharp/VS_Snippets_WebNet/HttpContext_ReWritePath/CS/rewritepath.aspx#2)]
 [!code-aspx-vb[HttpContext_RewritePath#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/HttpContext_ReWritePath/VB/rewritepath.aspx#2)]

 [!code-csharp[HttpContext_RewritePath#1](~/samples/snippets/csharp/VS_Snippets_WebNet/HttpContext_ReWritePath/CS/global.asax#1)]
 [!code-vb[HttpContext_RewritePath#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/HttpContext_ReWritePath/VB/global.asax#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> 参数为 <see langword="null" />。</exception>
        <exception cref="T:System.Web.HttpException"><paramref name="path" /> 参数不在当前应用程序的根目录中。</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/cc668201(v=vs.100)">ASP.NET 路由</related>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/dd329551(v=vs.140)">演练：在 Web 窗体应用程序中使用 ASP.NET 路由</related>
      </Docs>
    </Member>
    <Member MemberName="RewritePath">
      <MemberSignature Language="C#" Value="public void RewritePath (string path, bool rebaseClientPath);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RewritePath(string path, bool rebaseClientPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.RewritePath(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RewritePath (path As String, rebaseClientPath As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RewritePath(System::String ^ path, bool rebaseClientPath);" />
      <MemberSignature Language="F#" Value="member this.RewritePath : string * bool -&gt; unit" Usage="httpContext.RewritePath (path, rebaseClientPath)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="rebaseClientPath" Type="System.Boolean" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="path">内部重写路径。</param>
        <param name="rebaseClientPath">如果重置虚拟路径，则为 <see langword="true" />；如果保持虚拟路径不变，则为 <see langword="false" />。</param>
        <summary>使用给定路径和一个布尔值重写 URL，该布尔值用于指定是否修改服务器资源的虚拟路径。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.Web.HttpContext.RewritePath%28System.String%2CSystem.Boolean%29?displayProperty=nameWithType>方法由 <xref:System.Web.HttpContext.RewritePath%28System.String%29?displayProperty=nameWithType> 方法调用，且 `rebaseClientPath` 参数设置为 `true` 。 若要确保未修改用于构造资源路径的虚拟路径，请将 `rebaseClientPath` 参数设置为 `false` 。 通常情况下，你可能想要将设置 `rebaseClientPath` 为，这 `false` 是你需要重写 URL，并使用主题并将 URL 重定向到与所请求的资源位于不同文件夹中的资源时。

 如果要在 Web 应用程序中重构页面，并且想要确保具有书签的旧 Url 的用户仍可以在移动页面后使用这些页面，则 URL 重写非常有用。 URL 重写使你能够以透明方式将请求转发到新的页面位置。

 如果要使站点能够使用更易于用户理解并经过优化搜索引擎的 Url，更可靠的替代方法是使用 ASP.NET 路由。 有关详细信息，请参阅 [ASP.NET 路由](https://docs.microsoft.com/previous-versions/aspnet/cc668201(v=vs.100))。



## Examples
 有关代码示例，请参阅 <xref:System.Web.HttpContext.RewritePath%28System.String%29> 方法重载。

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> 参数为 <see langword="null" />。</exception>
        <exception cref="T:System.Web.HttpException"><paramref name="path" /> 参数不在当前应用程序的根目录中。</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/cc668201(v=vs.100)">ASP.NET 路由</related>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/dd329551(v=vs.140)">演练：在 Web 窗体应用程序中使用 ASP.NET 路由</related>
      </Docs>
    </Member>
    <Member MemberName="RewritePath">
      <MemberSignature Language="C#" Value="public void RewritePath (string filePath, string pathInfo, string queryString);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RewritePath(string filePath, string pathInfo, string queryString) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.RewritePath(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RewritePath (filePath As String, pathInfo As String, queryString As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RewritePath(System::String ^ filePath, System::String ^ pathInfo, System::String ^ queryString);" />
      <MemberSignature Language="F#" Value="member this.RewritePath : string * string * string -&gt; unit" Usage="httpContext.RewritePath (filePath, pathInfo, queryString)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filePath" Type="System.String" />
        <Parameter Name="pathInfo" Type="System.String" />
        <Parameter Name="queryString" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="filePath">内部重写路径。</param>
        <param name="pathInfo">资源的附加路径信息。 有关详细信息，请参阅 <see cref="P:System.Web.HttpRequest.PathInfo" />。</param>
        <param name="queryString">请求查询字符串。</param>
        <summary>使用给定的路径、路径信息和查询字符串信息重写 URL。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 方法将对 <xref:System.Web.HttpContext.RewritePath%2A> 资源的请求重定向到另一个资源，而无需更改 URL。

 `filePath`参数不包括 `pathInfo` 参数内容。 对于 URL `http://www.microsoft.com/virdir/page.html/tail` ， `filePath` 参数为 `http://www.microsoft.com/virdir/page.html` ， `pathInfo` 参数为 tail。

 如果要在 Web 应用程序中重构页面，并且想要确保具有书签的旧 Url 的用户仍可以在移动页面后使用这些页面，则 URL 重写非常有用。 URL 重写使你能够以透明方式将请求转发到新的页面位置。

 如果要使站点能够使用更易于用户理解并经过优化搜索引擎的 Url，更可靠的替代方法是使用 ASP.NET 路由。 有关详细信息，请参阅 [ASP.NET 路由](https://docs.microsoft.com/previous-versions/aspnet/cc668201(v=vs.100))。



## Examples
 有关代码示例（包括此方法重载的示例），请参阅 <xref:System.Web.HttpContext.RewritePath%28System.String%29> 方法重载。

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> 参数不在当前应用程序的根目录中。</exception>
        <exception cref="T:System.Web.HttpException"><paramref name="filePath" /> 参数不在当前应用程序的根目录中。</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/cc668201(v=vs.100)">ASP.NET 路由</related>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/dd329551(v=vs.140)">演练：在 Web 窗体应用程序中使用 ASP.NET 路由</related>
      </Docs>
    </Member>
    <Member MemberName="RewritePath">
      <MemberSignature Language="C#" Value="public void RewritePath (string filePath, string pathInfo, string queryString, bool setClientFilePath);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RewritePath(string filePath, string pathInfo, string queryString, bool setClientFilePath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.RewritePath(System.String,System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RewritePath (filePath As String, pathInfo As String, queryString As String, setClientFilePath As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RewritePath(System::String ^ filePath, System::String ^ pathInfo, System::String ^ queryString, bool setClientFilePath);" />
      <MemberSignature Language="F#" Value="member this.RewritePath : string * string * string * bool -&gt; unit" Usage="httpContext.RewritePath (filePath, pathInfo, queryString, setClientFilePath)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filePath" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="pathInfo" Type="System.String" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="queryString" Type="System.String" Index="2" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="setClientFilePath" Type="System.Boolean" Index="3" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="filePath">服务请求的资源的虚拟路径。</param>
        <param name="pathInfo">用于 URL 重定向的附加路径信息。 有关详细信息，请参阅 <see cref="P:System.Web.HttpRequest.PathInfo" />。</param>
        <param name="queryString">用于 URL 重定向的请求查询字符串。</param>
        <param name="setClientFilePath">若要将用于客户端资源的文件路径设置为 <paramref name="filePath" /> 参数的值，则为 <see langword="true" />；否则为 <see langword="false" />。</param>
        <summary>使用给定虚拟路径、路径信息、查询字符串信息和一个布尔值重写 URL，该布尔值用于指定是否将客户端文件路径设置为重写路径。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 `filePath`参数不包括参数的内容 `pathInfo` 。 对于 URL `http://www.microsoft.com/virdir/page.html/tail` ， `filePath` 参数为 `http://www.microsoft.com/virdir/page.html` ， `pathInfo` 参数为 tail。

 若要确保未修改用于构造资源路径的虚拟路径，请将 `setClientFilePath` 参数设置为 `false` 。 通常情况下，你可能想要将设置 `setClientFilePath` 为，这 `false` 是你需要重写 URL，并使用主题并将 URL 重定向到与所请求的资源位于不同文件夹中的资源时。

 如果要在 Web 应用程序中重构页面，并且想要确保具有书签的旧 Url 的用户仍可以在移动页面后使用这些页面，则 URL 重写非常有用。 URL 重写使你能够以透明方式将请求转发到新的页面位置。

 如果要使站点能够使用更易于用户理解并经过优化搜索引擎的 Url，更可靠的替代方法是使用 ASP.NET 路由。 有关详细信息，请参阅 [ASP.NET 路由](https://docs.microsoft.com/previous-versions/aspnet/cc668201(v=vs.100))。



## Examples
 有关代码示例，请参阅 <xref:System.Web.HttpContext.RewritePath%28System.String%29> 方法重载。

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> 参数不在当前应用程序的根目录中。</exception>
        <exception cref="T:System.Web.HttpException"><paramref name="filePath" /> 参数不在当前应用程序的根目录中。</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/cc668201(v=vs.100)">ASP.NET 路由</related>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/dd329551(v=vs.140)">演练：在 Web 窗体应用程序中使用 ASP.NET 路由</related>
      </Docs>
    </Member>
    <Member MemberName="Server">
      <MemberSignature Language="C#" Value="public System.Web.HttpServerUtility Server { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpServerUtility Server" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.Server" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Server As HttpServerUtility" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::HttpServerUtility ^ Server { System::Web::HttpServerUtility ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Server : System.Web.HttpServerUtility" Usage="System.Web.HttpContext.Server" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.HttpServerUtility</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取提供用于处理 Web 请求的方法的 <see cref="T:System.Web.HttpServerUtility" /> 对象。</summary>
        <value>当前 HTTP 请求的 <see cref="T:System.Web.HttpServerUtility" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.Web.HttpContext.Server%2A>属性提供对类的属性和方法的编程访问 <xref:System.Web.HttpServerUtility> 。 由于 ASP.NET 页包含对 <xref:System.Web> 包含) 类 (命名空间的默认引用 <xref:System.Web.HttpContext> ，因此可以 <xref:System.Web.HttpContext> 在不使用对的完全限定类引用的情况下引用 .aspx 页上的成员 <xref:System.Web.HttpContext> 。 例如，您可以使用在 `Server.CreateObject("MyCOMComponent")` 服务器上创建 COM 对象的实例。 但是，如果你想要 <xref:System.Web.HttpServerUtility> 从 ASP.NET 代码隐藏模块使用的成员，则必须 <xref:System.Web> 在模块中包括对命名空间的引用，以及对当前活动的请求/响应上下文和 <xref:System.Web> 你要使用的中的类的完全限定引用。 例如，在代码隐藏页中，必须指定完全限定的名称 `HttpContext.Current.Server.CreateObject("MyCOMComponent")` 。

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Session">
      <MemberSignature Language="C#" Value="public System.Web.SessionState.HttpSessionState Session { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.SessionState.HttpSessionState Session" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.Session" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Session As HttpSessionState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::SessionState::HttpSessionState ^ Session { System::Web::SessionState::HttpSessionState ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Session : System.Web.SessionState.HttpSessionState" Usage="System.Web.HttpContext.Session" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.SessionState.HttpSessionState</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>为当前 HTTP 请求获取 <see cref="T:System.Web.SessionState.HttpSessionState" /> 对象。</summary>
        <value>当前 HTTP 请求的 <see cref="T:System.Web.SessionState.HttpSessionState" /> 对象。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.Web.HttpContext.Session%2A>属性提供对类的属性和方法的编程访问 <xref:System.Web.SessionState.HttpSessionState> 。

 若要使用会话状态，必须启用它。 有关如何启用会话状态的信息，请参阅在 [ASP.NET 会话状态概述](https://docs.microsoft.com/previous-versions/aspnet/ms178581(v=vs.100))中 **配置会话状态**。

 有关如何在会话状态中保存值的信息，请参阅 [如何：在会话状态中保存值](https://docs.microsoft.com/previous-versions/aspnet/6ad7zeeb(v=vs.100))。 有关如何从会话状态读取值的信息，请参阅 [如何：读取会话状态的值](https://docs.microsoft.com/previous-versions/aspnet/03sekbw5(v=vs.100))。



## Examples
 下面的示例演示如何将值保存在会话状态中，以及如何从会话状态中读取值。

 这些示例需要：

-   已启用会话状态的 ASP.NET 应用程序。

-   有权访问属性的 Web 窗体页类 <xref:System.Web.UI.Page.Session%2A?displayProperty=nameWithType> ，或有权访问属性的任何类 <xref:System.Web.HttpContext.Current%2A?displayProperty=nameWithType> 。

```csharp
string firstName = "Jeff";
string lastName = "Smith";
string city = "Seattle";

// Save to session state in a Web Forms page class.
Session["FirstName"] = firstName;
Session["LastName"] = lastName;
Session["City"] = city;

// Read from session state in a Web Forms page class.
firstName = (string)(Session["FirstName"]);
lastName = (string)(Session["LastName"]);
city = (string)(Session["City"]);

// Outside of Web Forms page class, use HttpContext.Current.
HttpContext context = HttpContext.Current;
context.Session["FirstName"] = firstName;
firstName = (string)(context.Session["FirstName"]);

```

```vb
Dim firstName As String = "Jeff"
Dim lastName As String = "Smith"
Dim city As String = "Seattle"

' Save to session state in a Web Forms page class.
Session("FirstName") = firstName
Session("LastName") = lastName
Session("City") = city

' Read from session state in a Web Forms page class.
firstName = DirectCast(Session("FirstName"), String)
lastName = DirectCast(Session("LastName"), String)
city = DirectCast(Session("City"), String)

' Outside of Web Forms page class, use HttpContext.Current.
Dim context As HttpContext = HttpContext.Current
context.Session("FirstName") = firstName
firstName = DirectCast(context.Session("FirstName"), String)

```

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetSessionStateBehavior">
      <MemberSignature Language="C#" Value="public void SetSessionStateBehavior (System.Web.SessionState.SessionStateBehavior sessionStateBehavior);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetSessionStateBehavior(valuetype System.Web.SessionState.SessionStateBehavior sessionStateBehavior) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.SetSessionStateBehavior(System.Web.SessionState.SessionStateBehavior)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetSessionStateBehavior (sessionStateBehavior As SessionStateBehavior)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetSessionStateBehavior(System::Web::SessionState::SessionStateBehavior sessionStateBehavior);" />
      <MemberSignature Language="F#" Value="member this.SetSessionStateBehavior : System.Web.SessionState.SessionStateBehavior -&gt; unit" Usage="httpContext.SetSessionStateBehavior sessionStateBehavior" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sessionStateBehavior" Type="System.Web.SessionState.SessionStateBehavior" Index="0" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="sessionStateBehavior">枚举值之一，该值指定需要什么类型的会话状态行为。</param>
        <summary>设置支持 HTTP 请求所需的会话状态行为的类型。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 在 ASP.NET 默认实现中，HTTP 请求处理程序通过实现接口或接口来指示它是否需要会话状态 <xref:System.Web.SessionState.IRequiresSessionState> <xref:System.Web.SessionState.IReadOnlySessionState> 。 <xref:System.Web.HttpContext.SetSessionStateBehavior%2A>方法和 <xref:System.Web.SessionState.SessionStateBehavior> 枚举使你可以提供用于处理请求所需的会话状态支持类型的更多详细信息。 有关详细信息，请参见 <xref:System.Web.SessionState.SessionStateBehavior> 枚举。

 <xref:System.Web.HttpContext.SetSessionStateBehavior%2A>必须在管道事件之前调用方法 <xref:System.Web.HttpApplication.AcquireRequestState> 。 此事件期间或之后发生的调用将导致 <xref:System.InvalidOperationException> 异常。

 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">该方法是在引发 <see cref="E:System.Web.HttpApplication.AcquireRequestState" /> 事件之后调用的。</exception>
        <altmember cref="T:System.Web.SessionState.SessionStateBehavior" />
      </Docs>
    </Member>
    <Member MemberName="SkipAuthorization">
      <MemberSignature Language="C#" Value="public bool SkipAuthorization { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SkipAuthorization" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.SkipAuthorization" />
      <MemberSignature Language="VB.NET" Value="Public Property SkipAuthorization As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool SkipAuthorization { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.SkipAuthorization : bool with get, set" Usage="System.Web.HttpContext.SkipAuthorization" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指定 <see cref="T:System.Web.Security.UrlAuthorizationModule" /> 对象是否应跳过对当前请求的授权检查。</summary>
        <value>如果 <see cref="T:System.Web.Security.UrlAuthorizationModule" /> 应跳过授权检查，则为 <see langword="true" />；否则为 <see langword="false" />。 默认值为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.Web.HttpContext.SkipAuthorization%2A>属性旨在供需要重定向到允许匿名连接的页面的身份验证模块进行高级使用。 Forms 身份验证模块和 Passport 身份验证模块都在 <xref:System.Web.HttpContext.SkipAuthorization%2A> 重定向到已配置的登录页时设置。 设置 <xref:System.Web.HttpContext.SkipAuthorization%2A> 要求 `ControlPrincipal` 设置标志。 有关标志的信息 `ControlPrincipal` ，请参阅 <xref:System.Security.Permissions.SecurityPermissionFlag> 。

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IServiceProvider.GetService">
      <MemberSignature Language="C#" Value="object IServiceProvider.GetService (Type service);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance object System.IServiceProvider.GetService(class System.Type service) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.System#IServiceProvider#GetService(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Function GetService (service As Type) As Object Implements IServiceProvider.GetService" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Object ^ System.IServiceProvider.GetService(Type ^ service) = IServiceProvider::GetService;" />
      <MemberSignature Language="F#" Value="abstract member System.IServiceProvider.GetService : Type -&gt; obj&#xA;override this.System.IServiceProvider.GetService : Type -&gt; obj" Usage="httpContext.System.IServiceProvider.GetService service" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IServiceProvider.GetService(System.Type)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="service" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="service">要将服务提供商设置为的 <see cref="T:System.Web.HttpContext" /> 服务类型。</param>
        <summary>返回当前服务类型的对象。</summary>
        <returns>如果找到服务，则为 <see cref="T:System.Web.HttpContext" />；否则为 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 此方法可用于获取对基础对象的访问权限 <xref:System.Web.HttpWorkerRequest> 。

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ThreadAbortOnTimeout">
      <MemberSignature Language="C#" Value="public bool ThreadAbortOnTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ThreadAbortOnTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.ThreadAbortOnTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Property ThreadAbortOnTimeout As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ThreadAbortOnTimeout { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ThreadAbortOnTimeout : bool with get, set" Usage="System.Web.HttpContext.ThreadAbortOnTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，此值指示 ASP.NET 运行时是否应在请求超时时，调用为该请求提供服务的线程上的 <see cref="M:System.Threading.Thread.Abort" />。</summary>
        <value>如果在线程超时时调用 <see cref="M:System.Threading.Thread.Abort" />，则为 <see langword="true" />；否则为 <see langword="false" />。 默认值为 <see langword="true" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 在使用属性实现协作取消的处理程序和模块中 <xref:System.Web.HttpRequest.TimedOutToken%2A?displayProperty=nameWithType> ，你可能希望禁用在请求超 <xref:System.Threading.Thread.Abort%2A?displayProperty=nameWithType> 时时 ASP.NET 默认执行的行为。如果将此属性设置为， `false` 则可帮助您确保在不中断 ASP.NET 的情况下运行取消和清理例程。

 如果将此属性设置为 `false` ，则在发生超时时，ASP.NET 不会自动显示 "请求超时" 错误页。 应用程序负责正确设置响应内容。

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Timestamp">
      <MemberSignature Language="C#" Value="public DateTime Timestamp { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime Timestamp" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.Timestamp" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Timestamp As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime Timestamp { DateTime get(); };" />
      <MemberSignature Language="F#" Value="member this.Timestamp : DateTime" Usage="System.Web.HttpContext.Timestamp" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取当前 HTTP 请求的初始时间戳。</summary>
        <value>当前 HTTP 请求的时间戳。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 从属性返回的时间戳 <xref:System.Web.HttpContext.Timestamp%2A> 是服务器的本地时间，在对象的实例化过程中设置 <xref:System.Web.HttpContext> 。 本地时间等于 UTC 时间加上 UTC 偏移量。

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Trace">
      <MemberSignature Language="C#" Value="public System.Web.TraceContext Trace { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.TraceContext Trace" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.Trace" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Trace As TraceContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::TraceContext ^ Trace { System::Web::TraceContext ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Trace : System.Web.TraceContext" Usage="System.Web.HttpContext.Trace" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.TraceContext</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取当前 HTTP 响应的 <see cref="T:System.Web.TraceContext" /> 对象。</summary>
        <value>当前 HTTP 响应的 <see cref="T:System.Web.TraceContext" />。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="User">
      <MemberSignature Language="C#" Value="public System.Security.Principal.IPrincipal User { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Principal.IPrincipal User" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.User" />
      <MemberSignature Language="VB.NET" Value="Public Property User As IPrincipal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Principal::IPrincipal ^ User { System::Security::Principal::IPrincipal ^ get(); void set(System::Security::Principal::IPrincipal ^ value); };" />
      <MemberSignature Language="F#" Value="member this.User : System.Security.Principal.IPrincipal with get, set" Usage="System.Web.HttpContext.User" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.Principal.IPrincipal</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置当前 HTTP 请求的安全信息。</summary>
        <value>当前 HTTP 请求的安全信息。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.Web.HttpContext.User%2A>属性提供对接口的属性和方法的编程访问 <xref:System.Security.Principal.IPrincipal> 。

 由于 ASP.NET 页包含对 <xref:System.Web> 包含) 类 (命名空间的默认引用 <xref:System.Web.HttpContext> ，因此可以 <xref:System.Web.HttpContext> 在不使用对的完全限定类引用的情况下引用 .aspx 页上的成员 <xref:System.Web.HttpContext> 。 例如，可以使用 `User.Identity.Name` 获取当前进程正在其上运行的用户的名称。 但是，如果你想要 <xref:System.Security.Principal.IPrincipal> 从 ASP.NET 代码隐藏模块使用的成员，则必须 <xref:System.Web> 在模块中包括对命名空间的引用，以及对当前活动的请求/响应上下文和 <xref:System.Web> 你要使用的中的类的完全限定引用。 例如，在代码隐藏页中，必须指定完全限定的名称 `HttpContext.Current.User.Identity.Name` 。



## Examples
 下面的示例演示如何通过属性访问当前用户的属性 <xref:System.Web.HttpContext.User%2A> 。 这些属性用于设置网页标题。

 如果应用程序使用 Windows 身份验证，则用户名将包括域。 例如，页标题为 "域 \ 用户名的主页"。

 [!code-csharp[System.Web.HttpContext.User#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpContext.User/cs/Default.aspx.cs#1)]
 [!code-vb[System.Web.HttpContext.User#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpContext.User/vb/Default.aspx.vb#1)]

 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="/aspnet/mvc/overview/older-versions/using-oauth-providers-with-mvc">通过 MVC 4 使用 OAuth 提供程序</related>
        <related type="ExternalDocumentation" href="/aspnet/web-forms/overview/getting-started/getting-started-with-aspnet-45-web-forms/checkout-and-payment-with-paypal">ASP.NET 4.5 Web 窗体入门，通过 PayPal 结帐和付款</related>
        <related type="ExternalDocumentation" href="/aspnet/mvc/overview/older-versions-1/nerddinner/secure-applications-using-authentication-and-authorization">NerdDinner-使用身份验证和授权的安全应用程序</related>
      </Docs>
    </Member>
    <Member MemberName="WebSocketNegotiatedProtocol">
      <MemberSignature Language="C#" Value="public string WebSocketNegotiatedProtocol { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string WebSocketNegotiatedProtocol" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.WebSocketNegotiatedProtocol" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WebSocketNegotiatedProtocol As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ WebSocketNegotiatedProtocol { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.WebSocketNegotiatedProtocol : string" Usage="System.Web.HttpContext.WebSocketNegotiatedProtocol" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取用于 <see cref="T:System.Web.WebSockets.AspNetWebSocket" /> 连接而从服务器发送到客户端的协商协议。</summary>
        <value>协商协议。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="WebSocketRequestedProtocols">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IList&lt;string&gt; WebSocketRequestedProtocols { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IList`1&lt;string&gt; WebSocketRequestedProtocols" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.WebSocketRequestedProtocols" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WebSocketRequestedProtocols As IList(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::IList&lt;System::String ^&gt; ^ WebSocketRequestedProtocols { System::Collections::Generic::IList&lt;System::String ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.WebSocketRequestedProtocols : System.Collections.Generic.IList&lt;string&gt;" Usage="System.Web.HttpContext.WebSocketRequestedProtocols" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取客户要求的子协议列表的有序列表。</summary>
        <value>请求的协议，如果不是 <see cref="T:System.Web.WebSockets.AspNetWebSocket" /> 请求，或者列表不存在则为 <see langword="null" />。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
