<Type Name="HttpRequest" FullName="System.Web.HttpRequest">
  <Metadata><Meta Name="ms.openlocfilehash" Value="6c5463858a97e4fd47aa4b8477cc76c116a75f7c" /><Meta Name="ms.sourcegitcommit" Value="b53d35b4a410c949742abd4c6a989d1af5357bca" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-CN" /><Meta Name="ms.lasthandoff" Value="07/21/2020" /><Meta Name="ms.locfileid" Value="86654730" /></Metadata><TypeSignature Language="C#" Value="public sealed class HttpRequest" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit HttpRequest extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Web.HttpRequest" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class HttpRequest" />
  <TypeSignature Language="C++ CLI" Value="public ref class HttpRequest sealed" />
  <TypeSignature Language="F#" Value="type HttpRequest = class" />
  <AssemblyInfo>
    <AssemblyName>System.Web</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>使 ASP.NET 能够读取客户端在 Web 请求期间发送的 HTTP 值。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[

## Remarks
 类的方法和属性 <xref:System.Web.HttpRequest> 通过 `Request` <xref:System.Web.HttpApplication> 、 <xref:System.Web.HttpContext> 、 <xref:System.Web.UI.Page> 和类的属性公开 <xref:System.Web.UI.UserControl> 。

 若要访问 <xref:System.Web.HttpRequest.QueryString%2A> 、、或集合中的数据， <xref:System.Web.HttpRequest.Form%2A> <xref:System.Web.HttpRequest.Cookies%2A> <xref:System.Web.HttpRequest.ServerVariables%2A> 可以编写， `Request["key"]` 如属性的示例中所示 <xref:System.Web.HttpRequest.QueryString%2A> 。

> [!NOTE]
>  类成员的 Unicode 支持 <xref:System.Web.HttpRequest> 需要 IIS 版本6.0 或更高版本。



## Examples
 下面的示例 <xref:System.Web.HttpRequest> 使用类的属性访问当前请求的实例 <xref:System.Web.UI.Page.Request%2A> <xref:System.Web.UI.Page> 。

 您可以使用简化的语法来访问 <xref:System.Web.HttpRequest.QueryString%2A> 、 <xref:System.Web.HttpRequest.Form%2A> 、 <xref:System.Web.HttpRequest.Cookies%2A> 或集合中的数据 <xref:System.Web.HttpRequest.ServerVariables%2A> 。 可以写入 `Request["key"]` 。

 第一个示例演示如何在加载页面时检索查询字符串值。

```csharp
public partial class AddToCart : Page
{
    protected void Page_Load(object sender, EventArgs e)
    {
        string rawId = Request["ProductID"];
        int productId;
        if (!String.IsNullOrEmpty(rawId) && int.TryParse(rawId, out productId))
        {
            using (ShoppingCartActions usersShoppingCart = new ShoppingCartActions())
            {
                usersShoppingCart.AddToCart(productId);
            }
        }
        else
        {
            throw new Exception("Tried to call AddToCart.aspx without setting a ProductId.");
        }
        Response.Redirect("ShoppingCart.aspx");
    }
}
```

```vb
Public Class AddToCart
    Inherits Page

    Protected Sub Page_Load(ByVal sender As Object, ByVal e As EventArgs) Handles Me.Load
        Dim rawId = Request("ProductID")
        Dim productId As Integer
        If Not String.IsNullOrEmpty(rawId) And Integer.TryParse(rawId, productId) Then
            Using usersShoppingCart As New ShoppingCartActions()
                usersShoppingCart.AddToCart(productId)
            End Using

        Else
            Throw New Exception("Tried to call AddToCart.aspx without setting a ProductId.")
        End If
        Response.Redirect("ShoppingCart.aspx")
    End Sub
End Class
```

 下一个示例演示如何检查请求是否经过身份验证并检索原始 URL。

```csharp
public partial class RestrictedPage : Page
{
    protected void Page_Load(object sender, EventArgs e)
    {
        if (!Request.IsAuthenticated)
        {
            var rawUrl = Request.RawUrl;
            Response.Redirect("/Account/Login?ru=" + Server.HtmlEncode(rawUrl));
        }
    }
}
```

```vb
Public Class RestrictedPage
    Inherits Page

    Protected Sub Page_Load(ByVal sender As Object, ByVal e As EventArgs) Handles Me.Load
        If Not Request.IsAuthenticated Then
            Dim rawUrl = Request.RawUrl
            Response.Redirect("/Account/Login?ru=" + Server.HtmlEncode(rawUrl))
        End If
    End Sub
End Class
```

 本主题提供了包含源代码的 Visual Studio 网站项目： [下载](https://go.microsoft.com/fwlink/?LinkID=191455)。

 此示例使用 <xref:System.IO.StreamWriter> 类将多个类属性的值写入 <xref:System.Web.HttpRequest> 文件。 对于类型为字符串的属性，这些值将在写入文件时以 HTML 编码形式进行编码。 表示集合的属性会被循环，它们所包含的每个键/值对都将写入文件中。

> [!IMPORTANT]
>  此示例具有一个接受用户输入的文本框，这是一个潜在的安全威胁。 默认情况下，ASP.NET 网页验证用户输入是否不包含脚本或 HTML 元素。 有关详细信息，请参阅[脚本侵入概述](https://docs.microsoft.com/previous-versions/aspnet/w1sw53ds(v=vs.100))。

 [!code-aspx-csharp[System.Web.HttpRequest_Sample1#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/CS/requestdetailscs.aspx#1)]
 [!code-aspx-vb[System.Web.HttpRequest_Sample1#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/VB/requestdetailsvb.aspx#1)]

 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public HttpRequest (string filename, string url, string queryString);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string filename, string url, string queryString) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpRequest.#ctor(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (filename As String, url As String, queryString As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; HttpRequest(System::String ^ filename, System::String ^ url, System::String ^ queryString);" />
      <MemberSignature Language="F#" Value="new System.Web.HttpRequest : string * string * string -&gt; System.Web.HttpRequest" Usage="new System.Web.HttpRequest (filename, url, queryString)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="filename" Type="System.String" />
        <Parameter Name="url" Type="System.String" />
        <Parameter Name="queryString" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="filename">与请求关联的文件的名称。</param>
        <param name="url">关于当前请求的 URL 的信息。</param>
        <param name="queryString">与请求一同发送的整个查询字符串（“?”<c></c>之后的所有内容）。</param>
        <summary>初始化 <see cref="T:System.Web.HttpRequest" /> 对象。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 您无需创建您自己的类的实例 <xref:System.Web.HttpRequest> 。 类的方法和属性 <xref:System.Web.HttpRequest> 通过 `Request` <xref:System.Web.HttpApplication> 、 <xref:System.Web.HttpContext> 、 <xref:System.Web.UI.Page> 和类的属性公开 <xref:System.Web.UI.UserControl> 。

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Abort">
      <MemberSignature Language="C#" Value="public void Abort ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Abort() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpRequest.Abort" />
      <MemberSignature Language="VB.NET" Value="Public Sub Abort ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Abort();" />
      <MemberSignature Language="F#" Value="member this.Abort : unit -&gt; unit" Usage="httpRequest.Abort " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>强制地终止基础 TCP 连接，会导致任何显著的 I/O 失败。 可使用此方法来响应恶意 HTTP 客户端的攻击。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 此方法是线程安全的。 任何线程都可以随时调用它。

 此方法只能在集成模式下使用。 如果在经典模式下调用它，则会引发异常。 若要确定管道模式，请使用 <xref:System.Web.HttpRuntime.UsingIntegratedPipeline%2A> 。

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AcceptTypes">
      <MemberSignature Language="C#" Value="public string[] AcceptTypes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string[] AcceptTypes" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.AcceptTypes" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AcceptTypes As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::String ^&gt; ^ AcceptTypes { cli::array &lt;System::String ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AcceptTypes : string[]" Usage="System.Web.HttpRequest.AcceptTypes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取客户端支持的 MIME 接受类型的字符串数组。</summary>
        <value>客户端支持的 MIME 接受类型的字符串数组。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Examples
 下面的代码示例将属性返回的多个值捕获 <xref:System.Web.HttpRequest.AcceptTypes%2A> 到一个对象变量中，并将每个值的数目和名称写入到单独的 HTTP 输出行中。

 [!code-csharp[Classic HttpRequest.AcceptTypes Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpRequest.AcceptTypes Example/CS/source.cs#1)]
 [!code-vb[Classic HttpRequest.AcceptTypes Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpRequest.AcceptTypes Example/VB/source.vb#1)]

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AnonymousID">
      <MemberSignature Language="C#" Value="public string AnonymousID { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string AnonymousID" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.AnonymousID" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AnonymousID As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ AnonymousID { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AnonymousID : string" Usage="System.Web.HttpRequest.AnonymousID" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取该用户的匿名标识符（如果存在）。</summary>
        <value>字符串，表示当前匿名用户标识符。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.Web.HttpRequest.AnonymousID%2A>属性为未经过身份验证的用户分配长生存期的唯一标识符，该标识符可用于跟踪用户或将配置文件属性分配给该用户，而无需将数据存储在 `Session` 对象中。 默认情况下， <xref:System.Web.HttpRequest.AnonymousID%2A> 使用 cookie 跟踪属性，但在 <xref:System.Web.Configuration.SessionStateSection.Cookieless%2A> "匿名标识配置" 部分的属性设置为 <xref:System.Web.HttpCookieMode.UseUri> 、 <xref:System.Web.HttpCookieMode.UseDeviceProfile> 或值时，可以将其设置为使用 URI <xref:System.Web.HttpCookieMode.AutoDetect> 。 如果不再需要 cookie （例如，对匿名用户进行身份验证），则必须显式清除该 cookie。

 如果需要确定没有经过身份验证的实体和需要授权的实体，则使用匿名身份验证。 有关详细信息，请参阅 [AnonymousIdentification 元素 (ASP.NET Settings Schema) ](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/91ka2e6a(v=vs.100))



## Examples
 下面的示例演示如何 <xref:System.Web.HttpRequest.AnonymousID%2A> 通过处理 global.asax 文件中的事件来使用属性 <xref:System.Web.Security.AnonymousIdentificationModule.Creating> 。 此示例包含两个部分：

-   Global.asax 文件中处理事件的方法 <xref:System.Web.Security.AnonymousIdentificationModule.Creating> 。

-   Web 窗体页。

 此代码示例的第一部分演示如何 <xref:System.Web.HttpRequest.AnonymousID%2A> 通过 <xref:System.Web.Security.AnonymousIdentificationModule.Creating> 在 global.asax 文件中处理事件来设置属性。 命名的方法 `AnonymousIdentification_Creating` <xref:System.Web.HttpRequest.AnonymousID%2A> 在创建匿名 ID 时设置属性。

 [!code-csharp[System.Web.HttpRequest_AnonymousID#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest_AnonymousID/CS/global_asax.cs#2)]
 [!code-vb[System.Web.HttpRequest_AnonymousID#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest_AnonymousID/vb/global_asax.vb#2)]

 此代码示例的第二部分演示如何显示 <xref:System.Web.HttpRequest.AnonymousID%2A> `AnonymousIdentification_Creating` 在前面的示例中由事件处理程序创建的新。

 [!code-aspx-csharp[System.Web.HttpRequest_AnonymousID#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest_AnonymousID/CS/anonid_cs.aspx#1)]
 [!code-aspx-vb[System.Web.HttpRequest_AnonymousID#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest_AnonymousID/vb/anonid_vb.aspx#1)]

 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.HttpRequest.IsAuthenticated" />
        <altmember cref="E:System.Web.Security.AnonymousIdentificationModule.Creating" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/91ka2e6a(v=vs.100)">anonymousIdentification 元素（ASP.NET 设置架构）</related>
      </Docs>
    </Member>
    <Member MemberName="ApplicationPath">
      <MemberSignature Language="C#" Value="public string ApplicationPath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ApplicationPath" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.ApplicationPath" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ApplicationPath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ApplicationPath { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ApplicationPath : string" Usage="System.Web.HttpRequest.ApplicationPath" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取服务器上 ASP.NET 应用程序的虚拟应用程序根路径。</summary>
        <value>当前应用程序的虚拟路径。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 使用此属性，可以从根目录之外的页面或 Web 用户控件构造相对于应用程序根的 URL。 这允许在目录结构的不同级别上存在的页和共享控件使用相同的代码链接到应用程序中固定位置的资源。



## Examples
 下面的示例使用 <xref:System.IO.StreamWriter.Write%2A> 方法对进行 HTML 编码，然后将属性的值写入 <xref:System.Web.HttpRequest.ApplicationPath%2A> 文本文件。 此代码示例是为类提供的更大示例的一部分 <xref:System.Web.HttpRequest> 。 它假定存在一个 <xref:System.IO.StreamWriter> 名为的对象 `sw` 。

 [!code-csharp[System.Web.HttpRequest_Sample1#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/CS/requestdetailscs.aspx#2)]
 [!code-vb[System.Web.HttpRequest_Sample1#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/VB/requestdetailsvb.aspx#2)]

 下面的示例使用 <xref:System.Web.HttpRequest.ApplicationPath%2A> 属性以编程方式构造指向应用程序中固定位置的资源的路径。 引用资源的页面不必与资源位于同一个目录中。

 [!code-aspx-csharp[System.Web.HttpRequest.ApplicationPath#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest.ApplicationPath/CS/ApplicationPath.aspx#2)]
 [!code-aspx-vb[System.Web.HttpRequest.ApplicationPath#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest.ApplicationPath/VB/ApplicationPath.aspx#2)]

 如果在名为 WebSite1 的 Web 应用程序中运行此示例，则  `/WebSite1` 将显示为属性的值 <xref:System.Web.HttpRequest.ApplicationPath%2A> ，并 `/WebSite1/images/Image1.gif` 将显示为图像的完整路径。

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AppRelativeCurrentExecutionFilePath">
      <MemberSignature Language="C#" Value="public string AppRelativeCurrentExecutionFilePath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string AppRelativeCurrentExecutionFilePath" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.AppRelativeCurrentExecutionFilePath" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AppRelativeCurrentExecutionFilePath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ AppRelativeCurrentExecutionFilePath { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AppRelativeCurrentExecutionFilePath : string" Usage="System.Web.HttpRequest.AppRelativeCurrentExecutionFilePath" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取应用程序根目录的虚拟路径，并通过对应用程序根目录使用波形符 (\~) 表示法（例如，以“\~/page.aspx”的形式）使该路径成为相对路径。</summary>
        <value>当前请求的应用程序根的虚拟路径。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 使用此属性可提供在应用程序更改位置时仍保持不变的 URL 信息。 这允许在测试环境和最终部署环境中使用相同的 URL 映射代码，或将其用于不同域中的 Web 应用程序副本。



## Examples
 下面的示例使用 <xref:System.Web.HttpRequest.AppRelativeCurrentExecutionFilePath%2A> 属性将控件的 URL 设置为 <xref:System.Web.UI.WebControls.Image> 页所在的同一目录中的图像。 在目录结构的不同级别运行此页可查看生成的 <xref:System.Web.HttpRequest.AppRelativeCurrentExecutionFilePath%2A> 属性值。

 [!code-aspx-csharp[System.Web.HttpRequest.AppRelativeCurrentExecutionPath#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest.AppRelativeCurrentExecutionPath/CS/AppRelativeCurrentExecutionPathCS.aspx#1)]
 [!code-aspx-vb[System.Web.HttpRequest.AppRelativeCurrentExecutionPath#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest.AppRelativeCurrentExecutionPath/VB/AppRelativeCurrentExecutionPathVB.aspx#1)]

 下面的示例使用 <xref:System.Web.HttpRequest.AppRelativeCurrentExecutionFilePath%2A> 属性，基于页面的当前路径以编程方式设置资源的路径。

 [!code-aspx-csharp[System.Web.HttpRequest.ApplicationPath#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest.ApplicationPath/CS/apprelativecurrentexecutionfilepath.aspx#1)]
 [!code-aspx-vb[System.Web.HttpRequest.ApplicationPath#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest.ApplicationPath/VB/apprelativecurrentexecutionfilepath.aspx#1)]

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BinaryRead">
      <MemberSignature Language="C#" Value="public byte[] BinaryRead (int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8[] BinaryRead(int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpRequest.BinaryRead(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function BinaryRead (count As Integer) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Byte&gt; ^ BinaryRead(int count);" />
      <MemberSignature Language="F#" Value="member this.BinaryRead : int -&gt; byte[]" Usage="httpRequest.BinaryRead count" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="count">要读取的字节数。</param>
        <summary>执行对当前输入流进行指定字节数的二进制读取。</summary>
        <returns>一个字节数组。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.Web.HttpRequest.BinaryRead%2A>提供此方法是为了与 ASP 兼容。

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="count" /> 为 0。

- 或 -

 <paramref name="count" /> 大于可用的字节数。</exception>
      </Docs>
    </Member>
    <Member MemberName="Browser">
      <MemberSignature Language="C#" Value="public System.Web.HttpBrowserCapabilities Browser { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpBrowserCapabilities Browser" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.Browser" />
      <MemberSignature Language="VB.NET" Value="Public Property Browser As HttpBrowserCapabilities" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::HttpBrowserCapabilities ^ Browser { System::Web::HttpBrowserCapabilities ^ get(); void set(System::Web::HttpBrowserCapabilities ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Browser : System.Web.HttpBrowserCapabilities with get, set" Usage="System.Web.HttpRequest.Browser" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.HttpBrowserCapabilities</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置有关正在请求的客户端的浏览器功能的信息。</summary>
        <value>列出客户端浏览器功能的 <see cref="T:System.Web.HttpBrowserCapabilities" /> 对象。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Examples
 下面的代码示例将浏览器的功能列表返回到 HTML 页中的客户端。

 [!code-csharp[Classic HttpRequest.Browser Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpRequest.Browser Example/CS/source.cs#1)]
 [!code-vb[Classic HttpRequest.Browser Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpRequest.Browser Example/VB/source.vb#1)]

 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.Page.ClientTarget" />
        <altmember cref="T:System.Web.HttpBrowserCapabilities" />
        <altmember cref="P:System.Web.HttpRequest.UserAgent" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/x3k2ssx2(v=vs.100)">ASP.NET 服务器控件和浏览器功能</related>
      </Docs>
    </Member>
    <Member MemberName="ClientCertificate">
      <MemberSignature Language="C#" Value="public System.Web.HttpClientCertificate ClientCertificate { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpClientCertificate ClientCertificate" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.ClientCertificate" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ClientCertificate As HttpClientCertificate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::HttpClientCertificate ^ ClientCertificate { System::Web::HttpClientCertificate ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ClientCertificate : System.Web.HttpClientCertificate" Usage="System.Web.HttpRequest.ClientCertificate" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.HttpClientCertificate</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取当前请求的客户端安全证书。</summary>
        <value>包含有关客户端安全证书设置的信息的 <see cref="T:System.Web.HttpClientCertificate" /> 对象。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Examples
 下面的代码示例在 HTML 页中将客户端的证书设置发送回客户端。

 [!code-csharp[Classic HttpRequest.ClientCertificate Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpRequest.ClientCertificate Example/CS/source.cs#1)]
 [!code-vb[Classic HttpRequest.ClientCertificate Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpRequest.ClientCertificate Example/VB/source.vb#1)]

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContentEncoding">
      <MemberSignature Language="C#" Value="public System.Text.Encoding ContentEncoding { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Text.Encoding ContentEncoding" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.ContentEncoding" />
      <MemberSignature Language="VB.NET" Value="Public Property ContentEncoding As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Text::Encoding ^ ContentEncoding { System::Text::Encoding ^ get(); void set(System::Text::Encoding ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ContentEncoding : System.Text.Encoding with get, set" Usage="System.Web.HttpRequest.ContentEncoding" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置实体主体的字符集。</summary>
        <value>表示客户端的字符集的 <see cref="T:System.Text.Encoding" /> 对象。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 可以在配置文件 [ (ASP.NET 设置架构) 中的全球化元素 ](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/hy4kkhe0(v=vs.100)) 中指定默认内容编码。 如果客户端也指定了内容编码，则会重写默认配置设置。



## Examples
 下面的代码示例将一个表示当前 HTTP 编码说明的值分配给一个字符串变量。

 [!code-csharp[Classic HttpRequest.ContentEncoding Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpRequest.ContentEncoding Example/CS/source.cs#1)]
 [!code-vb[Classic HttpRequest.ContentEncoding Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpRequest.ContentEncoding Example/VB/source.vb#1)]

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContentLength">
      <MemberSignature Language="C#" Value="public int ContentLength { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ContentLength" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.ContentLength" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ContentLength As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ContentLength { int get(); };" />
      <MemberSignature Language="F#" Value="member this.ContentLength : int" Usage="System.Web.HttpRequest.ContentLength" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指定客户端发送的内容的长度(以字节为单位)。</summary>
        <value>客户端发送的内容的长度(以字节为单位)。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Examples
 下面的代码示例将表示传入请求的内容长度的值分配给整数变量。

 [!code-csharp[Classic HttpRequest.ContentLength Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpRequest.ContentLength Example/CS/source.cs#1)]
 [!code-vb[Classic HttpRequest.ContentLength Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpRequest.ContentLength Example/VB/source.vb#1)]

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContentType">
      <MemberSignature Language="C#" Value="public string ContentType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ContentType" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.ContentType" />
      <MemberSignature Language="VB.NET" Value="Public Property ContentType As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ContentType { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ContentType : string with get, set" Usage="System.Web.HttpRequest.ContentType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置传入请求的 MIME 内容类型。</summary>
        <value>表示传入请求的 MIME 内容类型的字符串，例如，“text/html”。 其他常见 MIME 类型包括“audio.wav”、“image/gif”和“application/pdf”。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Examples
 下面的代码示例将表示传入请求的内容类型的值分配给字符串变量。

 [!code-csharp[Classic HttpRequest.ContentType Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpRequest.ContentType Example/CS/source.cs#1)]
 [!code-vb[Classic HttpRequest.ContentType Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpRequest.ContentType Example/VB/source.vb#1)]

 下面的示例演示了此代码可能生成的输出。

 `GET`

 `127.0.0.1`

 `127.0.0.1`

 `GET`

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cookies">
      <MemberSignature Language="C#" Value="public System.Web.HttpCookieCollection Cookies { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpCookieCollection Cookies" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.Cookies" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Cookies As HttpCookieCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::HttpCookieCollection ^ Cookies { System::Web::HttpCookieCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Cookies : System.Web.HttpCookieCollection" Usage="System.Web.HttpRequest.Cookies" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.HttpCookieCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取客户端发送的 cookie 的集合。</summary>
        <value>表示客户端的 cookie 变量的 <see cref="T:System.Web.HttpCookieCollection" /> 对象。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 ASP.NET 包括两个内部 cookie 集合。 通过的集合访问的集合 <xref:System.Web.HttpRequest.Cookies%2A> <xref:System.Web.HttpRequest> 包含客户端向标头中的服务器传输的 cookie `Cookie` 。 通过的集合访问的集合 <xref:System.Web.HttpResponse.Cookies%2A> <xref:System.Web.HttpResponse> 包含在服务器上创建并在标头中传输到客户端的新 cookie `Set-Cookie` 。

> [!NOTE]
>  使用集合添加 cookie 后 <xref:System.Web.HttpResponse.Cookies%2A?displayProperty=nameWithType> ，cookie 会立即出现在 <xref:System.Web.HttpRequest.Cookies%2A?displayProperty=nameWithType> 集合中，即使尚未将响应发送到客户端也是如此。



## Examples
 下面的代码示例循环遍历客户端发送的所有 cookie，并将每个 cookie 的名称、到期日期、安全参数和值发送到 HTTP 输出中。

 [!code-csharp[Classic HttpRequest.Cookies Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpRequest.Cookies Example/CS/source.cs#1)]
 [!code-vb[Classic HttpRequest.Cookies Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpRequest.Cookies Example/VB/source.vb#1)]

 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.HttpRequest.ValidateInput" />
        <altmember cref="P:System.Web.HttpRequest.Form" />
        <altmember cref="P:System.Web.HttpRequest.QueryString" />
      </Docs>
    </Member>
    <Member MemberName="CurrentExecutionFilePath">
      <MemberSignature Language="C#" Value="public string CurrentExecutionFilePath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string CurrentExecutionFilePath" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.CurrentExecutionFilePath" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CurrentExecutionFilePath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ CurrentExecutionFilePath { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CurrentExecutionFilePath : string" Usage="System.Web.HttpRequest.CurrentExecutionFilePath" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取当前请求的虚拟路径。</summary>
        <value>当前请求的虚拟路径。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.Web.HttpRequest.CurrentExecutionFilePath%2A> 返回当前正在执行的页处理程序的文件路径。 对于使用和方法的重定向方案， <xref:System.Web.HttpServerUtility.Execute%2A> <xref:System.Web.HttpServerUtility.Transfer%2A> 这意味着 <xref:System.Web.HttpRequest.CurrentExecutionFilePath%2A> 属性返回重定向到 (子页) 的页的路径。 但是，当客户端重定向到另一页时， <xref:System.Web.HttpRequest.FilePath%2A> 属性将返回原始页的路径。



## Examples
 下面的代码示例使用 <xref:System.Web.HttpUtility.HtmlEncode%2A> 方法对属性的值进行 HTML 编码 <xref:System.Web.HttpRequest.CurrentExecutionFilePath%2A> ，并使用 <xref:System.IO.TextWriter.WriteLine%2A> 方法将编码的值写入文件。 此代码示例是为类提供的更大示例的一部分 <xref:System.Web.HttpRequest> 。

 [!code-csharp[System.Web.HttpRequest_Sample1#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/CS/requestdetailscs.aspx#2)]
 [!code-vb[System.Web.HttpRequest_Sample1#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/VB/requestdetailsvb.aspx#2)]

 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.HttpRequest.FilePath" />
        <altmember cref="P:System.Web.HttpRequest.Path" />
        <altmember cref="P:System.Web.HttpRequest.PathInfo" />
        <altmember cref="M:System.Web.HttpServerUtility.Execute(System.String)" />
        <altmember cref="M:System.Web.HttpServerUtility.Transfer(System.String,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="CurrentExecutionFilePathExtension">
      <MemberSignature Language="C#" Value="public string CurrentExecutionFilePathExtension { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string CurrentExecutionFilePathExtension" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.CurrentExecutionFilePathExtension" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CurrentExecutionFilePathExtension As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ CurrentExecutionFilePathExtension { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CurrentExecutionFilePathExtension : string" Usage="System.Web.HttpRequest.CurrentExecutionFilePathExtension" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取 <see cref="P:System.Web.HttpRequest.CurrentExecutionFilePath" /> 属性中指定的文件名的扩展名。</summary>
        <value><see cref="P:System.Web.HttpRequest.CurrentExecutionFilePath" /> 属性中指定的文件名的扩展名。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FilePath">
      <MemberSignature Language="C#" Value="public string FilePath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string FilePath" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.FilePath" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property FilePath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ FilePath { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.FilePath : string" Usage="System.Web.HttpRequest.FilePath" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取当前请求的虚拟路径。</summary>
        <value>当前请求的虚拟路径。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.Web.HttpRequest.FilePath%2A>属性不包括 <xref:System.Web.HttpRequest.PathInfo%2A> 尾部。 例如，对于 URL `http://www.contoso.com/virdir/page.html/tail` ， <xref:System.Web.HttpRequest.FilePath%2A> 值为/virdir/page.html。



## Examples
 下面的代码示例使用 <xref:System.Web.HttpUtility.HtmlEncode%2A> 方法对属性的值进行 HTML 编码 <xref:System.Web.HttpRequest.FilePath%2A> ，并使用 <xref:System.IO.TextWriter.WriteLine%2A> 方法将编码的值写入文件。 此代码示例是为类提供的更大示例的一部分 <xref:System.Web.HttpRequest> 。

 [!code-csharp[System.Web.HttpRequest_Sample1#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/CS/requestdetailscs.aspx#2)]
 [!code-vb[System.Web.HttpRequest_Sample1#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/VB/requestdetailsvb.aspx#2)]

 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.HttpRequest.PathInfo" />
        <altmember cref="P:System.Web.HttpRequest.Path" />
      </Docs>
    </Member>
    <Member MemberName="Files">
      <MemberSignature Language="C#" Value="public System.Web.HttpFileCollection Files { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpFileCollection Files" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.Files" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Files As HttpFileCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::HttpFileCollection ^ Files { System::Web::HttpFileCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Files : System.Web.HttpFileCollection" Usage="System.Web.HttpRequest.Files" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.HttpFileCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取采用多部分 MIME 格式的由客户端上载的文件的集合。</summary>
        <value>表示客户端上载的文件集合的 <see cref="T:System.Web.HttpFileCollection" /> 对象。 <see cref="T:System.Web.HttpFileCollection" /> 对象的项属于 <see cref="T:System.Web.HttpPostedFile" /> 类型。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 仅当 HTTP 请求 `Content-Type` 值为 "多部分/窗体数据" 时，才填充文件集合。



## Examples
 下面的代码示例显示集合中所有文件的名称 <xref:System.Web.HttpRequest.Files%2A> 。

 [!code-csharp[Classic HttpRequest.Files Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpRequest.Files Example/CS/source.cs#1)]
 [!code-vb[Classic HttpRequest.Files Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpRequest.Files Example/VB/source.vb#1)]

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Filter">
      <MemberSignature Language="C#" Value="public System.IO.Stream Filter { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.Stream Filter" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.Filter" />
      <MemberSignature Language="VB.NET" Value="Public Property Filter As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Stream ^ Filter { System::IO::Stream ^ get(); void set(System::IO::Stream ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Filter : System.IO.Stream with get, set" Usage="System.Web.HttpRequest.Filter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置在读取当前输入流时要使用的筛选器。</summary>
        <value>要用作筛选器的 <see cref="T:System.IO.Stream" /> 对象。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Examples
 下面的代码示例创建两个新类， `QQQ1` 并 `QQQ2` 筛选 <xref:System.Web.HttpRequest.InputStream%2A> 。 将类放入 ASP.NET 应用程序的目录中的 Global.asa 文件，以便筛选应用程序中所有 ASP.NET 网页的所有输入。

 [!code-aspx-csharp[System.Web.HttpRequest.Filter#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest.Filter/CS/systemwebhttprequestfilter.cs.aspx#1)]
 [!code-aspx-vb[System.Web.HttpRequest.Filter#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest.Filter/VB/systemwebhttprequestfilter.vb.aspx#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">指定的 <see cref="T:System.IO.Stream" /> 无效。</exception>
      </Docs>
    </Member>
    <Member MemberName="Form">
      <MemberSignature Language="C#" Value="public System.Collections.Specialized.NameValueCollection Form { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Specialized.NameValueCollection Form" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.Form" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Form As NameValueCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Specialized::NameValueCollection ^ Form { System::Collections::Specialized::NameValueCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Form : System.Collections.Specialized.NameValueCollection" Usage="System.Web.HttpRequest.Form" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Specialized.NameValueCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取窗体变量集合。</summary>
        <value>表示窗体变量集合的 <see cref="T:System.Collections.Specialized.NameValueCollection" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.Web.HttpRequest.Form%2A>当 HTTP 请求 `Content-Type` 值为 "url 编码" 或 "多部分/窗体数据" 时，将填充该属性。



## Examples
 下面的示例演示如何读取从浏览器发布的窗体集合中的值。 集合中的每个名称/值对都表示一个窗体中的控件及其值。

 [!code-csharp[Classic HttpRequest.Form Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpRequest.Form Example/CS/source.cs#1)]
 [!code-vb[Classic HttpRequest.Form Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpRequest.Form Example/VB/source.vb#1)]

 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.HttpRequest.ValidateInput" />
        <altmember cref="P:System.Web.HttpRequest.Cookies" />
        <altmember cref="P:System.Web.HttpRequest.QueryString" />
      </Docs>
    </Member>
    <Member MemberName="GetBufferedInputStream">
      <MemberSignature Language="C#" Value="public System.IO.Stream GetBufferedInputStream ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Stream GetBufferedInputStream() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpRequest.GetBufferedInputStream" />
      <MemberSignature Language="VB.NET" Value="Public Function GetBufferedInputStream () As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Stream ^ GetBufferedInputStream();" />
      <MemberSignature Language="F#" Value="member this.GetBufferedInputStream : unit -&gt; System.IO.Stream" Usage="httpRequest.GetBufferedInputStream " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>获取一个 <see cref="T:System.IO.Stream" /> 对象，该对象可用于读取传入的 HTTP 实体主体。</summary>
        <returns>可用于读取传入的 HTTP 实体主体的 <see cref="T:System.IO.Stream" /> 对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 此方法与相同， <xref:System.Web.HttpRequest.GetBufferlessInputStream%2A> 只不过它还会复制读取到由 ASP.NET 使用的内部存储的字节，以填充 <xref:System.Web.HttpRequest.Form%2A> 、 <xref:System.Web.HttpRequest.Files%2A> 和 <xref:System.Web.HttpRequest.InputStream%2A> 属性。 由于保留了此信息，如 ASP.NET Web 窗体页面（.aspx 文件）这样的下游代码将成功运行。 这不同于使用 <xref:System.Web.HttpRequest.GetBufferlessInputStream%2A> 方法的情况。

 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">已加载和分析请求的实体主体。 导致加载和分析实体正文的属性的示例包括：

-   <see cref="P:System.Web.HttpRequest.Form" /> 属性。

-   <see cref="P:System.Web.HttpRequest.Files" /> 属性。

-   <see cref="P:System.Web.HttpRequest.InputStream" /> 属性。

-   <see cref="M:System.Web.HttpRequest.GetBufferlessInputStream" /> 方法。

要避免此异常，请首先调用 <see cref="P:System.Web.HttpRequest.ReadEntityBodyMode" /> 方法。 如果客户在实体正文读取时断开连接，则也会引发此异常。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetBufferlessInputStream">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>获取一个 <see cref="T:System.IO.Stream" /> 对象，该对象可用于读取传入的 HTTP 实体主体。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetBufferlessInputStream">
      <MemberSignature Language="C#" Value="public System.IO.Stream GetBufferlessInputStream ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Stream GetBufferlessInputStream() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpRequest.GetBufferlessInputStream" />
      <MemberSignature Language="VB.NET" Value="Public Function GetBufferlessInputStream () As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Stream ^ GetBufferlessInputStream();" />
      <MemberSignature Language="F#" Value="member this.GetBufferlessInputStream : unit -&gt; System.IO.Stream" Usage="httpRequest.GetBufferlessInputStream " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>获取一个 <see cref="T:System.IO.Stream" /> 对象，该对象可用于读取传入的 HTTP 实体主体。</summary>
        <returns>可用于读取传入的 HTTP 实体主体的 <see cref="T:System.IO.Stream" /> 对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 此方法提供使用属性的替代方法 <xref:System.Web.HttpRequest.InputStream%2A> 。 <xref:System.Web.HttpRequest.InputStream%2A>属性将等待，直到收到整个请求后再返回 <xref:System.IO.Stream> 对象。 与此相反， <xref:System.Web.HttpRequest.GetBufferlessInputStream%2A> 方法会 <xref:System.IO.Stream> 立即返回对象。 您可以使用方法来开始处理实体正文，然后再接收正文的完整内容。

 实体主体 (或尽可能多的实体正文，并收到) 仅当你使用此方法返回的对象通过调用方法（如方法）来读取流时返回 <xref:System.IO.Stream.Read%2A> 。 使用方法的参数 <xref:System.IO.Stream.Read%2A> 指定要读取的实体正文的数量。

 <xref:System.IO.Stream>ASP.NET 从此方法返回的对象支持同步和异步读取方法。 <xref:System.IO.Stream>对象同时实现 <xref:System.IO.Stream.BeginRead%2A> 和 <xref:System.IO.Stream.EndRead%2A> 方法。 使用异步方法，你可以在块中异步读取请求实体，而 ASP.NET 将在异步读取循环的每次迭代之间释放当前线程。

 此方法在以下情况下很有用：请求正在上传大型文件，并且想要在上传完成前访问文件内容。 但是，只应将此方法用于需要接管实体正文的所有处理的方案。 这意味着不能从 .aspx 页面使用此方法，因为 .aspx 页面运行时，实体正文已被读取。

 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">已加载和分析请求的实体主体。 导致加载和分析实体正文的属性的示例包括：

-   <see cref="P:System.Web.HttpRequest.Form" />

-   <see cref="P:System.Web.HttpRequest.InputStream" />

-   <see cref="P:System.Web.HttpRequest.Files" />

-   <see cref="M:System.Web.HttpRequest.GetBufferedInputStream" />

要避免此异常，请首先调用 <see cref="P:System.Web.HttpRequest.ReadEntityBodyMode" /> 方法。 如果客户在实体正文读取时断开连接，则也会引发此异常。</exception>
        <altmember cref="M:System.Web.HttpRequest.GetBufferedInputStream" />
      </Docs>
    </Member>
    <Member MemberName="GetBufferlessInputStream">
      <MemberSignature Language="C#" Value="public System.IO.Stream GetBufferlessInputStream (bool disableMaxRequestLength);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Stream GetBufferlessInputStream(bool disableMaxRequestLength) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpRequest.GetBufferlessInputStream(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetBufferlessInputStream (disableMaxRequestLength As Boolean) As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Stream ^ GetBufferlessInputStream(bool disableMaxRequestLength);" />
      <MemberSignature Language="F#" Value="member this.GetBufferlessInputStream : bool -&gt; System.IO.Stream" Usage="httpRequest.GetBufferlessInputStream disableMaxRequestLength" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disableMaxRequestLength" Type="System.Boolean" Index="0" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="disableMaxRequestLength">若要禁用请求长度限制，则为 <see langword="true" />；否则为 <see langword="false" />。</param>
        <summary>获取能被用于读取正在到来的 HTTP 实体主体的 <see cref="T:System.IO.Stream" /> 对象，同时随意地禁止设置在 <see cref="P:System.Web.Configuration.HttpRuntimeSection.MaxRequestLength" /> 属性中的请求长度限制。</summary>
        <returns>可用于读取传入的 HTTP 实体主体的 <see cref="T:System.IO.Stream" /> 对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 有关此方法的详细信息，请参阅 <xref:System.Web.HttpRequest.GetBufferlessInputStream> 重载。

 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">已加载和分析请求的实体主体。 导致加载和分析实体正文的属性的示例包括：

-   <see cref="P:System.Web.HttpRequest.Form" /> 属性。

-   <see cref="P:System.Web.HttpRequest.Files" /> 属性。

-   <see cref="P:System.Web.HttpRequest.InputStream" /> 属性。

-   <see cref="M:System.Web.HttpRequest.GetBufferedInputStream" /> 方法。

要避免此异常，请首先调用 <see cref="P:System.Web.HttpRequest.ReadEntityBodyMode" /> 方法。 如果客户在实体正文读取时断开连接，则也会引发此异常。</exception>
        <altmember cref="M:System.Web.HttpRequest.GetBufferedInputStream" />
      </Docs>
    </Member>
    <Member MemberName="Headers">
      <MemberSignature Language="C#" Value="public System.Collections.Specialized.NameValueCollection Headers { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Specialized.NameValueCollection Headers" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.Headers" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Headers As NameValueCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Specialized::NameValueCollection ^ Headers { System::Collections::Specialized::NameValueCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Headers : System.Collections.Specialized.NameValueCollection" Usage="System.Web.HttpRequest.Headers" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Specialized.NameValueCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取 HTTP 头集合。</summary>
        <value>标头的 <see cref="T:System.Collections.Specialized.NameValueCollection" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 有关所有可能的标头的列表，请参阅 W3C 网站上的 [请求标头字段](https://go.microsoft.com/fwlink/?LinkId=73147) 。



## Examples
 下面的代码示例显示 HTTP 请求中所有标头的名称和值。

 [!code-csharp[Classic HttpRequest.Headers Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpRequest.Headers Example/CS/source.cs#1)]
 [!code-vb[Classic HttpRequest.Headers Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpRequest.Headers Example/VB/source.vb#1)]

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HttpChannelBinding">
      <MemberSignature Language="C#" Value="public System.Security.Authentication.ExtendedProtection.ChannelBinding HttpChannelBinding { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Authentication.ExtendedProtection.ChannelBinding HttpChannelBinding" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.HttpChannelBinding" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HttpChannelBinding As ChannelBinding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Authentication::ExtendedProtection::ChannelBinding ^ HttpChannelBinding { System::Security::Authentication::ExtendedProtection::ChannelBinding ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.HttpChannelBinding : System.Security.Authentication.ExtendedProtection.ChannelBinding" Usage="System.Web.HttpRequest.HttpChannelBinding" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Authentication.ExtendedProtection.ChannelBinding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取当前 <see cref="T:System.Security.Authentication.ExtendedProtection.ChannelBinding" /> 实例的 <see cref="T:System.Web.HttpWorkerRequest" /> 对象。</summary>
        <value>当前 <see cref="T:System.Web.HttpWorkerRequest" /> 实例的 <see cref="T:System.Security.Authentication.ExtendedProtection.ChannelBinding" /> 对象。</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.PlatformNotSupportedException">当前的 <see cref="T:System.Web.HttpWorkerRequest" /> 对象不是 <see langword="System.Web.Hosting.IIS7WorkerRequest" /> 对象或 <see langword="System.Web.Hosting.ISAPIWorkerRequestInProc" /> 对象。</exception>
      </Docs>
    </Member>
    <Member MemberName="HttpMethod">
      <MemberSignature Language="C#" Value="public string HttpMethod { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string HttpMethod" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.HttpMethod" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HttpMethod As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ HttpMethod { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.HttpMethod : string" Usage="System.Web.HttpRequest.HttpMethod" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取客户端使用的 HTTP 数据传输方法(如 <see langword="GET" />、<see langword="POST" /> 或 <see langword="HEAD" />)。</summary>
        <value>客户端所用的 HTTP 数据传输方法。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Examples
 下面的代码示例使用 <xref:System.Web.HttpUtility.HtmlEncode%2A> 方法对属性的值进行 HTML 编码 <xref:System.Web.HttpRequest.HttpMethod%2A> ，并使用 <xref:System.IO.TextWriter.WriteLine%2A> 方法将编码的值写入文件。 此代码示例是为类提供的更大示例的一部分 <xref:System.Web.HttpRequest> 。

 [!code-csharp[System.Web.HttpRequest_Sample1#7](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/CS/requestdetailscs.aspx#7)]
 [!code-vb[System.Web.HttpRequest_Sample1#7](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/VB/requestdetailsvb.aspx#7)]

 下面的示例演示了此代码生成的输出。

 `GET`

 `127.0.0.1`

 `127.0.0.1`

 `GET`

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InputStream">
      <MemberSignature Language="C#" Value="public System.IO.Stream InputStream { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.Stream InputStream" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.InputStream" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property InputStream As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Stream ^ InputStream { System::IO::Stream ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.InputStream : System.IO.Stream" Usage="System.Web.HttpRequest.InputStream" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取传入的 HTTP 实体主体的内容。</summary>
        <value>表示传入 HTTP 内容主体的内容的 <see cref="T:System.IO.Stream" /> 对象。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Examples
 下面的代码示例将的内容复制 <xref:System.Web.HttpRequest.InputStream%2A> 到字符串中。

 [!code-csharp[Classic HttpRequest.InputStream Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpRequest.InputStream Example/cs/source.aspx#1)]
 [!code-vb[Classic HttpRequest.InputStream Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpRequest.InputStream Example/VB/source.vb#1)]

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="InsertEntityBody">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>为用于将 HTTP 请求实体正文插入内存的 IIS 方法提供托管包装。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.Web.HttpRequest.InsertEntityBody%2A>方法重载提供对 IIS 7 方法的托管访问 `IHttpRequest::InsertEntityBody` 。 IIS 方法将 HTTP 请求实体正文插入 (客户端) 发送到内存中的数据。 这很有用，因为 IIS 在读取请求实体后不会保留它的副本。 <xref:System.Web.HttpRequest.InsertEntityBody%2A>方法创建 HTTP 请求实体数据的副本，并将其提供给 IIS 以便进行其他自定义处理。

> [!NOTE]
>  <xref:System.Web.HttpRequest.InsertEntityBody%2A>方法重载仅适用于 iis 7.0 或更高版本，因为该 `IHttpRequest::InsertEntityBody` 方法是在 iis 7.0 中添加的。

 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="InsertEntityBody">
      <MemberSignature Language="C#" Value="public void InsertEntityBody ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void InsertEntityBody() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpRequest.InsertEntityBody" />
      <MemberSignature Language="VB.NET" Value="Public Sub InsertEntityBody ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void InsertEntityBody();" />
      <MemberSignature Language="F#" Value="member this.InsertEntityBody : unit -&gt; unit" Usage="httpRequest.InsertEntityBody " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>向 IIS 提供 HTTP 请求实体正文的副本。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 IIS 在读取请求后不会保留该请求的副本。 因此，建议只对 HTTP 请求的处理程序读取请求实体。

 <xref:System.Web.HttpRequest.InsertEntityBody%2A?displayProperty=nameWithType>如果先前已由 ASP.NET 读取，则方法重载将向 IIS 提供请求实体的副本。 此方法重载适用于 ASP.NET 已读取实体请求并想要重用现有请求数据的情况。

 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">在 IIS 7.0 以前的 IIS 版本上调用该方法。</exception>
      </Docs>
    </Member>
    <Member MemberName="InsertEntityBody">
      <MemberSignature Language="C#" Value="public void InsertEntityBody (byte[] buffer, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void InsertEntityBody(unsigned int8[] buffer, int32 offset, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpRequest.InsertEntityBody(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub InsertEntityBody (buffer As Byte(), offset As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void InsertEntityBody(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count);" />
      <MemberSignature Language="F#" Value="member this.InsertEntityBody : byte[] * int * int -&gt; unit" Usage="httpRequest.InsertEntityBody (buffer, offset, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="buffer">一个包含请求实体数据的数组。</param>
        <param name="offset"><paramref name="buffer" /> 中开始存储请求实体数据的位置，该位置从零开始计数。</param>
        <param name="count">要读取到 <paramref name="buffer" /> 数组中的字节数。</param>
        <summary>向 IIS 提供 HTTP 请求实体正文的副本以及有关请求实体对象的信息。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 IIS 在读取请求后不会保留该请求的副本。 因此，建议只对 HTTP 请求的处理程序读取请求实体。

 <xref:System.Web.HttpRequest.InsertEntityBody%2A?displayProperty=nameWithType>如果要执行自定义处理（如将不同的实体正文插入内存），方法重载会很有用。

 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">在 IIS 7.0 以前的 IIS 版本上调用该方法。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" /> 或 <paramref name="count" /> 是负值。</exception>
        <exception cref="T:System.ArgumentException">如果给定 <paramref name="offset" /> 值，则 <paramref name="count" /> 中的项目数大于 <paramref name="buffer" /> 中的可用空间。</exception>
      </Docs>
    </Member>
    <Member MemberName="IsAuthenticated">
      <MemberSignature Language="C#" Value="public bool IsAuthenticated { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAuthenticated" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.IsAuthenticated" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAuthenticated As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAuthenticated { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAuthenticated : bool" Usage="System.Web.HttpRequest.IsAuthenticated" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示是否验证了请求。</summary>
        <value>如果请求已经过身份验证，则为 <see langword="true" />；否则，为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Examples
 下面的代码示例使用 <xref:System.Web.HttpRequest.IsAuthenticated%2A> 属性来确定当前请求是否已经过身份验证。 如果尚未对其进行身份验证，则会将请求重定向到另一个页面，用户可在其中向 Web 应用程序输入其凭据。 这是在应用程序的默认页中使用的常用技术。

 [!code-csharp[System.Web.HttpRequest_Sample3#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest_Sample3/CS/isauthenticatedcs.aspx#1)]
 [!code-vb[System.Web.HttpRequest_Sample3#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest_Sample3/VB/isauthenticatedvb.aspx#1)]

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsLocal">
      <MemberSignature Language="C#" Value="public bool IsLocal { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsLocal" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.IsLocal" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsLocal As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsLocal { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsLocal : bool" Usage="System.Web.HttpRequest.IsLocal" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取指示请求是否来自本地计算机的值。</summary>
        <value>如果请求来自本地计算机，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.Web.HttpRequest.IsLocal%2A> `true` 如果请求发起方的 ip 地址为127.0.0.1 或请求的 ip 地址与服务器的 ip 地址相同，则属性将返回。

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSecureConnection">
      <MemberSignature Language="C#" Value="public bool IsSecureConnection { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecureConnection" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.IsSecureConnection" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsSecureConnection As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsSecureConnection { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSecureConnection : bool" Usage="System.Web.HttpRequest.IsSecureConnection" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，指示 HTTP 连接是否使用安全套接字（即 HTTPS）。</summary>
        <value>如果连接为 SSL 连接，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Examples
 下面的代码示例确定属性是否 <xref:System.Web.HttpRequest.IsSecureConnection%2A> 设置为 false。 如果是，则将 <xref:System.Web.HttpResponse.SuppressContent%2A> 属性设置为 true 以停止发送响应。

 [!code-csharp[System.Web.HttpResponse_Sample5#3](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Sample5/CS/httpresponsesuppresscontentcs.aspx#3)]
 [!code-vb[System.Web.HttpResponse_Sample5#3](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Sample5/VB/httpresponsesuppresscontentvb.aspx#3)]

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public string this[string key] { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Item(string)" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.Item(System.String)" />
      <MemberSignature Language="VB.NET" Value="Default Public ReadOnly Property Item(key As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ default[System::String ^] { System::String ^ get(System::String ^ key); };" />
      <MemberSignature Language="F#" Value="member this.Item(string) : string" Usage="System.Web.HttpRequest.Item" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">要获取的集合成员的名称。</param>
        <summary>从 <see cref="P:System.Web.HttpRequest.QueryString" />、<see cref="P:System.Web.HttpRequest.Form" />、<see cref="P:System.Web.HttpRequest.Cookies" /> 或 <see cref="P:System.Web.HttpRequest.ServerVariables" /> 集合获取指定的对象。</summary>
        <value><see cref="P:System.Web.HttpRequest.QueryString" /> 参数中指定的 <see cref="P:System.Web.HttpRequest.Form" />、<see cref="P:System.Web.HttpRequest.Cookies" />、<see cref="P:System.Web.HttpRequest.ServerVariables" /> 或 <paramref name="key" /> 集合成员。 如果未找到指定的 <paramref name="key" />，则返回 <see langword="null" />。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LogonUserIdentity">
      <MemberSignature Language="C#" Value="public System.Security.Principal.WindowsIdentity LogonUserIdentity { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Principal.WindowsIdentity LogonUserIdentity" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.LogonUserIdentity" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LogonUserIdentity As WindowsIdentity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Principal::WindowsIdentity ^ LogonUserIdentity { System::Security::Principal::WindowsIdentity ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.LogonUserIdentity : System.Security.Principal.WindowsIdentity" Usage="System.Web.HttpRequest.LogonUserIdentity" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Principal.WindowsIdentity</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取当前用户的 <see cref="T:System.Security.Principal.WindowsIdentity" /> 类型。</summary>
        <value>当前 Microsoft Internet Information Services (IIS)身份验证设置的 <see cref="T:System.Security.Principal.WindowsIdentity" /> 对象。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.Web.HttpRequest.LogonUserIdentity%2A>属性将当前连接的用户的对象的属性和方法公开 <xref:System.Security.Principal.WindowsIdentity> 给 Microsoft INTERNET INFORMATION SERVICES (IIS) 。 <xref:System.Security.Principal.WindowsIdentity>通过跟踪 IIS 请求标记公开的类的实例 <xref:System.Web.HttpRequest.LogonUserIdentity%2A> ，并为当前在 ASP.NET 中处理的当前 HTTP 请求提供轻松访问此标记的权限。 <xref:System.Security.Principal.WindowsIdentity>自动创建类的一个实例，因此无需对其进行构造以获取对其方法和属性的访问权限。



## Examples
 下面的代码示例演示如何检索 <xref:System.Web.HttpRequest.LogonUserIdentity%2A> 当前用户的属性并写出文本文件中每一项的值。 将此代码放在窗体的属性所引用的 ASP.NET 页上 `ACTION` 。

 [!code-aspx-csharp[System.Web.HttpRequest_LogonUserIdentity#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest_LogonUserIdentity/CS/logonuseridentity_cs.aspx#1)]
 [!code-aspx-vb[System.Web.HttpRequest_LogonUserIdentity#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest_LogonUserIdentity/VB/logonuseridentity_vb.aspx#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Web 应用程序正在 IIS 7 集成模式下运行，尚未引发 <see cref="E:System.Web.HttpApplication.PostAuthenticateRequest" /> 事件。</exception>
      </Docs>
    </Member>
    <Member MemberName="MapImageCoordinates">
      <MemberSignature Language="C#" Value="public int[] MapImageCoordinates (string imageFieldName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32[] MapImageCoordinates(string imageFieldName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpRequest.MapImageCoordinates(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function MapImageCoordinates (imageFieldName As String) As Integer()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;int&gt; ^ MapImageCoordinates(System::String ^ imageFieldName);" />
      <MemberSignature Language="F#" Value="member this.MapImageCoordinates : string -&gt; int[]" Usage="httpRequest.MapImageCoordinates imageFieldName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="imageFieldName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="imageFieldName">窗体图像映射的名称。</param>
        <summary>将传入图像字段窗体参数映射为适当的 x 坐标值和 y 坐标值。</summary>
        <returns>二维整数数组。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="MapPath">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>为当前请求将请求的 URL 中的虚拟路径映射到服务器上的物理路径。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MapPath">
      <MemberSignature Language="C#" Value="public string MapPath (string virtualPath);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string MapPath(string virtualPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpRequest.MapPath(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function MapPath (virtualPath As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ MapPath(System::String ^ virtualPath);" />
      <MemberSignature Language="F#" Value="member this.MapPath : string -&gt; string" Usage="httpRequest.MapPath virtualPath" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="virtualPath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="virtualPath">当前请求的虚拟路径（绝对路径或相对路径）。</param>
        <summary>将指定的虚拟路径映射到物理路径。</summary>
        <returns>由 <paramref name="virtualPath" /> 指定的服务器物理路径。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

> [!CAUTION]
>  <xref:System.Web.HttpRequest.MapPath%2A>属性可能包含有关宿主环境的敏感信息。 不应向用户显示返回值。



## Examples
 下面的代码示例使用 <xref:System.Web.HttpRequest.MapPath%2A> 方法将虚拟路径转换为服务器上的完全限定的物理路径。 此示例包含两个部分：

-   .Aspx 页映射路径，读取文件，并显示读取操作的结果。

-   一个类， `UpperCaseFilterStream` 它将通过其传递的所有字符更改为大写。

 该示例的第一部分演示如何使用方法将虚拟路径转换为完全限定的物理路径 <xref:System.Web.HttpRequest.MapPath%2A> 。 然后，将此物理路径传递给一个 <xref:System.IO.StreamReader> 对象，该对象获取文件的内容。 <xref:System.Web.HttpResponse.Write%2A>然后调用方法以在页面上显示该文件的内容。 <xref:System.Web.HttpResponse.Filter%2A>属性用于将筛选器附加到响应流，使文本显示为大写页面。

 [!code-aspx-csharp[System.Web.HttpRequest_Samples2#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest_Samples2/CS/requestsamples2cs.aspx#1)]
 [!code-aspx-vb[System.Web.HttpRequest_Samples2#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest_Samples2/VB/requestsamples2vb.aspx#1)]

 该示例的第二部分演示从继承的类 <xref:System.IO.Stream> ，并将流中的所有字符转换为大写。 将此代码放在 `App_Code` 应用程序的文件夹中。

 [!code-csharp[System.Web.HttpRequest_Samples2#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest_Samples2/CS/responsefilter.cs#2)]
 [!code-vb[System.Web.HttpRequest_Samples2#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest_Samples2/VB/responsefilter.vb#2)]

 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">没有为请求定义 <see cref="T:System.Web.HttpContext" /> 对象。</exception>
      </Docs>
    </Member>
    <Member MemberName="MapPath">
      <MemberSignature Language="C#" Value="public string MapPath (string virtualPath, string baseVirtualDir, bool allowCrossAppMapping);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string MapPath(string virtualPath, string baseVirtualDir, bool allowCrossAppMapping) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpRequest.MapPath(System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function MapPath (virtualPath As String, baseVirtualDir As String, allowCrossAppMapping As Boolean) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ MapPath(System::String ^ virtualPath, System::String ^ baseVirtualDir, bool allowCrossAppMapping);" />
      <MemberSignature Language="F#" Value="member this.MapPath : string * string * bool -&gt; string" Usage="httpRequest.MapPath (virtualPath, baseVirtualDir, allowCrossAppMapping)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="virtualPath" Type="System.String" />
        <Parameter Name="baseVirtualDir" Type="System.String" />
        <Parameter Name="allowCrossAppMapping" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="virtualPath">当前请求的虚拟路径（绝对路径或相对路径）。</param>
        <param name="baseVirtualDir">用于相对解析的虚拟基目录路径。</param>
        <param name="allowCrossAppMapping">如果为 <see langword="true" />，则指示 <paramref name="virtualPath" /> 可能属于另一个应用程序；否则为 <see langword="false" />。</param>
        <summary>将指定的虚拟路径映射到物理路径。</summary>
        <returns>服务器上的物理路径。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

> [!CAUTION]
>  <xref:System.Web.HttpRequest.MapPath%2A>属性可能包含有关宿主环境的敏感信息。 不应向用户显示返回值。

 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException"><paramref name="allowCrossMapping" /> 为 <see langword="false" /> 且 <paramref name="virtualPath" /> 属于另一个应用程序。

- 或 -

没有为请求定义 <see cref="T:System.Web.HttpContext" /> 对象。</exception>
      </Docs>
    </Member>
    <Member MemberName="MapRawImageCoordinates">
      <MemberSignature Language="C#" Value="public double[] MapRawImageCoordinates (string imageFieldName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance float64[] MapRawImageCoordinates(string imageFieldName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpRequest.MapRawImageCoordinates(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function MapRawImageCoordinates (imageFieldName As String) As Double()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;double&gt; ^ MapRawImageCoordinates(System::String ^ imageFieldName);" />
      <MemberSignature Language="F#" Value="member this.MapRawImageCoordinates : string -&gt; double[]" Usage="httpRequest.MapRawImageCoordinates imageFieldName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="imageFieldName" Type="System.String" Index="0" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="imageFieldName">图像字段的名称。</param>
        <summary>将传入图像字段窗体参数映射为适当的 x 和 y 坐标值。</summary>
        <returns>x 和 y 坐标值。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Params">
      <MemberSignature Language="C#" Value="public System.Collections.Specialized.NameValueCollection Params { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Specialized.NameValueCollection Params" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.Params" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Params As NameValueCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Specialized::NameValueCollection ^ Params { System::Collections::Specialized::NameValueCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Params : System.Collections.Specialized.NameValueCollection" Usage="System.Web.HttpRequest.Params" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Specialized.NameValueCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取 <see cref="P:System.Web.HttpRequest.QueryString" />、<see cref="P:System.Web.HttpRequest.Form" />、<see cref="P:System.Web.HttpRequest.Cookies" /> 和 <see cref="P:System.Web.HttpRequest.ServerVariables" /> 项的组合集合。</summary>
        <value><see cref="T:System.Collections.Specialized.NameValueCollection" /> 对象。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 名称-值对按照以下顺序添加到集合中：

1.  查询字符串参数。

2.  窗体字段。

3.  Cookie。

4.  服务器变量。



## Examples
 下面的代码示例演示如何遍历 <xref:System.Web.HttpRequest.Params%2A> 页的属性，以及如何显示每个键/值对。

 [!code-aspx-csharp[System.Web.HttpRequest.Params#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest.Params/CS/requestparamscs.aspx#1)]
 [!code-aspx-vb[System.Web.HttpRequest.Params#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest.Params/VB/requestparamsvb.aspx#1)]

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Path">
      <MemberSignature Language="C#" Value="public string Path { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Path" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.Path" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Path As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Path { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Path : string" Usage="System.Web.HttpRequest.Path" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取当前请求的虚拟路径。</summary>
        <value>当前请求的虚拟路径。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.Web.HttpRequest.Path%2A>是 <xref:System.Web.HttpRequest.FilePath%2A> 与尾部的连接 <xref:System.Web.HttpRequest.PathInfo%2A> 。 例如，对于 URL `http://www.contoso.com/virdir/page.html/tail` ， <xref:System.Web.HttpRequest.Path%2A> 为/virdir/page.html/tail。



## Examples
 下面的代码示例使用 <xref:System.Web.HttpUtility.HtmlEncode%2A> 方法对属性的值进行 HTML 编码 <xref:System.Web.HttpRequest.Path%2A> ，并使用 <xref:System.IO.TextWriter.WriteLine%2A> 方法将编码的值写入文件。 此代码示例是为类提供的更大示例的一部分 <xref:System.Web.HttpRequest> 。

 [!code-csharp[System.Web.HttpRequest_Sample1#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/CS/requestdetailscs.aspx#2)]
 [!code-vb[System.Web.HttpRequest_Sample1#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/VB/requestdetailsvb.aspx#2)]

 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.HttpRequest.FilePath" />
        <altmember cref="P:System.Web.HttpRequest.PathInfo" />
      </Docs>
    </Member>
    <Member MemberName="PathInfo">
      <MemberSignature Language="C#" Value="public string PathInfo { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string PathInfo" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.PathInfo" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PathInfo As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ PathInfo { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.PathInfo : string" Usage="System.Web.HttpRequest.PathInfo" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取具有 URL 扩展名的资源的附加路径信息。</summary>
        <value>资源的附加路径信息。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 对于 URL `http://www.contoso.com/virdir/page.html/tail` ， <xref:System.Web.HttpRequest.PathInfo%2A> 值为/tail。



## Examples
 下面的代码示例确定属性是否 <xref:System.Web.HttpRequest.PathInfo%2A> 包含空字符串。 如果是这样，该 <xref:System.IO.StreamWriter.Write%2A> 方法会将指示这一点的字符串写入文件。 如果不是，则 <xref:System.Web.HttpUtility.HtmlEncode%2A> 方法对属性的值进行 HTML 编码， <xref:System.Web.HttpRequest.PathInfo%2A> 并且方法会将 <xref:System.IO.TextWriter.WriteLine%2A> 编码的值写入文件。 此代码示例是为类提供的更大示例的一部分 <xref:System.Web.HttpRequest> 。

 [!code-csharp[System.Web.HttpRequest_Sample1#4](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/CS/requestdetailscs.aspx#4)]
 [!code-vb[System.Web.HttpRequest_Sample1#4](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/VB/requestdetailsvb.aspx#4)]

 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.HttpRequest.Path" />
        <altmember cref="P:System.Web.HttpRequest.FilePath" />
      </Docs>
    </Member>
    <Member MemberName="PhysicalApplicationPath">
      <MemberSignature Language="C#" Value="public string PhysicalApplicationPath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string PhysicalApplicationPath" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.PhysicalApplicationPath" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PhysicalApplicationPath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ PhysicalApplicationPath { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.PhysicalApplicationPath : string" Usage="System.Web.HttpRequest.PhysicalApplicationPath" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取当前正在执行的服务器应用程序的根目录的物理文件系统路径。</summary>
        <value>当前应用程序的根目录的文件系统路径。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Examples
 下面的代码示例使用 <xref:System.Web.HttpUtility.HtmlEncode%2A> 方法对属性的值进行 HTML 编码 <xref:System.Web.HttpRequest.PhysicalApplicationPath%2A> ，并使用 <xref:System.IO.TextWriter.WriteLine%2A> 方法将编码的值写入文件。 此代码示例是为类提供的更大示例的一部分 <xref:System.Web.HttpRequest> 。

 [!code-csharp[System.Web.HttpRequest_Sample1#5](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/CS/requestdetailscs.aspx#5)]
 [!code-vb[System.Web.HttpRequest_Sample1#5](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/VB/requestdetailsvb.aspx#5)]

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PhysicalPath">
      <MemberSignature Language="C#" Value="public string PhysicalPath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string PhysicalPath" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.PhysicalPath" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PhysicalPath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ PhysicalPath { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.PhysicalPath : string" Usage="System.Web.HttpRequest.PhysicalPath" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取与请求的 URL 相对应的物理文件系统路径。</summary>
        <value>当前请求的文件系统路径。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 在使用和的重定向方案中 <xref:System.Web.HttpServerUtility.Execute%2A> <xref:System.Web.HttpServerUtility.Transfer%2A> ， <xref:System.Web.HttpRequest.PhysicalPath%2A> 属性将返回原始页面的路径。 若要查找当前正在执行的页的物理路径，请使用 <xref:System.Web.HttpRequest.MapPath%2A> 方法，并将输入参数设置为 <xref:System.Web.HttpRequest.CurrentExecutionFilePath%2A> 属性。



## Examples
 下面的代码示例使用 <xref:System.Web.HttpUtility.HtmlEncode%2A> 方法对属性的值进行 HTML 编码 <xref:System.Web.HttpRequest.PhysicalPath%2A> ，并使用 <xref:System.IO.TextWriter.WriteLine%2A> 方法将编码的值写入文件。 此代码示例是为类提供的更大示例的一部分 <xref:System.Web.HttpRequest> 。

 [!code-csharp[System.Web.HttpRequest_Sample1#5](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/CS/requestdetailscs.aspx#5)]
 [!code-vb[System.Web.HttpRequest_Sample1#5](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/VB/requestdetailsvb.aspx#5)]

 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.HttpRequest.MapPath(System.String)" />
        <altmember cref="P:System.Web.HttpRequest.CurrentExecutionFilePath" />
      </Docs>
    </Member>
    <Member MemberName="QueryString">
      <MemberSignature Language="C#" Value="public System.Collections.Specialized.NameValueCollection QueryString { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Specialized.NameValueCollection QueryString" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.QueryString" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property QueryString As NameValueCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Specialized::NameValueCollection ^ QueryString { System::Collections::Specialized::NameValueCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.QueryString : System.Collections.Specialized.NameValueCollection" Usage="System.Web.HttpRequest.QueryString" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Specialized.NameValueCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取 HTTP 查询字符串变量集合。</summary>
        <value>客户端发送的查询字符串变量。 键和值是 URL 解码。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Examples
 下面的代码示例演示了两种方法来获取名为 "fullname" 的查询字符串变量的值。 在每种情况下，如果 URL 为 `http://www.contoso.com/default.aspx?fullname=Fadi%20Fakhouri` ，则返回的值为 "Fadi Fakhouri"，因为将 `%20` URL 解码为空格字符。 如果 URL 不具有 `fullname` 查询字符串 ID，则返回的值为 `null` 。

 第一行代码仅在查询字符串中查找键 "fullname";第二行在所有 HTTP 请求集合中查找密钥 "fullname"。 有关第二行的详细信息，请参阅 <xref:System.Web.HttpRequest.Item%2A> 。

```csharp
string fullname1 = Request.QueryString["fullname"];
string fullname2 = Request["fullname"];

```

```vb
Dim fullname1 As String = Request.QueryString("fullname")
Dim fullname2 As String = Request("fullname")
```

 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.HttpRequest.ValidateInput" />
        <altmember cref="P:System.Web.HttpRequest.Form" />
        <altmember cref="P:System.Web.HttpRequest.Cookies" />
      </Docs>
    </Member>
    <Member MemberName="RawUrl">
      <MemberSignature Language="C#" Value="public string RawUrl { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string RawUrl" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.RawUrl" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RawUrl As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ RawUrl { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.RawUrl : string" Usage="System.Web.HttpRequest.RawUrl" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取当前请求的原始 URL。</summary>
        <value>当前请求的原始 URL。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 原始 URL 定义为后面包含域信息的 URL 部分。 在 URL 字符串中 `http://www.contoso.com/articles/recent.aspx` ，原始 URL 为/articles/recent.aspx。 原始 URL 包括查询字符串（如果存在）。



## Examples
 下面的代码示例使用 <xref:System.Web.HttpUtility.HtmlEncode%2A> 方法对属性的值进行 HTML 编码 <xref:System.Web.HttpRequest.RawUrl%2A> ，并使用 <xref:System.IO.TextWriter.WriteLine%2A> 方法将编码的值写入文件。 此代码示例是为类提供的更大示例的一部分 <xref:System.Web.HttpRequest> 。

 [!code-csharp[System.Web.HttpRequest_Sample1#5](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/CS/requestdetailscs.aspx#5)]
 [!code-vb[System.Web.HttpRequest_Sample1#5](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/VB/requestdetailsvb.aspx#5)]

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadEntityBodyMode">
      <MemberSignature Language="C#" Value="public System.Web.ReadEntityBodyMode ReadEntityBodyMode { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Web.ReadEntityBodyMode ReadEntityBodyMode" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.ReadEntityBodyMode" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ReadEntityBodyMode As ReadEntityBodyMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::ReadEntityBodyMode ReadEntityBodyMode { System::Web::ReadEntityBodyMode get(); };" />
      <MemberSignature Language="F#" Value="member this.ReadEntityBodyMode : System.Web.ReadEntityBodyMode" Usage="System.Web.HttpRequest.ReadEntityBodyMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.ReadEntityBodyMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取指示请求实体是否被读以及如何被读的值。</summary>
        <value>指示的值请求实体怎么读取，或者未读取。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 如果已读取实体正文，但尝试使用不兼容的方法对其进行读取，则使用此方法可避免引发异常。 读取实体主体的方法和属性包括：

-   <xref:System.Web.HttpRequest.Form%2A> 属性。

-   <xref:System.Web.HttpRequest.Files%2A> 属性。

-   <xref:System.Web.HttpRequest.InputStream%2A> 属性。

-   <xref:System.Web.HttpRequest.GetBufferedInputStream%2A> 方法。

-   <xref:System.Web.HttpRequest.GetBufferlessInputStream%2A> 方法。

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RequestContext">
      <MemberSignature Language="C#" Value="public System.Web.Routing.RequestContext RequestContext { get; }" FrameworkAlternate="netframework-4.0" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.Routing.RequestContext RequestContext" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.RequestContext" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RequestContext As RequestContext" FrameworkAlternate="netframework-4.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::Routing::RequestContext ^ RequestContext { System::Web::Routing::RequestContext ^ get(); };" FrameworkAlternate="netframework-4.0" />
      <MemberSignature Language="F#" Value="member this.RequestContext : System.Web.Routing.RequestContext" Usage="System.Web.HttpRequest.RequestContext" FrameworkAlternate="netframework-4.0" />
      <MemberSignature Language="C#" Value="public System.Web.Routing.RequestContext RequestContext { get; set; }" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="VB.NET" Value="Public Property RequestContext As RequestContext" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::Routing::RequestContext ^ RequestContext { System::Web::Routing::RequestContext ^ get(); void set(System::Web::Routing::RequestContext ^ value); };" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="F#" Value="member this.RequestContext : System.Web.Routing.RequestContext with get, set" Usage="System.Web.HttpRequest.RequestContext" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.Routing.RequestContext</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取当前请求的 <see cref="T:System.Web.Routing.RequestContext" /> 实例。</summary>
        <value>当前请求的 <see cref="T:System.Web.Routing.RequestContext" /> 实例。 对于非路由请求，返回的 <see cref="T:System.Web.Routing.RequestContext" /> 对象为空。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 此属性为当前请求提供对对象的访问 <xref:System.Web.Routing.RouteData> 。 有关 ASP.NET 路由的详细信息，请参阅。[ASP.NET 路由](https://docs.microsoft.com/previous-versions/aspnet/cc668201(v=vs.100))。

 ]]></format>
        </remarks>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/dd329551(v=vs.140)">演练：在 Web 窗体应用程序中使用 ASP.NET 路由</related>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/dd535620(v=vs.140)">如何：访问路由页中的 URL 参数</related>
      </Docs>
    </Member>
    <Member MemberName="RequestType">
      <MemberSignature Language="C#" Value="public string RequestType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string RequestType" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.RequestType" />
      <MemberSignature Language="VB.NET" Value="Public Property RequestType As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ RequestType { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.RequestType : string with get, set" Usage="System.Web.HttpRequest.RequestType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置客户端使用的 HTTP 数据传输方法(<see langword="GET" /> 或 <see langword="POST" />)。</summary>
        <value>表示客户端发送的 HTTP 调用类型的字符串。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Examples
 下面的代码示例使用 <xref:System.Web.HttpUtility.HtmlEncode%2A> 方法对属性的值进行 HTML 编码 <xref:System.Web.HttpRequest.RequestType%2A> ，并使用 <xref:System.IO.TextWriter.WriteLine%2A> 方法将编码的值写入文件。 此代码示例是为类提供的更大示例的一部分 <xref:System.Web.HttpRequest> 。

 [!code-csharp[System.Web.HttpRequest_Sample1#7](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/CS/requestdetailscs.aspx#7)]
 [!code-vb[System.Web.HttpRequest_Sample1#7](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/VB/requestdetailsvb.aspx#7)]

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SaveAs">
      <MemberSignature Language="C#" Value="public void SaveAs (string filename, bool includeHeaders);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SaveAs(string filename, bool includeHeaders) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpRequest.SaveAs(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SaveAs (filename As String, includeHeaders As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SaveAs(System::String ^ filename, bool includeHeaders);" />
      <MemberSignature Language="F#" Value="member this.SaveAs : string * bool -&gt; unit" Usage="httpRequest.SaveAs (filename, includeHeaders)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filename" Type="System.String" />
        <Parameter Name="includeHeaders" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="filename">物理驱动器路径。</param>
        <param name="includeHeaders">一个布尔值，该值指定是否应将 HTTP 头保存到磁盘。</param>
        <summary>将 HTTP 请求保存到磁盘。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 将请求上下文保存到磁盘对于调试很有用。



## Examples
 下面的代码示例 <xref:System.Web.HttpRequest.SaveAs%2A> 在加载页面时调用方法。 此调用指定该请求将作为文本文件保存在 ASP.NET 进程标识已被授予写入权限的目录中，并且该请求中包含的任何标头信息都包含在该文件中。

 [!code-csharp[System.Web.HttpRequest_Sample6#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest_Sample6/cs/requestsample6cs.aspx#1)]
 [!code-vb[System.Web.HttpRequest_Sample6#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest_Sample6/vb/requestsample6vb.aspx#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException"><see cref="T:System.Web.Configuration.HttpRuntimeSection" /> 的 <see cref="P:System.Web.Configuration.HttpRuntimeSection.RequireRootedSaveAsPath" /> 属性设置为 <see langword="true" />，但 <paramref name="filename" /> 不是绝对路径。</exception>
      </Docs>
    </Member>
    <Member MemberName="ServerVariables">
      <MemberSignature Language="C#" Value="public System.Collections.Specialized.NameValueCollection ServerVariables { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Specialized.NameValueCollection ServerVariables" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.ServerVariables" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ServerVariables As NameValueCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Specialized::NameValueCollection ^ ServerVariables { System::Collections::Specialized::NameValueCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ServerVariables : System.Collections.Specialized.NameValueCollection" Usage="System.Web.HttpRequest.ServerVariables" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Specialized.NameValueCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取 Web 服务器变量的集合。</summary>
        <value>服务器变量的 <see cref="T:System.Collections.Specialized.NameValueCollection" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 有关 IIS 支持的服务器变量的列表，请参阅 [Iis 服务器变量](https://go.microsoft.com/fwlink/?LinkId=52471)。



## Examples
 下面的代码示例显示所有命名服务器变量的名称和值。

 [!code-csharp[Classic HttpRequest.ServerVariables Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpRequest.ServerVariables Example/CS/source.cs#1)]
 [!code-vb[Classic HttpRequest.ServerVariables Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpRequest.ServerVariables Example/VB/source.vb#1)]

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TimedOutToken">
      <MemberSignature Language="C#" Value="public System.Threading.CancellationToken TimedOutToken { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Threading.CancellationToken TimedOutToken" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.TimedOutToken" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TimedOutToken As CancellationToken" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::CancellationToken TimedOutToken { System::Threading::CancellationToken get(); };" />
      <MemberSignature Language="F#" Value="member this.TimedOutToken : System.Threading.CancellationToken" Usage="System.Web.HttpRequest.TimedOutToken" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.CancellationToken</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取请求超时时去除的 <see cref="T:System.Threading.CancellationToken" /> 对象。</summary>
        <value>取消标记。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 可以在 Web.config 文件中指定超时时间 (请参阅 <xref:System.Web.Configuration.HttpRuntimeSection.ExecutionTimeout%2A?displayProperty=nameWithType>) 或以编程方式 (参阅 <xref:System.Web.HttpServerUtility.ScriptTimeout%2A?displayProperty=nameWithType>) 。 超时期限从请求传入的时间开始算起。 如果默认的超时值为110秒，则在请求处理开始后，取消标记将不早于110秒。 您可以更改 <xref:System.Web.HttpServerUtility.ScriptTimeout%2A?displayProperty=nameWithType> 属性值，并且只要此标记尚未转到，就会考虑新的超时值。

 目前，令牌仅提供15秒的粒度，这意味着，如果超时值为110秒，则在请求处理开始后，令牌将在110到125秒之间触发。 粒度可能会在将来发生变化。

 即使此属性是线程安全的，但使用时也存在限制。 有关详细信息，请参阅 <xref:System.Web.HttpResponse.ClientDisconnectedToken%2A?displayProperty=nameWithType>。

 如果 Websocket 请求处理已开始，则此属性无意义。

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TlsTokenBindingInfo">
      <MemberSignature Language="C#" Value="public System.Web.ITlsTokenBindingInfo TlsTokenBindingInfo { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.ITlsTokenBindingInfo TlsTokenBindingInfo" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.TlsTokenBindingInfo" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TlsTokenBindingInfo As ITlsTokenBindingInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::ITlsTokenBindingInfo ^ TlsTokenBindingInfo { System::Web::ITlsTokenBindingInfo ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TlsTokenBindingInfo : System.Web.ITlsTokenBindingInfo" Usage="System.Web.HttpRequest.TlsTokenBindingInfo" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.ITlsTokenBindingInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取 TLS 标记绑定信息。 此属性使应用程序可以从传入的增强身份验证的 HTTP 请求检索令牌信息。</summary>
        <value>当前连接的绑定令牌。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 此属性 `null` 在非 windows 10 平台上返回。

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TotalBytes">
      <MemberSignature Language="C#" Value="public int TotalBytes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 TotalBytes" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.TotalBytes" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TotalBytes As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int TotalBytes { int get(); };" />
      <MemberSignature Language="F#" Value="member this.TotalBytes : int" Usage="System.Web.HttpRequest.TotalBytes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取当前输入流中的字节数。</summary>
        <value>输入流中的字节数。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Examples
 下面的代码示例确定 <xref:System.Web.HttpRequest.TotalBytes%2A> 属性值是否大于1000字节，并将该信息写入文件。

 [!code-csharp[System.Web.HttpRequest_Sample1#6](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/CS/requestdetailscs.aspx#6)]
 [!code-vb[System.Web.HttpRequest_Sample1#6](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/VB/requestdetailsvb.aspx#6)]

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Unvalidated">
      <MemberSignature Language="C#" Value="public System.Web.UnvalidatedRequestValues Unvalidated { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UnvalidatedRequestValues Unvalidated" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.Unvalidated" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Unvalidated As UnvalidatedRequestValues" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UnvalidatedRequestValues ^ Unvalidated { System::Web::UnvalidatedRequestValues ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Unvalidated : System.Web.UnvalidatedRequestValues" Usage="System.Web.HttpRequest.Unvalidated" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UnvalidatedRequestValues</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取 HTTP 请求值，不触发请求验证。</summary>
        <value>尚未使用请求验证检查的 HTTP 请求值。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 请求验证检查是否存在可能指示跨站点脚本攻击的 HTML 标记和脚本。 默认情况下，所有值都是使用请求验证进行检查的，如果任何值包含标记或脚本，ASP.NET 将引发 <xref:System.Web.HttpRequestValidationException> 异常。 如果预计请求将包含标记 (例如，你允许用户发布包含标记) 的内容，并且你想要获取请求的原始值，请使用此方法。

> [!IMPORTANT]
>  如果使用此属性，则必须手动检查数据是否存在潜在的跨站点脚本攻击。

 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UnvalidatedRequestValues" />
      </Docs>
    </Member>
    <Member MemberName="Url">
      <MemberSignature Language="C#" Value="public Uri Url { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Uri Url" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.Url" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Url As Uri" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Uri ^ Url { Uri ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Url : Uri" Usage="System.Web.HttpRequest.Url" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Uri</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取有关当前请求的 URL 的信息。</summary>
        <value>包含当前请求的 URL <see cref="T:System.Uri" /> 的对象。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Examples
 下面的代码示例将 <xref:System.Uri> 当前请求的对象分配给对象变量，并将 URL 对象的两个属性的值显示到 HTTP 输出中。

 [!code-csharp[Classic HttpRequest.Url Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpRequest.Url Example/CS/source.cs#1)]
 [!code-vb[Classic HttpRequest.Url Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpRequest.Url Example/VB/source.vb#1)]

 ]]></format>
        </remarks>
        <altmember cref="T:System.Uri" />
        <altmember cref="P:System.Web.HttpRequest.RawUrl" />
      </Docs>
    </Member>
    <Member MemberName="UrlReferrer">
      <MemberSignature Language="C#" Value="public Uri UrlReferrer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Uri UrlReferrer" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.UrlReferrer" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property UrlReferrer As Uri" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Uri ^ UrlReferrer { Uri ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UrlReferrer : Uri" Usage="System.Web.HttpRequest.UrlReferrer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Uri</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取有关客户端上次请求的 URL 的信息，该请求链接到当前的 URL。</summary>
        <value><see cref="T:System.Uri" /> 对象。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Examples
 下面的代码示例显示了引用当前应用程序的客户端的 URL 的两个属性的值。

 [!code-csharp[Classic HttpRequest.UrlReferrer Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpRequest.UrlReferrer Example/CS/source.cs#1)]
 [!code-vb[Classic HttpRequest.UrlReferrer Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpRequest.UrlReferrer Example/VB/source.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.UriFormatException">HTTP <see langword="Referer" /> 请求标头格式不正确，并且不能转换为 <see cref="T:System.Uri" /> 对象。</exception>
      </Docs>
    </Member>
    <Member MemberName="UserAgent">
      <MemberSignature Language="C#" Value="public string UserAgent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string UserAgent" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.UserAgent" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property UserAgent As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ UserAgent { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UserAgent : string" Usage="System.Web.HttpRequest.UserAgent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取所提供的客户端浏览器的原始用户代理字符串。 请注意此字符串可能为 Null。</summary>
        <value>客户端浏览器的原始用户代理信息。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Examples
 下面的代码示例将请求浏览器的类型标识分配给一个字符串变量。

 [!code-csharp[Classic HttpRequest.UserAgent Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpRequest.UserAgent Example/CS/source.cs#1)]
 [!code-vb[Classic HttpRequest.UserAgent Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpRequest.UserAgent Example/VB/source.vb#1)]

 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.Page.ClientTarget" />
        <altmember cref="T:System.Web.HttpBrowserCapabilities" />
        <altmember cref="P:System.Web.HttpRequest.Browser" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/x3k2ssx2(v=vs.100)">ASP.NET 服务器控件和浏览器功能</related>
      </Docs>
    </Member>
    <Member MemberName="UserHostAddress">
      <MemberSignature Language="C#" Value="public string UserHostAddress { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string UserHostAddress" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.UserHostAddress" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property UserHostAddress As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ UserHostAddress { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UserHostAddress : string" Usage="System.Web.HttpRequest.UserHostAddress" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取远程客户端的 IP 主机地址。</summary>
        <value>远程客户端的 IP 地址。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Examples
 下面的代码示例使用 <xref:System.Web.HttpUtility.HtmlEncode%2A> 方法对属性的值进行 HTML 编码 <xref:System.Web.HttpRequest.UserHostAddress%2A> ，并使用 <xref:System.IO.TextWriter.WriteLine%2A> 方法将编码的值写入文件。 此代码示例是为类提供的更大示例的一部分 <xref:System.Web.HttpRequest> 。

 [!code-csharp[System.Web.HttpRequest_Sample1#7](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/CS/requestdetailscs.aspx#7)]
 [!code-vb[System.Web.HttpRequest_Sample1#7](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/VB/requestdetailsvb.aspx#7)]

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UserHostName">
      <MemberSignature Language="C#" Value="public string UserHostName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string UserHostName" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.UserHostName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property UserHostName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ UserHostName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UserHostName : string" Usage="System.Web.HttpRequest.UserHostName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取远程客户端的 DNS 名称。</summary>
        <value>远程客户端的 DNS 名称。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Examples
 下面的代码示例使用 <xref:System.Web.HttpUtility.HtmlEncode%2A> 方法对属性的值进行 HTML 编码 <xref:System.Web.HttpRequest.UserHostName%2A> ，并使用 <xref:System.IO.TextWriter.WriteLine%2A> 方法将编码的值写入文件。 此代码示例是为类提供的更大示例的一部分 <xref:System.Web.HttpRequest> 。

 [!code-csharp[System.Web.HttpRequest_Sample1#7](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/CS/requestdetailscs.aspx#7)]
 [!code-vb[System.Web.HttpRequest_Sample1#7](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/VB/requestdetailsvb.aspx#7)]

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UserLanguages">
      <MemberSignature Language="C#" Value="public string[] UserLanguages { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string[] UserLanguages" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.UserLanguages" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property UserLanguages As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::String ^&gt; ^ UserLanguages { cli::array &lt;System::String ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UserLanguages : string[]" Usage="System.Web.HttpRequest.UserLanguages" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取客户端语言首选项的排序字符串数组。</summary>
        <value>经过排序的客户端语言首选项的字符串数组，或者，如果为空，则为 <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Examples
 下面的代码示例将属性返回的多个值捕获 <xref:System.Web.HttpRequest.UserLanguages%2A> 到字符串数组中，并将每个语言名称写入单独的 HTTP 输出行中。

 语言名称由浏览器提供，且没有任何可能的代码的明确列表。  通常，这些是由两个字符组成的代码：语言的两个字符代码、一个连字符和两个字符的区域性代码（例如 "en-us" 表示美国英语，"fr" 表示加拿大法语）。

 [!code-csharp[Classic HttpRequest.UserLanguages Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpRequest.UserLanguages Example/CS/source.cs#1)]
 [!code-vb[Classic HttpRequest.UserLanguages Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpRequest.UserLanguages Example/VB/source.vb#1)]

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ValidateInput">
      <MemberSignature Language="C#" Value="public void ValidateInput ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ValidateInput() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpRequest.ValidateInput" />
      <MemberSignature Language="VB.NET" Value="Public Sub ValidateInput ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ValidateInput();" />
      <MemberSignature Language="F#" Value="member this.ValidateInput : unit -&gt; unit" Usage="httpRequest.ValidateInput " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>引发对通过 <see cref="P:System.Web.HttpRequest.Cookies" /> 、<see cref="P:System.Web.HttpRequest.Form" /> 和 <see cref="P:System.Web.HttpRequest.QueryString" /> 属性访问的集合的验证。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.Web.HttpRequest>类使用输入验证标志来跟踪是否对通过 <xref:System.Web.HttpRequest.Cookies%2A> 、 <xref:System.Web.HttpRequest.Form%2A> 和属性访问的请求集合执行验证 <xref:System.Web.HttpRequest.QueryString%2A> 。 <xref:System.Web.HttpRequest.ValidateInput%2A>方法设置这些标志，以便在调用、或属性的 get 访问器时 <xref:System.Web.HttpRequest.Cookies%2A> <xref:System.Web.HttpRequest.Form%2A> <xref:System.Web.HttpRequest.QueryString%2A> ，执行输入验证。 验证的工作原理是，针对可能危险的数据的硬编码列表检查所有输入数据。

 如果通过页面指令或配置启用验证功能，则在页面的处理阶段会调用此方法 `ProcessRequest` 。 <xref:System.Web.HttpRequest.ValidateInput%2A>如果未启用验证功能，则您的代码可以调用方法。

 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpRequestValidationException">从客户端接收到具有潜在危险的数据。</exception>
        <altmember cref="P:System.Web.HttpRequest.Cookies" />
        <altmember cref="P:System.Web.HttpRequest.Form" />
        <altmember cref="P:System.Web.HttpRequest.QueryString" />
      </Docs>
    </Member>
  </Members>
</Type>
