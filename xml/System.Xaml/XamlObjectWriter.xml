<Type Name="XamlObjectWriter" FullName="System.Xaml.XamlObjectWriter">
  <Metadata><Meta Name="ms.openlocfilehash" Value="6713a2cb1884363c06d70a8db2a846ebfa8e3889" /><Meta Name="ms.sourcegitcommit" Value="b53d35b4a410c949742abd4c6a989d1af5357bca" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-CN" /><Meta Name="ms.lasthandoff" Value="07/21/2020" /><Meta Name="ms.locfileid" Value="86692157" /></Metadata><TypeSignature Language="C#" Value="public class XamlObjectWriter : System.Xaml.XamlWriter, System.Xaml.IXamlLineInfoConsumer" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit XamlObjectWriter extends System.Xaml.XamlWriter implements class System.Xaml.IXamlLineInfoConsumer" />
  <TypeSignature Language="DocId" Value="T:System.Xaml.XamlObjectWriter" />
  <TypeSignature Language="VB.NET" Value="Public Class XamlObjectWriter&#xA;Inherits XamlWriter&#xA;Implements IXamlLineInfoConsumer" />
  <TypeSignature Language="C++ CLI" Value="public ref class XamlObjectWriter : System::Xaml::XamlWriter, System::Xaml::IXamlLineInfoConsumer" />
  <TypeSignature Language="F#" Value="type XamlObjectWriter = class&#xA;    inherit XamlWriter&#xA;    interface IXamlLineInfoConsumer" />
  <AssemblyInfo>
    <AssemblyName>System.Xaml</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>5.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Xaml.XamlWriter</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Xaml.IXamlLineInfoConsumer</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>从源 XAML 节点流创建对象图。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 的 `Write` 方法 <xref:System.Xaml.XamlObjectWriter> 实现模式，以便 <xref:System.Xaml.XamlObjectWriter> 使用 <xref:System.Xaml.XamlWriter> 由方法定义的 <xref:System.Xaml.XamlWriter.WriteNode%2A> 。 <xref:System.Xaml.XamlWriter.WriteNode%2A> 逻辑 `Write` 在方法之间切换，具体取决于读取器中当前位置的节点类型。  
  
## <a name="scope"></a>范围  
 <xref:System.Xaml.XamlObjectWriter>具有作用域的概念; 即，在 <xref:System.Xaml.XamlObjectWriter> 其输出对象关系图中维护一个概念点引用。 对于特定范围，某些操作可能有效或无效，或者产生无操作结果。 例如，如果您调用 <xref:System.Xaml.XamlObjectWriter.WriteStartMember%2A> 来编写在已作为实例存在的对象上进行初始化的指令，则默认实现将引发异常。  
  
 跟踪自定义中的作用域的可能方法 <xref:System.Xaml.XamlObjectWriter> 是将节点操作与堆栈或帧类对齐。 在写入对象图时，堆栈或帧可以跟踪输入或退出的对象模型深度的每个级别的 push 和 pop <xref:System.Xaml.XamlObjectWriter> 。  
  
## <a name="callbacks"></a>回调  
 为了支持中级和高级 <xref:System.Xaml.XamlObjectWriter> 方案，编写对象图的机制提供了在 <xref:System.Xaml.XamlObjectWriter> 提交或将要提交特定操作时出现的回调入口点。 某些回调在设置中启用，并且不特定于对象类型或被写入的成员;但是，回调信息通常在上下文中提供，或在通过回调发送的事件数据中提供。 下面是相关回调的列表：  
  
-   <xref:System.Xaml.XamlObjectWriterSettings.AfterBeginInitHandler%2A>当作用域进入新对象时，以及在 <xref:System.ComponentModel.ISupportInitialize.BeginInit%2A> 对象生存期的每个所创建对象的阶段，将调用由声明的回调。  
  
-   <xref:System.Xaml.XamlObjectWriterSettings.AfterEndInitHandler%2A>当作用域进入新对象时，以及在 <xref:System.ComponentModel.ISupportInitialize.EndInit%2A> 对象生存期的每个所创建对象的阶段，将调用由声明的回调。  
  
-   <xref:System.Xaml.XamlObjectWriterSettings.BeforePropertiesHandler%2A>当作用域在对象中启动时，将调用由声明的回调，并在第一次 <xref:System.Xaml.XamlObjectWriter.WriteStartMember%2A> 调用该对象范围但尚未提交时发生。  
  
-   <xref:System.Xaml.XamlObjectWriterSettings.AfterPropertiesHandler%2A>当作用域在对象中启动时，将调用由声明的回调，并在对 <xref:System.Xaml.XamlObjectWriter.WriteEndObject%2A> 该对象范围的调用但尚未提交时发生。  
  
-   当调用时，将调用由声明的回调 <xref:System.Xaml.XamlObjectWriterSettings.XamlSetValueHandler%2A> <xref:System.Xaml.XamlObjectWriter.OnSetValue%2A> 。  
  
## <a name="writing-dictionary-keys"></a>写入字典键  
 <xref:System.Xaml.XamlObjectWriter>在将 <xref:System.Collections.Generic.Dictionary%602> 字典内容添加到对象图之前，的默认实现支持对的约束的类型转换。 通过这种方式，一般字典可在运行时按对象进行键控，并可与相关的泛型 `Add` 和索引器行为匹配。 但是，在为基实现时 <xref:System.Xaml.XamlObjectWriter> ，此功能仅适用于从基类创建的对象图，不适用于的 <xref:System.Collections.Generic.Dictionary%602> 派生类 <xref:System.Collections.Generic.Dictionary%602> 。  
  
## <a name="checks-for-disposed"></a>检查是否已释放  
 XAML 编写器可能用于延迟的操作，或对已在中期中释放的 XAML 编写器实例进行调用的位置。 <xref:System.Xaml.XamlObjectWriter>在这些情况下，可能会引发的各种 api <xref:System.ObjectDisposedException> 。  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Xaml.XamlWriter" />
    <altmember cref="T:System.Xaml.XamlObjectReader" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>初始化 <see cref="T:System.Xaml.XamlObjectWriter" /> 类的新实例。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XamlObjectWriter (System.Xaml.XamlSchemaContext schemaContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Xaml.XamlSchemaContext schemaContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlObjectWriter.#ctor(System.Xaml.XamlSchemaContext)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (schemaContext As XamlSchemaContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XamlObjectWriter(System::Xaml::XamlSchemaContext ^ schemaContext);" />
      <MemberSignature Language="F#" Value="new System.Xaml.XamlObjectWriter : System.Xaml.XamlSchemaContext -&gt; System.Xaml.XamlObjectWriter" Usage="new System.Xaml.XamlObjectWriter schemaContext" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="schemaContext" Type="System.Xaml.XamlSchemaContext" />
      </Parameters>
      <Docs>
        <param name="schemaContext">与 XAML 读取器共享的 XAML 架构上下文，该读取器提供节点用于编写。</param>
        <summary>使用 <see cref="T:System.Xaml.XamlObjectWriter" /> 所用的 XAML 架构上下文初始化 <see cref="T:System.Xaml.XamlReader" /> 类的新实例。</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="schemaContext" /> 为 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XamlObjectWriter (System.Xaml.XamlSchemaContext schemaContext, System.Xaml.XamlObjectWriterSettings settings);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Xaml.XamlSchemaContext schemaContext, class System.Xaml.XamlObjectWriterSettings settings) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlObjectWriter.#ctor(System.Xaml.XamlSchemaContext,System.Xaml.XamlObjectWriterSettings)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (schemaContext As XamlSchemaContext, settings As XamlObjectWriterSettings)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XamlObjectWriter(System::Xaml::XamlSchemaContext ^ schemaContext, System::Xaml::XamlObjectWriterSettings ^ settings);" />
      <MemberSignature Language="F#" Value="new System.Xaml.XamlObjectWriter : System.Xaml.XamlSchemaContext * System.Xaml.XamlObjectWriterSettings -&gt; System.Xaml.XamlObjectWriter" Usage="new System.Xaml.XamlObjectWriter (schemaContext, settings)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="schemaContext" Type="System.Xaml.XamlSchemaContext" />
        <Parameter Name="settings" Type="System.Xaml.XamlObjectWriterSettings" />
      </Parameters>
      <Docs>
        <param name="schemaContext">与 XAML 读取器共享的 XAML 架构上下文，该读取器提供节点用于编写。</param>
        <param name="settings">一个设置对象，该对象为 <see cref="T:System.Xaml.XamlObjectWriter" /> 行为和输出指定某些选项。</param>
        <summary>使用 <see cref="T:System.Xaml.XamlObjectWriter" /> 所用的上下文及其设置初始化 <see cref="T:System.Xaml.XamlReader" /> 类的新实例。</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="schemaContext" /> 为 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlObjectWriter.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Sub Clear ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Clear();" />
      <MemberSignature Language="F#" Value="member this.Clear : unit -&gt; unit" Usage="xamlObjectWriter.Clear " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>重置所有可能的框架并清除对象图。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlObjectWriter.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="override this.Dispose : bool -&gt; unit" Usage="xamlObjectWriter.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing"><see langword="true" /> 表示释放托管资源；否则为 <see langword="false" />。</param>
        <summary>释放由 <see cref="T:System.Xaml.XamlObjectWriter" /> 占用的非托管资源，也可以选择释放托管资源。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnAfterBeginInit">
      <MemberSignature Language="C#" Value="protected virtual void OnAfterBeginInit (object value);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnAfterBeginInit(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlObjectWriter.OnAfterBeginInit(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnAfterBeginInit (value As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnAfterBeginInit(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="abstract member OnAfterBeginInit : obj -&gt; unit&#xA;override this.OnAfterBeginInit : obj -&gt; unit" Usage="xamlObjectWriter.OnAfterBeginInit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">要报告的对象。 在调用处理程序时，此对象封装在 <see cref="T:System.Xaml.XamlObjectEventArgs" /> 中。</param>
        <summary>为此 <see cref="P:System.Xaml.XamlObjectWriterSettings.AfterBeginInitHandler" /> 调用任何与 <see cref="T:System.Xaml.XamlObjectWriterSettings" /> 关联的 <see cref="T:System.Xaml.XamlObjectWriter" /> 方法。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnAfterEndInit">
      <MemberSignature Language="C#" Value="protected virtual void OnAfterEndInit (object value);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnAfterEndInit(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlObjectWriter.OnAfterEndInit(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnAfterEndInit (value As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnAfterEndInit(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="abstract member OnAfterEndInit : obj -&gt; unit&#xA;override this.OnAfterEndInit : obj -&gt; unit" Usage="xamlObjectWriter.OnAfterEndInit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">要报告的对象。 在调用处理程序时，此值封装在 <see cref="T:System.Xaml.XamlObjectEventArgs" /> 中。</param>
        <summary>为此 <see cref="P:System.Xaml.XamlObjectWriterSettings.AfterEndInitHandler" /> 调用任何与 <see cref="T:System.Xaml.XamlObjectWriterSettings" /> 关联的 <see cref="T:System.Xaml.XamlObjectWriter" /> 方法。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnAfterProperties">
      <MemberSignature Language="C#" Value="protected virtual void OnAfterProperties (object value);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnAfterProperties(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlObjectWriter.OnAfterProperties(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnAfterProperties (value As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnAfterProperties(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="abstract member OnAfterProperties : obj -&gt; unit&#xA;override this.OnAfterProperties : obj -&gt; unit" Usage="xamlObjectWriter.OnAfterProperties value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">要报告的对象。 在调用处理程序时，此对象封装在 <see cref="T:System.Xaml.XamlObjectEventArgs" /> 中。</param>
        <summary>为此 <see cref="P:System.Xaml.XamlObjectWriterSettings.AfterPropertiesHandler" /> 调用任何与 <see cref="T:System.Xaml.XamlObjectWriterSettings" />  关联的 <see cref="T:System.Xaml.XamlObjectWriter" /> 引用的方法。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnBeforeProperties">
      <MemberSignature Language="C#" Value="protected virtual void OnBeforeProperties (object value);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnBeforeProperties(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlObjectWriter.OnBeforeProperties(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnBeforeProperties (value As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnBeforeProperties(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="abstract member OnBeforeProperties : obj -&gt; unit&#xA;override this.OnBeforeProperties : obj -&gt; unit" Usage="xamlObjectWriter.OnBeforeProperties value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">要在调用处理程序时通过 <see cref="T:System.Xaml.XamlObjectEventArgs" /> 传递的值。</param>
        <summary>为此 <see cref="P:System.Xaml.XamlObjectWriterSettings.BeforePropertiesHandler" /> 调用任何与 <see cref="T:System.Xaml.XamlObjectWriterSettings" />  关联的 <see cref="T:System.Xaml.XamlObjectWriter" /> 引用的方法。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnSetValue">
      <MemberSignature Language="C#" Value="protected virtual bool OnSetValue (object eventSender, System.Xaml.XamlMember member, object value);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool OnSetValue(object eventSender, class System.Xaml.XamlMember member, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlObjectWriter.OnSetValue(System.Object,System.Xaml.XamlMember,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function OnSetValue (eventSender As Object, member As XamlMember, value As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool OnSetValue(System::Object ^ eventSender, System::Xaml::XamlMember ^ member, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="abstract member OnSetValue : obj * System.Xaml.XamlMember * obj -&gt; bool&#xA;override this.OnSetValue : obj * System.Xaml.XamlMember * obj -&gt; bool" Usage="xamlObjectWriter.OnSetValue (eventSender, member, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="eventSender" Type="System.Object" />
        <Parameter Name="member" Type="System.Xaml.XamlMember" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="eventSender">要作为源向处理程序报告的对象。</param>
        <param name="member">要设置的属性的名称，该名称将作为 <see cref="T:System.Windows.Markup.XamlSetValueEventArgs" /> 的一部分传递到处理程序。</param>
        <param name="value">要为由 <paramref name="property" /> 命名的属性提供的值。 此值作为 <see cref="T:System.Windows.Markup.XamlSetValueEventArgs" /> 的一部分传递给处理程序。</param>
        <summary>为此编写器调用任何与 <see cref="P:System.Xaml.XamlObjectWriterSettings.XamlSetValueHandler" /> 关联的 <see cref="T:System.Xaml.XamlObjectWriterSettings" /> 引用的方法（只要 <see cref="T:System.Windows.Markup.XamlSetValueEventArgs" /> 事件数据中的 <paramref name="handled" /> 不为 <see langword="true" />）。</summary>
        <returns>由任何关联的处理程序设置的布尔值；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果 `SetValue` 此 XAML 编写器的操作具有关联的处理程序 (<xref:System.Xaml.XamlObjectWriterSettings.XamlSetValueHandler%2A> 在) 中声明 <xref:System.Xaml.XamlObjectWriterSettings> ，则此方法将创建新的并将 <xref:System.Windows.Markup.XamlSetValueEventArgs> 其传递给处理程序。 返回值是通过读取 <xref:System.Windows.Markup.XamlSetValueEventArgs.Handled%2A> 通过事件数据传递的值来设置的。 如果不存在处理程序并且调用了此方法，则调用将返回 `false` 。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Result">
      <MemberSignature Language="C#" Value="public virtual object Result { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Result" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlObjectWriter.Result" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Result As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Object ^ Result { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Result : obj" Usage="System.Xaml.XamlObjectWriter.Result" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取写入的最后一个对象。 通常，仅在节点流位于结尾且对象关系图完整时才调用。</summary>
        <value>写入的最后一个对象，或者为 <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 最常见的用法 <xref:System.Xaml.XamlObjectWriter.Result%2A> 是仅当已知节点流的末尾时才调用此方法，并且对象图已经完成。 否则，对象图可能是不完整的，在大多数平台方案中都不适用。  
  
 <xref:System.Xaml.XamlObjectWriter.Result%2A> 通常，如果在调用后立即调用 <xref:System.Xaml.XamlObjectWriter.WriteEndObject%2A> ，并且当前范围位于对象提供值的成员中，则通常仅包含非 null 值。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RootNameScope">
      <MemberSignature Language="C#" Value="public System.Windows.Markup.INameScope RootNameScope { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Markup.INameScope RootNameScope" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlObjectWriter.RootNameScope" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RootNameScope As INameScope" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Markup::INameScope ^ RootNameScope { System::Windows::Markup::INameScope ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.RootNameScope : System.Windows.Markup.INameScope" Usage="System.Xaml.XamlObjectWriter.RootNameScope" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Markup.INameScope</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取 <see cref="T:System.Windows.Markup.INameScope" /> 服务，该服务为 XAML 对象编写器的绝对根节点维护 XAML 名称范围。</summary>
        <value><see cref="T:System.Windows.Markup.INameScope" /> 服务，该服务为对象编写器的当前根维护 XAML 名称范围。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此属性的值可能来自对象编写器上下文。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SchemaContext">
      <MemberSignature Language="C#" Value="public override System.Xaml.XamlSchemaContext SchemaContext { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xaml.XamlSchemaContext SchemaContext" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlObjectWriter.SchemaContext" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property SchemaContext As XamlSchemaContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Xaml::XamlSchemaContext ^ SchemaContext { System::Xaml::XamlSchemaContext ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SchemaContext : System.Xaml.XamlSchemaContext" Usage="System.Xaml.XamlObjectWriter.SchemaContext" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlSchemaContext</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取活动 XAML 架构上下文。</summary>
        <value>XAML 架构上下文。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 XAML 架构上下文是大多数实际对象编写方案必需的信息源。 XAML 架构上下文会影响后备类型的类型查找，并保存有关支持类型的程序集的信息。 默认 XAML 架构上下文基于 CLR 类型映射规则。 框架通常提供自己的 XAML 架构上下文，以确保程序集加载机制与框架的编程 amd 应用程序模型匹配。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetLineInfo">
      <MemberSignature Language="C#" Value="public void SetLineInfo (int lineNumber, int linePosition);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetLineInfo(int32 lineNumber, int32 linePosition) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlObjectWriter.SetLineInfo(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetLineInfo (lineNumber As Integer, linePosition As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void SetLineInfo(int lineNumber, int linePosition);" />
      <MemberSignature Language="F#" Value="abstract member SetLineInfo : int * int -&gt; unit&#xA;override this.SetLineInfo : int * int -&gt; unit" Usage="xamlObjectWriter.SetLineInfo (lineNumber, linePosition)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Xaml.IXamlLineInfoConsumer.SetLineInfo(System.Int32,System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="lineNumber" Type="System.Int32" />
        <Parameter Name="linePosition" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="lineNumber">读取器中的行号。</param>
        <param name="linePosition">读取器中的行位置。</param>
        <summary>实现 <see cref="M:System.Xaml.IXamlLineInfoConsumer.SetLineInfo(System.Int32,System.Int32)" />，并为异常提供行信息。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此服务方法不应在代码中直接调用。 但是，如果要从创建派生类 <xref:System.Xaml.XamlObjectWriter> ，并希望报告某个行号不可用或不有用的上下文，则可以调用此方法。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldProvideLineInfo">
      <MemberSignature Language="C#" Value="public bool ShouldProvideLineInfo { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ShouldProvideLineInfo" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlObjectWriter.ShouldProvideLineInfo" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ShouldProvideLineInfo As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ShouldProvideLineInfo { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.ShouldProvideLineInfo : bool" Usage="System.Xaml.XamlObjectWriter.ShouldProvideLineInfo" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Xaml.IXamlLineInfoConsumer.ShouldProvideLineInfo</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值报告行信息服务是否应提供值并因此在相关时同时调用 <see cref="M:System.Xaml.IXamlLineInfoConsumer.SetLineInfo(System.Int32,System.Int32)" /> 方法。</summary>
        <value>如果行信息由编写器使用，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此实现始终返回 `true`。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteEndMember">
      <MemberSignature Language="C#" Value="public override void WriteEndMember ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void WriteEndMember() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlObjectWriter.WriteEndMember" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub WriteEndMember ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void WriteEndMember();" />
      <MemberSignature Language="F#" Value="override this.WriteEndMember : unit -&gt; unit" Usage="xamlObjectWriter.WriteEndMember " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>关闭当前成员范围，并且可能在关闭时写入成员范围的值。 新范围将成为成员的父对象范围。</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Xaml.XamlObjectWriterException">未能从在此调用和上一个 <see langword="StartMember" /> 之间遇到的值节点创建成员值。</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteEndObject">
      <MemberSignature Language="C#" Value="public override void WriteEndObject ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void WriteEndObject() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlObjectWriter.WriteEndObject" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub WriteEndObject ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void WriteEndObject();" />
      <MemberSignature Language="F#" Value="override this.WriteEndObject : unit -&gt; unit" Usage="xamlObjectWriter.WriteEndObject " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>关闭编写器中的当前对象范围。 新对象范围将成为的父成员范围。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果此 `EndObject` 位置范围正在关闭根对象，则新的对象范围将成为根范围。  
  
 对的调用 <xref:System.Xaml.XamlObjectWriter.WriteStartObject%2A> 可能尚未创建对象，因为对象成员可能是必需的初始化路径，例如初始化文本或初始化参数。 对于这些情况，调用实际上会 <xref:System.Xaml.XamlObjectWriter.WriteEndObject%2A> 写入对象。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteGetObject">
      <MemberSignature Language="C#" Value="public override void WriteGetObject ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void WriteGetObject() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlObjectWriter.WriteGetObject" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub WriteGetObject ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void WriteGetObject();" />
      <MemberSignature Language="F#" Value="override this.WriteGetObject : unit -&gt; unit" Usage="xamlObjectWriter.WriteGetObject " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>当指定对象是父属性的默认值或隐式值时，将概念 <see langword="StartObject" /> 写入对象关系图。 隐式值来自从 XAML 架构上下文中获取的信息以及后备类型信息，而不是指定为输入 XAML 节点集中的对象值。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Xaml.XamlObjectWriter.WriteGetObject%2A> <xref:System.Xaml.XamlObjectWriter.WriteStartObject%2A> 可在生成的对象图中查看通过编写和向写入的不同之处。 <xref:System.Xaml.XamlObjectWriter.WriteGetObject%2A> 不构造类型的实例，因为 <xref:System.Xaml.XamlObjectWriter.WriteGetObject%2A> API 没有信息来通知对象关系图的构造。 相反，对象是在初始化父属性时创建的;因此，不 <xref:System.Xaml.XamlObjectWriter> 需要构造它。 相反， <xref:System.Xaml.XamlObjectWriter.WriteStartObject%2A> 指定应构造该类型的实例并将其插入到对象图中。  
  
 如果将 XAML 节点流视为一系列的帧，则会将其 <xref:System.Xaml.XamlObjectWriter.WriteGetObject%2A> 平衡到 <xref:System.Xaml.XamlObjectWriter.WriteEndObject%2A> 调用。 因此， <xref:System.Xaml.XamlObjectWriter.WriteGetObject%2A> 加上调用的次数 <xref:System.Xaml.XamlObjectWriter.WriteStartObject%2A> 应等于 <xref:System.Xaml.XamlObjectWriter.WriteEndObject%2A> XAML 节点流的完整对象写入计算的一部分的调用数。  
  
 `StartObject`对象图中的隐式对象的概念位置是必需的，因为虽然对象值本身是隐式默认值，但该对象可能仍有需要基于 XAML 节点流编写的成员。 出现这种情况的典型方案是：为 <xref:System.Xaml.XamlObjectWriter> 集合属性写入成员节点，并且集合初始化是隐式的，以创建拥有集合属性的对象。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteNamespace">
      <MemberSignature Language="C#" Value="public override void WriteNamespace (System.Xaml.NamespaceDeclaration namespaceDeclaration);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void WriteNamespace(class System.Xaml.NamespaceDeclaration namespaceDeclaration) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlObjectWriter.WriteNamespace(System.Xaml.NamespaceDeclaration)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub WriteNamespace (namespaceDeclaration As NamespaceDeclaration)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void WriteNamespace(System::Xaml::NamespaceDeclaration ^ namespaceDeclaration);" />
      <MemberSignature Language="F#" Value="override this.WriteNamespace : System.Xaml.NamespaceDeclaration -&gt; unit" Usage="xamlObjectWriter.WriteNamespace namespaceDeclaration" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="namespaceDeclaration" Type="System.Xaml.NamespaceDeclaration" />
      </Parameters>
      <Docs>
        <param name="namespaceDeclaration">要写入的命名空间声明。</param>
        <summary>定义一个命名空间声明，该声明适用于下一个对象范围或成员范围。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果当前范围是根范围、对象范围或成员范围，则可以编写命名空间声明。 但是， <xref:System.Xaml.XamlObjectWriter.WriteNamespace%2A> 只能在调用以下项之一之前调用： <xref:System.Xaml.XamlObjectWriter.WriteNamespace%2A> 、 <xref:System.Xaml.XamlObjectWriter.WriteStartObject%2A> 或 <xref:System.Xaml.XamlObjectWriter.WriteStartMember%2A> 。 连续的 <xref:System.Xaml.XamlObjectWriter.WriteNamespace%2A> 情况是将多个命名空间声明写入同一节点。 最终， <xref:System.Xaml.XamlObjectWriter.WriteStartObject%2A> <xref:System.Xaml.XamlObjectWriter.WriteStartMember%2A> 必须调用或。  
  
 <xref:System.Xaml.XamlObjectWriter.WriteNamespace%2A>不使用 `Start` / `End` 比喻。 尽管 XAML 命名空间具有 CLR 表示法中的成员，但这些成员是已知的，无需表示为可扩展性的特殊类型 <xref:System.Xaml.XamlMember> 。 若要访问的值 <xref:System.Xaml.NamespaceDeclaration> ，请访问其 <xref:System.Xaml.NamespaceDeclaration.Namespace%2A> 和 <xref:System.Xaml.NamespaceDeclaration.Prefix%2A> 属性。  
  
 命名空间声明可以具有 <xref:System.String.Empty?displayProperty=nameWithType> 前缀的值。 <xref:System.String.Empty?displayProperty=nameWithType>前缀表示默认 XAML 命名空间的声明。 不要尝试使用 null 来表示默认前缀; 它在此 API 中引发异常。 有关详细信息，请参阅 <xref:System.Xaml.NamespaceDeclaration>。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="namespaceDeclaration" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="namespaceDeclaration" /> 的组件为 <see langword="null" />。</exception>
        <exception cref="T:System.Xaml.XamlObjectReaderException">尝试在无效的范围中写入 XAML 命名空间节点。</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteStartMember">
      <MemberSignature Language="C#" Value="public override void WriteStartMember (System.Xaml.XamlMember property);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void WriteStartMember(class System.Xaml.XamlMember property) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlObjectWriter.WriteStartMember(System.Xaml.XamlMember)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub WriteStartMember (property As XamlMember)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void WriteStartMember(System::Xaml::XamlMember ^ property);" />
      <MemberSignature Language="F#" Value="override this.WriteStartMember : System.Xaml.XamlMember -&gt; unit" Usage="xamlObjectWriter.WriteStartMember property" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="property" Type="System.Xaml.XamlMember" />
      </Parameters>
      <Docs>
        <param name="property">要写入的 XAML 属性。 通常，您通过中间 XAML 节点流从 XAML 读取器中获取此值。</param>
        <summary>将新成员节点写入当前对象范围，并且该范围将成为新的成员范围。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!TIP]
>  监视 <xref:System.Xaml.XamlDuplicateMemberException> ，这在 xaml 输入中两次设置相同的 xaml 属性时发生。 在简单的情况下（如在属性语法和属性元素语法中同时设置相同属性时），可以轻松地在输入标记中看到此异常。 但是，可能会出现更难以发现的更多微妙情况。 例如，如果您设置了 xaml 内容属性（包括 XAML 环境属性），并且属性同时启用了可附加的用法和实例使用情况，则可能会发生此异常。 在开发的调试阶段，你通常可以通过查看连接标记读取和对象图写入的中间 XAML 节点表示形式来查找此异常。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xaml.XamlObjectWriterException"><paramref name="property" /> 将 <see cref="P:System.Xaml.XamlMember.IsUnknown" /> 设置为 <see langword="true" />。  
  
- 或 - 
 <see cref="P:System.Xaml.XamlLanguage.UnknownContent" /> 传递，指示 XAML 节点流为不支持内容的对象包含内容。  
  
- 或 - 
尝试在无效的范围中写入开始成员。</exception>
        <exception cref="T:System.Xaml.XamlDuplicateMemberException"><paramref name="property" /> 指定父对象作用域中已显式设置的属性。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="property" /> 为 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteStartObject">
      <MemberSignature Language="C#" Value="public override void WriteStartObject (System.Xaml.XamlType xamlType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void WriteStartObject(class System.Xaml.XamlType xamlType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlObjectWriter.WriteStartObject(System.Xaml.XamlType)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub WriteStartObject (xamlType As XamlType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void WriteStartObject(System::Xaml::XamlType ^ xamlType);" />
      <MemberSignature Language="F#" Value="override this.WriteStartObject : System.Xaml.XamlType -&gt; unit" Usage="xamlObjectWriter.WriteStartObject xamlType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="xamlType" Type="System.Xaml.XamlType" />
      </Parameters>
      <Docs>
        <param name="xamlType">要写入的类型。 通常，您从 XAML 读取器中获取此值。</param>
        <summary>将对象节点写入当前范围，并将该范围设置为新对象范围。</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Xaml.XamlObjectWriterException">处理 <see cref="P:System.Xaml.XamlType.IsUnknown" /> 类型，且无法创建对象。  
  
- 或 - 
尝试在无效的范围中写入开始对象。</exception>
        <exception cref="T:System.Xaml.XamlParseException">尝试在根对象已经在设置中提供时写入根对象。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="xamlType" /> 为 <see langword="null" />。</exception>
        <block subset="none" type="overrides"><para>如果当前范围位于集合、字典或数组中，则应使用相关类型的方法将新实例添加到集合、字典或数组 <see langword="Add" /> 。 否则，应将成员分配给新的实例。</para></block>
      </Docs>
    </Member>
    <Member MemberName="WriteValue">
      <MemberSignature Language="C#" Value="public override void WriteValue (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void WriteValue(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlObjectWriter.WriteValue(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub WriteValue (value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void WriteValue(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="override this.WriteValue : obj -&gt; unit" Usage="xamlObjectWriter.WriteValue value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">要写入的值。</param>
        <summary>将值写入当前成员范围。 如果当前范围位于集合、字典或数组对象内部，则应将该值添加到集合、字典或数组中。</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Xaml.XamlObjectWriterException">尝试在无效的范围中写入值。</exception>
      </Docs>
    </Member>
  </Members>
</Type>
