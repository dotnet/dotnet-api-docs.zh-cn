<Type Name="XamlType" FullName="System.Xaml.XamlType">
  <Metadata><Meta Name="ms.openlocfilehash" Value="71fe6c46af1937889aa265860ef9a4011d590f01" /><Meta Name="ms.sourcegitcommit" Value="45d7745d094b38af5ccba8a4ca47efe84a312ef0" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-CN" /><Meta Name="ms.lasthandoff" Value="10/27/2020" /><Meta Name="ms.locfileid" Value="92686161" /></Metadata><TypeSignature Language="C#" Value="public class XamlType : IEquatable&lt;System.Xaml.XamlType&gt;" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit XamlType extends System.Object implements class System.IEquatable`1&lt;class System.Xaml.XamlType&gt;" />
  <TypeSignature Language="DocId" Value="T:System.Xaml.XamlType" />
  <TypeSignature Language="VB.NET" Value="Public Class XamlType&#xA;Implements IEquatable(Of XamlType)" />
  <TypeSignature Language="C++ CLI" Value="public ref class XamlType : IEquatable&lt;System::Xaml::XamlType ^&gt;" />
  <TypeSignature Language="F#" Value="type XamlType = class&#xA;    interface IEquatable&lt;XamlType&gt;" />
  <AssemblyInfo>
    <AssemblyName>System.Xaml</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>5.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IEquatable&lt;System.Xaml.XamlType&gt;</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>报告作为整体 XAML 系统（在 .NET XAML 服务中实现）的一部分的 XAML 类型相关信息。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 类中的很多 Api <xref:System.Xaml.XamlType> 提供有关 xaml 类型的信息，其中所报告的概念类似于 xaml 规范 [ms-chap] 的特定部分。  
  
 <xref:System.Xaml.XamlType> 广泛用于 .NET Framework XAML 服务 API，用于报告有关 XAML 类型的信息。 <xref:System.Xaml.XamlType> 报告您需要了解的有关 XAML 类型的信息，以便使用实例或从 XAML 节点流中访问其成员或类似的 XAML 表示形式。 它的报告类似于 <xref:System.Type> clr 类型系统中与反射类（如 <xref:System.Reflection.MemberInfo> ）一起提供有关 CLR 类型及其用法的信息。  
  
 若要扩展 XAML 类型系统，可以从派生 <xref:System.Xaml.XamlType> 。 为了有效地执行此操作，你可能还需要实现 <xref:System.Xaml.Schema.XamlTypeInvoker> 。 <xref:System.Xaml.Schema.XamlTypeInvoker>使通用化 XAML 类型系统能够处理你在调用行为中指定的类型系统支持。 特定自定义 <xref:System.Xaml.Schema.XamlTypeInvoker> 提供了一种方法来减少 CLR 类型系统上的依赖项，这些依赖项由默认 <xref:System.Xaml.XamlType> 行为使用。  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>初始化 <see cref="T:System.Xaml.XamlType" /> 类的新实例。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XamlType (Type underlyingType, System.Xaml.XamlSchemaContext schemaContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Type underlyingType, class System.Xaml.XamlSchemaContext schemaContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.#ctor(System.Type,System.Xaml.XamlSchemaContext)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (underlyingType As Type, schemaContext As XamlSchemaContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XamlType(Type ^ underlyingType, System::Xaml::XamlSchemaContext ^ schemaContext);" />
      <MemberSignature Language="F#" Value="new System.Xaml.XamlType : Type * System.Xaml.XamlSchemaContext -&gt; System.Xaml.XamlType" Usage="new System.Xaml.XamlType (underlyingType, schemaContext)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="underlyingType" Type="System.Type" />
        <Parameter Name="schemaContext" Type="System.Xaml.XamlSchemaContext" />
      </Parameters>
      <Docs>
        <param name="underlyingType">要构造的 XAML 类型的基础 CLR <see cref="T:System.Type" />。</param>
        <param name="schemaContext">XAML 读取器或 XAML 编写器的 XAML 架构上下文。</param>
        <summary>基于基础 CLR 类型信息初始化 <see cref="T:System.Xaml.XamlType" /> 类的新实例。</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">一个或多个 <paramref name="underlyingType" /> 或 <paramref name="schemaContext" /> 为 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected XamlType (string typeName, System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt; typeArguments, System.Xaml.XamlSchemaContext schemaContext);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(string typeName, class System.Collections.Generic.IList`1&lt;class System.Xaml.XamlType&gt; typeArguments, class System.Xaml.XamlSchemaContext schemaContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.#ctor(System.String,System.Collections.Generic.IList{System.Xaml.XamlType},System.Xaml.XamlSchemaContext)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (typeName As String, typeArguments As IList(Of XamlType), schemaContext As XamlSchemaContext)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; XamlType(System::String ^ typeName, System::Collections::Generic::IList&lt;System::Xaml::XamlType ^&gt; ^ typeArguments, System::Xaml::XamlSchemaContext ^ schemaContext);" />
      <MemberSignature Language="F#" Value="new System.Xaml.XamlType : string * System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt; * System.Xaml.XamlSchemaContext -&gt; System.Xaml.XamlType" Usage="new System.Xaml.XamlType (typeName, typeArguments, schemaContext)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="typeArguments" Type="System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt;" />
        <Parameter Name="schemaContext" Type="System.Xaml.XamlSchemaContext" />
      </Parameters>
      <Docs>
        <param name="typeName">要创建的类型的名称。</param>
        <param name="typeArguments">用于表示泛型类型的 <see cref="T:System.Xaml.XamlType" /> 的类型参数。 可能为（并且通常为） <see langword="null" />，指示表示的类型不是泛型类型。</param>
        <param name="schemaContext">XAML 读取器和 XAML 编写器的 XAML 架构上下文。</param>
        <summary>基于类型的字符串名称初始化 <see cref="T:System.Xaml.XamlType" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 这是一个受保护的构造函数。 不存在使用此特定构造的公共派生类。 作为现有的使用者 <xref:System.Xaml.XamlType> ，必须使用其他构造函数签名 (<xref:System.Xaml.XamlType.%23ctor%28System.Type%2CSystem.Xaml.XamlSchemaContext%2CSystem.Xaml.Schema.XamlTypeInvoker%29> 、 <xref:System.Xaml.XamlType.%23ctor%28System.Type%2CSystem.Xaml.XamlSchemaContext%29> 或 <xref:System.Xaml.XamlType.%23ctor%28System.String%2CSystem.String%2CSystem.Collections.Generic.IList%7BSystem.Xaml.XamlType%7D%2CSystem.Xaml.XamlSchemaContext%29>) 才能初始化 <xref:System.Xaml.XamlType> 对象。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">一个或多个 <paramref name="typeName" /> 或 <paramref name="schemaContext" /> 为 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XamlType (Type underlyingType, System.Xaml.XamlSchemaContext schemaContext, System.Xaml.Schema.XamlTypeInvoker invoker);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Type underlyingType, class System.Xaml.XamlSchemaContext schemaContext, class System.Xaml.Schema.XamlTypeInvoker invoker) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.#ctor(System.Type,System.Xaml.XamlSchemaContext,System.Xaml.Schema.XamlTypeInvoker)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (underlyingType As Type, schemaContext As XamlSchemaContext, invoker As XamlTypeInvoker)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XamlType(Type ^ underlyingType, System::Xaml::XamlSchemaContext ^ schemaContext, System::Xaml::Schema::XamlTypeInvoker ^ invoker);" />
      <MemberSignature Language="F#" Value="new System.Xaml.XamlType : Type * System.Xaml.XamlSchemaContext * System.Xaml.Schema.XamlTypeInvoker -&gt; System.Xaml.XamlType" Usage="new System.Xaml.XamlType (underlyingType, schemaContext, invoker)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="underlyingType" Type="System.Type" />
        <Parameter Name="schemaContext" Type="System.Xaml.XamlSchemaContext" />
        <Parameter Name="invoker" Type="System.Xaml.Schema.XamlTypeInvoker" />
      </Parameters>
      <Docs>
        <param name="underlyingType">要构造的 XAML 类型的基础类型。</param>
        <param name="schemaContext">XAML 读取器的 XAML 架构上下文。</param>
        <param name="invoker">可针对 <see cref="T:System.Xaml.Schema.XamlTypeInvoker" /> 处理运行时反射调用的 <see cref="T:System.Xaml.XamlType" /> 实现。</param>
        <summary>基于基础类型信息和 <see cref="T:System.Xaml.XamlType" /> 实现初始化 <see cref="T:System.Xaml.Schema.XamlTypeInvoker" /> 类的新实例。</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">一个或多个 <paramref name="underlyingType" /> 或 <paramref name="schemaContext" /> 为 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XamlType (string unknownTypeNamespace, string unknownTypeName, System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt; typeArguments, System.Xaml.XamlSchemaContext schemaContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string unknownTypeNamespace, string unknownTypeName, class System.Collections.Generic.IList`1&lt;class System.Xaml.XamlType&gt; typeArguments, class System.Xaml.XamlSchemaContext schemaContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.#ctor(System.String,System.String,System.Collections.Generic.IList{System.Xaml.XamlType},System.Xaml.XamlSchemaContext)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (unknownTypeNamespace As String, unknownTypeName As String, typeArguments As IList(Of XamlType), schemaContext As XamlSchemaContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XamlType(System::String ^ unknownTypeNamespace, System::String ^ unknownTypeName, System::Collections::Generic::IList&lt;System::Xaml::XamlType ^&gt; ^ typeArguments, System::Xaml::XamlSchemaContext ^ schemaContext);" />
      <MemberSignature Language="F#" Value="new System.Xaml.XamlType : string * string * System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt; * System.Xaml.XamlSchemaContext -&gt; System.Xaml.XamlType" Usage="new System.Xaml.XamlType (unknownTypeNamespace, unknownTypeName, typeArguments, schemaContext)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="unknownTypeNamespace" Type="System.String" />
        <Parameter Name="unknownTypeName" Type="System.String" />
        <Parameter Name="typeArguments" Type="System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt;" />
        <Parameter Name="schemaContext" Type="System.Xaml.XamlSchemaContext" />
      </Parameters>
      <Docs>
        <param name="unknownTypeNamespace">类型的 XAML 命名空间（字符串形式）。</param>
        <param name="unknownTypeName">提供的 <paramref name="unknownTypeNamespace" /> XAML 命名空间中类型的名称。</param>
        <param name="typeArguments">用于表示泛型类型的 <see cref="T:System.Xaml.XamlType" /> 的类型参数。 可能为（并且通常为） <see langword="null" />，指示表示的类型不是泛型类型。</param>
        <param name="schemaContext">XAML 读取器或 XAML 编写器的 XAML 架构上下文。</param>
        <summary>基于 XAML 命名空间和类型的字符串名称初始化 <see cref="T:System.Xaml.XamlType" /> 类的新实例。 此构造函数专用于已知在支持类型系统和 XAML 架构上下文中，没有支持的类型用法的分析和 XAML 节点记录。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 仅将此构造函数用于映射到基础类型系统的 XAML 类型不可用的 "未知" 类型。 如果为，则此构造函数可能不会生成结果 <xref:System.Xaml.XamlType.IsUnknown%2A?displayProperty=nameWithType> `true` 。 相反，默认反射器逻辑将基础类型报告为 <xref:System.Xaml.XamlLanguage.Object%2A?displayProperty=nameWithType> 。 但是，此行为可能会因 <xref:System.Xaml.XamlType.LookupIsUnknown%2A> 重写而更改。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">一个或多个 <paramref name="unknownTypeNamespace" />、<paramref name="unknownTypeName" /> 或 <paramref name="schemaContext" /> 为 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="AllowedContentTypes">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt; AllowedContentTypes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IList`1&lt;class System.Xaml.XamlType&gt; AllowedContentTypes" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.AllowedContentTypes" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AllowedContentTypes As IList(Of XamlType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::IList&lt;System::Xaml::XamlType ^&gt; ^ AllowedContentTypes { System::Collections::Generic::IList&lt;System::Xaml::XamlType ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AllowedContentTypes : System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt;" Usage="System.Xaml.XamlType.AllowedContentTypes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取类型的只读集合，这些类型可用作此 <see cref="P:System.Xaml.XamlType.ContentProperty" /> 的 <see cref="T:System.Xaml.XamlType" /> 值。</summary>
        <value>可能的内容类型的只读集合。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 可分配特定内容类型的类型 (例如，可分配给作为允许内容类型的基类型，而不会将其视为) 的多个类型 <xref:System.Xaml.XamlType.AllowedContentTypes%2A> 。  
  
 如果不使用默认的内部 CLR 反射技术 <xref:System.Xaml.XamlType> ，则对此属性的调用可以调用 <xref:System.Xaml.XamlType.LookupAllowedContentTypes%2A> 派生类的重写 <xref:System.Xaml.XamlType> 。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BaseType">
      <MemberSignature Language="C#" Value="public System.Xaml.XamlType BaseType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xaml.XamlType BaseType" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.BaseType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property BaseType As XamlType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xaml::XamlType ^ BaseType { System::Xaml::XamlType ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.BaseType : System.Xaml.XamlType" Usage="System.Xaml.XamlType.BaseType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取此 XAML 类型的直接基类型的 <see cref="T:System.Xaml.XamlType" />。 将基于此 <see cref="T:System.Xaml.XamlType" /> 的基础类型和架构上下文来确定此值。</summary>
        <value>此 XAML 类型的直接基类型的 <see cref="T:System.Xaml.XamlType" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果不使用默认的内部 CLR 反射技术 <xref:System.Xaml.XamlType> ，则对此属性的调用可以调用 <xref:System.Xaml.XamlType.LookupBaseType%2A> 派生类的重写 <xref:System.Xaml.XamlType> 。 有关返回值和其他行为的详细信息，请参阅有关 <xref:System.Xaml.XamlType.LookupBaseType%2A> 此类型的文档。 默认情况下， <xref:System.Xaml.XamlType.BaseType%2A> 如果为，则返回表示的内部常数 <xref:System.Object> <xref:System.Xaml.XamlType.UnderlyingType%2A> `null` 。  
  
> [!IMPORTANT]
>  <xref:System.Xaml.XamlType.LookupBaseType%2A> 是虚拟的，因此可以重写。 重写有可能 (出于恶意目的，或者) 更改有关 XAML 类型的报告类型信息，使其不再以预期方式与其基础 CLR 类型的类型系统信息对齐。 对于分配操作和访问的任何安全关键检查，请改用基础 CLR 类型。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanAssignTo">
      <MemberSignature Language="C#" Value="public virtual bool CanAssignTo (System.Xaml.XamlType xamlType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool CanAssignTo(class System.Xaml.XamlType xamlType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.CanAssignTo(System.Xaml.XamlType)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CanAssignTo (xamlType As XamlType) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool CanAssignTo(System::Xaml::XamlType ^ xamlType);" />
      <MemberSignature Language="F#" Value="abstract member CanAssignTo : System.Xaml.XamlType -&gt; bool&#xA;override this.CanAssignTo : System.Xaml.XamlType -&gt; bool" Usage="xamlType.CanAssignTo xamlType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="xamlType" Type="System.Xaml.XamlType" />
      </Parameters>
      <Docs>
        <param name="xamlType">要针对当前的 <see cref="T:System.Xaml.XamlType" /> 检查的类型。</param>
        <summary>返回一个值，该值指示此 <see cref="T:System.Xaml.XamlType" /> 的实例在其可分配类型的列表中是否有指定的 <see cref="T:System.Xaml.XamlType" />。</summary>
        <returns>如果 <paramref name="xamlType" /> 在可分配的类型列表中，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 尽管可赋值类型不具有引用类型的所有功能，但你可以将其用于赋值。 例如，你可以使用赋值使类型与属性的值相匹配。 XAML 中可赋值类型的概念与 CLR 类型系统中强制转换的概念类似。 例如，在 CLR 类型系统下，每个类型 <xref:System.Object> 在其可赋值的类型列表中都有一个。  
  
 如果用于比较的两个 <xref:System.Xaml.XamlType> 实例中有一个 <xref:System.Xaml.XamlType.IsUnknown%2A> 与相等，则 `true` 此方法具有特殊的未知模式， `true` 如果两个 <xref:System.Xaml.XamlType> 实例是等效的，则返回。  
  
 默认实现使用的 CLR <xref:System.Type> <xref:System.Xaml.XamlType.UnderlyingType%2A> 作为此 <xref:System.Xaml.XamlType> 和输入 <xref:System.Xaml.XamlType> ，然后调用 <xref:System.Type.IsAssignableFrom%2A> 。 如果需要对可分配类型进行不同的确定，请重写此方法。  
  
 传递 null 不 `xamlType` 会引发异常，而总是返回 `false` 。  
  
> [!IMPORTANT]
>  <xref:System.Xaml.XamlType.CanAssignTo%2A> 是虚拟的，因此可以重写。 重写有可能 (出于恶意目的，或者) 更改 XAML 类型的依据，以使其不再以预期方式与其基础 CLR 类型的类型转换行为对齐。 对于分配操作和访问的任何安全关键检查，请改用基础 CLR 类型。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ConstructionRequiresArguments">
      <MemberSignature Language="C#" Value="public bool ConstructionRequiresArguments { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ConstructionRequiresArguments" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.ConstructionRequiresArguments" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ConstructionRequiresArguments As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ConstructionRequiresArguments { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.ConstructionRequiresArguments : bool" Usage="System.Xaml.XamlType.ConstructionRequiresArguments" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示此 <see cref="T:System.Xaml.XamlType" /> 是否必须具有参数（通过 <see langword="x:TypeArguments" /> 实现的泛型约束、初始化文本或其他 XAML 技术）才能构造有效的类型实例。</summary>
        <value>如果需要某个参数值才能构造实例，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果不使用默认的内部 CLR 反射技术 <xref:System.Xaml.XamlType> ，则对此属性的调用可以调用 <xref:System.Xaml.XamlType.LookupConstructionRequiresArguments%2A> 派生类的重写 <xref:System.Xaml.XamlType> 。 有关返回值和其他行为的详细信息，请参阅有关 <xref:System.Xaml.XamlType.LookupConstructionRequiresArguments%2A> 此类型的文档。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContentProperty">
      <MemberSignature Language="C#" Value="public System.Xaml.XamlMember ContentProperty { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xaml.XamlMember ContentProperty" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.ContentProperty" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ContentProperty As XamlMember" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xaml::XamlMember ^ ContentProperty { System::Xaml::XamlMember ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ContentProperty : System.Xaml.XamlMember" Usage="System.Xaml.XamlType.ContentProperty" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlMember</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取此 <see cref="T:System.Xaml.XamlMember" /> 的内容属性的 <see cref="T:System.Xaml.XamlType" /> 信息。</summary>
        <value>此 <see cref="T:System.Xaml.XamlMember" /> 的内容属性的 <see cref="T:System.Xaml.XamlType" /> 信息。 如果不存在内容属性，则可能为 <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用 CLR 类型系统的绑定或支持时，可以通过将应用到类型定义来指定类型的 XAML 内容属性 <xref:System.Windows.Markup.ContentPropertyAttribute> 。  
  
 此属性与 `[content property]` [ms-chap] 规范中的信息项对齐。  
  
 如果不使用默认的内部 CLR 反射技术 <xref:System.Xaml.XamlType> ，则对此属性的调用可以调用 <xref:System.Xaml.XamlType.LookupContentProperty%2A> 派生类的重写 <xref:System.Xaml.XamlType> 。 有关返回值和其他行为的详细信息，请参阅有关 <xref:System.Xaml.XamlType.LookupContentProperty%2A> 此类型的文档。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContentWrappers">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt; ContentWrappers { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IList`1&lt;class System.Xaml.XamlType&gt; ContentWrappers" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.ContentWrappers" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ContentWrappers As IList(Of XamlType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::IList&lt;System::Xaml::XamlType ^&gt; ^ ContentWrappers { System::Collections::Generic::IList&lt;System::Xaml::XamlType ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ContentWrappers : System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt;" Usage="System.Xaml.XamlType.ContentWrappers" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取用于在内容属性不是严格类型匹配时包装其内容的类型，例如强类型 <see langword="Collection&lt;T&gt;" /> 中的字符串。</summary>
        <value>可能的内容包装类型的只读集合；否则为 <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果没有要为类型匹配放宽考虑的包装，则此属性为 `null` 。  
  
 针对 <xref:System.Xaml.XamlType.CanAssignTo%2A> 特定内容类型计算为的类型不会被视为用于的多个类型 <xref:System.Xaml.XamlType.ContentWrappers%2A> 。  
  
 在和的 CLR 绑定 <xref:System.Xaml> 中 <xref:System.Xaml.XamlType> ，可以在类型上将 XAML 内容包装类型指定为 <xref:System.Windows.Markup.ContentWrapperAttribute> 。  
  
 如果不使用默认的内部 CLR 反射技术 <xref:System.Xaml.XamlType> ，则对此属性的调用可以调用 <xref:System.Xaml.XamlType.LookupContentWrappers%2A> 派生类的重写 <xref:System.Xaml.XamlType> 。 有关返回值和其他行为的详细信息，请参阅有关 <xref:System.Xaml.XamlType.LookupContentWrappers%2A> 此类型的文档。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DeferringLoader">
      <MemberSignature Language="C#" Value="public System.Xaml.Schema.XamlValueConverter&lt;System.Xaml.XamlDeferringLoader&gt; DeferringLoader { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xaml.Schema.XamlValueConverter`1&lt;class System.Xaml.XamlDeferringLoader&gt; DeferringLoader" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.DeferringLoader" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DeferringLoader As XamlValueConverter(Of XamlDeferringLoader)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xaml::Schema::XamlValueConverter&lt;System::Xaml::XamlDeferringLoader ^&gt; ^ DeferringLoader { System::Xaml::Schema::XamlValueConverter&lt;System::Xaml::XamlDeferringLoader ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DeferringLoader : System.Xaml.Schema.XamlValueConverter&lt;System.Xaml.XamlDeferringLoader&gt;" Usage="System.Xaml.XamlType.DeferringLoader" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.Schema.XamlValueConverter&lt;System.Xaml.XamlDeferringLoader&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取 <see cref="T:System.Xaml.Schema.XamlValueConverter`1" />，它表示此类型的延迟加载转换行为。</summary>
        <value>具有 <see cref="T:System.Xaml.Schema.XamlValueConverter`1" /> 约束的 <see cref="T:System.Xaml.XamlDeferringLoader" />，表示此类型的延迟加载行为。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 WPF 中的 XAML 模板行为是延迟加载行为的示例。  
  
 如果不使用默认的内部 CLR 反射技术 <xref:System.Xaml.XamlType> ，则对此属性的调用可以调用 <xref:System.Xaml.XamlType.LookupDeferringLoader%2A> 派生类的重写 <xref:System.Xaml.XamlType> 。 有关返回值和其他行为的详细信息，请参阅有关 <xref:System.Xaml.XamlType.LookupDeferringLoader%2A> 此类型的文档。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Equals">
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>指示当前对象是否等于另一个对象。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="xamlType.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">要与此对象进行比较的对象。</param>
        <summary>指示当前对象是否等于另一个对象。</summary>
        <returns>如果当前对象等于 <paramref name="obj" /> 参数，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (System.Xaml.XamlType other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(class System.Xaml.XamlType other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.Equals(System.Xaml.XamlType)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (other As XamlType) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Equals(System::Xaml::XamlType ^ other);" />
      <MemberSignature Language="F#" Value="override this.Equals : System.Xaml.XamlType -&gt; bool" Usage="xamlType.Equals other" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IEquatable`1.Equals(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Xaml.XamlType" />
      </Parameters>
      <Docs>
        <param name="other">与此对象进行比较的对象。</param>
        <summary>指示当前对象是否等于同一类型的另一个对象。</summary>
        <returns>如果当前对象等于 <paramref name="other" /> 参数，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetAliasedProperty">
      <MemberSignature Language="C#" Value="public System.Xaml.XamlMember GetAliasedProperty (System.Xaml.XamlDirective directive);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Xaml.XamlMember GetAliasedProperty(class System.Xaml.XamlDirective directive) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.GetAliasedProperty(System.Xaml.XamlDirective)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAliasedProperty (directive As XamlDirective) As XamlMember" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Xaml::XamlMember ^ GetAliasedProperty(System::Xaml::XamlDirective ^ directive);" />
      <MemberSignature Language="F#" Value="member this.GetAliasedProperty : System.Xaml.XamlDirective -&gt; System.Xaml.XamlMember" Usage="xamlType.GetAliasedProperty directive" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlMember</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="directive" Type="System.Xaml.XamlDirective" />
      </Parameters>
      <Docs>
        <param name="directive">要为其查找别名成员的指令。</param>
        <summary>返回由此 <see cref="T:System.Xaml.XamlType" /> 将其别名设置为 XAML 指令的 XAML 成员。</summary>
        <returns>如果可找到，则为别名成员，否则为 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果不使用默认的内部 CLR 反射技术 <xref:System.Xaml.XamlType> ，则对此方法的调用可以调用 <xref:System.Xaml.XamlType.LookupAliasedProperty%2A> 派生类的重写 <xref:System.Xaml.XamlType> 。 有关返回值和其他行为的详细信息，请参阅有关 <xref:System.Xaml.XamlType.LookupAliasedProperty%2A> 此类型的文档。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetAllAttachableMembers">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.ICollection&lt;System.Xaml.XamlMember&gt; GetAllAttachableMembers ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.ICollection`1&lt;class System.Xaml.XamlMember&gt; GetAllAttachableMembers() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.GetAllAttachableMembers" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAllAttachableMembers () As ICollection(Of XamlMember)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::ICollection&lt;System::Xaml::XamlMember ^&gt; ^ GetAllAttachableMembers();" />
      <MemberSignature Language="F#" Value="member this.GetAllAttachableMembers : unit -&gt; System.Collections.Generic.ICollection&lt;System.Xaml.XamlMember&gt;" Usage="xamlType.GetAllAttachableMembers " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.ICollection&lt;System.Xaml.XamlMember&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回一个集合，该集合包含由此 <see cref="T:System.Xaml.XamlType" /> 公开的所有可附加的属性。</summary>
        <returns>一个包含零个或多个 <see cref="T:System.Xaml.XamlMember" /> 值的集合。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Xaml.XamlMember>返回的集合中的每个都应包含支持为可附加成员的概念的值 <xref:System.Xaml.XamlMember> 。 例如，成员应 `true` 为 <xref:System.Xaml.XamlMember.IsAttachable%2A> 、类型为 <xref:System.Xaml.XamlMember.TargetType%2A> ，依此类推。  
  
 如果不使用默认的内部 CLR 反射技术 <xref:System.Xaml.XamlType> ，则对此方法的调用可以调用 <xref:System.Xaml.XamlType.LookupAllAttachableMembers%2A> 派生类的重写 <xref:System.Xaml.XamlType> 。 有关返回值和其他行为的详细信息，请参阅有关 <xref:System.Xaml.XamlType.LookupAllAttachableMembers%2A> 此类型的文档。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetAllMembers">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.ICollection&lt;System.Xaml.XamlMember&gt; GetAllMembers ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.ICollection`1&lt;class System.Xaml.XamlMember&gt; GetAllMembers() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.GetAllMembers" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAllMembers () As ICollection(Of XamlMember)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::ICollection&lt;System::Xaml::XamlMember ^&gt; ^ GetAllMembers();" />
      <MemberSignature Language="F#" Value="member this.GetAllMembers : unit -&gt; System.Collections.Generic.ICollection&lt;System.Xaml.XamlMember&gt;" Usage="xamlType.GetAllMembers " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.ICollection&lt;System.Xaml.XamlMember&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回一个集合，该集合包含由此 <see cref="T:System.Xaml.XamlType" /> 公开的所有成员。</summary>
        <returns>一个包含零个或多个 <see cref="T:System.Xaml.XamlMember" /> 值的集合。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 对此方法的调用可以调用 <xref:System.Xaml.XamlType.LookupAllMembers%2A> 派生类的重写 <xref:System.Xaml.XamlType> 。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetAttachableMember">
      <MemberSignature Language="C#" Value="public System.Xaml.XamlMember GetAttachableMember (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Xaml.XamlMember GetAttachableMember(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.GetAttachableMember(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAttachableMember (name As String) As XamlMember" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Xaml::XamlMember ^ GetAttachableMember(System::String ^ name);" />
      <MemberSignature Language="F#" Value="member this.GetAttachableMember : string -&gt; System.Xaml.XamlMember" Usage="xamlType.GetAttachableMember name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlMember</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">要获取的可附加成员的名称，形式为 <c>ownerTypeName.MemberName</c>。</param>
        <summary>返回一个 <see cref="T:System.Xaml.XamlMember" />，表示此 <see cref="T:System.Xaml.XamlType" /> 的一个命名的特定可附加成员。</summary>
        <returns>请求的可附加成员的 <see cref="T:System.Xaml.XamlMember" /> 对象；如果不存在该名称的可附加成员，则为 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 对此方法的调用可以调用 <xref:System.Xaml.XamlType.LookupAttachableMember%2A> 派生类的重写 <xref:System.Xaml.XamlType> 。  
  
> [!IMPORTANT]
>  <xref:System.Xaml.XamlType.LookupAttachableMember%2A> 是虚拟的，因此可以重写。 重写有可能 (出于恶意目的，或者) 更改 XAML 类型的已报告成员，使其不再按预期方式与 <xref:System.ComponentModel.TypeDescriptor> `Get*` 有关基础 CLR 类型的信息对齐。 对于成员报告的任何安全关键检查，请改用基础 CLR 类型。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="xamlType.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回该对象的哈希代码。</summary>
        <returns>整数哈希代码。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMember">
      <MemberSignature Language="C#" Value="public System.Xaml.XamlMember GetMember (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Xaml.XamlMember GetMember(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.GetMember(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMember (name As String) As XamlMember" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Xaml::XamlMember ^ GetMember(System::String ^ name);" />
      <MemberSignature Language="F#" Value="member this.GetMember : string -&gt; System.Xaml.XamlMember" Usage="xamlType.GetMember name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlMember</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">要获取的成员的名称（字符串形式）。</param>
        <summary>从此 <see cref="T:System.Xaml.XamlMember" /> 中返回特定命名成员的 <see cref="T:System.Xaml.XamlType" />。</summary>
        <returns>如果已找到此类成员，则为成员的 <see cref="T:System.Xaml.XamlMember" /> 信息；否则为 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 的值 `name` 应是非限定的。 指示附加成员应改为提交到的类型限定名称 <xref:System.Xaml.XamlType.GetAttachableMember%2A> 。 不应使用带前缀的成员名称;前缀是使用情况的，XAML 类型系统不能知道此类用法的上下文以及如何映射前缀。  
  
 对此方法的调用可以调用 <xref:System.Xaml.XamlType.LookupMember%2A> 派生类的重写 <xref:System.Xaml.XamlType> 。  
  
> [!IMPORTANT]
>  <xref:System.Xaml.XamlType.LookupMember%2A> 是虚拟的，因此可以重写。 重写有可能 (出于恶意目的，或者) 更改 XAML 类型的已报告成员，使其不再按预期方式与 <xref:System.ComponentModel.TypeDescriptor> `Get*` 有关基础 CLR 类型的信息对齐。 对于成员报告的任何安全关键检查，请改用基础 CLR 类型。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetPositionalParameters">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt; GetPositionalParameters (int parameterCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IList`1&lt;class System.Xaml.XamlType&gt; GetPositionalParameters(int32 parameterCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.GetPositionalParameters(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetPositionalParameters (parameterCount As Integer) As IList(Of XamlType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IList&lt;System::Xaml::XamlType ^&gt; ^ GetPositionalParameters(int parameterCount);" />
      <MemberSignature Language="F#" Value="member this.GetPositionalParameters : int -&gt; System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt;" Usage="xamlType.GetPositionalParameters parameterCount" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="parameterCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="parameterCount">您需要其相关信息的特定语法或构造函数模式的计数 (arity)。</param>
        <summary>对于标记扩展类型，返回此 <see cref="T:System.Xaml.XamlType" /> 的特定标记扩展用法中所支持位置参数的类型。</summary>
        <returns><see cref="T:System.Xaml.XamlType" /> 值的列表，其中每个 <see cref="T:System.Xaml.XamlType" /> 都是该位置在语法中的类型。 您必须按照为标记扩展提供标记输入时的相同顺序指定类型。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 仅当这 <xref:System.Xaml.XamlType> 表示)  (标记扩展时，此 API 才适用 <xref:System.Xaml.XamlType.IsMarkupExtension%2A> `true` 。  
  
 输入 `parameterCount` 不用于请求特定位置参数的类型。 它用于指定标记扩展用法的 arity。 标记扩展用法通常包含多个 "签名"，并使用不同的参数 arity (要区分) 位置参数的数目。 不过，您可以将架构上下文配置为允许重复的 arities，并使用位置参数的类型进行区分。 有关详细信息，请参阅 <xref:System.Xaml.XamlSchemaContext.SupportMarkupExtensionsWithDuplicateArity%2A>。 对于特定 arity (计数) ，参数位置和类型可能会有所不同。 若要获取特定 arity 标记扩展用法的位置类型，请首先调用 <xref:System.Xaml.XamlType.GetPositionalParameters%2A> 指定 arity 计数。 然后从返回的集合中获取该位置处的项。  
  
 对此方法的调用可以调用 <xref:System.Xaml.XamlType.LookupPositionalParameters%2A> 派生类的重写 <xref:System.Xaml.XamlType> 。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetXamlNamespaces">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IList&lt;string&gt; GetXamlNamespaces ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IList`1&lt;string&gt; GetXamlNamespaces() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.GetXamlNamespaces" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetXamlNamespaces () As IList(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::Generic::IList&lt;System::String ^&gt; ^ GetXamlNamespaces();" />
      <MemberSignature Language="F#" Value="abstract member GetXamlNamespaces : unit -&gt; System.Collections.Generic.IList&lt;string&gt;&#xA;override this.GetXamlNamespaces : unit -&gt; System.Collections.Generic.IList&lt;string&gt;" Usage="xamlType.GetXamlNamespaces " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>为包括了类型的 XAML 命名空间返回字符串标识符的列表。</summary>
        <returns>字符串值的列表，其中的每个字符串都是 XAML 命名空间的 URI 标识符。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 典型的 XAML 命名空间标识符是 URI 格式的字符串。  
  
 默认实现按顺序检查以下各项：构造中提供的 XAML 命名空间 (<xref:System.Xaml.XamlType.%23ctor%28System.String%2CSystem.String%2CSystem.Collections.Generic.IList%7BSystem.Xaml.XamlType%7D%2CSystem.Xaml.XamlSchemaContext%29> 签名仅) ; 和架构上下文中可用的命名空间。 如果这些都是 `null` ，则会生成一个新列表，其中包含一个空字符串。 您可以重写此方法以更改查找方法。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Invoker">
      <MemberSignature Language="C#" Value="public System.Xaml.Schema.XamlTypeInvoker Invoker { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xaml.Schema.XamlTypeInvoker Invoker" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.Invoker" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Invoker As XamlTypeInvoker" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xaml::Schema::XamlTypeInvoker ^ Invoker { System::Xaml::Schema::XamlTypeInvoker ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Invoker : System.Xaml.Schema.XamlTypeInvoker" Usage="System.Xaml.XamlType.Invoker" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.Schema.XamlTypeInvoker</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取与此 <see cref="T:System.Xaml.Schema.XamlTypeInvoker" /> 关联的 <see cref="T:System.Xaml.XamlType" /> 实现。</summary>
        <value>与此 <see cref="T:System.Xaml.Schema.XamlTypeInvoker" /> 关联的 <see cref="T:System.Xaml.XamlType" /> 实现。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果不使用默认的内部 CLR 反射技术 <xref:System.Xaml.XamlType> ，则调用 <xref:System.Xaml.XamlType.Invoker%2A> 可以调用 <xref:System.Xaml.XamlType.LookupInvoker%2A> 或该方法的特定重写。 有关返回值和其他行为的详细信息，请参阅有关 <xref:System.Xaml.XamlType.LookupInvoker%2A> 此类型的文档。  
  
 如果 <xref:System.Xaml.XamlType.LookupInvoker%2A> 重写返回 `null` ，或如果 `null` 由于缺少此而导致默认实现返回 <xref:System.Xaml.XamlType.UnderlyingType%2A> <xref:System.Xaml.XamlType> ，则 <xref:System.Xaml.XamlType.Invoker%2A> 返回 <xref:System.Xaml.Schema.XamlTypeInvoker.UnknownInvoker%2A?displayProperty=nameWithType> 。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsAmbient">
      <MemberSignature Language="C#" Value="public bool IsAmbient { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAmbient" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.IsAmbient" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAmbient As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAmbient { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAmbient : bool" Usage="System.Xaml.XamlType.IsAmbient" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示此 <see cref="T:System.Xaml.XamlType" /> 按照 XAML 定义是否表示环境类型。</summary>
        <value>如果此 <see cref="T:System.Xaml.XamlType" /> 表示环境类型，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果不使用默认的内部 CLR 反射技术 <xref:System.Xaml.XamlType> ，则对此属性的调用可以调用 <xref:System.Xaml.XamlType.LookupIsAmbient%2A> 派生类的重写 <xref:System.Xaml.XamlType> 。 有关返回值和其他行为的详细信息，请参阅有关 <xref:System.Xaml.XamlType.LookupIsAmbient%2A> 此类型的文档。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsArray">
      <MemberSignature Language="C#" Value="public bool IsArray { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsArray" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.IsArray" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsArray As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsArray { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsArray : bool" Usage="System.Xaml.XamlType.IsArray" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示此 <see cref="T:System.Xaml.XamlType" /> 是否表示数组。</summary>
        <value>如果此 <see cref="T:System.Xaml.XamlType" /> 表示数组，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果不使用默认的内部 CLR 反射技术 <xref:System.Xaml.XamlType> ，则对此属性的调用可以调用 <xref:System.Xaml.XamlType.LookupCollectionKind%2A> 派生类的重写 <xref:System.Xaml.XamlType> 。 有关返回值和其他行为的详细信息，请参阅有关 <xref:System.Xaml.XamlType.LookupCollectionKind%2A> 此类型的文档。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsCollection">
      <MemberSignature Language="C#" Value="public bool IsCollection { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsCollection" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.IsCollection" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsCollection As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsCollection { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsCollection : bool" Usage="System.Xaml.XamlType.IsCollection" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示此 <see cref="T:System.Xaml.XamlType" /> 是否表示集合。</summary>
        <value>如果此 <see cref="T:System.Xaml.XamlType" /> 表示集合，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果不使用默认的内部 CLR 反射技术 <xref:System.Xaml.XamlType> ，则对此属性的调用可以调用 <xref:System.Xaml.XamlType.LookupCollectionKind%2A> 派生类的重写 <xref:System.Xaml.XamlType> 。 有关返回值和其他行为的详细信息，请参阅有关 <xref:System.Xaml.XamlType.LookupCollectionKind%2A> 此类型的文档。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsConstructible">
      <MemberSignature Language="C#" Value="public bool IsConstructible { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsConstructible" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.IsConstructible" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsConstructible As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsConstructible { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsConstructible : bool" Usage="System.Xaml.XamlType.IsConstructible" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示此 <see cref="T:System.Xaml.XamlType" /> 按照 XAML 定义是否表示可构造类型。</summary>
        <value>如果此 <see cref="T:System.Xaml.XamlType" /> 表示可构造类型，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此属性与 `[is default constructible]` [ms-chap] 规范中的信息项对齐。  
  
 如果不使用默认的内部 CLR 反射技术 <xref:System.Xaml.XamlType> ，则对此属性的调用可以调用 <xref:System.Xaml.XamlType.LookupIsConstructible%2A> 派生类的重写 <xref:System.Xaml.XamlType> 。 有关返回值和其他行为的详细信息，请参阅有关 <xref:System.Xaml.XamlType.LookupIsConstructible%2A> 此类型的文档。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Xaml.XamlType.ConstructionRequiresArguments" />
      </Docs>
    </Member>
    <Member MemberName="IsDictionary">
      <MemberSignature Language="C#" Value="public bool IsDictionary { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsDictionary" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.IsDictionary" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsDictionary As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsDictionary { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsDictionary : bool" Usage="System.Xaml.XamlType.IsDictionary" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示此 <see cref="T:System.Xaml.XamlType" /> 按照 XAML 定义是否表示字典。</summary>
        <value>如果此 <see cref="T:System.Xaml.XamlType" /> 表示字典，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此属性与 `[is dictionary]` [ms-chap] 规范中的信息项对齐。  
  
 如果不使用默认的内部 CLR 反射技术 <xref:System.Xaml.XamlType> ，则对此属性的调用可以调用 <xref:System.Xaml.XamlType.LookupCollectionKind%2A> 派生类的重写 <xref:System.Xaml.XamlType> 。 有关返回值和其他行为的详细信息，请参阅有关 <xref:System.Xaml.XamlType.LookupCollectionKind%2A> 此类型的文档。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsGeneric">
      <MemberSignature Language="C#" Value="public bool IsGeneric { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGeneric" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.IsGeneric" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsGeneric As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsGeneric { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsGeneric : bool" Usage="System.Xaml.XamlType.IsGeneric" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示此 <see cref="T:System.Xaml.XamlType" /> 是否表示泛型类型。</summary>
        <value>如果此 <see cref="T:System.Xaml.XamlType" /> 表示泛型类型，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此属性是一个帮助器属性，用于检查的 null 值 <xref:System.Xaml.XamlType.TypeArguments%2A> 。 没有 `Lookup` 与相关的特定方法 <xref:System.Xaml.XamlType.IsGeneric%2A> 。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsMarkupExtension">
      <MemberSignature Language="C#" Value="public bool IsMarkupExtension { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsMarkupExtension" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.IsMarkupExtension" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsMarkupExtension As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsMarkupExtension { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsMarkupExtension : bool" Usage="System.Xaml.XamlType.IsMarkupExtension" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示此 <see cref="T:System.Xaml.XamlType" /> 是否表示标记扩展。</summary>
        <value>如果此 <see cref="T:System.Xaml.XamlType" /> 表示标记扩展，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在 XAML 规范术语中，此类型必须可分配给，以便为 `x:MarkupExtension` 返回 `true` <xref:System.Xaml.XamlType.IsMarkupExtension%2A> 。  
  
 如果不使用默认的内部 CLR 反射技术 <xref:System.Xaml.XamlType> ，则对此属性的调用可以调用 <xref:System.Xaml.XamlType.LookupIsMarkupExtension%2A> 派生类的重写 <xref:System.Xaml.XamlType> 。 有关返回值和其他行为的详细信息，请参阅有关 <xref:System.Xaml.XamlType.LookupIsMarkupExtension%2A> 此类型的文档。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsNameScope">
      <MemberSignature Language="C#" Value="public bool IsNameScope { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNameScope" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.IsNameScope" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNameScope As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNameScope { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNameScope : bool" Usage="System.Xaml.XamlType.IsNameScope" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示此 <see cref="T:System.Xaml.XamlType" /> 按照 XAML 定义是否表示 XAML 名称范围。</summary>
        <value>如果此 <see cref="T:System.Xaml.XamlType" /> 表示 XAML 名称范围，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 XAML 命名范围强制执行用于的属性或属性的名称的唯一性 `x:Name`  /  `[name property]` 。 如果 <xref:System.Xaml.XamlType.IsNameScope%2A> 为 `true` ，则应存在一些强制唯一性的机制，并且应从拥有 XAML 名称范围的此类型的角度进行评估。 然后，XAML 名称范围将扩展到该类型的内容，直到遇到另一个 XAML 名称范围类型。  
  
 此属性与 `[is name scope]` [ms-chap] 规范中的信息项对齐。  
  
 如果不使用默认的内部 CLR 反射技术 <xref:System.Xaml.XamlType> ，则对此属性的调用可以调用 <xref:System.Xaml.XamlType.LookupIsNameScope%2A> 派生类的重写 <xref:System.Xaml.XamlType> 。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsNameValid">
      <MemberSignature Language="C#" Value="public bool IsNameValid { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNameValid" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.IsNameValid" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNameValid As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNameValid { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNameValid : bool" Usage="System.Xaml.XamlType.IsNameValid" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示是否使用有效的 <see langword="xamlName" /> 字符串作为其 <see cref="T:System.Xaml.XamlType" /> 来初始化此 <see cref="P:System.Xaml.XamlType.Name" />。</summary>
        <value>如果使用有效的 <see langword="true" /> 字符串来初始化此 <see cref="T:System.Xaml.XamlType" />，则为 <see langword="xamlName" />；否则为 <see langword="false" />。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsNullable">
      <MemberSignature Language="C#" Value="public bool IsNullable { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNullable" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.IsNullable" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNullable As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNullable { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNullable : bool" Usage="System.Xaml.XamlType.IsNullable" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示此 <see cref="T:System.Xaml.XamlType" /> 按照 XAML 定义是否表示可以为 null 的类型。</summary>
        <value>如果此 <see cref="T:System.Xaml.XamlType" /> 表示可以为 null 的类型，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此属性与 `[is nullable]` [ms-chap] 规范中的信息项对齐。  
  
 如果不使用默认的内部 CLR 反射技术 <xref:System.Xaml.XamlType> ，则对此属性的调用可以调用 <xref:System.Xaml.XamlType.LookupIsNullable%2A> 派生类的重写 <xref:System.Xaml.XamlType> 。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsPublic">
      <MemberSignature Language="C#" Value="public bool IsPublic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsPublic" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.IsPublic" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsPublic As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsPublic { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsPublic : bool" Usage="System.Xaml.XamlType.IsPublic" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示此 <see cref="T:System.Xaml.XamlType" /> 是否表示相关类型系统中的公共类型。</summary>
        <value>如果此 <see cref="T:System.Xaml.XamlType" /> 表示公共类型，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果不使用默认的内部 CLR 反射技术 <xref:System.Xaml.XamlType> ，则对此属性的调用可以调用 <xref:System.Xaml.XamlType.LookupIsPublic%2A> 派生类的重写 <xref:System.Xaml.XamlType> 。  
  
> [!IMPORTANT]
>  <xref:System.Xaml.XamlType.LookupIsPublic%2A> 是虚拟的，因此可以重写。 重写可能 (出于恶意目的，或者) 更改有关 XAML 类型的报告访问信息，使其不再以预期方式与类型系统和其基础 CLR 类型的访问信息对齐。 对于分配操作和访问的任何安全关键检查，请改用基础 CLR 类型。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsUnknown">
      <MemberSignature Language="C#" Value="public bool IsUnknown { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsUnknown" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.IsUnknown" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsUnknown As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsUnknown { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsUnknown : bool" Usage="System.Xaml.XamlType.IsUnknown" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示此 <see cref="T:System.Xaml.XamlType" /> 是否表示无法在基础类型系统中解析的类型。</summary>
        <value>如果此 <see cref="T:System.Xaml.XamlType" /> 表示不可解析的类型，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果不使用默认的内部 CLR 反射技术 <xref:System.Xaml.XamlType> ，则对此属性的调用可以调用 <xref:System.Xaml.XamlType.LookupIsUnknown%2A> 派生类的重写 <xref:System.Xaml.XamlType> 。  
  
 对于涉及的加载路径 <xref:System.Xaml.XamlObjectWriter> ， <xref:System.Xaml.XamlType> 具有 `true` 的 <xref:System.Xaml.XamlType.IsUnknown%2A> 不能写入对象图。 在的默认实现下 <xref:System.Xaml> ， <xref:System.Xaml.XamlObjectWriter.WriteStartObject%2A?displayProperty=nameWithType> 如果的相关报表，调用将引发 <xref:System.Xaml.XamlObjectWriterException> <xref:System.Xaml.XamlType> `true` <xref:System.Xaml.XamlType.IsUnknown%2A> 。 不应传递 <xref:System.Xaml.XamlType> 与相同的， <xref:System.Xaml.XamlType.IsUnknown%2A> `true` 除非您已准备好处理中的异常 <xref:System.Xaml.XamlObjectWriter> ，或者，您还可以通过其他方式在 <xref:System.Xaml.XamlObjectWriter> 编写对象图之前调整行为或 XAML 节点流。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsUsableDuringInitialization">
      <MemberSignature Language="C#" Value="public bool IsUsableDuringInitialization { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsUsableDuringInitialization" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.IsUsableDuringInitialization" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsUsableDuringInitialization As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsUsableDuringInitialization { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsUsableDuringInitialization : bool" Usage="System.Xaml.XamlType.IsUsableDuringInitialization" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示在 XAML 初始化过程中是否自上而下生成此 <see cref="T:System.Xaml.XamlType" />。</summary>
        <value>如果在 XAML 初始化过程中自上而下生成此 <see cref="T:System.Xaml.XamlType" />，则为 <see langword="true" />；否则为 <see langword="false" />。 默认值为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 从上到下是在创建对象图时，与 XAML 处理器行为接近的比喻。 当自上而下生成时，会实例化一个类型，并将其附加到父，然后设置其属性。 自上而下的构造避免多次调用属性更改的处理程序。 此类处理 ripples 对象图，因此，消除了多个处理程序调用，并为启动对象图提供了性能优化。  
  
 如果不使用默认的内部 CLR 反射技术 <xref:System.Xaml.XamlType> ，则对此属性的调用可以调用 <xref:System.Xaml.XamlType.LookupUsableDuringInitialization%2A> 派生类的重写 <xref:System.Xaml.XamlType> 。 有关返回值和其他行为的详细信息，请参阅有关 <xref:System.Xaml.XamlType.LookupUsableDuringInitialization%2A> 此类型的文档。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Markup.XamlReader.LoadAsync(System.IO.Stream)" />
        <altmember cref="P:System.Windows.FrameworkElement.IsInitialized" />
      </Docs>
    </Member>
    <Member MemberName="IsWhitespaceSignificantCollection">
      <MemberSignature Language="C#" Value="public bool IsWhitespaceSignificantCollection { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsWhitespaceSignificantCollection" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.IsWhitespaceSignificantCollection" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsWhitespaceSignificantCollection As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsWhitespaceSignificantCollection { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsWhitespaceSignificantCollection : bool" Usage="System.Xaml.XamlType.IsWhitespaceSignificantCollection" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示此 <see cref="T:System.Xaml.XamlType" /> 按照 XML 定义是否表示空白有意义集合。</summary>
        <value>如果此 <see cref="T:System.Xaml.XamlType" /> 表示空白有意义集合，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果不使用默认的内部 CLR 反射技术 <xref:System.Xaml.XamlType> ，则对此属性的调用可以调用 <xref:System.Xaml.XamlType.LookupIsWhitespaceSignificantCollection%2A> 派生类的重写 <xref:System.Xaml.XamlType> 。 有关返回值和其他行为的详细信息，请参阅有关 <xref:System.Xaml.XamlType.LookupIsWhitespaceSignificantCollection%2A> 此类型的文档。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsXData">
      <MemberSignature Language="C#" Value="public bool IsXData { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsXData" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.IsXData" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsXData As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsXData { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsXData : bool" Usage="System.Xaml.XamlType.IsXData" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示此 <see cref="T:System.Xaml.XamlType" /> 按照 XAML 定义是否表示 XML <see langword="XDATA" />。</summary>
        <value>如果此 <see cref="T:System.Xaml.XamlType" /> 表示 <see langword="true" />，则为 <see langword="XDATA" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此属性与 `[is xdata]` [ms-chap] 规范中的信息项对齐。  
  
 如果不使用默认的内部 CLR 反射技术 <xref:System.Xaml.XamlType> ，则对此属性的调用可以调用 <xref:System.Xaml.XamlType.LookupIsXData%2A> 派生类的重写 <xref:System.Xaml.XamlType> 。 有关返回值和其他行为的详细信息，请参阅有关 <xref:System.Xaml.XamlType.LookupIsXData%2A> 此类型的文档。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ItemType">
      <MemberSignature Language="C#" Value="public System.Xaml.XamlType ItemType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xaml.XamlType ItemType" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.ItemType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ItemType As XamlType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xaml::XamlType ^ ItemType { System::Xaml::XamlType ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ItemType : System.Xaml.XamlType" Usage="System.Xaml.XamlType.ItemType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值为此 <see cref="T:System.Xaml.XamlType" /> 的 <see langword="Items" /> 属性提供类型信息。</summary>
        <value>集合中项的类型的 <see cref="T:System.Xaml.XamlType" /> 对象；如果此 <see cref="T:System.Xaml.XamlType" /> 不表示集合，则为 <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 仅当此属性 <xref:System.Xaml.XamlType> 表示)  (集合时，此属性才适用 <xref:System.Xaml.XamlType.IsCollection%2A> `true` 。 `Items`属性是包含该类型的集合或数组中的项的任何属性。  
  
 如果不使用默认的内部 CLR 反射技术 <xref:System.Xaml.XamlType> ，则对此属性的调用可以调用 <xref:System.Xaml.XamlType.LookupItemType%2A> 派生类的重写 <xref:System.Xaml.XamlType> 。 有关返回值和其他行为的详细信息，请参阅有关 <xref:System.Xaml.XamlType.LookupItemType%2A> 此类型的文档。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="KeyType">
      <MemberSignature Language="C#" Value="public System.Xaml.XamlType KeyType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xaml.XamlType KeyType" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.KeyType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property KeyType As XamlType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xaml::XamlType ^ KeyType { System::Xaml::XamlType ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.KeyType : System.Xaml.XamlType" Usage="System.Xaml.XamlType.KeyType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>如果 <see cref="T:System.Xaml.XamlType" /> 表示字典，则获取一个值，该值为此 <see cref="T:System.Xaml.XamlType" /> 的键属性提供类型信息。</summary>
        <value>字典用法键的类型的 <see cref="T:System.Xaml.XamlType" /> 对象；否则，如果此 <see cref="T:System.Xaml.XamlType" /> 不表示字典，则为 <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 仅当此属性 <xref:System.Xaml.XamlType> 表示)  (字典时，此属性才适用 <xref:System.Xaml.XamlType.IsDictionary%2A> `true` 。  
  
 如果不使用默认的内部 CLR 反射技术 <xref:System.Xaml.XamlType> ，则对此属性的调用可以调用 <xref:System.Xaml.XamlType.LookupKeyType%2A> 派生类的重写 <xref:System.Xaml.XamlType> 。 有关返回值和其他行为的详细信息，请参阅有关 <xref:System.Xaml.XamlType.LookupKeyType%2A> 此类型的文档。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupAliasedProperty">
      <MemberSignature Language="C#" Value="protected virtual System.Xaml.XamlMember LookupAliasedProperty (System.Xaml.XamlDirective directive);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Xaml.XamlMember LookupAliasedProperty(class System.Xaml.XamlDirective directive) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupAliasedProperty(System.Xaml.XamlDirective)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupAliasedProperty (directive As XamlDirective) As XamlMember" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Xaml::XamlMember ^ LookupAliasedProperty(System::Xaml::XamlDirective ^ directive);" />
      <MemberSignature Language="F#" Value="abstract member LookupAliasedProperty : System.Xaml.XamlDirective -&gt; System.Xaml.XamlMember&#xA;override this.LookupAliasedProperty : System.Xaml.XamlDirective -&gt; System.Xaml.XamlMember" Usage="xamlType.LookupAliasedProperty directive" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlMember</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="directive" Type="System.Xaml.XamlDirective" />
      </Parameters>
      <Docs>
        <param name="directive">要为其查找别名成员的指令。</param>
        <summary>返回由此 <see cref="T:System.Xaml.XamlType" /> 将其别名设置为 XAML 指令的 XAML 成员。</summary>
        <returns>如果可找到，则为别名成员，否则为 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当调用方从获取值时，可以调用此方法 <xref:System.Xaml.XamlType.GetAliasedProperty%2A> 。  
  
 默认实现可返回以下 XAML 指令的结果：、、 `Key` 、 `Name` `Uid` 和 `xml:lang` 。 这些属性的值取决于基础反射， `null` 如果未找到别名属性，可能仍返回。  
  
 如果您不依赖于默认的内部 CLR 反射，并使用元数据或其他技术来报告 XAML 类型系统信息或类型的架构信息，请重写此方法。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xaml.XamlDirective" />
        <altmember cref="T:System.Xaml.XamlLanguage" />
      </Docs>
    </Member>
    <Member MemberName="LookupAllAttachableMembers">
      <MemberSignature Language="C#" Value="protected virtual System.Collections.Generic.IEnumerable&lt;System.Xaml.XamlMember&gt; LookupAllAttachableMembers ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class System.Xaml.XamlMember&gt; LookupAllAttachableMembers() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupAllAttachableMembers" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupAllAttachableMembers () As IEnumerable(Of XamlMember)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Collections::Generic::IEnumerable&lt;System::Xaml::XamlMember ^&gt; ^ LookupAllAttachableMembers();" />
      <MemberSignature Language="F#" Value="abstract member LookupAllAttachableMembers : unit -&gt; seq&lt;System.Xaml.XamlMember&gt;&#xA;override this.LookupAllAttachableMembers : unit -&gt; seq&lt;System.Xaml.XamlMember&gt;" Usage="xamlType.LookupAllAttachableMembers " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Xaml.XamlMember&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回一个可枚举集合，该集合包含由此 <see cref="T:System.Xaml.XamlType" /> 公开的所有可附加的属性。</summary>
        <returns>包含零个或多个 <see cref="T:System.Xaml.XamlMember" /> 值的可枚举集合；否则为 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当调用方从获取值时，可以调用此方法 <xref:System.Xaml.XamlType.GetAllAttachableMembers%2A> 。  
  
 尽管 <xref:System.Xaml.XamlType.GetAllAttachableMembers%2A> 返回泛型集合，但此 `Lookup` 方法返回泛型可枚举集。  
  
 默认实现使用内部 CLR 反射。 如果 <xref:System.Xaml.XamlType.UnderlyingType%2A> 为 `null` ，则默认实现可以使用 <xref:System.Xaml.XamlType.BaseType%2A> （如果可用）。 此行为以 <xref:System.Xaml.XamlType.LookupAllAttachableMembers%2A> 递归方式调用以尝试查找有效的基类型，并 `null` 在不存在有效的基类型时返回。  
  
 如果不依赖于默认的内部 CLR 反射，并使用元数据或其他技术报告类型的 XAML 类型系统信息或架构信息，请重写此方法。 应为不能确定信息的情况保留空返回，因为缺乏类型系统或反射支持。 如果类型有效且反射或其他技术可用，但类型没有可附加成员，则应改为返回空 <xref:System.Collections.Generic.IEnumerable%601> 集。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupAllMembers">
      <MemberSignature Language="C#" Value="protected virtual System.Collections.Generic.IEnumerable&lt;System.Xaml.XamlMember&gt; LookupAllMembers ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class System.Xaml.XamlMember&gt; LookupAllMembers() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupAllMembers" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupAllMembers () As IEnumerable(Of XamlMember)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Collections::Generic::IEnumerable&lt;System::Xaml::XamlMember ^&gt; ^ LookupAllMembers();" />
      <MemberSignature Language="F#" Value="abstract member LookupAllMembers : unit -&gt; seq&lt;System.Xaml.XamlMember&gt;&#xA;override this.LookupAllMembers : unit -&gt; seq&lt;System.Xaml.XamlMember&gt;" Usage="xamlType.LookupAllMembers " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Xaml.XamlMember&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回一个可枚举集合，该集合包含由此 <see cref="T:System.Xaml.XamlType" /> 公开的所有成员。</summary>
        <returns>包含零个或多个 <see cref="T:System.Xaml.XamlMember" /> 值的可枚举集合。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当调用方从获取值时，可以调用此方法 <xref:System.Xaml.XamlType.GetAllMembers%2A> 。  
  
 尽管 <xref:System.Xaml.XamlType.GetAllMembers%2A> 返回泛型集合，但此 `Lookup` 方法返回泛型可枚举集。  
  
 默认实现使用内部 CLR 反射。 对于 <xref:System.Xaml.XamlType.UnderlyingType%2A> 为 `null` ，默认实现可以使用 <xref:System.Xaml.XamlType.BaseType%2A> （如果可用）。 此行为以 <xref:System.Xaml.XamlType.LookupAllMembers%2A> 递归方式调用以尝试查找有效的基类型， `null` 如果不存在有效的基类型，则返回。  
  
 如果不依赖于默认的内部 CLR 反射，并使用元数据或其他技术报告类型的 XAML 类型系统信息或架构信息，请重写此方法。 应为不能确定信息的情况保留空返回，因为缺乏类型系统或反射支持。 如果类型有效，则可以使用反射或其他技术;如果某个类型不具有成员，则应返回空 <xref:System.Collections.Generic.IEnumerable%601> 集。  
  
 和的返回 <xref:System.Xaml.XamlType.LookupAllMembers%2A> 值 <xref:System.Xaml.XamlType.LookupAllAttachableMembers%2A> 应互相排斥。 如果有一种情况，即后备类型系统属性可以支持标准实例使用情况以及可附加的用法，则应将该成员报告为两个不同的 <xref:System.Xaml.XamlMember> 值，其中一个值出现在可附加列表中，另一个值出现在标准成员列表中。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupAllowedContentTypes">
      <MemberSignature Language="C#" Value="protected virtual System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt; LookupAllowedContentTypes ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Collections.Generic.IList`1&lt;class System.Xaml.XamlType&gt; LookupAllowedContentTypes() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupAllowedContentTypes" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupAllowedContentTypes () As IList(Of XamlType)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Collections::Generic::IList&lt;System::Xaml::XamlType ^&gt; ^ LookupAllowedContentTypes();" />
      <MemberSignature Language="F#" Value="abstract member LookupAllowedContentTypes : unit -&gt; System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt;&#xA;override this.LookupAllowedContentTypes : unit -&gt; System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt;" Usage="xamlType.LookupAllowedContentTypes " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回类型的列表，这些类型可用作此 <see cref="P:System.Xaml.XamlType.ContentProperty" /> 的 <see cref="T:System.Xaml.XamlType" /> 值。</summary>
        <returns>可能的内容类型的列表。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当调用方从获取值时，可以调用此方法 <xref:System.Xaml.XamlType.AllowedContentTypes%2A> 。  
  
 针对 <xref:System.Xaml.XamlType.CanAssignTo%2A> 特定内容类型计算为的类型不会被视为用于的多个类型 <xref:System.Xaml.XamlType.AllowedContentTypes%2A> 。  
  
 默认实现可以使用 <xref:System.Xaml.XamlType> (<xref:System.Xaml.XamlType.ContentWrappers%2A> 、或) 的其他属性 <xref:System.Xaml.XamlType.ContentProperty%2A> <xref:System.Xaml.XamlType.ItemType%2A> 来获取结果。 `Lookup`在此确定中，还可以调用前面属性列表的重写。  
  
 如果不依赖于默认的内部 CLR 反射，并使用元数据或其他技术报告类型的 XAML 类型系统信息或架构信息，请重写此方法。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupAttachableMember">
      <MemberSignature Language="C#" Value="protected virtual System.Xaml.XamlMember LookupAttachableMember (string name);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Xaml.XamlMember LookupAttachableMember(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupAttachableMember(System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupAttachableMember (name As String) As XamlMember" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Xaml::XamlMember ^ LookupAttachableMember(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member LookupAttachableMember : string -&gt; System.Xaml.XamlMember&#xA;override this.LookupAttachableMember : string -&gt; System.Xaml.XamlMember" Usage="xamlType.LookupAttachableMember name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlMember</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">要获取的可附加成员的名称，形式为 <c>ownerTypeName.MemberName</c>。</param>
        <summary>为 <see cref="T:System.Xaml.XamlType" /> 中特定的已命名可附加成员返回 <see cref="T:System.Xaml.XamlMember" />。</summary>
        <returns>请求的可附加成员的 <see cref="T:System.Xaml.XamlMember" /> 对象；如果不存在该名称的可附加成员，则为 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当调用方从获取值时，可以调用此方法 <xref:System.Xaml.XamlType.GetAttachableMember%2A> 。  
  
 默认实现使用内部 CLR 反射。 如果 <xref:System.Xaml.XamlType.UnderlyingType%2A> 为 `null` ，则默认实现可以使用 <xref:System.Xaml.XamlType.BaseType%2A> （如果可用）。 此行为以 <xref:System.Xaml.XamlType.LookupAttachableMember%2A> 递归方式调用以尝试查找有效的基类型，并 `null` 在不存在有效的基类型时返回。  
  
 如果不依赖于默认的内部 CLR 反射，并使用元数据或其他技术报告类型的 XAML 类型系统信息或架构信息，请重写此方法。  
  
> [!IMPORTANT]
>  <xref:System.Xaml.XamlType.LookupAttachableMember%2A> 是虚拟的，因此可以重写。 重写有可能 (出于恶意目的，或者) 更改 XAML 类型的已报告成员，使其不再按预期方式与 <xref:System.ComponentModel.TypeDescriptor> `Get*` 有关基础 CLR 类型的信息对齐。 对于成员报告的任何安全关键检查，请改用基础 CLR 类型。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupBaseType">
      <MemberSignature Language="C#" Value="protected virtual System.Xaml.XamlType LookupBaseType ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Xaml.XamlType LookupBaseType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupBaseType" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupBaseType () As XamlType" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Xaml::XamlType ^ LookupBaseType();" />
      <MemberSignature Language="F#" Value="abstract member LookupBaseType : unit -&gt; System.Xaml.XamlType&#xA;override this.LookupBaseType : unit -&gt; System.Xaml.XamlType" Usage="xamlType.LookupBaseType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlType</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回此 XAML 类型的直接基类型的 <see cref="T:System.Xaml.XamlType" />。 将基于此 <see cref="T:System.Xaml.XamlType" /> 的基础类型和架构上下文来确定此值。</summary>
        <returns>此 XAML 类型的直接基类型的 <see cref="T:System.Xaml.XamlType" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当调用方从获取值时，可以调用此方法 <xref:System.Xaml.XamlType.BaseType%2A> 。  
  
 <xref:System.Object>如果为，则默认实现可能返回表示的内部常数 <xref:System.Xaml.XamlType.UnderlyingType%2A> `null` 。  
  
 如果不依赖于默认的内部 CLR 反射，并使用元数据或其他技术报告类型的 XAML 类型系统信息或架构信息，请重写此方法。  
  
> [!IMPORTANT]
>  <xref:System.Xaml.XamlType.LookupBaseType%2A> 是虚拟的，因此可以重写。 重写有可能 (出于恶意目的，或者) 更改有关 XAML 类型的报告类型信息，使其不再以预期方式与其基础 CLR 类型的类型系统信息对齐。 对于分配操作和访问的任何安全关键检查，请改用基础 CLR 类型。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupCollectionKind">
      <MemberSignature Language="C#" Value="protected virtual System.Xaml.Schema.XamlCollectionKind LookupCollectionKind ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance valuetype System.Xaml.Schema.XamlCollectionKind LookupCollectionKind() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupCollectionKind" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupCollectionKind () As XamlCollectionKind" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Xaml::Schema::XamlCollectionKind LookupCollectionKind();" />
      <MemberSignature Language="F#" Value="abstract member LookupCollectionKind : unit -&gt; System.Xaml.Schema.XamlCollectionKind&#xA;override this.LookupCollectionKind : unit -&gt; System.Xaml.Schema.XamlCollectionKind" Usage="xamlType.LookupCollectionKind " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.Schema.XamlCollectionKind</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回 <see cref="T:System.Xaml.Schema.XamlCollectionKind" /> 枚举的一个值，该枚举声明此 <see cref="T:System.Xaml.XamlType" /> 使用哪种特定集合类型。</summary>
        <returns><see cref="T:System.Xaml.Schema.XamlCollectionKind" /> 枚举的一个值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法由内部私有方法调用， (`CollectionKind` `GetCollectionKind` 在) 上不存在公共或 API <xref:System.Xaml.XamlType> 。  
  
 默认实现使用内部 CLR 反射。 对于 <xref:System.Xaml.XamlType.UnderlyingType%2A> 为 `null` ，默认实现可以使用 <xref:System.Xaml.XamlType.BaseType%2A> （如果可用）。 此行为间接调用 <xref:System.Xaml.XamlType.LookupCollectionKind%2A> 以尝试查找有效的基类型; <xref:System.Xaml.Schema.XamlCollectionKind.None?displayProperty=nameWithType> 如果不存在有效的基类型，则返回。 通常，默认实现尝试 `Add` 通过反射查找基础类型的方法。 如果找到，则 <xref:System.Reflection.MethodInfo> 该 `Add` 方法的是足够的信息来确定 <xref:System.Xaml.Schema.XamlCollectionKind> 应返回的值。 否则，它将返回 <xref:System.Xaml.Schema.XamlCollectionKind.None?displayProperty=nameWithType>。  
  
 如果不依赖于默认的内部 CLR 反射，并使用元数据或其他技术报告类型的 XAML 类型系统信息或架构信息，请重写此方法。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupConstructionRequiresArguments">
      <MemberSignature Language="C#" Value="protected virtual bool LookupConstructionRequiresArguments ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool LookupConstructionRequiresArguments() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupConstructionRequiresArguments" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupConstructionRequiresArguments () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool LookupConstructionRequiresArguments();" />
      <MemberSignature Language="F#" Value="abstract member LookupConstructionRequiresArguments : unit -&gt; bool&#xA;override this.LookupConstructionRequiresArguments : unit -&gt; bool" Usage="xamlType.LookupConstructionRequiresArguments " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回一个值，该值指示此 <see cref="T:System.Xaml.XamlType" /> 是否必须具有参数（通过 <see langword="x:TypeArguments" /> 实现的泛型约束、初始化文本或其他 XAML 技术）才能构造有效的类型实例。</summary>
        <returns>如果需要某个参数值才能构造实例，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当调用方从获取值时，可以调用此方法 <xref:System.Xaml.XamlType.ConstructionRequiresArguments%2A> 。  
  
 默认实现 `false` 为 CLR 类型系统中被视为值类型的类型返回。 对于除值类型以外的值，CLR 反射 <xref:System.Reflection.ConstructorInfo> 用于确定是否存在无参数的构造函数。  
  
 如果不依赖于默认的内部 CLR 反射，并使用元数据或其他技术报告类型的 XAML 类型系统信息或架构信息，请重写此方法。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupContentProperty">
      <MemberSignature Language="C#" Value="protected virtual System.Xaml.XamlMember LookupContentProperty ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Xaml.XamlMember LookupContentProperty() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupContentProperty" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupContentProperty () As XamlMember" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Xaml::XamlMember ^ LookupContentProperty();" />
      <MemberSignature Language="F#" Value="abstract member LookupContentProperty : unit -&gt; System.Xaml.XamlMember&#xA;override this.LookupContentProperty : unit -&gt; System.Xaml.XamlMember" Usage="xamlType.LookupContentProperty " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlMember</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回此 <see cref="T:System.Xaml.XamlMember" /> 的内容属性的 <see cref="T:System.Xaml.XamlType" /> 信息。</summary>
        <returns>此 <see cref="T:System.Xaml.XamlMember" /> 的内容属性的 <see cref="T:System.Xaml.XamlType" /> 信息。 可为 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当调用方从获取值时，可以调用此方法 <xref:System.Xaml.XamlType.ContentProperty%2A> 。  
  
 默认实现检查 <xref:System.Windows.Markup.ContentPropertyAttribute> 类型定义上的。 <xref:System.Xaml.XamlType.BaseType%2A>如果在直接基础类型上找不到属性，它还可以检查特性。 如果这些检查未发现内容类型，则默认实现返回 `null` 。  
  
 如果不依赖于默认的内部 CLR 反射，并使用元数据或其他技术报告类型的 XAML 类型系统信息或架构信息，请重写此方法。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupContentWrappers">
      <MemberSignature Language="C#" Value="protected virtual System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt; LookupContentWrappers ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Collections.Generic.IList`1&lt;class System.Xaml.XamlType&gt; LookupContentWrappers() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupContentWrappers" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupContentWrappers () As IList(Of XamlType)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Collections::Generic::IList&lt;System::Xaml::XamlType ^&gt; ^ LookupContentWrappers();" />
      <MemberSignature Language="F#" Value="abstract member LookupContentWrappers : unit -&gt; System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt;&#xA;override this.LookupContentWrappers : unit -&gt; System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt;" Usage="xamlType.LookupContentWrappers " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>获取 <see cref="T:System.Xaml.XamlType" /> 值的列表，这些值表示此 <see cref="T:System.Xaml.XamlType" /> 的内容包装。</summary>
        <returns><see cref="T:System.Xaml.XamlType" /> 值的列表，这些值表示此 <see cref="T:System.Xaml.XamlType" /> 的内容包装。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当集合中使用的类型与类型系统不连续时，内容包装是一个表示内容集合类型的类。 内容包装的集合项的类型应在某种程度上受到限制， <xref:System.Object> 或与非特定对象等效。 但是，此限制仅由使用该类型的属性的设计或用途而非类型系统强制实施。 类型上可以存在多个内容包装。  
  
 有关 WPF XAML 实现中的示例类和方案，请参阅 <xref:System.Windows.Documents.InlineCollection> 。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupCustomAttributeProvider">
      <MemberSignature Language="C#" Value="protected virtual System.Reflection.ICustomAttributeProvider LookupCustomAttributeProvider ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.ICustomAttributeProvider LookupCustomAttributeProvider() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupCustomAttributeProvider" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupCustomAttributeProvider () As ICustomAttributeProvider" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Reflection::ICustomAttributeProvider ^ LookupCustomAttributeProvider();" />
      <MemberSignature Language="F#" Value="abstract member LookupCustomAttributeProvider : unit -&gt; System.Reflection.ICustomAttributeProvider&#xA;override this.LookupCustomAttributeProvider : unit -&gt; System.Reflection.ICustomAttributeProvider" Usage="xamlType.LookupCustomAttributeProvider " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.ICustomAttributeProvider</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>在派生类中实现时，返回 <see cref="T:System.Reflection.ICustomAttributeProvider" /> 实现。</summary>
        <returns><see cref="T:System.Reflection.ICustomAttributeProvider" /> 实现。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 重写此方法以使用替代方法获取内部反射，以获取 CLR 特性值。 在没有重写的情况下，内部反射器使用典型的 CLR 反射逻辑。  
  
 默认实现返回 `null`。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupDeferringLoader">
      <MemberSignature Language="C#" Value="protected virtual System.Xaml.Schema.XamlValueConverter&lt;System.Xaml.XamlDeferringLoader&gt; LookupDeferringLoader ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Xaml.Schema.XamlValueConverter`1&lt;class System.Xaml.XamlDeferringLoader&gt; LookupDeferringLoader() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupDeferringLoader" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupDeferringLoader () As XamlValueConverter(Of XamlDeferringLoader)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Xaml::Schema::XamlValueConverter&lt;System::Xaml::XamlDeferringLoader ^&gt; ^ LookupDeferringLoader();" />
      <MemberSignature Language="F#" Value="abstract member LookupDeferringLoader : unit -&gt; System.Xaml.Schema.XamlValueConverter&lt;System.Xaml.XamlDeferringLoader&gt;&#xA;override this.LookupDeferringLoader : unit -&gt; System.Xaml.Schema.XamlValueConverter&lt;System.Xaml.XamlDeferringLoader&gt;" Usage="xamlType.LookupDeferringLoader " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.Schema.XamlValueConverter&lt;System.Xaml.XamlDeferringLoader&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回一个 <see cref="T:System.Xaml.Schema.XamlValueConverter`1" /> 对象，该对象用于 XAML 声明的对象的延迟加载。</summary>
        <returns>对泛型具有 <see cref="T:System.Xaml.Schema.XamlValueConverter`1" /> 约束的 <see cref="T:System.Xaml.XamlDeferringLoader" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当调用方从获取值时，可以调用此方法 <xref:System.Xaml.XamlType.DeferringLoader%2A> 。 如果要 <xref:System.Xaml.XamlType.DeferringLoader%2A> 返回的值不同于默认内部反射启用的，并且还提供自定义信息，请重写此方法 <xref:System.Xaml.Schema.XamlTypeInvoker> 。  
  
 默认实现通过读取来返回对象 <xref:System.Windows.Markup.XamlDeferLoadAttribute> 。 <xref:System.Xaml.XamlType.BaseType%2A>如果在直接基础类型上找不到属性，它还可以检查特性。 如果某个值不可用，则此方法返回 `null` 。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupInvoker">
      <MemberSignature Language="C#" Value="protected virtual System.Xaml.Schema.XamlTypeInvoker LookupInvoker ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Xaml.Schema.XamlTypeInvoker LookupInvoker() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupInvoker" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupInvoker () As XamlTypeInvoker" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Xaml::Schema::XamlTypeInvoker ^ LookupInvoker();" />
      <MemberSignature Language="F#" Value="abstract member LookupInvoker : unit -&gt; System.Xaml.Schema.XamlTypeInvoker&#xA;override this.LookupInvoker : unit -&gt; System.Xaml.Schema.XamlTypeInvoker" Usage="xamlType.LookupInvoker " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.Schema.XamlTypeInvoker</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回与此 <see cref="T:System.Xaml.Schema.XamlTypeInvoker" /> 关联的 <see cref="T:System.Xaml.XamlType" />。</summary>
        <returns>此 <see cref="T:System.Xaml.Schema.XamlTypeInvoker" /> 的 <see cref="T:System.Xaml.XamlType" /> 信息；否则为 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 可以通过调用来调用此方法 <xref:System.Xaml.XamlType.Invoker%2A> 。  
  
 默认实现不要求 <xref:System.Xaml.XamlType> 使用传递初始的构造函数之一来构造 <xref:System.Xaml.Schema.XamlTypeInvoker> 。 但是， <xref:System.Xaml.XamlType.UnderlyingType%2A> 的值必须为 <xref:System.Xaml.XamlType> ; 否则，默认实现返回 `null` 。  
  
 如果还从创建派生类 <xref:System.Xaml.Schema.XamlTypeInvoker> 并希望返回派生类，请重写此方法。 如果返回 `null` ，则 <xref:System.Xaml.XamlType.Invoker%2A> 返回 <xref:System.Xaml.Schema.XamlTypeInvoker.UnknownInvoker%2A?displayProperty=nameWithType> 到调用方。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupIsAmbient">
      <MemberSignature Language="C#" Value="protected virtual bool LookupIsAmbient ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool LookupIsAmbient() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupIsAmbient" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupIsAmbient () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool LookupIsAmbient();" />
      <MemberSignature Language="F#" Value="abstract member LookupIsAmbient : unit -&gt; bool&#xA;override this.LookupIsAmbient : unit -&gt; bool" Usage="xamlType.LookupIsAmbient " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回一个值，该值指示此 <see cref="T:System.Xaml.XamlType" /> 按照 XAML 定义是否表示环境类型。</summary>
        <returns>如果此 <see cref="T:System.Xaml.XamlType" /> 表示环境类型，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 可以通过调用来调用此方法 <xref:System.Xaml.XamlType.IsAmbient%2A> 。  
  
 默认实现使用上的 CLR 反射 <xref:System.Xaml.XamlType.UnderlyingType%2A> ，并可检查基类型。 此实现将检查 <xref:System.Windows.Markup.AmbientAttribute> 应用于类级别的相关类型定义的，并 `true` 在此情况下返回。 所有其他情况都返回 `false` 。  
  
 如果要 <xref:System.Xaml.XamlType.IsAmbient%2A> 返回的值不同于默认的内部反射，请重写此方法。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupIsConstructible">
      <MemberSignature Language="C#" Value="protected virtual bool LookupIsConstructible ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool LookupIsConstructible() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupIsConstructible" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupIsConstructible () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool LookupIsConstructible();" />
      <MemberSignature Language="F#" Value="abstract member LookupIsConstructible : unit -&gt; bool&#xA;override this.LookupIsConstructible : unit -&gt; bool" Usage="xamlType.LookupIsConstructible " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回一个值，该值指示此 <see cref="T:System.Xaml.XamlType" /> 按照 XAML 定义是否表示可构造类型。</summary>
        <returns>如果此 <see cref="T:System.Xaml.XamlType" /> 表示可构造类型，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 可以通过调用来调用此方法 <xref:System.Xaml.XamlType.IsConstructible%2A> 。  
  
 默认实现使用上的 CLR 反射 <xref:System.Xaml.XamlType.UnderlyingType%2A> 。 类型必须为具体、非嵌套并已关闭。 默认实现检查类型是否为值类型和的返回值 <xref:System.Xaml.XamlType.ConstructionRequiresArguments%2A> 。 对于 null <xref:System.Xaml.XamlType.UnderlyingType%2A> ，此方法返回 `true` 。  
  
 如果要 <xref:System.Xaml.XamlType.IsConstructible%2A> 返回的值不同于默认的内部反射，请重写此方法。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupIsMarkupExtension">
      <MemberSignature Language="C#" Value="protected virtual bool LookupIsMarkupExtension ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool LookupIsMarkupExtension() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupIsMarkupExtension" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupIsMarkupExtension () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool LookupIsMarkupExtension();" />
      <MemberSignature Language="F#" Value="abstract member LookupIsMarkupExtension : unit -&gt; bool&#xA;override this.LookupIsMarkupExtension : unit -&gt; bool" Usage="xamlType.LookupIsMarkupExtension " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回一个值，该值指示此 <see cref="T:System.Xaml.XamlType" /> 是否表示标记扩展。</summary>
        <returns>如果此 <see cref="T:System.Xaml.XamlType" /> 表示标记扩展，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 可以通过调用来调用此方法 <xref:System.Xaml.XamlType.IsMarkupExtension%2A> 。  
  
 默认实现仅包括此调用：  
  
 `return CanAssignTo(XamlLanguage.MarkupExtension);`  
  
 如果要 <xref:System.Xaml.XamlType.IsMarkupExtension%2A> 使用不同的逻辑，请重写此方法。  
  
 在 XAML 规范术语中，此类型必须可分配给，以便为 `x:MarkupExtension` 返回 `true` <xref:System.Xaml.XamlType.IsMarkupExtension%2A> 。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupIsNameScope">
      <MemberSignature Language="C#" Value="protected virtual bool LookupIsNameScope ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool LookupIsNameScope() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupIsNameScope" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupIsNameScope () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool LookupIsNameScope();" />
      <MemberSignature Language="F#" Value="abstract member LookupIsNameScope : unit -&gt; bool&#xA;override this.LookupIsNameScope : unit -&gt; bool" Usage="xamlType.LookupIsNameScope " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回一个值，该值指示此 <see cref="T:System.Xaml.XamlType" /> 按照 XAML 定义是否表示 XAML 名称范围。</summary>
        <returns>如果此 <see cref="T:System.Xaml.XamlType" /> 表示 XAML 名称范围，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 可以通过调用来调用此方法 <xref:System.Xaml.XamlType.IsNameScope%2A> 。  
  
 默认实现 <xref:System.Xaml.XamlType.CanAssignTo%2A> 间接调用类型 <xref:System.Windows.Markup.INameScope> 。 <xref:System.Windows.Markup.INameScope> 是在程序集 WindowsBase.dll 中定义的接口。 Xaml 名称范围标识的这种方法可用于 WPF 和 XAML 的 Windows Workflow Foundation 实现。  
  
 如果要 <xref:System.Xaml.XamlType.IsNameScope%2A> 使用不同的逻辑，请重写此方法。  
  
 XAML 命名范围强制执行用于的属性或属性的名称的唯一性 `x:Name`  /  `[name property]` 。 如果 <xref:System.Xaml.XamlType.IsNameScope%2A> 为 `true` ，则应存在一些强制唯一性的机制，并且应从拥有 XAML 名称范围的此类型的角度进行计算。 然后，XAML 名称范围将扩展到该类型的内容，直到遇到另一个 XAML 名称范围所属类型。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Xaml.XamlObjectWriter.RootNameScope" />
      </Docs>
    </Member>
    <Member MemberName="LookupIsNullable">
      <MemberSignature Language="C#" Value="protected virtual bool LookupIsNullable ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool LookupIsNullable() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupIsNullable" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupIsNullable () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool LookupIsNullable();" />
      <MemberSignature Language="F#" Value="abstract member LookupIsNullable : unit -&gt; bool&#xA;override this.LookupIsNullable : unit -&gt; bool" Usage="xamlType.LookupIsNullable " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回一个值，该值指示此 <see cref="T:System.Xaml.XamlType" /> 按照 XAML 定义是否表示可以为 null 的类型。</summary>
        <returns>如果此 <see cref="T:System.Xaml.XamlType" /> 表示可以为 null 的类型，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 可以通过调用来调用此方法 <xref:System.Xaml.XamlType.IsNullable%2A> 。  
  
 默认实现基于 CLR 核心库可为 null 的概念进行确定，并对其进行检查 <xref:System.Xaml.XamlType.UnderlyingType%2A> 。 对于 null <xref:System.Xaml.XamlType.UnderlyingType%2A> ，它将返回 `true` 。  
  
 如果要 <xref:System.Xaml.XamlType.IsNullable%2A> 使用不同的逻辑，请重写此方法。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupIsPublic">
      <MemberSignature Language="C#" Value="protected virtual bool LookupIsPublic ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool LookupIsPublic() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupIsPublic" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupIsPublic () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool LookupIsPublic();" />
      <MemberSignature Language="F#" Value="abstract member LookupIsPublic : unit -&gt; bool&#xA;override this.LookupIsPublic : unit -&gt; bool" Usage="xamlType.LookupIsPublic " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回一个值，该值指示此 <see cref="T:System.Xaml.XamlType" /> 是否表示相关类型系统中的公共类型。</summary>
        <returns>如果此 <see cref="T:System.Xaml.XamlType" /> 表示公共类型，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 可以通过调用来调用此方法 <xref:System.Xaml.XamlType.IsPublic%2A> 。  
  
 默认实现对非 null 使用 CLR 反射 <xref:System.Xaml.XamlType.UnderlyingType%2A> 。 对于 null <xref:System.Xaml.XamlType.UnderlyingType%2A> ，它将返回 `true` 。  
  
 如果要 <xref:System.Xaml.XamlType.IsPublic%2A> 使用不同的逻辑，请重写此方法。  
  
> [!IMPORTANT]
>  <xref:System.Xaml.XamlType.LookupIsPublic%2A> 是虚拟的，因此可以重写。 重写有可能 (出于恶意目的，或者) 更改有关 XAML 类型的报告访问信息，使其不再以预期方式与类型系统或其基础 CLR 类型的访问信息对齐。 对于分配操作和访问的任何安全关键检查，请改用基础 CLR 类型。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupIsUnknown">
      <MemberSignature Language="C#" Value="protected virtual bool LookupIsUnknown ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool LookupIsUnknown() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupIsUnknown" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupIsUnknown () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool LookupIsUnknown();" />
      <MemberSignature Language="F#" Value="abstract member LookupIsUnknown : unit -&gt; bool&#xA;override this.LookupIsUnknown : unit -&gt; bool" Usage="xamlType.LookupIsUnknown " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回一个值，该值指示此 <see cref="T:System.Xaml.XamlType" /> 是否表示无法在基础类型系统中解析的类型。</summary>
        <returns>如果此 <see cref="T:System.Xaml.XamlType" /> 表示不可解析的类型，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 可以通过调用来调用此方法 <xref:System.Xaml.XamlType.IsUnknown%2A> 。  
  
 默认实现可以使用 CLR 反射。 对于 null <xref:System.Xaml.XamlType.UnderlyingType%2A> ，它将返回 `true` 。  
  
 如果要 <xref:System.Xaml.XamlType.IsUnknown%2A> 使用不同的逻辑，请重写此方法。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupIsWhitespaceSignificantCollection">
      <MemberSignature Language="C#" Value="protected virtual bool LookupIsWhitespaceSignificantCollection ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool LookupIsWhitespaceSignificantCollection() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupIsWhitespaceSignificantCollection" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupIsWhitespaceSignificantCollection () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool LookupIsWhitespaceSignificantCollection();" />
      <MemberSignature Language="F#" Value="abstract member LookupIsWhitespaceSignificantCollection : unit -&gt; bool&#xA;override this.LookupIsWhitespaceSignificantCollection : unit -&gt; bool" Usage="xamlType.LookupIsWhitespaceSignificantCollection " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回一个值，该值指示此 <see cref="T:System.Xaml.XamlType" /> 按照 XML 定义是否表示空白有意义集合。</summary>
        <returns>如果此 <see cref="T:System.Xaml.XamlType" /> 表示空白有意义集合，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 可以通过调用来调用此方法 <xref:System.Xaml.XamlType.IsWhitespaceSignificantCollection%2A> 。  
  
 默认实现基于读取返回值 <xref:System.Windows.Markup.WhitespaceSignificantCollectionAttribute> 。 <xref:System.Xaml.XamlType.BaseType%2A>如果在直接基础类型上找不到属性，还可以检查属性的是否为。 如果值不可用，则返回 `false` 。  
  
 如果要 <xref:System.Xaml.XamlType.IsWhitespaceSignificantCollection%2A> 使用不同的逻辑，请重写此方法。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupIsXData">
      <MemberSignature Language="C#" Value="protected virtual bool LookupIsXData ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool LookupIsXData() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupIsXData" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupIsXData () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool LookupIsXData();" />
      <MemberSignature Language="F#" Value="abstract member LookupIsXData : unit -&gt; bool&#xA;override this.LookupIsXData : unit -&gt; bool" Usage="xamlType.LookupIsXData " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回一个值，该值指示此 <see cref="T:System.Xaml.XamlType" /> 按照 XAML 定义是否表示 XML <see langword="XDATA" />。</summary>
        <returns>如果此 <see cref="T:System.Xaml.XamlType" /> 表示 <see langword="true" />，则为 <see langword="XDATA" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 可以通过调用来调用此方法 <xref:System.Xaml.XamlType.IsXData%2A> 。  
  
 默认实现 <xref:System.Xaml.XamlType.CanAssignTo%2A> 间接调用类型 <xref:System.Xml.Serialization.IXmlSerializable> 。  
  
 如果要 <xref:System.Xaml.XamlType.IsXData%2A> 使用不同的逻辑，请重写此方法。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupItemType">
      <MemberSignature Language="C#" Value="protected virtual System.Xaml.XamlType LookupItemType ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Xaml.XamlType LookupItemType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupItemType" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupItemType () As XamlType" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Xaml::XamlType ^ LookupItemType();" />
      <MemberSignature Language="F#" Value="abstract member LookupItemType : unit -&gt; System.Xaml.XamlType&#xA;override this.LookupItemType : unit -&gt; System.Xaml.XamlType" Usage="xamlType.LookupItemType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlType</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回一个值，该值为此 <see cref="T:System.Xaml.XamlType" /> 的 <see langword="Items" /> 属性提供类型信息。</summary>
        <returns>集合中项的类型的 <see cref="T:System.Xaml.XamlType" /> 对象；如果此 <see cref="T:System.Xaml.XamlType" /> 不表示集合，则为 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 可以通过调用来调用此方法 <xref:System.Xaml.XamlType.ItemType%2A> 。  
  
 默认实现可以使用 CLR 反射概念，例如通过检查方法并使用检查，并在 `Add` <xref:System.Reflection.MethodInfo> 此处检查 <xref:System.Reflection.ParameterInfo> <xref:System.Xaml.XamlType.IsArray%2A> <xref:System.Xaml.XamlType.BaseType%2A> 和尝试相同的逻辑。  
  
 如果要 <xref:System.Xaml.XamlType.ItemType%2A> 使用不同的逻辑，请重写此方法。 <xref:System.Xaml.XamlType.LookupCollectionKind%2A>返回 <xref:System.Xaml.Schema.XamlCollectionKind.None?displayProperty=nameWithType> 应返回的情况 `null` 。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupKeyType">
      <MemberSignature Language="C#" Value="protected virtual System.Xaml.XamlType LookupKeyType ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Xaml.XamlType LookupKeyType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupKeyType" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupKeyType () As XamlType" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Xaml::XamlType ^ LookupKeyType();" />
      <MemberSignature Language="F#" Value="abstract member LookupKeyType : unit -&gt; System.Xaml.XamlType&#xA;override this.LookupKeyType : unit -&gt; System.Xaml.XamlType" Usage="xamlType.LookupKeyType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlType</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>如果 <see cref="T:System.Xaml.XamlType" /> 表示字典，则返回一个值，该值为此 <see cref="T:System.Xaml.XamlType" /> 的键属性提供类型信息。</summary>
        <returns>字典用法的键类型的 <see cref="T:System.Xaml.XamlType" /> 对象，或者，如果此 <see cref="T:System.Xaml.XamlType" /> 不表示字典，则为 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 可以通过调用来调用此方法 <xref:System.Xaml.XamlType.KeyType%2A> 。  
  
 默认实现可以使用 CLR 反射概念，如 `Add` 通过和使用检查方法， <xref:System.Reflection.MethodInfo> 并在 <xref:System.Reflection.ParameterInfo> <xref:System.Xaml.XamlType.BaseType%2A> 此处检查和尝试相同的逻辑。  
  
 如果要 <xref:System.Xaml.XamlType.KeyType%2A> 使用不同的逻辑，请重写此方法。 <xref:System.Xaml.XamlType.LookupCollectionKind%2A>不返回的情况 <xref:System.Xaml.Schema.XamlCollectionKind.Dictionary?displayProperty=nameWithType> 应返回 `null` 。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupMarkupExtensionReturnType">
      <MemberSignature Language="C#" Value="protected virtual System.Xaml.XamlType LookupMarkupExtensionReturnType ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Xaml.XamlType LookupMarkupExtensionReturnType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupMarkupExtensionReturnType" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupMarkupExtensionReturnType () As XamlType" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Xaml::XamlType ^ LookupMarkupExtensionReturnType();" />
      <MemberSignature Language="F#" Value="abstract member LookupMarkupExtensionReturnType : unit -&gt; System.Xaml.XamlType&#xA;override this.LookupMarkupExtensionReturnType : unit -&gt; System.Xaml.XamlType" Usage="xamlType.LookupMarkupExtensionReturnType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlType</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>如果此 <see cref="T:System.Xaml.XamlType" /> 表示标记扩展，则返回一个为其已返回的 <see langword="ProvideValue" /> 提供类型信息的值。</summary>
        <returns>标记扩展用法的返回类型的 <see cref="T:System.Xaml.XamlType" /> 对象；否则，如果此 <see cref="T:System.Xaml.XamlType" /> 不表示标记扩展，则为 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 可以通过调用来调用此方法 <xref:System.Xaml.XamlType.MarkupExtensionReturnType%2A> 。  
  
 默认实现 <xref:System.Xaml.XamlType> 在读取时返回 <xref:System.Windows.Markup.MarkupExtensionReturnTypeAttribute> 。 <xref:System.Xaml.XamlType.BaseType%2A>如果在直接基础类型上找不到属性，它还可以检查特性。 如果值不可用，则返回 `null` 。  
  
 如果要 <xref:System.Xaml.XamlType.MarkupExtensionReturnType%2A> 使用不同的逻辑，请重写此方法。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupMember">
      <MemberSignature Language="C#" Value="protected virtual System.Xaml.XamlMember LookupMember (string name, bool skipReadOnlyCheck);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Xaml.XamlMember LookupMember(string name, bool skipReadOnlyCheck) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupMember(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupMember (name As String, skipReadOnlyCheck As Boolean) As XamlMember" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Xaml::XamlMember ^ LookupMember(System::String ^ name, bool skipReadOnlyCheck);" />
      <MemberSignature Language="F#" Value="abstract member LookupMember : string * bool -&gt; System.Xaml.XamlMember&#xA;override this.LookupMember : string * bool -&gt; System.Xaml.XamlMember" Usage="xamlType.LookupMember (name, skipReadOnlyCheck)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlMember</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="skipReadOnlyCheck" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name">要获取的成员的名称（字符串形式）。</param>
        <param name="skipReadOnlyCheck">设置为 <see langword="true" /> 以返回成员，即使该成员的 <see cref="P:System.Xaml.XamlMember.IsReadOnly" /> 值为 <see langword="true" />；设置为 <see langword="false" /> 以返回 <see cref="P:System.Xaml.XamlMember.IsReadOnly" /> 成员。 默认值为 <see langword="false" />。</param>
        <summary>从此 <see cref="T:System.Xaml.XamlMember" /> 中返回特定命名成员的 <see cref="T:System.Xaml.XamlType" />。</summary>
        <returns>如果已找到成员，则为成员的 <see cref="T:System.Xaml.XamlMember" /> 信息；否则为 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 可以通过调用来调用此方法 <xref:System.Xaml.XamlType.GetMember%2A> 。  
  
 默认实现根据 <xref:System.Xaml.XamlType> 架构上下文的内部 CLR 反射和计算返回。  
  
 如果要 <xref:System.Xaml.XamlType.GetMember%2A> 使用不同的逻辑，请重写此方法。  
  
> [!IMPORTANT]
>  <xref:System.Xaml.XamlType.LookupMember%2A> 是虚拟的，因此可以重写。 重写有可能 (出于恶意目的，或者) 更改 XAML 类型的已报告成员，使其不再按预期方式与 <xref:System.ComponentModel.TypeDescriptor> `Get*` 有关基础 CLR 类型的信息对齐。 对于成员报告的任何安全关键检查，请改用基础 CLR 类型。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupPositionalParameters">
      <MemberSignature Language="C#" Value="protected virtual System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt; LookupPositionalParameters (int parameterCount);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Collections.Generic.IList`1&lt;class System.Xaml.XamlType&gt; LookupPositionalParameters(int32 parameterCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupPositionalParameters(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupPositionalParameters (parameterCount As Integer) As IList(Of XamlType)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Collections::Generic::IList&lt;System::Xaml::XamlType ^&gt; ^ LookupPositionalParameters(int parameterCount);" />
      <MemberSignature Language="F#" Value="abstract member LookupPositionalParameters : int -&gt; System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt;&#xA;override this.LookupPositionalParameters : int -&gt; System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt;" Usage="xamlType.LookupPositionalParameters parameterCount" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="parameterCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="parameterCount">您需要其相关信息的特定语法或构造函数模式的计数 (arity)。</param>
        <summary>对于标记扩展类型，返回此 <see cref="T:System.Xaml.XamlType" /> 的特定标记扩展用法中所支持位置参数的类型。</summary>
        <returns><see cref="T:System.Xaml.XamlType" /> 值的列表，其中每个此类 <see cref="T:System.Xaml.XamlType" /> 都是该位置在语法中的类型。 您必须按照为标记扩展提供标记输入时的相同顺序指定这些类型。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 可以通过调用来调用此方法 <xref:System.Xaml.XamlType.GetPositionalParameters%2A> 。  
  
 默认实现使用基于查找构造函数和检查 arity 的内部反射信息。 如果要 <xref:System.Xaml.XamlType.GetPositionalParameters%2A> 使用不同的逻辑，请重写此方法。  
  
 仅当这 <xref:System.Xaml.XamlType> 表示)  (标记扩展时，此 API 才适用 <xref:System.Xaml.XamlType.IsMarkupExtension%2A> `true` 。  
  
 输入 `parameterCount` 不用于请求特定位置参数的类型。 它用于指定标记扩展用法的 arity。 标记扩展用法通常包含多个签名，并使用不同的参数 arity () 位置参数的计数来区分。 不过，您可以将架构上下文配置为允许重复的 arities，并使用位置参数的类型进行区分。 有关详细信息，请参阅 <xref:System.Xaml.XamlSchemaContext.SupportMarkupExtensionsWithDuplicateArity%2A>。 对于特定数量的计数，参数位置和类型可能会有所不同。 若要获取特定 arity 标记扩展用法的位置类型，请首先 <xref:System.Xaml.XamlType.GetPositionalParameters%2A> 使用 arity 计数调用。 然后从返回的集合中获取该位置处的项。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupSetMarkupExtensionHandler">
      <MemberSignature Language="C#" Value="protected virtual EventHandler&lt;System.Windows.Markup.XamlSetMarkupExtensionEventArgs&gt; LookupSetMarkupExtensionHandler ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.EventHandler`1&lt;class System.Windows.Markup.XamlSetMarkupExtensionEventArgs&gt; LookupSetMarkupExtensionHandler() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupSetMarkupExtensionHandler" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupSetMarkupExtensionHandler () As EventHandler(Of XamlSetMarkupExtensionEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual EventHandler&lt;System::Windows::Markup::XamlSetMarkupExtensionEventArgs ^&gt; ^ LookupSetMarkupExtensionHandler();" />
      <MemberSignature Language="F#" Value="abstract member LookupSetMarkupExtensionHandler : unit -&gt; EventHandler&lt;System.Windows.Markup.XamlSetMarkupExtensionEventArgs&gt;&#xA;override this.LookupSetMarkupExtensionHandler : unit -&gt; EventHandler&lt;System.Windows.Markup.XamlSetMarkupExtensionEventArgs&gt;" Usage="xamlType.LookupSetMarkupExtensionHandler " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Markup.XamlSetMarkupExtensionEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回一个用于标记扩展的 set 操作的处理程序回调。</summary>
        <returns>用于标记扩展的 set 操作的处理程序回调。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 默认实现基于读取返回值 <xref:System.Windows.Markup.XamlSetMarkupExtensionAttribute> 。 <xref:System.Xaml.XamlType.BaseType%2A>如果在直接基础类型上找不到属性，它还可以检查特性。 如果某个值不可用，则返回 `null` 。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupSetTypeConverterHandler">
      <MemberSignature Language="C#" Value="protected virtual EventHandler&lt;System.Windows.Markup.XamlSetTypeConverterEventArgs&gt; LookupSetTypeConverterHandler ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.EventHandler`1&lt;class System.Windows.Markup.XamlSetTypeConverterEventArgs&gt; LookupSetTypeConverterHandler() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupSetTypeConverterHandler" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupSetTypeConverterHandler () As EventHandler(Of XamlSetTypeConverterEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual EventHandler&lt;System::Windows::Markup::XamlSetTypeConverterEventArgs ^&gt; ^ LookupSetTypeConverterHandler();" />
      <MemberSignature Language="F#" Value="abstract member LookupSetTypeConverterHandler : unit -&gt; EventHandler&lt;System.Windows.Markup.XamlSetTypeConverterEventArgs&gt;&#xA;override this.LookupSetTypeConverterHandler : unit -&gt; EventHandler&lt;System.Windows.Markup.XamlSetTypeConverterEventArgs&gt;" Usage="xamlType.LookupSetTypeConverterHandler " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Markup.XamlSetTypeConverterEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回一个用于类型转换器设置情况的处理程序。</summary>
        <returns>一个用于类型转换器设置情况的处理程序。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 默认实现基于读取返回值 <xref:System.Windows.Markup.XamlSetTypeConverterAttribute> 。 <xref:System.Xaml.XamlType.BaseType%2A>如果在直接基础类型上找不到属性，它还可以检查特性。 如果某个值不可用，则返回 `null` 。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupTrimSurroundingWhitespace">
      <MemberSignature Language="C#" Value="protected virtual bool LookupTrimSurroundingWhitespace ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool LookupTrimSurroundingWhitespace() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupTrimSurroundingWhitespace" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupTrimSurroundingWhitespace () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool LookupTrimSurroundingWhitespace();" />
      <MemberSignature Language="F#" Value="abstract member LookupTrimSurroundingWhitespace : unit -&gt; bool&#xA;override this.LookupTrimSurroundingWhitespace : unit -&gt; bool" Usage="xamlType.LookupTrimSurroundingWhitespace " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回一个值，该值指示此 <see cref="T:System.Xaml.XamlType" /> 是否应使用修整周围空白的模式进行序列化。</summary>
        <returns>如果此 <see cref="T:System.Xaml.XamlType" /> 应使用修整周围空白的模式进行序列化，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 可以通过调用来调用此方法 <xref:System.Xaml.XamlType.TrimSurroundingWhitespace%2A> 。  
  
 默认实现基于读取返回值 <xref:System.Windows.Markup.TrimSurroundingWhitespaceAttribute> 。 <xref:System.Xaml.XamlType.BaseType%2A>如果在直接基础类型上找不到属性，它还可以检查特性。 如果某个值不可用，则返回 `false` 。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupTypeConverter">
      <MemberSignature Language="C#" Value="protected virtual System.Xaml.Schema.XamlValueConverter&lt;System.ComponentModel.TypeConverter&gt; LookupTypeConverter ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Xaml.Schema.XamlValueConverter`1&lt;class System.ComponentModel.TypeConverter&gt; LookupTypeConverter() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupTypeConverter" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupTypeConverter () As XamlValueConverter(Of TypeConverter)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Xaml::Schema::XamlValueConverter&lt;System::ComponentModel::TypeConverter ^&gt; ^ LookupTypeConverter();" />
      <MemberSignature Language="F#" Value="abstract member LookupTypeConverter : unit -&gt; System.Xaml.Schema.XamlValueConverter&lt;System.ComponentModel.TypeConverter&gt;&#xA;override this.LookupTypeConverter : unit -&gt; System.Xaml.Schema.XamlValueConverter&lt;System.ComponentModel.TypeConverter&gt;" Usage="xamlType.LookupTypeConverter " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.Schema.XamlValueConverter&lt;System.ComponentModel.TypeConverter&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回具有 <see cref="T:System.Xaml.Schema.XamlValueConverter`1" /> 约束的 <see cref="T:System.ComponentModel.TypeConverter" />，该约束表示此 <see cref="T:System.Xaml.XamlType" /> 的值的类型转换行为。</summary>
        <returns>具有 <see cref="T:System.Xaml.Schema.XamlValueConverter`1" /> 约束的 <see cref="T:System.ComponentModel.TypeConverter" />，该约束表示此 <see cref="T:System.Xaml.XamlType" /> 的值的类型转换行为；否则为 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 可以通过调用来调用此方法 <xref:System.Xaml.XamlType.TypeConverter%2A> 。  
  
 默认实现基于读取返回值 <xref:System.ComponentModel.TypeConverterAttribute> 。 <xref:System.Xaml.XamlType.BaseType%2A>如果在直接基础类型上找不到属性，则默认实现还可以检查特性。 它还包括枚举、常用值类型和泛型的默认转换的特殊逻辑。 如果某个值不可用，则返回 `null` 。  
  
 如果要 <xref:System.Xaml.XamlType.TypeConverter%2A> 使用不同的逻辑，请重写此方法。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupUnderlyingType">
      <MemberSignature Language="C#" Value="protected virtual Type LookupUnderlyingType ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Type LookupUnderlyingType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupUnderlyingType" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupUnderlyingType () As Type" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual Type ^ LookupUnderlyingType();" />
      <MemberSignature Language="F#" Value="abstract member LookupUnderlyingType : unit -&gt; Type&#xA;override this.LookupUnderlyingType : unit -&gt; Type" Usage="xamlType.LookupUnderlyingType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回为此 <see cref="T:System.Type" /> 提供支持的 CLR <see cref="T:System.Xaml.XamlType" />。</summary>
        <returns>为此 <see cref="T:System.Type" /> 提供支持的 CLR <see cref="T:System.Xaml.XamlType" />；否则为 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 可以通过调用来调用此方法 <xref:System.Xaml.XamlType.UnderlyingType%2A> 。  
  
 默认实现返回内部字段。 该字段通常在构造过程中初始化，其值基于调用的构造函数和提供的信息。  
  
 如果要 <xref:System.Xaml.XamlType.UnderlyingType%2A> 使用不同的逻辑，请重写此方法。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupUsableDuringInitialization">
      <MemberSignature Language="C#" Value="protected virtual bool LookupUsableDuringInitialization ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool LookupUsableDuringInitialization() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupUsableDuringInitialization" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupUsableDuringInitialization () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool LookupUsableDuringInitialization();" />
      <MemberSignature Language="F#" Value="abstract member LookupUsableDuringInitialization : unit -&gt; bool&#xA;override this.LookupUsableDuringInitialization : unit -&gt; bool" Usage="xamlType.LookupUsableDuringInitialization " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回一个值，该值指示在 XAML 初始化过程中是否自上而下生成此 <see cref="T:System.Xaml.XamlType" />。</summary>
        <returns>如果在 XAML 初始化过程中自上而下生成此 <see cref="T:System.Xaml.XamlType" />，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 自顶向下是在创建对象图时模拟 XAML 处理器行为的比喻。 当自上而下生成时，会实例化一个类型，并将其附加到父，并设置其属性。 自上而下的构造避免多次调用属性更改的处理程序。 此类处理 ripples 对象图，因此，消除了多个处理程序调用，并为启动对象图提供了性能优化。  
  
 可以通过调用来调用此方法 <xref:System.Xaml.XamlType.IsUsableDuringInitialization%2A> 。  
  
 默认实现基于读取返回值 <xref:System.Windows.Markup.UsableDuringInitializationAttribute> 。 <xref:System.Xaml.XamlType.BaseType%2A>如果在直接基础类型上找不到属性，它还可以检查特性。 如果某个值不可用，则返回 `false` 。  
  
 如果要 <xref:System.Xaml.XamlType.IsUsableDuringInitialization%2A> 使用不同的逻辑，请重写此方法。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupValueSerializer">
      <MemberSignature Language="C#" Value="protected virtual System.Xaml.Schema.XamlValueConverter&lt;System.Windows.Markup.ValueSerializer&gt; LookupValueSerializer ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Xaml.Schema.XamlValueConverter`1&lt;class System.Windows.Markup.ValueSerializer&gt; LookupValueSerializer() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupValueSerializer" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupValueSerializer () As XamlValueConverter(Of ValueSerializer)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Xaml::Schema::XamlValueConverter&lt;System::Windows::Markup::ValueSerializer ^&gt; ^ LookupValueSerializer();" />
      <MemberSignature Language="F#" Value="abstract member LookupValueSerializer : unit -&gt; System.Xaml.Schema.XamlValueConverter&lt;System.Windows.Markup.ValueSerializer&gt;&#xA;override this.LookupValueSerializer : unit -&gt; System.Xaml.Schema.XamlValueConverter&lt;System.Windows.Markup.ValueSerializer&gt;" Usage="xamlType.LookupValueSerializer " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.Schema.XamlValueConverter&lt;System.Windows.Markup.ValueSerializer&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回具有 <see cref="T:System.Xaml.Schema.XamlValueConverter`1" /> 约束的 <see cref="T:System.Windows.Markup.ValueSerializer" />，该约束表示此 <see cref="T:System.Xaml.XamlType" /> 的值的值序列化行为。</summary>
        <returns>具有 <see cref="T:System.Xaml.Schema.XamlValueConverter`1" /> 约束的 <see cref="T:System.Windows.Markup.ValueSerializer" />，该约束表示此 <see cref="T:System.Xaml.XamlType" /> 的值的值序列化行为；否则为 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 可以通过调用来调用此方法 <xref:System.Xaml.XamlType.ValueSerializer%2A> 。  
  
 默认实现基于读取返回值 <xref:System.Windows.Markup.ValueSerializerAttribute> 。 <xref:System.Xaml.XamlType.BaseType%2A>如果在直接基础类型上找不到属性，它还可以检查特性。 它还包括枚举、常用值类型或泛型的默认序列化的特殊逻辑。 如果某个值不可用，则返回 `null` 。  
  
 如果要 <xref:System.Xaml.XamlType.ValueSerializer%2A> 使用不同的逻辑，请重写此方法。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MarkupExtensionReturnType">
      <MemberSignature Language="C#" Value="public System.Xaml.XamlType MarkupExtensionReturnType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xaml.XamlType MarkupExtensionReturnType" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.MarkupExtensionReturnType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MarkupExtensionReturnType As XamlType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xaml::XamlType ^ MarkupExtensionReturnType { System::Xaml::XamlType ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MarkupExtensionReturnType : System.Xaml.XamlType" Usage="System.Xaml.XamlType.MarkupExtensionReturnType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>如果此 <see cref="T:System.Xaml.XamlType" /> 表示标记扩展，则获取一个为其已返回的 <see langword="ProvideValue" /> 提供类型信息的值。</summary>
        <value>标记扩展用法的返回类型的 <see cref="T:System.Xaml.XamlType" /> 对象；否则，如果此 <see cref="T:System.Xaml.XamlType" /> 不表示标记扩展，则为 <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此属性仅在以下情况下才相关 <xref:System.Xaml.XamlType> ：这表示标记扩展 (`x:MarkupExtension` 位于可分配的类型列表中) 。  
  
 如果不使用默认的内部 CLR 反射技术 <xref:System.Xaml.XamlType> ，则对此属性的调用可以调用 <xref:System.Xaml.XamlType.LookupMarkupExtensionReturnType%2A> 派生类的重写 <xref:System.Xaml.XamlType> 。 有关返回值和其他行为的详细信息，请参阅有关 <xref:System.Xaml.XamlType.LookupMarkupExtensionReturnType%2A> 此类型的文档。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.Name" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Name { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Name : string" Usage="System.Xaml.XamlType.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取此 <see cref="T:System.Xaml.XamlType" /> 表示的类型的字符串名称。</summary>
        <value>此 XAML 类型的字符串名称。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此属性通常获取 (每个签名) 的架构构造名称 <xref:System.Xaml.XamlType.%23ctor%2A> ，或者 <xref:System.Type> ，如果它是使用 CLR 类型系统的相关构造函数构造的，则为的名称。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (System.Xaml.XamlType xamlType1, System.Xaml.XamlType xamlType2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(class System.Xaml.XamlType xamlType1, class System.Xaml.XamlType xamlType2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.op_Equality(System.Xaml.XamlType,System.Xaml.XamlType)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (xamlType1 As XamlType, xamlType2 As XamlType) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::Xaml::XamlType ^ xamlType1, System::Xaml::XamlType ^ xamlType2);" />
      <MemberSignature Language="F#" Value="static member ( = ) : System.Xaml.XamlType * System.Xaml.XamlType -&gt; bool" Usage="xamlType1 = xamlType2" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="xamlType1" Type="System.Xaml.XamlType" />
        <Parameter Name="xamlType2" Type="System.Xaml.XamlType" />
      </Parameters>
      <Docs>
        <param name="xamlType1"><see cref="T:System.Xaml.XamlType" /> 或 <see langword="null" />。</param>
        <param name="xamlType2"><see cref="T:System.Xaml.XamlType" /> 或 <see langword="null" />。</param>
        <summary>确定两个指定的 <see cref="T:System.Xaml.XamlType" /> 对象是否具有相同的值。</summary>
        <returns>如果 <see langword="true" /> 的值与 <paramref name="xamlType1" /> 的值相同，则为 <paramref name="xamlType2" />；否则为 <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (System.Xaml.XamlType xamlType1, System.Xaml.XamlType xamlType2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(class System.Xaml.XamlType xamlType1, class System.Xaml.XamlType xamlType2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.op_Inequality(System.Xaml.XamlType,System.Xaml.XamlType)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (xamlType1 As XamlType, xamlType2 As XamlType) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::Xaml::XamlType ^ xamlType1, System::Xaml::XamlType ^ xamlType2);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : System.Xaml.XamlType * System.Xaml.XamlType -&gt; bool" Usage="System.Xaml.XamlType.op_Inequality (xamlType1, xamlType2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="xamlType1" Type="System.Xaml.XamlType" />
        <Parameter Name="xamlType2" Type="System.Xaml.XamlType" />
      </Parameters>
      <Docs>
        <param name="xamlType1"><see cref="T:System.Xaml.XamlType" /> 或 <see langword="null" />。</param>
        <param name="xamlType2"><see cref="T:System.Xaml.XamlType" /> 或 <see langword="null" />。</param>
        <summary>确定两个指定的 <see cref="T:System.Xaml.XamlType" /> 对象是否具有不同的值。</summary>
        <returns>如果 <paramref name="xamlType1" /> 的值与 <paramref name="xamlType2" /> 的值不同，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PreferredXamlNamespace">
      <MemberSignature Language="C#" Value="public string PreferredXamlNamespace { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string PreferredXamlNamespace" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.PreferredXamlNamespace" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PreferredXamlNamespace As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ PreferredXamlNamespace { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.PreferredXamlNamespace : string" Usage="System.Xaml.XamlType.PreferredXamlNamespace" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取单个 XAML 命名空间，该命名空间是此 <see cref="T:System.Xaml.XamlType" /> 的主 XAML 命名空间。</summary>
        <value>此 XAML 类型的主 XAML 命名空间的标识符（字符串形式）。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此实现提供与调用相同的值 <xref:System.Xaml.XamlType.GetXamlNamespaces%2A> ，并从返回的可枚举集中获取第一个值字符串。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SchemaContext">
      <MemberSignature Language="C#" Value="public System.Xaml.XamlSchemaContext SchemaContext { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xaml.XamlSchemaContext SchemaContext" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.SchemaContext" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SchemaContext As XamlSchemaContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xaml::XamlSchemaContext ^ SchemaContext { System::Xaml::XamlSchemaContext ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SchemaContext : System.Xaml.XamlSchemaContext" Usage="System.Xaml.XamlType.SchemaContext" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlSchemaContext</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取用于处理此 <see cref="T:System.Xaml.XamlSchemaContext" /> 的活动 <see cref="T:System.Xaml.XamlType" />。</summary>
        <value>用于处理此 <see cref="T:System.Xaml.XamlSchemaContext" /> 的活动 <see cref="T:System.Xaml.XamlType" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Xaml.XamlSchemaContext> 构造时是必需的参数项 <xref:System.Xaml.XamlType> 。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="xamlType.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回此 <see cref="T:System.Xaml.XamlType" /> 的字符串表示形式。</summary>
        <returns>此 <see cref="T:System.Xaml.XamlType" /> 的字符串表示形式。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 的 <xref:System.Xaml.XamlType> 实现 <xref:System.Object.ToString%2A> 返回 <xref:System.Xaml.XamlType.Name%2A> 的属性 <xref:System.Xaml.XamlType> 。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimSurroundingWhitespace">
      <MemberSignature Language="C#" Value="public bool TrimSurroundingWhitespace { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool TrimSurroundingWhitespace" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.TrimSurroundingWhitespace" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TrimSurroundingWhitespace As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool TrimSurroundingWhitespace { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.TrimSurroundingWhitespace : bool" Usage="System.Xaml.XamlType.TrimSurroundingWhitespace" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示此 <see cref="T:System.Xaml.XamlType" /> 是否具有用于在其内容中修整周围空白的序列化空白处理行为。</summary>
        <value>如果此 <see cref="T:System.Xaml.XamlType" /> 表示使用空白修整的类型，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果不使用默认的内部 CLR 反射技术 <xref:System.Xaml.XamlType> ，则对此属性的调用可以调用 <xref:System.Xaml.XamlType.LookupIsWhitespaceSignificantCollection%2A> 派生类的重写 <xref:System.Xaml.XamlType> 。 有关返回值和其他行为的详细信息，请参阅有关 <xref:System.Xaml.XamlType.LookupIsWhitespaceSignificantCollection%2A> 此类型的文档。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TypeArguments">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt; TypeArguments { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IList`1&lt;class System.Xaml.XamlType&gt; TypeArguments" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.TypeArguments" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TypeArguments As IList(Of XamlType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::IList&lt;System::Xaml::XamlType ^&gt; ^ TypeArguments { System::Collections::Generic::IList&lt;System::Xaml::XamlType ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TypeArguments : System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt;" Usage="System.Xaml.XamlType.TypeArguments" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>针对此 <see cref="T:System.Xaml.XamlType" /> 表示泛型的情况获取类型参数的列表。</summary>
        <value>类型参数类型的列表；否则，如果此 <see cref="T:System.Xaml.XamlType" /> 不表示泛型，则为 <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在某些情况下，调用参数的情况会 <xref:System.Xaml.XamlType> <xref:System.Xaml.XamlType.TypeArguments%2A> 返回一个列表，其中的类型仍处于打开状态。 在这种情况下，一个或多个返回 <xref:System.Xaml.XamlType> 值将具有占位符值 <xref:System.Xaml.XamlType.Name%2A?displayProperty=nameWithType> ，例如 `T` ，表示泛型仍处于打开状态。 如果从对的调用中获取 <xref:System.Xaml.XamlType> <xref:System.Xaml.XamlSchemaContext.GetXamlType%2A> ，而不是从 XAML 读取器实现中获取，则会发生这种情况。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TypeConverter">
      <MemberSignature Language="C#" Value="public System.Xaml.Schema.XamlValueConverter&lt;System.ComponentModel.TypeConverter&gt; TypeConverter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xaml.Schema.XamlValueConverter`1&lt;class System.ComponentModel.TypeConverter&gt; TypeConverter" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.TypeConverter" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TypeConverter As XamlValueConverter(Of TypeConverter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xaml::Schema::XamlValueConverter&lt;System::ComponentModel::TypeConverter ^&gt; ^ TypeConverter { System::Xaml::Schema::XamlValueConverter&lt;System::ComponentModel::TypeConverter ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TypeConverter : System.Xaml.Schema.XamlValueConverter&lt;System.ComponentModel.TypeConverter&gt;" Usage="System.Xaml.XamlType.TypeConverter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.Schema.XamlValueConverter&lt;System.ComponentModel.TypeConverter&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个具有 <see cref="T:System.Xaml.Schema.XamlValueConverter`1" /> 约束的 <see cref="T:System.ComponentModel.TypeConverter" />，该约束表示此 <see cref="T:System.Xaml.XamlType" /> 的值的类型转换行为。</summary>
        <value>一个具有 <see cref="T:System.Xaml.Schema.XamlValueConverter`1" /> 约束的 <see cref="T:System.ComponentModel.TypeConverter" />，该约束表示此 <see cref="T:System.Xaml.XamlType" /> 的值的类型转换行为。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果不使用默认的内部 CLR 反射技术 <xref:System.Xaml.XamlType> ，则对此属性的调用可以调用 <xref:System.Xaml.XamlType.LookupTypeConverter%2A> 派生类的重写 <xref:System.Xaml.XamlType> 。 有关返回值和其他行为的详细信息，请参阅有关 <xref:System.Xaml.XamlType.LookupTypeConverter%2A> 此类型的文档。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UnderlyingType">
      <MemberSignature Language="C#" Value="public Type UnderlyingType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type UnderlyingType" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.UnderlyingType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property UnderlyingType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Type ^ UnderlyingType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UnderlyingType : Type" Usage="System.Xaml.XamlType.UnderlyingType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[get: System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取为此 <see cref="T:System.Type" /> 提供支持的 CLR <see cref="T:System.Xaml.XamlType" />。</summary>
        <value>为此 <see cref="T:System.Type" /> 提供支持的 CLR <see cref="T:System.Xaml.XamlType" />。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ValueSerializer">
      <MemberSignature Language="C#" Value="public System.Xaml.Schema.XamlValueConverter&lt;System.Windows.Markup.ValueSerializer&gt; ValueSerializer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xaml.Schema.XamlValueConverter`1&lt;class System.Windows.Markup.ValueSerializer&gt; ValueSerializer" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.ValueSerializer" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ValueSerializer As XamlValueConverter(Of ValueSerializer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xaml::Schema::XamlValueConverter&lt;System::Windows::Markup::ValueSerializer ^&gt; ^ ValueSerializer { System::Xaml::Schema::XamlValueConverter&lt;System::Windows::Markup::ValueSerializer ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ValueSerializer : System.Xaml.Schema.XamlValueConverter&lt;System.Windows.Markup.ValueSerializer&gt;" Usage="System.Xaml.XamlType.ValueSerializer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.Schema.XamlValueConverter&lt;System.Windows.Markup.ValueSerializer&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取具有 <see cref="T:System.Xaml.Schema.XamlValueConverter`1" /> 约束的 <see cref="T:System.Windows.Markup.ValueSerializer" />，该约束表示此 <see cref="T:System.Xaml.XamlType" /> 的值的值序列化行为。</summary>
        <value>具有 <see cref="T:System.Xaml.Schema.XamlValueConverter`1" /> 约束的 <see cref="T:System.Windows.Markup.ValueSerializer" />，该约束表示此 <see cref="T:System.Xaml.XamlType" /> 的值的值序列化行为；否则为 <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果不使用默认的内部 CLR 反射技术 <xref:System.Xaml.XamlType> ，则对此属性的调用可以调用 <xref:System.Xaml.XamlType.LookupValueSerializer%2A> 派生类的重写 <xref:System.Xaml.XamlType> 。 有关返回值和其他行为的详细信息，请参阅有关 <xref:System.Xaml.XamlType.LookupValueSerializer%2A> 此类型的文档。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
