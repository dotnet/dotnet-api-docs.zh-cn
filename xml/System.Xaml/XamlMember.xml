<Type Name="XamlMember" FullName="System.Xaml.XamlMember">
  <Metadata><Meta Name="ms.openlocfilehash" Value="63bb4edf7be371b8f0d7899368ff07fb986789d6" /><Meta Name="ms.sourcegitcommit" Value="b0947fed0227b6b2e292d7efb43705b488b130aa" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-CN" /><Meta Name="ms.lasthandoff" Value="04/29/2020" /><Meta Name="ms.locfileid" Value="82377339" /></Metadata><TypeSignature Language="C#" Value="public class XamlMember : IEquatable&lt;System.Xaml.XamlMember&gt;" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit XamlMember extends System.Object implements class System.IEquatable`1&lt;class System.Xaml.XamlMember&gt;" />
  <TypeSignature Language="DocId" Value="T:System.Xaml.XamlMember" />
  <TypeSignature Language="VB.NET" Value="Public Class XamlMember&#xA;Implements IEquatable(Of XamlMember)" />
  <TypeSignature Language="C++ CLI" Value="public ref class XamlMember : IEquatable&lt;System::Xaml::XamlMember ^&gt;" />
  <TypeSignature Language="F#" Value="type XamlMember = class&#xA;    interface IEquatable&lt;XamlMember&gt;" />
  <AssemblyInfo>
    <AssemblyName>System.Xaml</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>5.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IEquatable&lt;System.Xaml.XamlMember&gt;</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>为 XAML 类型的成员提供 XAML 类型系统标识符。 该标识符由 XAML 读取器和 XAML 编写器在处理成员节点的过程中使用（如果 XAML 读取器位于 <see cref="F:System.Xaml.XamlNodeType.StartMember" /> 上），另外还用于常规 XAML 类型系统逻辑。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Xaml.XamlMember> 可以使用三种方法来返回有关 XAML 成员的信息：标准公共语言运行时（CLR）反射;调用使用经过优化的位标志的内部 Api 的仅引用反射技术;或调入 <xref:System.Xaml.XamlMember> 子类提供的 `Lookup*` API 的虚拟覆盖。 若要在大多数情况下使用 .NET Framework XAML 服务 Api 和 <xref:System.Xaml.XamlMember> API，请使用默认的 XAML 架构上下文。 .NET Framework XAML 服务的默认 XAML 架构上下文将 CLR 支持用于类型系统。 这使得 XAML 读取器和 XAML 编写器可以使用在中定义的任何类型或成员，也可用于 CLR 及其反射技术。  
  
## <a name="lookup-apis-and-xamlmember-derived-classes"></a>Lookup * Api 和 XamlMember 派生类  
 <xref:System.Xaml.XamlMember> 定义派生类可能重写的若干虚拟成员。 这些成员的名称始终以字符串 `Lookup`开头。 然后，API 名称的其余部分引用该虚拟方法所影响的属性。 例如，<xref:System.Xaml.XamlMember> 派生类可能重写 <xref:System.Xaml.XamlMember.LookupTargetType%2A>，以影响在派生类中 <xref:System.Xaml.XamlMember.TargetType%2A> 返回的 base 定义属性。 通过阅读相关 `Lookup*` 方法的文档，可以预测 <xref:System.Xaml.XamlMember> 或现有派生类中的此类属性的返回值。  
  
 `Lookup*` 方法的目的是提供一个包含 <xref:System.Xaml.XamlMember> 基类的 XAML 类型系统扩展技术。 通过从 <xref:System.Xaml.XamlMember> 和重写 `Lookup` 虚拟成员，您可以为 XAML 类型系统中的 XAML 架构定义 XAML 成员的概念，而不会绑定到后备类型系统或技术的具体内容。 您还可以在此方案下使用提供的 XAML 架构上下文，并且仍返回所需的结果。  
  
 作为示例，请考虑 <xref:System.Xaml.XamlMember.IsWritePublic%2A>的 <xref:System.Xaml.XamlMember> 属性。 此属性通知调用方，如使用 <xref:System.Xaml.XamlWriter> 进行序列化等操作可以在目标对象上写入此成员的值。 在默认实现中，确定成员是否可写是通过对后备 CLR <xref:System.Type> 及其成员（<xref:System.Reflection.MemberInfo>）使用反射技术来进行的。 因此，默认情况下，XAML 类型系统依赖于 CLR 类型系统。 但是，您可以通过重写 API <xref:System.Xaml.XamlMember.LookupIsWritePublic%2A>来删除 XAML 类型系统报告 <xref:System.Xaml.XamlMember.IsWritePublic%2A> 的依赖项。 在重写中，可以使用其他确定，例如特定于技术的元数据、针对固定 XAML 词汇进行了优化的主查找表或用于确定 xaml 成员在 XAML 词汇中是否可写的各种其他策略。  
  
## <a name="constructing-xamlmember-without-xaml-schema-context"></a>构造没有 XAML 架构上下文的 XamlMember  
 <xref:System.Xaml.XamlMember> 的大多数构造函数要求在初始化过程中使用 <xref:System.Xaml.XamlSchemaContext>。 许多内部 <xref:System.Xaml.XamlSchemaContext> 操作都需要 <xref:System.Xaml.XamlSchemaContext>，例如获取从后备类型转发的信息。 使用 <xref:System.Xaml.XamlMember> API 时，通常会有一个 <xref:System.Xaml.XamlSchemaContext> 可从周围的构造（如 <xref:System.Xaml.XamlWriter>）获得。 在这种情况下，可以将 <xref:System.Xaml.XamlSchemaContext> 引用传递到需要 XAML 架构上下文的所有 XAML 类型系统调用。  
  
 <xref:System.Xaml.XamlMember.%23ctor%28System.String%2CSystem.Xaml.XamlType%2CSystem.Boolean%29>中的一个特定构造函数不需要 <xref:System.Xaml.XamlSchemaContext>。 但是，使用 <xref:System.Xaml.XamlMember.%23ctor%28System.String%2CSystem.Xaml.XamlType%2CSystem.Boolean%29> 签名构造的 <xref:System.Xaml.XamlMember> 将为 <xref:System.Xaml.XamlMember.IsUnknown%2A>返回 `true`。  
  
 对于涉及 <xref:System.Xaml.XamlObjectWriter>的加载路径，此类成员不能写入对象关系图。 使用 .NET Framework XAML 服务实现，当相关 <xref:System.Xaml.XamlMember> 报表 `true` <xref:System.Xaml.XamlMember.IsUnknown%2A>时，<xref:System.Xaml.XamlObjectWriter.WriteStartMember%2A?displayProperty=nameWithType> 调用将引发 <xref:System.Xaml.XamlObjectWriterException>。  
  
 您不应构造 `true` 的值为 <xref:System.Xaml.XamlMember.IsUnknown%2A> 的 <xref:System.Xaml.XamlMember>，除非您的实现可以处理 <xref:System.Xaml.XamlObjectWriter>中的异常，或者您可以使用其他方法来调整 <xref:System.Xaml.XamlObjectWriter> 行为。 例如，以下一项或多项操作可能适用于你的实现：  
  
-   XAML 架构上下文稍后会提供。  
  
-   你使用成员调用程序模式。  
  
-   您有意重写自定义 XAML 编写器中的 <xref:System.Xaml.XamlObjectWriter.WriteStartMember%2A?displayProperty=nameWithType>。  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Xaml.XamlType" />
    <altmember cref="T:System.Xaml.XamlDirective" />
    <altmember cref="T:System.Xaml.XamlObjectWriter" />
    <related type="Article" href="https://msdn.microsoft.com/library/7c11abec-1075-474c-9d9b-778e5dab21c3">了解 XAML 节点流结构和概念</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>初始化 <see cref="T:System.Xaml.XamlMember" /> 类的新实例。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XamlMember (System.Reflection.EventInfo eventInfo, System.Xaml.XamlSchemaContext schemaContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Reflection.EventInfo eventInfo, class System.Xaml.XamlSchemaContext schemaContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.#ctor(System.Reflection.EventInfo,System.Xaml.XamlSchemaContext)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (eventInfo As EventInfo, schemaContext As XamlSchemaContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XamlMember(System::Reflection::EventInfo ^ eventInfo, System::Xaml::XamlSchemaContext ^ schemaContext);" />
      <MemberSignature Language="F#" Value="new System.Xaml.XamlMember : System.Reflection.EventInfo * System.Xaml.XamlSchemaContext -&gt; System.Xaml.XamlMember" Usage="new System.Xaml.XamlMember (eventInfo, schemaContext)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="eventInfo" Type="System.Reflection.EventInfo" />
        <Parameter Name="schemaContext" Type="System.Xaml.XamlSchemaContext" />
      </Parameters>
      <Docs>
        <param name="eventInfo">用于表示事件成员的 CLR 类型系统 <see cref="T:System.Reflection.EventInfo" />。</param>
        <param name="schemaContext">用于限定成员的 <see cref="T:System.Xaml.XamlSchemaContext" /> 上下文。</param>
        <summary>使用 CLR 类型系统 <see cref="T:System.Xaml.XamlMember" /> 和 <see cref="T:System.Reflection.EventInfo" /> 初始化 <see cref="T:System.Xaml.XamlSchemaContext" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果成员表示事件（事件处理程序连接点属性），则使用此构造函数。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XamlMember (System.Reflection.PropertyInfo propertyInfo, System.Xaml.XamlSchemaContext schemaContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Reflection.PropertyInfo propertyInfo, class System.Xaml.XamlSchemaContext schemaContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.#ctor(System.Reflection.PropertyInfo,System.Xaml.XamlSchemaContext)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (propertyInfo As PropertyInfo, schemaContext As XamlSchemaContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XamlMember(System::Reflection::PropertyInfo ^ propertyInfo, System::Xaml::XamlSchemaContext ^ schemaContext);" />
      <MemberSignature Language="F#" Value="new System.Xaml.XamlMember : System.Reflection.PropertyInfo * System.Xaml.XamlSchemaContext -&gt; System.Xaml.XamlMember" Usage="new System.Xaml.XamlMember (propertyInfo, schemaContext)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="propertyInfo" Type="System.Reflection.PropertyInfo" />
        <Parameter Name="schemaContext" Type="System.Xaml.XamlSchemaContext" />
      </Parameters>
      <Docs>
        <param name="propertyInfo">用于表示属性成员的 CLR 类型系统 <see cref="T:System.Reflection.PropertyInfo" />。</param>
        <param name="schemaContext">用于限定成员的 <see cref="T:System.Xaml.XamlSchemaContext" /> 上下文。</param>
        <summary>使用 CLR 类型系统 <see cref="T:System.Xaml.XamlMember" /> 和 <see cref="T:System.Reflection.PropertyInfo" /> 初始化 <see cref="T:System.Xaml.XamlSchemaContext" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果成员表示属性（具体不是事件处理程序连接），则使用此构造函数。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XamlMember (System.Reflection.EventInfo eventInfo, System.Xaml.XamlSchemaContext schemaContext, System.Xaml.Schema.XamlMemberInvoker invoker);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Reflection.EventInfo eventInfo, class System.Xaml.XamlSchemaContext schemaContext, class System.Xaml.Schema.XamlMemberInvoker invoker) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.#ctor(System.Reflection.EventInfo,System.Xaml.XamlSchemaContext,System.Xaml.Schema.XamlMemberInvoker)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (eventInfo As EventInfo, schemaContext As XamlSchemaContext, invoker As XamlMemberInvoker)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XamlMember(System::Reflection::EventInfo ^ eventInfo, System::Xaml::XamlSchemaContext ^ schemaContext, System::Xaml::Schema::XamlMemberInvoker ^ invoker);" />
      <MemberSignature Language="F#" Value="new System.Xaml.XamlMember : System.Reflection.EventInfo * System.Xaml.XamlSchemaContext * System.Xaml.Schema.XamlMemberInvoker -&gt; System.Xaml.XamlMember" Usage="new System.Xaml.XamlMember (eventInfo, schemaContext, invoker)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="eventInfo" Type="System.Reflection.EventInfo" />
        <Parameter Name="schemaContext" Type="System.Xaml.XamlSchemaContext" />
        <Parameter Name="invoker" Type="System.Xaml.Schema.XamlMemberInvoker" />
      </Parameters>
      <Docs>
        <param name="eventInfo">用于表示事件成员的 CLR 类型系统 <see cref="T:System.Reflection.EventInfo" />。</param>
        <param name="schemaContext">用于限定成员的 <see cref="T:System.Xaml.XamlSchemaContext" /> 上下文。</param>
        <param name="invoker">可针对 <see cref="T:System.Xaml.Schema.XamlMemberInvoker" /> 处理运行时反射调用的 <see cref="T:System.Xaml.XamlMember" /> 实现。</param>
        <summary>使用 CLR 类型系统 <see cref="T:System.Xaml.XamlMember" /> 和 <see cref="T:System.Reflection.EventInfo" />（包括 <see cref="T:System.Xaml.XamlSchemaContext" /> 信息）初始化 <see cref="T:System.Xaml.Schema.XamlMemberInvoker" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果成员表示事件（或事件处理程序连接点属性），则使用此构造函数。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XamlMember (System.Reflection.PropertyInfo propertyInfo, System.Xaml.XamlSchemaContext schemaContext, System.Xaml.Schema.XamlMemberInvoker invoker);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Reflection.PropertyInfo propertyInfo, class System.Xaml.XamlSchemaContext schemaContext, class System.Xaml.Schema.XamlMemberInvoker invoker) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.#ctor(System.Reflection.PropertyInfo,System.Xaml.XamlSchemaContext,System.Xaml.Schema.XamlMemberInvoker)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (propertyInfo As PropertyInfo, schemaContext As XamlSchemaContext, invoker As XamlMemberInvoker)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XamlMember(System::Reflection::PropertyInfo ^ propertyInfo, System::Xaml::XamlSchemaContext ^ schemaContext, System::Xaml::Schema::XamlMemberInvoker ^ invoker);" />
      <MemberSignature Language="F#" Value="new System.Xaml.XamlMember : System.Reflection.PropertyInfo * System.Xaml.XamlSchemaContext * System.Xaml.Schema.XamlMemberInvoker -&gt; System.Xaml.XamlMember" Usage="new System.Xaml.XamlMember (propertyInfo, schemaContext, invoker)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="propertyInfo" Type="System.Reflection.PropertyInfo" />
        <Parameter Name="schemaContext" Type="System.Xaml.XamlSchemaContext" />
        <Parameter Name="invoker" Type="System.Xaml.Schema.XamlMemberInvoker" />
      </Parameters>
      <Docs>
        <param name="propertyInfo">用于表示属性成员的 CLR 类型系统 <see cref="T:System.Reflection.PropertyInfo" />。</param>
        <param name="schemaContext">用于限定成员的 <see cref="T:System.Xaml.XamlSchemaContext" /> 上下文。</param>
        <param name="invoker">用于针对 <see cref="T:System.Xaml.Schema.XamlMemberInvoker" /> 处理运行时调用的 <see cref="T:System.Xaml.XamlMember" /> 实现。</param>
        <summary>使用反射 <see cref="T:System.Xaml.XamlMember" /> 和 <see cref="T:System.Reflection.PropertyInfo" />（包括 <see cref="T:System.Xaml.XamlSchemaContext" /> 信息）初始化 <see cref="T:System.Xaml.Schema.XamlMemberInvoker" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 仅当成员表示属性并且不是事件处理程序连接时，才使用此构造函数。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XamlMember (string attachableEventName, System.Reflection.MethodInfo adder, System.Xaml.XamlSchemaContext schemaContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string attachableEventName, class System.Reflection.MethodInfo adder, class System.Xaml.XamlSchemaContext schemaContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.#ctor(System.String,System.Reflection.MethodInfo,System.Xaml.XamlSchemaContext)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (attachableEventName As String, adder As MethodInfo, schemaContext As XamlSchemaContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XamlMember(System::String ^ attachableEventName, System::Reflection::MethodInfo ^ adder, System::Xaml::XamlSchemaContext ^ schemaContext);" />
      <MemberSignature Language="F#" Value="new System.Xaml.XamlMember : string * System.Reflection.MethodInfo * System.Xaml.XamlSchemaContext -&gt; System.Xaml.XamlMember" Usage="new System.Xaml.XamlMember (attachableEventName, adder, schemaContext)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="attachableEventName" Type="System.String" />
        <Parameter Name="adder" Type="System.Reflection.MethodInfo" />
        <Parameter Name="schemaContext" Type="System.Xaml.XamlSchemaContext" />
      </Parameters>
      <Docs>
        <param name="attachableEventName">可附加事件的字符串名称。</param>
        <param name="adder">可附加成员的支持实现的处理程序 <see cref="T:System.Reflection.MethodInfo" /> 方法的 CLR 类型系统 <see langword="Add" />。</param>
        <param name="schemaContext">用于限定成员的 <see cref="T:System.Xaml.XamlSchemaContext" /> 上下文。</param>
        <summary>针对表示可附加事件的 <see cref="T:System.Xaml.XamlMember" /> 初始化 <see cref="T:System.Xaml.XamlMember" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果成员表示可附加的事件成员，请使用此构造函数。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XamlMember (string name, System.Xaml.XamlType declaringType, bool isAttachable);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name, class System.Xaml.XamlType declaringType, bool isAttachable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.#ctor(System.String,System.Xaml.XamlType,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As String, declaringType As XamlType, isAttachable As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XamlMember(System::String ^ name, System::Xaml::XamlType ^ declaringType, bool isAttachable);" />
      <MemberSignature Language="F#" Value="new System.Xaml.XamlMember : string * System.Xaml.XamlType * bool -&gt; System.Xaml.XamlMember" Usage="new System.Xaml.XamlMember (name, declaringType, isAttachable)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="declaringType" Type="System.Xaml.XamlType" />
        <Parameter Name="isAttachable" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name">成员的字符串名称。</param>
        <param name="declaringType">声明类型的 <see cref="T:System.Xaml.XamlType" /> 信息。</param>
        <param name="isAttachable">如果要指示成员是可附加的，则为 <see langword="true" />；否则为 <see langword="false" />。</param>
        <summary>使用字符串名称和声明 <see cref="T:System.Xaml.XamlMember" /> 信息初始化 <see cref="T:System.Xaml.XamlType" /> 类的新实例。 使用此签名构造的 <see cref="T:System.Xaml.XamlMember" /> 具有很大的限制。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用 <xref:System.Xaml.XamlMember.%23ctor%28System.String%2CSystem.Xaml.XamlType%2CSystem.Boolean%29> 签名构造的 <xref:System.Xaml.XamlMember> 将为 <xref:System.Xaml.XamlMember.IsUnknown%2A>返回 `true`。  
  
 对于涉及 <xref:System.Xaml.XamlObjectWriter>的加载路径，此类成员不能写入对象关系图。 使用 .NET Framework XAML 服务实现，当相关 <xref:System.Xaml.XamlMember> 报表 `true` <xref:System.Xaml.XamlMember.IsUnknown%2A>时，<xref:System.Xaml.XamlObjectWriter.WriteStartMember%2A?displayProperty=nameWithType> 调用将引发 <xref:System.Xaml.XamlObjectWriterException>。  
  
 不应使用 `true` <xref:System.Xaml.XamlMember.IsUnknown%2A>构造 <xref:System.Xaml.XamlMember>，除非您的实现可以处理 <xref:System.Xaml.XamlObjectWriter>中的异常，或者您可以使用其他方法来调整 <xref:System.Xaml.XamlObjectWriter> 行为。 例如，以下一项或多项操作可能适用于你的实现：  
  
-   XAML 架构上下文稍后会提供。  
  
-   你使用成员调用程序模式。  
  
-   您有意重写自定义 XAML 编写器中的 <xref:System.Xaml.XamlObjectWriter.WriteStartMember%2A?displayProperty=nameWithType>。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> 或 <paramref name="declaringType" /> 为 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XamlMember (string attachablePropertyName, System.Reflection.MethodInfo getter, System.Reflection.MethodInfo setter, System.Xaml.XamlSchemaContext schemaContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string attachablePropertyName, class System.Reflection.MethodInfo getter, class System.Reflection.MethodInfo setter, class System.Xaml.XamlSchemaContext schemaContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.#ctor(System.String,System.Reflection.MethodInfo,System.Reflection.MethodInfo,System.Xaml.XamlSchemaContext)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (attachablePropertyName As String, getter As MethodInfo, setter As MethodInfo, schemaContext As XamlSchemaContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XamlMember(System::String ^ attachablePropertyName, System::Reflection::MethodInfo ^ getter, System::Reflection::MethodInfo ^ setter, System::Xaml::XamlSchemaContext ^ schemaContext);" />
      <MemberSignature Language="F#" Value="new System.Xaml.XamlMember : string * System.Reflection.MethodInfo * System.Reflection.MethodInfo * System.Xaml.XamlSchemaContext -&gt; System.Xaml.XamlMember" Usage="new System.Xaml.XamlMember (attachablePropertyName, getter, setter, schemaContext)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="attachablePropertyName" Type="System.String" />
        <Parameter Name="getter" Type="System.Reflection.MethodInfo" />
        <Parameter Name="setter" Type="System.Reflection.MethodInfo" />
        <Parameter Name="schemaContext" Type="System.Xaml.XamlSchemaContext" />
      </Parameters>
      <Docs>
        <param name="attachablePropertyName">可附加属性的字符串名称。</param>
        <param name="getter">可附加成员的支持实现的 <see cref="T:System.Reflection.MethodInfo" /> 访问器的 CLR 类型系统 <see langword="get" />。</param>
        <param name="setter">可附加成员的支持实现的 <see cref="T:System.Reflection.MethodInfo" /> 访问器的 CLR 类型系统 <see langword="set" />。</param>
        <param name="schemaContext">用于限定成员的 <see cref="T:System.Xaml.XamlSchemaContext" /> 上下文。</param>
        <summary>针对表示可附加属性的 <see cref="T:System.Xaml.XamlMember" /> 初始化 <see cref="T:System.Xaml.XamlMember" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果成员表示可附加的属性，请使用此构造函数。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XamlMember (string attachableEventName, System.Reflection.MethodInfo adder, System.Xaml.XamlSchemaContext schemaContext, System.Xaml.Schema.XamlMemberInvoker invoker);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string attachableEventName, class System.Reflection.MethodInfo adder, class System.Xaml.XamlSchemaContext schemaContext, class System.Xaml.Schema.XamlMemberInvoker invoker) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.#ctor(System.String,System.Reflection.MethodInfo,System.Xaml.XamlSchemaContext,System.Xaml.Schema.XamlMemberInvoker)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (attachableEventName As String, adder As MethodInfo, schemaContext As XamlSchemaContext, invoker As XamlMemberInvoker)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XamlMember(System::String ^ attachableEventName, System::Reflection::MethodInfo ^ adder, System::Xaml::XamlSchemaContext ^ schemaContext, System::Xaml::Schema::XamlMemberInvoker ^ invoker);" />
      <MemberSignature Language="F#" Value="new System.Xaml.XamlMember : string * System.Reflection.MethodInfo * System.Xaml.XamlSchemaContext * System.Xaml.Schema.XamlMemberInvoker -&gt; System.Xaml.XamlMember" Usage="new System.Xaml.XamlMember (attachableEventName, adder, schemaContext, invoker)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="attachableEventName" Type="System.String" />
        <Parameter Name="adder" Type="System.Reflection.MethodInfo" />
        <Parameter Name="schemaContext" Type="System.Xaml.XamlSchemaContext" />
        <Parameter Name="invoker" Type="System.Xaml.Schema.XamlMemberInvoker" />
      </Parameters>
      <Docs>
        <param name="attachableEventName">可附加事件的字符串名称。</param>
        <param name="adder">可附加成员的支持实现的处理程序 <see cref="T:System.Reflection.MethodInfo" /> 方法的 CLR 类型系统 <see langword="Add" />。</param>
        <param name="schemaContext">用于限定成员的 <see cref="T:System.Xaml.XamlSchemaContext" /> 上下文。</param>
        <param name="invoker">用于针对 <see cref="T:System.Xaml.Schema.XamlMemberInvoker" /> 处理运行时调用的 <see cref="T:System.Xaml.XamlMember" /> 实现。</param>
        <summary>针对表示可附加事件的 <see cref="T:System.Xaml.XamlMember" />（包括 <see cref="T:System.Xaml.XamlMember" /> 信息）初始化 <see cref="T:System.Xaml.Schema.XamlMemberInvoker" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果成员表示可附加的事件成员，请使用此构造函数。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XamlMember (string attachablePropertyName, System.Reflection.MethodInfo getter, System.Reflection.MethodInfo setter, System.Xaml.XamlSchemaContext schemaContext, System.Xaml.Schema.XamlMemberInvoker invoker);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string attachablePropertyName, class System.Reflection.MethodInfo getter, class System.Reflection.MethodInfo setter, class System.Xaml.XamlSchemaContext schemaContext, class System.Xaml.Schema.XamlMemberInvoker invoker) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.#ctor(System.String,System.Reflection.MethodInfo,System.Reflection.MethodInfo,System.Xaml.XamlSchemaContext,System.Xaml.Schema.XamlMemberInvoker)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (attachablePropertyName As String, getter As MethodInfo, setter As MethodInfo, schemaContext As XamlSchemaContext, invoker As XamlMemberInvoker)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XamlMember(System::String ^ attachablePropertyName, System::Reflection::MethodInfo ^ getter, System::Reflection::MethodInfo ^ setter, System::Xaml::XamlSchemaContext ^ schemaContext, System::Xaml::Schema::XamlMemberInvoker ^ invoker);" />
      <MemberSignature Language="F#" Value="new System.Xaml.XamlMember : string * System.Reflection.MethodInfo * System.Reflection.MethodInfo * System.Xaml.XamlSchemaContext * System.Xaml.Schema.XamlMemberInvoker -&gt; System.Xaml.XamlMember" Usage="new System.Xaml.XamlMember (attachablePropertyName, getter, setter, schemaContext, invoker)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="attachablePropertyName" Type="System.String" />
        <Parameter Name="getter" Type="System.Reflection.MethodInfo" />
        <Parameter Name="setter" Type="System.Reflection.MethodInfo" />
        <Parameter Name="schemaContext" Type="System.Xaml.XamlSchemaContext" />
        <Parameter Name="invoker" Type="System.Xaml.Schema.XamlMemberInvoker" />
      </Parameters>
      <Docs>
        <param name="attachablePropertyName">可附加属性的字符串名称。</param>
        <param name="getter">可附加成员的支持实现的 <see cref="T:System.Reflection.MethodInfo" /> 访问器的 CLR 类型系统 <see langword="get" />。</param>
        <param name="setter">可附加成员的支持实现的 <see cref="T:System.Reflection.MethodInfo" /> 访问器的 CLR 类型系统 <see langword="set" />。</param>
        <param name="schemaContext">用于限定成员的 <see cref="T:System.Xaml.XamlSchemaContext" /> 上下文。</param>
        <param name="invoker">用于针对 <see cref="T:System.Xaml.Schema.XamlMemberInvoker" /> 处理运行时调用的 <see cref="T:System.Xaml.XamlMember" /> 实现。</param>
        <summary>针对表示可附加属性的 <see cref="T:System.Xaml.XamlMember" />（包括 <see cref="T:System.Xaml.XamlMember" /> 信息）初始化 <see cref="T:System.Xaml.Schema.XamlMemberInvoker" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果成员表示可附加的属性成员，则使用此构造函数。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DeclaringType">
      <MemberSignature Language="C#" Value="public System.Xaml.XamlType DeclaringType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xaml.XamlType DeclaringType" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.DeclaringType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DeclaringType As XamlType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xaml::XamlType ^ DeclaringType { System::Xaml::XamlType ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DeclaringType : System.Xaml.XamlType" Usage="System.Xaml.XamlMember.DeclaringType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取类型的 <see cref="T:System.Xaml.XamlType" />，该类型声明与此 <see cref="T:System.Xaml.XamlMember" /> 关联的成员。</summary>
        <value>类型的 <see cref="T:System.Xaml.XamlType" />，该类型声明与此 <see cref="T:System.Xaml.XamlMember" /> 关联的成员。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此值通常是在初始化过程中设置的，通常不 `null`。  
  
> [!IMPORTANT]
>  <xref:System.Xaml.XamlMember.DeclaringType%2A> 的信息可由构造函数传入以便进行初始化。 通过将直接调用到基构造函数中，<xref:System.Xaml.XamlMember> 派生类的初始化可能会忽略在基类中进行的一些值检查。 因此，派生的初始化可更改 XAML 成员的已报告类型成员关系信息，使其不再按预期方式与其基础 CLR 声明的类型系统信息对齐。 对于声明类型信息的任何安全关键检查，请改用基础 CLR 类型。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DeferringLoader">
      <MemberSignature Language="C#" Value="public System.Xaml.Schema.XamlValueConverter&lt;System.Xaml.XamlDeferringLoader&gt; DeferringLoader { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xaml.Schema.XamlValueConverter`1&lt;class System.Xaml.XamlDeferringLoader&gt; DeferringLoader" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.DeferringLoader" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DeferringLoader As XamlValueConverter(Of XamlDeferringLoader)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xaml::Schema::XamlValueConverter&lt;System::Xaml::XamlDeferringLoader ^&gt; ^ DeferringLoader { System::Xaml::Schema::XamlValueConverter&lt;System::Xaml::XamlDeferringLoader ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DeferringLoader : System.Xaml.Schema.XamlValueConverter&lt;System.Xaml.XamlDeferringLoader&gt;" Usage="System.Xaml.XamlMember.DeferringLoader" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.Schema.XamlValueConverter&lt;System.Xaml.XamlDeferringLoader&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个 <see cref="T:System.Xaml.Schema.XamlValueConverter`1" /> 对象，该对象用于 XAML 声明的对象的延迟加载。</summary>
        <value>一个对泛型具有 <see cref="T:System.Xaml.Schema.XamlValueConverter`1" /> 约束的 <see cref="T:System.Xaml.XamlDeferringLoader" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 调用 <xref:System.Xaml.XamlMember.DeferringLoader%2A> 将调用该方法的 <xref:System.Xaml.XamlMember.LookupDeferringLoader%2A> 或特定的重写。 在初始内部反射逻辑尚未设置信息的情况下，会发生此行为。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DependsOn">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IList&lt;System.Xaml.XamlMember&gt; DependsOn { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IList`1&lt;class System.Xaml.XamlMember&gt; DependsOn" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.DependsOn" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DependsOn As IList(Of XamlMember)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::IList&lt;System::Xaml::XamlMember ^&gt; ^ DependsOn { System::Collections::Generic::IList&lt;System::Xaml::XamlMember ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DependsOn : System.Collections.Generic.IList&lt;System.Xaml.XamlMember&gt;" Usage="System.Xaml.XamlMember.DependsOn" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;System.Xaml.XamlMember&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取 <see cref="T:System.Xaml.XamlMember" /> 对象的列表。 这些对象报告一些成员，其中的初始化顺序依赖关系相对于此 <see cref="T:System.Xaml.XamlMember" /> 存在。</summary>
        <value>
          <see cref="T:System.Xaml.XamlMember" /> 对象列表。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 调用 <xref:System.Xaml.XamlMember.DependsOn%2A> 将调用该方法的 <xref:System.Xaml.XamlMember.LookupDependsOn%2A> 或特定的重写。 在初始内部反射逻辑尚未设置信息的情况下，会发生此行为。  
  
 `DependsOn` 模式可应用于特意矛盾一般 XAML 规则的对象模型事例。 一般的 XAML 规则是，不能作为初始化文本传递的类型成员（或通过 XAML 2009 中的工厂方法传递的成员）必须能够以任意顺序分配。 通过向成员应用 `DependsOn` 模式，可以指示 XAML 编写器始终处理此成员之前的引用成员。 您可以在以下情况下应用此模式：当前成员的值需要上下文或其他仅在设置其他成员后才可用的信息。  
  
 应慎用 `DependsOn` 模式，为其提供结构化用途的属性方案保留。 大量依赖项可能会减慢 XAML 处理的速度。 此外，还可以生成循环依赖项，在这种情况下，XAML 处理行为是不确定的。  
  
 WPF `DependsOn` 方案的示例包括 <xref:System.Windows.Controls.ControlTemplate> 和 <xref:System.Windows.DataTemplate>上的某些属性、<xref:System.Windows.Trigger>上和上的 <xref:System.Windows.Setter>。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Markup.DependsOnAttribute" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Equals">
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>指示当前对象是否等于另一个对象。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="xamlMember.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">要与此对象进行比较的对象。</param>
        <summary>指示当前对象是否等于另一个对象。</summary>
        <returns>如果当前对象等于 <see langword="true" /> 参数，则为 <paramref name="obj" />；否则为 <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (System.Xaml.XamlMember other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(class System.Xaml.XamlMember other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.Equals(System.Xaml.XamlMember)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (other As XamlMember) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Equals(System::Xaml::XamlMember ^ other);" />
      <MemberSignature Language="F#" Value="override this.Equals : System.Xaml.XamlMember -&gt; bool" Usage="xamlMember.Equals other" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IEquatable`1.Equals(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Xaml.XamlMember" />
      </Parameters>
      <Docs>
        <param name="other">一个与此对象进行比较的对象。</param>
        <summary>指示当前对象是否等于同一类型的另一个对象。</summary>
        <returns>如果当前对象等于 <see langword="true" /> 参数，则为 <paramref name="other" />；否则为 <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="xamlMember.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回此对象的哈希代码。</summary>
        <returns>整数哈希代码。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetXamlNamespaces">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IList&lt;string&gt; GetXamlNamespaces ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IList`1&lt;string&gt; GetXamlNamespaces() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.GetXamlNamespaces" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetXamlNamespaces () As IList(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::Generic::IList&lt;System::String ^&gt; ^ GetXamlNamespaces();" />
      <MemberSignature Language="F#" Value="abstract member GetXamlNamespaces : unit -&gt; System.Collections.Generic.IList&lt;string&gt;&#xA;override this.GetXamlNamespaces : unit -&gt; System.Collections.Generic.IList&lt;string&gt;" Usage="xamlMember.GetXamlNamespaces " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回 XAML 命名空间的列表，此 XAML 成员可能存在于这些命名空间中。</summary>
        <returns>字符串形式的 XAML 命名空间标识符的列表。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 默认实现从与此 <xref:System.Xaml.XamlMember>相关联的 <xref:System.Xaml.XamlMember.DeclaringType%2A> 返回 <xref:System.Xaml.XamlType.GetXamlNamespaces%2A?displayProperty=nameWithType> 调用结果。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Invoker">
      <MemberSignature Language="C#" Value="public System.Xaml.Schema.XamlMemberInvoker Invoker { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xaml.Schema.XamlMemberInvoker Invoker" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.Invoker" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Invoker As XamlMemberInvoker" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xaml::Schema::XamlMemberInvoker ^ Invoker { System::Xaml::Schema::XamlMemberInvoker ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Invoker : System.Xaml.Schema.XamlMemberInvoker" Usage="System.Xaml.XamlMember.Invoker" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.Schema.XamlMemberInvoker</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取与此 <see cref="T:System.Xaml.Schema.XamlMemberInvoker" /> 关联的 <see cref="T:System.Xaml.XamlMember" /> 实现。</summary>
        <value>与此 <see cref="T:System.Xaml.Schema.XamlMemberInvoker" /> 关联的 <see cref="T:System.Xaml.XamlMember" /> 实现。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Invoker` 模式是一种高级的 XAML 类型系统扩展技术。 `Invoker` 模式提供了一种方法，用于注入不同的架构类型映射行为，同时仍然使用 .NET Framework XAML 服务中的 XAML 类型系统定义。  
  
 如果 <xref:System.Xaml.XamlMember.LookupInvoker%2A> 重写返回 `null`，或如果默认实现返回 `null`，因为它缺少此 <xref:System.Xaml.XamlMember>的 <xref:System.Xaml.XamlMember.UnderlyingMember%2A>，<xref:System.Xaml.XamlMember.Invoker%2A> 属性返回 <xref:System.Xaml.Schema.XamlMemberInvoker.UnknownInvoker%2A?displayProperty=nameWithType>。  
  
 <xref:System.Xaml.Schema.XamlMemberInvoker.UnknownInvoker%2A?displayProperty=nameWithType> 为默认值。 这适用于大多数使用 .NET Framework XAML 服务和默认 XAML 架构上下文的操作，并且没有为 XAML 类型系统实体的构造传递特定的重写 `Invoker` 模式。  
  
 调用 <xref:System.Xaml.XamlMember.Invoker%2A> 将调用该方法的 <xref:System.Xaml.XamlMember.LookupInvoker%2A> 或特定的重写。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsAmbient">
      <MemberSignature Language="C#" Value="public bool IsAmbient { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAmbient" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.IsAmbient" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAmbient As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAmbient { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAmbient : bool" Usage="System.Xaml.XamlMember.IsAmbient" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示是否将此 <see cref="T:System.Xaml.XamlMember" /> 报告为一个环境属性。</summary>
        <value>如果将此 <see langword="true" /> 报告为环境属性，则为 <see cref="T:System.Xaml.XamlMember" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 调用 <xref:System.Xaml.XamlMember.IsAmbient%2A> 将调用该方法的 <xref:System.Xaml.XamlMember.LookupIsAmbient%2A> 或特定的重写。 此行为发生在初始内部反射逻辑尚未设置信息的实现中。  
  
 检查环境属性通常是 XAML 处理逻辑的一部分，以确保依赖于类型限定的环境使用的对象和值可以正常工作。 .NET Framework XAML 服务 Api 和默认的 XAML 架构上下文基于具有 <xref:System.Windows.Markup.AmbientAttribute>的特性填充此值。 <xref:System.Xaml.XamlMember.LookupIsAmbient%2A> 的默认实现使用这一现有 <xref:System.Windows.Markup.AmbientAttribute> 方法，如果 <xref:System.Windows.Markup.AmbientAttribute> 存在于成员声明中，它将返回 `true`。  
  
 在多个 WPF 类型的成员（包括 <xref:System.Windows.Application>、<xref:System.Windows.Setter>和 <xref:System.Windows.Style>）上找到 <xref:System.Windows.Markup.AmbientAttribute>。 它也可以在 <xref:System.Windows.ResourceDictionary> 类型上找到，该类型隐含任何使用 <xref:System.Windows.ResourceDictionary> 作为其类型的成员都应被视为环境，即使成员并未专门进行特性化。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Markup.AmbientAttribute" />
      </Docs>
    </Member>
    <Member MemberName="IsAttachable">
      <MemberSignature Language="C#" Value="public bool IsAttachable { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAttachable" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.IsAttachable" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAttachable As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAttachable { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAttachable : bool" Usage="System.Xaml.XamlMember.IsAttachable" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示此 <see cref="T:System.Xaml.XamlMember" /> 是否为可附加成员。</summary>
        <value>如果此 <see langword="true" /> 是可附加成员，则为 <see cref="T:System.Xaml.XamlMember" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 根据用来构造 <xref:System.Xaml.XamlMember>的构造函数初始化 <xref:System.Xaml.XamlMember.IsAttachable%2A> 值。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsDirective">
      <MemberSignature Language="C#" Value="public bool IsDirective { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsDirective" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.IsDirective" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsDirective As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsDirective { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsDirective : bool" Usage="System.Xaml.XamlMember.IsDirective" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示此 <see cref="T:System.Xaml.XamlMember" /> 是否为 XAML 指令。</summary>
        <value>如果此 <see langword="true" /> 是 XAML 指令，则为 <see cref="T:System.Xaml.XamlMember" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 根据用来构造 <xref:System.Xaml.XamlMember>的构造函数初始化 <xref:System.Xaml.XamlMember.IsDirective%2A> 值。 基本 <xref:System.Xaml.XamlMember> 构造函数将初始化，以便 `false`<xref:System.Xaml.XamlMember.IsDirective%2A>。 但是，<xref:System.Xaml.XamlDirective> 类（<xref:System.Xaml.XamlMember> 派生类）将初始化，以便 `true`<xref:System.Xaml.XamlMember.IsDirective%2A>。  
  
 如果要将 <xref:System.Xaml.XamlMember.IsDirective%2A> 报告为 XAML 成员的自定义 XAML 架构类的调用方 `true`，请确保从 <xref:System.Xaml.XamlDirective> 派生，因为这是启用该行为的唯一方法。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsEvent">
      <MemberSignature Language="C#" Value="public bool IsEvent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsEvent" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.IsEvent" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsEvent As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsEvent { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsEvent : bool" Usage="System.Xaml.XamlMember.IsEvent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示此 <see cref="T:System.Xaml.XamlMember" /> 是否表示事件成员。</summary>
        <value>如果此 <see langword="true" /> 表示事件，则为 <see cref="T:System.Xaml.XamlMember" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 调用 <xref:System.Xaml.XamlMember.IsEvent%2A> 将调用该方法的 <xref:System.Xaml.XamlMember.LookupIsEvent%2A> 或特定的重写。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsNameValid">
      <MemberSignature Language="C#" Value="public bool IsNameValid { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNameValid" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.IsNameValid" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNameValid As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNameValid { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNameValid : bool" Usage="System.Xaml.XamlMember.IsNameValid" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示是否使用有效的 <see cref="T:System.Xaml.XamlMember" /> 字符串作为其 <see langword="xamlName" /> 来初始化此 <see cref="P:System.Xaml.XamlMember.Name" />。</summary>
        <value>如果使用有效的 <see langword="true" /> 字符串来初始化此 <see cref="T:System.Xaml.XamlMember" />，则为 <see langword="xamlName" />；否则为 <see langword="false" />。</value>
        <remarks>To be added.</remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/11e4cada-41d2-494d-9531-0d3df4dfcbe3">XamlName</related>
      </Docs>
    </Member>
    <Member MemberName="IsReadOnly">
      <MemberSignature Language="C#" Value="public bool IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.IsReadOnly" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsReadOnly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsReadOnly { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsReadOnly : bool" Usage="System.Xaml.XamlMember.IsReadOnly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示此 <see cref="T:System.Xaml.XamlMember" /> 是否表示只读成员。</summary>
        <value>如果此 <see langword="true" /> 表示只读成员，则为 <see cref="T:System.Xaml.XamlMember" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 调用 <xref:System.Xaml.XamlMember.IsReadOnly%2A> 将调用该方法的 <xref:System.Xaml.XamlMember.LookupIsReadOnly%2A> 或特定的重写。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsReadPublic">
      <MemberSignature Language="C#" Value="public bool IsReadPublic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsReadPublic" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.IsReadPublic" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsReadPublic As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsReadPublic { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsReadPublic : bool" Usage="System.Xaml.XamlMember.IsReadPublic" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示此 <see cref="T:System.Xaml.XamlMember" /> 是否表示一个具有可调用公共 <see langword="get" /> 访问器的成员。</summary>
        <value>如果此 <see langword="true" /> 表示可调用公共 <see cref="T:System.Xaml.XamlMember" /> 访问器，则为 <see langword="get" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Xaml.XamlMember.IsReadPublic%2A> 值检查 <xref:System.Xaml.XamlMember.DeclaringType%2A> 是否为公共的。 如果 <xref:System.Xaml.XamlMember.DeclaringType%2A> 不是公共的，则 `get` 访问器无法以实用方式调用，<xref:System.Xaml.XamlMember.IsReadPublic%2A> 返回 `false`。  
  
 调用 <xref:System.Xaml.XamlMember.IsReadPublic%2A> 将调用该方法的 <xref:System.Xaml.XamlMember.LookupIsReadPublic%2A> 或特定的重写。  
  
> [!IMPORTANT]
>  <xref:System.Xaml.XamlMember.LookupIsReadPublic%2A> 方法是虚拟的，因此可以重写。 重写可能会更改（恶意或其他）已报告的 XAML 成员访问信息，使其不再以预期方式与其基础 CLR 声明的类型系统访问信息对齐。 对于访问级别的任何安全关键检查，请改用基础 CLR 类型。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsUnknown">
      <MemberSignature Language="C#" Value="public bool IsUnknown { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsUnknown" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.IsUnknown" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsUnknown As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsUnknown { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsUnknown : bool" Usage="System.Xaml.XamlMember.IsUnknown" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示用于类型和成员解析的支持系统是否无法解析成员。</summary>
        <value>如果成员不可解析，则为 <see langword="true" />；如果成员可解析，则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用 <xref:System.Xaml.XamlMember.%23ctor%28System.String%2CSystem.Xaml.XamlType%2CSystem.Boolean%29> 签名构造的 <xref:System.Xaml.XamlMember> 将为 <xref:System.Xaml.XamlMember.IsUnknown%2A>返回 `true`。  
  
 对于涉及 <xref:System.Xaml.XamlObjectWriter>的加载路径，无法将 <xref:System.Xaml.XamlMember.IsUnknown%2A> `true` 的 <xref:System.Xaml.XamlMember> 写入对象关系图。 在 .NET Framework XAML 服务 Api 中的默认实现下，如果 `true` 的相关 <xref:System.Xaml.XamlMember> 报表 <xref:System.Xaml.XamlMember.IsUnknown%2A>，则 <xref:System.Xaml.XamlObjectWriter.WriteStartMember%2A?displayProperty=nameWithType> 调用将引发一个 <xref:System.Xaml.XamlObjectWriterException>。  
  
 您不应构造 `true` 的值为 <xref:System.Xaml.XamlMember.IsUnknown%2A> 的 <xref:System.Xaml.XamlMember>，除非您的实现可以处理 <xref:System.Xaml.XamlObjectWriter>中的异常，或者您可以使用其他方法来调整 <xref:System.Xaml.XamlObjectWriter> 行为。  
  
 调用 <xref:System.Xaml.XamlMember.IsUnknown%2A> 将调用该方法的 <xref:System.Xaml.XamlMember.LookupIsUnknown%2A> 或特定的重写。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsWriteOnly">
      <MemberSignature Language="C#" Value="public bool IsWriteOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsWriteOnly" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.IsWriteOnly" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsWriteOnly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsWriteOnly { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsWriteOnly : bool" Usage="System.Xaml.XamlMember.IsWriteOnly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示此 <see cref="T:System.Xaml.XamlMember" /> 是否表示只写成员。</summary>
        <value>如果此 <see langword="true" /> 表示只写成员，则为 <see cref="T:System.Xaml.XamlMember" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 调用 <xref:System.Xaml.XamlMember.IsWriteOnly%2A> 将调用该方法的 <xref:System.Xaml.XamlMember.LookupIsWriteOnly%2A> 或特定的重写。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsWritePublic">
      <MemberSignature Language="C#" Value="public bool IsWritePublic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsWritePublic" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.IsWritePublic" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsWritePublic As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsWritePublic { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsWritePublic : bool" Usage="System.Xaml.XamlMember.IsWritePublic" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示此 <see cref="T:System.Xaml.XamlMember" /> 是否表示一个具有可调用公共 <see langword="set" /> 访问器的成员。</summary>
        <value>如果此 <see langword="true" /> 表示可调用公共 <see cref="T:System.Xaml.XamlMember" /> 访问器，则为 <see langword="set" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Xaml.XamlMember.IsWritePublic%2A> 值决定了 <xref:System.Xaml.XamlMember.DeclaringType%2A> 是否作为确定的一部分公开。 如果 <xref:System.Xaml.XamlMember.DeclaringType%2A> 不是公共的，则 `set` 访问器无法以实用方式调用，<xref:System.Xaml.XamlMember.IsWritePublic%2A> 返回 `false`。  
  
 调用 <xref:System.Xaml.XamlMember.IsWritePublic%2A> 将调用该方法的 <xref:System.Xaml.XamlMember.LookupIsWritePublic%2A> 或特定的重写。  
  
> [!IMPORTANT]
>  <xref:System.Xaml.XamlMember.LookupIsWritePublic%2A> 方法是虚拟的，因此可以重写。 重写可能会更改（恶意或其他）已报告的 XAML 成员访问信息，使其不再以预期方式与其基础 CLR 声明的类型系统访问信息对齐。 对于访问级别的任何安全关键检查，请改用基础 CLR 类型。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupCustomAttributeProvider">
      <MemberSignature Language="C#" Value="protected virtual System.Reflection.ICustomAttributeProvider LookupCustomAttributeProvider ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.ICustomAttributeProvider LookupCustomAttributeProvider() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupCustomAttributeProvider" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupCustomAttributeProvider () As ICustomAttributeProvider" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Reflection::ICustomAttributeProvider ^ LookupCustomAttributeProvider();" />
      <MemberSignature Language="F#" Value="abstract member LookupCustomAttributeProvider : unit -&gt; System.Reflection.ICustomAttributeProvider&#xA;override this.LookupCustomAttributeProvider : unit -&gt; System.Reflection.ICustomAttributeProvider" Usage="xamlMember.LookupCustomAttributeProvider " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.ICustomAttributeProvider</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>在派生类中实现时，返回 <see cref="T:System.Reflection.ICustomAttributeProvider" /> 实现。</summary>
        <returns><see cref="T:System.Reflection.ICustomAttributeProvider" /> 实现。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 重写此方法以使用替代方法获取内部反射，以获取 CLR 特性值。 在没有重写的情况下，内部反射器使用典型的 CLR 反射逻辑，如调用 <xref:System.Reflection.CustomAttributeData.GetCustomAttributes%2A>。  
  
 默认实现返回 `null`。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupDeferringLoader">
      <MemberSignature Language="C#" Value="protected virtual System.Xaml.Schema.XamlValueConverter&lt;System.Xaml.XamlDeferringLoader&gt; LookupDeferringLoader ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Xaml.Schema.XamlValueConverter`1&lt;class System.Xaml.XamlDeferringLoader&gt; LookupDeferringLoader() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupDeferringLoader" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupDeferringLoader () As XamlValueConverter(Of XamlDeferringLoader)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Xaml::Schema::XamlValueConverter&lt;System::Xaml::XamlDeferringLoader ^&gt; ^ LookupDeferringLoader();" />
      <MemberSignature Language="F#" Value="abstract member LookupDeferringLoader : unit -&gt; System.Xaml.Schema.XamlValueConverter&lt;System.Xaml.XamlDeferringLoader&gt;&#xA;override this.LookupDeferringLoader : unit -&gt; System.Xaml.Schema.XamlValueConverter&lt;System.Xaml.XamlDeferringLoader&gt;" Usage="xamlMember.LookupDeferringLoader " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.Schema.XamlValueConverter&lt;System.Xaml.XamlDeferringLoader&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回一个 <see cref="T:System.Xaml.Schema.XamlValueConverter`1" /> 对象，该对象用于 XAML 声明的对象的延迟加载。</summary>
        <returns>对泛型具有 <see cref="T:System.Xaml.Schema.XamlValueConverter`1" /> 约束的 <see cref="T:System.Xaml.XamlDeferringLoader" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当调用方从 <xref:System.Xaml.XamlMember.DeferringLoader%2A> 属性获取值时，将调用此方法。 如果希望 <xref:System.Xaml.XamlMember.DeferringLoader%2A> 返回与默认内部反射启用的值不同的值，并且还提供自定义的 <xref:System.Xaml.Schema.XamlMemberInvoker> 信息，请重写此方法。  
  
 默认实现通过读取 <xref:System.Windows.Markup.XamlDeferLoadAttribute> 或使用声明类型中的 <xref:System.Xaml.XamlDeferringLoader> 来返回对象。 如果这两个对象均不可用，则此方法可能会返回 `null`。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Xaml.XamlMember.DeferringLoader" />
      </Docs>
    </Member>
    <Member MemberName="LookupDependsOn">
      <MemberSignature Language="C#" Value="protected virtual System.Collections.Generic.IList&lt;System.Xaml.XamlMember&gt; LookupDependsOn ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Collections.Generic.IList`1&lt;class System.Xaml.XamlMember&gt; LookupDependsOn() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupDependsOn" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupDependsOn () As IList(Of XamlMember)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Collections::Generic::IList&lt;System::Xaml::XamlMember ^&gt; ^ LookupDependsOn();" />
      <MemberSignature Language="F#" Value="abstract member LookupDependsOn : unit -&gt; System.Collections.Generic.IList&lt;System.Xaml.XamlMember&gt;&#xA;override this.LookupDependsOn : unit -&gt; System.Collections.Generic.IList&lt;System.Xaml.XamlMember&gt;" Usage="xamlMember.LookupDependsOn " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;System.Xaml.XamlMember&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回 <see cref="T:System.Xaml.XamlMember" /> 对象的列表。 此列表中的项报告一些成员，其中的初始化顺序依赖关系相对于此 <see cref="T:System.Xaml.XamlMember" /> 存在。</summary>
        <returns>
          <see cref="T:System.Xaml.XamlMember" /> 对象列表。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当调用方从 <xref:System.Xaml.XamlMember.DependsOn%2A> 属性获取值时，将调用此方法。 如果希望 <xref:System.Xaml.XamlMember.DependsOn%2A> 返回与默认内部反射启用的值不同的值，并且还提供自定义的 <xref:System.Xaml.Schema.XamlMemberInvoker> 信息，请重写此方法。  
  
 WPF XAML 读取器和编写器实现将此用例与 <xref:System.Windows.Markup.DependsOnAttribute>特性。 默认实现使用这种现有 <xref:System.Windows.Markup.DependsOnAttribute> 方法。  
  
 如果未将 <xref:System.Windows.Markup.DependsOnAttribute> 用于此目的，并且打算使用自己的方法替换指示属性处理顺序的方法，请重写此方法。 如果不打算支持属性处理顺序，则可以使用默认实现，因为它不返回任何适当的结果。  
  
 列表为只读。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Xaml.XamlMember.DependsOn" />
      </Docs>
    </Member>
    <Member MemberName="LookupInvoker">
      <MemberSignature Language="C#" Value="protected virtual System.Xaml.Schema.XamlMemberInvoker LookupInvoker ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Xaml.Schema.XamlMemberInvoker LookupInvoker() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupInvoker" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupInvoker () As XamlMemberInvoker" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Xaml::Schema::XamlMemberInvoker ^ LookupInvoker();" />
      <MemberSignature Language="F#" Value="abstract member LookupInvoker : unit -&gt; System.Xaml.Schema.XamlMemberInvoker&#xA;override this.LookupInvoker : unit -&gt; System.Xaml.Schema.XamlMemberInvoker" Usage="xamlMember.LookupInvoker " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.Schema.XamlMemberInvoker</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回与此 <see cref="T:System.Xaml.Schema.XamlMemberInvoker" /> 关联的 <see cref="T:System.Xaml.XamlMember" />。</summary>
        <returns>此 <see cref="T:System.Xaml.Schema.XamlMemberInvoker" /> 的 <see cref="T:System.Xaml.XamlMember" /> 信息；或者为 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法通过调用 <xref:System.Xaml.XamlMember.Invoker%2A>调用。  
  
 默认实现不要求使用传递初始 <xref:System.Xaml.Schema.XamlMemberInvoker>的构造函数之一来构造 <xref:System.Xaml.XamlMember>。 但 <xref:System.Xaml.XamlMember>必须存在 <xref:System.Xaml.XamlMember.UnderlyingMember%2A> 值;否则，默认实现返回 `null`。  
  
 如果也派生自 <xref:System.Xaml.Schema.XamlMemberInvoker> 并且打算返回派生类，请重写此方法。 如果返回 `null`，<xref:System.Xaml.XamlMember.Invoker%2A> 将 <xref:System.Xaml.Schema.XamlMemberInvoker.UnknownInvoker%2A?displayProperty=nameWithType> 返回到调用方。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Xaml.XamlMember.Invoker" />
        <altmember cref="T:System.Xaml.Schema.XamlMemberInvoker" />
      </Docs>
    </Member>
    <Member MemberName="LookupIsAmbient">
      <MemberSignature Language="C#" Value="protected virtual bool LookupIsAmbient ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool LookupIsAmbient() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupIsAmbient" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupIsAmbient () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool LookupIsAmbient();" />
      <MemberSignature Language="F#" Value="abstract member LookupIsAmbient : unit -&gt; bool&#xA;override this.LookupIsAmbient : unit -&gt; bool" Usage="xamlMember.LookupIsAmbient " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回的值指示是否将此 <see cref="T:System.Xaml.XamlMember" /> 作为环境属性报告。</summary>
        <returns>如果要将此 <see langword="true" /> 报告为环境属性，则为 <see cref="T:System.Xaml.XamlMember" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法由检查环境 XAML 属性信息的内部调用调用。 环境属性行为在 XAML 读取器和 XAML 编写器的公共 API 行为中进行考虑。 引用 <xref:System.Xaml.XamlMember.LookupIsAmbient%2A> 的内部调用通常是 XAML 处理逻辑的一部分，以确保依赖于类型限定的环境使用的对象和值可以正常工作。 XAML 服务实现的默认 .NET Framework 使用 CLR 特性化，以通过支持类型的反射获取此信息。 具体而言，默认实现将检查 <xref:System.Windows.Markup.AmbientAttribute> 并返回 <xref:System.Xaml.XamlMember.LookupIsAmbient%2A> 的 `true` 如果成员定义上存在 <xref:System.Windows.Markup.AmbientAttribute>。  
  
 如果未将 <xref:System.Windows.Markup.AmbientAttribute> 用于此目的，并且打算使用自己的方法替换指示环境 XAML 属性的该方法，请重写此方法。  
  
 WPF 中具有 <xref:System.Windows.Markup.AmbientAttribute> 属性的示例 Api <xref:System.Windows.Trigger.Property%2A?displayProperty=nameWithType> 和 <xref:System.Windows.Style.BasedOn%2A?displayProperty=nameWithType>。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Markup.AmbientAttribute" />
      </Docs>
    </Member>
    <Member MemberName="LookupIsEvent">
      <MemberSignature Language="C#" Value="protected virtual bool LookupIsEvent ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool LookupIsEvent() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupIsEvent" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupIsEvent () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool LookupIsEvent();" />
      <MemberSignature Language="F#" Value="abstract member LookupIsEvent : unit -&gt; bool&#xA;override this.LookupIsEvent : unit -&gt; bool" Usage="xamlMember.LookupIsEvent " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回的值指示此 <see cref="T:System.Xaml.XamlMember" /> 是否表示一个事件。</summary>
        <returns>如果要报告此 <see langword="true" /> 表示事件，则为 <see cref="T:System.Xaml.XamlMember" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 默认实现检查 <xref:System.Xaml.XamlMember.UnderlyingMember%2A> 是否为类型 <xref:System.Reflection.EventInfo>，如果是，则返回 `true`。  
  
 当调用方从 <xref:System.Xaml.XamlMember.IsEvent%2A>获取值时，将调用此方法。 如果要为整个 <xref:System.Xaml.XamlMember> 派生类报告统一的结果，或者您具有可用的专用元数据（可根据每种情况解释为确定 XAML 类型系统表示形式），请重写此方法。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Xaml.XamlMember.IsEvent" />
      </Docs>
    </Member>
    <Member MemberName="LookupIsReadOnly">
      <MemberSignature Language="C#" Value="protected virtual bool LookupIsReadOnly ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool LookupIsReadOnly() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupIsReadOnly" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupIsReadOnly () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool LookupIsReadOnly();" />
      <MemberSignature Language="F#" Value="abstract member LookupIsReadOnly : unit -&gt; bool&#xA;override this.LookupIsReadOnly : unit -&gt; bool" Usage="xamlMember.LookupIsReadOnly " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回的值指示此 <see cref="T:System.Xaml.XamlMember" /> 是否表示预期的只读属性。</summary>
        <returns>如果要将此 <see langword="true" /> 报告为预期的只读属性，则为 <see cref="T:System.Xaml.XamlMember" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果 <xref:System.Xaml.XamlMember.UnderlyingMember%2A> 存在，则默认实现将返回 `true`，但对于此实现，不存在公共 `set` 访问器，这是由内部反射确定的。  
  
 当调用方从 <xref:System.Xaml.XamlMember.IsReadOnly%2A>获取值时，将调用此方法。 如果要为整个 <xref:System.Xaml.XamlMember> 派生类报告统一的结果，或者您具有可用的专用元数据（可根据每种情况解释为确定 XAML 类型系统表示形式），请重写此方法。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Xaml.XamlMember.IsReadOnly" />
      </Docs>
    </Member>
    <Member MemberName="LookupIsReadPublic">
      <MemberSignature Language="C#" Value="protected virtual bool LookupIsReadPublic ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool LookupIsReadPublic() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupIsReadPublic" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupIsReadPublic () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool LookupIsReadPublic();" />
      <MemberSignature Language="F#" Value="abstract member LookupIsReadPublic : unit -&gt; bool&#xA;override this.LookupIsReadPublic : unit -&gt; bool" Usage="xamlMember.LookupIsReadPublic " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回的值指示此 <see cref="T:System.Xaml.XamlMember" /> 是否表示一个具有公共 <see langword="get" /> 访问器的属性。</summary>
        <returns>如果此 <see langword="true" /> 表示具有公共 <see cref="T:System.Xaml.XamlMember" /> 访问器的属性，则为 <see langword="get" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 默认实现返回基于内部反射或非 <xref:System.Xaml.XamlMember.IsWriteOnly%2A>的结果，并按该顺序进行处理。  
  
 <xref:System.Xaml.XamlMember.LookupIsReadPublic%2A> 返回成员本身是否为公共的;它为非公共声明类型上的公共成员返回 `true`。 如果还想要考虑声明类型的可见性，请改用 <xref:System.Xaml.XamlMember.IsReadPublic%2A>。  
  
 当调用方从 <xref:System.Xaml.XamlMember.IsReadPublic%2A>获取值时，将调用此方法。 如果您想要报告整个 <xref:System.Xaml.XamlMember> 派生类的统一结果，或者您有可用于根据每种情况确定这一点的专用元数据，请重写此方法。  
  
> [!IMPORTANT]
>  <xref:System.Xaml.XamlMember.LookupIsReadPublic%2A> 方法是虚拟的，因此可以重写。 重写可能会更改（恶意或其他）已报告的 XAML 成员访问信息，使其不再以预期方式与其基础 CLR 声明的类型系统访问信息对齐。 对于访问级别的任何安全关键检查，请改用基础 CLR 类型。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Xaml.XamlMember.IsReadPublic" />
      </Docs>
    </Member>
    <Member MemberName="LookupIsUnknown">
      <MemberSignature Language="C#" Value="protected virtual bool LookupIsUnknown ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool LookupIsUnknown() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupIsUnknown" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupIsUnknown () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool LookupIsUnknown();" />
      <MemberSignature Language="F#" Value="abstract member LookupIsUnknown : unit -&gt; bool&#xA;override this.LookupIsUnknown : unit -&gt; bool" Usage="xamlMember.LookupIsUnknown " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回的值指示此 <see cref="T:System.Xaml.XamlMember" /> 是否表示一个用于类型和成员解析的支持系统无法解析的成员。</summary>
        <returns>如果此 <see langword="true" /> 表示不可解析的成员，则为 <see cref="T:System.Xaml.XamlMember" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当调用方从 <xref:System.Xaml.XamlMember.IsUnknown%2A>获取值时，可以调用此方法。 默认实现返回基于内部反射或检查 <xref:System.Xaml.XamlMember.UnderlyingMember%2A>`null` 值的结果，以该顺序进行处理。  
  
 如果您想要报告整个 <xref:System.Xaml.XamlMember> 派生类的统一结果，或者您有可用于根据每种情况确定这一点的专用元数据，请重写此方法。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Xaml.XamlMember.IsUnknown" />
      </Docs>
    </Member>
    <Member MemberName="LookupIsWriteOnly">
      <MemberSignature Language="C#" Value="protected virtual bool LookupIsWriteOnly ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool LookupIsWriteOnly() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupIsWriteOnly" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupIsWriteOnly () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool LookupIsWriteOnly();" />
      <MemberSignature Language="F#" Value="abstract member LookupIsWriteOnly : unit -&gt; bool&#xA;override this.LookupIsWriteOnly : unit -&gt; bool" Usage="xamlMember.LookupIsWriteOnly " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回的值指示此 <see cref="T:System.Xaml.XamlMember" /> 是否表示一个具有公共 <see langword="set" /> 访问器但没有公共 <see langword="get" /> 访问器的成员。</summary>
        <returns>如果此 <see langword="true" /> 表示只写成员，则为 <see cref="T:System.Xaml.XamlMember" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果存在具有公共 `set` 访问器和非公共 `get` 访问器的 <xref:System.Xaml.XamlMember.UnderlyingMember%2A> （由内部反射确定），则默认实现将返回 `true`。  
  
 当调用方从 <xref:System.Xaml.XamlMember.IsWriteOnly%2A>获取值时，将调用此方法。 如果您想要报告整个 <xref:System.Xaml.XamlMember> 派生类的统一结果，或者您有可用于根据每种情况确定这一点的专用元数据，请重写此方法。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Xaml.XamlMember.IsWriteOnly" />
      </Docs>
    </Member>
    <Member MemberName="LookupIsWritePublic">
      <MemberSignature Language="C#" Value="protected virtual bool LookupIsWritePublic ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool LookupIsWritePublic() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupIsWritePublic" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupIsWritePublic () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool LookupIsWritePublic();" />
      <MemberSignature Language="F#" Value="abstract member LookupIsWritePublic : unit -&gt; bool&#xA;override this.LookupIsWritePublic : unit -&gt; bool" Usage="xamlMember.LookupIsWritePublic " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回的值指示此 <see cref="T:System.Xaml.XamlMember" /> 是否表示一个具有公共 <see langword="set" /> 访问器的成员。</summary>
        <returns>如果此 <see langword="true" /> 表示可写成员，则为 <see cref="T:System.Xaml.XamlMember" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 默认实现根据内部反射或反运算返回结果，并按该顺序进行处理 <xref:System.Xaml.XamlMember.IsReadOnly%2A>。  
  
 当调用方从 <xref:System.Xaml.XamlMember.IsWritePublic%2A>获取值时，将调用此方法。 如果您想要报告整个 <xref:System.Xaml.XamlMember> 派生类的统一结果，或者您有可用于根据每种情况确定这一点的专用元数据，请重写此方法。  
  
> [!IMPORTANT]
>  <xref:System.Xaml.XamlMember.LookupIsWritePublic%2A> 方法是虚拟的，因此可以重写。 重写可能会更改（恶意或其他）已报告的 XAML 成员访问信息，使其不再以预期方式与其基础 CLR 声明的类型系统访问信息对齐。 对于访问级别的任何安全关键检查，请改用基础 CLR 类型。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Xaml.XamlMember.IsWritePublic" />
      </Docs>
    </Member>
    <Member MemberName="LookupMarkupExtensionBracketCharacters">
      <MemberSignature Language="C#" Value="protected virtual System.Collections.Generic.IReadOnlyDictionary&lt;char,char&gt; LookupMarkupExtensionBracketCharacters ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Collections.Generic.IReadOnlyDictionary`2&lt;char, char&gt; LookupMarkupExtensionBracketCharacters() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupMarkupExtensionBracketCharacters" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupMarkupExtensionBracketCharacters () As IReadOnlyDictionary(Of Char, Char)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Collections::Generic::IReadOnlyDictionary&lt;char, char&gt; ^ LookupMarkupExtensionBracketCharacters();" />
      <MemberSignature Language="F#" Value="abstract member LookupMarkupExtensionBracketCharacters : unit -&gt; System.Collections.Generic.IReadOnlyDictionary&lt;char, char&gt;&#xA;override this.LookupMarkupExtensionBracketCharacters : unit -&gt; System.Collections.Generic.IReadOnlyDictionary&lt;char, char&gt;" Usage="xamlMember.LookupMarkupExtensionBracketCharacters " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IReadOnlyDictionary&lt;System.Char,System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回标记扩展的开始和结束括号字符。</summary>
        <returns>包含开始和结束括号字符的集合。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupTargetType">
      <MemberSignature Language="C#" Value="protected virtual System.Xaml.XamlType LookupTargetType ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Xaml.XamlType LookupTargetType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupTargetType" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupTargetType () As XamlType" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Xaml::XamlType ^ LookupTargetType();" />
      <MemberSignature Language="F#" Value="abstract member LookupTargetType : unit -&gt; System.Xaml.XamlType&#xA;override this.LookupTargetType : unit -&gt; System.Xaml.XamlType" Usage="xamlMember.LookupTargetType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlType</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回其中可能存在 <see cref="T:System.Xaml.XamlType" /> 的类型的 <see cref="T:System.Xaml.XamlMember" />。</summary>
        <returns>其中可能存在 <see cref="T:System.Xaml.XamlMember" /> 的类型。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 默认实现可区分可附加和不可附加的成员。 对于不可附加的成员，<xref:System.Xaml.XamlMember.LookupTargetType%2A> 始终返回 <xref:System.Xaml.XamlMember.DeclaringType%2A>。 对于可附加成员，<xref:System.Xaml.XamlMember.LookupTargetType%2A> 返回基于检查 <xref:System.Xaml.XamlMember.UnderlyingMember%2A> 访问器参数类型的结果，并基于 XAML 架构上下文解释该类型。  
  
 当调用方从 <xref:System.Xaml.XamlMember.TargetType%2A>获取值时，将调用此方法。 如果您想要报告整个 <xref:System.Xaml.XamlMember> 派生类的统一结果，或者您有可用于根据每种情况确定这一点的专用元数据，请重写此方法。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Xaml.XamlMember.TargetType" />
      </Docs>
    </Member>
    <Member MemberName="LookupType">
      <MemberSignature Language="C#" Value="protected virtual System.Xaml.XamlType LookupType ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Xaml.XamlType LookupType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupType" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupType () As XamlType" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Xaml::XamlType ^ LookupType();" />
      <MemberSignature Language="F#" Value="abstract member LookupType : unit -&gt; System.Xaml.XamlType&#xA;override this.LookupType : unit -&gt; System.Xaml.XamlType" Usage="xamlMember.LookupType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlType</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回成员所使用的类型的 <see cref="T:System.Xaml.XamlType" />。</summary>
        <returns>成员所使用的类型的 <see cref="T:System.Xaml.XamlType" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当调用方从 <xref:System.Xaml.XamlMember.Type%2A>获取值时，将调用此方法。 如果希望 <xref:System.Xaml.XamlMember.Type%2A> 返回与默认内部反射启用的值不同的值，并且还提供自定义的 <xref:System.Xaml.Schema.XamlMemberInvoker> 信息，请重写此方法。  
  
 默认实现对返回的 <xref:System.Xaml.XamlType> 使用不同的代码路径和概念含义，具体取决于此 <xref:System.Xaml.XamlMember> 是否表示属性、方法或事件。  
  
-   对于属性，返回的 <xref:System.Xaml.XamlType> 是设置属性或由属性返回的类型。  
  
-   对于事件，返回的 <xref:System.Xaml.XamlType> 是必需的事件处理程序类型（CLR 实现中的委托）。  
  
-   对于方法，<xref:System.Xaml.XamlType> 是返回类型。  
  
 在每种情况下，XAML 架构上下文用于计算基础系统类型的 XAML 类型。  
  
 当调用方从 <xref:System.Xaml.XamlMember.Type%2A>获取值时，将调用此方法。 如果您想要报告整个 <xref:System.Xaml.XamlMember> 派生类的统一结果，或者您有可用于根据每种情况确定这一点的专用元数据，请重写此方法。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Xaml.XamlMember.Type" />
      </Docs>
    </Member>
    <Member MemberName="LookupTypeConverter">
      <MemberSignature Language="C#" Value="protected virtual System.Xaml.Schema.XamlValueConverter&lt;System.ComponentModel.TypeConverter&gt; LookupTypeConverter ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Xaml.Schema.XamlValueConverter`1&lt;class System.ComponentModel.TypeConverter&gt; LookupTypeConverter() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupTypeConverter" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupTypeConverter () As XamlValueConverter(Of TypeConverter)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Xaml::Schema::XamlValueConverter&lt;System::ComponentModel::TypeConverter ^&gt; ^ LookupTypeConverter();" />
      <MemberSignature Language="F#" Value="abstract member LookupTypeConverter : unit -&gt; System.Xaml.Schema.XamlValueConverter&lt;System.ComponentModel.TypeConverter&gt;&#xA;override this.LookupTypeConverter : unit -&gt; System.Xaml.Schema.XamlValueConverter&lt;System.ComponentModel.TypeConverter&gt;" Usage="xamlMember.LookupTypeConverter " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.Schema.XamlValueConverter&lt;System.ComponentModel.TypeConverter&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回与此 <see cref="T:System.Xaml.XamlMember" /> 关联的类型转换器实现。</summary>
        <returns>一个具有 <see cref="T:System.Xaml.Schema.XamlValueConverter`1" /> 约束的 <see cref="T:System.ComponentModel.TypeConverter" /> 实例，或者为 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 默认实现使用以下逻辑和处理顺序：  
  
-   如果在成员级别（<xref:System.ComponentModel.TypeConverterAttribute>）存在特性化，则特性信息用于针对 XAML 架构上下文调用 <xref:System.Xaml.XamlSchemaContext.GetValueConverter%2A>。  
  
-   如果 <xref:System.Xaml.XamlMember.Type%2A> 有效，则返回与该类型关联的类型转换器。  
  
-   如果成员是事件，则返回特定于事件的类型转换器。  
  
 当调用方从 <xref:System.Xaml.XamlMember.TypeConverter%2A>获取值时，将调用此方法。 如果您想要报告整个 <xref:System.Xaml.XamlMember> 派生类的统一结果，或者您有可用于根据每种情况确定这一点的专用元数据，请重写此方法。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Xaml.XamlMember.TypeConverter" />
      </Docs>
    </Member>
    <Member MemberName="LookupUnderlyingGetter">
      <MemberSignature Language="C#" Value="protected virtual System.Reflection.MethodInfo LookupUnderlyingGetter ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.MethodInfo LookupUnderlyingGetter() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupUnderlyingGetter" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupUnderlyingGetter () As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Reflection::MethodInfo ^ LookupUnderlyingGetter();" />
      <MemberSignature Language="F#" Value="abstract member LookupUnderlyingGetter : unit -&gt; System.Reflection.MethodInfo&#xA;override this.LookupUnderlyingGetter : unit -&gt; System.Reflection.MethodInfo" Usage="xamlMember.LookupUnderlyingGetter " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回与此 <see langword="get" /> 关联的 <see cref="T:System.Xaml.XamlMember" /> 访问器。</summary>
        <returns>关联 <see cref="T:System.Reflection.MethodInfo" /> 访问器的 <see langword="get" />，或者为 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 默认实现将 <xref:System.Xaml.XamlMember.UnderlyingMember%2A> 属性解释为 <xref:System.Reflection.PropertyInfo> 并返回 <xref:System.Reflection.PropertyInfo.GetGetMethod%2A?displayProperty=nameWithType> 的值（参数设置为 `true`），这意味着返回的方法可以是非公共的。 在某些情况下，此行为可能会导致 `null`。 包括不存在关联的访问器或成员不是属性的情况。  
  
 当调用方从关联 <xref:System.Xaml.Schema.XamlMemberInvoker>上的 <xref:System.Xaml.Schema.XamlMemberInvoker.UnderlyingGetter%2A> 属性获取值时，将调用此方法。 如果您想要报告整个 <xref:System.Xaml.XamlMember> 派生类的统一结果，或者您有可用于根据每种情况确定这一点的专用元数据，请重写此方法。 请确保实现 <xref:System.Xaml.XamlMember.LookupUnderlyingGetter%2A>、<xref:System.Xaml.XamlMember.LookupUnderlyingSetter%2A>和 <xref:System.Xaml.XamlMember.LookupUnderlyingMember%2A>，以便它们都返回关联的结果。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupUnderlyingMember">
      <MemberSignature Language="C#" Value="protected virtual System.Reflection.MemberInfo LookupUnderlyingMember ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.MemberInfo LookupUnderlyingMember() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupUnderlyingMember" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupUnderlyingMember () As MemberInfo" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Reflection::MemberInfo ^ LookupUnderlyingMember();" />
      <MemberSignature Language="F#" Value="abstract member LookupUnderlyingMember : unit -&gt; System.Reflection.MemberInfo&#xA;override this.LookupUnderlyingMember : unit -&gt; System.Reflection.MemberInfo" Usage="xamlMember.LookupUnderlyingMember " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回与此 <see cref="T:System.Reflection.MemberInfo" /> 关联的 CLR 类型系统 <see cref="T:System.Xaml.XamlMember" />。</summary>
        <returns>与此 <see cref="T:System.Reflection.MemberInfo" /> 关联的 CLR 类型系统 <see cref="T:System.Xaml.XamlMember" /> 对象，或者为 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 默认实现返回基于构造的基础成员信息。 如果 <xref:System.Reflection.MemberInfo> 对象是使用未提供足够的信息来设置基础成员的签名构造的，则此方法返回 `null`。  
  
 如果基础成员是在构造过程中设置的，则无需调用此方法。  
  
 当调用方从 <xref:System.Xaml.XamlMember.UnderlyingMember%2A>获取值时，将调用此方法。 如果您想要报告整个 <xref:System.Xaml.XamlMember> 派生类的统一结果，或者您有可用于根据每种情况确定这一点的专用元数据，请重写此方法。 请确保实现 <xref:System.Xaml.XamlMember.LookupUnderlyingGetter%2A>、<xref:System.Xaml.XamlMember.LookupUnderlyingSetter%2A>和 <xref:System.Xaml.XamlMember.LookupUnderlyingMember%2A>，以便它们都返回关联的结果。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Xaml.XamlMember.UnderlyingMember" />
      </Docs>
    </Member>
    <Member MemberName="LookupUnderlyingSetter">
      <MemberSignature Language="C#" Value="protected virtual System.Reflection.MethodInfo LookupUnderlyingSetter ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.MethodInfo LookupUnderlyingSetter() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupUnderlyingSetter" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupUnderlyingSetter () As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Reflection::MethodInfo ^ LookupUnderlyingSetter();" />
      <MemberSignature Language="F#" Value="abstract member LookupUnderlyingSetter : unit -&gt; System.Reflection.MethodInfo&#xA;override this.LookupUnderlyingSetter : unit -&gt; System.Reflection.MethodInfo" Usage="xamlMember.LookupUnderlyingSetter " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回与此 <see langword="set" /> 关联的 <see cref="T:System.Xaml.XamlMember" /> 访问器。</summary>
        <returns>关联 <see cref="T:System.Reflection.MethodInfo" /> 访问器的 <see langword="set" />，或者为 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 默认实现将 <xref:System.Xaml.XamlMember.UnderlyingMember%2A> 解释为 <xref:System.Reflection.PropertyInfo> 并返回 <xref:System.Reflection.PropertyInfo.GetSetMethod%2A?displayProperty=nameWithType> 的值（参数设置为 `true`），这意味着返回的方法可以是非公共的。 这可能会导致在某些情况下 `null`，包括没有此类访问器或成员不是属性的情况。  
  
 调用方从关联 <xref:System.Xaml.Schema.XamlMemberInvoker>上的 <xref:System.Xaml.Schema.XamlMemberInvoker.UnderlyingSetter%2A> 获取值时，将调用此方法。如果您想要报告整个 <xref:System.Xaml.XamlMember> 派生类的统一结果，或者您有可用于根据每种情况确定这一点的专用元数据，请重写此方法。 请确保实现 <xref:System.Xaml.XamlMember.LookupUnderlyingGetter%2A>、<xref:System.Xaml.XamlMember.LookupUnderlyingSetter%2A>和 <xref:System.Xaml.XamlMember.LookupUnderlyingMember%2A>，以便它们都返回关联的结果。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupValueSerializer">
      <MemberSignature Language="C#" Value="protected virtual System.Xaml.Schema.XamlValueConverter&lt;System.Windows.Markup.ValueSerializer&gt; LookupValueSerializer ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Xaml.Schema.XamlValueConverter`1&lt;class System.Windows.Markup.ValueSerializer&gt; LookupValueSerializer() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupValueSerializer" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupValueSerializer () As XamlValueConverter(Of ValueSerializer)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Xaml::Schema::XamlValueConverter&lt;System::Windows::Markup::ValueSerializer ^&gt; ^ LookupValueSerializer();" />
      <MemberSignature Language="F#" Value="abstract member LookupValueSerializer : unit -&gt; System.Xaml.Schema.XamlValueConverter&lt;System.Windows.Markup.ValueSerializer&gt;&#xA;override this.LookupValueSerializer : unit -&gt; System.Xaml.Schema.XamlValueConverter&lt;System.Windows.Markup.ValueSerializer&gt;" Usage="xamlMember.LookupValueSerializer " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.Schema.XamlValueConverter&lt;System.Windows.Markup.ValueSerializer&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回与此 <see cref="T:System.Xaml.XamlMember" /> 关联的值序列化程序实现。</summary>
        <returns>一个具有 <see cref="T:System.Xaml.Schema.XamlValueConverter`1" /> 约束的 <see cref="T:System.Windows.Markup.ValueSerializer" /> 实例，或者为 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 默认实现使用以下逻辑和处理顺序：  
  
-   如果在成员级别（<xref:System.Windows.Markup.ValueSerializerAttribute>）存在特性化，则特性信息用于针对 XAML 架构上下文调用 <xref:System.Xaml.XamlSchemaContext.GetValueConverter%2A>。  
  
-   如果 <xref:System.Xaml.XamlMember.Type%2A> 有效，则返回与该类型相关联的值转换器。  
  
-   如果上述条件不适用，则返回 `null`。  
  
 当调用方从 <xref:System.Xaml.XamlMember.ValueSerializer%2A>获取值时，将调用此方法。 如果您想要报告整个 <xref:System.Xaml.XamlMember> 派生类的统一结果，或者您有可用于根据每种情况确定这一点的专用元数据，请重写此方法。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Xaml.XamlMember.ValueSerializer" />
      </Docs>
    </Member>
    <Member MemberName="MarkupExtensionBracketCharacters">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IReadOnlyDictionary&lt;char,char&gt; MarkupExtensionBracketCharacters { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IReadOnlyDictionary`2&lt;char, char&gt; MarkupExtensionBracketCharacters" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.MarkupExtensionBracketCharacters" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MarkupExtensionBracketCharacters As IReadOnlyDictionary(Of Char, Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::IReadOnlyDictionary&lt;char, char&gt; ^ MarkupExtensionBracketCharacters { System::Collections::Generic::IReadOnlyDictionary&lt;char, char&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MarkupExtensionBracketCharacters : System.Collections.Generic.IReadOnlyDictionary&lt;char, char&gt;" Usage="System.Xaml.XamlMember.MarkupExtensionBracketCharacters" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IReadOnlyDictionary&lt;System.Char,System.Char&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>定义标记扩展的开始和结束括号字符。</summary>
        <value>包含开始和结束括号字符的集合。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.Name" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Name { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Name : string" Usage="System.Xaml.XamlMember.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取 <see langword="xamlName" /> 名称字符串，该字符串声明此 <see cref="T:System.Xaml.XamlMember" />。</summary>
        <value><see langword="xamlName" /> 名称字符串，该字符串声明此 <see cref="T:System.Xaml.XamlMember" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此值始终在构造过程中设置。 如果未指定初始名称，则 <xref:System.Xaml.XamlMember> 实现的构造函数通常会引发异常;因此，如果您使用的是默认 .NET Framework XAML 服务实现，则不希望将此属性 `null` 或空字符串中。  
  
 CLR 类型和成员的[XamlName 语法](~/docs/framework/xaml-services/xamlname-grammar.md)和命名规则并不完全相交。 可以声明在 CLR 下合法但在 XAML 命名下无效的成员名称。 如果可能，应尽量避免这种情况。  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/11e4cada-41d2-494d-9531-0d3df4dfcbe3">XamlName</related>
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (System.Xaml.XamlMember xamlMember1, System.Xaml.XamlMember xamlMember2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(class System.Xaml.XamlMember xamlMember1, class System.Xaml.XamlMember xamlMember2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.op_Equality(System.Xaml.XamlMember,System.Xaml.XamlMember)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (xamlMember1 As XamlMember, xamlMember2 As XamlMember) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::Xaml::XamlMember ^ xamlMember1, System::Xaml::XamlMember ^ xamlMember2);" />
      <MemberSignature Language="F#" Value="static member ( = ) : System.Xaml.XamlMember * System.Xaml.XamlMember -&gt; bool" Usage="xamlMember1 = xamlMember2" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="xamlMember1" Type="System.Xaml.XamlMember" />
        <Parameter Name="xamlMember2" Type="System.Xaml.XamlMember" />
      </Parameters>
      <Docs>
        <param name="xamlMember1"><see cref="T:System.Xaml.XamlMember" /> 或 <see langword="null" />。</param>
        <param name="xamlMember2"><see cref="T:System.Xaml.XamlMember" /> 或 <see langword="null" />。</param>
        <summary>确定两个指定的 <see cref="T:System.Xaml.XamlMember" /> 对象是否具有相同的值。</summary>
        <returns>如果 <see langword="true" /> 的值与 <paramref name="xamlMember1" /> 的值相同，则为 <paramref name="xamlMember2" />；否则为 <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (System.Xaml.XamlMember xamlMember1, System.Xaml.XamlMember xamlMember2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(class System.Xaml.XamlMember xamlMember1, class System.Xaml.XamlMember xamlMember2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.op_Inequality(System.Xaml.XamlMember,System.Xaml.XamlMember)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (xamlMember1 As XamlMember, xamlMember2 As XamlMember) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::Xaml::XamlMember ^ xamlMember1, System::Xaml::XamlMember ^ xamlMember2);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : System.Xaml.XamlMember * System.Xaml.XamlMember -&gt; bool" Usage="System.Xaml.XamlMember.op_Inequality (xamlMember1, xamlMember2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="xamlMember1" Type="System.Xaml.XamlMember" />
        <Parameter Name="xamlMember2" Type="System.Xaml.XamlMember" />
      </Parameters>
      <Docs>
        <param name="xamlMember1"><see cref="T:System.Xaml.XamlMember" /> 或 <see langword="null" />。</param>
        <param name="xamlMember2"><see cref="T:System.Xaml.XamlMember" /> 或 <see langword="null" />。</param>
        <summary>确定两个指定的 <see cref="T:System.Xaml.XamlMember" /> 对象是否具有不同的值。</summary>
        <returns>如果 <see langword="true" /> 的值与 <paramref name="xamlMember1" /> 的值不同，则为 <paramref name="xamlMember2" />；否则为 <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PreferredXamlNamespace">
      <MemberSignature Language="C#" Value="public string PreferredXamlNamespace { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string PreferredXamlNamespace" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.PreferredXamlNamespace" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PreferredXamlNamespace As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ PreferredXamlNamespace { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.PreferredXamlNamespace : string" Usage="System.Xaml.XamlMember.PreferredXamlNamespace" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取单个 XAML 命名空间 URI，该 URI 标识此 <see cref="T:System.Xaml.XamlMember" /> 的主 XAML 命名空间。</summary>
        <value>此 <see cref="T:System.Xaml.XamlMember" /> 的主 XAML 命名空间的标识符（字符串形式）。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Xaml.XamlMember.PreferredXamlNamespace%2A> 属性提供与调用 <xref:System.Xaml.XamlMember.GetXamlNamespaces%2A> 相同的值，并从返回的列表中获取第一个值字符串。 将成员写回保留 XAML 命名空间信息的文本或其他表示形式时，应使用首选 XAML 命名空间。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SerializationVisibility">
      <MemberSignature Language="C#" Value="public System.ComponentModel.DesignerSerializationVisibility SerializationVisibility { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.ComponentModel.DesignerSerializationVisibility SerializationVisibility" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.SerializationVisibility" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SerializationVisibility As DesignerSerializationVisibility" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ComponentModel::DesignerSerializationVisibility SerializationVisibility { System::ComponentModel::DesignerSerializationVisibility get(); };" />
      <MemberSignature Language="F#" Value="member this.SerializationVisibility : System.ComponentModel.DesignerSerializationVisibility" Usage="System.Xaml.XamlMember.SerializationVisibility" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.DesignerSerializationVisibility</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个 <see cref="T:System.ComponentModel.DesignerSerializationVisibility" /> 值，该值指示可视化设计器应如何处理成员。</summary>
        <value><see cref="T:System.ComponentModel.DesignerSerializationVisibility" /> 枚举的一个值。 默认为 <see cref="F:System.ComponentModel.DesignerSerializationVisibility.Visible" />。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TargetType">
      <MemberSignature Language="C#" Value="public System.Xaml.XamlType TargetType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xaml.XamlType TargetType" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.TargetType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TargetType As XamlType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xaml::XamlType ^ TargetType { System::Xaml::XamlType ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TargetType : System.Xaml.XamlType" Usage="System.Xaml.XamlMember.TargetType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取其中可能存在 <see cref="T:System.Xaml.XamlType" /> 的类型的 <see cref="T:System.Xaml.XamlMember" />。</summary>
        <value>其中可能存在 <see cref="T:System.Xaml.XamlMember" /> 的类型。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 对于可附加和不可附加成员，返回的值不同。 对于不可附加的成员，<xref:System.Xaml.XamlMember.TargetType%2A> 返回 <xref:System.Xaml.XamlMember.DeclaringType%2A>。 对于可附加成员，<xref:System.Xaml.XamlMember.LookupTargetType%2A> 返回基于此逻辑的结果：  
  
-   如果反射无法解析支持（<xref:System.Xaml.XamlMember.IsUnknown%2A> `true`），则此方法将返回表示泛型对象类型的内部常数。  
  
-   如果前面的条件不适用，则调用 <xref:System.Xaml.XamlMember.LookupTargetType%2A>。 默认实现返回基于检查实现 `get` 和 `set` 访问器的方法的 <xref:System.Xaml.XamlType>。 类可能会重写 <xref:System.Xaml.XamlMember.LookupTargetType%2A>，以使用不同的行为，例如可能会报告可附加成员的目标类型的其他元数据形式。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="xamlMember.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回此 <see cref="T:System.Xaml.XamlMember" /> 的字符串表示形式。</summary>
        <returns>此 <see cref="T:System.Xaml.XamlMember" /> 的字符串表示形式。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此实现返回 <xref:System.Xaml.XamlMember.Name%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Type">
      <MemberSignature Language="C#" Value="public System.Xaml.XamlType Type { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xaml.XamlType Type" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.Type" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Type As XamlType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xaml::XamlType ^ Type { System::Xaml::XamlType ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Type : System.Xaml.XamlType" Usage="System.Xaml.XamlMember.Type" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取成员所使用的类型的 <see cref="T:System.Xaml.XamlType" />。</summary>
        <value>成员所使用的类型的 <see cref="T:System.Xaml.XamlType" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 调用 <xref:System.Xaml.XamlMember.Type%2A> 将调用该方法的 <xref:System.Xaml.XamlMember.LookupType%2A> 或特定的重写。 初始内部反射逻辑尚未设置信息时，会发生这种情况。  
  
 在默认行为（无 <xref:System.Xaml.XamlMember.LookupType%2A> 重写）中，返回的 <xref:System.Xaml.XamlType> 的概念含义可能不同。 适用的含义取决于此 <xref:System.Xaml.XamlMember> 表示属性、方法还是事件，如以下列表所示：  
  
-   对于属性，返回的 <xref:System.Xaml.XamlType> 是设置属性或由属性返回的类型。  
  
-   对于事件，返回的 <xref:System.Xaml.XamlType> 是必需的事件处理程序类型（CLR 实现中的委托）。  
  
-   对于方法，<xref:System.Xaml.XamlType> 是该方法的返回类型，可以是 `null`。  
  
 在每种情况下，XAML 架构上下文用于计算来自后备类型的 XAML 类型。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TypeConverter">
      <MemberSignature Language="C#" Value="public System.Xaml.Schema.XamlValueConverter&lt;System.ComponentModel.TypeConverter&gt; TypeConverter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xaml.Schema.XamlValueConverter`1&lt;class System.ComponentModel.TypeConverter&gt; TypeConverter" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.TypeConverter" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TypeConverter As XamlValueConverter(Of TypeConverter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xaml::Schema::XamlValueConverter&lt;System::ComponentModel::TypeConverter ^&gt; ^ TypeConverter { System::Xaml::Schema::XamlValueConverter&lt;System::ComponentModel::TypeConverter ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TypeConverter : System.Xaml.Schema.XamlValueConverter&lt;System.ComponentModel.TypeConverter&gt;" Usage="System.Xaml.XamlMember.TypeConverter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.Schema.XamlValueConverter&lt;System.ComponentModel.TypeConverter&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个 <see cref="T:System.Xaml.Schema.XamlValueConverter`1" /> 对象，该对象可用于 XAML 声明的对象的类型转换构造。</summary>
        <value>一个对泛型具有 <see cref="T:System.Xaml.Schema.XamlValueConverter`1" /> 约束的 <see cref="T:System.ComponentModel.TypeConverter" /> 值。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 调用 <xref:System.Xaml.XamlMember.TypeConverter%2A> 将调用该方法的 <xref:System.Xaml.XamlMember.LookupTypeConverter%2A> 或特定的重写。 当初始内部反射逻辑尚未设置此信息时，会出现此行为。  
  
 为 <xref:System.Xaml.XamlMember.TypeConverter%2A> 返回非 null 属性值的实现不一定是工作 <xref:System.ComponentModel.TypeConverter>。 下面是 <xref:System.Xaml.XamlMember.TypeConverter%2A> 的可能的非 null 返回值的列表以及这些值的含义：  
  
-   返回值将报告特定于该成员或更一般为转换器的目标类型的类型转换器。 此行为通常是大多数 XAML 类型系统和 XAML 处理器的外观，以便实例化类型转换器并调用其方法。  
  
-   返回值报告内置值转换器。 这些转换器适用于 XAML 编写器执行的某些内部操作。 特别是，这些内置值转换器将原始属性字符串值转换为 XAML 语言级基元。 对于 .NET Framework XAML 服务实现，这些内置类型转换通常转发到系统程序集中定义的类型转换器。 例如，<xref:System.Int32> 值的转换具有内置的正向转换，因此 <xref:System.Xaml.Schema.XamlValueConverter%601.ConverterType%2A> 值引用 <xref:System.ComponentModel.Int32Converter>。  
  
-   返回值报告不受约束的对象模型的特殊情况;也就是说，<xref:System.Xaml.XamlMember> 的 <xref:System.Xaml.XamlMember.Type%2A> 值为 <xref:System.Object>。 在这种情况下，<xref:System.Xaml.Schema.XamlValueConverter%601> 将报告 <xref:System.Xaml.Schema.XamlValueConverter%601.Name%2A?displayProperty=nameWithType> 为 {`Object}`。 但 <xref:System.Xaml.Schema.XamlValueConverter%601.ConverterInstance%2A> 是 `null` 的，因为没有可用于执行此转换的实际类型或实例。 相反，在运行时，当特定技术的运行时确定其对象图的处理时，不能确定对象模型的行为。  
  
 如果可从 <xref:System.Xaml.Schema.XamlValueConverter%601.ConverterInstance%2A>访问工作 <xref:System.ComponentModel.TypeConverter>，则可以调用其转换方法。 但是，许多转换方法依赖于服务上下文。 如果你没有可用的相同服务上下文，并且类型转换器需要其为对象图写入对象的典型角色，则转换器方法可能会引发异常。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UnderlyingMember">
      <MemberSignature Language="C#" Value="public System.Reflection.MemberInfo UnderlyingMember { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.MemberInfo UnderlyingMember" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.UnderlyingMember" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property UnderlyingMember As MemberInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Reflection::MemberInfo ^ UnderlyingMember { System::Reflection::MemberInfo ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UnderlyingMember : System.Reflection.MemberInfo" Usage="System.Xaml.XamlMember.UnderlyingMember" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取 CLR 类型系统 <see cref="T:System.Reflection.MemberInfo" />，它可用于由 <see cref="T:System.Reflection.PropertyInfo" />、<see cref="T:System.Reflection.MethodInfo" /> 或 <see cref="T:System.Reflection.EventInfo" /> 构造的成员。</summary>
        <value>从初始构造函数参数强制转换的 CLR 类型系统 <see cref="T:System.Reflection.MemberInfo" /> 信息。 使用 <see cref="T:System.Xaml.XamlMember" /> 签名构造的 <see cref="M:System.Xaml.XamlMember.#ctor(System.String,System.Xaml.XamlType,System.Boolean)" /> 返回 <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 调用 <xref:System.Xaml.XamlMember.UnderlyingMember%2A> 将调用该方法的 <xref:System.Xaml.XamlMember.LookupUnderlyingMember%2A> 或特定的重写。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ValueSerializer">
      <MemberSignature Language="C#" Value="public System.Xaml.Schema.XamlValueConverter&lt;System.Windows.Markup.ValueSerializer&gt; ValueSerializer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xaml.Schema.XamlValueConverter`1&lt;class System.Windows.Markup.ValueSerializer&gt; ValueSerializer" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.ValueSerializer" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ValueSerializer As XamlValueConverter(Of ValueSerializer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xaml::Schema::XamlValueConverter&lt;System::Windows::Markup::ValueSerializer ^&gt; ^ ValueSerializer { System::Xaml::Schema::XamlValueConverter&lt;System::Windows::Markup::ValueSerializer ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ValueSerializer : System.Xaml.Schema.XamlValueConverter&lt;System.Windows.Markup.ValueSerializer&gt;" Usage="System.Xaml.XamlMember.ValueSerializer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.Schema.XamlValueConverter&lt;System.Windows.Markup.ValueSerializer&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个 <see cref="T:System.Xaml.Schema.XamlValueConverter`1" /> 对象，该对象用于 XAML 声明的对象的值序列化。</summary>
        <value>一个对泛型具有 <see cref="T:System.Xaml.Schema.XamlValueConverter`1" /> 约束的 <see cref="T:System.Windows.Markup.ValueSerializer" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 调用 <xref:System.Xaml.XamlMember.ValueSerializer%2A> 将调用该方法的 <xref:System.Xaml.XamlMember.LookupValueSerializer%2A> 或特定的重写。 当初始内部反射逻辑尚未设置此信息时，会出现此行为。  
  
 并非所有返回 <xref:System.Xaml.XamlMember.ValueSerializer%2A> 的非 null 属性值的情况都必须是有效的 <xref:System.Windows.Markup.ValueSerializer>。 请参阅 <xref:System.Xaml.XamlMember.TypeConverter%2A>;<xref:System.Xaml.XamlMember.ValueSerializer%2A>的注意事项同样适用。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
