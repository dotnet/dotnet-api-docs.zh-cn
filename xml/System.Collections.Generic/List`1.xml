<Type Name="List&lt;T&gt;" FullName="System.Collections.Generic.List&lt;T&gt;">
  <Metadata><Meta Name="ms.openlocfilehash" Value="fb26641fa5269f2bd5f37c1305c4e758c3b8a01a" /><Meta Name="ms.sourcegitcommit" Value="8fab45da9f77f8bbc3ae5817515b40ac6ff205a2" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-CN" /><Meta Name="ms.lasthandoff" Value="01/20/2021" /><Meta Name="ms.locfileid" Value="98617916" /></Metadata><TypeSignature Language="C#" Value="public class List&lt;T&gt; : System.Collections.Generic.ICollection&lt;T&gt;, System.Collections.Generic.IEnumerable&lt;T&gt;, System.Collections.Generic.IList&lt;T&gt;, System.Collections.Generic.IReadOnlyCollection&lt;T&gt;, System.Collections.Generic.IReadOnlyList&lt;T&gt;, System.Collections.IList" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit List`1&lt;T&gt; extends System.Object implements class System.Collections.Generic.ICollection`1&lt;!T&gt;, class System.Collections.Generic.IEnumerable`1&lt;!T&gt;, class System.Collections.Generic.IList`1&lt;!T&gt;, class System.Collections.Generic.IReadOnlyCollection`1&lt;!T&gt;, class System.Collections.Generic.IReadOnlyList`1&lt;!T&gt;, class System.Collections.ICollection, class System.Collections.IEnumerable, class System.Collections.IList" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1" />
  <TypeSignature Language="DocId" Value="T:System.Collections.Generic.List`1" />
  <TypeSignature Language="VB.NET" Value="Public Class List(Of T)&#xA;Implements ICollection(Of T), IEnumerable(Of T), IList, IList(Of T), IReadOnlyCollection(Of T), IReadOnlyList(Of T)" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <TypeSignature Language="C++ CLI" Value="generic &lt;typename T&gt;&#xA;public ref class List : System::Collections::Generic::ICollection&lt;T&gt;, System::Collections::Generic::IEnumerable&lt;T&gt;, System::Collections::Generic::IList&lt;T&gt;, System::Collections::Generic::IReadOnlyCollection&lt;T&gt;, System::Collections::Generic::IReadOnlyList&lt;T&gt;, System::Collections::IList" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <TypeSignature Language="F#" Value="type List&lt;'T&gt; = class&#xA;    interface ICollection&lt;'T&gt;&#xA;    interface seq&lt;'T&gt;&#xA;    interface IEnumerable&#xA;    interface IList&lt;'T&gt;&#xA;    interface IReadOnlyCollection&lt;'T&gt;&#xA;    interface IReadOnlyList&lt;'T&gt;&#xA;    interface ICollection&#xA;    interface IList" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1" />
  <TypeSignature Language="C#" Value="public class List&lt;T&gt; : System.Collections.Generic.ICollection&lt;T&gt;, System.Collections.Generic.IEnumerable&lt;T&gt;, System.Collections.Generic.IList&lt;T&gt;, System.Collections.IList" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit List`1&lt;T&gt; extends System.Object implements class System.Collections.Generic.ICollection`1&lt;!T&gt;, class System.Collections.Generic.IEnumerable`1&lt;!T&gt;, class System.Collections.Generic.IList`1&lt;!T&gt;, class System.Collections.ICollection, class System.Collections.IEnumerable, class System.Collections.IList" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
  <TypeSignature Language="VB.NET" Value="Public Class List(Of T)&#xA;Implements ICollection(Of T), IEnumerable(Of T), IList, IList(Of T)" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
  <TypeSignature Language="C++ CLI" Value="generic &lt;typename T&gt;&#xA;public ref class List : System::Collections::Generic::ICollection&lt;T&gt;, System::Collections::Generic::IEnumerable&lt;T&gt;, System::Collections::Generic::IList&lt;T&gt;, System::Collections::IList" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
  <TypeSignature Language="F#" Value="type List&lt;'T&gt; = class&#xA;    interface IList&lt;'T&gt;&#xA;    interface ICollection&lt;'T&gt;&#xA;    interface seq&lt;'T&gt;&#xA;    interface IList&#xA;    interface ICollection&#xA;    interface IEnumerable" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit List`1&lt;T&gt; extends System.Object implements class System.Collections.Generic.ICollection`1&lt;!T&gt;, class System.Collections.Generic.IEnumerable`1&lt;!T&gt;, class System.Collections.Generic.IList`1&lt;!T&gt;, class System.Collections.Generic.IReadOnlyCollection`1&lt;!T&gt;, class System.Collections.Generic.IReadOnlyList`1&lt;!T&gt;, class System.Collections.ICollection, class System.Collections.IEnumerable, class System.Collections.IList" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <TypeSignature Language="F#" Value="type List&lt;'T&gt; = class&#xA;    interface IList&lt;'T&gt;&#xA;    interface ICollection&lt;'T&gt;&#xA;    interface IList&#xA;    interface ICollection&#xA;    interface IReadOnlyList&lt;'T&gt;&#xA;    interface IReadOnlyCollection&lt;'T&gt;&#xA;    interface seq&lt;'T&gt;&#xA;    interface IEnumerable" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2" />
  <TypeSignature Language="F#" Value="type List&lt;'T&gt; = class&#xA;    interface IList&lt;'T&gt;&#xA;    interface ICollection&lt;'T&gt;&#xA;    interface seq&lt;'T&gt;&#xA;    interface IEnumerable&#xA;    interface IList&#xA;    interface ICollection&#xA;    interface IReadOnlyList&lt;'T&gt;&#xA;    interface IReadOnlyCollection&lt;'T&gt;" FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
  <TypeSignature Language="F#" Value="type List&lt;'T&gt; = class&#xA;    interface IList&lt;'T&gt;&#xA;    interface ICollection&lt;'T&gt;&#xA;    interface IReadOnlyList&lt;'T&gt;&#xA;    interface IReadOnlyCollection&lt;'T&gt;&#xA;    interface seq&lt;'T&gt;&#xA;    interface IList&#xA;    interface ICollection&#xA;    interface IEnumerable" FrameworkAlternate="netstandard-1.0;netstandard-1.1;netstandard-1.2" />
  <TypeSignature Language="F#" Value="type List&lt;'T&gt; = class&#xA;    interface IList&lt;'T&gt;&#xA;    interface IList&#xA;    interface IReadOnlyList&lt;'T&gt;&#xA;    interface ICollection&lt;'T&gt;&#xA;    interface seq&lt;'T&gt;&#xA;    interface IEnumerable&#xA;    interface ICollection&#xA;    interface IReadOnlyCollection&lt;'T&gt;" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <AssemblyInfo>
    <AssemblyName>System.Collections</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
    <AssemblyVersion>4.1.2.0</AssemblyVersion>
    <AssemblyVersion>5.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeForwardingChain>
    <TypeForwarding From="mscorlib" FromVersion="4.0.0.0" To="System.Collections" ToVersion="0.0.0.0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0" />
    <TypeForwarding From="netstandard" FromVersion="2.1.0.0" To="System.Collections" ToVersion="5.0.0.0" FrameworkAlternate="net-5.0" />
  </TypeForwardingChain>
  <TypeParameters>
    <TypeParameter Name="T" />
  </TypeParameters>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.Generic.ICollection&lt;T&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IEnumerable&lt;T&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IList&lt;T&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <InterfaceName>System.Collections.Generic.IReadOnlyCollection&lt;T&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <InterfaceName>System.Collections.Generic.IReadOnlyList&lt;T&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.ICollection</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IEnumerable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IList</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName Language="C#">[System.Diagnostics.DebuggerDisplay("Count = {Count}")]</AttributeName>
      <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerDisplay("Count = {Count}")&gt;]</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName Language="C#">[System.Diagnostics.DebuggerTypeProxy(typeof(System.Collections.Generic.Mscorlib_CollectionDebugView`1))]</AttributeName>
      <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerTypeProxy(typeof(System.Collections.Generic.Mscorlib_CollectionDebugView`1))&gt;]</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName Language="C#">[System.Serializable]</AttributeName>
      <AttributeName Language="F#">[&lt;System.Serializable&gt;]</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <typeparam name="T">列表中元素的类型。</typeparam>
    <summary>表示可通过索引访问的对象的强类型列表。 提供用于对列表进行搜索、排序和操作的方法。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601>类是类的泛型等效项 <xref:System.Collections.ArrayList> 。 它 <xref:System.Collections.Generic.IList%601> 通过使用大小根据需要动态增加的数组来实现泛型接口。  
  
 您可以 <xref:System.Collections.Generic.List%601> 使用或方法将项添加到 <xref:System.Collections.Generic.List%601.Add%2A> 中 <xref:System.Collections.Generic.List%601.AddRange%2A> 。  
  
 <xref:System.Collections.Generic.List%601>类使用相等比较器和排序比较器。  
  
-   诸如、、 <xref:System.Collections.Generic.List%601.Contains%2A> 和等方法 <xref:System.Collections.Generic.List%601.IndexOf%2A> <xref:System.Collections.Generic.List%601.LastIndexOf%2A> <xref:System.Collections.Generic.Dictionary%602.Remove%2A> 对列表元素使用相等比较器。 按如下方式确定类型的默认相等比较器 `T` 。 如果类型 `T` 实现 <xref:System.IEquatable%601> 泛型接口，则相等比较器是 <xref:System.IEquatable%601.Equals%28%600%29> 该接口的方法; 否则，默认的相等比较器为 <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> 。  
  
-   和等方法 <xref:System.Collections.Generic.List%601.BinarySearch%2A> <xref:System.Collections.Generic.List%601.Sort%2A> 将排序比较器用于列表元素。 按如下方式确定类型的默认比较器 `T` 。  如果类型 `T` 实现 <xref:System.IComparable%601> 泛型接口，则默认比较器是 <xref:System.IComparable%601.CompareTo%28%600%29> 该接口的方法; 否则，如果类型 `T` 实现非泛型 <xref:System.IComparable> 接口，则默认比较器是 <xref:System.IComparable.CompareTo%28System.Object%29> 该接口的方法。 如果类型同时 `T` 实现两个接口，则没有默认比较器，必须显式提供一个比较器或比较委托。  
  
 不保证会对进行 <xref:System.Collections.Generic.List%601> 排序。  在执行操作之前必须对进行排序 <xref:System.Collections.Generic.List%601> (如 <xref:System.Collections.Generic.List%601.BinarySearch%2A> 需要 <xref:System.Collections.Generic.List%601> 对进行排序) 。  
  
 可以使用整数索引访问此集合中的元素。  此集合中的索引从零开始。  
  
 **仅 .NET Framework：** 对于非常大的 <xref:System.Collections.Generic.List%601> 对象，可以通过 `enabled` [`<gcAllowVeryLargeObjects>`](/dotnet/framework/configure-apps/file-schema/runtime/gcallowverylargeobjects-element) `true` 在运行时环境中将配置元素的属性设置为，来将64位系统上的最大容量增加到2000000000个元素。  
  
 <xref:System.Collections.Generic.List%601> 接受 `null` 作为引用类型的有效值，并允许重复元素。  
  
 有关类的不可变版本 <xref:System.Collections.Generic.List%601> ，请参见 <xref:System.Collections.Immutable.ImmutableList%601> 。  
  
## <a name="performance-considerations"></a>性能注意事项  
 在决定是使用 <xref:System.Collections.Generic.List%601> 还是 <xref:System.Collections.ArrayList> 类（两者都具有类似的功能）时，请记住 <xref:System.Collections.Generic.List%601> 类在大多数情况下性能更佳并且是类型安全的。 如果引用类型用于 `T` 类的类型 <xref:System.Collections.Generic.List%601> ，则这两个类的行为是相同的。 但是，如果将值类型用于类型 `T` ，则需要考虑实现和装箱问题。  
  
 如果将值类型用于类型 `T` ，则编译器将生成 <xref:System.Collections.Generic.List%601> 专用于该值类型的类的实现。 这意味着 <xref:System.Collections.Generic.List%601> ，在使用元素之前无需装箱对象的列表元素，在创建了大约500个列表元素之后，已保存的未装箱的内存列表元素大于用于生成类实现的内存。  
  
 确定用于类型的值类型 `T` 实现 <xref:System.IEquatable%601> 泛型接口。 如果不是，则等方法 <xref:System.Collections.Generic.List%601.Contains%2A> 必须调用 <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> 方法，这会对受影响的列表元素进行装箱。 如果值类型实现了 <xref:System.IComparable> 接口，并且你拥有源代码，还需要实现 <xref:System.IComparable%601> 泛型接口，以防止 <xref:System.Collections.Generic.List%601.BinarySearch%2A> 和方法对 <xref:System.Collections.Generic.List%601.Sort%2A> 列表元素进行装箱。 如果你不拥有源代码，请将 <xref:System.Collections.Generic.IComparer%601> 对象传递给 <xref:System.Collections.Generic.List%601.BinarySearch%2A> 和 <xref:System.Collections.Generic.List%601.Sort%2A> 方法  
  
 您可以使用类的特定于类型的实现， <xref:System.Collections.Generic.List%601> 而不是使用 <xref:System.Collections.ArrayList> 类或自行编写强类型包装集合。 原因在于，你的实现必须执行 .NET Framework 的操作，并且公共语言运行时可以共享你的实现不能的 Microsoft 中间语言代码和元数据。  
  
## <a name="f-considerations"></a>F # 注意事项  
 <xref:System.Collections.Generic.List%601>类在 F # 代码中很少使用。 通常， [列表](/dotnet/fsharp/language-reference/lists)（这是不可变的单向链接列表）通常是首选的。 F # 列表提供了有序的、不可变的值序列，并支持在功能样式开发中使用。 在 F # 中使用类时， <xref:System.Collections.Generic.List%601> 类通常由[ \<'T> collections.resizearray](https://fsharp.github.io/fsharp-core-docs/reference/fsharp-collections-resizearray-1.html)类型缩写词引用，以避免与 F # 列表之间发生命名冲突。
  
## Examples  

 下面的示例演示如何在中添加、移除和插入简单的业务对象 <xref:System.Collections.Generic.List%601> 。  
  
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/cs/program.cs" interactive="try-dotnet" id="snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/vb/module1.vb" id="snippet1":::
 :::code language="fsharp" source="~/samples/snippets/fsharp/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/fs/addremoveinsert.fs" id="snippet1":::
  
 下面的示例演示了 string 类型的泛型类的多个属性和方法 <xref:System.Collections.Generic.List%601> 。  (有关复杂类型的示例 <xref:System.Collections.Generic.List%601> ，请参阅 <xref:System.Collections.Generic.List%601.Contains%2A> 方法。 )   
  
 无参数构造函数用于创建具有默认容量的字符串列表。 <xref:System.Collections.Generic.List%601.Capacity%2A>显示属性，然后 <xref:System.Collections.Generic.List%601.Add%2A> 使用方法添加多个项。 将列出这些项，并 <xref:System.Collections.Generic.List%601.Capacity%2A> 再次显示属性和 <xref:System.Collections.Generic.List%601.Count%2A> 属性，以显示容量已根据需要增加。  
  
 <xref:System.Collections.Generic.List%601.Contains%2A>方法用于测试列表中是否存在某一项，此 <xref:System.Collections.Generic.List%601.Insert%2A> 方法用于在列表的中间插入新项，并再次显示该列表的内容。  
  
 <xref:System.Collections.Generic.List%601.Item%2A>C # ) 中索引器 (的默认属性用于检索项， <xref:System.Collections.Generic.List%601.Remove%2A> 方法用于删除之前添加的重复项的第一个实例，并再次显示内容。 <xref:System.Collections.Generic.List%601.Remove%2A>方法始终删除其遇到的第一个实例。  
  
 <xref:System.Collections.Generic.List%601.TrimExcess%2A>方法用于降低容量以匹配计数，并 <xref:System.Collections.Generic.List%601.Capacity%2A> <xref:System.Collections.Generic.List%601.Count%2A> 显示和属性。 如果未使用的容量小于总容量的10%，则不会调整此列表的大小。  
  
 最后， <xref:System.Collections.Generic.List%601.Clear%2A> 使用方法从列表中移除所有项，并 <xref:System.Collections.Generic.List%601.Capacity%2A> <xref:System.Collections.Generic.List%601.Count%2A> 显示和属性。  
  
 [!code-cpp[List\`1_Class#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Class/cpp/source.cpp#1)]
 [!code-csharp-interactive[List\`1_Class#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Class/cs/source.cs#1)]
 [!code-vb[List\`1_Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Class/vb/source.vb#1)]  
 [!code-fsharp[List\`1_Class#1](~/samples/snippets/fsharp/VS_Snippets_CLR/List`1_Class/fs/listclass.fs#1)]
  
 ]]></format>
    </remarks>
    <threadsafe><see langword="Shared" />此类型) 成员 Visual Basic 的公共静态 (是线程安全的。 但不保证所有实例成员都是线程安全的。  
  
在上执行多个读取操作是安全的 <see cref="T:System.Collections.Generic.List`1" /> ，但是如果在读取集合时修改了集合，则可能会出现问题。 若要确保线程安全，请在读或写操作过程中锁定集合。 若要允许多个线程访问集合以进行读写，必须实现自己的同步。 对于带有内置同步的集合，请参阅命名空间中的类 <see cref="N:System.Collections.Concurrent" /> 。 有关本质上是线程安全的替代方法，请参阅 <see cref="T:System.Collections.Immutable.ImmutableList`1" /> 类。</threadsafe>
    <altmember cref="T:System.Collections.IList" />
    <altmember cref="T:System.Collections.Immutable.ImmutableList`1" />
    <related type="Article" href="/dotnet/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections">在集合中执行不区分区域性的字符串操作</related>
    <related type="Article" href="/dotnet/csharp/programming-guide/concepts/iterators">迭代器 (C#)</related>
    <related type="Article" href="/dotnet/visual-basic/programming-guide/concepts/iterators">迭代器 (Visual Basic)</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>初始化 <see cref="T:System.Collections.Generic.List`1" /> 类的新实例。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public List ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; List();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>初始化 <see cref="T:System.Collections.Generic.List`1" /> 类的新实例，该实例为空并且具有默认初始容量。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 的容量 <xref:System.Collections.Generic.List%601> 是可容纳的元素数 <xref:System.Collections.Generic.List%601> 。 当向添加元素时 <xref:System.Collections.Generic.List%601> ，将根据需要通过重新分配内部数组来自动增加容量。  
  
 如果集合的大小可以估算，使用 <xref:System.Collections.Generic.List%601.%23ctor%28System.Int32%29> 构造函数并指定初始容量，则无需在将元素添加到时执行多个大小调整操作 <xref:System.Collections.Generic.List%601> 。  
  
 可以通过调用 <xref:System.Collections.Generic.List%601.TrimExcess%2A> 方法或通过显式设置属性来减少容量 <xref:System.Collections.Generic.List%601.Capacity%2A> 。 减少容量会重新分配内存，并复制中的所有元素 <xref:System.Collections.Generic.List%601> 。  
  
 此构造函数是一个 O (1) 操作。
  
## Examples  

 下面的示例演示了泛型类的无参数构造函数 <xref:System.Collections.Generic.List%601> 。 无参数构造函数将创建一个具有默认容量的列表，如显示属性所示 <xref:System.Collections.Generic.List%601.Capacity%2A> 。  
  
 该示例添加、插入和删除项，显示了在使用这些方法时容量如何变化。  
 
 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Class/cpp/source.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Class/cs/source.cs" interactive="try-dotnet-method" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Class/vb/source.vb" id="Snippet1":::
 :::code language="fsharp" source="~/samples/snippets/fsharp/VS_Snippets_CLR/List`1_Class/fs/listclass.fs" id="Snippet1":::
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public List (System.Collections.Generic.IEnumerable&lt;T&gt; collection);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.Generic.IEnumerable`1&lt;!T&gt; collection) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.#ctor(System.Collections.Generic.IEnumerable{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (collection As IEnumerable(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; List(System::Collections::Generic::IEnumerable&lt;T&gt; ^ collection);" />
      <MemberSignature Language="F#" Value="new System.Collections.Generic.List&lt;'T&gt; : seq&lt;'T&gt; -&gt; System.Collections.Generic.List&lt;'T&gt;" Usage="new System.Collections.Generic.List&lt;'T&gt; collection" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="collection" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="collection">一个集合，其元素被复制到新列表中。</param>
        <summary>初始化 <see cref="T:System.Collections.Generic.List`1" /> 类的新实例，该实例包含从指定集合复制的元素并且具有足够的容量来容纳所复制的元素。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 按集合的枚举器读取元素的顺序将这些元素复制到 <xref:System.Collections.Generic.List%601> 中。  
  
 此构造函数是一个 O (*n*) 操作，其中 *n* 是中的元素数目 `collection` 。
  
## Examples  
 下面的示例演示了对 <xref:System.Collections.Generic.List%601.%23ctor%2A> 范围执行操作的类的构造函数和各种方法 <xref:System.Collections.Generic.List%601> 。 创建一个字符串数组，并将其传递给构造函数，并用数组的元素填充该列表。 <xref:System.Collections.Generic.List%601.Capacity%2A>然后显示该属性，以显示初始容量完全是保留输入元素所需的容量。  
  
 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Ranges/cpp/source.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Ranges/cs/source.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Ranges/vb/source.vb" id="Snippet1":::
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="collection" /> 为 <see langword="null" />。</exception>
        <altmember cref="T:System.Collections.Generic.IEnumerable`1" />
        <altmember cref="P:System.Collections.Generic.List`1.Capacity" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public List (int capacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 capacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.#ctor(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (capacity As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; List(int capacity);" />
      <MemberSignature Language="F#" Value="new System.Collections.Generic.List&lt;'T&gt; : int -&gt; System.Collections.Generic.List&lt;'T&gt;" Usage="new System.Collections.Generic.List&lt;'T&gt; capacity" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="capacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="capacity">新列表最初可以存储的元素数。</param>
        <summary>初始化 <see cref="T:System.Collections.Generic.List`1" /> 类的新实例，该实例为空并且具有指定的初始容量。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 的容量 <xref:System.Collections.Generic.List%601> 是可容纳的元素数 <xref:System.Collections.Generic.List%601> 。 当向添加元素时 <xref:System.Collections.Generic.List%601> ，将根据需要通过重新分配内部数组来自动增加容量。  
  
 如果集合的大小可为估算值，则指定初始容量后，无需在将元素添加到时执行多个大小调整操作 <xref:System.Collections.Generic.List%601> 。  
  
 可以通过调用 <xref:System.Collections.Generic.List%601.TrimExcess%2A> 方法或通过显式设置属性来减少容量 <xref:System.Collections.Generic.List%601.Capacity%2A> 。 减少容量会重新分配内存，并复制中的所有元素 <xref:System.Collections.Generic.List%601> 。  
  
 此构造函数是一个 O (*n*) 操作，其中 *n* 是 `capacity` 。
  
## Examples  
 下面的示例演示了 <xref:System.Collections.Generic.List%601.%23ctor%28System.Int32%29> 构造函数。 <xref:System.Collections.Generic.List%601>创建了容量为4的字符串的，因为已知列表的最终大小为4。 使用四个字符串填充列表，并使用方法创建只读副本 <xref:System.Collections.Generic.List%601.AsReadOnly%2A> 。  
 
 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR/List`1_AsReadOnly/cpp/source.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR/List`1_AsReadOnly/cs/source.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_AsReadOnly/vb/source.vb" id="Snippet1":::
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="capacity" /> 小于 0。</exception>
        <altmember cref="P:System.Collections.Generic.List`1.Capacity" />
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public void Add (T item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Add(!T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Add(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Add (item As T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Add(T item);" />
      <MemberSignature Language="F#" Value="abstract member Add : 'T -&gt; unit&#xA;override this.Add : 'T -&gt; unit" Usage="list.Add item" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Add(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="item">要添加到 <see cref="T:System.Collections.Generic.List`1" /> 末尾的对象。 对于引用类型，该值可以为 <see langword="null" />。</param>
        <summary>将对象添加到 <see cref="T:System.Collections.Generic.List`1" /> 的结尾处。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601> 接受 `null` 作为引用类型的有效值，并允许重复元素。  
  
 如果 <xref:System.Collections.Generic.List%601.Count%2A> 已 <xref:System.Collections.Generic.List%601.Capacity%2A> 为 equals，则 <xref:System.Collections.Generic.List%601> 通过自动重新分配内部数组，并将现有元素复制到新数组，然后再添加新元素。  
  
 如果 <xref:System.Collections.Generic.List%601.Count%2A> 小于，则 <xref:System.Collections.Generic.List%601.Capacity%2A> 此方法是 O (1) 操作。 如果需要增加容量以容纳新元素，则此方法将变成 O (*n*) 操作，其中 *n* 是 <xref:System.Collections.Generic.List%601.Count%2A> 。
  
## Examples  

 下面的示例演示如何在中添加、移除和插入简单的业务对象 <xref:System.Collections.Generic.List%601> 。  
 
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/cs/program.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/vb/module1.vb" id="Snippet1":::
 :::code language="fsharp" source="~/samples/snippets/fsharp/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/fs/addremoveinsert.fs" id="Snippet1":::
  
 下面的示例演示了泛型类的多个属性和方法 <xref:System.Collections.Generic.List%601> ，包括 <xref:System.Collections.Generic.List%601.Add%2A> 方法。 无参数构造函数用于创建容量为0的字符串列表。 <xref:System.Collections.Generic.List%601.Capacity%2A>显示属性，然后 <xref:System.Collections.Generic.List%601.Add%2A> 使用方法添加多个项。 将列出这些项，并 <xref:System.Collections.Generic.List%601.Capacity%2A> 再次显示属性和 <xref:System.Collections.Generic.List%601.Count%2A> 属性，以显示容量已根据需要增加。  
  
 其他属性和方法用于搜索、插入和删除列表中的元素，最后还用于清除列表。  
  
 [!code-cpp[List\`1_Class#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Class/cpp/source.cpp#1)]
 [!code-csharp-interactive[List\`1_Class#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Class/cs/source.cs#1)]
 [!code-vb[List\`1_Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Class/vb/source.vb#1)]  
 [!code-fsharp[List\`1_Class#1](~/samples/snippets/fsharp/VS_Snippets_CLR/List`1_Class/fs/listclass.fs#1)]
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Generic.List`1.AddRange(System.Collections.Generic.IEnumerable{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.Insert(System.Int32,`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.Remove(`0)" />
        <altmember cref="P:System.Collections.Generic.List`1.Count" />
      </Docs>
    </Member>
    <Member MemberName="AddRange">
      <MemberSignature Language="C#" Value="public void AddRange (System.Collections.Generic.IEnumerable&lt;T&gt; collection);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddRange(class System.Collections.Generic.IEnumerable`1&lt;!T&gt; collection) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.AddRange(System.Collections.Generic.IEnumerable{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddRange (collection As IEnumerable(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddRange(System::Collections::Generic::IEnumerable&lt;T&gt; ^ collection);" />
      <MemberSignature Language="F#" Value="member this.AddRange : seq&lt;'T&gt; -&gt; unit" Usage="list.AddRange collection" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="collection" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="collection">应将其元素添加到 <see cref="T:System.Collections.Generic.List`1" /> 的末尾的集合。 集合自身不能为 <see langword="null" />，但它可以包含为 <see langword="null" /> 的元素（如果类型 <paramref name="T" /> 为引用类型）。</param>
        <summary>将指定集合的元素添加到 <see cref="T:System.Collections.Generic.List`1" /> 的末尾。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 集合中元素的顺序保留在中 <xref:System.Collections.Generic.List%601> 。  
  
 如果新 <xref:System.Collections.Generic.List%601.Count%2A> (当前 <xref:System.Collections.Generic.List%601.Count%2A> 加上集合的大小) 将大于 <xref:System.Collections.Generic.List%601.Capacity%2A> ，则 <xref:System.Collections.Generic.List%601> 通过自动重新分配内部数组以容纳新元素，并将现有元素复制到新数组中，然后再添加新元素。  
  
 如果在 <xref:System.Collections.Generic.List%601> 不增加的情况下可以容纳新元素 <xref:System.Collections.Generic.List%601.Capacity%2A> ，则此方法是 O (*n*) 操作，其中 *n* 是要添加的元素的数目。 如果需要增加容量以容纳新元素，则此方法将变成 O (*n*  +  *m*) 操作，其中 *n* 是要添加的元素的数目， *m* 为 <xref:System.Collections.Generic.List%601.Count%2A> 。
  
## Examples  
 下面的示例演示了对 <xref:System.Collections.Generic.List%601.AddRange%2A> 范围执行操作的类的方法和其他方法 <xref:System.Collections.Generic.List%601> 。 创建一个字符串数组，并将其传递给构造函数，并用数组的元素填充该列表。 <xref:System.Collections.Generic.List%601.AddRange%2A>调用方法，并将列表作为其参数。 结果是列表的当前元素将添加到列表的末尾，从而复制所有元素。  
  
 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Ranges/cpp/source.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Ranges/cs/source.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Ranges/vb/source.vb" id="Snippet1":::
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="collection" /> 为 <see langword="null" />。</exception>
        <altmember cref="T:System.Collections.Generic.IEnumerable`1" />
        <altmember cref="P:System.Collections.Generic.List`1.Capacity" />
        <altmember cref="P:System.Collections.Generic.List`1.Count" />
        <altmember cref="M:System.Collections.Generic.List`1.Add(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.InsertRange(System.Int32,System.Collections.Generic.IEnumerable{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.RemoveRange(System.Int32,System.Int32)" />
        <altmember cref="M:System.Collections.Generic.List`1.GetRange(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="AsReadOnly">
      <MemberSignature Language="C#" Value="public System.Collections.ObjectModel.ReadOnlyCollection&lt;T&gt; AsReadOnly ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;!T&gt; AsReadOnly() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.AsReadOnly" />
      <MemberSignature Language="VB.NET" Value="Public Function AsReadOnly () As ReadOnlyCollection(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::ObjectModel::ReadOnlyCollection&lt;T&gt; ^ AsReadOnly();" />
      <MemberSignature Language="F#" Value="member this.AsReadOnly : unit -&gt; System.Collections.ObjectModel.ReadOnlyCollection&lt;'T&gt;" Usage="list.AsReadOnly " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回当前集合的只读 <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> 包装器。</summary>
        <returns>一个对象，作为围绕当前 <see cref="T:System.Collections.Generic.List`1" /> 的只读包装器。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要防止对该对象进行任何修改 <xref:System.Collections.Generic.List%601> ，只需要通过此包装器进行公开。 <xref:System.Collections.ObjectModel.ReadOnlyCollection%601>对象不公开修改集合的方法。 但是，如果对基础对象进行了更改 <xref:System.Collections.Generic.List%601> ，只读集合将反映这些更改。  
  
 此方法是 O (1) 操作。
  
## Examples  
 下面的示例演示 <xref:System.Collections.Generic.List%601.AsReadOnly%2A> 方法。 <xref:System.Collections.Generic.List%601>创建了容量为4的字符串的，因为已知列表的最终大小为4。 列表中填充了四个字符串， <xref:System.Collections.Generic.List%601.AsReadOnly%2A> 方法用于获取 <xref:System.Collections.Generic.IList%601> 包装原始列表的只读泛型接口实现。  
  
 使用 c # ) 中索引器 (的属性将原始列表的元素设置为 "Coelophysis" <xref:System.Collections.Generic.List%601.Item%2A> ，并再次显示只读列表的内容，以表明它只是原始列表的包装。  
 
 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR/List`1_AsReadOnly/cpp/source.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR/List`1_AsReadOnly/cs/source.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_AsReadOnly/vb/source.vb" id="Snippet1":::
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="BinarySearch">
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>使用对分检索算法在已排序的 <see cref="T:System.Collections.Generic.List`1" /> 或它的一部分中查找特定元素。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BinarySearch">
      <MemberSignature Language="C#" Value="public int BinarySearch (T item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 BinarySearch(!T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.BinarySearch(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function BinarySearch (item As T) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int BinarySearch(T item);" />
      <MemberSignature Language="F#" Value="member this.BinarySearch : 'T -&gt; int" Usage="list.BinarySearch item" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="item">要定位的对象。 对于引用类型，该值可以为 <see langword="null" />。</param>
        <summary>使用默认的比较器在整个已排序的 <see cref="T:System.Collections.Generic.List`1" /> 中搜索元素，并返回该元素从零开始的索引。</summary>
        <returns>如果找到 <paramref name="item" />，则为已排序的 <see cref="T:System.Collections.Generic.List`1" /> 中 <paramref name="item" /> 的从零开始的索引；否则为一个负数，该负数是大于 <paramref name="item" /> 的下一个元素的索引的按位求补。如果没有更大的元素，则为 <see cref="P:System.Collections.Generic.List`1.Count" /> 的按位求补。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法使用类型的默认比较器 <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> `T` 来确定列表元素的顺序。 <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType>属性检查类型是否 `T` 实现 <xref:System.IComparable%601> 泛型接口，并使用该实现（如果可用）。  否则，将 <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> 检查类型是否 `T` 实现 <xref:System.IComparable> 接口。  如果类型 `T` 未实现任何一个接口， <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> 则会引发 <xref:System.InvalidOperationException> 。  
  
 <xref:System.Collections.Generic.List%601>必须已根据比较器实现进行排序; 否则，结果不正确。  
  
 `null`使用泛型接口时，允许与任何引用类型进行比较，并且不会生成异常 <xref:System.IComparable%601> 。 进行排序时， `null` 视为小于任何其他对象。  
  
 如果 <xref:System.Collections.Generic.List%601> 包含多个具有相同值的元素，则此方法只返回其中一个匹配项，并且它可能会返回任何一个匹配项，而不一定是第一个匹配项。  
  
 如果不 <xref:System.Collections.Generic.List%601> 包含指定的值，则该方法返回一个负整数。 可以将按位求补运算 (~) 应用于此负整数，以获取大于搜索值的第一个元素的索引。 将值插入到时 <xref:System.Collections.Generic.List%601> ，应将此索引用作插入点来维护排序顺序。  
  
 此方法是一个 O (log *n*) 操作，其中 *n* 是该范围中的元素的数目。
  
## Examples  
 下面的示例演示 <xref:System.Collections.Generic.List%601.Sort> 方法重载和 <xref:System.Collections.Generic.List%601.BinarySearch%28%600%29> 方法重载。 <xref:System.Collections.Generic.List%601>将创建一个字符串，并以无特定顺序填充四个字符串。 将显示并排序列表，并再次显示该列表。  
  
 <xref:System.Collections.Generic.List%601.BinarySearch%28%600%29>然后，使用方法重载搜索两个不在列表中的字符串，该方法 <xref:System.Collections.Generic.List%601.Insert%2A> 用于插入它们。 <xref:System.Collections.Generic.List%601.BinarySearch%28%600%29>在每种情况下，方法的返回值为负，因为字符串不在列表中。 采用 "c #" 和 "Visual C++ 中的 ~ 运算符 (按位求补运算， `Xor` 此负数 Visual Basic) 中的-1 将生成列表中大于搜索字符串的第一个元素的索引，并且在此位置插入将保留排序顺序。 第二个搜索字符串大于列表中的任何元素，因此插入位置在列表的末尾。  
  
 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR/List`1_SortSearch/cpp/source.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR/List`1_SortSearch/cs/source.cs" interactive="try-dotnet-method" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_SortSearch/vb/source.vb" id="Snippet1":::
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">此默认比较器 <see cref="P:System.Collections.Generic.Comparer`1.Default" /> 无法找到 <see cref="T:System.IComparable`1" /> 泛型接口或类型为 <paramref name="T" /> 的 <see cref="T:System.IComparable" /> 接口的实现。</exception>
        <related type="Article" href="/dotnet/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections">在集合中执行不区分区域性的字符串操作</related>
      </Docs>
    </Member>
    <Member MemberName="BinarySearch">
      <MemberSignature Language="C#" Value="public int BinarySearch (T item, System.Collections.Generic.IComparer&lt;T&gt; comparer);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 BinarySearch(!T item, class System.Collections.Generic.IComparer`1&lt;!T&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.BinarySearch(`0,System.Collections.Generic.IComparer{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function BinarySearch (item As T, comparer As IComparer(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int BinarySearch(T item, System::Collections::Generic::IComparer&lt;T&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="member this.BinarySearch : 'T * System.Collections.Generic.IComparer&lt;'T&gt; -&gt; int" Usage="list.BinarySearch (item, comparer)" />
      <MemberSignature Language="C#" Value="public int BinarySearch (T item, System.Collections.Generic.IComparer&lt;T&gt;? comparer);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="item">要定位的对象。 对于引用类型，该值可以为 <see langword="null" />。</param>
        <param name="comparer">比较元素时要使用的 <see cref="T:System.Collections.Generic.IComparer`1" /> 实现。  
  
- 或 - 
 如果使用默认比较器 <see cref="P:System.Collections.Generic.Comparer`1.Default" />，则为 <see langword="null" />。</param>
        <summary>使用指定的比较器在整个已排序的 <see cref="T:System.Collections.Generic.List`1" /> 中搜索元素，并返回该元素从零开始的索引。</summary>
        <returns>如果找到 <paramref name="item" />，则为已排序的 <see cref="T:System.Collections.Generic.List`1" /> 中 <paramref name="item" /> 的从零开始的索引；否则为一个负数，该负数是大于 <paramref name="item" /> 的下一个元素的索引的按位求补。如果没有更大的元素，则为 <see cref="P:System.Collections.Generic.List`1.Count" /> 的按位求补。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 比较器自定义元素的比较方式。 例如，可以将 <xref:System.Collections.CaseInsensitiveComparer> 实例用作比较器来执行不区分大小写的字符串搜索。  
  
 如果 `comparer` 提供了，则使用指定的实现将的元素 <xref:System.Collections.Generic.List%601> 与指定的值进行比较 <xref:System.Collections.Generic.IComparer%601> 。  
  
 如果 `comparer` 为 `null` ，则默认比较器将 <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> 检查类型是否 `T` 实现 <xref:System.IComparable%601> 泛型接口，并使用该实现（如果可用）。  否则，将 <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> 检查类型是否 `T` 实现 <xref:System.IComparable> 接口。  如果类型 `T` 未实现任何一个接口， <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> 则引发 <xref:System.InvalidOperationException> 。  
  
 <xref:System.Collections.Generic.List%601>必须已根据比较器实现进行排序; 否则，结果不正确。  
  
 `null`使用泛型接口时，允许与任何引用类型进行比较，并且不会生成异常 <xref:System.IComparable%601> 。 进行排序时， `null` 视为小于任何其他对象。  
  
 如果 <xref:System.Collections.Generic.List%601> 包含多个具有相同值的元素，则此方法只返回其中一个匹配项，并且它可能会返回任何一个匹配项，而不一定是第一个匹配项。  
  
 如果不 <xref:System.Collections.Generic.List%601> 包含指定的值，则该方法返回一个负整数。 可以将按位求补运算 (~) 应用于此负整数，以获取大于搜索值的第一个元素的索引。 将值插入到时 <xref:System.Collections.Generic.List%601> ，应将此索引用作插入点来维护排序顺序。  
  
 此方法是一个 O (log *n*) 操作，其中 *n* 是该范围中的元素的数目。
  
## Examples  
 下面的示例演示 <xref:System.Collections.Generic.List%601.Sort%28System.Collections.Generic.IComparer%7B%600%7D%29> 方法重载和 <xref:System.Collections.Generic.List%601.BinarySearch%28%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> 方法重载。  
  
 该示例定义了一个名为 DinoCompare 的字符串的替代比较器，该比较器 `IComparer<string>` `IComparer(Of String)` `IComparer<String^>` 在 Visual C++) 泛型接口中实现 Visual Basic 中的 (。 比较器的工作方式如下：首先，测试比较规则 `null` ，并将 null 引用视为小于非空引用。 其次，比较字符串长度，较长的字符串被认为更大。 第三，如果长度相等，则使用普通字符串比较。  
  
 <xref:System.Collections.Generic.List%601>将创建一个字符串，并以无特定顺序填充四个字符串。 随即显示列表，使用替代比较器对其进行排序，并再次显示。  
  
 <xref:System.Collections.Generic.List%601.BinarySearch%28%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29>然后，使用方法重载搜索多个不在列表中的字符串（采用备用比较器）。 <xref:System.Collections.Generic.List%601.Insert%2A>方法用于插入字符串。 这两个方法都位于名为的函数中 `SearchAndInsert` ，以及用于采用 c # 和 Visual C++ 中的 ~ 运算符 (按位求补的代码 `Xor`) Visual Basic， <xref:System.Collections.Generic.List%601.BinarySearch%28%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> 并将其用作用于插入新字符串的索引。  
 
 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR/List`1_SortSearchComparer/cpp/source.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR/List`1_SortSearchComparer/cs/source.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_SortSearchComparer/vb/source.vb" id="Snippet1":::
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><paramref name="comparer" /> 为 <see langword="null" />，并且默认比较器 <see cref="P:System.Collections.Generic.Comparer`1.Default" /> 找不到 <see cref="T:System.IComparable`1" /> 泛型接口或类型为 <paramref name="T" /> 的 <see cref="T:System.IComparable" /> 接口的实现。</exception>
        <related type="Article" href="/dotnet/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections">在集合中执行不区分区域性的字符串操作</related>
      </Docs>
    </Member>
    <Member MemberName="BinarySearch">
      <MemberSignature Language="C#" Value="public int BinarySearch (int index, int count, T item, System.Collections.Generic.IComparer&lt;T&gt; comparer);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 BinarySearch(int32 index, int32 count, !T item, class System.Collections.Generic.IComparer`1&lt;!T&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.BinarySearch(System.Int32,System.Int32,`0,System.Collections.Generic.IComparer{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function BinarySearch (index As Integer, count As Integer, item As T, comparer As IComparer(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int BinarySearch(int index, int count, T item, System::Collections::Generic::IComparer&lt;T&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="member this.BinarySearch : int * int * 'T * System.Collections.Generic.IComparer&lt;'T&gt; -&gt; int" Usage="list.BinarySearch (index, count, item, comparer)" />
      <MemberSignature Language="C#" Value="public int BinarySearch (int index, int count, T item, System.Collections.Generic.IComparer&lt;T&gt;? comparer);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="item" Type="T" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="index">要搜索范围的从零开始的起始索引。</param>
        <param name="count">要搜索的范围的长度。</param>
        <param name="item">要定位的对象。 对于引用类型，该值可以为 <see langword="null" />。</param>
        <param name="comparer">比较元素时要使用的 <see cref="T:System.Collections.Generic.IComparer`1" /> 实现，若要使用默认比较器 <see cref="P:System.Collections.Generic.Comparer`1.Default" />，则为 <see langword="null" />。</param>
        <summary>使用指定的比较器在已排序 <see cref="T:System.Collections.Generic.List`1" /> 的某个元素范围中搜索元素，并返回该元素从零开始的索引。</summary>
        <returns>如果找到 <paramref name="item" />，则为已排序的 <see cref="T:System.Collections.Generic.List`1" /> 中 <paramref name="item" /> 的从零开始的索引；否则为一个负数，该负数是大于 <paramref name="item" /> 的下一个元素的索引的按位求补。如果没有更大的元素，则为 <see cref="P:System.Collections.Generic.List`1.Count" /> 的按位求补。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 比较器自定义元素的比较方式。 例如，可以将 <xref:System.Collections.CaseInsensitiveComparer> 实例用作比较器来执行不区分大小写的字符串搜索。  
  
 如果 `comparer` 提供了，则使用指定的实现将的元素 <xref:System.Collections.Generic.List%601> 与指定的值进行比较 <xref:System.Collections.Generic.IComparer%601> 。  
  
 如果 `comparer` 为 `null` ，则默认比较器将 <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> 检查类型是否 `T` 实现 <xref:System.IComparable%601> 泛型接口，并使用该实现（如果可用）。  否则，将 <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> 检查类型是否 `T` 实现 <xref:System.IComparable> 接口。  如果类型 `T` 未实现任何一个接口， <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> 则引发 <xref:System.InvalidOperationException> 。  
  
 <xref:System.Collections.Generic.List%601>必须已根据比较器实现进行排序; 否则，结果不正确。  
  
 `null`使用泛型接口时，允许与任何引用类型进行比较，并且不会生成异常 <xref:System.IComparable%601> 。 进行排序时， `null` 视为小于任何其他对象。  
  
 如果 <xref:System.Collections.Generic.List%601> 包含多个具有相同值的元素，则此方法只返回其中一个匹配项，并且它可能会返回任何一个匹配项，而不一定是第一个匹配项。  
  
 如果不 <xref:System.Collections.Generic.List%601> 包含指定的值，则该方法返回一个负整数。 可以将按位求补运算 (~) 应用于此负整数，以获取大于搜索值的第一个元素的索引。 将值插入到时 <xref:System.Collections.Generic.List%601> ，应将此索引用作插入点来维护排序顺序。  
  
 此方法是一个 O (log *n*) 操作，其中 *n* 是该范围中的元素的数目。
  
## Examples  
 下面的示例演示 <xref:System.Collections.Generic.List%601.Sort%28System.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> 方法重载和 <xref:System.Collections.Generic.List%601.BinarySearch%28System.Int32%2CSystem.Int32%2C%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> 方法重载。  
  
 该示例定义了一个名为 DinoCompare 的字符串的替代比较器，该比较器 `IComparer<string>` `IComparer(Of String)` `IComparer<String^>` 在 Visual C++) 泛型接口中实现 Visual Basic 中的 (。 比较器的工作方式如下：首先，测试比较规则 `null` ，并将 null 引用视为小于非空引用。 其次，比较字符串长度，较长的字符串被认为更大。 第三，如果长度相等，则使用普通字符串比较。  
  
 <xref:System.Collections.Generic.List%601>创建一个字符串，并使用5个 herbivorous 恐龙和3个 carnivorous 恐龙的名称填充。 这两个组中的每个组的名称不是任何特定的排序顺序。 随即显示列表，使用替代比较器对 herbivores 的范围进行排序，并再次显示该列表。  
  
 <xref:System.Collections.Generic.List%601.BinarySearch%28System.Int32%2CSystem.Int32%2C%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29>然后，使用方法重载仅搜索 "Brachiosaurus" 的 herbivores 范围。 找不到该字符串，按位求补 (c # 中的 ~ 运算符和 Visual C++， `Xor` 该方法返回的负数 Visual Basic) 中的-1 <xref:System.Collections.Generic.List%601.BinarySearch%28System.Int32%2CSystem.Int32%2C%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> 将用作插入新字符串的索引。  
 
 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR/List`1_SortSearchComparerRange/cpp/source.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR/List`1_SortSearchComparerRange/cs/source.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_SortSearchComparerRange/vb/source.vb" id="Snippet1":::
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> 小于 0。  
  
- 或 - 
 <paramref name="count" /> 小于 0。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="index" /> 和 <paramref name="count" /> 不表示 <see cref="T:System.Collections.Generic.List`1" /> 中的有效范围。</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="comparer" /> 为 <see langword="null" />，并且默认比较器 <see cref="P:System.Collections.Generic.Comparer`1.Default" /> 找不到 <see cref="T:System.IComparable`1" /> 泛型接口或类型为 <paramref name="T" /> 的 <see cref="T:System.IComparable" /> 接口的实现。</exception>
        <altmember cref="T:System.Collections.Generic.IComparer`1" />
        <altmember cref="T:System.IComparable`1" />
        <related type="Article" href="/dotnet/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections">在集合中执行不区分区域性的字符串操作</related>
      </Docs>
    </Member>
    <Member MemberName="Capacity">
      <MemberSignature Language="C#" Value="public int Capacity { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Capacity" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.List`1.Capacity" />
      <MemberSignature Language="VB.NET" Value="Public Property Capacity As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Capacity { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.Capacity : int with get, set" Usage="System.Collections.Generic.List&lt;'T&gt;.Capacity" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName Language="C#">[get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置该内部数据结构在不调整大小的情况下能够容纳的元素总数。</summary>
        <value>在需要调整大小之前 <see cref="T:System.Collections.Generic.List`1" /> 可包含的元素数目。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601.Capacity%2A> 在 <xref:System.Collections.Generic.List%601> 需要调整大小之前可存储的元素数，而 <xref:System.Collections.Generic.List%601.Count%2A> 是中实际的元素数 <xref:System.Collections.Generic.List%601> 。  
  
 <xref:System.Collections.Generic.List%601.Capacity%2A> 始终大于或等于 <xref:System.Collections.Generic.List%601.Count%2A> 。 如果 <xref:System.Collections.Generic.List%601.Count%2A> 在 <xref:System.Collections.Generic.List%601.Capacity%2A> 添加元素时超过，则会在复制旧元素并添加新元素之前自动重新分配内部数组，从而增加容量。  
  
 如果容量大大大于计数，并且你想要减少使用的内存 <xref:System.Collections.Generic.List%601> ，则可以通过调用 <xref:System.Collections.Generic.List%601.TrimExcess%2A> 方法或将 <xref:System.Collections.Generic.List%601.Capacity%2A> 属性显式设置为较低值来减少容量。 如果显式设置的值，则还将重新 <xref:System.Collections.Generic.List%601.Capacity%2A> 分配内部数组以容纳指定的容量，并复制所有元素。  
  
 检索此属性的值是一个 O (1) 操作;设置属性是一个 O (*n*) 操作，其中 *n* 是新容量。
   
## Examples  
 
 下面的示例演示如何检查 <xref:System.Collections.Generic.List%601> 包含简单业务对象的的容量和计数，并说明如何使用 <xref:System.Collections.Generic.List%601.TrimExcess%2A> 方法来删除额外的容量。  
  
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.capacitycount/cs/program.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.capacitycount/vb/module1.vb" id="Snippet1":::
  
 下面的示例显示 <xref:System.Collections.Generic.List%601.Capacity%2A> 列表生存期中多个点的属性。 无参数构造函数用于创建容量为0的字符串列表，并 <xref:System.Collections.Generic.List%601.Capacity%2A> 显示属性以演示这一点。 <xref:System.Collections.Generic.List%601.Add%2A>使用方法添加多个项后，将列出这些项，然后 <xref:System.Collections.Generic.List%601.Capacity%2A> 再次显示属性和 <xref:System.Collections.Generic.List%601.Count%2A> 属性，以显示容量已根据需要增加。  
  
 <xref:System.Collections.Generic.List%601.Capacity%2A> <xref:System.Collections.Generic.List%601.TrimExcess%2A> 使用方法减小与计数匹配的容量后，将再次显示该属性。 最后， <xref:System.Collections.Generic.List%601.Clear%2A> 使用方法从列表中移除所有项，并 <xref:System.Collections.Generic.List%601.Capacity%2A> <xref:System.Collections.Generic.List%601.Count%2A> 再次显示和属性。  
  
 [!code-cpp[List\`1_Class#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Class/cpp/source.cpp#1)]
 [!code-csharp-interactive[List\`1_Class#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Class/cs/source.cs#1)]
 [!code-vb[List\`1_Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Class/vb/source.vb#1)]  
 [!code-fsharp[List\`1_Class#1](~/samples/snippets/fsharp/VS_Snippets_CLR/List`1_Class/fs/listclass.fs#1)]
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><see cref="P:System.Collections.Generic.List`1.Capacity" /> 已设置为一个小于 <see cref="P:System.Collections.Generic.List`1.Count" /> 的值。</exception>
        <exception cref="T:System.OutOfMemoryException">系统上没有足够的可用内存。</exception>
        <altmember cref="P:System.Collections.Generic.List`1.Count" />
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Sub Clear ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Clear();" />
      <MemberSignature Language="F#" Value="abstract member Clear : unit -&gt; unit&#xA;override this.Clear : unit -&gt; unit" Usage="list.Clear " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Clear</InterfaceMember>
        <InterfaceMember>M:System.Collections.IList.Clear</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>从 <see cref="T:System.Collections.Generic.List`1" /> 中移除所有元素。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601.Count%2A> 设置为0，还会释放对集合的元素的其他对象的引用。  
  
 <xref:System.Collections.Generic.List%601.Capacity%2A> 保持不变。 若要重置的容量 <xref:System.Collections.Generic.List%601> ，请调用 <xref:System.Collections.Generic.List%601.TrimExcess%2A> 方法或直接设置 <xref:System.Collections.Generic.List%601.Capacity%2A> 属性。 减少容量会重新分配内存，并复制中的所有元素 <xref:System.Collections.Generic.List%601> 。 修整空会将的 <xref:System.Collections.Generic.List%601> 容量设置 <xref:System.Collections.Generic.List%601> 为默认容量。  
  
 此方法是 O (*n*) 操作，其中 *n* 是 <xref:System.Collections.Generic.List%601.Count%2A> 。
  
## Examples  

 下面的示例演示了 <xref:System.Collections.Generic.List%601.Clear%2A> 泛型类的方法和其他各种属性和方法 <xref:System.Collections.Generic.List%601> 。 在 <xref:System.Collections.Generic.List%601.Clear%2A> 程序的末尾使用方法，以便从列表中删除所有项，然后 <xref:System.Collections.Generic.List%601.Capacity%2A> <xref:System.Collections.Generic.List%601.Count%2A> 显示和属性。  
  
 [!code-cpp[List\`1_Class#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Class/cpp/source.cpp#1)]
 [!code-csharp-interactive[List\`1_Class#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Class/cs/source.cs#1)]
 [!code-vb[List\`1_Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Class/vb/source.vb#1)]  
 [!code-fsharp[List\`1_Class#1](~/samples/snippets/fsharp/VS_Snippets_CLR/List`1_Class/fs/listclass.fs#1)]
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Generic.List`1.TrimExcess" />
        <altmember cref="P:System.Collections.Generic.List`1.Capacity" />
        <altmember cref="P:System.Collections.Generic.List`1.Count" />
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (T item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Contains(!T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Contains(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function Contains (item As T) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Contains(T item);" />
      <MemberSignature Language="F#" Value="abstract member Contains : 'T -&gt; bool&#xA;override this.Contains : 'T -&gt; bool" Usage="list.Contains item" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Contains(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="item">要在 <see cref="T:System.Collections.Generic.List`1" /> 中定位的对象。 对于引用类型，该值可以为 <see langword="null" />。</param>
        <summary>确定某元素是否在 <see cref="T:System.Collections.Generic.List`1" /> 中。</summary>
        <returns>如果在 <see langword="true" /> 中找到 <paramref name="item" />，则为 <see cref="T:System.Collections.Generic.List`1" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法通过使用默认的相等比较器来确定相等性，如对象实现的方法所定义的 <xref:System.IEquatable%601.Equals%2A?displayProperty=nameWithType> `T` (列表) 中值的类型。  
  
 此方法执行线性搜索;因此，此方法是 O (*n*) 操作，其中 *n* 是 <xref:System.Collections.Generic.List%601.Count%2A> 。
  
## Examples  
 下面的示例演示了的 <xref:System.Collections.Generic.List%601.Contains%2A> 和 <xref:System.Collections.Generic.List%601.Exists%2A> 方法 <xref:System.Collections.Generic.List%601> ，其中包含实现的简单业务对象 <xref:System.IEquatable%601.Equals%2A> 。  
 
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.containsexists/cs/program.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.containsexists/vb/module1.vb" id="Snippet1"::: 
  
 下面的示例包含类型为的复杂对象的列表 `Cube` 。 `Cube`类实现方法， <xref:System.IEquatable%601.Equals%2A?displayProperty=nameWithType> 以便两个多维数据集的维度相同时被视为相等。 在此示例中， <xref:System.Collections.Generic.List%601.Contains%2A> 方法返回 `true` ，因为集合中已存在具有指定维度的多维数据集。  
 
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.contains/cs/program.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.contains/vb/program.vb" id="Snippet1":::
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Generic.List`1.IndexOf(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.LastIndexOf(`0)" />
        <related type="Article" href="/dotnet/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections">在集合中执行不区分区域性的字符串操作</related>
      </Docs>
    </Member>
    <Member MemberName="ConvertAll&lt;TOutput&gt;">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.List&lt;TOutput&gt; ConvertAll&lt;TOutput&gt; (Converter&lt;T,TOutput&gt; converter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.List`1&lt;!!TOutput&gt; ConvertAll&lt;TOutput&gt;(class System.Converter`2&lt;!T, !!TOutput&gt; converter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.ConvertAll``1(System.Converter{`0,``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function ConvertAll(Of TOutput) (converter As Converter(Of T, TOutput)) As List(Of TOutput)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TOutput&gt;&#xA; System::Collections::Generic::List&lt;TOutput&gt; ^ ConvertAll(Converter&lt;T, TOutput&gt; ^ converter);" />
      <MemberSignature Language="F#" Value="member this.ConvertAll : Converter&lt;'T, 'Output&gt; -&gt; System.Collections.Generic.List&lt;'Output&gt;" Usage="list.ConvertAll converter" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.List&lt;TOutput&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TOutput" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="converter" Type="System.Converter&lt;T,TOutput&gt;" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <typeparam name="TOutput">目标数组元素的类型。</typeparam>
        <param name="converter">一个 <see cref="T:System.Converter`2" /> 委托，可将每个元素从一种类型转换为另一种类型。</param>
        <summary>将当前 <see cref="T:System.Collections.Generic.List`1" /> 中的元素转换为另一种类型，并返回包含已转换元素的列表。</summary>
        <returns>目标类型的 <see cref="T:System.Collections.Generic.List`1" />，包含当前 <see cref="T:System.Collections.Generic.List`1" /> 中转换后的元素。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Converter%602>是一个方法委托，该委托将对象转换为目标类型。  当前的元素 <xref:System.Collections.Generic.List%601> 分别传递到 <xref:System.Converter%602> 委托，转换后的元素保存在新的中 <xref:System.Collections.Generic.List%601> 。  
  
 当前 <xref:System.Collections.Generic.List%601> 保持不变。  
  
 此方法是 O (*n*) 操作，其中 *n* 是 <xref:System.Collections.Generic.List%601.Count%2A> 。
  
## Examples  
 下面的示例定义了一个名为 `PointFToPoint` 的方法，该方法将 <xref:System.Drawing.PointF> 结构转换为 <xref:System.Drawing.Point> 结构。 然后，该示例创建了一个 <xref:System.Collections.Generic.List%601> <xref:System.Drawing.PointF> 结构， `Converter\<PointF, Point>` `Converter(Of PointF, Point)` 在 Visual Basic) 中创建委托 (来表示 `PointFToPoint` 方法，并将委托传递给 <xref:System.Collections.Generic.List%601.ConvertAll%2A> 方法。 <xref:System.Collections.Generic.List%601.ConvertAll%2A>方法将输入列表的每个元素传递给 `PointFToPoint` 方法，并将转换后的元素放入新的 <xref:System.Drawing.Point> 结构列表。 将显示这两个列表。  
 
 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR/List`1_ConvertAll/cpp/source.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR/List`1_ConvertAll/cs/source.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_ConvertAll/vb/source.vb" id="Snippet1":::
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="converter" /> 为 <see langword="null" />。</exception>
        <altmember cref="T:System.Converter`2" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CopyTo">
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>将 <see cref="T:System.Collections.Generic.List`1" /> 或它的一部分复制到一个数组中。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
   
## Examples  
 下面的示例演示方法的所有三个重载 <xref:System.Collections.Generic.List%601.CopyTo%2A> 。 <xref:System.Collections.Generic.List%601>创建字符串的，并使用5个字符串填充。 将创建一个由15个元素组成的空字符串数组， <xref:System.Collections.Generic.List%601.CopyTo%28%600%5B%5D%29> 方法重载用于将列表中的所有元素复制到数组中从数组的第一个元素开始的位置。 <xref:System.Collections.Generic.List%601.CopyTo%28%600%5B%5D%2CSystem.Int32%29>方法重载用于将列表中的所有元素复制到数组索引6开始 (数组索引为5的空) 。 最后， <xref:System.Collections.Generic.List%601.CopyTo%28System.Int32%2C%600%5B%5D%2CSystem.Int32%2CSystem.Int32%29> 使用方法重载将从索引2开始的列表中的3个元素复制到数组索引12处开始的数组， (使索引11为空) 。 然后，将显示数组的内容。  
  
 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR/List`1_CopyTo/cpp/source.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR/List`1_CopyTo/cs/source.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_CopyTo/vb/source.vb" id="Snippet1":::
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.CopyTo(`0[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (array As T())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyTo(cli::array &lt;T&gt; ^ array);" />
      <MemberSignature Language="F#" Value="member this.CopyTo : 'T[] -&gt; unit" Usage="list.CopyTo array" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <param name="array">一维 <see cref="T:System.Array" />，它是从 <see cref="T:System.Collections.Generic.List`1" /> 复制的元素的目标。 <see cref="T:System.Array" /> 必须具有从零开始的索引。</param>
        <summary>从目标数组的开头开始，将整个 <see cref="T:System.Collections.Generic.List`1" /> 复制到兼容的一维数组。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法使用 <xref:System.Array.Copy%2A?displayProperty=nameWithType> 复制元素。  
  
 元素 <xref:System.Array> 按枚举器循环访问的相同顺序复制到中 <xref:System.Collections.Generic.List%601> 。  
  
 此方法是 O (*n*) 操作，其中 *n* 是 <xref:System.Collections.Generic.List%601.Count%2A> 。
 
       ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">源 <see cref="T:System.Collections.Generic.List`1" /> 中的元素个数大于目标 <paramref name="array" /> 可以包含的元素个数。</exception>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (T[] array, int arrayIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void CopyTo(!T[] array, int32 arrayIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.CopyTo(`0[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (array As T(), arrayIndex As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void CopyTo(cli::array &lt;T&gt; ^ array, int arrayIndex);" />
      <MemberSignature Language="F#" Value="abstract member CopyTo : 'T[] * int -&gt; unit&#xA;override this.CopyTo : 'T[] * int -&gt; unit" Usage="list.CopyTo (array, arrayIndex)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.CopyTo(`0[],System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="arrayIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">一维 <see cref="T:System.Array" />，它是从 <see cref="T:System.Collections.Generic.List`1" /> 复制的元素的目标。 <see cref="T:System.Array" /> 必须具有从零开始的索引。</param>
        <param name="arrayIndex"><paramref name="array" /> 中从零开始的索引，从此处开始复制。</param>
        <summary>从目标数组的指定索引处开始，将整个 <see cref="T:System.Collections.Generic.List`1" /> 复制到兼容的一维数组。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法使用 <xref:System.Array.Copy%2A?displayProperty=nameWithType> 复制元素。  
  
 元素 <xref:System.Array> 按枚举器循环访问的相同顺序复制到中 <xref:System.Collections.Generic.List%601> 。  
  
 此方法是 O (*n*) 操作，其中 *n* 是 <xref:System.Collections.Generic.List%601.Count%2A> 。  
   
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="arrayIndex" /> 小于 0。</exception>
        <exception cref="T:System.ArgumentException">源 <see cref="T:System.Collections.Generic.List`1" /> 中的元素个数大于从 <paramref name="arrayIndex" /> 到目标 <paramref name="array" /> 末尾之间的可用空间。</exception>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (int index, T[] array, int arrayIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(int32 index, !T[] array, int32 arrayIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.CopyTo(System.Int32,`0[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (index As Integer, array As T(), arrayIndex As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyTo(int index, cli::array &lt;T&gt; ^ array, int arrayIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.CopyTo : int * 'T[] * int * int -&gt; unit" Usage="list.CopyTo (index, array, arrayIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="arrayIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">复制即从源 <see cref="T:System.Collections.Generic.List`1" /> 中从零开始的索引开始。</param>
        <param name="array">一维 <see cref="T:System.Array" />，它是从 <see cref="T:System.Collections.Generic.List`1" /> 复制的元素的目标。 <see cref="T:System.Array" /> 必须具有从零开始的索引。</param>
        <param name="arrayIndex"><paramref name="array" /> 中从零开始的索引，从此处开始复制。</param>
        <param name="count">要复制的元素数。</param>
        <summary>从目标数组的指定索引处开始，将元素的范围从 <see cref="T:System.Collections.Generic.List`1" /> 复制到兼容的一维数组。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法使用 <xref:System.Array.Copy%2A?displayProperty=nameWithType> 复制元素。  
  
 元素 <xref:System.Array> 按枚举器循环访问的相同顺序复制到中 <xref:System.Collections.Generic.List%601> 。  
  
 此方法是 O (*n*) 操作，其中 *n* 是 `count` 。  
   
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> 小于 0。  
  
- 或 - 
 <paramref name="arrayIndex" /> 小于 0。  
  
- 或 - 
 <paramref name="count" /> 小于 0。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="index" /> 等于或大于源 <see cref="T:System.Collections.Generic.List`1" /> 的 <see cref="P:System.Collections.Generic.List`1.Count" />。  
  
- 或 - 
从 <paramref name="index" /> 到源 <see cref="T:System.Collections.Generic.List`1" /> 的末尾的元素数大于从 <paramref name="arrayIndex" /> 到目标 <paramref name="array" /> 的末尾的可用空间。</exception>
      </Docs>
    </Member>
    <Member MemberName="Count">
      <MemberSignature Language="C#" Value="public int Count { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Count" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.List`1.Count" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Count As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Count { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Count : int" Usage="System.Collections.Generic.List&lt;'T&gt;.Count" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.ICollection`1.Count</InterfaceMember>
        <InterfaceMember FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">P:System.Collections.Generic.IReadOnlyCollection`1.Count</InterfaceMember>
        <InterfaceMember FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1">P:System.Collections.ICollection.Count</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取 <see cref="T:System.Collections.Generic.List`1" /> 中包含的元素数。</summary>
        <value><see cref="T:System.Collections.Generic.List`1" /> 中包含的元素数。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601.Capacity%2A><xref:System.Collections.Generic.List%601>需要调整大小之前可存储的元素数。 <xref:System.Collections.Generic.List%601.Count%2A> 实际在中的元素的数目 <xref:System.Collections.Generic.List%601> 。  
  
 <xref:System.Collections.Generic.List%601.Capacity%2A> 始终大于或等于 <xref:System.Collections.Generic.List%601.Count%2A> 。 如果 <xref:System.Collections.Generic.List%601.Count%2A> 在 <xref:System.Collections.Generic.List%601.Capacity%2A> 添加元素时超过，则会在复制旧元素并添加新元素之前自动重新分配内部数组，从而增加容量。  
  
 检索此属性的值的运算复杂度为 O(1)。
  
## Examples  

 下面的示例演示如何检查  <xref:System.Collections.Generic.List%601> 包含简单业务对象的的容量和计数，并说明如何使用 <xref:System.Collections.Generic.List%601.TrimExcess%2A> 方法来删除额外的容量。  
 
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.capacitycount/cs/program.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.capacitycount/vb/module1.vb" id="Snippet1":::
  
 下面的示例显示 <xref:System.Collections.Generic.List%601.Count%2A> 列表生存期中各个点的属性值。 创建并填充列表并显示其元素后，将 <xref:System.Collections.Generic.List%601.Capacity%2A> <xref:System.Collections.Generic.List%601.Count%2A> 显示和属性。 这些属性在调用方法之后再次显示 <xref:System.Collections.Generic.List%601.TrimExcess%2A> ，并在列表的内容被清除后再次显示。  

 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Class/cpp/source.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Class/cs/source.cs" interactive="try-dotnet-method" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Class/vb/source.vb" id="Snippet1":::
 :::code language="fsharp" source="~/samples/snippets/fsharp/VS_Snippets_CLR/List`1_Class/fs/listclass.fs" id="Snippet1":::
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Collections.Generic.List`1.Capacity" />
      </Docs>
    </Member>
    <Member MemberName="Exists">
      <MemberSignature Language="C#" Value="public bool Exists (Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Exists(class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Exists(System.Predicate{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function Exists (match As Predicate(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Exists(Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="member this.Exists : Predicate&lt;'T&gt; -&gt; bool" Usage="list.Exists match" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="match"><see cref="T:System.Predicate`1" /> 委托，用于定义要搜索的元素应满足的条件。</param>
        <summary>确定 <see cref="T:System.Collections.Generic.List`1" /> 是否包含与指定谓词定义的条件匹配的元素。</summary>
        <returns>如果 <see cref="T:System.Collections.Generic.List`1" /> 包含一个或多个元素与指定谓词定义的条件匹配，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Predicate%601>是一个方法委托， `true` 如果传递给它的对象与委托中定义的条件相匹配，则它将返回。  当前的元素 <xref:System.Collections.Generic.List%601> 分别传递到 <xref:System.Predicate%601> 委托，并在找到匹配项时停止处理。  
  
 此方法执行线性搜索;因此，此方法是 O (*n*) 操作，其中 *n* 是 <xref:System.Collections.Generic.List%601.Count%2A> 。
  
## Examples  
 下面的示例演示了的 <xref:System.Collections.Generic.List%601.Contains%2A> 和 <xref:System.Collections.Generic.List%601.Exists%2A> 方法 <xref:System.Collections.Generic.List%601> ，其中包含实现的简单业务对象 <xref:System.IEquatable%601.Equals%2A> 。  
  
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.containsexists/cs/program.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.containsexists/vb/module1.vb" id="Snippet1":::
  
 下面的示例演示了 <xref:System.Collections.Generic.List%601.Exists%2A> 使用泛型委托的方法和其他几种方法 <xref:System.Predicate%601> 。  
  
 <xref:System.Collections.Generic.List%601>创建一个字符串，其中包含8个恐龙名称，其中两个名称 (在位置1，5) 以 "saurus" 结尾。 该示例还定义了一个名为的搜索谓词方法 `EndsWithSaurus` ，该方法接受一个字符串参数，并返回一个布尔值，指示输入字符串是否以 "saurus" 结尾。  
  
 <xref:System.Collections.Generic.List%601.Find%2A>、 <xref:System.Collections.Generic.List%601.FindLast%2A> 和 <xref:System.Collections.Generic.List%601.FindAll%2A> 方法用于在列表中搜索搜索谓词方法，然后 <xref:System.Collections.Generic.List%601.RemoveAll%2A> 使用方法删除所有以 "saurus" 结尾的项。  
  
 最后， <xref:System.Collections.Generic.List%601.Exists%2A> 调用方法。 它从头开始遍历列表，并将每个元素传递给 `EndsWithSaurus` 方法。 `true`如果 `EndsWithSaurus` 方法为任何元素返回，则搜索将停止，并且方法将返回 `true` 。 <xref:System.Collections.Generic.List%601.Exists%2A>方法返回， `false` 因为已删除所有此类元素。  
  
> [!NOTE]
>  在 c # 和 Visual Basic 中，无需 `Predicate<string>` `Predicate(Of String)` 显式创建 Visual Basic) 中的委托 (。 这些语言从上下文推断正确的委托并自动创建它。  
 
 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR/List`1_FindEtAl/cpp/source.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR/List`1_FindEtAl/cs/source.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_FindEtAl/vb/source.vb" id="Snippet1"::: 
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="match" /> 为 <see langword="null" />。</exception>
        <altmember cref="M:System.Collections.Generic.List`1.Find(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindLast(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindAll(System.Predicate{`0})" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindLastIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.BinarySearch" />
        <altmember cref="Overload:System.Collections.Generic.List`1.IndexOf" />
        <altmember cref="Overload:System.Collections.Generic.List`1.LastIndexOf" />
        <altmember cref="M:System.Collections.Generic.List`1.TrueForAll(System.Predicate{`0})" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="Find">
      <MemberSignature Language="C#" Value="public T Find (Predicate&lt;T&gt; match);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !T Find(class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Find(System.Predicate{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function Find (match As Predicate(Of T)) As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; T Find(Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="member this.Find : Predicate&lt;'T&gt; -&gt; 'T" Usage="list.Find match" />
      <MemberSignature Language="C#" Value="public T? Find (Predicate&lt;T&gt; match);" FrameworkAlternate="net-5.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="match"><see cref="T:System.Predicate`1" /> 委托，用于定义要搜索的元素的条件。</param>
        <summary>搜索与指定谓词所定义的条件相匹配的元素，并返回整个 <see cref="T:System.Collections.Generic.List`1" /> 中的第一个匹配元素。</summary>
        <returns>如果找到与指定谓词定义的条件匹配的第一个元素，则为该元素；否则为类型 <paramref name="T" /> 的默认值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Predicate%601>是一个方法委托， `true` 如果传递给它的对象与委托中定义的条件相匹配，则它将返回。  当前的元素 <xref:System.Collections.Generic.List%601> 分别传递到 <xref:System.Predicate%601> 委托，并在中向前移动 <xref:System.Collections.Generic.List%601> ，从第一个元素开始，到最后一个元素结束。  找到匹配项时将停止处理。  
  
> [!IMPORTANT]
>  在搜索包含值类型的列表时，请确保该类型的默认值不满足搜索谓词。 否则，无法区分默认值，指示找不到任何匹配项，并且不能区分发生了该类型的默认值的列表元素。 如果默认值满足搜索谓词，请改用 <xref:System.Collections.Generic.List%601.FindIndex%2A> 方法。  
  
 此方法执行线性搜索;因此，此方法是 O (*n*) 操作，其中 *n* 是 <xref:System.Collections.Generic.List%601.Count%2A> 。
  
## Examples  
 以下示例演示包含简单上下文对象的 <xref:System.Collections.Generic.List%601.Find%2A> 上的 <xref:System.Collections.Generic.List%601> 方法。  
 
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.containsexists/cs/program.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.containsexists/vb/module1.vb" id="Snippet1":::
  
 下面的示例演示了类的查找方法 <xref:System.Collections.Generic.List%601> 。 类的示例 <xref:System.Collections.Generic.List%601> 包含 `book` 类的对象（ `Book` 使用示例 XML 文件中的数据） [：书籍 (LINQ to XML) ](/dotnet/standard/linq/sample-xml-file-books)。 `FillList`该示例中的方法使用[LINQ to XML](/dotnet/standard/linq/linq-xml-overview)分析从 XML 到对象的属性值的值 `book` 。  
  
 下表介绍了为 find 方法提供的示例。  
  
|方法|示例|  
|------------|-------------|  
|<xref:System.Collections.Generic.List%601.Find%28System.Predicate%7B%600%7D%29>|使用谓词委托按 ID 查找书籍 `IDToFind` 。<br /><br /> C # 示例使用匿名委托。|  
|<xref:System.Collections.Generic.List%601.FindAll%28System.Predicate%7B%600%7D%29>|`Genre`使用谓词委托查找其属性为 "Computer" 的所有书籍 `FindComputer` 。|  
|<xref:System.Collections.Generic.List%601.FindLast%28System.Predicate%7B%600%7D%29>|使用谓词委托查找集合中其发布日期早于2001的最后一本书 `PubBefore2001` 。<br /><br /> C # 示例使用匿名委托。|  
|<xref:System.Collections.Generic.List%601.FindIndex%28System.Predicate%7B%600%7D%29>|使用谓词委托查找第一台计算机的索引 `FindComputer` 。|  
|<xref:System.Collections.Generic.List%601.FindLastIndex%28System.Predicate%7B%600%7D%29>|使用谓词委托查找最后一台计算机的索引 `FindComputer` 。|  
|<xref:System.Collections.Generic.List%601.FindIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29>|使用谓词委托查找集合的第二部分中第一台计算机书籍的索引 `FindComputer` 。|  
|<xref:System.Collections.Generic.List%601.FindLastIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29>|使用谓词委托查找集合的后半部分中的最后一台计算机的索引 `FindComputer` 。|  
  
 [!code-csharp[List\`1_Find_Methods#1](~/samples/snippets/csharp/VS_Snippets_CLR/list`1_find_methods/cs/program.cs#1)]
 [!code-vb[List\`1_Find_Methods#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/list`1_find_methods/vb/module1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="match" /> 为 <see langword="null" />。</exception>
        <altmember cref="M:System.Collections.Generic.List`1.Exists(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindLast(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindAll(System.Predicate{`0})" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindLastIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.BinarySearch" />
        <altmember cref="Overload:System.Collections.Generic.List`1.IndexOf" />
        <altmember cref="Overload:System.Collections.Generic.List`1.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindAll">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.List&lt;T&gt; FindAll (Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.List`1&lt;!T&gt; FindAll(class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.FindAll(System.Predicate{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function FindAll (match As Predicate(Of T)) As List(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::List&lt;T&gt; ^ FindAll(Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="member this.FindAll : Predicate&lt;'T&gt; -&gt; System.Collections.Generic.List&lt;'T&gt;" Usage="list.FindAll match" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.List&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="match"><see cref="T:System.Predicate`1" /> 委托，用于定义要搜索的元素应满足的条件。</param>
        <summary>检索与指定谓词定义的条件匹配的所有元素。</summary>
        <returns>如果找到一个 <see cref="T:System.Collections.Generic.List`1" />，其中所有元素均与指定谓词定义的条件匹配，则为该数组；否则为一个空 <see cref="T:System.Collections.Generic.List`1" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Predicate%601>是一个方法委托， `true` 如果传递给它的对象与委托中定义的条件相匹配，则它将返回。  将当前的元素 <xref:System.Collections.Generic.List%601> 分别传递到 <xref:System.Predicate%601> 委托，并将与条件相匹配的元素保存在返回的中 <xref:System.Collections.Generic.List%601> 。  
  
 此方法执行线性搜索;因此，此方法是 O (*n*) 操作，其中 *n* 是 <xref:System.Collections.Generic.List%601.Count%2A> 。
  
## Examples  
 下面的示例演示了类的查找方法 <xref:System.Collections.Generic.List%601> 。 类的示例 <xref:System.Collections.Generic.List%601> 包含 `book` 类的对象（ `Book` 使用示例 XML 文件中的数据） [：书籍 (LINQ to XML) ](/dotnet/standard/linq/sample-xml-file-books)。 `FillList`该示例中的方法使用[LINQ to XML](/dotnet/standard/linq/linq-xml-overview)分析从 XML 到对象的属性值的值 `book` 。  
  
 下表介绍了为 find 方法提供的示例。  
  
|方法|示例|  
|------------|-------------|  
|<xref:System.Collections.Generic.List%601.Find%28System.Predicate%7B%600%7D%29>|使用谓词委托按 ID 查找书籍 `IDToFind` 。<br /><br /> C # 示例使用匿名委托。|  
|<xref:System.Collections.Generic.List%601.FindAll%28System.Predicate%7B%600%7D%29>|`Genre`使用谓词委托查找其属性为 "Computer" 的所有书籍 `FindComputer` 。|  
|<xref:System.Collections.Generic.List%601.FindLast%28System.Predicate%7B%600%7D%29>|使用谓词委托查找集合中其发布日期早于2001的最后一本书 `PubBefore2001` 。<br /><br /> C # 示例使用匿名委托。|  
|<xref:System.Collections.Generic.List%601.FindIndex%28System.Predicate%7B%600%7D%29>|使用谓词委托查找第一台计算机的索引 `FindComputer` 。|  
|<xref:System.Collections.Generic.List%601.FindLastIndex%28System.Predicate%7B%600%7D%29>|使用谓词委托查找最后一台计算机的索引 `FindComputer` 。|  
|<xref:System.Collections.Generic.List%601.FindIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29>|使用谓词委托查找集合的第二部分中第一台计算机书籍的索引 `FindComputer` 。|  
|<xref:System.Collections.Generic.List%601.FindLastIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29>|使用谓词委托查找集合的后半部分中的最后一台计算机的索引 `FindComputer` 。|  
  
 [!code-csharp[List\`1_Find_Methods#1](~/samples/snippets/csharp/VS_Snippets_CLR/list`1_find_methods/cs/program.cs#1)]
 [!code-vb[List\`1_Find_Methods#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/list`1_find_methods/vb/module1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="match" /> 为 <see langword="null" />。</exception>
        <altmember cref="M:System.Collections.Generic.List`1.Exists(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.Find(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindLast(System.Predicate{`0})" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindLastIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.BinarySearch" />
        <altmember cref="Overload:System.Collections.Generic.List`1.IndexOf" />
        <altmember cref="Overload:System.Collections.Generic.List`1.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <MemberGroup MemberName="FindIndex">
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>搜索与指定谓词所定义的条件相匹配的元素，返回 <see cref="T:System.Collections.Generic.List`1" /> 或它的一部分中第一个匹配项的从零开始的索引。 如果未找到与条件匹配的项，则此方法返回 -1。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FindIndex">
      <MemberSignature Language="C#" Value="public int FindIndex (Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 FindIndex(class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.FindIndex(System.Predicate{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function FindIndex (match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int FindIndex(Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="member this.FindIndex : Predicate&lt;'T&gt; -&gt; int" Usage="list.FindIndex match" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="match"><see cref="T:System.Predicate`1" /> 委托，用于定义要搜索的元素的条件。</param>
        <summary>搜索与指定谓词所定义的条件相匹配的元素，并返回整个 <see cref="T:System.Collections.Generic.List`1" /> 中第一个匹配元素的从零开始的索引。</summary>
        <returns>如果找到与 <paramref name="match" /> 定义的条件相匹配的第一个元素，则为该元素的从零开始的索引；否则为 -1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601>向前搜索从第一个元素开始，到最后一个元素结束。  
  
 <xref:System.Predicate%601>是一个方法委托， `true` 如果传递给它的对象与委托中定义的条件相匹配，则它将返回。  当前的元素 <xref:System.Collections.Generic.List%601> 被单独传递到 <xref:System.Predicate%601> 委托。 委托具有签名：  
  
```csharp  
public bool methodName(T obj)  
```  
  
```vb  
Public Function methodName(obj As T) As Boolean  
```  
  
 此方法执行线性搜索;因此，此方法是 O (*n*) 操作，其中 *n* 是 <xref:System.Collections.Generic.List%601.Count%2A> 。
  
## Examples  
 下面的示例定义了一个 `Employee` 具有两个字段 `Name` 和的类 `Id` 。 它还 `EmployeeSearch` 使用单个方法定义一个类， `StartsWith` 该方法指示 `Employee.Name` 字段是否以提供给 `EmployeeSearch` 类构造函数的指定子字符串开头。 记下此方法的签名  
  
```csharp  
public bool StartsWith(Employee e)  
```  
  
```vb  
Public Function StartsWith(e As Employee) As Boolean  
```  
  
 对应于可传递给方法的委托签名 <xref:System.Collections.Generic.List%601.FindIndex%2A> 。 该示例实例化一个 `List<Employee>` 对象，向其中添加多个 `Employee` 对象，然后调用该 <xref:System.Collections.Generic.List%601.FindIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29> 方法两次，以便在整个集合中搜索整个集合; 第一次是，第一个对象的第一个 `Employee` 对象以 `Name` "J" 开头，第二次是第一个对象的第一个对象的第一个 `Employee` 对象以 `Name` "Ju" 开头。  
  
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Collections.Generic.List.FindIndex/cs/FindIndex2.cs" interactive="try-dotnet" id="Snippet2":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Collections.Generic.List.FindIndex/vb/FindIndex2.vb" id="Snippet2":::
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="match" /> 为 <see langword="null" />。</exception>
        <altmember cref="M:System.Collections.Generic.List`1.Exists(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.Find(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindLast(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindAll(System.Predicate{`0})" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindLastIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.BinarySearch" />
        <altmember cref="Overload:System.Collections.Generic.List`1.IndexOf" />
        <altmember cref="Overload:System.Collections.Generic.List`1.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindIndex">
      <MemberSignature Language="C#" Value="public int FindIndex (int startIndex, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 FindIndex(int32 startIndex, class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.FindIndex(System.Int32,System.Predicate{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function FindIndex (startIndex As Integer, match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int FindIndex(int startIndex, Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="member this.FindIndex : int * Predicate&lt;'T&gt; -&gt; int" Usage="list.FindIndex (startIndex, match)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="startIndex">从零开始的搜索的起始索引。</param>
        <param name="match"><see cref="T:System.Predicate`1" /> 委托，用于定义要搜索的元素的条件。</param>
        <summary>搜索与指定谓词所定义的条件相匹配的元素，并返回 <see cref="T:System.Collections.Generic.List`1" /> 中从指定索引到最后一个元素的元素范围内第一个匹配项的从零开始的索引。</summary>
        <returns>如果找到与 <paramref name="match" /> 定义的条件相匹配的第一个元素，则为该元素的从零开始的索引；否则为 -1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601>将从 `startIndex` 最后一个元素开始向前搜索并结束。  
  
 <xref:System.Predicate%601>是一个方法委托， `true` 如果传递给它的对象与委托中定义的条件相匹配，则它将返回。  当前的元素 <xref:System.Collections.Generic.List%601> 被单独传递到 <xref:System.Predicate%601> 委托。 委托具有签名：  
  
```csharp  
public bool methodName(T obj)  
```  
  
```vb  
Public Function methodName(obj As T) As Boolean  
```  
  
 此方法执行线性搜索;因此，此方法是 O (*n*) 操作，其中 *n* 是从到末尾的元素数 `startIndex` <xref:System.Collections.Generic.List%601> 。
  
## Examples  
 下面的示例定义了一个 `Employee` 具有两个字段 `Name` 和的类 `Id` 。 它还 `EmployeeSearch` 使用单个方法定义一个类， `StartsWith` 该方法指示 `Employee.Name` 字段是否以提供给 `EmployeeSearch` 类构造函数的指定子字符串开头。 记下此方法的签名  
  
```csharp  
public bool StartsWith(Employee e)  
```  
  
```vb  
Public Function StartsWith(e As Employee) As Boolean  
```  
  
 对应于可传递给方法的委托签名 <xref:System.Collections.Generic.List%601.FindIndex%2A> 。 该示例实例化一个 `List<Employee>` 对象，向其中添加多个 `Employee` 对象，然后调用该 <xref:System.Collections.Generic.List%601.FindIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29> 方法两次以搜索该集合（从第五个成员开始， (即索引 4) 的成员）。 第一次，它会搜索 `Employee` 其 `Name` 字段以 "J" 开头的第一个对象; 第二次搜索其 `Employee` 字段以 `Name` "Ju" 开头的第一个对象。  
 
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Collections.Generic.List.FindIndex/cs/FindIndex3.cs" interactive="try-dotnet" id="Snippet3":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Collections.Generic.List.FindIndex/vb/FindIndex3.vb" id="Snippet3"::: 
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="match" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> 超出了 <see cref="T:System.Collections.Generic.List`1" /> 的有效索引范围。</exception>
        <altmember cref="M:System.Collections.Generic.List`1.Exists(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.Find(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindLast(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindAll(System.Predicate{`0})" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindLastIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.BinarySearch" />
        <altmember cref="Overload:System.Collections.Generic.List`1.IndexOf" />
        <altmember cref="Overload:System.Collections.Generic.List`1.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindIndex">
      <MemberSignature Language="C#" Value="public int FindIndex (int startIndex, int count, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 FindIndex(int32 startIndex, int32 count, class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.FindIndex(System.Int32,System.Int32,System.Predicate{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function FindIndex (startIndex As Integer, count As Integer, match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int FindIndex(int startIndex, int count, Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="member this.FindIndex : int * int * Predicate&lt;'T&gt; -&gt; int" Usage="list.FindIndex (startIndex, count, match)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="startIndex">从零开始的搜索的起始索引。</param>
        <param name="count">要搜索的部分中的元素数。</param>
        <param name="match"><see cref="T:System.Predicate`1" /> 委托，用于定义要搜索的元素的条件。</param>
        <summary>搜索与指定谓词所定义的条件相匹配的一个元素，并返回 <see cref="T:System.Collections.Generic.List`1" /> 中从指定的索引开始、包含指定元素个数的元素范围内第一个匹配项的从零开始的索引。</summary>
        <returns>如果找到与 <paramref name="match" /> 定义的条件相匹配的第一个元素，则为该元素的从零开始的索引；否则为 -1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601>如果大于0，则从开始向前搜索， `startIndex` 并在 `startIndex` plus `count` 减1处结束 `count` 。  
  
 <xref:System.Predicate%601>是一个方法委托， `true` 如果传递给它的对象与委托中定义的条件相匹配，则它将返回。  当前的元素 <xref:System.Collections.Generic.List%601> 被单独传递到 <xref:System.Predicate%601> 委托。 委托具有签名：  
  
```csharp  
public bool methodName(T obj)  
```  
  
```vb  
Public Function methodName(obj As T) As Boolean  
```  
  
 此方法执行线性搜索;因此，此方法是 O (*n*) 操作，其中 *n* 是 `count` 。
  
## Examples  
 下面的示例定义了一个 `Employee` 具有两个字段 `Name` 和的类 `Id` 。 它还 `EmployeeSearch` 使用单个方法定义一个类， `StartsWith` 该方法指示 `Employee.Name` 字段是否以提供给 `EmployeeSearch` 类构造函数的指定子字符串开头。 记下此方法的签名  
  
```csharp  
public bool StartsWith(Employee e)  
```  
  
```vb  
Public Function StartsWith(e As Employee) As Boolean  
```  
  
 对应于可传递给方法的委托签名 <xref:System.Collections.Generic.List%601.FindIndex%2A> 。 该示例实例化一个 `List<Employee>` 对象，向其中添加多个 `Employee` 对象，然后调用该 <xref:System.Collections.Generic.List%601.FindIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29> 方法两次以搜索整个集合 (即，从索引0到索引 <xref:System.Collections.Generic.List%601.Count%2A> -1) 的成员。 第一次，它会搜索 `Employee` 其 `Name` 字段以 "J" 开头的第一个对象; 第二次搜索其 `Employee` 字段以 `Name` "Ju" 开头的第一个对象。  
  
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Collections.Generic.List.FindIndex/cs/FindIndex1.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Collections.Generic.List.FindIndex/vb/FindIndex1.vb" id="Snippet1":::
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="match" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> 超出了 <see cref="T:System.Collections.Generic.List`1" /> 的有效索引范围。  
  
- 或 - 
 <paramref name="count" /> 小于 0。  
  
- 或 - 
 <paramref name="startIndex" /> 和 <paramref name="count" /> 未在 <see cref="T:System.Collections.Generic.List`1" /> 中指定有效部分。</exception>
        <altmember cref="M:System.Collections.Generic.List`1.Exists(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.Find(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindLast(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindAll(System.Predicate{`0})" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindLastIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.BinarySearch" />
        <altmember cref="Overload:System.Collections.Generic.List`1.IndexOf" />
        <altmember cref="Overload:System.Collections.Generic.List`1.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindLast">
      <MemberSignature Language="C#" Value="public T FindLast (Predicate&lt;T&gt; match);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !T FindLast(class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.FindLast(System.Predicate{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function FindLast (match As Predicate(Of T)) As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; T FindLast(Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="member this.FindLast : Predicate&lt;'T&gt; -&gt; 'T" Usage="list.FindLast match" />
      <MemberSignature Language="C#" Value="public T? FindLast (Predicate&lt;T&gt; match);" FrameworkAlternate="net-5.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="match"><see cref="T:System.Predicate`1" /> 委托，用于定义要搜索的元素的条件。</param>
        <summary>搜索与指定谓词所定义的条件相匹配的元素，并返回整个 <see cref="T:System.Collections.Generic.List`1" /> 中的最后一个匹配元素。</summary>
        <returns>如果找到，则为与指定谓词所定义的条件相匹配的最后一个元素；否则为类型 <paramref name="T" /> 的默认值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Predicate%601>是一个方法委托， `true` 如果传递给它的对象与委托中定义的条件相匹配，则它将返回。  当前的元素 <xref:System.Collections.Generic.List%601> 分别传递到 <xref:System.Predicate%601> 委托，并在中向后移动 <xref:System.Collections.Generic.List%601> ，从最后一个元素开始，到第一个元素结束。  找到匹配项时将停止处理。  
  
> [!IMPORTANT]
>  在搜索包含值类型的列表时，请确保该类型的默认值不满足搜索谓词。 否则，无法区分默认值，指示找不到任何匹配项，并且不能区分发生了该类型的默认值的列表元素。 如果默认值满足搜索谓词，请改用 <xref:System.Collections.Generic.List%601.FindLastIndex%2A> 方法。  
  
 此方法执行线性搜索;因此，此方法是 O (*n*) 操作，其中 *n* 是 <xref:System.Collections.Generic.List%601.Count%2A> 。
  
## Examples  
 下面的示例演示了类的查找方法 <xref:System.Collections.Generic.List%601> 。 类的示例 <xref:System.Collections.Generic.List%601> 包含 `book` 类的对象（ `Book` 使用示例 XML 文件中的数据） [：书籍 (LINQ to XML) ](/dotnet/standard/linq/sample-xml-file-books)。 `FillList`该示例中的方法使用[LINQ to XML](/dotnet/standard/linq/linq-xml-overview)分析从 XML 到对象的属性值的值 `book` 。  
  
 下表介绍了为 find 方法提供的示例。  
  
|方法|示例|  
|------------|-------------|  
|<xref:System.Collections.Generic.List%601.Find%28System.Predicate%7B%600%7D%29>|使用谓词委托按 ID 查找书籍 `IDToFind` 。<br /><br /> C # 示例使用匿名委托。|  
|<xref:System.Collections.Generic.List%601.FindAll%28System.Predicate%7B%600%7D%29>|`Genre`使用谓词委托查找其属性为 "Computer" 的所有书籍 `FindComputer` 。|  
|<xref:System.Collections.Generic.List%601.FindLast%28System.Predicate%7B%600%7D%29>|使用谓词委托查找集合中其发布日期早于2001的最后一本书 `PubBefore2001` 。<br /><br /> C # 示例使用匿名委托。|  
|<xref:System.Collections.Generic.List%601.FindIndex%28System.Predicate%7B%600%7D%29>|使用谓词委托查找第一台计算机的索引 `FindComputer` 。|  
|<xref:System.Collections.Generic.List%601.FindLastIndex%28System.Predicate%7B%600%7D%29>|使用谓词委托查找最后一台计算机的索引 `FindComputer` 。|  
|<xref:System.Collections.Generic.List%601.FindIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29>|使用谓词委托查找集合的第二部分中第一台计算机书籍的索引 `FindComputer` 。|  
|<xref:System.Collections.Generic.List%601.FindLastIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29>|使用谓词委托查找集合的后半部分中的最后一台计算机的索引 `FindComputer` 。|  
  
 [!code-csharp[List\`1_Find_Methods#1](~/samples/snippets/csharp/VS_Snippets_CLR/list`1_find_methods/cs/program.cs#1)]
 [!code-vb[List\`1_Find_Methods#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/list`1_find_methods/vb/module1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="match" /> 为 <see langword="null" />。</exception>
        <altmember cref="M:System.Collections.Generic.List`1.Exists(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.Find(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindAll(System.Predicate{`0})" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindLastIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.BinarySearch" />
        <altmember cref="Overload:System.Collections.Generic.List`1.IndexOf" />
        <altmember cref="Overload:System.Collections.Generic.List`1.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <MemberGroup MemberName="FindLastIndex">
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>搜索与指定谓词所定义的条件相匹配的元素，返回 <see cref="T:System.Collections.Generic.List`1" /> 或它的一部分中最后一个匹配项的从零开始的索引。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FindLastIndex">
      <MemberSignature Language="C#" Value="public int FindLastIndex (Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 FindLastIndex(class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.FindLastIndex(System.Predicate{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function FindLastIndex (match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int FindLastIndex(Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="member this.FindLastIndex : Predicate&lt;'T&gt; -&gt; int" Usage="list.FindLastIndex match" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="match"><see cref="T:System.Predicate`1" /> 委托，用于定义要搜索的元素的条件。</param>
        <summary>搜索与指定谓词所定义的条件相匹配的元素，并返回整个 <see cref="T:System.Collections.Generic.List`1" /> 中最后一个匹配元素的从零开始的索引。</summary>
        <returns>如果找到与 <paramref name="match" /> 定义的条件相匹配的最后一个元素，则为该元素的从零开始的索引；否则为 -1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601>向后搜索从最后一个元素开始，到第一个元素结束。  
  
 <xref:System.Predicate%601>是一个方法委托， `true` 如果传递给它的对象与委托中定义的条件相匹配，则它将返回。  当前的元素 <xref:System.Collections.Generic.List%601> 被单独传递到 <xref:System.Predicate%601> 委托。  
  
 此方法执行线性搜索;因此，此方法是 O (*n*) 操作，其中 *n* 是 <xref:System.Collections.Generic.List%601.Count%2A> 。
  
## Examples  
 下面的示例演示了类的查找方法 <xref:System.Collections.Generic.List%601> 。 类的示例 <xref:System.Collections.Generic.List%601> 包含 `book` 类的对象（ `Book` 使用示例 XML 文件中的数据） [：书籍 (LINQ to XML) ](/dotnet/standard/linq/sample-xml-file-books)。 `FillList`该示例中的方法使用[LINQ to XML](/dotnet/standard/linq/linq-xml-overview)分析从 XML 到对象的属性值的值 `book` 。  
  
 下表介绍了为 find 方法提供的示例。  
  
|方法|示例|  
|------------|-------------|  
|<xref:System.Collections.Generic.List%601.Find%28System.Predicate%7B%600%7D%29>|使用谓词委托按 ID 查找书籍 `IDToFind` 。<br /><br /> C # 示例使用匿名委托。|  
|<xref:System.Collections.Generic.List%601.FindAll%28System.Predicate%7B%600%7D%29>|`Genre`使用谓词委托查找其属性为 "Computer" 的所有书籍 `FindComputer` 。|  
|<xref:System.Collections.Generic.List%601.FindLast%28System.Predicate%7B%600%7D%29>|使用谓词委托查找集合中其发布日期早于2001的最后一本书 `PubBefore2001` 。<br /><br /> C # 示例使用匿名委托。|  
|<xref:System.Collections.Generic.List%601.FindIndex%28System.Predicate%7B%600%7D%29>|使用谓词委托查找第一台计算机的索引 `FindComputer` 。|  
|<xref:System.Collections.Generic.List%601.FindLastIndex%28System.Predicate%7B%600%7D%29>|使用谓词委托查找最后一台计算机的索引 `FindComputer` 。|  
|<xref:System.Collections.Generic.List%601.FindIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29>|使用谓词委托查找集合的第二部分中第一台计算机书籍的索引 `FindComputer` 。|  
|<xref:System.Collections.Generic.List%601.FindLastIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29>|使用谓词委托查找集合的后半部分中的最后一台计算机的索引 `FindComputer` 。|  
  
 [!code-csharp[List\`1_Find_Methods#1](~/samples/snippets/csharp/VS_Snippets_CLR/list`1_find_methods/cs/program.cs#1)]
 [!code-vb[List\`1_Find_Methods#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/list`1_find_methods/vb/module1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="match" /> 为 <see langword="null" />。</exception>
        <altmember cref="M:System.Collections.Generic.List`1.Exists(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.Find(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindLast(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindAll(System.Predicate{`0})" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.BinarySearch" />
        <altmember cref="Overload:System.Collections.Generic.List`1.IndexOf" />
        <altmember cref="Overload:System.Collections.Generic.List`1.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindLastIndex">
      <MemberSignature Language="C#" Value="public int FindLastIndex (int startIndex, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 FindLastIndex(int32 startIndex, class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.FindLastIndex(System.Int32,System.Predicate{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function FindLastIndex (startIndex As Integer, match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int FindLastIndex(int startIndex, Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="member this.FindLastIndex : int * Predicate&lt;'T&gt; -&gt; int" Usage="list.FindLastIndex (startIndex, match)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="startIndex">向后搜索的从零开始的起始索引。</param>
        <param name="match"><see cref="T:System.Predicate`1" /> 委托，用于定义要搜索的元素的条件。</param>
        <summary>搜索与由指定谓词定义的条件相匹配的元素，并返回 <see cref="T:System.Collections.Generic.List`1" /> 中从第一个元素到指定索引的元素范围内最后一个匹配项的从零开始的索引。</summary>
        <returns>如果找到与 <paramref name="match" /> 定义的条件相匹配的最后一个元素，则为该元素的从零开始的索引；否则为 -1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601>向后搜索从 `startIndex` 第一个元素开始和结束的位置。  
  
 <xref:System.Predicate%601>是一个方法委托， `true` 如果传递给它的对象与委托中定义的条件相匹配，则它将返回。  当前的元素 <xref:System.Collections.Generic.List%601> 被单独传递到 <xref:System.Predicate%601> 委托。  
  
 此方法执行线性搜索;因此，此方法是 O (*n*) 操作，其中 *n* 是从开始到的元素的数目 <xref:System.Collections.Generic.List%601> `startIndex` 。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="match" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> 超出了 <see cref="T:System.Collections.Generic.List`1" /> 的有效索引范围。</exception>
        <altmember cref="M:System.Collections.Generic.List`1.Exists(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.Find(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindLast(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindAll(System.Predicate{`0})" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.BinarySearch" />
        <altmember cref="Overload:System.Collections.Generic.List`1.IndexOf" />
        <altmember cref="Overload:System.Collections.Generic.List`1.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindLastIndex">
      <MemberSignature Language="C#" Value="public int FindLastIndex (int startIndex, int count, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 FindLastIndex(int32 startIndex, int32 count, class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.FindLastIndex(System.Int32,System.Int32,System.Predicate{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function FindLastIndex (startIndex As Integer, count As Integer, match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int FindLastIndex(int startIndex, int count, Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="member this.FindLastIndex : int * int * Predicate&lt;'T&gt; -&gt; int" Usage="list.FindLastIndex (startIndex, count, match)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="startIndex">向后搜索的从零开始的起始索引。</param>
        <param name="count">要搜索的部分中的元素数。</param>
        <param name="match"><see cref="T:System.Predicate`1" /> 委托，用于定义要搜索的元素的条件。</param>
        <summary>搜索与指定谓词所定义的条件相匹配的元素，并返回 <see cref="T:System.Collections.Generic.List`1" /> 中包含指定元素个数、到指定索引结束的元素范围内最后一个匹配项的从零开始的索引。</summary>
        <returns>如果找到与 <paramref name="match" /> 定义的条件相匹配的最后一个元素，则为该元素的从零开始的索引；否则为 -1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601> `startIndex` `startIndex` `count` 如果 `count` 大于0，则搜索从开始，到从减号 + 1 开始向后终止。  
  
 <xref:System.Predicate%601>是一个方法委托， `true` 如果传递给它的对象与委托中定义的条件相匹配，则它将返回。  当前的元素 <xref:System.Collections.Generic.List%601> 被单独传递到 <xref:System.Predicate%601> 委托。  
  
 此方法执行线性搜索;因此，此方法是 O (*n*) 操作，其中 *n* 是 `count` 。
  
## Examples  
 下面的示例演示了类的查找方法 <xref:System.Collections.Generic.List%601> 。 类的示例 <xref:System.Collections.Generic.List%601> 包含 `book` 类的对象（ `Book` 使用示例 XML 文件中的数据） [：书籍 (LINQ to XML) ](/dotnet/standard/linq/sample-xml-file-books)。 `FillList`该示例中的方法使用[LINQ to XML](/dotnet/standard/linq/linq-xml-overview)分析从 XML 到对象的属性值的值 `book` 。  
  
 下表介绍了为 find 方法提供的示例。  
  
|方法|示例|  
|------------|-------------|  
|<xref:System.Collections.Generic.List%601.Find%28System.Predicate%7B%600%7D%29>|使用谓词委托按 ID 查找书籍 `IDToFind` 。<br /><br /> C # 示例使用匿名委托。|  
|<xref:System.Collections.Generic.List%601.FindAll%28System.Predicate%7B%600%7D%29>|`Genre`使用谓词委托查找其属性为 "Computer" 的所有书籍 `FindComputer` 。|  
|<xref:System.Collections.Generic.List%601.FindLast%28System.Predicate%7B%600%7D%29>|使用谓词委托查找集合中其发布日期早于2001的最后一本书 `PubBefore2001` 。<br /><br /> C # 示例使用匿名委托。|  
|<xref:System.Collections.Generic.List%601.FindIndex%28System.Predicate%7B%600%7D%29>|使用谓词委托查找第一台计算机的索引 `FindComputer` 。|  
|<xref:System.Collections.Generic.List%601.FindLastIndex%28System.Predicate%7B%600%7D%29>|使用谓词委托查找最后一台计算机的索引 `FindComputer` 。|  
|<xref:System.Collections.Generic.List%601.FindIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29>|使用谓词委托查找集合的第二部分中第一台计算机书籍的索引 `FindComputer` 。|  
|<xref:System.Collections.Generic.List%601.FindLastIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29>|使用谓词委托查找集合的后半部分中的最后一台计算机的索引 `FindComputer` 。|  
  
 [!code-csharp[List\`1_Find_Methods#1](~/samples/snippets/csharp/VS_Snippets_CLR/list`1_find_methods/cs/program.cs#1)]
 [!code-vb[List\`1_Find_Methods#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/list`1_find_methods/vb/module1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="match" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> 超出了 <see cref="T:System.Collections.Generic.List`1" /> 的有效索引范围。  
  
- 或 - 
 <paramref name="count" /> 小于 0。  
  
- 或 - 
 <paramref name="startIndex" /> 和 <paramref name="count" /> 未在 <see cref="T:System.Collections.Generic.List`1" /> 中指定有效部分。</exception>
        <altmember cref="M:System.Collections.Generic.List`1.Exists(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.Find(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindLast(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindAll(System.Predicate{`0})" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.BinarySearch" />
        <altmember cref="Overload:System.Collections.Generic.List`1.IndexOf" />
        <altmember cref="Overload:System.Collections.Generic.List`1.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="ForEach">
      <MemberSignature Language="C#" Value="public void ForEach (Action&lt;T&gt; action);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ForEach(class System.Action`1&lt;!T&gt; action) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.ForEach(System.Action{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub ForEach (action As Action(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ForEach(Action&lt;T&gt; ^ action);" />
      <MemberSignature Language="F#" Value="member this.ForEach : Action&lt;'T&gt; -&gt; unit" Usage="list.ForEach action" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Action&lt;T&gt;" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="action">要对 <see cref="T:System.Collections.Generic.List`1" /> 的每个元素执行的 <see cref="T:System.Action`1" /> 委托。</param>
        <summary>对 <see cref="T:System.Collections.Generic.List`1" /> 的每个元素执行指定操作。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Action%601>是对传递给它的对象执行操作的方法的委托。  当前的元素 <xref:System.Collections.Generic.List%601> 被单独传递到 <xref:System.Action%601> 委托。  
  
 此方法是 O (*n*) 操作，其中 *n* 是 <xref:System.Collections.Generic.List%601.Count%2A> 。  
  
 不支持修改委托正文中的基础集合 <xref:System.Action%601> ，这会导致未定义的行为。
  
## Examples  
 下面的示例演示 <xref:System.Action%601> 如何使用委托打印对象的内容 <xref:System.Collections.Generic.List%601> 。 在此示例中， `Print` 方法用于将列表的内容显示到控制台。  
  
> [!NOTE]
>  除了使用方法显示内容外 `Print` ，c # 示例还演示了如何使用 [匿名方法](/dotnet/csharp/programming-guide/statements-expressions-operators/anonymous-methods) 将结果显示到控制台。  
  
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Action_PrintExample/cs/action.cs" interactive="try-dotnet-method" id="Snippet01":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Action_PrintExample/vb/action.vb" id="Snippet01":::  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="action" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">已修改集合中的某个元素。</exception>
        <altmember cref="T:System.Action`1" />
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.List&lt;T&gt;.Enumerator GetEnumerator ();" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Collections.Generic.List`1/Enumerator&lt;!T&gt; GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEnumerator () As List(Of T).Enumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::List&lt;T&gt;::Enumerator GetEnumerator();" />
      <MemberSignature Language="F#" Value="member this.GetEnumerator : unit -&gt; System.Collections.Generic.List&lt;'T&gt;.Enumerator" Usage="list.GetEnumerator " />
      <MemberSignature Language="C#" Value="public System.Collections.Generic.List&lt;T&gt;.Enumerator? GetEnumerator ();" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.List&lt;T&gt;+Enumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回循环访问 <see cref="T:System.Collections.Generic.List`1" /> 的枚举数。</summary>
        <returns>用于 <see cref="T:System.Collections.Generic.List`1.Enumerator" /> 的 <see cref="T:System.Collections.Generic.List`1" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 C `foreach` + + 中的 c # 语言 (在 `for each` `For Each` Visual Basic 中) 隐藏了枚举器的复杂性。 因此，建议使用 `foreach`，而不是直接操作枚举数。  
  
 枚举器可用于读取集合中的数据，但不能用于修改基础集合。  
  
 最初，枚举数定位在集合中第一个元素的前面。 在此位置， <xref:System.Collections.Generic.List%601.Enumerator.Current%2A> 属性未定义。 因此，在读取的值之前，必须调用 <xref:System.Collections.Generic.List%601.Enumerator.MoveNext%2A> 方法，以将枚举器前进到集合的第一个元素 <xref:System.Collections.Generic.List%601.Enumerator.Current%2A> 。  
  
 在 <xref:System.Collections.Generic.List%601.Enumerator.Current%2A> 调用之前，属性将返回相同的对象 <xref:System.Collections.Generic.List%601.Enumerator.MoveNext%2A> 。 <xref:System.Collections.Generic.List%601.Enumerator.MoveNext%2A> 将 <xref:System.Collections.Generic.List%601.Enumerator.Current%2A> 设置为下一个元素。  
  
 如果 <xref:System.Collections.Generic.List%601.Enumerator.MoveNext%2A> 越过集合的末尾，则枚举器将定位在集合中最后一个元素之后，并 <xref:System.Collections.Generic.List%601.Enumerator.MoveNext%2A> 返回 `false` 。 当枚举器位于此位置时，对的后续调用 <xref:System.Collections.Generic.List%601.Enumerator.MoveNext%2A> 也将返回 `false` 。 如果最后一次调用 <xref:System.Collections.Generic.List%601.Enumerator.MoveNext%2A> 返回 `false` ， <xref:System.Collections.Generic.List%601.Enumerator.Current%2A> 则未定义。 无法再次将 <xref:System.Collections.Generic.List%601.Enumerator.Current%2A> 设置为集合的第一个元素；必须改为创建新的枚举器实例。  
  
 只要集合保持不变，枚举器就仍有效。 如果对集合所做的更改（如添加、修改或删除元素），则枚举器将失效且不可恢复，并且对或的下一个调用将 <xref:System.Collections.Generic.List%601.Enumerator.MoveNext%2A> <xref:System.Collections.Generic.List%601.Enumerator.System%23Collections%23IEnumerator%23Reset%2A> 引发 <xref:System.InvalidOperationException> 。  
  
 枚举数没有对集合的独占访问权；因此，从头到尾对一个集合进行枚举在本质上不是一个线程安全的过程。 若要确保枚举过程中的线程安全性，可以在整个枚举过程中锁定集合。  若要允许多个线程访问集合以进行读写操作，则必须实现自己的同步。  
  
 <xref:System.Collections.Generic?displayProperty=nameWithType> 命名空间中集合的默认实现是不同步的。  
  
 此方法是 O (1) 操作。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.Generic.List`1.Enumerator" />
        <altmember cref="T:System.Collections.Generic.IEnumerator`1" />
      </Docs>
    </Member>
    <Member MemberName="GetRange">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.List&lt;T&gt; GetRange (int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.List`1&lt;!T&gt; GetRange(int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.GetRange(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetRange (index As Integer, count As Integer) As List(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::List&lt;T&gt; ^ GetRange(int index, int count);" />
      <MemberSignature Language="F#" Value="member this.GetRange : int * int -&gt; System.Collections.Generic.List&lt;'T&gt;" Usage="list.GetRange (index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.List&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">范围开始处的从零开始的 <see cref="T:System.Collections.Generic.List`1" /> 索引。</param>
        <param name="count">范围中的元素数。</param>
        <summary>在源 <see cref="T:System.Collections.Generic.List`1" /> 中创建元素范围的浅表复制。</summary>
        <returns>源 <see cref="T:System.Collections.Generic.List`1" /> 中的元素范围的浅表副本复制。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 引用类型集合或集合子集的浅表副本只包含对集合中元素的引用。 对象本身不会被复制。 新列表中的引用指向与原始列表中的引用相同的对象。  
  
 值类型集合（或该集合的子集）的浅层副本包含该集合的元素。 但是，如果集合的元素包含对其他对象的引用，则不会复制这些对象。 新集合的元素中的引用指向与原始集合的元素中的引用相同的对象。  
  
 与此相反，集合的深层副本会复制元素以及元素直接或间接引用的所有内容。  
  
 此方法是 O (*n*) 操作，其中 *n* 是 `count` 。
  
## Examples  
 下面的示例演示了对 <xref:System.Collections.Generic.List%601.GetRange%2A> 范围执行操作的类的方法和其他方法 <xref:System.Collections.Generic.List%601> 。 在示例结束时， <xref:System.Collections.Generic.List%601.GetRange%2A> 方法用于从列表中获取三个项，从索引位置2开始。 对 <xref:System.Collections.Generic.List%601.ToArray%2A> 生成的方法调用方法 <xref:System.Collections.Generic.List%601> ，创建一个包含三个元素的数组。 显示数组的元素。  
  
 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Ranges/cpp/source.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Ranges/cs/source.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Ranges/vb/source.vb" id="Snippet1"::: 

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> 小于 0。  
  
- 或 - 
 <paramref name="count" /> 小于 0。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="index" /> 和 <paramref name="count" /> 不表示 <see cref="T:System.Collections.Generic.List`1" /> 中元素的有效范围。</exception>
        <altmember cref="M:System.Collections.Generic.List`1.RemoveRange(System.Int32,System.Int32)" />
        <altmember cref="M:System.Collections.Generic.List`1.AddRange(System.Collections.Generic.IEnumerable{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.InsertRange(System.Int32,System.Collections.Generic.IEnumerable{`0})" />
      </Docs>
    </Member>
    <MemberGroup MemberName="IndexOf">
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>返回 <see cref="T:System.Collections.Generic.List`1" /> 或它的一部分中某个值的第一个匹配项的从零开始的索引。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
 
## Examples  
 下面的示例演示方法的所有三个重载 <xref:System.Collections.Generic.List%601.IndexOf%2A> 。 将 <xref:System.Collections.Generic.List%601> 创建一个字符串，其中一个条目出现两次，位于索引位置0和索引位置5。 <xref:System.Collections.Generic.List%601.IndexOf%28%600%29>方法重载从开始处搜索列表，并查找字符串的第一个匹配项。 <xref:System.Collections.Generic.List%601.IndexOf%28%600%2CSystem.Int32%29>方法重载用于搜索索引位置3开头的列表并继续到列表末尾，并查找字符串的第二个匹配项。 最后， <xref:System.Collections.Generic.List%601.IndexOf%28%600%2CSystem.Int32%2CSystem.Int32%29> 使用方法重载搜索两个条目的范围（从第二个索引位置开始）; 它返回-1，因为该范围中没有搜索字符串的实例。  
  
 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR/List`1_IndexOf/cpp/source.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR/List`1_IndexOf/cs/source.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_IndexOf/vb/source.vb" id="Snippet1":::
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (T item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 IndexOf(!T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.IndexOf(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (item As T) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int IndexOf(T item);" />
      <MemberSignature Language="F#" Value="abstract member IndexOf : 'T -&gt; int&#xA;override this.IndexOf : 'T -&gt; int" Usage="list.IndexOf item" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IList`1.IndexOf(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="item">要在 <see cref="T:System.Collections.Generic.List`1" /> 中定位的对象。 对于引用类型，该值可以为 <see langword="null" />。</param>
        <summary>搜索指定的对象，并返回整个 <see cref="T:System.Collections.Generic.List`1" /> 中第一个匹配项的从零开始的索引。</summary>
        <returns>如果找到，则为整个 <paramref name="item" /> 中 <see cref="T:System.Collections.Generic.List`1" /> 第一个匹配项的从零开始的索引；否则为 -1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601>向前搜索从第一个元素开始，到最后一个元素结束。  
  
 此方法使用的默认相等比较器 <xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=nameWithType> `T` （列表中的值的类型）确定相等性。  
  
 此方法执行线性搜索;因此，此方法是 O (*n*) 操作，其中 *n* 是 <xref:System.Collections.Generic.List%601.Count%2A> 。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Generic.List`1.LastIndexOf(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.Contains(`0)" />
        <related type="Article" href="/dotnet/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections">在集合中执行不区分区域性的字符串操作</related>
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (T item, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(!T item, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.IndexOf(`0,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (item As T, index As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(T item, int index);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : 'T * int -&gt; int" Usage="list.IndexOf (item, index)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="item">要在 <see cref="T:System.Collections.Generic.List`1" /> 中定位的对象。 对于引用类型，该值可以为 <see langword="null" />。</param>
        <param name="index">从零开始的搜索的起始索引。 空列表中 0（零）为有效值。</param>
        <summary>搜索指定对象并返回 <see cref="T:System.Collections.Generic.List`1" /> 中从指定索引到最后一个元素这部分元素中第一个匹配项的从零开始索引。</summary>
        <returns>如果在 <see cref="T:System.Collections.Generic.List`1" /> 中从 <paramref name="index" /> 到最后一个元素的元素范围内找到 <paramref name="item" /> 的第一个匹配项，则为该项的从零开始的索引；否则为 -1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601>将从 `index` 最后一个元素开始向前搜索并结束。  
  
 此方法使用的默认相等比较器 <xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=nameWithType> `T` （列表中的值的类型）确定相等性。  
  
 此方法执行线性搜索;因此，此方法是 O (*n*) 操作，其中 *n* 是从到末尾的元素数 `index` <xref:System.Collections.Generic.List%601> 。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> 超出了 <see cref="T:System.Collections.Generic.List`1" /> 的有效索引范围。</exception>
        <altmember cref="M:System.Collections.Generic.List`1.LastIndexOf(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.Contains(`0)" />
        <related type="Article" href="/dotnet/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections">在集合中执行不区分区域性的字符串操作</related>
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (T item, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(!T item, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.IndexOf(`0,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (item As T, index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(T item, int index, int count);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : 'T * int * int -&gt; int" Usage="list.IndexOf (item, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="item">要在 <see cref="T:System.Collections.Generic.List`1" /> 中定位的对象。 对于引用类型，该值可以为 <see langword="null" />。</param>
        <param name="index">从零开始的搜索的起始索引。 空列表中 0（零）为有效值。</param>
        <param name="count">要搜索的部分中的元素数。</param>
        <summary>搜索指定对象并返回 <see cref="T:System.Collections.Generic.List`1" /> 中从指定索引开始并包含指定元素数的这部分元素中第一个匹配项的从零开始索引。</summary>
        <returns>如果在 <see cref="T:System.Collections.Generic.List`1" /> 中从 <paramref name="index" /> 开始并包含 <paramref name="count" /> 个元素的元素范围内找到 <paramref name="item" /> 的第一个匹配项，则为该项的从零开始的索引；否则为 -1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601>如果大于0，则从开始向前搜索， `index` 并在 `index` plus `count` 减1处结束 `count` 。  
  
 此方法使用的默认相等比较器 <xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=nameWithType> `T` （列表中的值的类型）确定相等性。  
  
 此方法执行线性搜索;因此，此方法是 O (*n*) 操作，其中 *n* 是 `count` 。  
  
  ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> 超出了 <see cref="T:System.Collections.Generic.List`1" /> 的有效索引范围。  
  
- 或 - 
 <paramref name="count" /> 小于 0。  
  
- 或 - 
 <paramref name="index" /> 和 <paramref name="count" /> 未在 <see cref="T:System.Collections.Generic.List`1" /> 中指定有效部分。</exception>
        <altmember cref="M:System.Collections.Generic.List`1.LastIndexOf(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.Contains(`0)" />
        <related type="Article" href="/dotnet/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections">在集合中执行不区分区域性的字符串操作</related>
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public void Insert (int index, T item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Insert(int32 index, !T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Insert(System.Int32,`0)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Insert (index As Integer, item As T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Insert(int index, T item);" />
      <MemberSignature Language="F#" Value="abstract member Insert : int * 'T -&gt; unit&#xA;override this.Insert : int * 'T -&gt; unit" Usage="list.Insert (index, item)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IList`1.Insert(System.Int32,`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="index">应插入 <paramref name="item" /> 的从零开始的索引。</param>
        <param name="item">要插入的对象。 对于引用类型，该值可以为 <see langword="null" />。</param>
        <summary>将元素插入 <see cref="T:System.Collections.Generic.List`1" /> 的指定索引处。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601> 接受 `null` 作为引用类型的有效值，并允许重复元素。  
  
 如果 <xref:System.Collections.Generic.List%601.Count%2A> 已 <xref:System.Collections.Generic.List%601.Capacity%2A> 为 equals，则 <xref:System.Collections.Generic.List%601> 通过自动重新分配内部数组，并将现有元素复制到新数组，然后再添加新元素。  
  
 如果 `index` 等于 <xref:System.Collections.Generic.List%601.Count%2A> ， `item` 则将添加到的末尾 <xref:System.Collections.Generic.List%601> 。  
  
 此方法是 O (*n*) 操作，其中 *n* 是 <xref:System.Collections.Generic.List%601.Count%2A> 。
  
## Examples  

 下面的示例演示如何在中添加、移除和插入简单的业务对象 <xref:System.Collections.Generic.List%601> 。  
  
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/cs/program.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/vb/module1.vb" id="Snippet1":::
 :::code language="fsharp" source="~/samples/snippets/fsharp/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/fs/addremoveinsert.fs" id="Snippet1":::
  
 下面的示例演示 <xref:System.Collections.Generic.List%601.Insert%2A> 方法以及泛型类的各种其他属性和方法 <xref:System.Collections.Generic.List%601> 。 创建列表后，会添加元素。 <xref:System.Collections.Generic.List%601.Insert%2A>方法用于将一项插入到列表中间。 插入的项是一个重复项，以后将使用方法将其移除 <xref:System.Collections.Generic.List%601.Remove%2A> 。  
  
 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Class/cpp/source.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Class/cs/source.cs" interactive="try-dotnet-method" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Class/vb/source.vb" id="Snippet1"::: 
 :::code language="fsharp" source="~/samples/snippets/fsharp/VS_Snippets_CLR/List`1_Class/fs/listclass.fs" id="Snippet1":::
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> 小于 0。  
  
- 或 - 
 <paramref name="index" /> 大于 <see cref="P:System.Collections.Generic.List`1.Count" />。</exception>
        <altmember cref="M:System.Collections.Generic.List`1.InsertRange(System.Int32,System.Collections.Generic.IEnumerable{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.Add(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.Remove(`0)" />
      </Docs>
    </Member>
    <Member MemberName="InsertRange">
      <MemberSignature Language="C#" Value="public void InsertRange (int index, System.Collections.Generic.IEnumerable&lt;T&gt; collection);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void InsertRange(int32 index, class System.Collections.Generic.IEnumerable`1&lt;!T&gt; collection) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.InsertRange(System.Int32,System.Collections.Generic.IEnumerable{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub InsertRange (index As Integer, collection As IEnumerable(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void InsertRange(int index, System::Collections::Generic::IEnumerable&lt;T&gt; ^ collection);" />
      <MemberSignature Language="F#" Value="member this.InsertRange : int * seq&lt;'T&gt; -&gt; unit" Usage="list.InsertRange (index, collection)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="collection" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="index">应在此处插入新元素的从零开始的索引。</param>
        <param name="collection">应将其元素插入到 <see cref="T:System.Collections.Generic.List`1" /> 中的集合。 集合自身不能为 <see langword="null" />，但它可以包含为 <see langword="null" /> 的元素（如果类型 <paramref name="T" /> 为引用类型）。</param>
        <summary>将集合中的元素插入 <see cref="T:System.Collections.Generic.List`1" /> 的指定索引处。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601> 接受 `null` 作为引用类型的有效值，并允许重复元素。  
  
 如果新 <xref:System.Collections.Generic.List%601.Count%2A> (当前 <xref:System.Collections.Generic.List%601.Count%2A> 加上集合的大小) 将大于 <xref:System.Collections.Generic.List%601.Capacity%2A> ，则 <xref:System.Collections.Generic.List%601> 通过自动重新分配内部数组以容纳新元素，并将现有元素复制到新数组中，然后再添加新元素。  
  
 如果 `index` 等于 <xref:System.Collections.Generic.List%601.Count%2A> ，则将元素添加到的末尾 <xref:System.Collections.Generic.List%601> 。  
  
 集合中元素的顺序保留在中 <xref:System.Collections.Generic.List%601> 。  
  
 此方法是一个 O (*n*  *  *m*) 操作，其中 *n* 是要添加的元素的数目， *m* 为 <xref:System.Collections.Generic.List%601.Count%2A> 。
  
## Examples  
 下面的示例演示了 <xref:System.Collections.Generic.List%601.InsertRange%2A> 对范围执行操作的类的方法和各种其他方法 <xref:System.Collections.Generic.List%601> 。 创建列表并使用多个平静植物恐龙的名称填充后，该 <xref:System.Collections.Generic.List%601.InsertRange%2A> 方法用于将三个 ferocious 肉恐龙的数组插入到列表中，从索引位置3开始。  
  
 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Ranges/cpp/source.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Ranges/cs/source.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Ranges/vb/source.vb" id="Snippet1":::
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="collection" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> 小于 0。  
  
- 或 - 
 <paramref name="index" /> 大于 <see cref="P:System.Collections.Generic.List`1.Count" />。</exception>
        <altmember cref="M:System.Collections.Generic.List`1.Insert(System.Int32,`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.AddRange(System.Collections.Generic.IEnumerable{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.GetRange(System.Int32,System.Int32)" />
        <altmember cref="M:System.Collections.Generic.List`1.RemoveRange(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public T this[int index] { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance !T Item(int32)" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.List`1.Item(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Default Public Property Item(index As Integer) As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property T default[int] { T get(int index); void set(int index, T value); };" />
      <MemberSignature Language="F#" Value="member this.Item(int) : 'T with get, set" Usage="System.Collections.Generic.List&lt;'T&gt;.Item" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.IList`1.Item(System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName Language="C#">[get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName Language="C#">[set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">要获取或设置的元素的从零开始的索引。</param>
        <summary>获取或设置指定索引处的元素。</summary>
        <value>指定索引处的元素。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601> 接受 `null` 作为引用类型的有效值，并允许重复元素。  
  
 通过此属性，可以使用以下语法来访问集合中的特定元素：`myCollection[index]`。  
  
 检索此属性的值是一个 O (1) 操作;设置属性也是 O (1) 操作。
  
## Examples  
 本部分中的示例演示了 <xref:System.Collections.Generic.List%601.Item%2A> c # 中的索引器 (的属性 ) 以及泛型类的各种其他属性和方法 <xref:System.Collections.Generic.List%601> 。 使用方法创建并填充列表后 <xref:System.Collections.Generic.List%601.Add%2A> ，将使用属性检索和显示元素 <xref:System.Collections.Generic.List%601.Item%2A> 。  (有关使用 <xref:System.Collections.Generic.List%601.Item%2A> 属性设置列表元素值的示例，请参阅 <xref:System.Collections.Generic.List%601.AsReadOnly%2A> 。 )   
  
> [!NOTE]
>  Visual Basic、c # 和 c + + 都具有用于访问属性的语法， <xref:System.Collections.Generic.List%601.Item%2A> 而不使用其名称。 相反，包含的变量 <xref:System.Collections.Generic.List%601> 将用作数组。  
  
 C # 语言使用 [`this`](/dotnet/csharp/language-reference/keywords/this) 关键字来定义索引器，而不是实现 <xref:System.Collections.Generic.List%601.Item%2A> 属性。 Visual Basic 将 <xref:System.Collections.Generic.List%601.Item%2A> 实现为默认属性，该属性提供相同的索引功能。  
  
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Class/cs/source.cs" interactive="try-dotnet-method" id="Snippet2":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Class/vb/source.vb" id="Snippet2":::
 [!code-csharp[List`1_Class#3](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Class/cs/source.cs#3)]
 [!code-vb[List`1_Class#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Class/vb/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> 小于 0。  
  
- 或 - 
 <paramref name="index" /> 等于或大于 <see cref="P:System.Collections.Generic.List`1.Count" />。</exception>
        <altmember cref="P:System.Collections.Generic.List`1.Count" />
      </Docs>
    </Member>
    <MemberGroup MemberName="LastIndexOf">
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>返回 <see cref="T:System.Collections.Generic.List`1" /> 或它的一部分中某个值的最后一个匹配项的从零开始的索引。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
 
## Examples  
 下面的示例演示方法的所有三个重载 <xref:System.Collections.Generic.List%601.LastIndexOf%2A> 。 将 <xref:System.Collections.Generic.List%601> 创建一个字符串，其中一个条目出现两次，位于索引位置0和索引位置5。 <xref:System.Collections.Generic.List%601.LastIndexOf%28%600%29>方法重载从末尾搜索整个列表，并查找字符串的第二个匹配项。 <xref:System.Collections.Generic.List%601.LastIndexOf%28%600%2CSystem.Int32%29>方法重载用于在列表中从索引位置3开始向后搜索，并延续到列表的开头，以便在列表中找到该字符串的第一个匹配项。 最后， <xref:System.Collections.Generic.List%601.LastIndexOf%28%600%2CSystem.Int32%2CSystem.Int32%29> 方法重载用于搜索由四个条目组成的范围，从索引位置4开始，扩展向后 (，也就是说，它在位置4、3、2和 1) 搜索项; 此搜索将返回-1，因为该范围中没有搜索字符串的实例。  
  
 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR/List`1_LastIndexOf/cpp/source.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR/List`1_LastIndexOf/cs/source.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_LastIndexOf/vb/source.vb" id="Snippet1":::
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (T item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(!T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.LastIndexOf(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (item As T) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(T item);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : 'T -&gt; int" Usage="list.LastIndexOf item" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="item">要在 <see cref="T:System.Collections.Generic.List`1" /> 中定位的对象。 对于引用类型，该值可以为 <see langword="null" />。</param>
        <summary>搜索指定对象并返回整个 <see cref="T:System.Collections.Generic.List`1" /> 中最后一个匹配项的从零开始索引。</summary>
        <returns>如果在整个 <see cref="T:System.Collections.Generic.List`1" /> 中找到 <paramref name="item" /> 的最后一个匹配项，则为该项的从零开始的索引；否则为 -1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601>向后搜索从最后一个元素开始，到第一个元素结束。  
  
 此方法使用的默认相等比较器 <xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=nameWithType> `T` （列表中的值的类型）确定相等性。  
  
 此方法执行线性搜索;因此，此方法是 O (*n*) 操作，其中 *n* 是 <xref:System.Collections.Generic.List%601.Count%2A> 。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Generic.List`1.IndexOf(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.Contains(`0)" />
        <related type="Article" href="/dotnet/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections">在集合中执行不区分区域性的字符串操作</related>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (T item, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(!T item, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.LastIndexOf(`0,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (item As T, index As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(T item, int index);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : 'T * int -&gt; int" Usage="list.LastIndexOf (item, index)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="item">要在 <see cref="T:System.Collections.Generic.List`1" /> 中定位的对象。 对于引用类型，该值可以为 <see langword="null" />。</param>
        <param name="index">向后搜索的从零开始的起始索引。</param>
        <summary>搜索指定对象并返回 <see cref="T:System.Collections.Generic.List`1" /> 中从第一个元素到指定索引这部分元素中最后一个匹配项的从零开始的索引。</summary>
        <returns>如果找到，则返回在 <see cref="T:System.Collections.Generic.List`1" /> 中从第一个元素到 <paramref name="index" /> 的元素范围内找到 <paramref name="item" /> 的最后一个匹配项的从零开始的索引；否则为 -1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601>向后搜索从 `index` 第一个元素开始和结束的位置。  
  
 此方法使用的默认相等比较器 <xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=nameWithType> `T` （列表中的值的类型）确定相等性。  
  
 此方法执行线性搜索;因此，此方法是 O (*n*) 操作，其中 *n* 是从开始到的元素的数目 <xref:System.Collections.Generic.List%601> `index` 。  
 
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> 超出了 <see cref="T:System.Collections.Generic.List`1" /> 的有效索引范围。</exception>
        <altmember cref="M:System.Collections.Generic.List`1.IndexOf(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.Contains(`0)" />
        <related type="Article" href="/dotnet/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections">在集合中执行不区分区域性的字符串操作</related>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (T item, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(!T item, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.LastIndexOf(`0,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (item As T, index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(T item, int index, int count);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : 'T * int * int -&gt; int" Usage="list.LastIndexOf (item, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="item">要在 <see cref="T:System.Collections.Generic.List`1" /> 中定位的对象。 对于引用类型，该值可以为 <see langword="null" />。</param>
        <param name="index">向后搜索的从零开始的起始索引。</param>
        <param name="count">要搜索的部分中的元素数。</param>
        <summary>搜索指定对象并返回 <see cref="T:System.Collections.Generic.List`1" /> 中到指定索引为止包含指定元素数的这部分元素中最后一个匹配项的从零开始索引。</summary>
        <returns>如果在 <see cref="T:System.Collections.Generic.List`1" /> 中到 <paramref name="index" /> 为止包含 <paramref name="count" /> 个元素的这部分元素中找到 <paramref name="item" /> 的最后一个匹配项，则为该项的从零开始的索引；否则为 -1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601> `index` `index` `count` 如果 `count` 大于0，则搜索从开始，到从减号 + 1 开始向后终止。  
  
 此方法使用的默认相等比较器 <xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=nameWithType> `T` （列表中的值的类型）确定相等性。  
  
 此方法执行线性搜索;因此，此方法是 O (*n*) 操作，其中 *n* 是 `count` 。  
 
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> 超出了 <see cref="T:System.Collections.Generic.List`1" /> 的有效索引范围。  
  
- 或 - 
 <paramref name="count" /> 小于 0。  
  
- 或 - 
 <paramref name="index" /> 和 <paramref name="count" /> 未在 <see cref="T:System.Collections.Generic.List`1" /> 中指定有效部分。</exception>
        <altmember cref="M:System.Collections.Generic.List`1.IndexOf(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.Contains(`0)" />
        <related type="Article" href="/dotnet/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections">在集合中执行不区分区域性的字符串操作</related>
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public bool Remove (T item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Remove(!T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Remove(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function Remove (item As T) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Remove(T item);" />
      <MemberSignature Language="F#" Value="abstract member Remove : 'T -&gt; bool&#xA;override this.Remove : 'T -&gt; bool" Usage="list.Remove item" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Remove(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="item">要从 <see cref="T:System.Collections.Generic.List`1" /> 中删除的对象。 对于引用类型，该值可以为 <see langword="null" />。</param>
        <summary>从 <see cref="T:System.Collections.Generic.List`1" /> 中移除特定对象的第一个匹配项。</summary>
        <returns>如果成功移除了 <paramref name="item" />，则为 <see langword="true" />；否则为 <see langword="false" />。  如果在 <see langword="false" /> 中没有找到 <paramref name="item" />，则此方法也会返回 <see cref="T:System.Collections.Generic.List`1" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果类型 `T` 实现 <xref:System.IEquatable%601> 泛型接口，则相等比较器是 <xref:System.IEquatable%601.Equals%2A> 该接口的方法; 否则，默认的相等比较器为 <xref:System.Object.Equals%2A?displayProperty=nameWithType> 。  
  
 此方法执行线性搜索;因此，此方法是 O (*n*) 操作，其中 *n* 是 <xref:System.Collections.Generic.List%601.Count%2A> 。
  
## Examples  

 下面的示例演示如何在中添加、移除和插入简单的业务对象 <xref:System.Collections.Generic.List%601> 。  
  
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/cs/program.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/vb/module1.vb" id="Snippet1":::
 :::code language="fsharp" source="~/samples/snippets/fsharp/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/fs/addremoveinsert.fs" id="Snippet1":::
  
 下面的示例演示 <xref:System.Collections.Generic.List%601.Remove%2A> 方法。 泛型类的多个属性和方法 <xref:System.Collections.Generic.List%601> 用于添加、插入和搜索列表。 完成这些操作后，列表包含重复的。 <xref:System.Collections.Generic.List%601.Remove%2A>方法用于删除重复项的第一个实例，并显示内容。 <xref:System.Collections.Generic.List%601.Remove%2A>方法始终删除其遇到的第一个实例。  
  
 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Class/cpp/source.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Class/cs/source.cs" interactive="try-dotnet-method" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Class/vb/source.vb" id="Snippet1":::
 :::code language="fsharp" source="~/samples/snippets/fsharp/VS_Snippets_CLR/List`1_Class/fs/listclass.fs" id="Snippet1":::
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Generic.List`1.RemoveAt(System.Int32)" />
        <altmember cref="M:System.Collections.Generic.List`1.RemoveRange(System.Int32,System.Int32)" />
        <altmember cref="M:System.Collections.Generic.List`1.Add(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.Insert(System.Int32,`0)" />
        <related type="Article" href="/dotnet/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections">在集合中执行不区分区域性的字符串操作</related>
      </Docs>
    </Member>
    <Member MemberName="RemoveAll">
      <MemberSignature Language="C#" Value="public int RemoveAll (Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 RemoveAll(class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.RemoveAll(System.Predicate{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveAll (match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int RemoveAll(Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="member this.RemoveAll : Predicate&lt;'T&gt; -&gt; int" Usage="list.RemoveAll match" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="match"><see cref="T:System.Predicate`1" /> 委托，用于定义要移除的元素应满足的条件。</param>
        <summary>移除与指定的谓词所定义的条件相匹配的所有元素。</summary>
        <returns>从 <see cref="T:System.Collections.Generic.List`1" /> 中移除的元素数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Predicate%601>是一个方法委托， `true` 如果传递给它的对象与委托中定义的条件相匹配，则它将返回。  将当前的元素 <xref:System.Collections.Generic.List%601> 分别传递到 <xref:System.Predicate%601> 委托，并从中删除与条件相匹配的元素 <xref:System.Collections.Generic.List%601> 。  
  
 此方法执行线性搜索;因此，此方法是 O (*n*) 操作，其中 *n* 是 <xref:System.Collections.Generic.List%601.Count%2A> 。
  
## Examples  
 下面的示例演示了 <xref:System.Collections.Generic.List%601.RemoveAll%2A> 使用泛型委托的方法和其他几种方法 <xref:System.Predicate%601> 。  
  
 <xref:System.Collections.Generic.List%601>创建一个字符串，其中包含8个恐龙名称，其中两个名称 (在位置1，5) 以 "saurus" 结尾。 该示例还定义了一个名为的搜索谓词方法 `EndsWithSaurus` ，该方法接受一个字符串参数，并返回一个布尔值，指示输入字符串是否以 "saurus" 结尾。  
  
 <xref:System.Collections.Generic.List%601.Find%2A>、 <xref:System.Collections.Generic.List%601.FindLast%2A> 和 <xref:System.Collections.Generic.List%601.FindAll%2A> 方法用于使用搜索谓词方法搜索列表。  
  
 <xref:System.Collections.Generic.List%601.RemoveAll%2A>方法用于删除以 "saurus" 结尾的所有条目。 它从头开始遍历列表，并将每个元素传递给 `EndsWithSaurus` 方法。 如果该方法返回，则移除该元素 `EndsWithSaurus` `true` 。  
  
> [!NOTE]
>  在 c # 和 Visual Basic 中，无需 `Predicate<string>` `Predicate(Of String)` 显式创建 Visual Basic) 中的委托 (。 这些语言从上下文推导出正确的委托，并自动创建它。  
  
 最后， <xref:System.Collections.Generic.List%601.Exists%2A> 方法验证列表中是否不存在以 "saurus" 结尾的字符串。  
 
 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR/List`1_FindEtAl/cpp/source.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR/List`1_FindEtAl/cs/source.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_FindEtAl/vb/source.vb" id="Snippet1"::: 
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="match" /> 为 <see langword="null" />。</exception>
        <altmember cref="M:System.Collections.Generic.List`1.FindAll(System.Predicate{`0})" />
        <altmember cref="T:System.Predicate`1" />
        <altmember cref="M:System.Collections.Generic.List`1.Remove(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.RemoveAt(System.Int32)" />
        <altmember cref="M:System.Collections.Generic.List`1.RemoveRange(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="RemoveAt">
      <MemberSignature Language="C#" Value="public void RemoveAt (int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RemoveAt(int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.RemoveAt(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RemoveAt (index As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void RemoveAt(int index);" />
      <MemberSignature Language="F#" Value="abstract member RemoveAt : int -&gt; unit&#xA;override this.RemoveAt : int -&gt; unit" Usage="list.RemoveAt index" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IList`1.RemoveAt(System.Int32)</InterfaceMember>
        <InterfaceMember>M:System.Collections.IList.RemoveAt(System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">要移除的元素的从零开始的索引。</param>
        <summary>移除 <see cref="T:System.Collections.Generic.List`1" /> 的指定索引处的元素。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 调用 <xref:System.Collections.Generic.List%601.RemoveAt%2A> 删除项时，将对列表中的其余项重新编号以替换移除的项。 例如，如果删除索引3处的项，则索引4处的项将移动到3个位置。 此外，列表中项目的数量 (由 <xref:System.Collections.Generic.List%601.Count%2A> 属性表示) 减少1。  
  
 此方法是一个 O (*n*) 操作，其中 *n* (<xref:System.Collections.Generic.List%601.Count%2A>  -  `index`) 。
  
## Examples  
 下面的示例演示如何在中添加、移除和插入简单的业务对象 <xref:System.Collections.Generic.List%601> 。  
  
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/cs/program.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/vb/module1.vb" id="Snippet1":::
 :::code language="fsharp" source="~/samples/snippets/fsharp/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/fs/addremoveinsert.fs" id="Snippet1":::
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> 小于 0。  
  
- 或 - 
 <paramref name="index" /> 等于或大于 <see cref="P:System.Collections.Generic.List`1.Count" />。</exception>
        <altmember cref="M:System.Collections.Generic.List`1.Remove(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.RemoveRange(System.Int32,System.Int32)" />
        <altmember cref="M:System.Collections.Generic.List`1.Add(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.Insert(System.Int32,`0)" />
      </Docs>
    </Member>
    <Member MemberName="RemoveRange">
      <MemberSignature Language="C#" Value="public void RemoveRange (int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RemoveRange(int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.RemoveRange(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RemoveRange (index As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RemoveRange(int index, int count);" />
      <MemberSignature Language="F#" Value="member this.RemoveRange : int * int -&gt; unit" Usage="list.RemoveRange (index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">要移除的元素范围的从零开始的起始索引。</param>
        <param name="count">要移除的元素数。</param>
        <summary>从 <see cref="T:System.Collections.Generic.List`1" /> 中移除一系列元素。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 项将被删除，并且它们后面的所有元素 <xref:System.Collections.Generic.List%601> 都使索引减少 `count` 。  
  
 此方法是 O (*n*) 操作，其中 *n* 是 <xref:System.Collections.Generic.List%601.Count%2A> 。
  
## Examples  
 下面的示例演示了对 <xref:System.Collections.Generic.List%601.RemoveRange%2A> 范围执行操作的类的方法和其他方法 <xref:System.Collections.Generic.List%601> 。 创建并修改列表后， <xref:System.Collections.Generic.List%601.RemoveRange%2A> 使用方法从列表中删除两个元素，从索引位置2开始。  
 
 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Ranges/cpp/source.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Ranges/cs/source.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Ranges/vb/source.vb" id="Snippet1":::
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> 小于 0。  
  
- 或 - 
 <paramref name="count" /> 小于 0。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="index" /> 和 <paramref name="count" /> 不表示 <see cref="T:System.Collections.Generic.List`1" /> 中元素的有效范围。</exception>
        <altmember cref="M:System.Collections.Generic.List`1.Remove(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.RemoveAt(System.Int32)" />
        <altmember cref="M:System.Collections.Generic.List`1.GetRange(System.Int32,System.Int32)" />
        <altmember cref="M:System.Collections.Generic.List`1.AddRange(System.Collections.Generic.IEnumerable{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.InsertRange(System.Int32,System.Collections.Generic.IEnumerable{`0})" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Reverse">
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>将 <see cref="T:System.Collections.Generic.List`1" /> 或它的一部分中元素的顺序反转。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下面的示例演示方法的两个重载 <xref:System.Collections.Generic.List%601.Reverse%2A> 。 该示例创建了一个 <xref:System.Collections.Generic.List%601> 字符串，并添加了六个字符串。 <xref:System.Collections.Generic.List%601.Reverse>方法重载用于反转列表，然后 <xref:System.Collections.Generic.List%601.Reverse%28System.Int32%2CSystem.Int32%29> 使用方法重载反转列表中间，从元素1开始，包含四个元素。  
  
 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Reverse/cpp/source.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Reverse/cs/source.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Reverse/vb/source.vb" id="Snippet1":::
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Reverse">
      <MemberSignature Language="C#" Value="public void Reverse ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Reverse() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Reverse" />
      <MemberSignature Language="VB.NET" Value="Public Sub Reverse ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Reverse();" />
      <MemberSignature Language="F#" Value="member this.Reverse : unit -&gt; unit" Usage="list.Reverse " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>将整个 <see cref="T:System.Collections.Generic.List`1" /> 中元素的顺序反转。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法使用 <xref:System.Array.Reverse%2A?displayProperty=nameWithType> 反转元素的顺序。  
  
 此方法是 O (*n*) 操作，其中 *n* 是 <xref:System.Collections.Generic.List%601.Count%2A> 。

       ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Reverse">
      <MemberSignature Language="C#" Value="public void Reverse (int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Reverse(int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Reverse(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Reverse (index As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Reverse(int index, int count);" />
      <MemberSignature Language="F#" Value="member this.Reverse : int * int -&gt; unit" Usage="list.Reverse (index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">要反转的范围的从零开始的起始索引。</param>
        <param name="count">要反转的范围内的元素数。</param>
        <summary>将指定范围中元素的顺序反转。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法使用 <xref:System.Array.Reverse%2A?displayProperty=nameWithType> 反转元素的顺序。  
  
 此方法是 O (*n*) 操作，其中 *n* 是 <xref:System.Collections.Generic.List%601.Count%2A> 。  
   
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> 小于 0。  
  
- 或 - 
 <paramref name="count" /> 小于 0。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="index" /> 和 <paramref name="count" /> 不表示 <see cref="T:System.Collections.Generic.List`1" /> 中元素的有效范围。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Sort">
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>使用指定或默认的 <see cref="T:System.Collections.Generic.IComparer`1" /> 实现或提供的 <see cref="T:System.Comparison`1" /> 委托对 <see cref="T:System.Collections.Generic.List`1" /> 中的元素或部分元素进行排序，以比较列表元素。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public void Sort ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Sort() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Sort" />
      <MemberSignature Language="VB.NET" Value="Public Sub Sort ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Sort();" />
      <MemberSignature Language="F#" Value="member this.Sort : unit -&gt; unit" Usage="list.Sort " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>使用默认比较器对整个 <see cref="T:System.Collections.Generic.List`1" /> 中的元素进行排序。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法使用类型的默认比较器 <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> `T` 来确定列表元素的顺序。 <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType>属性检查类型是否 `T` 实现 <xref:System.IComparable%601> 泛型接口，并使用该实现（如果可用）。  否则，将 <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> 检查类型是否 `T` 实现 <xref:System.IComparable> 接口。  如果类型 `T` 未实现任何一个接口， <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> 则会引发 <xref:System.InvalidOperationException> 。  
  
 此方法使用 <xref:System.Array.Sort%2A?displayProperty=nameWithType> 方法，该方法应用反省排序，如下所示：  
  
-   如果分区大小小于或等于16个元素，则它将使用插入排序算法。  
  
-   如果分区数超过2个 log *n*，其中 *n* 是输入数组的范围，则使用 Heapsort 算法。  
  
-   否则，它将使用快速排序算法。  
  
 此实现执行不稳定的排序;也就是说，如果两个元素相等，则可能不会保留它们的顺序。 相反，稳定排序会保留相等元素的顺序。  
  
 此方法是一个 O (*n* log *n*) 操作，其中 *n* 是 <xref:System.Collections.Generic.List%601.Count%2A> 。
  
## Examples  

 下面的示例向对象添加一些名称 `List<String>` ，以未排序的顺序显示列表，调用 <xref:System.Collections.Generic.List%601.Sort%2A> 方法，然后显示已排序的列表。  
  
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.sort/cs/Sort1.cs" interactive="try-dotnet-method" id="Snippet2":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.sort/vb/Sort1.vb" id="Snippet2":::
  
 下面的代码演示 <xref:System.Collections.Generic.List%601.Sort> <xref:System.Collections.Generic.List%601.Sort%28System.Comparison%7B%600%7D%29> 简单业务对象上的和方法重载。 调用 <xref:System.Collections.Generic.List%601.Sort> 方法会导致为部件类型使用默认比较器，并 <xref:System.Collections.Generic.List%601.Sort%28System.Comparison%7B%600%7D%29> 使用匿名方法实现方法。  
  
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.sort/cs/program.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.sort/vb/module1.vb" id="Snippet1":::  
  
 下面的示例演示 <xref:System.Collections.Generic.List%601.Sort> 方法重载和 <xref:System.Collections.Generic.List%601.BinarySearch%28%600%29> 方法重载。 <xref:System.Collections.Generic.List%601>将创建一个字符串，并以无特定顺序填充四个字符串。 将显示并排序列表，并再次显示该列表。  
  
 <xref:System.Collections.Generic.List%601.BinarySearch%28%600%29>然后，使用方法重载搜索两个不在列表中的字符串，该方法 <xref:System.Collections.Generic.List%601.Insert%2A> 用于插入它们。 <xref:System.Collections.Generic.List%601.BinarySearch%2A>在每种情况下，方法的返回值为负，因为字符串不在列表中。 采用 "c #" 和 "Visual C++ 中的 ~ 运算符 (按位求补运算， `Xor` 此负数 Visual Basic) 中的-1 将生成列表中大于搜索字符串的第一个元素的索引，并且在此位置插入将保留排序顺序。 第二个搜索字符串大于列表中的任何元素，因此插入位置在列表的末尾。  
  
 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR/List`1_SortSearch/cpp/source.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR/List`1_SortSearch/cs/source.cs" interactive="try-dotnet-method" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_SortSearch/vb/source.vb" id="Snippet1":::
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">此默认比较器 <see cref="P:System.Collections.Generic.Comparer`1.Default" /> 无法找到 <see cref="T:System.IComparable`1" /> 泛型接口或类型为 <paramref name="T" /> 的 <see cref="T:System.IComparable" /> 接口的实现。</exception>
        <related type="Article" href="/dotnet/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections">在集合中执行不区分区域性的字符串操作</related>
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public void Sort (System.Collections.Generic.IComparer&lt;T&gt; comparer);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Sort(class System.Collections.Generic.IComparer`1&lt;!T&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Sort(System.Collections.Generic.IComparer{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub Sort (comparer As IComparer(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Sort(System::Collections::Generic::IComparer&lt;T&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="member this.Sort : System.Collections.Generic.IComparer&lt;'T&gt; -&gt; unit" Usage="list.Sort comparer" />
      <MemberSignature Language="C#" Value="public void Sort (System.Collections.Generic.IComparer&lt;T&gt;? comparer);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="comparer">比较元素时要使用的 <see cref="T:System.Collections.Generic.IComparer`1" /> 实现，若要使用默认比较器 <see cref="P:System.Collections.Generic.Comparer`1.Default" />，则为 <see langword="null" />。</param>
        <summary>使用指定的比较器对整个 <see cref="T:System.Collections.Generic.List`1" /> 中的元素进行排序。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果 `comparer` 提供了，则使用指定的实现对的元素 <xref:System.Collections.Generic.List%601> 进行排序 <xref:System.Collections.Generic.IComparer%601> 。  
  
 如果 `comparer` 为 `null` ，则默认比较器将 <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> 检查类型是否 `T` 实现 <xref:System.IComparable%601> 泛型接口，并使用该实现（如果可用）。  否则，将 <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> 检查类型是否 `T` 实现 <xref:System.IComparable> 接口。  如果类型 `T` 未实现任何一个接口， <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> 则会引发 <xref:System.InvalidOperationException> 。  
  
 此方法使用 <xref:System.Array.Sort%2A?displayProperty=nameWithType> 方法，该方法应用反省排序，如下所示：  
  
-   如果分区大小小于或等于16个元素，则它将使用插入排序算法。  
  
-   如果分区数超过2个 log *n*，其中 *n* 是输入数组的范围，则使用 Heapsort 算法。  
  
-   否则，它将使用快速排序算法。  
  
 此实现执行不稳定的排序;也就是说，如果两个元素相等，则可能不会保留它们的顺序。 相反，稳定排序会保留相等元素的顺序。  
  
 此方法是一个 O (*n* log *n*) 操作，其中 *n* 是 <xref:System.Collections.Generic.List%601.Count%2A> 。
  
## Examples  
 下面的示例演示 <xref:System.Collections.Generic.List%601.Sort%28System.Collections.Generic.IComparer%7B%600%7D%29> 方法重载和 <xref:System.Collections.Generic.List%601.BinarySearch%28%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> 方法重载。  
  
 该示例定义了一个名为 DinoCompare 的字符串的替代比较器，该比较器 `IComparer<string>` `IComparer(Of String)` `IComparer<String^>` 在 Visual C++) 泛型接口中实现 Visual Basic 中的 (。 比较器的工作方式如下：首先，测试比较规则 `null` ，并将 null 引用视为小于非空引用。 其次，比较字符串长度，较长的字符串被认为更大。 第三，如果长度相等，则使用普通字符串比较。  
  
 <xref:System.Collections.Generic.List%601>将创建一个字符串，并以无特定顺序填充四个字符串。 随即显示列表，使用替代比较器对其进行排序，并再次显示。  
  
 <xref:System.Collections.Generic.List%601.BinarySearch%28%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29>然后，使用方法重载搜索多个不在列表中的字符串（采用备用比较器）。 <xref:System.Collections.Generic.List%601.Insert%2A>方法用于插入字符串。 这两个方法都位于名为的函数中 `SearchAndInsert` ，以及用于采用 c # 和 Visual C++ 中的 ~ 运算符 (按位求补的代码 `Xor`) Visual Basic， <xref:System.Collections.Generic.List%601.BinarySearch%28%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> 并将其用作用于插入新字符串的索引。  
  
 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR/List`1_SortSearchComparer/cpp/source.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR/List`1_SortSearchComparer/cs/source.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_SortSearchComparer/vb/source.vb" id="Snippet1":::
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><paramref name="comparer" /> 为 <see langword="null" />，且默认比较器 <see cref="P:System.Collections.Generic.Comparer`1.Default" /> 找不到 <see cref="T:System.IComparable`1" /> 泛型接口或类型为 <paramref name="T" /> 的 <see cref="T:System.IComparable" /> 接口的实现。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="comparer" /> 的实现导致排序时出现错误。 例如，将某个项与其自身比较时，<paramref name="comparer" /> 可能不返回 0。</exception>
        <related type="Article" href="/dotnet/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections">在集合中执行不区分区域性的字符串操作</related>
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public void Sort (Comparison&lt;T&gt; comparison);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Sort(class System.Comparison`1&lt;!T&gt; comparison) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Sort(System.Comparison{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub Sort (comparison As Comparison(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Sort(Comparison&lt;T&gt; ^ comparison);" />
      <MemberSignature Language="F#" Value="member this.Sort : Comparison&lt;'T&gt; -&gt; unit" Usage="list.Sort comparison" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="comparison" Type="System.Comparison&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="comparison">比较元素时要使用的 <see cref="T:System.Comparison`1" />。</param>
        <summary>使用指定的 <see cref="T:System.Comparison`1" />，对整个 <see cref="T:System.Collections.Generic.List`1" /> 中的元素进行排序。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果 `comparison` 提供了，则 <xref:System.Collections.Generic.List%601> 使用委托表示的方法对的元素进行排序。  
  
 如果 `comparison` 为 `null` ，则 <xref:System.ArgumentNullException> 引发。  
  
 此方法使用 <xref:System.Array.Sort%2A?displayProperty=nameWithType> ，它将应用反省排序，如下所示：  
  
-   如果分区大小小于或等于16个元素，则它将使用插入排序算法  
  
-   如果分区数超过2个 log *n*，其中 *n* 是输入数组的范围，则使用 [Heapsort](https://en.wikipedia.org/wiki/Heapsort) 算法。  
  
-   否则，它将使用快速排序算法。  
  
 此实现执行不稳定的排序;也就是说，如果两个元素相等，则可能不会保留它们的顺序。 相反，稳定排序会保留相等元素的顺序。  
  
 此方法是一个 O (*n* log *n*) 操作，其中 *n* 是 <xref:System.Collections.Generic.List%601.Count%2A> 。
  
## Examples  
 下面的代码演示 <xref:System.Collections.Generic.List%601.Sort%2A> <xref:System.Collections.Generic.List%601.Sort%2A> 简单业务对象上的和方法重载。 调用 <xref:System.Collections.Generic.List%601.Sort%2A> 方法会导致为部件类型使用默认比较器，并 <xref:System.Collections.Generic.List%601.Sort%2A> 使用匿名方法实现方法。  
  
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.sort/cs/program.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.sort/vb/module1.vb" id="Snippet1"::: 
  
 下面的示例演示 <xref:System.Collections.Generic.List%601.Sort%28System.Comparison%7B%600%7D%29> 方法重载。  
  
 该示例定义了一个名为的字符串的替代比较方法 `CompareDinosByLength` 。 此方法的工作方式如下：首先，测试比较规则 `null` ，并将 null 引用视为小于非空引用。 其次，比较字符串长度，较长的字符串被认为更大。 第三，如果长度相等，则使用普通字符串比较。  
  
 <xref:System.Collections.Generic.List%601>将创建一个字符串，并以无特定顺序填充四个字符串。 此列表还包括一个空字符串和一个空引用。 显示列表，使用 <xref:System.Comparison%601> 表示方法的泛型委托 `CompareDinosByLength` 进行排序，并再次显示。  
 
 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR/List`1_SortComparison/cpp/source.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR/List`1_SortComparison/cs/source.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_SortComparison/vb/source.vb" id="Snippet1"::: 
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="comparison" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="comparison" /> 的实现导致排序时出现错误。 例如，将某个项与其自身比较时，<paramref name="comparison" /> 可能不返回 0。</exception>
        <altmember cref="T:System.Comparison`1" />
        <related type="Article" href="/dotnet/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections">在集合中执行不区分区域性的字符串操作</related>
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public void Sort (int index, int count, System.Collections.Generic.IComparer&lt;T&gt; comparer);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Sort(int32 index, int32 count, class System.Collections.Generic.IComparer`1&lt;!T&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Sort(System.Int32,System.Int32,System.Collections.Generic.IComparer{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub Sort (index As Integer, count As Integer, comparer As IComparer(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Sort(int index, int count, System::Collections::Generic::IComparer&lt;T&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="member this.Sort : int * int * System.Collections.Generic.IComparer&lt;'T&gt; -&gt; unit" Usage="list.Sort (index, count, comparer)" />
      <MemberSignature Language="C#" Value="public void Sort (int index, int count, System.Collections.Generic.IComparer&lt;T&gt;? comparer);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="index">要排序范围的从零开始的起始索引。</param>
        <param name="count">要排序的范围的长度。</param>
        <param name="comparer">比较元素时要使用的 <see cref="T:System.Collections.Generic.IComparer`1" /> 实现，若要使用默认比较器 <see cref="P:System.Collections.Generic.Comparer`1.Default" />，则为 <see langword="null" />。</param>
        <summary>使用指定的比较器对 <see cref="T:System.Collections.Generic.List`1" /> 中某个范围内的元素进行排序。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果 `comparer` 提供了，则使用指定的实现对的元素 <xref:System.Collections.Generic.List%601> 进行排序 <xref:System.Collections.Generic.IComparer%601> 。  
  
 如果 `comparer` 为 `null` ，则默认比较器将 <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> 检查类型是否 `T` 实现 <xref:System.IComparable%601> 泛型接口，并使用该实现（如果可用）。  否则，将 <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> 检查类型是否 `T` 实现 <xref:System.IComparable> 接口。  如果类型 `T` 未实现任何一个接口， <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> 则会引发 <xref:System.InvalidOperationException> 。  
  
 此方法使用 <xref:System.Array.Sort%2A?displayProperty=nameWithType> ，它将应用反省排序，如下所示：  
  
-   如果分区大小小于或等于16个元素，则它将使用插入排序算法  
  
-   如果分区数超过2个 log *n*，其中 *n* 是输入数组的范围，则使用 [Heapsort](https://en.wikipedia.org/wiki/Heapsort) 算法。  
  
-   否则，它将使用快速排序算法。  
  
 此实现执行不稳定的排序;也就是说，如果两个元素相等，则可能不会保留它们的顺序。 相反，稳定排序会保留相等元素的顺序。  
  
 此方法是一个 O (*n* log *n*) 操作，其中 *n* 是 <xref:System.Collections.Generic.List%601.Count%2A> 。
  
## Examples  
 下面的示例演示 <xref:System.Collections.Generic.List%601.Sort%28System.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> 方法重载和 <xref:System.Collections.Generic.List%601.BinarySearch%28System.Int32%2CSystem.Int32%2C%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> 方法重载。  
  
 该示例定义了一个名为 DinoCompare 的字符串的替代比较器，该比较器 `IComparer<string>` `IComparer(Of String)` `IComparer<String^>` 在 Visual C++) 泛型接口中实现 Visual Basic 中的 (。 比较器的工作方式如下：首先，测试比较规则 `null` ，并将 null 引用视为小于非空引用。 其次，比较字符串长度，较长的字符串被认为更大。 第三，如果长度相等，则使用普通字符串比较。  
  
 <xref:System.Collections.Generic.List%601>创建一个字符串，并使用5个 herbivorous 恐龙和3个 carnivorous 恐龙的名称填充。 这两个组中的每个组的名称不是任何特定的排序顺序。 随即显示列表，使用替代比较器对 herbivores 的范围进行排序，并再次显示该列表。  
  
 <xref:System.Collections.Generic.List%601.BinarySearch%28System.Int32%2CSystem.Int32%2C%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29>然后，使用方法重载仅搜索 "Brachiosaurus" 的 herbivores 范围。 找不到该字符串，按位求补 (c # 中的 ~ 运算符和 Visual C++， `Xor` 该方法返回的负数 Visual Basic) 中的-1 <xref:System.Collections.Generic.List%601.BinarySearch%28System.Int32%2CSystem.Int32%2C%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> 将用作插入新字符串的索引。  
  
 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR/List`1_SortSearchComparerRange/cpp/source.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR/List`1_SortSearchComparerRange/cs/source.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_SortSearchComparerRange/vb/source.vb" id="Snippet1":::
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> 小于 0。  
  
- 或 - 
 <paramref name="count" /> 小于 0。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="index" /> 和 <paramref name="count" /> 未在 <see cref="T:System.Collections.Generic.List`1" /> 中指定有效范围。  
  
- 或 - 
<paramref name="comparer" /> 的实现导致排序时出现错误。 例如，将某个项与其自身比较时，<paramref name="comparer" /> 可能不返回 0。</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="comparer" /> 为 <see langword="null" />，且默认比较器 <see cref="P:System.Collections.Generic.Comparer`1.Default" /> 找不到 <see cref="T:System.IComparable`1" /> 泛型接口或类型为 <paramref name="T" /> 的 <see cref="T:System.IComparable" /> 接口的实现。</exception>
        <related type="Article" href="/dotnet/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections">在集合中执行不区分区域性的字符串操作</related>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.ICollection&lt;T&gt;.IsReadOnly">
      <MemberSignature Language="C#" Value="bool System.Collections.Generic.ICollection&lt;T&gt;.IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.Generic.ICollection&lt;T&gt;.IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.List`1.System#Collections#Generic#ICollection&lt;T&gt;#IsReadOnly" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsReadOnly As Boolean Implements ICollection(Of T).IsReadOnly" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Collections::Generic::ICollection&lt;T&gt;::IsReadOnly { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.System.Collections.Generic.ICollection&lt;T&gt;.IsReadOnly : bool" Usage="System.Collections.Generic.ICollection&lt;T&gt;.IsReadOnly" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.ICollection`1.IsReadOnly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName Language="C#">[get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示 <see cref="T:System.Collections.Generic.ICollection`1" /> 是否为只读。</summary>
        <value>如果 <see langword="true" /> 是只读的，则为 <see cref="T:System.Collections.Generic.ICollection`1" />；否则为 <see langword="false" />。  在 <see cref="T:System.Collections.Generic.List`1" /> 的默认实现中，此属性始终返回 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在创建只读集合后，该集合不允许添加、移除或修改元素。  
  
 只读集合就是一个集合，其中包含阻止修改集合的包装器;因此，如果对基础集合进行了更改，只读集合将反映这些更改。  
  
 检索此属性的值的运算复杂度为 O(1)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.IEnumerable&lt;T&gt;.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerator&lt;T&gt; IEnumerable&lt;T&gt;.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerator`1&lt;!T&gt; System.Collections.Generic.IEnumerable&lt;T&gt;.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.System#Collections#Generic#IEnumerable&lt;T&gt;#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator(Of T) Implements IEnumerable(Of T).GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::Generic::IEnumerator&lt;T&gt; ^ System.Collections.Generic.IEnumerable&lt;T&gt;.GetEnumerator() = System::Collections::Generic::IEnumerable&lt;T&gt;::GetEnumerator;" />
      <MemberSignature Language="F#" Value="abstract member System.Collections.Generic.IEnumerable&lt;T&gt;.GetEnumerator : unit -&gt; System.Collections.Generic.IEnumerator&lt;'T&gt;&#xA;override this.System.Collections.Generic.IEnumerable&lt;T&gt;.GetEnumerator : unit -&gt; System.Collections.Generic.IEnumerator&lt;'T&gt;" Usage="list.System.Collections.Generic.IEnumerable&lt;T&gt;.GetEnumerator " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IEnumerable`1.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerator&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回循环访问集合的枚举数。</summary>
        <returns>可用于循环访问集合的 <see cref="T:System.Collections.Generic.IEnumerator`1" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 C `foreach` + + 中的 c # 语言 (在 `for each` `For Each` Visual Basic 中) 隐藏了枚举器的复杂性。 因此，建议使用 `foreach`，而不是直接操作枚举数。  
  
 枚举器可用于读取集合中的数据，但不能用于修改基础集合。  
  
 最初，枚举数定位在集合中第一个元素的前面。 在此位置， <xref:System.Collections.Generic.IEnumerator%601.Current%2A> 属性未定义。 因此，在读取的值之前，必须调用 <xref:System.Collections.IEnumerator.MoveNext%2A> 方法，以将枚举器前进到集合的第一个元素 <xref:System.Collections.Generic.IEnumerator%601.Current%2A> 。  
  
 在 <xref:System.Collections.Generic.IEnumerator%601.Current%2A> 调用之前，属性将返回相同的对象 <xref:System.Collections.IEnumerator.MoveNext%2A> 。 <xref:System.Collections.IEnumerator.MoveNext%2A> 将 <xref:System.Collections.Generic.IEnumerator%601.Current%2A> 设置为下一个元素。  
  
 如果 <xref:System.Collections.IEnumerator.MoveNext%2A> 越过集合的末尾，则枚举器将定位在集合中最后一个元素之后，并 <xref:System.Collections.IEnumerator.MoveNext%2A> 返回 `false` 。 当枚举器位于此位置时，对的后续调用 <xref:System.Collections.IEnumerator.MoveNext%2A> 也将返回 `false` 。 如果最后一次调用 <xref:System.Collections.IEnumerator.MoveNext%2A> 返回 `false` ， <xref:System.Collections.Generic.IEnumerator%601.Current%2A> 则未定义。 无法再次将 <xref:System.Collections.Generic.IEnumerator%601.Current%2A> 设置为集合的第一个元素；必须改为创建新的枚举器实例。  
  
 只要集合保持不变，枚举器就仍有效。 如果对集合所做的更改（如添加、修改或删除元素），则枚举器将失效且不可恢复，并且对或的下一个调用将 <xref:System.Collections.IEnumerator.MoveNext%2A> <xref:System.Collections.IEnumerator.Reset%2A> 引发 <xref:System.InvalidOperationException> 。  
  
 枚举数没有对集合的独占访问权；因此，从头到尾对一个集合进行枚举在本质上不是一个线程安全的过程。 若要确保枚举过程中的线程安全性，可以在整个枚举过程中锁定集合。  若要允许多个线程访问集合以进行读写操作，则必须实现自己的同步。  
  
 <xref:System.Collections.Generic?displayProperty=nameWithType> 命名空间中集合的默认实现是不同步的。  
  
 此方法是 O (1) 操作。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.Generic.IEnumerator`1" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.CopyTo">
      <MemberSignature Language="C#" Value="void ICollection.CopyTo (Array array, int arrayIndex);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.ICollection.CopyTo(class System.Array array, int32 arrayIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.System#Collections#ICollection#CopyTo(System.Array,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Sub CopyTo (array As Array, arrayIndex As Integer) Implements ICollection.CopyTo" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.ICollection.CopyTo(Array ^ array, int arrayIndex) = System::Collections::ICollection::CopyTo;" />
      <MemberSignature Language="F#" Value="abstract member System.Collections.ICollection.CopyTo : Array * int -&gt; unit&#xA;override this.System.Collections.ICollection.CopyTo : Array * int -&gt; unit" Usage="list.System.Collections.ICollection.CopyTo (array, arrayIndex)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.ICollection.CopyTo(System.Array,System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="arrayIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">一维 <see cref="T:System.Array" />，它是从 <see cref="T:System.Collections.ICollection" /> 复制的元素的目标。 <see cref="T:System.Array" /> 必须具有从零开始的索引。</param>
        <param name="arrayIndex"><paramref name="array" /> 中从零开始的索引，从此处开始复制。</param>
        <summary>从特定的 <see cref="T:System.Collections.ICollection" /> 索引开始，将 <see cref="T:System.Array" /> 的元素复制到一个 <see cref="T:System.Array" /> 中。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  如果源的类型 <xref:System.Collections.ICollection> 不能自动强制转换为目标的类型 `array` ，则引发的非泛型实现 <xref:System.Collections.ICollection.CopyTo%2A?displayProperty=nameWithType> <xref:System.InvalidCastException> ，而泛型实现将引发 <xref:System.ArgumentException> 。  
  
 此方法是 O (*n*) 操作，其中 *n* 是 <xref:System.Collections.Generic.List%601.Count%2A> 。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="arrayIndex" /> 小于 0。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="array" /> 是多维的。  
  
- 或 - 
 <paramref name="array" /> 没有从零开始的索引。  
  
- 或 - 
源 <see cref="T:System.Collections.ICollection" /> 中的元素个数大于从 <paramref name="arrayIndex" /> 到目标 <paramref name="array" /> 末尾之间的可用空间。  
  
- 或 - 
无法自动将源 <see cref="T:System.Collections.ICollection" /> 的类型转换为目标 <paramref name="array" /> 的类型。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.IsSynchronized">
      <MemberSignature Language="C#" Value="bool System.Collections.ICollection.IsSynchronized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.ICollection.IsSynchronized" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.List`1.System#Collections#ICollection#IsSynchronized" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsSynchronized As Boolean Implements ICollection.IsSynchronized" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Collections::ICollection::IsSynchronized { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.System.Collections.ICollection.IsSynchronized : bool" Usage="System.Collections.ICollection.IsSynchronized" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.IsSynchronized</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示是否同步对 <see cref="T:System.Collections.ICollection" /> 的访问（线程安全）。</summary>
        <value>如果对 <see langword="true" /> 的访问是同步的（线程安全），则为 <see cref="T:System.Collections.ICollection" />；否则为 <see langword="false" />。  在 <see cref="T:System.Collections.Generic.List`1" /> 的默认实现中，此属性始终返回 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic?displayProperty=nameWithType> 命名空间中集合的默认实现是不同步的。  
  
 枚举整个集合本质上不是一个线程安全的过程。  在具有写入访问的枚举竞争的罕见情况下，可以在整个枚举过程中锁定集合。  若要允许多个线程访问集合以进行读写操作，则必须实现自己的同步。  
  
 <xref:System.Collections.ICollection.SyncRoot%2A> 返回一个对象，该对象可用于同步对的访问 <xref:System.Collections.ICollection> 。 仅当所有线程在访问集合之前锁定此对象时，同步才有效。  
  
 检索此属性的值的运算复杂度为 O(1)。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Collections.Generic.List`1.System#Collections#ICollection#SyncRoot" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.SyncRoot">
      <MemberSignature Language="C#" Value="object System.Collections.ICollection.SyncRoot { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object System.Collections.ICollection.SyncRoot" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.List`1.System#Collections#ICollection#SyncRoot" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property SyncRoot As Object Implements ICollection.SyncRoot" />
      <MemberSignature Language="C++ CLI" Value="property System::Object ^ System::Collections::ICollection::SyncRoot { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.System.Collections.ICollection.SyncRoot : obj" Usage="System.Collections.ICollection.SyncRoot" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.SyncRoot</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取可用于同步对 <see cref="T:System.Collections.ICollection" /> 的访问的对象。</summary>
        <value>用于同步对 <see cref="T:System.Collections.ICollection" /> 的访问的对象。  在 <see cref="T:System.Collections.Generic.List`1" /> 的默认实现中，此属性始终返回当前实例。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic?displayProperty=nameWithType> 命名空间中集合的默认实现是不同步的。  
  
 枚举整个集合本质上不是一个线程安全的过程。  若要确保枚举过程中的线程安全性，可以在整个枚举过程中锁定集合。  若要允许多个线程访问集合以进行读写操作，则必须实现自己的同步。  
  
 <xref:System.Collections.ICollection.SyncRoot%2A> 返回一个对象，该对象可用于同步对的访问 <xref:System.Collections.ICollection> 。 仅当所有线程在访问集合之前锁定此对象时，同步才有效。 下面的代码演示 <xref:System.Collections.ICollection.SyncRoot%2A> c #、c + + 和 Visual Basic 的属性的用法。  
  
```csharp  
ICollection ic = ...;  
lock (ic.SyncRoot)   
{  
    // Access the collection.  
}  
```  
  
```vb  
Dim ic As ICollection = ...  
SyncLock ic.SyncRoot  
    ' Access the collection.  
End SyncLock  
```  
  
```cpp
ICollection^ ic = ...;  
try   
{  
    Monitor::Enter(ic->SyncRoot);  
    // Access the collection.  
}  
finally   
{  
    Monitor::Exit(ic->SyncRoot);  
}  
```  
  
 检索此属性的值的运算复杂度为 O(1)。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Collections.Generic.List`1.System#Collections#ICollection#IsSynchronized" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerable.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IEnumerator IEnumerable.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.System#Collections#IEnumerable#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator Implements IEnumerable.GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IEnumerator ^ System.Collections.IEnumerable.GetEnumerator() = System::Collections::IEnumerable::GetEnumerator;" />
      <MemberSignature Language="F#" Value="abstract member System.Collections.IEnumerable.GetEnumerator : unit -&gt; System.Collections.IEnumerator&#xA;override this.System.Collections.IEnumerable.GetEnumerator : unit -&gt; System.Collections.IEnumerator" Usage="list.System.Collections.IEnumerable.GetEnumerator " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回循环访问集合的枚举数。</summary>
        <returns>可用于循环访问集合的 <see cref="T:System.Collections.IEnumerator" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 C `foreach` + + 中的 c # 语言 (在 `for each` `For Each` Visual Basic 中) 隐藏了枚举器的复杂性。 因此，建议使用 `foreach`，而不是直接操作枚举数。  
  
 枚举器可用于读取集合中的数据，但不能用于修改基础集合。  
  
 最初，枚举数定位在集合中第一个元素的前面。 <xref:System.Collections.IEnumerator.Reset%2A> 也会将枚举器放回此位置。  在此位置， <xref:System.Collections.IEnumerator.Current%2A> 属性未定义。 因此，在读取的值之前，必须调用 <xref:System.Collections.IEnumerator.MoveNext%2A> 方法，以将枚举器前进到集合的第一个元素 <xref:System.Collections.IEnumerator.Current%2A> 。  
  
 在 <xref:System.Collections.IEnumerator.Current%2A> 调用或之前，属性将返回相同的对象 <xref:System.Collections.IEnumerator.MoveNext%2A> <xref:System.Collections.IEnumerator.Reset%2A> 。 <xref:System.Collections.IEnumerator.MoveNext%2A> 将 <xref:System.Collections.IEnumerator.Current%2A> 设置为下一个元素。  
  
 如果 <xref:System.Collections.IEnumerator.MoveNext%2A> 越过集合的末尾，则枚举器将定位在集合中最后一个元素之后，并 <xref:System.Collections.IEnumerator.MoveNext%2A> 返回 `false` 。 当枚举器位于此位置时，对的后续调用 <xref:System.Collections.IEnumerator.MoveNext%2A> 也将返回 `false` 。 如果最后一次调用 <xref:System.Collections.IEnumerator.MoveNext%2A> 返回 `false` ， <xref:System.Collections.IEnumerator.Current%2A> 则未定义。 若要再次将 <xref:System.Collections.IEnumerator.Current%2A> 设置为集合的第一个元素，可以调用 <xref:System.Collections.IEnumerator.Reset%2A> 并接着调用 <xref:System.Collections.IEnumerator.MoveNext%2A>。  
  
 只要集合保持不变，枚举器就仍有效。 如果对集合所做的更改（如添加、修改或删除元素），则枚举器将失效且不可恢复，并且对或的下一个调用将 <xref:System.Collections.IEnumerator.MoveNext%2A> <xref:System.Collections.IEnumerator.Reset%2A> 引发 <xref:System.InvalidOperationException> 。  
  
 枚举数没有对集合的独占访问权；因此，从头到尾对一个集合进行枚举在本质上不是一个线程安全的过程。  若要确保枚举过程中的线程安全性，可以在整个枚举过程中锁定集合。  若要允许多个线程访问集合以进行读写操作，则必须实现自己的同步。  
  
 <xref:System.Collections.Generic?displayProperty=nameWithType> 命名空间中集合的默认实现是不同步的。  
  
 此方法是 O (1) 操作。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.IEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Add">
      <MemberSignature Language="C#" Value="int IList.Add (object item);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.Collections.IList.Add(object item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.System#Collections#IList#Add(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function Add (item As Object) As Integer Implements IList.Add" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.Collections.IList.Add(System::Object ^ item) = System::Collections::IList::Add;" />
      <MemberSignature Language="F#" Value="abstract member System.Collections.IList.Add : obj -&gt; int&#xA;override this.System.Collections.IList.Add : obj -&gt; int" Usage="list.System.Collections.IList.Add item" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Add(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="item">要添加到 <see cref="T:System.Object" /> 的 <see cref="T:System.Collections.IList" />。</param>
        <summary>将某项添加到 <see cref="T:System.Collections.IList" /> 中。</summary>
        <returns>新元素的插入位置。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果 <xref:System.Collections.Generic.List%601.Count%2A> 小于，则 <xref:System.Collections.Generic.List%601.Capacity%2A> 此方法是 O (1) 操作。 如果需要增加容量以容纳新元素，则此方法将变成 O (*n*) 操作，其中 *n* 是 <xref:System.Collections.Generic.List%601.Count%2A> 。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="item" /> 是一个无法赋值给 <see cref="T:System.Collections.IList" /> 的类型。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Contains">
      <MemberSignature Language="C#" Value="bool IList.Contains (object item);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Collections.IList.Contains(object item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.System#Collections#IList#Contains(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function Contains (item As Object) As Boolean Implements IList.Contains" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Collections.IList.Contains(System::Object ^ item) = System::Collections::IList::Contains;" />
      <MemberSignature Language="F#" Value="abstract member System.Collections.IList.Contains : obj -&gt; bool&#xA;override this.System.Collections.IList.Contains : obj -&gt; bool" Usage="list.System.Collections.IList.Contains item" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Contains(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="item">要在 <see cref="T:System.Object" /> 中定位的 <see cref="T:System.Collections.IList" />。</param>
        <summary>确定 <see cref="T:System.Collections.IList" /> 是否包含特定值。</summary>
        <returns>如果在 <see langword="true" /> 中找到 <paramref name="item" />，则为 <see cref="T:System.Collections.IList" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法使用的默认相等比较器 <xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=nameWithType> `T` （列表中的值的类型）确定相等性。  
  
 此方法执行线性搜索;因此，此方法是 O (*n*) 操作，其中 *n* 是 <xref:System.Collections.Generic.List%601.Count%2A> 。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.IndexOf">
      <MemberSignature Language="C#" Value="int IList.IndexOf (object item);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.Collections.IList.IndexOf(object item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.System#Collections#IList#IndexOf(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function IndexOf (item As Object) As Integer Implements IList.IndexOf" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.Collections.IList.IndexOf(System::Object ^ item) = System::Collections::IList::IndexOf;" />
      <MemberSignature Language="F#" Value="abstract member System.Collections.IList.IndexOf : obj -&gt; int&#xA;override this.System.Collections.IList.IndexOf : obj -&gt; int" Usage="list.System.Collections.IList.IndexOf item" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.IndexOf(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="item">要在 <see cref="T:System.Collections.IList" /> 中定位的对象。</param>
        <summary>确定 <see cref="T:System.Collections.IList" /> 中特定项的索引。</summary>
        <returns>如果在列表中找到，则为 <paramref name="item" /> 的索引；否则为 -1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法使用的默认相等比较器 <xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=nameWithType> `T` （列表中的值的类型）确定相等性。  
  
 此方法执行线性搜索;因此，此方法是 O (*n*) 操作，其中 *n* 是 <xref:System.Collections.Generic.List%601.Count%2A> 。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="item" /> 是一个无法赋值给 <see cref="T:System.Collections.IList" /> 的类型。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Insert">
      <MemberSignature Language="C#" Value="void IList.Insert (int index, object item);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.IList.Insert(int32 index, object item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.System#Collections#IList#Insert(System.Int32,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Sub Insert (index As Integer, item As Object) Implements IList.Insert" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.IList.Insert(int index, System::Object ^ item) = System::Collections::IList::Insert;" />
      <MemberSignature Language="F#" Value="abstract member System.Collections.IList.Insert : int * obj -&gt; unit&#xA;override this.System.Collections.IList.Insert : int * obj -&gt; unit" Usage="list.System.Collections.IList.Insert (index, item)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Insert(System.Int32,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="item" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="index">应插入 <paramref name="item" /> 的从零开始的索引。</param>
        <param name="item">要插入到 <see cref="T:System.Collections.IList" /> 中的对象。</param>
        <summary>在 <see cref="T:System.Collections.IList" /> 中的指定索引处插入一个项。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果 `index` 等于 <xref:System.Collections.IList> 中的项数，则将 `item` 追加到末尾。  
  
 此方法是 O (*n*) 操作，其中 *n* 是 <xref:System.Collections.Generic.List%601.Count%2A> 。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> 不是 <see cref="T:System.Collections.IList" /> 中的有效索引。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="item" /> 是一个无法赋值给 <see cref="T:System.Collections.IList" /> 的类型。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.IsFixedSize">
      <MemberSignature Language="C#" Value="bool System.Collections.IList.IsFixedSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.IList.IsFixedSize" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.List`1.System#Collections#IList#IsFixedSize" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsFixedSize As Boolean Implements IList.IsFixedSize" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Collections::IList::IsFixedSize { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.System.Collections.IList.IsFixedSize : bool" Usage="System.Collections.IList.IsFixedSize" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IList.IsFixedSize</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示 <see cref="T:System.Collections.IList" /> 是否具有固定大小。</summary>
        <value>如果 <see langword="true" /> 具有固定大小，则为 <see cref="T:System.Collections.IList" />；否则为 <see langword="false" />。  在 <see cref="T:System.Collections.Generic.List`1" /> 的默认实现中，此属性始终返回 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 具有固定大小的集合在创建之后不能再添加或移除元素，但是允许修改现有元素。  
  
 具有固定大小的集合就是一个集合，其中包含阻止添加和移除元素的包装;因此，如果对基础集合进行了更改，包括添加或删除元素，则固定大小的集合将反映这些更改。  
  
 检索此属性的值的运算复杂度为 O(1)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.IsReadOnly">
      <MemberSignature Language="C#" Value="bool System.Collections.IList.IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.IList.IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.List`1.System#Collections#IList#IsReadOnly" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsReadOnly As Boolean Implements IList.IsReadOnly" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Collections::IList::IsReadOnly { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.System.Collections.IList.IsReadOnly : bool" Usage="System.Collections.IList.IsReadOnly" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IList.IsReadOnly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName Language="C#">[get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示 <see cref="T:System.Collections.IList" /> 是否为只读。</summary>
        <value>如果 <see langword="true" /> 是只读的，则为 <see cref="T:System.Collections.IList" />；否则为 <see langword="false" />。  在 <see cref="T:System.Collections.Generic.List`1" /> 的默认实现中，此属性始终返回 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在创建只读集合后，该集合不允许添加、移除或修改元素。  
  
 只读集合就是一个集合，其中包含阻止修改集合的包装器;因此，如果对基础集合进行了更改，只读集合将反映这些更改。  
  
 检索此属性的值的运算复杂度为 O(1)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Item">
      <MemberSignature Language="C#" Value="object System.Collections.IList.Item[int index] { get; set; }" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".property instance object System.Collections.IList.Item(int32)" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.List`1.System#Collections#IList#Item(System.Int32)" />
      <MemberSignature Language="VB.NET" Value=" Property Item(index As Integer) As Object Implements IList.Item" />
      <MemberSignature Language="C++ CLI" Value="property System::Object ^ System::Collections::IList::Item[int] { System::Object ^ get(int index); void set(int index, System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.System.Collections.IList.Item(int) : obj with get, set" Usage="System.Collections.IList.Item" />
      <MemberSignature Language="C#" Value="object? System.Collections.IList.Item[int index] { get; set; }" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IList.Item(System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">要获取或设置的元素的从零开始的索引。</param>
        <summary>获取或设置指定索引处的元素。</summary>
        <value>指定索引处的元素。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 C # 语言使用 [this](/dotnet/csharp/language-reference/keywords/this) 关键字来定义索引器，而不是实现 <xref:System.Collections.Generic.List%601.System%23Collections%23IList%23Item%2A> 属性。 Visual Basic 将 <xref:System.Collections.Generic.List%601.System%23Collections%23IList%23Item%2A> 实现为默认属性，该属性提供相同的索引功能。  
  
 检索此属性的值是一个 O (1) 操作;设置属性也是 O (1) 操作。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> 不是 <see cref="T:System.Collections.IList" /> 中的有效索引。</exception>
        <exception cref="T:System.ArgumentException">已设置属性，且 <paramref name="value" /> 属于不能对 <see cref="T:System.Collections.IList" /> 赋值的类型。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Remove">
      <MemberSignature Language="C#" Value="void IList.Remove (object item);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.IList.Remove(object item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.System#Collections#IList#Remove(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Sub Remove (item As Object) Implements IList.Remove" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.IList.Remove(System::Object ^ item) = System::Collections::IList::Remove;" />
      <MemberSignature Language="F#" Value="abstract member System.Collections.IList.Remove : obj -&gt; unit&#xA;override this.System.Collections.IList.Remove : obj -&gt; unit" Usage="list.System.Collections.IList.Remove item" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Remove(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="item">要从 <see cref="T:System.Collections.IList" /> 中删除的对象。</param>
        <summary>从 <see cref="T:System.Collections.IList" /> 中移除特定对象的第一个匹配项。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法使用的默认相等比较器 <xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=nameWithType> `T` （列表中的值的类型）确定相等性。  
  
 此方法执行线性搜索;因此，此方法是 O (*n*) 操作，其中 *n* 是 <xref:System.Collections.Generic.List%601.Count%2A> 。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="item" /> 是一个无法赋值给 <see cref="T:System.Collections.IList" /> 的类型。</exception>
      </Docs>
    </Member>
    <Member MemberName="ToArray">
      <MemberSignature Language="C#" Value="public T[] ToArray ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !T[] ToArray() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.ToArray" />
      <MemberSignature Language="VB.NET" Value="Public Function ToArray () As T()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;T&gt; ^ ToArray();" />
      <MemberSignature Language="F#" Value="member this.ToArray : unit -&gt; 'T[]" Usage="list.ToArray " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>将 <see cref="T:System.Collections.Generic.List`1" /> 的元素复制到新数组中。</summary>
        <returns>一个包含 <see cref="T:System.Collections.Generic.List`1" /> 的元素副本的数组。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用复制元素 <xref:System.Array.Copy%2A?displayProperty=nameWithType> ，这是一个 O (*n*) 操作，其中 *n* 是 <xref:System.Collections.Generic.List%601.Count%2A> 。  
  
 此方法是 O (*n*) 操作，其中 *n* 是 <xref:System.Collections.Generic.List%601.Count%2A> 。
  
## Examples  
 下面的示例演示了对 <xref:System.Collections.Generic.List%601.ToArray%2A> 范围执行操作的类的方法和其他方法 <xref:System.Collections.Generic.List%601> 。 在示例结束时， <xref:System.Collections.Generic.List%601.GetRange%2A> 方法用于从列表中获取三个项，从索引位置2开始。 对 <xref:System.Collections.Generic.List%601.ToArray%2A> 生成的方法调用方法 <xref:System.Collections.Generic.List%601> ，创建一个包含三个元素的数组。 显示数组的元素。  
  
 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Ranges/cpp/source.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Ranges/cs/source.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Ranges/vb/source.vb" id="Snippet1"::: 
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimExcess">
      <MemberSignature Language="C#" Value="public void TrimExcess ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void TrimExcess() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.TrimExcess" />
      <MemberSignature Language="VB.NET" Value="Public Sub TrimExcess ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void TrimExcess();" />
      <MemberSignature Language="F#" Value="member this.TrimExcess : unit -&gt; unit" Usage="list.TrimExcess " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>将容量设置为 <see cref="T:System.Collections.Generic.List`1" /> 中元素的实际数目（如果该数目小于某个阈值）。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果没有新元素添加到集合中，则可以使用此方法最大程度地减少集合的内存开销。 但重新分配和复制较大的成本 <xref:System.Collections.Generic.List%601> 可能很大，因此， <xref:System.Collections.Generic.List%601.TrimExcess%2A> 如果列表的容量超过90%，此方法不会执行任何操作。 这样可以避免因相对较小的收益而产生较大的重新分配成本。  
  
> [!NOTE]
>  在未来的版本中，当前阈值90% 可能会更改。  
  
 此方法是 O (*n*) 操作，其中 *n* 是 <xref:System.Collections.Generic.List%601.Count%2A> 。  
  
 若要将重置 <xref:System.Collections.Generic.List%601> 为其初始状态，请 <xref:System.Collections.Generic.List%601.Clear%2A> 在调用方法之前调用方法 <xref:System.Collections.Generic.List%601.TrimExcess%2A> 。 修整空会将的 <xref:System.Collections.Generic.List%601> 容量设置 <xref:System.Collections.Generic.List%601> 为默认容量。  
  
 还可以使用属性设置容量 <xref:System.Collections.Generic.List%601.Capacity%2A> 。
  
## Examples  

 下面的示例演示如何检查  <xref:System.Collections.Generic.List%601> 包含简单业务对象的的容量和计数，并说明如何使用 <xref:System.Collections.Generic.List%601.TrimExcess%2A> 方法来删除额外的容量。  
 
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.capacitycount/cs/program.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.capacitycount/vb/module1.vb" id="Snippet1":::
  
 下面的示例演示 <xref:System.Collections.Generic.List%601.TrimExcess%2A> 方法。 类的多个属性和方法 <xref:System.Collections.Generic.List%601> 用于在字符串列表中添加、插入和移除项。 然后， <xref:System.Collections.Generic.List%601.TrimExcess%2A> 使用方法来减小容量以匹配计数，并 <xref:System.Collections.Generic.List%601.Capacity%2A> <xref:System.Collections.Generic.List%601.Count%2A> 显示和属性。 如果未使用的容量小于总容量的10%，则不会调整此列表的大小。 最后，清除列表的内容。  
 
 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Class/cpp/source.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Class/cs/source.cs" interactive="try-dotnet-method" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Class/vb/source.vb" id="Snippet1":::  
 :::code language="fsharp" source="~/samples/snippets/fsharp/VS_Snippets_CLR/List`1_Class/fs/listclass.fs" id="Snippet1":::
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Generic.List`1.Clear" />
        <altmember cref="P:System.Collections.Generic.List`1.Capacity" />
        <altmember cref="P:System.Collections.Generic.List`1.Count" />
      </Docs>
    </Member>
    <Member MemberName="TrueForAll">
      <MemberSignature Language="C#" Value="public bool TrueForAll (Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TrueForAll(class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.TrueForAll(System.Predicate{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function TrueForAll (match As Predicate(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TrueForAll(Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="member this.TrueForAll : Predicate&lt;'T&gt; -&gt; bool" Usage="list.TrueForAll match" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="match">用于定义检查元素时要对照条件的 <see cref="T:System.Predicate`1" /> 委托。</param>
        <summary>确定 <see cref="T:System.Collections.Generic.List`1" /> 中的每个元素是否都与指定谓词定义的条件匹配。</summary>
        <returns>如果 <see cref="T:System.Collections.Generic.List`1" /> 中的每个元素都与指定的谓词所定义的条件相匹配，则为 <see langword="true" />；否则为 <see langword="false" />。 如果列表没有元素，则返回值为 <see langword="true" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Predicate%601>是一个方法委托， `true` 如果传递给它的对象与委托中定义的条件相匹配，则它将返回。  当前的元素 <xref:System.Collections.Generic.List%601> 被单独传递到 <xref:System.Predicate%601> 委托，当委托为任何元素返回时，将停止处理 `false` 。 元素按顺序进行处理，所有调用都在单个线程上进行。  
  
 此方法是 O (*n*) 操作，其中 *n* 是 <xref:System.Collections.Generic.List%601.Count%2A> 。
  
## Examples  
 下面的示例演示了 <xref:System.Collections.Generic.List%601.TrueForAll%2A> 使用泛型委托的方法和其他几种方法 <xref:System.Predicate%601> 。  
  
 <xref:System.Collections.Generic.List%601>创建一个字符串，其中包含8个恐龙名称，其中两个名称 (在位置1，5) 以 "saurus" 结尾。 该示例还定义了一个名为的搜索谓词方法 `EndsWithSaurus` ，该方法接受一个字符串参数，并返回一个布尔值，指示输入字符串是否以 "saurus" 结尾。  
  
 <xref:System.Collections.Generic.List%601.TrueForAll%2A>方法从头开始遍历列表，并将中的每个元素传递给 `EndsWithSaurus` 方法。 此方法返回时将停止搜索 `EndsWithSaurus` `false` 。  
  
> [!NOTE]
>  在 c # 和 Visual Basic 中，无需 `Predicate<string>` `Predicate(Of String)` 显式创建 Visual Basic) 中的委托 (。 这些语言从上下文推断正确的委托并自动创建它。  
  
 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR/List`1_FindEtAl/cpp/source.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR/List`1_FindEtAl/cs/source.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_FindEtAl/vb/source.vb" id="Snippet1":::
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="match" /> 为 <see langword="null" />。</exception>
        <altmember cref="M:System.Collections.Generic.List`1.Exists(System.Predicate{`0})" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
  </Members>
</Type>
