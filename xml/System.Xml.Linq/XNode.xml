<Type Name="XNode" FullName="System.Xml.Linq.XNode">
  <Metadata><Meta Name="ms.openlocfilehash" Value="6562d9a525aa8909246d60534789d15b2b8661fa" /><Meta Name="ms.sourcegitcommit" Value="5484acfd78fc29edb48fc1ca6925046c4672954a" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-CN" /><Meta Name="ms.lasthandoff" Value="09/16/2020" /><Meta Name="ms.locfileid" Value="90690350" /></Metadata><TypeSignature Language="C#" Value="public abstract class XNode : System.Xml.Linq.XObject" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit XNode extends System.Xml.Linq.XObject" />
  <TypeSignature Language="DocId" Value="T:System.Xml.Linq.XNode" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class XNode&#xA;Inherits XObject" />
  <TypeSignature Language="C++ CLI" Value="public ref class XNode abstract : System::Xml::Linq::XObject" />
  <TypeSignature Language="F#" Value="type XNode = class&#xA;    inherit XObject" />
  <AssemblyInfo>
    <AssemblyName>System.Xml.XDocument</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
    <AssemblyVersion>4.1.2.0</AssemblyVersion>
    <AssemblyVersion>5.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Xml.Linq</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>3.5.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeForwardingChain>
    <TypeForwarding From="System.Xml.Linq" FromVersion="4.0.0.0" To="System.Xml.XDocument" ToVersion="0.0.0.0" FrameworkAlternate="dotnet-uwp-10.0" />
    <TypeForwarding From="netstandard" FromVersion="2.1.0.0" To="System.Xml.XDocument" ToVersion="5.0.0.0" FrameworkAlternate="net-5.0" />
  </TypeForwardingChain>
  <Base>
    <BaseTypeName>System.Xml.Linq.XObject</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary><span data-ttu-id="d621c-101">表示 XML 树中节点的抽象概念（元素、注释、文档类型、处理指令或文本节点）。</span><span class="sxs-lookup"><span data-stu-id="d621c-101">Represents the abstract concept of a node (element, comment, document type, processing instruction, or text node) in the XML tree.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d621c-102"><xref:System.Xml.Linq.XNode> 是以下类型的抽象公共基类：</span><span class="sxs-lookup"><span data-stu-id="d621c-102"><xref:System.Xml.Linq.XNode> is an abstract common base class for the following types:</span></span>  
  
-   <xref:System.Xml.Linq.XComment>  
  
-   <xref:System.Xml.Linq.XContainer>  
  
-   <xref:System.Xml.Linq.XDocumentType>  
  
-   <xref:System.Xml.Linq.XProcessingInstruction>  
  
-   <xref:System.Xml.Linq.XText>  
  
 <span data-ttu-id="d621c-103"><xref:System.Xml.Linq.XContainer> 是以下类型的抽象公共基类：</span><span class="sxs-lookup"><span data-stu-id="d621c-103"><xref:System.Xml.Linq.XContainer> is an abstract common base class for the following types:</span></span>  
  
-   <xref:System.Xml.Linq.XDocument>  
  
-   <xref:System.Xml.Linq.XElement>  
  
 <span data-ttu-id="d621c-104">派生自的类的对象 <xref:System.Xml.Linq.XContainer> 可包含子节点。</span><span class="sxs-lookup"><span data-stu-id="d621c-104">Objects of classes that derive from <xref:System.Xml.Linq.XContainer> can contain child nodes.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d621c-105"><xref:System.Xml.Linq.XAttribute>不是 <xref:System.Xml.Linq.XNode> 。</span><span class="sxs-lookup"><span data-stu-id="d621c-105">An <xref:System.Xml.Linq.XAttribute> is not an <xref:System.Xml.Linq.XNode>.</span></span> <span data-ttu-id="d621c-106">特性作为元素的名称/值对列表进行维护。</span><span class="sxs-lookup"><span data-stu-id="d621c-106">Attributes are maintained as a list of name/value pairs on an element.</span></span>  
  
 <span data-ttu-id="d621c-107">如果您要编写一个复杂的 XML 应用程序（例如，将内容存储为 XML 的 XML 编辑器或字处理器），则通常会在节点级别上工作。</span><span class="sxs-lookup"><span data-stu-id="d621c-107">If you are writing a complex XML application, such as an XML editor or a word processor that stores content as XML, you will often work at the node level.</span></span> <span data-ttu-id="d621c-108">在节点级别工作时的典型活动包括添加节点、删除节点、转换节点以及循环访问返回节点集合的轴。</span><span class="sxs-lookup"><span data-stu-id="d621c-108">Typical activities when working at the node level include adding nodes, deleting nodes, transforming nodes, and iterating through axes that return collections of nodes.</span></span>  
  
 ]]></format>
    </remarks>
    <related type="Article" href="/dotnet/standard/linq/linq-xml-overview"><span data-ttu-id="d621c-109">LINQ to XML 概述</span><span class="sxs-lookup"><span data-stu-id="d621c-109">LINQ to XML overview</span></span></related>
  </Docs>
  <Members>
    <MemberGroup MemberName="AddAfterSelf">
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="d621c-110">紧跟在此节点之后添加指定的内容。</span><span class="sxs-lookup"><span data-stu-id="d621c-110">Adds the specified content immediately after this node.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d621c-111">有关可传递到此方法的有效内容的详细信息，请参阅 [system.xml.linq.xelement> 和 XDocument 对象的有效内容](/dotnet/standard/linq/valid-content-xelement-xdocument-objects)。</span><span class="sxs-lookup"><span data-stu-id="d621c-111">For details about the valid content that can be passed to this method, see [Valid Content of XElement and XDocument Objects](/dotnet/standard/linq/valid-content-xelement-xdocument-objects).</span></span>  
  
 <span data-ttu-id="d621c-112">此方法将引发 <xref:System.Xml.Linq.XObject.Changed> 和 <xref:System.Xml.Linq.XObject.Changing> 事件。</span><span class="sxs-lookup"><span data-stu-id="d621c-112">This method will raise the <xref:System.Xml.Linq.XObject.Changed> and the <xref:System.Xml.Linq.XObject.Changing> events.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d621c-113">下面的示例使用 LINQ 查询创建 <xref:System.Collections.Generic.IEnumerable%601> 的 <xref:System.Xml.Linq.XElement> ，然后将其传递给此方法。</span><span class="sxs-lookup"><span data-stu-id="d621c-113">The following example uses a LINQ query to create an <xref:System.Collections.Generic.IEnumerable%601> of <xref:System.Xml.Linq.XElement>, which it then passes to this method.</span></span> <span data-ttu-id="d621c-114">这会将查询结果添加到树中所需的位置。</span><span class="sxs-lookup"><span data-stu-id="d621c-114">This adds the results of a query to the tree in the desired location.</span></span>  
  
```csharp  
XElement srcTree = new XElement("Root",  
    new XElement("Element1", 1),  
    new XElement("Element2", 2),  
    new XElement("Element3", 3),  
    new XElement("Element4", 4),  
    new XElement("Element5", 5)  
);  
XElement xmlTree = new XElement("Root",  
    new XElement("Child1", 1),  
    new XElement("Child2", 2),  
    new XElement("Child3", 3),  
    new XElement("Child4", 4),  
    new XElement("Child5", 5)  
);  
XElement child1 = xmlTree.Element("Child1");  
child1.AddAfterSelf(  
    from el in srcTree.Elements()  
    where (int)el > 3  
    select el  
);  
Console.WriteLine(xmlTree);  
```  
  
```vb  
Dim srcTree As XElement = _  
    <Root>  
        <Element1>1</Element1>  
        <Element2>2</Element2>  
        <Element3>3</Element3>  
        <Element4>4</Element4>  
        <Element5>5</Element5>  
    </Root>  
  
Dim xmlTree As XElement = _  
    <Root>  
        <Child1>1</Child1>  
        <Child2>2</Child2>  
        <Child3>3</Child3>  
        <Child4>4</Child4>  
        <Child5>5</Child5>  
    </Root>  
  
Dim child1 As XElement = xmlTree.<Child1>(0)  
child1.AddAfterSelf( _  
    From el In srcTree.Elements() _  
    Where CInt(el) > 3 _  
    Select el _  
)  
Console.WriteLine(xmlTree)  
```  
  
 <span data-ttu-id="d621c-115">该示例产生下面的输出：</span><span class="sxs-lookup"><span data-stu-id="d621c-115">This example produces the following output:</span></span>  
  
```xml  
<Root>  
  <Child1>1</Child1>  
  <Element4>4</Element4>  
  <Element5>5</Element5>  
  <Child2>2</Child2>  
  <Child3>3</Child3>  
  <Child4>4</Child4>  
  <Child5>5</Child5>  
</Root>  
```  
  
 ]]></format>
        </remarks>
        <related type="Article" href="/dotnet/standard/linq/linq-xml-overview"><span data-ttu-id="d621c-116">LINQ to XML 概述</span><span class="sxs-lookup"><span data-stu-id="d621c-116">LINQ to XML overview</span></span></related>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddAfterSelf">
      <MemberSignature Language="C#" Value="public void AddAfterSelf (object content);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddAfterSelf(object content) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XNode.AddAfterSelf(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddAfterSelf (content As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddAfterSelf(System::Object ^ content);" />
      <MemberSignature Language="F#" Value="member this.AddAfterSelf : obj -&gt; unit" Usage="xNode.AddAfterSelf content" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="content" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="content"><span data-ttu-id="d621c-117">要添加到此节点之后的包含简单内容的内容对象或内容对象集合。</span><span class="sxs-lookup"><span data-stu-id="d621c-117">A content object that contains simple content or a collection of content objects to be added after this node.</span></span></param>
        <summary><span data-ttu-id="d621c-118">紧跟在此节点之后添加指定的内容。</span><span class="sxs-lookup"><span data-stu-id="d621c-118">Adds the specified content immediately after this node.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d621c-119">有关可传递到此方法的有效内容的详细信息，请参阅 [system.xml.linq.xelement> 和 XDocument 对象的有效内容](/dotnet/standard/linq/valid-content-xelement-xdocument-objects)。</span><span class="sxs-lookup"><span data-stu-id="d621c-119">For details about the valid content that can be passed to this method, see [Valid Content of XElement and XDocument Objects](/dotnet/standard/linq/valid-content-xelement-xdocument-objects).</span></span>  
  
 <span data-ttu-id="d621c-120"><xref:System.Xml.Linq.XObject.Changing> 事件。</span><span class="sxs-lookup"><span data-stu-id="d621c-120"><xref:System.Xml.Linq.XObject.Changing> events.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d621c-121">下面的示例使用此方法将元素添加到树中。</span><span class="sxs-lookup"><span data-stu-id="d621c-121">The following example uses this method to add an element into the tree.</span></span>  
  
```csharp  
XElement xmlTree = new XElement("Root",  
    new XElement("Child1", 1),  
    new XElement("Child2", 2),  
    new XElement("Child3", 3),  
    new XElement("Child4", 4),  
    new XElement("Child5", 5)  
);  
XElement child1 = xmlTree.Element("Child1");  
child1.AddAfterSelf(  
    new XElement("NewChild", 10)  
);  
Console.WriteLine(xmlTree);  
```  
  
```vb  
Dim xmlTree As XElement = _   
        <Root>  
            <Child1>1</Child1>  
            <Child2>2</Child2>  
            <Child3>3</Child3>  
            <Child4>4</Child4>  
            <Child5>5</Child5>  
        </Root>  
  
Dim child1 As XElement = xmlTree.<Child1>(0)  
child1.AddAfterSelf(New XElement("NewChild", 10))  
Console.WriteLine(xmlTree)  
```  
  
 <span data-ttu-id="d621c-122">该示例产生下面的输出：</span><span class="sxs-lookup"><span data-stu-id="d621c-122">This example produces the following output:</span></span>  
  
```xml  
<Root>  
  <Child1>1</Child1>  
  <NewChild>10</NewChild>  
  <Child2>2</Child2>  
  <Child3>3</Child3>  
  <Child4>4</Child4>  
  <Child5>5</Child5>  
</Root>  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="d621c-123">父级为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d621c-123">The parent is <see langword="null" />.</span></span></exception>
        <related type="Article" href="/dotnet/standard/linq/linq-xml-overview"><span data-ttu-id="d621c-124">LINQ to XML 概述</span><span class="sxs-lookup"><span data-stu-id="d621c-124">LINQ to XML overview</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="AddAfterSelf">
      <MemberSignature Language="C#" Value="public void AddAfterSelf (params object[] content);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddAfterSelf(object[] content) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XNode.AddAfterSelf(System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddAfterSelf (ParamArray content As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddAfterSelf(... cli::array &lt;System::Object ^&gt; ^ content);" />
      <MemberSignature Language="F#" Value="member this.AddAfterSelf : obj[] -&gt; unit" Usage="xNode.AddAfterSelf content" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="content" Type="System.Object[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName Language="C#">[System.ParamArray]</AttributeName>
              <AttributeName Language="F#">[&lt;System.ParamArray&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="content"><span data-ttu-id="d621c-125">内容对象的参数列表。</span><span class="sxs-lookup"><span data-stu-id="d621c-125">A parameter list of content objects.</span></span></param>
        <summary><span data-ttu-id="d621c-126">紧跟在此节点之后添加指定的内容。</span><span class="sxs-lookup"><span data-stu-id="d621c-126">Adds the specified content immediately after this node.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d621c-127">有关可传递到此方法的有效内容的详细信息，请参阅 [system.xml.linq.xelement> 和 XDocument 对象的有效内容](/dotnet/standard/linq/valid-content-xelement-xdocument-objects)。</span><span class="sxs-lookup"><span data-stu-id="d621c-127">For details about the valid content that can be passed to this method, see [Valid Content of XElement and XDocument Objects](/dotnet/standard/linq/valid-content-xelement-xdocument-objects).</span></span>  
  
 <span data-ttu-id="d621c-128">此方法将引发 <xref:System.Xml.Linq.XObject.Changed> 和 <xref:System.Xml.Linq.XObject.Changing> 事件。</span><span class="sxs-lookup"><span data-stu-id="d621c-128">This method will raise the <xref:System.Xml.Linq.XObject.Changed> and the <xref:System.Xml.Linq.XObject.Changing> events.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d621c-129">下面的示例使用 LINQ 查询创建 <xref:System.Collections.Generic.IEnumerable%601> 的 <xref:System.Xml.Linq.XElement> ，然后将其传递给此方法。</span><span class="sxs-lookup"><span data-stu-id="d621c-129">The following example uses a LINQ query to create an <xref:System.Collections.Generic.IEnumerable%601> of <xref:System.Xml.Linq.XElement>, which it then passes to this method.</span></span> <span data-ttu-id="d621c-130">这会将查询结果添加到树中所需的位置。</span><span class="sxs-lookup"><span data-stu-id="d621c-130">This adds the results of a query to the tree in the desired location.</span></span>  
  
```csharp  
XElement srcTree = new XElement("Root",  
    new XElement("Element1", 1),  
    new XElement("Element2", 2),  
    new XElement("Element3", 3),  
    new XElement("Element4", 4),  
    new XElement("Element5", 5)  
);  
XElement xmlTree = new XElement("Root",  
    new XElement("Child1", 1),  
    new XElement("Child2", 2),  
    new XElement("Child3", 3),  
    new XElement("Child4", 4),  
    new XElement("Child5", 5)  
);  
XElement child1 = xmlTree.Element("Child1");  
child1.AddAfterSelf(  
    from el in srcTree.Elements()  
    where (int)el > 3  
    select el  
);  
Console.WriteLine(xmlTree);  
```  
  
```vb  
Dim srcTree As XElement = _   
        <Root>  
            <Element1>1</Element1>  
            <Element2>2</Element2>  
            <Element3>3</Element3>  
            <Element4>4</Element4>  
            <Element5>5</Element5>  
        </Root>  
  
Dim xmlTree As XElement = _   
        <Root>  
            <Child1>1</Child1>  
            <Child2>2</Child2>  
            <Child3>3</Child3>  
            <Child4>4</Child4>  
            <Child5>5</Child5>  
        </Root>  
  
Dim child1 As XElement = xmlTree.<Child1>(0)  
child1.AddAfterSelf( _  
    From el In srcTree.Elements() _  
    Where CInt(el) > 3 _  
    Select el)  
Console.WriteLine(xmlTree)  
```  
  
 <span data-ttu-id="d621c-131">该示例产生下面的输出：</span><span class="sxs-lookup"><span data-stu-id="d621c-131">This example produces the following output:</span></span>  
  
```xml  
<Root>  
  <Child1>1</Child1>  
  <Element4>4</Element4>  
  <Element5>5</Element5>  
  <Child2>2</Child2>  
  <Child3>3</Child3>  
  <Child4>4</Child4>  
  <Child5>5</Child5>  
</Root>  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="d621c-132">父级为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d621c-132">The parent is <see langword="null" />.</span></span></exception>
        <related type="Article" href="/dotnet/standard/linq/linq-xml-overview"><span data-ttu-id="d621c-133">LINQ to XML 概述</span><span class="sxs-lookup"><span data-stu-id="d621c-133">LINQ to XML overview</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="AddBeforeSelf">
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="d621c-134">紧邻此节点之前添加指定的内容。</span><span class="sxs-lookup"><span data-stu-id="d621c-134">Adds the specified content immediately before this node.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d621c-135">有关可传递到此方法的有效内容的详细信息，请参阅 [system.xml.linq.xelement> 和 XDocument 对象的有效内容](/dotnet/standard/linq/valid-content-xelement-xdocument-objects)。</span><span class="sxs-lookup"><span data-stu-id="d621c-135">For details about the valid content that can be passed to this method, see [Valid Content of XElement and XDocument Objects](/dotnet/standard/linq/valid-content-xelement-xdocument-objects).</span></span>  
  
 <span data-ttu-id="d621c-136">此方法将引发 <xref:System.Xml.Linq.XObject.Changed> 和 <xref:System.Xml.Linq.XObject.Changing> 事件。</span><span class="sxs-lookup"><span data-stu-id="d621c-136">This method will raise the <xref:System.Xml.Linq.XObject.Changed> and <xref:System.Xml.Linq.XObject.Changing> events.</span></span>  
  
 <span data-ttu-id="d621c-137">将其子 <xref:System.Xml.Linq.XContainer> 注释存储为对象的单向链接列表 <xref:System.Xml.Linq.XNode> 。</span><span class="sxs-lookup"><span data-stu-id="d621c-137">The <xref:System.Xml.Linq.XContainer> stores its child notes as a singly-linked list of <xref:System.Xml.Linq.XNode> objects.</span></span> <span data-ttu-id="d621c-138">这意味着该 <xref:System.Xml.Linq.XNode.AddBeforeSelf%2A> 方法必须遍历父容器下直接子节点的列表。</span><span class="sxs-lookup"><span data-stu-id="d621c-138">This means that the <xref:System.Xml.Linq.XNode.AddBeforeSelf%2A> method must traverse the list of direct child nodes under the parent container.</span></span> <span data-ttu-id="d621c-139">因此，使用此方法可能会影响性能。</span><span class="sxs-lookup"><span data-stu-id="d621c-139">Therefore, using this method might  affect your performance.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d621c-140">下面的示例使用 LINQ 查询创建 <xref:System.Collections.Generic.IEnumerable%601> 的 <xref:System.Xml.Linq.XElement> ，然后将其传递给此方法。</span><span class="sxs-lookup"><span data-stu-id="d621c-140">The following example uses a LINQ query to create an <xref:System.Collections.Generic.IEnumerable%601> of <xref:System.Xml.Linq.XElement>, which it then passes to this method.</span></span> <span data-ttu-id="d621c-141">这会将查询结果添加到树中所需的位置。</span><span class="sxs-lookup"><span data-stu-id="d621c-141">This adds the results of a query to the tree in the desired location.</span></span>  
  
```csharp  
XElement srcTree = new XElement("Root",  
    new XElement("Element1", 1),  
    new XElement("Element2", 2),  
    new XElement("Element3", 3),  
    new XElement("Element4", 4),  
    new XElement("Element5", 5)  
);  
XElement xmlTree = new XElement("Root",  
    new XElement("Child1", 1),  
    new XElement("Child2", 2),  
    new XElement("Child3", 3),  
    new XElement("Child4", 4),  
    new XElement("Child5", 5)  
);  
XElement child1 = xmlTree.Element("Child1");  
child1.AddBeforeSelf(  
    from el in srcTree.Elements()  
    where (int)el > 3  
    select el  
);  
Console.WriteLine(xmlTree);  
```  
  
```vb  
Dim srcTree As XElement = _   
        <Root>  
            <Element1>1</Element1>  
            <Element2>2</Element2>  
            <Element3>3</Element3>  
            <Element4>4</Element4>  
            <Element5>5</Element5>  
        </Root>  
  
Dim xmlTree As XElement = _   
        <Root>  
            <Child1>1</Child1>  
            <Child2>2</Child2>  
            <Child3>3</Child3>  
            <Child4>4</Child4>  
            <Child5>5</Child5>  
        </Root>  
  
Dim child1 As XElement = xmlTree.<Child1>(0)  
child1.AddBeforeSelf( _  
From el In srcTree.Elements() _  
Where CInt(el) > 3 _  
Select el)  
  
Console.WriteLine(xmlTree)  
```  
  
 <span data-ttu-id="d621c-142">该示例产生下面的输出：</span><span class="sxs-lookup"><span data-stu-id="d621c-142">This example produces the following output:</span></span>  
  
```xml  
<Root>  
  <Element4>4</Element4>  
  <Element5>5</Element5>  
  <Child1>1</Child1>  
  <Child2>2</Child2>  
  <Child3>3</Child3>  
  <Child4>4</Child4>  
  <Child5>5</Child5>  
</Root>  
```  
  
 ]]></format>
        </remarks>
        <related type="Article" href="/dotnet/standard/linq/linq-xml-overview"><span data-ttu-id="d621c-143">LINQ to XML 概述</span><span class="sxs-lookup"><span data-stu-id="d621c-143">LINQ to XML overview</span></span></related>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddBeforeSelf">
      <MemberSignature Language="C#" Value="public void AddBeforeSelf (object content);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddBeforeSelf(object content) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XNode.AddBeforeSelf(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddBeforeSelf (content As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddBeforeSelf(System::Object ^ content);" />
      <MemberSignature Language="F#" Value="member this.AddBeforeSelf : obj -&gt; unit" Usage="xNode.AddBeforeSelf content" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="content" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="content"><span data-ttu-id="d621c-144">要添加到此节点之前的包含简单内容的内容对象或内容对象集合。</span><span class="sxs-lookup"><span data-stu-id="d621c-144">A content object that contains simple content or a collection of content objects to be added before this node.</span></span></param>
        <summary><span data-ttu-id="d621c-145">紧邻此节点之前添加指定的内容。</span><span class="sxs-lookup"><span data-stu-id="d621c-145">Adds the specified content immediately before this node.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d621c-146">有关可传递到此方法的有效内容的详细信息，请参阅 [system.xml.linq.xelement> 和 XDocument 对象的有效内容](/dotnet/standard/linq/valid-content-xelement-xdocument-objects)。</span><span class="sxs-lookup"><span data-stu-id="d621c-146">For details about the valid content that can be passed to this method, see [Valid Content of XElement and XDocument Objects](/dotnet/standard/linq/valid-content-xelement-xdocument-objects).</span></span>  
  
 <span data-ttu-id="d621c-147">此方法将引发 <xref:System.Xml.Linq.XObject.Changed> 和 <xref:System.Xml.Linq.XObject.Changing> 事件。</span><span class="sxs-lookup"><span data-stu-id="d621c-147">This method will raise the <xref:System.Xml.Linq.XObject.Changed> and the <xref:System.Xml.Linq.XObject.Changing> events.</span></span>  
  
 <span data-ttu-id="d621c-148">将其子 <xref:System.Xml.Linq.XContainer> 节点存储为对象的单向链接列表 <xref:System.Xml.Linq.XNode> 。</span><span class="sxs-lookup"><span data-stu-id="d621c-148">The <xref:System.Xml.Linq.XContainer> stores its child nodes as a singly-linked list of <xref:System.Xml.Linq.XNode> objects.</span></span> <span data-ttu-id="d621c-149">这意味着该 <xref:System.Xml.Linq.XNode.AddBeforeSelf%2A> 方法必须遍历父容器下直接子节点的列表。</span><span class="sxs-lookup"><span data-stu-id="d621c-149">This means that the <xref:System.Xml.Linq.XNode.AddBeforeSelf%2A> method must traverse the list of direct child nodes under the parent container.</span></span> <span data-ttu-id="d621c-150">因此，使用此方法可能会影响性能。</span><span class="sxs-lookup"><span data-stu-id="d621c-150">Therefore, using this method might  affect your performance.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d621c-151">下面的示例使用此方法将元素添加到树中。</span><span class="sxs-lookup"><span data-stu-id="d621c-151">The following example uses this method to add an element into the tree.</span></span>  
  
```csharp  
XElement xmlTree = new XElement("Root",  
    new XElement("Child1", 1),  
    new XElement("Child2", 2),  
    new XElement("Child3", 3),  
    new XElement("Child4", 4),  
    new XElement("Child5", 5)  
);  
XElement child1 = xmlTree.Element("Child1");  
child1.AddBeforeSelf(  
    new XElement("NewChild", 10)  
);  
Console.WriteLine(xmlTree);  
```  
  
```vb  
Dim xmlTree As XElement = _   
        <Root>  
            <Child1>1</Child1>  
            <Child2>2</Child2>  
            <Child3>3</Child3>  
            <Child4>4</Child4>  
            <Child5>5</Child5>  
        </Root>  
  
Dim child1 As XElement = xmlTree.<Child1>(0)  
child1.AddBeforeSelf(New XElement("NewChild", 10))  
Console.WriteLine(xmlTree)  
```  
  
 <span data-ttu-id="d621c-152">该示例产生下面的输出：</span><span class="sxs-lookup"><span data-stu-id="d621c-152">This example produces the following output:</span></span>  
  
```xml  
<Root>  
  <NewChild>10</NewChild>  
  <Child1>1</Child1>  
  <Child2>2</Child2>  
  <Child3>3</Child3>  
  <Child4>4</Child4>  
  <Child5>5</Child5>  
</Root>  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="d621c-153">父级为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d621c-153">The parent is <see langword="null" />.</span></span></exception>
        <related type="Article" href="/dotnet/standard/linq/linq-xml-overview"><span data-ttu-id="d621c-154">LINQ to XML 概述</span><span class="sxs-lookup"><span data-stu-id="d621c-154">LINQ to XML overview</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="AddBeforeSelf">
      <MemberSignature Language="C#" Value="public void AddBeforeSelf (params object[] content);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddBeforeSelf(object[] content) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XNode.AddBeforeSelf(System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddBeforeSelf (ParamArray content As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddBeforeSelf(... cli::array &lt;System::Object ^&gt; ^ content);" />
      <MemberSignature Language="F#" Value="member this.AddBeforeSelf : obj[] -&gt; unit" Usage="xNode.AddBeforeSelf content" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="content" Type="System.Object[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName Language="C#">[System.ParamArray]</AttributeName>
              <AttributeName Language="F#">[&lt;System.ParamArray&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="content"><span data-ttu-id="d621c-155">内容对象的参数列表。</span><span class="sxs-lookup"><span data-stu-id="d621c-155">A parameter list of content objects.</span></span></param>
        <summary><span data-ttu-id="d621c-156">紧邻此节点之前添加指定的内容。</span><span class="sxs-lookup"><span data-stu-id="d621c-156">Adds the specified content immediately before this node.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d621c-157">有关可传递到此方法的有效内容的详细信息，请参阅 [system.xml.linq.xelement> 和 XDocument 对象的有效内容](/dotnet/standard/linq/valid-content-xelement-xdocument-objects)。</span><span class="sxs-lookup"><span data-stu-id="d621c-157">For details about the valid content that can be passed to this method, see [Valid Content of XElement and XDocument Objects](/dotnet/standard/linq/valid-content-xelement-xdocument-objects).</span></span>  
  
 <span data-ttu-id="d621c-158">此方法将引发 <xref:System.Xml.Linq.XObject.Changed> 和 <xref:System.Xml.Linq.XObject.Changing> 事件。</span><span class="sxs-lookup"><span data-stu-id="d621c-158">This method will raise the <xref:System.Xml.Linq.XObject.Changed> and the <xref:System.Xml.Linq.XObject.Changing> events.</span></span>  
  
 <span data-ttu-id="d621c-159">将其子 <xref:System.Xml.Linq.XContainer> 节点存储为对象的单向链接列表 <xref:System.Xml.Linq.XNode> 。</span><span class="sxs-lookup"><span data-stu-id="d621c-159">The <xref:System.Xml.Linq.XContainer> stores its child nodes as a singly-linked list of <xref:System.Xml.Linq.XNode> objects.</span></span> <span data-ttu-id="d621c-160">这意味着该 <xref:System.Xml.Linq.XNode.AddBeforeSelf%2A> 方法必须遍历父容器下直接子节点的列表。</span><span class="sxs-lookup"><span data-stu-id="d621c-160">This means that the <xref:System.Xml.Linq.XNode.AddBeforeSelf%2A> method must traverse the list of direct child nodes under the parent container.</span></span> <span data-ttu-id="d621c-161">因此，使用此函数可能会影响性能。</span><span class="sxs-lookup"><span data-stu-id="d621c-161">Therefore, using this function might affect your performance.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d621c-162">下面的示例使用 LINQ 查询创建 <xref:System.Collections.Generic.IEnumerable%601> 的 <xref:System.Xml.Linq.XElement> ，然后将其传递给此方法。</span><span class="sxs-lookup"><span data-stu-id="d621c-162">The following example uses a LINQ query to create an <xref:System.Collections.Generic.IEnumerable%601> of <xref:System.Xml.Linq.XElement>, which it then passes to this method.</span></span> <span data-ttu-id="d621c-163">这会将查询结果添加到树中所需的位置。</span><span class="sxs-lookup"><span data-stu-id="d621c-163">This adds the results of a query to the tree in the desired location.</span></span>  
  
```csharp  
XElement srcTree = new XElement("Root",  
    new XElement("Element1", 1),  
    new XElement("Element2", 2),  
    new XElement("Element3", 3),  
    new XElement("Element4", 4),  
    new XElement("Element5", 5)  
);  
XElement xmlTree = new XElement("Root",  
    new XElement("Child1", 1),  
    new XElement("Child2", 2),  
    new XElement("Child3", 3),  
    new XElement("Child4", 4),  
    new XElement("Child5", 5)  
);  
XElement child1 = xmlTree.Element("Child1");  
child1.AddBeforeSelf(  
    from el in srcTree.Elements()  
    where (int)el > 3  
    select el  
);  
Console.WriteLine(xmlTree);  
```  
  
```vb  
Dim srcTree As XElement = _   
        <Root>  
            <Element1>1</Element1>  
            <Element2>2</Element2>  
            <Element3>3</Element3>  
            <Element4>4</Element4>  
            <Element5>5</Element5>  
        </Root>  
  
Dim xmlTree As XElement = _   
        <Root>  
            <Child1>1</Child1>  
            <Child2>2</Child2>  
            <Child3>3</Child3>  
            <Child4>4</Child4>  
            <Child5>5</Child5>  
        </Root>  
  
Dim child1 As XElement = xmlTree.<Child1>(0)  
child1.AddBeforeSelf( _  
    From el In srcTree.Elements() _  
    Where CInt(el) > 3 _  
    Select el)  
  
Console.WriteLine(xmlTree)  
```  
  
 <span data-ttu-id="d621c-164">该示例产生下面的输出：</span><span class="sxs-lookup"><span data-stu-id="d621c-164">This example produces the following output:</span></span>  
  
```xml  
<Root>  
  <Element4>4</Element4>  
  <Element5>5</Element5>  
  <Child1>1</Child1>  
  <Child2>2</Child2>  
  <Child3>3</Child3>  
  <Child4>4</Child4>  
  <Child5>5</Child5>  
</Root>  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="d621c-165">父级为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d621c-165">The parent is <see langword="null" />.</span></span></exception>
        <related type="Article" href="/dotnet/standard/linq/linq-xml-overview"><span data-ttu-id="d621c-166">LINQ to XML 概述</span><span class="sxs-lookup"><span data-stu-id="d621c-166">LINQ to XML overview</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Ancestors">
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="d621c-167">返回此节点的上级元素的集合。</span><span class="sxs-lookup"><span data-stu-id="d621c-167">Returns a collection of the ancestor elements of this node.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d621c-168">（可选）可以指定节点名称以筛选具有特定名称的上级元素。</span><span class="sxs-lookup"><span data-stu-id="d621c-168">Optionally a node name can be specified to filter for ancestor elements with a specific name.</span></span>  
  
 <span data-ttu-id="d621c-169">返回的集合中的节点顺序与文档顺序相反。</span><span class="sxs-lookup"><span data-stu-id="d621c-169">The nodes in the returned collection are in reverse document order.</span></span>  
  
 <span data-ttu-id="d621c-170">此方法使用延迟执行。</span><span class="sxs-lookup"><span data-stu-id="d621c-170">This method uses deferred execution.</span></span>  
  
 ]]></format>
        </remarks>
        <related type="Article" href="/dotnet/standard/linq/linq-xml-overview"><span data-ttu-id="d621c-171">LINQ to XML 概述</span><span class="sxs-lookup"><span data-stu-id="d621c-171">LINQ to XML overview</span></span></related>
      </Docs>
    </MemberGroup>
    <Member MemberName="Ancestors">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.Xml.Linq.XElement&gt; Ancestors ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;class System.Xml.Linq.XElement&gt; Ancestors() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XNode.Ancestors" />
      <MemberSignature Language="VB.NET" Value="Public Function Ancestors () As IEnumerable(Of XElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IEnumerable&lt;System::Xml::Linq::XElement ^&gt; ^ Ancestors();" />
      <MemberSignature Language="F#" Value="member this.Ancestors : unit -&gt; seq&lt;System.Xml.Linq.XElement&gt;" Usage="xNode.Ancestors " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Xml.Linq.XElement&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="d621c-172">返回此节点的上级元素的集合。</span><span class="sxs-lookup"><span data-stu-id="d621c-172">Returns a collection of the ancestor elements of this node.</span></span></summary>
        <returns><span data-ttu-id="d621c-173">此节点上级元素的 <see cref="T:System.Xml.Linq.XElement" /> 的 <see cref="T:System.Collections.Generic.IEnumerable`1" />。</span><span class="sxs-lookup"><span data-stu-id="d621c-173">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> of <see cref="T:System.Xml.Linq.XElement" /> of the ancestor elements of this node.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d621c-174">此方法不会在结果中返回自身。</span><span class="sxs-lookup"><span data-stu-id="d621c-174">This method does not return itself in the results.</span></span>  
  
 <span data-ttu-id="d621c-175">返回的集合中的节点顺序与文档顺序相反。</span><span class="sxs-lookup"><span data-stu-id="d621c-175">The nodes in the returned collection are in reverse document order.</span></span>  
  
 <span data-ttu-id="d621c-176">此方法使用延迟执行。</span><span class="sxs-lookup"><span data-stu-id="d621c-176">This method uses deferred execution.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d621c-177">下面的示例使用此方法枚举节点的上级。</span><span class="sxs-lookup"><span data-stu-id="d621c-177">The following example uses this method to enumerate the ancestors of a node.</span></span>  
  
```csharp  
XElement xmlTree = new XElement("Root",  
    new XElement("Child",   
        new XElement("GrandChild", "content")  
    )  
);  
IEnumerable<XElement> grandChild = xmlTree.Descendants("GrandChild");  
foreach (XElement el in grandChild.Ancestors())  
    Console.WriteLine(el.Name);  
```  
  
```vb  
Dim xmlTree As XElement = _   
        <Root>  
            <Child>  
                <GrandChild>content</GrandChild>  
            </Child>  
        </Root>  
  
Dim grandChild As IEnumerable(Of XElement) = xmlTree...<GrandChild>  
For Each el In grandChild.Ancestors()  
    Console.WriteLine(el.Name)  
Next  
```  
  
 <span data-ttu-id="d621c-178">该示例产生下面的输出：</span><span class="sxs-lookup"><span data-stu-id="d621c-178">This example produces the following output:</span></span>  
  
```  
Child  
Root  
```  
  
 ]]></format>
        </remarks>
        <related type="Article" href="/dotnet/standard/linq/linq-xml-overview"><span data-ttu-id="d621c-179">LINQ to XML 概述</span><span class="sxs-lookup"><span data-stu-id="d621c-179">LINQ to XML overview</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Ancestors">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.Xml.Linq.XElement&gt; Ancestors (System.Xml.Linq.XName name);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;class System.Xml.Linq.XElement&gt; Ancestors(class System.Xml.Linq.XName name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XNode.Ancestors(System.Xml.Linq.XName)" />
      <MemberSignature Language="VB.NET" Value="Public Function Ancestors (name As XName) As IEnumerable(Of XElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IEnumerable&lt;System::Xml::Linq::XElement ^&gt; ^ Ancestors(System::Xml::Linq::XName ^ name);" />
      <MemberSignature Language="F#" Value="member this.Ancestors : System.Xml.Linq.XName -&gt; seq&lt;System.Xml.Linq.XElement&gt;" Usage="xNode.Ancestors name" />
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.Xml.Linq.XElement&gt; Ancestors (System.Xml.Linq.XName? name);" FrameworkAlternate="net-5.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Xml.Linq.XElement&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Xml.Linq.XName" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="d621c-180">要匹配的 <see cref="T:System.Xml.Linq.XName" />。</span><span class="sxs-lookup"><span data-stu-id="d621c-180">The <see cref="T:System.Xml.Linq.XName" /> to match.</span></span></param>
        <summary><span data-ttu-id="d621c-181">返回此节点的经过筛选的上级元素的集合。</span><span class="sxs-lookup"><span data-stu-id="d621c-181">Returns a filtered collection of the ancestor elements of this node.</span></span> <span data-ttu-id="d621c-182">集合中仅包括具有匹配 <see cref="T:System.Xml.Linq.XName" /> 的元素。</span><span class="sxs-lookup"><span data-stu-id="d621c-182">Only elements that have a matching <see cref="T:System.Xml.Linq.XName" /> are included in the collection.</span></span></summary>
        <returns><span data-ttu-id="d621c-183">此节点上级元素的 <see cref="T:System.Xml.Linq.XElement" /> 的 <see cref="T:System.Collections.Generic.IEnumerable`1" />。</span><span class="sxs-lookup"><span data-stu-id="d621c-183">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> of <see cref="T:System.Xml.Linq.XElement" /> of the ancestor elements of this node.</span></span> <span data-ttu-id="d621c-184">集合中仅包括具有匹配 <see cref="T:System.Xml.Linq.XName" /> 的元素。</span><span class="sxs-lookup"><span data-stu-id="d621c-184">Only elements that have a matching <see cref="T:System.Xml.Linq.XName" /> are included in the collection.</span></span>  
  
<span data-ttu-id="d621c-185">返回的集合中的节点顺序与文档顺序相反。</span><span class="sxs-lookup"><span data-stu-id="d621c-185">The nodes in the returned collection are in reverse document order.</span></span>  
  
<span data-ttu-id="d621c-186">此方法使用延迟执行。</span><span class="sxs-lookup"><span data-stu-id="d621c-186">This method uses deferred execution.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d621c-187">此方法不会在结果中返回自身。</span><span class="sxs-lookup"><span data-stu-id="d621c-187">This method will not return itself in the results.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d621c-188">下面的示例使用此方法。</span><span class="sxs-lookup"><span data-stu-id="d621c-188">The following example uses this method.</span></span>  
  
```csharp  
XElement xmlTree = new XElement("Root",  
    new XElement("Child",   
        new XElement("GrandChild", "content")  
    )  
);  
IEnumerable<XElement> grandChild = xmlTree.Descendants("GrandChild");  
foreach (XElement el in grandChild.Ancestors("Child"))  
    Console.WriteLine(el.Name);  
```  
  
```vb  
Dim xmlTree As XElement = _   
        <Root>  
            <Child>  
                <GrandChild>content</GrandChild>  
            </Child>  
        </Root>  
  
Dim grandChild As IEnumerable(Of XElement) = xmlTree...<GrandChild>  
For Each el In grandChild.Ancestors("Child")  
    Console.WriteLine(el.Name)  
Next  
```  
  
 <span data-ttu-id="d621c-189">该示例产生下面的输出：</span><span class="sxs-lookup"><span data-stu-id="d621c-189">This example produces the following output:</span></span>  
  
```  
Child  
```  
  
 ]]></format>
        </remarks>
        <related type="Article" href="/dotnet/standard/linq/linq-xml-overview"><span data-ttu-id="d621c-190">LINQ to XML 概述</span><span class="sxs-lookup"><span data-stu-id="d621c-190">LINQ to XML overview</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="CompareDocumentOrder">
      <MemberSignature Language="C#" Value="public static int CompareDocumentOrder (System.Xml.Linq.XNode n1, System.Xml.Linq.XNode n2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 CompareDocumentOrder(class System.Xml.Linq.XNode n1, class System.Xml.Linq.XNode n2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XNode.CompareDocumentOrder(System.Xml.Linq.XNode,System.Xml.Linq.XNode)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CompareDocumentOrder (n1 As XNode, n2 As XNode) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int CompareDocumentOrder(System::Xml::Linq::XNode ^ n1, System::Xml::Linq::XNode ^ n2);" />
      <MemberSignature Language="F#" Value="static member CompareDocumentOrder : System.Xml.Linq.XNode * System.Xml.Linq.XNode -&gt; int" Usage="System.Xml.Linq.XNode.CompareDocumentOrder (n1, n2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="n1" Type="System.Xml.Linq.XNode" />
        <Parameter Name="n2" Type="System.Xml.Linq.XNode" />
      </Parameters>
      <Docs>
        <param name="n1"><span data-ttu-id="d621c-191">要比较的第一个 <see cref="T:System.Xml.Linq.XNode" />。</span><span class="sxs-lookup"><span data-stu-id="d621c-191">First <see cref="T:System.Xml.Linq.XNode" /> to compare.</span></span></param>
        <param name="n2"><span data-ttu-id="d621c-192">要比较的第二个 <see cref="T:System.Xml.Linq.XNode" />。</span><span class="sxs-lookup"><span data-stu-id="d621c-192">Second <see cref="T:System.Xml.Linq.XNode" /> to compare.</span></span></param>
        <summary><span data-ttu-id="d621c-193">比较两个节点以确定其相对的 XML 文档顺序。</span><span class="sxs-lookup"><span data-stu-id="d621c-193">Compares two nodes to determine their relative XML document order.</span></span></summary>
        <returns><span data-ttu-id="d621c-194">如果节点相等，则为包含 0 的 <see langword="int" />；如果 <paramref name="n1" /> 位于 <paramref name="n2" /> 之前，则为包含 -1；如果 <paramref name="n1" /> 位于 <paramref name="n2" /> 之后，则为包含 1。</span><span class="sxs-lookup"><span data-stu-id="d621c-194">An <see langword="int" /> containing 0 if the nodes are equal; -1 if <paramref name="n1" /> is before <paramref name="n2" />; 1 if <paramref name="n1" /> is after <paramref name="n2" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d621c-195">将其子 <xref:System.Xml.Linq.XContainer> 节点存储为对象的单向链接列表 <xref:System.Xml.Linq.XNode> 。</span><span class="sxs-lookup"><span data-stu-id="d621c-195">The <xref:System.Xml.Linq.XContainer> stores its child nodes as a singly-linked list of <xref:System.Xml.Linq.XNode> objects.</span></span> <span data-ttu-id="d621c-196">这意味着 <xref:System.Xml.Linq.XNode.CompareDocumentOrder%2A> 方法必须遍历所比较的两个节点的上级，直到它找到公共父级。</span><span class="sxs-lookup"><span data-stu-id="d621c-196">This means that the <xref:System.Xml.Linq.XNode.CompareDocumentOrder%2A> method must traverse the ancestors of the two nodes being compared until it finds the common parent.</span></span> <span data-ttu-id="d621c-197">然后，它必须遍历公共父节点的列表，以确定所比较的两个节点的顺序。</span><span class="sxs-lookup"><span data-stu-id="d621c-197">Then it must traverse the list of the common parent's child nodes to determine the order of the two nodes being compared.</span></span> <span data-ttu-id="d621c-198">因此，使用此方法可能会影响性能。</span><span class="sxs-lookup"><span data-stu-id="d621c-198">Therefore, using this method might affect your performance.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d621c-199">下面的示例使用此方法。</span><span class="sxs-lookup"><span data-stu-id="d621c-199">The following example uses this method.</span></span>  
  
```csharp  
XElement xmlTree = new XElement("Root",  
    new XElement("Child1",  
        new XElement("GrandChild1", 1),  
        new XElement("GrandChild2", 2),  
        new XElement("GrandChild3", 3)  
    ),  
    new XElement("Child2",  
        new XElement("GrandChild4", 4),  
        new XElement("GrandChild5", 5),  
        new XElement("GrandChild6", 6)  
    )  
);  
XElement el1 = xmlTree.Descendants("GrandChild2").First();  
XElement el2 = xmlTree.Descendants("GrandChild6").First();  
if (XElement.CompareDocumentOrder(el1, el2) == 0)  
    Console.WriteLine("Compared elements are the same element");  
else if (XElement.CompareDocumentOrder(el1, el2) > 0)  
    Console.WriteLine("el1 is after el2");  
else  
    Console.WriteLine("el1 is before el2");  
```  
  
```vb  
Dim xmlTree As XElement = _   
        <Root>  
            <Child1>  
                <GrandChild1>1</GrandChild1>  
                <GrandChild2>2</GrandChild2>  
                <GrandChild3>3</GrandChild3>  
            </Child1>  
            <Child2>  
                <GrandChild4>4</GrandChild4>  
                <GrandChild5>5</GrandChild5>  
                <GrandChild6>6</GrandChild6>  
            </Child2>  
        </Root>  
  
Dim el1 As XElement = xmlTree...<GrandChild2>(0)  
Dim el2 As XElement = xmlTree...<GrandChild6>(0)  
  
If (XElement.CompareDocumentOrder(el1, el2) = 0) Then  
    Console.WriteLine("Compared elements are the same element")  
ElseIf (XElement.CompareDocumentOrder(el1, el2) > 0) Then  
    Console.WriteLine("el1 is after el2")  
Else  
    Console.WriteLine("el1 is before el2")  
End If  
```  
  
 <span data-ttu-id="d621c-200">该示例产生下面的输出：</span><span class="sxs-lookup"><span data-stu-id="d621c-200">This example produces the following output:</span></span>  
  
```  
el1 is before el2  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="d621c-201">两个节点不共用一个公共上级。</span><span class="sxs-lookup"><span data-stu-id="d621c-201">The two nodes do not share a common ancestor.</span></span></exception>
        <related type="Article" href="/dotnet/standard/linq/linq-xml-overview"><span data-ttu-id="d621c-202">LINQ to XML 概述</span><span class="sxs-lookup"><span data-stu-id="d621c-202">LINQ to XML overview</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateReader">
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="d621c-203">创建此节点的 <see cref="T:System.Xml.XmlReader" />。</span><span class="sxs-lookup"><span data-stu-id="d621c-203">Creates an <see cref="T:System.Xml.XmlReader" /> for this node.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateReader">
      <MemberSignature Language="C#" Value="public System.Xml.XmlReader CreateReader ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Xml.XmlReader CreateReader() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XNode.CreateReader" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateReader () As XmlReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Xml::XmlReader ^ CreateReader();" />
      <MemberSignature Language="F#" Value="member this.CreateReader : unit -&gt; System.Xml.XmlReader" Usage="xNode.CreateReader " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlReader</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="d621c-204">创建此节点的 <see cref="T:System.Xml.XmlReader" />。</span><span class="sxs-lookup"><span data-stu-id="d621c-204">Creates an <see cref="T:System.Xml.XmlReader" /> for this node.</span></span></summary>
        <returns><span data-ttu-id="d621c-205">可用于读取此节点及其子代的 <see cref="T:System.Xml.XmlReader" />。</span><span class="sxs-lookup"><span data-stu-id="d621c-205">An <see cref="T:System.Xml.XmlReader" /> that can be used to read this node and its descendants.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d621c-206">当必须提供其他组件时，通常使用此方法 <xref:System.Xml.XmlReader> 。</span><span class="sxs-lookup"><span data-stu-id="d621c-206">You typically use this method when you have to supply another component with an <xref:System.Xml.XmlReader>.</span></span> <span data-ttu-id="d621c-207">例如，您可以 <xref:System.Xml.XmlReader> 从树中创建 [!INCLUDE[sqltecxlinq](~/includes/sqltecxlinq-md.md)] ，然后将该读取器传递到 <xref:System.Xml.XmlDocument.Load%2A> 。</span><span class="sxs-lookup"><span data-stu-id="d621c-207">For example, you can create an <xref:System.Xml.XmlReader> from a [!INCLUDE[sqltecxlinq](~/includes/sqltecxlinq-md.md)] tree, and then pass that reader to <xref:System.Xml.XmlDocument.Load%2A>.</span></span>  
  
 <span data-ttu-id="d621c-208">返回的所有读取器 <xref:System.Xml.XmlReader.Create%2A> 均为规范化读取器。</span><span class="sxs-lookup"><span data-stu-id="d621c-208">All of the readers returned by <xref:System.Xml.XmlReader.Create%2A> are normalizing readers.</span></span> <span data-ttu-id="d621c-209">它们始终执行分行规范化和属性的完全规范化。</span><span class="sxs-lookup"><span data-stu-id="d621c-209">They always perform line break normalization and full normalization of attributes.</span></span> <span data-ttu-id="d621c-210">相反，返回的 <xref:System.Xml.XmlReader> <xref:System.Xml.Linq.XNode.CreateReader%2A> 不是规范化读取器。</span><span class="sxs-lookup"><span data-stu-id="d621c-210">In contrast, the <xref:System.Xml.XmlReader> returned by <xref:System.Xml.Linq.XNode.CreateReader%2A> is not a normalizing reader.</span></span> <span data-ttu-id="d621c-211">它不会转换任何空白。</span><span class="sxs-lookup"><span data-stu-id="d621c-211">It does not transform any white space.</span></span> <span data-ttu-id="d621c-212">它还按它们的添加顺序返回属性，而不是按属性名称顺序返回。</span><span class="sxs-lookup"><span data-stu-id="d621c-212">It also returns attributes in the order that they were added, not in attribute name order.</span></span>  
  
 [!INCLUDE[sqltecxlinq](~/includes/sqltecxlinq-md.md)] <span data-ttu-id="d621c-213">不保留有关特性是否为默认特性的信息。</span><span class="sxs-lookup"><span data-stu-id="d621c-213">does not keep information about whether attributes are default attributes.</span></span> <span data-ttu-id="d621c-214"><xref:System.Xml.XmlReader.IsDefault%2A> 无论是否从默认值填充属性，都将始终返回 false。</span><span class="sxs-lookup"><span data-stu-id="d621c-214"><xref:System.Xml.XmlReader.IsDefault%2A> will always return false regardless of whether the attribute was populated from a default value or not.</span></span>  
  
 <span data-ttu-id="d621c-215">`PUBLIC`上的和 `SYSTEM` 伪特性 <xref:System.Xml.Linq.XDocumentType> 无法通过 <xref:System.Xml.XmlReader.MoveToAttribute%2A?displayProperty=nameWithType> 方法获取。</span><span class="sxs-lookup"><span data-stu-id="d621c-215">The `PUBLIC` and `SYSTEM` pseudo attributes on <xref:System.Xml.Linq.XDocumentType> are not available through the <xref:System.Xml.XmlReader.MoveToAttribute%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="d621c-216">仅可通过将属性的 <xref:System.Xml.XmlReader.GetAttribute%2A?displayProperty=nameWithType> 限定名称作为参数的方法使用。</span><span class="sxs-lookup"><span data-stu-id="d621c-216">They are only available through the <xref:System.Xml.XmlReader.GetAttribute%2A?displayProperty=nameWithType> method that takes the qualified name of the attribute as a parameter.</span></span> <span data-ttu-id="d621c-217">如果必须检索 `PUBLIC` 或 `SYSTEM` 特性，则应使用 <xref:System.Xml.XmlReader.GetAttribute%2A?displayProperty=nameWithType> 方法。</span><span class="sxs-lookup"><span data-stu-id="d621c-217">If you have to retrieve the `PUBLIC` or `SYSTEM` attributes, you should use the <xref:System.Xml.XmlReader.GetAttribute%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="d621c-218">Base64 和 BinHex 数据不受支持。</span><span class="sxs-lookup"><span data-stu-id="d621c-218">Base64 and BinHex data are not supported.</span></span> <span data-ttu-id="d621c-219">如果尝试检索这些类型的数据 (例如，通过调用 <xref:System.Xml.XmlReader.ReadElementContentAsBase64%2A>) ，读取器将引发 <xref:System.NotSupportedException> 。</span><span class="sxs-lookup"><span data-stu-id="d621c-219">If you attempt to retrieve these types of data (for example, by calling <xref:System.Xml.XmlReader.ReadElementContentAsBase64%2A>), the reader will throw <xref:System.NotSupportedException>.</span></span>  
  
 <span data-ttu-id="d621c-220">`xml`读取器不会显示声明。</span><span class="sxs-lookup"><span data-stu-id="d621c-220">The `xml` declaration is not surfaced by the reader.</span></span> <span data-ttu-id="d621c-221">在读取时，不会遇到类型为的节点 <xref:System.Xml.XmlNodeType.XmlDeclaration> 。</span><span class="sxs-lookup"><span data-stu-id="d621c-221">While reading, you will not encounter a node of type <xref:System.Xml.XmlNodeType.XmlDeclaration>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d621c-222">下面的示例创建一个 XML 树， <xref:System.Xml.XmlReader> 使用方法创建一个， <xref:System.Xml.Linq.XNode.CreateReader%2A> 并 <xref:System.Xml.XmlDocument> 使用读取器创建一个。</span><span class="sxs-lookup"><span data-stu-id="d621c-222">The following example creates an XML tree, creates an <xref:System.Xml.XmlReader> by using the <xref:System.Xml.Linq.XNode.CreateReader%2A> method, and creates an <xref:System.Xml.XmlDocument> by using the reader.</span></span>  
  
```csharp  
XDocument xmlTree = new XDocument(  
    new XElement("Root",  
        new XAttribute("Att1", "Attribute Content"),  
        new XElement("Child1", 1),  
        new XElement("Child2", 2)  
    )  
);  
XmlReader reader = xmlTree.CreateReader();  
reader.MoveToContent();  
XmlDocument doc = new XmlDocument();  
XmlNode cd = doc.ReadNode(reader);  
doc.AppendChild(cd);  
Console.WriteLine(doc.OuterXml);  
```  
  
```vb  
Dim xmlTree As XDocument =  _   
    <?xml version="1.0" encoding="utf-8" standalone="yes"?>  
        <Root Att1="Attribute Content">  
            <Child1>1</Child1>  
            <Child2>2</Child2>  
        </Root>  
Dim reader As XmlReader = xmlTree.CreateReader()  
reader.MoveToContent()  
Dim doc As XmlDocument = New XmlDocument()  
Dim cd As XmlNode = doc.ReadNode(reader)  
doc.AppendChild(cd)  
Console.WriteLine(doc.OuterXml)  
```  
  
 <span data-ttu-id="d621c-223">该示例产生下面的输出：</span><span class="sxs-lookup"><span data-stu-id="d621c-223">This example produces the following output:</span></span>  
  
```xml  
<Root Att1="Attribute Content"><Child1>1</Child1><Child2>2</Child2></Root>  
```  
  
 <span data-ttu-id="d621c-224">此方法的另一个用途是执行 XSLT 转换。</span><span class="sxs-lookup"><span data-stu-id="d621c-224">Another use for this method is to do an XSLT transformation.</span></span> <span data-ttu-id="d621c-225">可以创建 XML 树，从 XML 树创建 <xref:System.Xml.XmlReader>，创建新文档，然后创建 <xref:System.Xml.XmlWriter>，以写入新文档。</span><span class="sxs-lookup"><span data-stu-id="d621c-225">You can create an XML tree, create an <xref:System.Xml.XmlReader> from the XML tree, create a new document, and create an <xref:System.Xml.XmlWriter> that will write into the new document.</span></span> <span data-ttu-id="d621c-226">然后，您可以调用 XSLT 转换，并可以将 <xref:System.Xml.XmlReader> 和 <xref:System.Xml.XmlWriter> 传递到转换中。</span><span class="sxs-lookup"><span data-stu-id="d621c-226">Then, you can invoke the XSLT transformation, passing the <xref:System.Xml.XmlReader> and <xref:System.Xml.XmlWriter> to the transformation.</span></span> <span data-ttu-id="d621c-227">在转换成功完成后，使用转换的结果，填充新的 XML 树。</span><span class="sxs-lookup"><span data-stu-id="d621c-227">After the transformation successfully completes, the new XML tree is populated with the results of the transform.</span></span>  
  
```csharp  
string xslMarkup = @"<?xml version='1.0'?>  
<xsl:stylesheet xmlns:xsl='http://www.w3.org/1999/XSL/Transform' version='1.0'>  
    <xsl:template match='/Parent'>  
        <Root>  
            <C1>  
            <xsl:value-of select='Child1'/>  
            </C1>  
            <C2>  
            <xsl:value-of select='Child2'/>  
            </C2>  
        </Root>  
    </xsl:template>  
</xsl:stylesheet>";  
  
XDocument xmlTree = new XDocument(  
    new XElement("Parent",  
        new XElement("Child1", "Child1 data"),  
        new XElement("Child2", "Child2 data")  
    )  
);  
  
XDocument newTree = new XDocument();  
using (XmlWriter writer = newTree.CreateWriter()) {  
    // Load the style sheet.  
    XslCompiledTransform xslt = new XslCompiledTransform();  
    xslt.Load(XmlReader.Create(new StringReader(xslMarkup)));  
  
    // Execute the transform and output the results to a writer.  
    xslt.Transform(xmlTree.CreateReader(), writer);  
}  
  
Console.WriteLine(newTree);  
```  
  
```vb  
Dim xslMarkup As XDocument = _   
    <?xml version='1.0'?>  
    <xsl:stylesheet xmlns:xsl='http://www.w3.org/1999/XSL/Transform' version='1.0'>  
        <xsl:template match='/Parent'>  
            <Root>  
                <C1>  
                    <xsl:value-of select='Child1'/>  
                </C1>  
                <C2>  
                    <xsl:value-of select='Child2'/>  
                </C2>  
            </Root>  
        </xsl:template>  
    </xsl:stylesheet>  
  
Dim xmlTree As XElement = _   
        <Parent>  
            <Child1>Child1 data</Child1>  
            <Child2>Child2 data</Child2>  
        </Parent>  
  
Dim newTree As XDocument = New XDocument()  
  
Using writer As XmlWriter = newTree.CreateWriter()  
    ' Load the style sheet.  
    Dim xslt As XslCompiledTransform = _  
        New XslCompiledTransform()  
    xslt.Load(xslMarkup.CreateReader())  
  
    ' Execute the transform and output the results to a writer.  
    xslt.Transform(xmlTree.CreateReader(), writer)  
End Using  
  
Console.WriteLine(newTree)  
```  
  
 <span data-ttu-id="d621c-228">该示例产生下面的输出：</span><span class="sxs-lookup"><span data-stu-id="d621c-228">This example produces the following output:</span></span>  
  
```xml  
<Root>  
  <C1>Child1 data</C1>  
  <C2>Child2 data</C2>  
</Root>  
```  
  
 ]]></format>
        </remarks>
        <related type="Article" href="/dotnet/standard/linq/linq-xml-overview"><span data-ttu-id="d621c-229">LINQ to XML 概述</span><span class="sxs-lookup"><span data-stu-id="d621c-229">LINQ to XML overview</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="CreateReader">
      <MemberSignature Language="C#" Value="public System.Xml.XmlReader CreateReader (System.Xml.Linq.ReaderOptions readerOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Xml.XmlReader CreateReader(valuetype System.Xml.Linq.ReaderOptions readerOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XNode.CreateReader(System.Xml.Linq.ReaderOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateReader (readerOptions As ReaderOptions) As XmlReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Xml::XmlReader ^ CreateReader(System::Xml::Linq::ReaderOptions readerOptions);" />
      <MemberSignature Language="F#" Value="member this.CreateReader : System.Xml.Linq.ReaderOptions -&gt; System.Xml.XmlReader" Usage="xNode.CreateReader readerOptions" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlReader</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="readerOptions" Type="System.Xml.Linq.ReaderOptions" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="readerOptions"><span data-ttu-id="d621c-230">指定是否省略重复的命名空间的 <see cref="T:System.Xml.Linq.ReaderOptions" /> 对象。</span><span class="sxs-lookup"><span data-stu-id="d621c-230">A <see cref="T:System.Xml.Linq.ReaderOptions" /> object that specifies whether to omit duplicate namespaces.</span></span></param>
        <summary><span data-ttu-id="d621c-231">使用 <paramref name="readerOptions" /> 参数指定的选项创建 <see cref="T:System.Xml.XmlReader" />。</span><span class="sxs-lookup"><span data-stu-id="d621c-231">Creates an <see cref="T:System.Xml.XmlReader" /> with the options specified by the <paramref name="readerOptions" /> parameter.</span></span></summary>
        <returns><span data-ttu-id="d621c-232">一个 <see cref="T:System.Xml.XmlReader" /> 对象。</span><span class="sxs-lookup"><span data-stu-id="d621c-232">An <see cref="T:System.Xml.XmlReader" /> object.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DeepEquals">
      <MemberSignature Language="C#" Value="public static bool DeepEquals (System.Xml.Linq.XNode n1, System.Xml.Linq.XNode n2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool DeepEquals(class System.Xml.Linq.XNode n1, class System.Xml.Linq.XNode n2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XNode.DeepEquals(System.Xml.Linq.XNode,System.Xml.Linq.XNode)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function DeepEquals (n1 As XNode, n2 As XNode) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool DeepEquals(System::Xml::Linq::XNode ^ n1, System::Xml::Linq::XNode ^ n2);" />
      <MemberSignature Language="F#" Value="static member DeepEquals : System.Xml.Linq.XNode * System.Xml.Linq.XNode -&gt; bool" Usage="System.Xml.Linq.XNode.DeepEquals (n1, n2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="n1" Type="System.Xml.Linq.XNode" />
        <Parameter Name="n2" Type="System.Xml.Linq.XNode" />
      </Parameters>
      <Docs>
        <param name="n1"><span data-ttu-id="d621c-233">要比较的第一个 <see cref="T:System.Xml.Linq.XNode" />。</span><span class="sxs-lookup"><span data-stu-id="d621c-233">The first <see cref="T:System.Xml.Linq.XNode" /> to compare.</span></span></param>
        <param name="n2"><span data-ttu-id="d621c-234">要比较的第二个 <see cref="T:System.Xml.Linq.XNode" />。</span><span class="sxs-lookup"><span data-stu-id="d621c-234">The second <see cref="T:System.Xml.Linq.XNode" /> to compare.</span></span></param>
        <summary><span data-ttu-id="d621c-235">比较两个节点的值，包括所有子代节点的值。</span><span class="sxs-lookup"><span data-stu-id="d621c-235">Compares the values of two nodes, including the values of all descendant nodes.</span></span></summary>
        <returns><span data-ttu-id="d621c-236">如果节点相等，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="d621c-236"><see langword="true" /> if the nodes are equal; otherwise <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d621c-237">以下条件确定两个节点是否相等：</span><span class="sxs-lookup"><span data-stu-id="d621c-237">The following criteria determine whether two nodes are equal:</span></span>  
  
-   <span data-ttu-id="d621c-238">`null`节点与另一个节点相等， `null` 但不等于非 `null` 节点。</span><span class="sxs-lookup"><span data-stu-id="d621c-238">A `null` node is equal to another `null` node but unequal to a non-`null` node.</span></span>  
  
-   <span data-ttu-id="d621c-239"><xref:System.Xml.Linq.XNode>不同类型的两个对象从不相等。</span><span class="sxs-lookup"><span data-stu-id="d621c-239">Two <xref:System.Xml.Linq.XNode> objects of different types are never equal.</span></span>  
  
-   <span data-ttu-id="d621c-240">如果两个 <xref:System.Xml.Linq.XText> 节点包含相同的文本，则这两个节点相等。</span><span class="sxs-lookup"><span data-stu-id="d621c-240">Two <xref:System.Xml.Linq.XText> nodes are equal if they contain the same text.</span></span>  
  
-   <span data-ttu-id="d621c-241">如果两个 <xref:System.Xml.Linq.XElement> 节点具有相同的标记名称、同一组具有相同值的属性，并且 (忽略注释和处理指令) 包含相等内容节点的两个相等长度序列，则这两个节点相等。</span><span class="sxs-lookup"><span data-stu-id="d621c-241">Two <xref:System.Xml.Linq.XElement> nodes are equal if they have the same tag name, the same set of attributes with the same values, and (ignoring comments and processing instructions) contain two equal length sequences of equal content nodes.</span></span>  
  
-   <span data-ttu-id="d621c-242">如果两个节点的根节点相等，则这两个 <xref:System.Xml.Linq.XDocument> 节点相等。</span><span class="sxs-lookup"><span data-stu-id="d621c-242">Two <xref:System.Xml.Linq.XDocument> nodes are equal if their root nodes are equal.</span></span>  
  
-   <span data-ttu-id="d621c-243">如果两个 <xref:System.Xml.Linq.XComment> 节点包含相同的注释文本，则这两个节点相等。</span><span class="sxs-lookup"><span data-stu-id="d621c-243">Two <xref:System.Xml.Linq.XComment> nodes are equal if they contain the same comment text.</span></span>  
  
-   <span data-ttu-id="d621c-244">如果两个 <xref:System.Xml.Linq.XProcessingInstruction> 节点具有相同的目标和数据，则这两个节点相等。</span><span class="sxs-lookup"><span data-stu-id="d621c-244">Two <xref:System.Xml.Linq.XProcessingInstruction> nodes are equal if they have the same target and data.</span></span>  
  
-   <span data-ttu-id="d621c-245">如果两个 <xref:System.Xml.Linq.XDocumentType> 节点具有相同的名称、公用 ID、系统 ID 和内部子集，则这两个节点相等。</span><span class="sxs-lookup"><span data-stu-id="d621c-245">Two <xref:System.Xml.Linq.XDocumentType> nodes are equal if the have the same name, public ID, system ID, and internal subset.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d621c-246">下面的示例使用此方法来比较两个 XML 树。</span><span class="sxs-lookup"><span data-stu-id="d621c-246">The following example uses this method to compare two XML trees.</span></span>  
  
```csharp  
XElement xmlTree1 = new XElement("Root",  
    new XAttribute("Att1", 1),  
    new XAttribute("Att2", 2),  
    new XElement("Child1", 1),  
    new XElement("Child2", "some content")  
);  
XElement xmlTree2 = new XElement("Root",  
    new XAttribute("Att1", 1),  
    new XAttribute("Att2", 2),  
    new XElement("Child1", 1),  
    new XElement("Child2", "some content")  
);  
Console.WriteLine(XNode.DeepEquals(xmlTree1, xmlTree2));  
```  
  
```vb  
Dim xmlTree1 As XElement = _   
        <Root Att1="1" Att2="2">  
            <Child1>1</Child1>  
            <Child2>some content</Child2>  
        </Root>  
  
Dim xmlTree2 As XElement = _   
        <Root Att1="1" Att2="2">  
            <Child1>1</Child1>  
            <Child2>some content</Child2>  
        </Root>  
  
Console.WriteLine(XNode.DeepEquals(xmlTree1, xmlTree2))  
```  
  
 <span data-ttu-id="d621c-247">该示例产生下面的输出：</span><span class="sxs-lookup"><span data-stu-id="d621c-247">This example produces the following output:</span></span>  
  
```  
True  
```  
  
 ]]></format>
        </remarks>
        <related type="Article" href="/dotnet/standard/linq/linq-xml-overview"><span data-ttu-id="d621c-248">LINQ to XML 概述</span><span class="sxs-lookup"><span data-stu-id="d621c-248">LINQ to XML overview</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="DocumentOrderComparer">
      <MemberSignature Language="C#" Value="public static System.Xml.Linq.XNodeDocumentOrderComparer DocumentOrderComparer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Xml.Linq.XNodeDocumentOrderComparer DocumentOrderComparer" />
      <MemberSignature Language="DocId" Value="P:System.Xml.Linq.XNode.DocumentOrderComparer" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property DocumentOrderComparer As XNodeDocumentOrderComparer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Xml::Linq::XNodeDocumentOrderComparer ^ DocumentOrderComparer { System::Xml::Linq::XNodeDocumentOrderComparer ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DocumentOrderComparer : System.Xml.Linq.XNodeDocumentOrderComparer" Usage="System.Xml.Linq.XNode.DocumentOrderComparer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Linq.XNodeDocumentOrderComparer</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="d621c-249">获取可以比较两个节点相对位置的比较器。</span><span class="sxs-lookup"><span data-stu-id="d621c-249">Gets a comparer that can compare the relative position of two nodes.</span></span></summary>
        <value><span data-ttu-id="d621c-250">一个 <see cref="T:System.Xml.Linq.XNodeDocumentOrderComparer" />，可以比较两个节点的相对位置。</span><span class="sxs-lookup"><span data-stu-id="d621c-250">An <see cref="T:System.Xml.Linq.XNodeDocumentOrderComparer" /> that can compare the relative position of two nodes.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d621c-251">此属性主要用于实现 <xref:System.Xml.Linq.Extensions.InDocumentOrder%2A> 扩展方法。</span><span class="sxs-lookup"><span data-stu-id="d621c-251">This property is primarily used internally for implementing the <xref:System.Xml.Linq.Extensions.InDocumentOrder%2A> extension method.</span></span> <span data-ttu-id="d621c-252">推荐的方法是使用该扩展方法，而不是直接使用此属性。</span><span class="sxs-lookup"><span data-stu-id="d621c-252">The recommended approach is to use that extension method instead of using this property directly.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d621c-253">下面的示例创建一个包含某些元素的 XML 树。</span><span class="sxs-lookup"><span data-stu-id="d621c-253">The following example creates an XML tree with some elements.</span></span> <span data-ttu-id="d621c-254">然后，它将创建一个 <xref:System.Collections.Generic.List%601> <xref:System.Xml.Linq.XNode> ，它从 XML 树中随机包含某些元素。</span><span class="sxs-lookup"><span data-stu-id="d621c-254">It then creates a <xref:System.Collections.Generic.List%601> of <xref:System.Xml.Linq.XNode> that contains some elements from the XML tree at random.</span></span> <span data-ttu-id="d621c-255">它会对列表进行排序，使用此属性检索 <xref:System.Xml.Linq.XNodeDocumentOrderComparer> 实现 <xref:System.Collections.IComparer?displayProperty=nameWithType> 和 <xref:System.Collections.Generic.IComparer%601?displayProperty=nameWithType> 接口的。</span><span class="sxs-lookup"><span data-stu-id="d621c-255">It sorts the list, using this property to retrieve a <xref:System.Xml.Linq.XNodeDocumentOrderComparer>, which implements the <xref:System.Collections.IComparer?displayProperty=nameWithType> and <xref:System.Collections.Generic.IComparer%601?displayProperty=nameWithType> interfaces.</span></span>  
  
```csharp  
XElement xmlTree = new XElement("Root",  
    new XElement("Child1", 1),  
    new XElement("Child2", 2),  
    new XElement("Child3", 3),  
    new XElement("Child4", 4),  
    new XElement("Child5", 5)  
);  
  
List<XNode> nodeList = new List<XNode>();  
nodeList.Add(xmlTree.Element("Child5"));  
nodeList.Add(xmlTree.Element("Child3"));  
nodeList.Add(xmlTree.Element("Child1"));  
  
// Sort nodes in document order.  
nodeList.Sort(XNode.DocumentOrderComparer);  
  
foreach (XElement el in nodeList)  
    Console.WriteLine(el);  
```  
  
```vb  
Dim xmlTree As XElement = _   
        <Root>  
            <Child1>1</Child1>  
            <Child2>2</Child2>  
            <Child3>3</Child3>  
            <Child4>4</Child4>  
            <Child5>5</Child5>  
        </Root>  
  
Dim nodeList As List(Of XNode) = New List(Of XNode)()  
nodeList.Add(xmlTree.Element("Child5"))  
nodeList.Add(xmlTree.Element("Child3"))  
nodeList.Add(xmlTree.Element("Child1"))  
  
' Sort nodes in document order.  
nodeList.Sort(XNode.DocumentOrderComparer)  
  
For Each el In nodeList  
    Console.WriteLine(el)  
Next  
```  
  
 <span data-ttu-id="d621c-256">该示例产生下面的输出：</span><span class="sxs-lookup"><span data-stu-id="d621c-256">This example produces the following output:</span></span>  
  
```  
<Child1>1</Child1>  
<Child3>3</Child3>  
<Child5>5</Child5>  
```  
  
 ]]></format>
        </remarks>
        <related type="Article" href="/dotnet/standard/linq/linq-xml-overview"><span data-ttu-id="d621c-257">LINQ to XML 概述</span><span class="sxs-lookup"><span data-stu-id="d621c-257">LINQ to XML overview</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="ElementsAfterSelf">
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="d621c-258">按文档顺序返回此节点后的同级元素集合。</span><span class="sxs-lookup"><span data-stu-id="d621c-258">Returns a collection of the sibling elements after this node, in document order.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d621c-259">此方法使用延迟执行。</span><span class="sxs-lookup"><span data-stu-id="d621c-259">This method uses deferred execution.</span></span>  
  
 ]]></format>
        </remarks>
        <related type="Article" href="/dotnet/standard/linq/linq-xml-overview"><span data-ttu-id="d621c-260">LINQ to XML 概述</span><span class="sxs-lookup"><span data-stu-id="d621c-260">LINQ to XML overview</span></span></related>
      </Docs>
    </MemberGroup>
    <Member MemberName="ElementsAfterSelf">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.Xml.Linq.XElement&gt; ElementsAfterSelf ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;class System.Xml.Linq.XElement&gt; ElementsAfterSelf() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XNode.ElementsAfterSelf" />
      <MemberSignature Language="VB.NET" Value="Public Function ElementsAfterSelf () As IEnumerable(Of XElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IEnumerable&lt;System::Xml::Linq::XElement ^&gt; ^ ElementsAfterSelf();" />
      <MemberSignature Language="F#" Value="member this.ElementsAfterSelf : unit -&gt; seq&lt;System.Xml.Linq.XElement&gt;" Usage="xNode.ElementsAfterSelf " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Xml.Linq.XElement&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="d621c-261">按文档顺序返回此节点后的同级元素集合。</span><span class="sxs-lookup"><span data-stu-id="d621c-261">Returns a collection of the sibling elements after this node, in document order.</span></span></summary>
        <returns><span data-ttu-id="d621c-262">此节点后同级元素（按文档顺序排列）的 <see cref="T:System.Xml.Linq.XElement" /> 的 <see cref="T:System.Collections.Generic.IEnumerable`1" />。</span><span class="sxs-lookup"><span data-stu-id="d621c-262">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> of <see cref="T:System.Xml.Linq.XElement" /> of the sibling elements after this node, in document order.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d621c-263">此方法仅在返回的集合中包含同级。</span><span class="sxs-lookup"><span data-stu-id="d621c-263">This method only includes siblings in the returned collection.</span></span> <span data-ttu-id="d621c-264">它不包括后代。</span><span class="sxs-lookup"><span data-stu-id="d621c-264">It does not include descendants.</span></span>  
  
 <span data-ttu-id="d621c-265">此方法使用延迟执行。</span><span class="sxs-lookup"><span data-stu-id="d621c-265">This method uses deferred execution.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d621c-266">下面的示例创建一个具有一些复杂内容的元素。</span><span class="sxs-lookup"><span data-stu-id="d621c-266">The following example creates an element with some complex content.</span></span> <span data-ttu-id="d621c-267">然后，它使用此方法以文档顺序检索节点。</span><span class="sxs-lookup"><span data-stu-id="d621c-267">It then uses this method to retrieve the nodes in document order.</span></span>  
  
```csharp  
XElement xmlTree = new XElement("Root",  
    new XText("Text content."),  
    new XElement("Child1", "child1 content"),  
    new XElement("Child2", "child2 content"),  
    new XElement("Child3", "child3 content"),  
    new XText("More text content."),  
    new XElement("Child4", "child4 content"),  
    new XElement("Child5", "child5 content")  
);  
XElement child = xmlTree.Element("Child3");  
IEnumerable<XElement> elements = child.ElementsAfterSelf();  
foreach (XElement el in elements)  
    Console.WriteLine(el.Name);  
```  
  
```vb  
Dim xmlTree As XElement = _  
        <Root>Text content.  
            <Child1>child1 content</Child1>  
            <Child2>child2 content</Child2>  
            <Child3>child3 content</Child3>More text content.  
            <Child4>child4 content</Child4>  
            <Child5>child5 content</Child5>  
        </Root>  
  
Dim child As XElement = xmlTree.<Child3>(0)  
Dim elements As IEnumerable(Of XElement) = child.ElementsAfterSelf()  
For Each el In elements  
    Console.WriteLine(el.Name)  
Next  
```  
  
 <span data-ttu-id="d621c-268">该示例产生下面的输出：</span><span class="sxs-lookup"><span data-stu-id="d621c-268">This example produces the following output:</span></span>  
  
```  
Child4  
Child5  
```  
  
 ]]></format>
        </remarks>
        <related type="Article" href="/dotnet/standard/linq/linq-xml-overview"><span data-ttu-id="d621c-269">LINQ to XML 概述</span><span class="sxs-lookup"><span data-stu-id="d621c-269">LINQ to XML overview</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="ElementsAfterSelf">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.Xml.Linq.XElement&gt; ElementsAfterSelf (System.Xml.Linq.XName name);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;class System.Xml.Linq.XElement&gt; ElementsAfterSelf(class System.Xml.Linq.XName name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XNode.ElementsAfterSelf(System.Xml.Linq.XName)" />
      <MemberSignature Language="VB.NET" Value="Public Function ElementsAfterSelf (name As XName) As IEnumerable(Of XElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IEnumerable&lt;System::Xml::Linq::XElement ^&gt; ^ ElementsAfterSelf(System::Xml::Linq::XName ^ name);" />
      <MemberSignature Language="F#" Value="member this.ElementsAfterSelf : System.Xml.Linq.XName -&gt; seq&lt;System.Xml.Linq.XElement&gt;" Usage="xNode.ElementsAfterSelf name" />
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.Xml.Linq.XElement&gt; ElementsAfterSelf (System.Xml.Linq.XName? name);" FrameworkAlternate="net-5.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Xml.Linq.XElement&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Xml.Linq.XName" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="d621c-270">要匹配的 <see cref="T:System.Xml.Linq.XName" />。</span><span class="sxs-lookup"><span data-stu-id="d621c-270">The <see cref="T:System.Xml.Linq.XName" /> to match.</span></span></param>
        <summary><span data-ttu-id="d621c-271">按文档顺序返回此节点后经过筛选的同级元素的集合。</span><span class="sxs-lookup"><span data-stu-id="d621c-271">Returns a filtered collection of the sibling elements after this node, in document order.</span></span> <span data-ttu-id="d621c-272">集合中仅包括具有匹配 <see cref="T:System.Xml.Linq.XName" /> 的元素。</span><span class="sxs-lookup"><span data-stu-id="d621c-272">Only elements that have a matching <see cref="T:System.Xml.Linq.XName" /> are included in the collection.</span></span></summary>
        <returns><span data-ttu-id="d621c-273">此节点后同级元素（按文档顺序排列）的 <see cref="T:System.Xml.Linq.XElement" /> 的 <see cref="T:System.Collections.Generic.IEnumerable`1" />。</span><span class="sxs-lookup"><span data-stu-id="d621c-273">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> of <see cref="T:System.Xml.Linq.XElement" /> of the sibling elements after this node, in document order.</span></span> <span data-ttu-id="d621c-274">集合中仅包括具有匹配 <see cref="T:System.Xml.Linq.XName" /> 的元素。</span><span class="sxs-lookup"><span data-stu-id="d621c-274">Only elements that have a matching <see cref="T:System.Xml.Linq.XName" /> are included in the collection.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d621c-275">此方法仅在返回的集合中包含同级。</span><span class="sxs-lookup"><span data-stu-id="d621c-275">This method only includes siblings in the returned collection.</span></span> <span data-ttu-id="d621c-276">它不包括后代。</span><span class="sxs-lookup"><span data-stu-id="d621c-276">It does not include descendants.</span></span>  
  
 <span data-ttu-id="d621c-277">此方法使用延迟执行。</span><span class="sxs-lookup"><span data-stu-id="d621c-277">This method uses deferred execution.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d621c-278">下面的示例创建一个具有一些复杂内容的元素。</span><span class="sxs-lookup"><span data-stu-id="d621c-278">The following example creates an element with some complex content.</span></span> <span data-ttu-id="d621c-279">然后，它使用此方法按文档顺序检索同级元素。</span><span class="sxs-lookup"><span data-stu-id="d621c-279">It then uses this method to retrieve the sibling elements, in document order.</span></span>  
  
```csharp  
XElement xmlTree = new XElement("Root",  
    new XText("Text content."),  
    new XElement("Child1", "child1 content"),  
    new XElement("Child2", "child2 content"),  
    new XElement("Child3", "child3 content"),  
    new XText("More text content."),  
    new XElement("Child4", "child4 content"),  
    new XElement("Child5", "child5 content")  
);  
XElement child = xmlTree.Element("Child3");  
IEnumerable<XElement> elements = child.ElementsAfterSelf("Child4");  
foreach (XElement el in elements)  
    Console.WriteLine(el.Name);  
```  
  
```vb  
Dim xmlTree As XElement = _   
        <Root>Text content.  
            <Child1>child1 content</Child1>  
            <Child2>child2 content</Child2>  
            <Child3>child3 content</Child3>More text content.  
            <Child4>child4 content</Child4>  
            <Child5>child5 content</Child5>  
        </Root>  
  
Dim child As XElement = xmlTree.<Child3>(0)  
Dim elements As IEnumerable(Of XElement) = child.ElementsAfterSelf("Child4")  
  
For Each el In elements  
    Console.WriteLine(el.Name)  
Next  
```  
  
 <span data-ttu-id="d621c-280">该示例产生下面的输出：</span><span class="sxs-lookup"><span data-stu-id="d621c-280">This example produces the following output:</span></span>  
  
```  
Child4  
```  
  
 ]]></format>
        </remarks>
        <related type="Article" href="/dotnet/standard/linq/linq-xml-overview"><span data-ttu-id="d621c-281">LINQ to XML 概述</span><span class="sxs-lookup"><span data-stu-id="d621c-281">LINQ to XML overview</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="ElementsBeforeSelf">
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="d621c-282">按文档顺序返回此节点前的同级元素集合。</span><span class="sxs-lookup"><span data-stu-id="d621c-282">Returns a collection of the sibling elements before this node, in document order.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d621c-283">此方法使用延迟执行。</span><span class="sxs-lookup"><span data-stu-id="d621c-283">This method uses deferred execution.</span></span>  
  
 ]]></format>
        </remarks>
        <related type="Article" href="/dotnet/standard/linq/linq-xml-overview"><span data-ttu-id="d621c-284">LINQ to XML 概述</span><span class="sxs-lookup"><span data-stu-id="d621c-284">LINQ to XML overview</span></span></related>
      </Docs>
    </MemberGroup>
    <Member MemberName="ElementsBeforeSelf">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.Xml.Linq.XElement&gt; ElementsBeforeSelf ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;class System.Xml.Linq.XElement&gt; ElementsBeforeSelf() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XNode.ElementsBeforeSelf" />
      <MemberSignature Language="VB.NET" Value="Public Function ElementsBeforeSelf () As IEnumerable(Of XElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IEnumerable&lt;System::Xml::Linq::XElement ^&gt; ^ ElementsBeforeSelf();" />
      <MemberSignature Language="F#" Value="member this.ElementsBeforeSelf : unit -&gt; seq&lt;System.Xml.Linq.XElement&gt;" Usage="xNode.ElementsBeforeSelf " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Xml.Linq.XElement&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="d621c-285">按文档顺序返回此节点前的同级元素集合。</span><span class="sxs-lookup"><span data-stu-id="d621c-285">Returns a collection of the sibling elements before this node, in document order.</span></span></summary>
        <returns><span data-ttu-id="d621c-286">此节点前同级元素（按文档顺序排列）的 <see cref="T:System.Xml.Linq.XElement" /> 的 <see cref="T:System.Collections.Generic.IEnumerable`1" />。</span><span class="sxs-lookup"><span data-stu-id="d621c-286">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> of <see cref="T:System.Xml.Linq.XElement" /> of the sibling elements before this node, in document order.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d621c-287">此方法仅在返回的集合中包含同级。</span><span class="sxs-lookup"><span data-stu-id="d621c-287">This method only includes siblings in the returned collection.</span></span> <span data-ttu-id="d621c-288">它不包括后代。</span><span class="sxs-lookup"><span data-stu-id="d621c-288">It does not include descendants.</span></span>  
  
 <span data-ttu-id="d621c-289">此方法使用延迟执行。</span><span class="sxs-lookup"><span data-stu-id="d621c-289">This method uses deferred execution.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d621c-290">下面的示例使用此轴方法。</span><span class="sxs-lookup"><span data-stu-id="d621c-290">The following example uses this axis method.</span></span>  
  
```csharp  
XElement xmlTree = new XElement("Root",  
    new XText("Text content."),  
    new XElement("Child1", "child1 content"),  
    new XElement("Child2", "child2 content"),  
    new XElement("Child3", "child3 content"),  
    new XText("More text content."),  
    new XElement("Child4", "child4 content"),  
    new XElement("Child5", "child5 content")  
);  
XElement child = xmlTree.Element("Child3");  
IEnumerable<XElement> elements = child.ElementsBeforeSelf();  
foreach (XElement el in elements)  
    Console.WriteLine(el.Name);  
```  
  
```vb  
Dim xmlTree As XElement = _   
        <Root>Text content.  
            <Child1>child1 content</Child1>  
            <Child2>child2 content</Child2>  
            <Child3>child3 content</Child3>More text content.  
            <Child4>child4 content</Child4>  
            <Child5>child5 content</Child5>  
        </Root>  
  
Dim child As XElement = xmlTree.<Child3>(0)  
Dim elements As IEnumerable(Of XElement) = child.ElementsBeforeSelf()  
  
For Each el In elements  
    Console.WriteLine(el.Name)  
Next  
```  
  
 <span data-ttu-id="d621c-291">该示例产生下面的输出：</span><span class="sxs-lookup"><span data-stu-id="d621c-291">This example produces the following output:</span></span>  
  
```  
Child1  
Child2  
```  
  
 ]]></format>
        </remarks>
        <related type="Article" href="/dotnet/standard/linq/linq-xml-overview"><span data-ttu-id="d621c-292">LINQ to XML 概述</span><span class="sxs-lookup"><span data-stu-id="d621c-292">LINQ to XML overview</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="ElementsBeforeSelf">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.Xml.Linq.XElement&gt; ElementsBeforeSelf (System.Xml.Linq.XName name);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;class System.Xml.Linq.XElement&gt; ElementsBeforeSelf(class System.Xml.Linq.XName name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XNode.ElementsBeforeSelf(System.Xml.Linq.XName)" />
      <MemberSignature Language="VB.NET" Value="Public Function ElementsBeforeSelf (name As XName) As IEnumerable(Of XElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IEnumerable&lt;System::Xml::Linq::XElement ^&gt; ^ ElementsBeforeSelf(System::Xml::Linq::XName ^ name);" />
      <MemberSignature Language="F#" Value="member this.ElementsBeforeSelf : System.Xml.Linq.XName -&gt; seq&lt;System.Xml.Linq.XElement&gt;" Usage="xNode.ElementsBeforeSelf name" />
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.Xml.Linq.XElement&gt; ElementsBeforeSelf (System.Xml.Linq.XName? name);" FrameworkAlternate="net-5.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Xml.Linq.XElement&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Xml.Linq.XName" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="d621c-293">要匹配的 <see cref="T:System.Xml.Linq.XName" />。</span><span class="sxs-lookup"><span data-stu-id="d621c-293">The <see cref="T:System.Xml.Linq.XName" /> to match.</span></span></param>
        <summary><span data-ttu-id="d621c-294">按文档顺序返回此节点前经过筛选的同级元素的集合。</span><span class="sxs-lookup"><span data-stu-id="d621c-294">Returns a filtered collection of the sibling elements before this node, in document order.</span></span> <span data-ttu-id="d621c-295">集合中仅包括具有匹配 <see cref="T:System.Xml.Linq.XName" /> 的元素。</span><span class="sxs-lookup"><span data-stu-id="d621c-295">Only elements that have a matching <see cref="T:System.Xml.Linq.XName" /> are included in the collection.</span></span></summary>
        <returns><span data-ttu-id="d621c-296">此节点前同级元素（按文档顺序排列）的 <see cref="T:System.Xml.Linq.XElement" /> 的 <see cref="T:System.Collections.Generic.IEnumerable`1" />。</span><span class="sxs-lookup"><span data-stu-id="d621c-296">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> of <see cref="T:System.Xml.Linq.XElement" /> of the sibling elements before this node, in document order.</span></span> <span data-ttu-id="d621c-297">集合中仅包括具有匹配 <see cref="T:System.Xml.Linq.XName" /> 的元素。</span><span class="sxs-lookup"><span data-stu-id="d621c-297">Only elements that have a matching <see cref="T:System.Xml.Linq.XName" /> are included in the collection.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d621c-298">此方法仅在返回的集合中包含同级。</span><span class="sxs-lookup"><span data-stu-id="d621c-298">This method only includes siblings in the returned collection.</span></span> <span data-ttu-id="d621c-299">它不包括后代。</span><span class="sxs-lookup"><span data-stu-id="d621c-299">It does not include descendants.</span></span>  
  
 <span data-ttu-id="d621c-300">此方法使用延迟执行。</span><span class="sxs-lookup"><span data-stu-id="d621c-300">This method uses deferred execution.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d621c-301">下面的示例使用此方法。</span><span class="sxs-lookup"><span data-stu-id="d621c-301">The following example uses this method.</span></span>  
  
```csharp  
XElement xmlTree = new XElement("Root",  
    new XText("Text content."),  
    new XElement("Child1", "child1 content"),  
    new XElement("Child2", "child2 content"),  
    new XElement("Child3", "child3 content"),  
    new XText("More text content."),  
    new XElement("Child4", "child4 content"),  
    new XElement("Child5", "child5 content")  
);  
XElement child = xmlTree.Element("Child3");  
IEnumerable<XElement> elements = child.ElementsBeforeSelf("Child2");  
foreach (XElement el in elements)  
    Console.WriteLine(el.Name);  
```  
  
```vb  
Dim xmlTree As XElement = _   
        <Root>Text content.  
            <Child1>child1 content</Child1>  
            <Child2>child2 content</Child2>  
            <Child3>child3 content</Child3>More text content.  
            <Child4>child4 content</Child4>  
            <Child5>child5 content</Child5>  
        </Root>  
  
Dim child As XElement = xmlTree.<Child3>(0)  
Dim elements As IEnumerable(Of XElement) = child.ElementsBeforeSelf("Child2")  
  
For Each el In elements  
    Console.WriteLine(el.Name)  
Next  
```  
  
 <span data-ttu-id="d621c-302">该示例产生下面的输出：</span><span class="sxs-lookup"><span data-stu-id="d621c-302">This example produces the following output:</span></span>  
  
```  
Child2  
```  
  
 ]]></format>
        </remarks>
        <related type="Article" href="/dotnet/standard/linq/linq-xml-overview"><span data-ttu-id="d621c-303">LINQ to XML 概述</span><span class="sxs-lookup"><span data-stu-id="d621c-303">LINQ to XML overview</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="EqualityComparer">
      <MemberSignature Language="C#" Value="public static System.Xml.Linq.XNodeEqualityComparer EqualityComparer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Xml.Linq.XNodeEqualityComparer EqualityComparer" />
      <MemberSignature Language="DocId" Value="P:System.Xml.Linq.XNode.EqualityComparer" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property EqualityComparer As XNodeEqualityComparer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Xml::Linq::XNodeEqualityComparer ^ EqualityComparer { System::Xml::Linq::XNodeEqualityComparer ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.EqualityComparer : System.Xml.Linq.XNodeEqualityComparer" Usage="System.Xml.Linq.XNode.EqualityComparer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Linq.XNodeEqualityComparer</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="d621c-304">获取可以比较两个节点值是否相等的比较器。</span><span class="sxs-lookup"><span data-stu-id="d621c-304">Gets a comparer that can compare two nodes for value equality.</span></span></summary>
        <value><span data-ttu-id="d621c-305">可以比较两个节点值是否相等的 <see cref="T:System.Xml.Linq.XNodeEqualityComparer" />。</span><span class="sxs-lookup"><span data-stu-id="d621c-305">A <see cref="T:System.Xml.Linq.XNodeEqualityComparer" /> that can compare two nodes for value equality.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="d621c-306">下面的示例使用此属性检索 <xref:System.Xml.Linq.XNodeEqualityComparer> 实现 <xref:System.Collections.IEqualityComparer?displayProperty=nameWithType> 和 <xref:System.Collections.Generic.IEqualityComparer%601?displayProperty=nameWithType> 接口的。</span><span class="sxs-lookup"><span data-stu-id="d621c-306">The following example uses this property to retrieve an <xref:System.Xml.Linq.XNodeEqualityComparer>, which implements the <xref:System.Collections.IEqualityComparer?displayProperty=nameWithType> and <xref:System.Collections.Generic.IEqualityComparer%601?displayProperty=nameWithType> interfaces.</span></span> <span data-ttu-id="d621c-307">它将创建一个使用此属性的字典。</span><span class="sxs-lookup"><span data-stu-id="d621c-307">It creates a dictionary that uses this property.</span></span>  
  
```csharp  
XElement xmlTree = new XElement("Root",  
    new XElement("Child1", 1),  
    new XElement("Child2", 2),  
    new XElement("Child3", 3),  
    new XElement("Child4", 4),  
    new XElement("Child5", 5)  
);  
  
Dictionary<XNode, string> nodeDictionary = new Dictionary<XNode, string>(XNode.EqualityComparer);  
nodeDictionary.Add(xmlTree.Element("Child5"), "Child 5 Information");  
nodeDictionary.Add(xmlTree.Element("Child3"), "Child 3 Information");  
nodeDictionary.Add(xmlTree.Element("Child1"), "Child 1 Information");  
  
string str = nodeDictionary[xmlTree.Element("Child3")];  
Console.WriteLine(str);  
```  
  
```vb  
Dim xmlTree As XElement = _   
        <Root>  
            <Child1>1</Child1>  
            <Child2>2</Child2>  
            <Child3>3</Child3>  
            <Child4>4</Child4>  
            <Child5>5</Child5>  
        </Root>  
  
Dim nodeDictionary As Dictionary(Of XNode, String) = New Dictionary(Of XNode, String)(XNode.EqualityComparer)  
nodeDictionary.Add(xmlTree.Element("Child5"), "Child 5 Information")  
nodeDictionary.Add(xmlTree.Element("Child3"), "Child 3 Information")  
nodeDictionary.Add(xmlTree.Element("Child1"), "Child 1 Information")  
  
Dim str As String = nodeDictionary(xmlTree.Element("Child3"))  
Console.WriteLine(str)  
```  
  
 <span data-ttu-id="d621c-308">该示例产生下面的输出：</span><span class="sxs-lookup"><span data-stu-id="d621c-308">This example produces the following output:</span></span>  
  
```  
Child 3 Information  
```  
  
 ]]></format>
        </remarks>
        <related type="Article" href="/dotnet/standard/linq/linq-xml-overview"><span data-ttu-id="d621c-309">LINQ to XML 概述</span><span class="sxs-lookup"><span data-stu-id="d621c-309">LINQ to XML overview</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="IsAfter">
      <MemberSignature Language="C#" Value="public bool IsAfter (System.Xml.Linq.XNode node);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsAfter(class System.Xml.Linq.XNode node) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XNode.IsAfter(System.Xml.Linq.XNode)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsAfter (node As XNode) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsAfter(System::Xml::Linq::XNode ^ node);" />
      <MemberSignature Language="F#" Value="member this.IsAfter : System.Xml.Linq.XNode -&gt; bool" Usage="xNode.IsAfter node" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="node" Type="System.Xml.Linq.XNode" />
      </Parameters>
      <Docs>
        <param name="node"><span data-ttu-id="d621c-310">要比较文档顺序的 <see cref="T:System.Xml.Linq.XNode" />。</span><span class="sxs-lookup"><span data-stu-id="d621c-310">The <see cref="T:System.Xml.Linq.XNode" /> to compare for document order.</span></span></param>
        <summary><span data-ttu-id="d621c-311">确定当前节点是否按文档顺序显示在指定节点之后。</span><span class="sxs-lookup"><span data-stu-id="d621c-311">Determines if the current node appears after a specified node in terms of document order.</span></span></summary>
        <returns><span data-ttu-id="d621c-312">如果此节点显示在指定节点之后，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="d621c-312"><see langword="true" /> if this node appears after the specified node; otherwise <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d621c-313">将其子 <xref:System.Xml.Linq.XContainer> 节点存储为对象的单向链接列表 <xref:System.Xml.Linq.XNode> 。</span><span class="sxs-lookup"><span data-stu-id="d621c-313">The <xref:System.Xml.Linq.XContainer> stores its child nodes as a singly-linked list of <xref:System.Xml.Linq.XNode> objects.</span></span> <span data-ttu-id="d621c-314">这意味着 <xref:System.Xml.Linq.XNode.CompareDocumentOrder%2A> 方法必须遍历所比较的两个节点的上级，直到它找到公共父级。</span><span class="sxs-lookup"><span data-stu-id="d621c-314">This means that the <xref:System.Xml.Linq.XNode.CompareDocumentOrder%2A> method must traverse the ancestors of the two nodes being compared until it finds the common parent.</span></span> <span data-ttu-id="d621c-315">然后，它必须遍历公共父节点的列表，以确定所比较的两个节点的顺序。</span><span class="sxs-lookup"><span data-stu-id="d621c-315">Then it must traverse the list of the common parent's child nodes to determine the order of the two nodes being compared.</span></span> <span data-ttu-id="d621c-316">因此，使用此方法可能会影响性能。</span><span class="sxs-lookup"><span data-stu-id="d621c-316">Therefore, using this method might affect your performance.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d621c-317">下面的示例使用此方法。</span><span class="sxs-lookup"><span data-stu-id="d621c-317">The following example uses this method.</span></span>  
  
```csharp  
XElement xmlTree = new XElement("Root",  
    new XText("Text content."),  
    new XElement("Child1", "child1 content"),  
    new XElement("Child2", "child2 content"),  
    new XElement("Child3", "child3 content"),  
    new XText("More text content."),  
    new XElement("Child4", "child4 content"),  
    new XElement("Child5", "child5 content")  
);  
XElement child3 = xmlTree.Element("Child3");  
XElement child5 = xmlTree.Element("Child5");  
if (child5.IsAfter(child3))  
    Console.WriteLine("Child5 is after Child3");  
else  
    Console.WriteLine("Child5 is not after Child3");  
```  
  
```vb  
Dim xmlTree As XElement = _   
        <Root>Text content.  
            <Child1>child1 content</Child1>  
            <Child2>child2 content</Child2>  
            <Child3>child3 content</Child3>More text content.  
            <Child4>child4 content</Child4>  
            <Child5>child5 content</Child5>  
        </Root>  
  
Dim child3 As XElement = xmlTree.<Child3>(0)  
Dim child5 As XElement = xmlTree.<Child5>(0)  
If (child5.IsAfter(child3)) Then  
    Console.WriteLine("Child5 is after Child3")  
Else  
    Console.WriteLine("Child5 is not after Child3")  
End If  
```  
  
 <span data-ttu-id="d621c-318">该示例产生下面的输出：</span><span class="sxs-lookup"><span data-stu-id="d621c-318">This example produces the following output:</span></span>  
  
```  
Child5 is after Child3  
```  
  
 ]]></format>
        </remarks>
        <related type="Article" href="/dotnet/standard/linq/linq-xml-overview"><span data-ttu-id="d621c-319">LINQ to XML 概述</span><span class="sxs-lookup"><span data-stu-id="d621c-319">LINQ to XML overview</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="IsBefore">
      <MemberSignature Language="C#" Value="public bool IsBefore (System.Xml.Linq.XNode node);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsBefore(class System.Xml.Linq.XNode node) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XNode.IsBefore(System.Xml.Linq.XNode)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsBefore (node As XNode) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsBefore(System::Xml::Linq::XNode ^ node);" />
      <MemberSignature Language="F#" Value="member this.IsBefore : System.Xml.Linq.XNode -&gt; bool" Usage="xNode.IsBefore node" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="node" Type="System.Xml.Linq.XNode" />
      </Parameters>
      <Docs>
        <param name="node"><span data-ttu-id="d621c-320">要比较文档顺序的 <see cref="T:System.Xml.Linq.XNode" />。</span><span class="sxs-lookup"><span data-stu-id="d621c-320">The <see cref="T:System.Xml.Linq.XNode" /> to compare for document order.</span></span></param>
        <summary><span data-ttu-id="d621c-321">确定当前节点是否按文档顺序显示在指定节点之前。</span><span class="sxs-lookup"><span data-stu-id="d621c-321">Determines if the current node appears before a specified node in terms of document order.</span></span></summary>
        <returns><span data-ttu-id="d621c-322">如果此节点显示在指定节点之前，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="d621c-322"><see langword="true" /> if this node appears before the specified node; otherwise <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d621c-323">将其子 <xref:System.Xml.Linq.XContainer> 节点存储为对象的单向链接列表 <xref:System.Xml.Linq.XNode> 。</span><span class="sxs-lookup"><span data-stu-id="d621c-323">The <xref:System.Xml.Linq.XContainer> stores its child nodes as a singly-linked list of <xref:System.Xml.Linq.XNode> objects.</span></span> <span data-ttu-id="d621c-324">这意味着 <xref:System.Xml.Linq.XNode.IsBefore%2A> 方法必须遍历所比较的两个节点的上级，直到它找到公共父级。</span><span class="sxs-lookup"><span data-stu-id="d621c-324">This means that the <xref:System.Xml.Linq.XNode.IsBefore%2A> method must traverse the ancestors of the two nodes being compared until it finds the common parent.</span></span> <span data-ttu-id="d621c-325">然后，它必须遍历公共父节点的列表，以确定所比较的两个节点的顺序。</span><span class="sxs-lookup"><span data-stu-id="d621c-325">Then it must traverse the list of the common parent's child nodes to determine the order of the two nodes being compared.</span></span> <span data-ttu-id="d621c-326">因此，使用此方法可能会影响性能。</span><span class="sxs-lookup"><span data-stu-id="d621c-326">Therefore, using this method might affect your performance.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d621c-327">下面的示例使用此方法。</span><span class="sxs-lookup"><span data-stu-id="d621c-327">The following example uses this method.</span></span>  
  
```csharp  
XElement xmlTree = new XElement("Root",  
    new XText("Text content."),  
    new XElement("Child1", "child1 content"),  
    new XElement("Child2", "child2 content"),  
    new XElement("Child3", "child3 content"),  
    new XText("More text content."),  
    new XElement("Child4", "child4 content"),  
    new XElement("Child5", "child5 content")  
);  
XElement child3 = xmlTree.Element("Child3");  
XElement child5 = xmlTree.Element("Child5");  
if (child5.IsBefore(child3))  
    Console.WriteLine("Child5 is before Child3");  
else  
    Console.WriteLine("Child5 is not before Child3");  
```  
  
```vb  
Dim xmlTree As XElement = _   
        <Root>Text content.  
            <Child1>child1 content</Child1>  
            <Child2>child2 content</Child2>  
            <Child3>child3 content</Child3>More text content.  
            <Child4>child4 content</Child4>  
            <Child5>child5 content</Child5>  
        </Root>  
  
Dim child3 As XElement = xmlTree.<Child3>(0)  
Dim child5 As XElement = xmlTree.<Child5>(0)  
If (child5.IsBefore(child3)) Then  
    Console.WriteLine("Child5 is before Child3")  
Else  
    Console.WriteLine("Child5 is not before Child3")  
End If  
```  
  
 <span data-ttu-id="d621c-328">该示例产生下面的输出：</span><span class="sxs-lookup"><span data-stu-id="d621c-328">This example produces the following output:</span></span>  
  
```  
Child5 is not before Child3  
```  
  
 ]]></format>
        </remarks>
        <related type="Article" href="/dotnet/standard/linq/linq-xml-overview"><span data-ttu-id="d621c-329">LINQ to XML 概述</span><span class="sxs-lookup"><span data-stu-id="d621c-329">LINQ to XML overview</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="NextNode">
      <MemberSignature Language="C#" Value="public System.Xml.Linq.XNode NextNode { get; }" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xml.Linq.XNode NextNode" />
      <MemberSignature Language="DocId" Value="P:System.Xml.Linq.XNode.NextNode" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property NextNode As XNode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xml::Linq::XNode ^ NextNode { System::Xml::Linq::XNode ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.NextNode : System.Xml.Linq.XNode" Usage="System.Xml.Linq.XNode.NextNode" />
      <MemberSignature Language="C#" Value="public System.Xml.Linq.XNode? NextNode { get; }" FrameworkAlternate="net-5.0" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Linq.XNode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="d621c-330">获取此节点的下一个同级节点。</span><span class="sxs-lookup"><span data-stu-id="d621c-330">Gets the next sibling node of this node.</span></span></summary>
        <value><span data-ttu-id="d621c-331">包含下一个同级节点的 <see cref="T:System.Xml.Linq.XNode" />。</span><span class="sxs-lookup"><span data-stu-id="d621c-331">The <see cref="T:System.Xml.Linq.XNode" /> that contains the next sibling node.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d621c-332">如果没有 <xref:System.Xml.Linq.XNode> 父级，或者没有下一个节点，则此属性返回 `null` 。</span><span class="sxs-lookup"><span data-stu-id="d621c-332">If this <xref:System.Xml.Linq.XNode> does not have a parent, or if there is no next node, this property returns `null`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d621c-333">下面的示例使用此属性循环遍历节点。</span><span class="sxs-lookup"><span data-stu-id="d621c-333">The following example uses this property to loop through nodes.</span></span>  
  
```csharp  
XElement xmlTree = new XElement("Root",  
    new XElement("Child1", 1),  
    new XText("Some Text"),  
    new XElement("Child2",  
        2,  
        new XElement("GrandChild", "GrandChild Content")  
    ),  
    new XComment("a comment"),  
    new XElement("Child3")  
);  
XNode node = xmlTree.Element("Child2");  
do {  
    StringBuilder sb = new StringBuilder();  
    sb.Append(String.Format("NodeType: {0}", node.NodeType.ToString().PadRight(10)));  
    switch (node.NodeType)  
    {  
        case XmlNodeType.Text:  
            sb.Append((node as XText).Value);  
            break;  
        case XmlNodeType.Element:  
            sb.Append((node as XElement).Name);  
            break;  
        case XmlNodeType.Comment:  
            sb.Append((node as XComment).Value);  
            break;  
    }  
    Console.WriteLine(sb.ToString());  
}  
while ((node = node.NextNode) != null);  
```  
  
```vb  
Dim xmlTree As XElement = _   
        <Root>  
            <Child1>1</Child1>Some Text  
            <Child2>2  
                <GrandChild>GrandChild Content</GrandChild>  
            </Child2>  
            <!--a comment-->  
            <Child3>3</Child3>  
        </Root>  
  
Dim node As XNode = xmlTree.Element("Child2")  
Do  
    Dim sb As StringBuilder = New StringBuilder()  
    sb.Append(String.Format("NodeType: {0}", node.NodeType.ToString().PadRight(10)))  
    Select Case node.NodeType  
        Case XmlNodeType.Text  
            sb.Append(DirectCast(node, XText).Value)  
        Case XmlNodeType.Element  
            sb.Append(DirectCast(node, XElement).Name)  
        Case XmlNodeType.Comment  
            sb.Append(DirectCast(node, XComment).Value)  
    End Select  
    Console.WriteLine(sb.ToString())  
  
    node = node.NextNode  
Loop While (Not (node Is Nothing))  
```  
  
 <span data-ttu-id="d621c-334">该示例产生下面的输出：</span><span class="sxs-lookup"><span data-stu-id="d621c-334">This example produces the following output:</span></span>  
  
```  
NodeType: Element   Child2  
NodeType: Comment   a comment  
NodeType: Element   Child3  
```  
  
 ]]></format>
        </remarks>
        <related type="Article" href="/dotnet/standard/linq/linq-xml-overview"><span data-ttu-id="d621c-335">LINQ to XML 概述</span><span class="sxs-lookup"><span data-stu-id="d621c-335">LINQ to XML overview</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="NodesAfterSelf">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.Xml.Linq.XNode&gt; NodesAfterSelf ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;class System.Xml.Linq.XNode&gt; NodesAfterSelf() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XNode.NodesAfterSelf" />
      <MemberSignature Language="VB.NET" Value="Public Function NodesAfterSelf () As IEnumerable(Of XNode)" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IEnumerable&lt;System::Xml::Linq::XNode ^&gt; ^ NodesAfterSelf();" />
      <MemberSignature Language="F#" Value="member this.NodesAfterSelf : unit -&gt; seq&lt;System.Xml.Linq.XNode&gt;" Usage="xNode.NodesAfterSelf " />
      <MemberSignature Language="VB.NET" Value="Public Iterator Function NodesAfterSelf () As IEnumerable(Of XNode)" FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.6">
          <AttributeName Language="C#">[System.Runtime.CompilerServices.IteratorStateMachine(typeof(System.Xml.Linq.XNode/&lt;NodesAfterSelf&gt;d__1))]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IteratorStateMachine(typeof(System.Xml.Linq.XNode/&lt;NodesAfterSelf&gt;d__1))&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.Runtime.CompilerServices.IteratorStateMachine(typeof(System.Xml.Linq.XNode/&lt;NodesAfterSelf&gt;d__21))]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IteratorStateMachine(typeof(System.Xml.Linq.XNode/&lt;NodesAfterSelf&gt;d__21))&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Xml.Linq.XNode&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="d621c-336">按文档顺序返回此节点后的同级节点的集合。</span><span class="sxs-lookup"><span data-stu-id="d621c-336">Returns a collection of the sibling nodes after this node, in document order.</span></span></summary>
        <returns><span data-ttu-id="d621c-337">此节点后同级节点（按文档顺序排列）的 <see cref="T:System.Xml.Linq.XNode" /> 的 <see cref="T:System.Collections.Generic.IEnumerable`1" />。</span><span class="sxs-lookup"><span data-stu-id="d621c-337">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> of <see cref="T:System.Xml.Linq.XNode" /> of the sibling nodes after this node, in document order.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d621c-338">此方法仅在返回的集合中包含同级。</span><span class="sxs-lookup"><span data-stu-id="d621c-338">This method only includes siblings in the returned collection.</span></span> <span data-ttu-id="d621c-339">它不包括后代。</span><span class="sxs-lookup"><span data-stu-id="d621c-339">It does not include descendants.</span></span>  
  
 <span data-ttu-id="d621c-340">此方法使用延迟执行。</span><span class="sxs-lookup"><span data-stu-id="d621c-340">This method uses deferred execution.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d621c-341">下面的示例创建一个 XML 树，然后使用此轴方法查询该树。</span><span class="sxs-lookup"><span data-stu-id="d621c-341">The following example creates an XML tree, and then queries the tree using this axis method.</span></span>  
  
```csharp  
XElement xmlTree = new XElement("Root",  
    new XText("Text content."),  
    new XElement("Child1", "child1 content"),  
    new XElement("Child2", "child2 content"),  
    new XText("More text content."),  
    new XElement("child3", "child3 content")  
);  
XElement child = xmlTree.Element("Child2");  
IEnumerable<XNode> nodes =  
    from node in child.NodesAfterSelf()  
    select node;  
foreach (XNode node in nodes)  
{  
    Console.WriteLine("Node type: {0}  {1}",  
        node.NodeType,  
        node.NodeType == XmlNodeType.Text ? (node as XText).Value : "");  
}  
```  
  
```vb  
Dim xmlTree As XElement = New XElement("Root", _New XText("Text content."), _  
    New XElement("Child1", "child1 content"), _  
    New XElement("Child2", "child2 content"), _  
    New XText("More text content."), _  
    New XElement("child3", "child3 content") _  
)  
  
Dim child As XElement = xmlTree.Element("Child2")  
Dim nodes As IEnumerable(Of XNode) = _  
    From node In child.NodesAfterSelf() _  
    Select node  
For Each node As XNode In nodes  
    Dim s As String = ""  
    If node.NodeType = XmlNodeType.Text Then  
        s = DirectCast(node, XText).Value  
    End If  
    Console.WriteLine("Node type: {0}  {1}", node.NodeType, s)  
Next  
```  
  
 <span data-ttu-id="d621c-342">该示例产生下面的输出：</span><span class="sxs-lookup"><span data-stu-id="d621c-342">This example produces the following output:</span></span>  
  
```  
Node type: Text  More text content.  
Node type: Element  
```  
  
 ]]></format>
        </remarks>
        <related type="Article" href="/dotnet/standard/linq/linq-xml-overview"><span data-ttu-id="d621c-343">LINQ to XML 概述</span><span class="sxs-lookup"><span data-stu-id="d621c-343">LINQ to XML overview</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="NodesBeforeSelf">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.Xml.Linq.XNode&gt; NodesBeforeSelf ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;class System.Xml.Linq.XNode&gt; NodesBeforeSelf() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XNode.NodesBeforeSelf" />
      <MemberSignature Language="VB.NET" Value="Public Function NodesBeforeSelf () As IEnumerable(Of XNode)" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IEnumerable&lt;System::Xml::Linq::XNode ^&gt; ^ NodesBeforeSelf();" />
      <MemberSignature Language="F#" Value="member this.NodesBeforeSelf : unit -&gt; seq&lt;System.Xml.Linq.XNode&gt;" Usage="xNode.NodesBeforeSelf " />
      <MemberSignature Language="VB.NET" Value="Public Iterator Function NodesBeforeSelf () As IEnumerable(Of XNode)" FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.6">
          <AttributeName Language="C#">[System.Runtime.CompilerServices.IteratorStateMachine(typeof(System.Xml.Linq.XNode/&lt;NodesBeforeSelf&gt;d__1))]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IteratorStateMachine(typeof(System.Xml.Linq.XNode/&lt;NodesBeforeSelf&gt;d__1))&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.Runtime.CompilerServices.IteratorStateMachine(typeof(System.Xml.Linq.XNode/&lt;NodesBeforeSelf&gt;d__22))]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IteratorStateMachine(typeof(System.Xml.Linq.XNode/&lt;NodesBeforeSelf&gt;d__22))&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Xml.Linq.XNode&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="d621c-344">按文档顺序返回此节点前的同级节点的集合。</span><span class="sxs-lookup"><span data-stu-id="d621c-344">Returns a collection of the sibling nodes before this node, in document order.</span></span></summary>
        <returns><span data-ttu-id="d621c-345">此节点前同级节点（按文档顺序排列）的 <see cref="T:System.Xml.Linq.XNode" /> 的 <see cref="T:System.Collections.Generic.IEnumerable`1" />。</span><span class="sxs-lookup"><span data-stu-id="d621c-345">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> of <see cref="T:System.Xml.Linq.XNode" /> of the sibling nodes before this node, in document order.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d621c-346">此方法仅在返回的集合中包含同级。</span><span class="sxs-lookup"><span data-stu-id="d621c-346">This method only includes siblings in the returned collection.</span></span> <span data-ttu-id="d621c-347">它不包括后代。</span><span class="sxs-lookup"><span data-stu-id="d621c-347">It does not include descendants.</span></span>  
  
 <span data-ttu-id="d621c-348">此方法使用延迟执行。</span><span class="sxs-lookup"><span data-stu-id="d621c-348">This method uses deferred execution.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d621c-349">下面的示例创建一个 XML 树，然后使用此轴方法查询该树。</span><span class="sxs-lookup"><span data-stu-id="d621c-349">The following example creates an XML tree, and then queries the tree using this axis method.</span></span>  
  
```csharp  
XElement xmlTree = new XElement("Root",  
    new XText("Text content."),  
    new XElement("Child1", "child1 content"),  
    new XElement("Child2", "child2 content"),  
    new XText("More text content."),  
    new XElement("child3", "child3 content")  
);  
XElement child = xmlTree.Element("Child2");  
IEnumerable<XNode> nodes =  
    from node in child.NodesBeforeSelf()  
    select node;  
foreach (XNode node in nodes)  
    Console.WriteLine("Node type: {0}  {1}",  
        node.NodeType,  
        node.NodeType == XmlNodeType.Text ? (node as XText).Value : "");  
```  
  
```vb  
Dim xmlTree As XElement = New XElement("Root", _  
    New XText("Text content."), _  
    New XElement("Child1", "child1 content"), _  
    New XElement("Child2", "child2 content"), _  
    New XText("More text content."), _  
    New XElement("child3", "child3 content") _  
)  
  
Dim child As XElement = xmlTree.Element("Child2")  
Dim nodes As IEnumerable(Of XNode) = _  
    From node In child.NodesBeforeSelf() _  
    Select node  
For Each node As XNode In nodes  
    Dim s As String = ""  
    If node.NodeType = XmlNodeType.Text Then  
        s = DirectCast(node, XText).Value  
    End If  
    Console.WriteLine("Node type: {0}  {1}", node.NodeType, s)  
Next  
```  
  
 <span data-ttu-id="d621c-350">该示例产生下面的输出：</span><span class="sxs-lookup"><span data-stu-id="d621c-350">This example produces the following output:</span></span>  
  
```  
Node type: Text  Text content.  
Node type: Element  
```  
  
 ]]></format>
        </remarks>
        <related type="Article" href="/dotnet/standard/linq/linq-xml-overview"><span data-ttu-id="d621c-351">LINQ to XML 概述</span><span class="sxs-lookup"><span data-stu-id="d621c-351">LINQ to XML overview</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="PreviousNode">
      <MemberSignature Language="C#" Value="public System.Xml.Linq.XNode PreviousNode { get; }" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xml.Linq.XNode PreviousNode" />
      <MemberSignature Language="DocId" Value="P:System.Xml.Linq.XNode.PreviousNode" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PreviousNode As XNode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xml::Linq::XNode ^ PreviousNode { System::Xml::Linq::XNode ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.PreviousNode : System.Xml.Linq.XNode" Usage="System.Xml.Linq.XNode.PreviousNode" />
      <MemberSignature Language="C#" Value="public System.Xml.Linq.XNode? PreviousNode { get; }" FrameworkAlternate="net-5.0" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Linq.XNode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="d621c-352">获取此节点的上一个同级节点。</span><span class="sxs-lookup"><span data-stu-id="d621c-352">Gets the previous sibling node of this node.</span></span></summary>
        <value><span data-ttu-id="d621c-353">包含上一个同级节点的 <see cref="T:System.Xml.Linq.XNode" />。</span><span class="sxs-lookup"><span data-stu-id="d621c-353">The <see cref="T:System.Xml.Linq.XNode" /> that contains the previous sibling node.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d621c-354">如果没有 <xref:System.Xml.Linq.XNode> 父级，或者没有上一个节点，则此属性返回 `null` 。</span><span class="sxs-lookup"><span data-stu-id="d621c-354">If this <xref:System.Xml.Linq.XNode> does not have a parent, or if there is no previous node, this property returns `null`.</span></span>  
  
 <span data-ttu-id="d621c-355">将其子 <xref:System.Xml.Linq.XContainer> 节点存储为对象的单向链接列表 <xref:System.Xml.Linq.XNode> 。</span><span class="sxs-lookup"><span data-stu-id="d621c-355">The <xref:System.Xml.Linq.XContainer> stores its child nodes as a singly-linked list of <xref:System.Xml.Linq.XNode> objects.</span></span> <span data-ttu-id="d621c-356">这意味着 <xref:System.Xml.Linq.XNode.PreviousNode%2A> 属性必须遍历父容器下直接子节点的列表。</span><span class="sxs-lookup"><span data-stu-id="d621c-356">This means that the <xref:System.Xml.Linq.XNode.PreviousNode%2A> property must traverse the list of direct child nodes under the parent container.</span></span> <span data-ttu-id="d621c-357">因此，使用此属性可能会影响性能。</span><span class="sxs-lookup"><span data-stu-id="d621c-357">Therefore, using this property might affect your performance.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d621c-358">下面的示例使用此属性循环遍历节点。</span><span class="sxs-lookup"><span data-stu-id="d621c-358">The following example uses this property to loop through nodes.</span></span>  
  
```csharp  
XElement xmlTree = new XElement("Root",  
    new XElement("Child1", 1),  
    new XText("Some Text"),  
    new XElement("Child2",  
        2,  
        new XElement("GrandChild", "GrandChild Content")  
    ),  
    new XComment("a comment"),  
    new XElement("Child3")  
);  
XNode node = xmlTree.Element("Child2");  
do {  
    StringBuilder sb = new StringBuilder();  
    sb.Append(String.Format("NodeType: {0}", node.NodeType.ToString().PadRight(10)));  
    switch (node.NodeType)  
    {  
        case XmlNodeType.Text:  
            sb.Append((node as XText).Value);  
            break;  
        case XmlNodeType.Element:  
            sb.Append((node as XElement).Name);  
            break;  
        case XmlNodeType.Comment:  
            sb.Append((node as XComment).Value);  
            break;  
    }  
    Console.WriteLine(sb.ToString());  
}  
while ((node = node.PreviousNode) != null);  
```  
  
```vb  
Dim xmlTree As XElement = _  
    <Root>  
        <Child1>1</Child1>Some Text<Child2>2  
            <GrandChild>GrandChild Content</GrandChild>  
        </Child2>  
        <!--a comment-->  
        <Child3>3</Child3>  
    </Root>  
  
Dim node As XNode = xmlTree.Element("Child2")  
Do  
    Dim sb As StringBuilder = New StringBuilder()  
    sb.Append(String.Format("NodeType: {0}", node.NodeType.ToString().PadRight(10)))  
    Select Case node.NodeType  
        Case XmlNodeType.Text  
            sb.Append(DirectCast(node, XText).Value)  
        Case XmlNodeType.Element  
            sb.Append(DirectCast(node, XElement).Name)  
        Case XmlNodeType.Comment  
            sb.Append(DirectCast(node, XComment).Value)  
    End Select  
    Console.WriteLine(sb.ToString())  
  
    node = node.PreviousNode  
Loop While (Not (node Is Nothing))  
```  
  
 <span data-ttu-id="d621c-359">该示例产生下面的输出：</span><span class="sxs-lookup"><span data-stu-id="d621c-359">This example produces the following output:</span></span>  
  
```  
NodeType: Element   Child2  
NodeType: Text      Some Text  
NodeType: Element   Child1  
```  
  
 ]]></format>
        </remarks>
        <related type="Article" href="/dotnet/standard/linq/linq-xml-overview"><span data-ttu-id="d621c-360">LINQ to XML 概述</span><span class="sxs-lookup"><span data-stu-id="d621c-360">LINQ to XML overview</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="ReadFrom">
      <MemberSignature Language="C#" Value="public static System.Xml.Linq.XNode ReadFrom (System.Xml.XmlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.Linq.XNode ReadFrom(class System.Xml.XmlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XNode.ReadFrom(System.Xml.XmlReader)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadFrom (reader As XmlReader) As XNode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Xml::Linq::XNode ^ ReadFrom(System::Xml::XmlReader ^ reader);" />
      <MemberSignature Language="F#" Value="static member ReadFrom : System.Xml.XmlReader -&gt; System.Xml.Linq.XNode" Usage="System.Xml.Linq.XNode.ReadFrom reader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Linq.XNode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="reader"><span data-ttu-id="d621c-361">定位于要读取到此 <see cref="T:System.Xml.Linq.XNode" /> 中的节点的 <see cref="T:System.Xml.XmlReader" />。</span><span class="sxs-lookup"><span data-stu-id="d621c-361">An <see cref="T:System.Xml.XmlReader" /> positioned at the node to read into this <see cref="T:System.Xml.Linq.XNode" />.</span></span></param>
        <summary><span data-ttu-id="d621c-362">从 <see cref="T:System.Xml.XmlReader" /> 创建 <see cref="T:System.Xml.Linq.XNode" />。</span><span class="sxs-lookup"><span data-stu-id="d621c-362">Creates an <see cref="T:System.Xml.Linq.XNode" /> from an <see cref="T:System.Xml.XmlReader" />.</span></span></summary>
        <returns><span data-ttu-id="d621c-363">一个 <see cref="T:System.Xml.Linq.XNode" />，其中包含从此读取器读取的节点及其子代节点。</span><span class="sxs-lookup"><span data-stu-id="d621c-363">An <see cref="T:System.Xml.Linq.XNode" /> that contains the node and its descendant nodes that were read from the reader.</span></span> <span data-ttu-id="d621c-364">节点的运行时类型由读取器中出现的第一个节点的节点类型 (<see cref="P:System.Xml.Linq.XObject.NodeType" />) 确定。</span><span class="sxs-lookup"><span data-stu-id="d621c-364">The runtime type of the node is determined by the node type (<see cref="P:System.Xml.Linq.XObject.NodeType" />) of the first node encountered in the reader.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d621c-365">您可以使用此方法来编写返回节点集合的方法，并在从读取器中读取节点时生成每个节点。</span><span class="sxs-lookup"><span data-stu-id="d621c-365">You can use this method to write a method that returns a collection of nodes, yielding each node as the node is read from the reader.</span></span> <span data-ttu-id="d621c-366">利用此方法，您可以处理很小的内存需求量的任意大型 XML 文件。</span><span class="sxs-lookup"><span data-stu-id="d621c-366">This method enables you to process arbitrarily large XML files with a very small memory footprint.</span></span>  
  
 <span data-ttu-id="d621c-367">传递给此方法的读取器可能会引发异常。</span><span class="sxs-lookup"><span data-stu-id="d621c-367">The reader that you pass to this method might throw exceptions.</span></span> <span data-ttu-id="d621c-368"><xref:System.Xml.Linq.XNode.ReadFrom%2A> 不捕获读取器引发的所有异常;未处理的异常会向上冒泡到调用的代码 <xref:System.Xml.Linq.XNode.ReadFrom%2A> 。</span><span class="sxs-lookup"><span data-stu-id="d621c-368"><xref:System.Xml.Linq.XNode.ReadFrom%2A> does not catch all exceptions thrown by the reader; the unhandled exceptions bubble up to the code that called <xref:System.Xml.Linq.XNode.ReadFrom%2A>.</span></span> <span data-ttu-id="d621c-369">特别是，您的代码应准备好处理 <xref:System.Xml.XmlException> 。</span><span class="sxs-lookup"><span data-stu-id="d621c-369">In particular, your code should be prepared to handle <xref:System.Xml.XmlException>.</span></span>  
  
 <span data-ttu-id="d621c-370">有关如何对更复杂的文档进行流式处理的示例，请参阅 [如何对 XML 片段进行流式处理以访问标头信息](/dotnet/standard/linq/stream-xml-fragments-access-header-information)。</span><span class="sxs-lookup"><span data-stu-id="d621c-370">For an example of how to stream a more complex document, see [How to stream XML fragments with access to header information](/dotnet/standard/linq/stream-xml-fragments-access-header-information).</span></span>  
  
 <span data-ttu-id="d621c-371">某些标准查询运算符（如 <xref:System.Linq.Enumerable.OrderBy%2A>）可以循环访问其源、收集所有数据、对数据排序，最后生成序列中的第一项。</span><span class="sxs-lookup"><span data-stu-id="d621c-371">Certain standard query operators, such as <xref:System.Linq.Enumerable.OrderBy%2A>, iterate their source, collect all of the data, sort it, and then finally yield the first item in the sequence.</span></span> <span data-ttu-id="d621c-372">如果使用可在生成第一项之前具体化源的查询运算符，则不会保持小的内存需求量。</span><span class="sxs-lookup"><span data-stu-id="d621c-372">If you use a query operator that materializes its source before yielding the first item, you will not retain a small memory footprint.</span></span>  
  
 <span data-ttu-id="d621c-373">有关如何 [!INCLUDE[sqltecxlinq](~/includes/sqltecxlinq-md.md)] 在保持较小的内存需求量的同时转换非常大的 xml 文档的示例，请参阅 [如何执行大型 xml 文档的流式转换](/dotnet/standard/linq/perform-streaming-transform-large-xml-documents)。</span><span class="sxs-lookup"><span data-stu-id="d621c-373">For an example of using [!INCLUDE[sqltecxlinq](~/includes/sqltecxlinq-md.md)] to transform extremely large XML documents while maintaining a small memory footprint, see [How to perform streaming transform of large XML documents](/dotnet/standard/linq/perform-streaming-transform-large-xml-documents).</span></span>  
  
## Examples

<span data-ttu-id="d621c-374">此示例使用名为 *Source.xml*的以下 XML 文件：</span><span class="sxs-lookup"><span data-stu-id="d621c-374">This example uses the following XML file, named *Source.xml*:</span></span>

[!code-xml[Source.xml](~/samples/snippets/csharp/api/system.xml.linq/xnode/readfrom/Source.xml)]

<span data-ttu-id="d621c-375">下面的示例创建一个自定义轴方法，该方法使用 <xref:System.Xml.Linq.XNode.ReadFrom%2A> ，然后使用 LINQ 查询来查询自定义轴：</span><span class="sxs-lookup"><span data-stu-id="d621c-375">The following example creates a custom axis method that uses <xref:System.Xml.Linq.XNode.ReadFrom%2A> and then queries the custom axis by using a LINQ query:</span></span>

[!code-csharp[XNode.ReadFromCS](~/samples/snippets/csharp/api/system.xml.linq/xnode/readfrom/Program.cs)]
[!code-vb[XNode.ReadFromVB](~/samples/snippets/visualbasic/api/system.xml.linq/xnode/readfrom/Program.vb)]

<span data-ttu-id="d621c-376">该示例产生下面的输出：</span><span class="sxs-lookup"><span data-stu-id="d621c-376">This example produces the following output:</span></span>

```  
bbb  
ccc  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="d621c-377"><see cref="T:System.Xml.XmlReader" /> 未定位于已识别的节点类型。</span><span class="sxs-lookup"><span data-stu-id="d621c-377">The <see cref="T:System.Xml.XmlReader" /> is not positioned on a recognized node type.</span></span></exception>
        <exception cref="T:System.Xml.XmlException"><span data-ttu-id="d621c-378">基础 <see cref="T:System.Xml.XmlReader" /> 引发异常。</span><span class="sxs-lookup"><span data-stu-id="d621c-378">The underlying <see cref="T:System.Xml.XmlReader" /> throws an exception.</span></span></exception>
        <related type="Article" href="/dotnet/standard/linq/linq-xml-overview"><span data-ttu-id="d621c-379">LINQ to XML 概述</span><span class="sxs-lookup"><span data-stu-id="d621c-379">LINQ to XML overview</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="ReadFromAsync">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;System.Xml.Linq.XNode&gt; ReadFromAsync (System.Xml.XmlReader reader, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;class System.Xml.Linq.XNode&gt; ReadFromAsync(class System.Xml.XmlReader reader, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XNode.ReadFromAsync(System.Xml.XmlReader,System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadFromAsync (reader As XmlReader, cancellationToken As CancellationToken) As Task(Of XNode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::Task&lt;System::Xml::Linq::XNode ^&gt; ^ ReadFromAsync(System::Xml::XmlReader ^ reader, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="static member ReadFromAsync : System.Xml.XmlReader * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;System.Xml.Linq.XNode&gt;" Usage="System.Xml.Linq.XNode.ReadFromAsync (reader, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Xml.Linq.XNode&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="reader"><span data-ttu-id="d621c-380">放置在用于读取此 <see cref="T:System.Xml.Linq.XNode" /> 内容的节点处的阅读器。</span><span class="sxs-lookup"><span data-stu-id="d621c-380">A reader positioned at the node to read into this <see cref="T:System.Xml.Linq.XNode" />.</span></span></param>
        <param name="cancellationToken"><span data-ttu-id="d621c-381">可用于请求异步操作取消的标志。</span><span class="sxs-lookup"><span data-stu-id="d621c-381">A token that can be used to request cancellation of the asynchronous operation.</span></span></param>
        <summary><span data-ttu-id="d621c-382">从 <see cref="T:System.Xml.XmlReader" /> 创建 <see cref="T:System.Xml.Linq.XNode" />。</span><span class="sxs-lookup"><span data-stu-id="d621c-382">Creates an <see cref="T:System.Xml.Linq.XNode" /> from an <see cref="T:System.Xml.XmlReader" />.</span></span> <span data-ttu-id="d621c-383">节点的运行时类型由读取器中出现的第一个节点的 <see cref="P:System.Xml.Linq.XObject.NodeType" /> 确定。</span><span class="sxs-lookup"><span data-stu-id="d621c-383">The runtime type of the node is determined by the <see cref="P:System.Xml.Linq.XObject.NodeType" /> of the first node encountered in the reader.</span></span></summary>
        <returns><span data-ttu-id="d621c-384">包含从读取器读取的节点的 XNode。</span><span class="sxs-lookup"><span data-stu-id="d621c-384">An XNode that contains the nodes read from the reader.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="d621c-385"><see cref="T:System.Xml.XmlReader" /> 未定位于已识别的节点类型。</span><span class="sxs-lookup"><span data-stu-id="d621c-385">The <see cref="T:System.Xml.XmlReader" /> is not positioned on a recognized node type.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public void Remove ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Remove() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XNode.Remove" />
      <MemberSignature Language="VB.NET" Value="Public Sub Remove ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Remove();" />
      <MemberSignature Language="F#" Value="member this.Remove : unit -&gt; unit" Usage="xNode.Remove " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="d621c-386">从节点父级中删除此节点。</span><span class="sxs-lookup"><span data-stu-id="d621c-386">Removes this node from its parent.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d621c-387">在 [!INCLUDE[sqltecxlinq](~/includes/sqltecxlinq-md.md)] 编程中，在查询集中的节点时，不应操作或修改一组节点。</span><span class="sxs-lookup"><span data-stu-id="d621c-387">In [!INCLUDE[sqltecxlinq](~/includes/sqltecxlinq-md.md)] programming, you should not manipulate or modify a set of nodes while you are querying for nodes in that set.</span></span> <span data-ttu-id="d621c-388">在实际情况下，这意味着不应循环访问一组节点并将其删除。</span><span class="sxs-lookup"><span data-stu-id="d621c-388">In practical terms, this means that you should not iterate over a set of nodes and remove them.</span></span> <span data-ttu-id="d621c-389">相反，应 <xref:System.Collections.Generic.List%601> 使用扩展方法将其具体化为 <xref:System.Linq.Enumerable.ToList%2A> 。</span><span class="sxs-lookup"><span data-stu-id="d621c-389">Instead, you should materialize them into a <xref:System.Collections.Generic.List%601> by using the <xref:System.Linq.Enumerable.ToList%2A> extension method.</span></span> <span data-ttu-id="d621c-390">然后，您可以循环访问该列表以删除节点。</span><span class="sxs-lookup"><span data-stu-id="d621c-390">Then, you can iterate over the list to remove the nodes.</span></span> <span data-ttu-id="d621c-391">有关详细信息，请参阅 [混合声明性代码/命令性代码 bug (LINQ to XML) ](/dotnet/standard/linq/mixed-declarative-imperative-code-bugs)。</span><span class="sxs-lookup"><span data-stu-id="d621c-391">For more information, see [Mixed Declarative Code/Imperative Code Bugs (LINQ to XML)](/dotnet/standard/linq/mixed-declarative-imperative-code-bugs).</span></span>  
  
 <span data-ttu-id="d621c-392">或者，如果要删除一组节点，建议使用 <xref:System.Xml.Linq.Extensions.Remove%2A?displayProperty=nameWithType> 方法。</span><span class="sxs-lookup"><span data-stu-id="d621c-392">Alternatively, if you want to remove a set of nodes, it is recommended that you use the <xref:System.Xml.Linq.Extensions.Remove%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="d621c-393">此方法将节点复制到列表，然后循环访问列表以删除节点。</span><span class="sxs-lookup"><span data-stu-id="d621c-393">This method copies the nodes to a list, and then iterates over the list to remove the nodes.</span></span>  
  
 <span data-ttu-id="d621c-394">此方法将引发 <xref:System.Xml.Linq.XObject.Changed> 和 <xref:System.Xml.Linq.XObject.Changing> 事件。</span><span class="sxs-lookup"><span data-stu-id="d621c-394">This method will raise the <xref:System.Xml.Linq.XObject.Changed> and the <xref:System.Xml.Linq.XObject.Changing> events.</span></span>  
  
 <span data-ttu-id="d621c-395">将其子 <xref:System.Xml.Linq.XContainer> 节点存储为对象的单向链接列表 <xref:System.Xml.Linq.XNode> 。</span><span class="sxs-lookup"><span data-stu-id="d621c-395">The <xref:System.Xml.Linq.XContainer> stores its child nodes as a singly-linked list of <xref:System.Xml.Linq.XNode> objects.</span></span> <span data-ttu-id="d621c-396">这意味着该 <xref:System.Xml.Linq.XNode.Remove%2A> 方法必须遍历父容器下直接子节点的列表。</span><span class="sxs-lookup"><span data-stu-id="d621c-396">This means that the <xref:System.Xml.Linq.XNode.Remove%2A> method must traverse the list of direct child nodes under the parent container.</span></span> <span data-ttu-id="d621c-397">因此，使用此方法可能会影响性能。</span><span class="sxs-lookup"><span data-stu-id="d621c-397">Therefore, using this method might affect your performance.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d621c-398">下面的示例从父节点中删除节点。</span><span class="sxs-lookup"><span data-stu-id="d621c-398">The following example removes a node from its parent.</span></span>  
  
```csharp  
XElement xmlTree = new XElement("Root",  
    new XElement("Child1", "child1 content"),  
    new XElement("Child2", "child2 content"),  
    new XElement("Child3", "child3 content"),  
    new XElement("Child4", "child4 content"),  
    new XElement("Child5", "child5 content")  
);  
XElement child3 = xmlTree.Element("Child3");  
child3.Remove();  
Console.WriteLine(xmlTree);  
```  
  
```vb  
Dim xmlTree As XElement = _   
        <Root>  
            <Child1>child1 content</Child1>  
            <Child2>child2 content</Child2>  
            <Child3>child3 content</Child3>  
            <Child4>child4 content</Child4>  
            <Child5>child5 content</Child5>  
        </Root>  
  
Dim child3 As XElement = xmlTree.<Child3>(0)  
child3.Remove()  
Console.WriteLine(xmlTree)  
```  
  
 <span data-ttu-id="d621c-399">该示例产生下面的输出：</span><span class="sxs-lookup"><span data-stu-id="d621c-399">This example produces the following output:</span></span>  
  
```xml  
<Root>  
  <Child1>child1 content</Child1>  
  <Child2>child2 content</Child2>  
  <Child4>child4 content</Child4>  
  <Child5>child5 content</Child5>  
</Root>  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="d621c-400">父级为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d621c-400">The parent is <see langword="null" />.</span></span></exception>
        <related type="Article" href="/dotnet/standard/linq/linq-xml-overview"><span data-ttu-id="d621c-401">LINQ to XML 概述</span><span class="sxs-lookup"><span data-stu-id="d621c-401">LINQ to XML overview</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReplaceWith">
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="d621c-402">将此节点替换为指定的内容。</span><span class="sxs-lookup"><span data-stu-id="d621c-402">Replaces this node with the specified content.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d621c-403">有关可传递到此方法的有效内容的详细信息，请参阅 [system.xml.linq.xelement> 和 XDocument 对象的有效内容](/dotnet/standard/linq/valid-content-xelement-xdocument-objects)。</span><span class="sxs-lookup"><span data-stu-id="d621c-403">For details about the valid content that can be passed to this method, see [Valid Content of XElement and XDocument Objects](/dotnet/standard/linq/valid-content-xelement-xdocument-objects).</span></span>  
  
 <span data-ttu-id="d621c-404">此方法将引发 <xref:System.Xml.Linq.XObject.Changed> 和 <xref:System.Xml.Linq.XObject.Changing> 事件。</span><span class="sxs-lookup"><span data-stu-id="d621c-404">This method will raise the <xref:System.Xml.Linq.XObject.Changed> and the <xref:System.Xml.Linq.XObject.Changing> events.</span></span>  
  
 <span data-ttu-id="d621c-405">将其子 <xref:System.Xml.Linq.XContainer> 节点存储为对象的单向链接列表 <xref:System.Xml.Linq.XNode> 。</span><span class="sxs-lookup"><span data-stu-id="d621c-405">The <xref:System.Xml.Linq.XContainer> stores its child nodes as a singly-linked list of <xref:System.Xml.Linq.XNode> objects.</span></span> <span data-ttu-id="d621c-406">这意味着该 <xref:System.Xml.Linq.XNode.ReplaceWith%2A> 方法必须遍历父容器下直接子节点的列表。</span><span class="sxs-lookup"><span data-stu-id="d621c-406">This means that the <xref:System.Xml.Linq.XNode.ReplaceWith%2A> method must  traverse the list of direct child nodes under the parent container.</span></span> <span data-ttu-id="d621c-407">因此，使用此方法可能会影响性能。</span><span class="sxs-lookup"><span data-stu-id="d621c-407">Therefore, using this method might affect your performance.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d621c-408">下面的示例使用此方法来替换具有不同内容的节点的内容。</span><span class="sxs-lookup"><span data-stu-id="d621c-408">The following example uses this method to replace the contents of a node with different content.</span></span>  
  
```csharp  
XElement xmlTree = new XElement("Root",  
    new XElement("Child1", "child1 content"),  
    new XElement("Child2", "child2 content"),  
    new XElement("Child3", "child3 content"),  
    new XElement("Child4", "child4 content"),  
    new XElement("Child5", "child5 content")  
);  
XElement child3 = xmlTree.Element("Child3");  
child3.ReplaceWith(  
    new XElement("NewChild", "new content")  
);  
Console.WriteLine(xmlTree);  
```  
  
```vb  
Dim xmlTree As XElement = _   
        <Root>  
            <Child1>child1 content</Child1>  
            <Child2>child2 content</Child2>  
            <Child3>child3 content</Child3>  
            <Child4>child4 content</Child4>  
            <Child5>child5 content</Child5>  
        </Root>  
  
Dim child3 As XElement = xmlTree.<Child3>(0)  
child3.ReplaceWith(<NewChild>new content</NewChild>)  
Console.WriteLine(xmlTree)  
```  
  
 <span data-ttu-id="d621c-409">该示例产生下面的输出：</span><span class="sxs-lookup"><span data-stu-id="d621c-409">This example produces the following output:</span></span>  
  
```xml  
<Root>  
  <Child1>child1 content</Child1>  
  <Child2>child2 content</Child2>  
  <NewChild>new content</NewChild>  
  <Child4>child4 content</Child4>  
  <Child5>child5 content</Child5>  
</Root>  
```  
  
 ]]></format>
        </remarks>
        <related type="Article" href="/dotnet/standard/linq/linq-xml-overview"><span data-ttu-id="d621c-410">LINQ to XML 概述</span><span class="sxs-lookup"><span data-stu-id="d621c-410">LINQ to XML overview</span></span></related>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReplaceWith">
      <MemberSignature Language="C#" Value="public void ReplaceWith (object content);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReplaceWith(object content) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XNode.ReplaceWith(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReplaceWith (content As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ReplaceWith(System::Object ^ content);" />
      <MemberSignature Language="F#" Value="member this.ReplaceWith : obj -&gt; unit" Usage="xNode.ReplaceWith content" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="content" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="content"><span data-ttu-id="d621c-411">替换此节点时所用的内容。</span><span class="sxs-lookup"><span data-stu-id="d621c-411">Content that replaces this node.</span></span></param>
        <summary><span data-ttu-id="d621c-412">将此节点替换为指定的内容。</span><span class="sxs-lookup"><span data-stu-id="d621c-412">Replaces this node with the specified content.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d621c-413">此方法首先从其父级中删除此节点，然后将指定的内容添加到此节点的父节点中的位置。</span><span class="sxs-lookup"><span data-stu-id="d621c-413">This method first removes this node from its parent, and then adds the specified content to this node's parent, in the place of this node.</span></span>  
  
 <span data-ttu-id="d621c-414">将其子 <xref:System.Xml.Linq.XContainer> 节点存储为对象的单向链接列表 <xref:System.Xml.Linq.XNode> 。</span><span class="sxs-lookup"><span data-stu-id="d621c-414">The <xref:System.Xml.Linq.XContainer> stores its child nodes as a singly-linked list of <xref:System.Xml.Linq.XNode> objects.</span></span> <span data-ttu-id="d621c-415">这意味着该 <xref:System.Xml.Linq.XNode.ReplaceWith%2A> 方法必须遍历父容器下直接子节点的列表。</span><span class="sxs-lookup"><span data-stu-id="d621c-415">This means that the <xref:System.Xml.Linq.XNode.ReplaceWith%2A> method must traverse the list of direct child nodes under the parent container.</span></span> <span data-ttu-id="d621c-416">因此，使用此方法可能会影响性能。</span><span class="sxs-lookup"><span data-stu-id="d621c-416">Therefore, using this method might affect your performance.</span></span>  
  
 <span data-ttu-id="d621c-417">有关可传递到此方法的有效内容的详细信息，请参阅 [system.xml.linq.xelement> 和 XDocument 对象的有效内容](/dotnet/standard/linq/valid-content-xelement-xdocument-objects)。</span><span class="sxs-lookup"><span data-stu-id="d621c-417">For details about the valid content that can be passed to this method, see [Valid Content of XElement and XDocument Objects](/dotnet/standard/linq/valid-content-xelement-xdocument-objects).</span></span>  
  
 <span data-ttu-id="d621c-418">此方法将引发 <xref:System.Xml.Linq.XObject.Changed> 和 <xref:System.Xml.Linq.XObject.Changing> 事件。</span><span class="sxs-lookup"><span data-stu-id="d621c-418">This method will raise the <xref:System.Xml.Linq.XObject.Changed> and the <xref:System.Xml.Linq.XObject.Changing> events.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d621c-419">下面的示例使用此方法来替换具有不同内容的节点的内容。</span><span class="sxs-lookup"><span data-stu-id="d621c-419">The following example uses this method to replace the contents of a node with different content.</span></span>  
  
```csharp  
XElement xmlTree = new XElement("Root",  
    new XElement("Child1", "child1 content"),  
    new XElement("Child2", "child2 content"),  
    new XElement("Child3", "child3 content"),  
    new XElement("Child4", "child4 content"),  
    new XElement("Child5", "child5 content")  
);  
XElement child3 = xmlTree.Element("Child3");  
child3.ReplaceWith(  
    new XElement("NewChild", "new content")  
);  
Console.WriteLine(xmlTree);  
```  
  
```vb  
Dim xmlTree As XElement = _   
        <Root>  
            <Child1>child1 content</Child1>  
            <Child2>child2 content</Child2>  
            <Child3>child3 content</Child3>  
            <Child4>child4 content</Child4>  
            <Child5>child5 content</Child5>  
        </Root>  
  
Dim child3 As XElement = xmlTree.<Child3>(0)  
child3.ReplaceWith(<NewChild>new content</NewChild>)  
Console.WriteLine(xmlTree)  
```  
  
 <span data-ttu-id="d621c-420">该示例产生下面的输出：</span><span class="sxs-lookup"><span data-stu-id="d621c-420">This example produces the following output:</span></span>  
  
```xml  
<Root>  
  <Child1>child1 content</Child1>  
  <Child2>child2 content</Child2>  
  <NewChild>new content</NewChild>  
  <Child4>child4 content</Child4>  
  <Child5>child5 content</Child5>  
</Root>  
```  
  
 ]]></format>
        </remarks>
        <related type="Article" href="/dotnet/standard/linq/linq-xml-overview"><span data-ttu-id="d621c-421">LINQ to XML 概述</span><span class="sxs-lookup"><span data-stu-id="d621c-421">LINQ to XML overview</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="ReplaceWith">
      <MemberSignature Language="C#" Value="public void ReplaceWith (params object[] content);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReplaceWith(object[] content) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XNode.ReplaceWith(System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReplaceWith (ParamArray content As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ReplaceWith(... cli::array &lt;System::Object ^&gt; ^ content);" />
      <MemberSignature Language="F#" Value="member this.ReplaceWith : obj[] -&gt; unit" Usage="xNode.ReplaceWith content" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="content" Type="System.Object[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName Language="C#">[System.ParamArray]</AttributeName>
              <AttributeName Language="F#">[&lt;System.ParamArray&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="content"><span data-ttu-id="d621c-422">新内容的参数列表。</span><span class="sxs-lookup"><span data-stu-id="d621c-422">A parameter list of the new content.</span></span></param>
        <summary><span data-ttu-id="d621c-423">将此节点替换为指定的内容。</span><span class="sxs-lookup"><span data-stu-id="d621c-423">Replaces this node with the specified content.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d621c-424">此方法首先从其父级中删除此节点，然后将指定的内容添加到此节点的父节点中的位置。</span><span class="sxs-lookup"><span data-stu-id="d621c-424">This method first removes this node from its parent, and then adds the specified content to this node's parent, in the place of this node.</span></span>  
  
 <span data-ttu-id="d621c-425">将其子 <xref:System.Xml.Linq.XContainer> 节点存储为对象的单向链接列表 <xref:System.Xml.Linq.XNode> 。</span><span class="sxs-lookup"><span data-stu-id="d621c-425">The <xref:System.Xml.Linq.XContainer> stores its child nodes as a singly-linked list of <xref:System.Xml.Linq.XNode> objects.</span></span> <span data-ttu-id="d621c-426">这意味着该 <xref:System.Xml.Linq.XNode.ReplaceWith%2A> 方法必须遍历父容器下直接子节点的列表。</span><span class="sxs-lookup"><span data-stu-id="d621c-426">This means that the <xref:System.Xml.Linq.XNode.ReplaceWith%2A> method must traverse the list of direct child nodes under the parent container.</span></span> <span data-ttu-id="d621c-427">因此，使用此方法可能会影响性能。</span><span class="sxs-lookup"><span data-stu-id="d621c-427">Therefore, using this method might affect your performance.</span></span>  
  
 <span data-ttu-id="d621c-428">有关可传递到此方法的有效内容的详细信息，请参阅 [system.xml.linq.xelement> 和 XDocument 对象的有效内容](/dotnet/standard/linq/valid-content-xelement-xdocument-objects)。</span><span class="sxs-lookup"><span data-stu-id="d621c-428">For details about the valid content that can be passed to this method, see [Valid Content of XElement and XDocument Objects](/dotnet/standard/linq/valid-content-xelement-xdocument-objects).</span></span>  
  
 <span data-ttu-id="d621c-429">此方法将引发 <xref:System.Xml.Linq.XObject.Changed> 和 <xref:System.Xml.Linq.XObject.Changing> 事件。</span><span class="sxs-lookup"><span data-stu-id="d621c-429">This method will raise the <xref:System.Xml.Linq.XObject.Changed> and the <xref:System.Xml.Linq.XObject.Changing> events.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d621c-430">下面的示例演示如何使用查询的结果 [!INCLUDE[sqltecxlinq](~/includes/sqltecxlinq-md.md)] 作为此方法的输入。</span><span class="sxs-lookup"><span data-stu-id="d621c-430">The following example shows using the results of a [!INCLUDE[sqltecxlinq](~/includes/sqltecxlinq-md.md)] query as the input to this method.</span></span>  
  
```csharp  
XElement srcTree = new XElement("Root",  
    new XElement("Element1", 1),  
    new XElement("Element2", 2),  
    new XElement("Element3", 3),  
    new XElement("Element4", 4),  
    new XElement("Element5", 5)  
);  
XElement xmlTree = new XElement("Root",  
    new XElement("Child1", 1),  
    new XElement("Child2", 2),  
    new XElement("Child3", 3),  
    new XElement("Child4", 4),  
    new XElement("Child5", 5)  
);  
XElement child3 = xmlTree.Element("Child3");  
child3.ReplaceWith(  
    from el in srcTree.Elements()  
    where (int)el > 3  
    select el  
);  
Console.WriteLine(xmlTree);  
```  
  
```vb  
Dim srcTree As XElement = _   
        <Root>  
            <Element1>1</Element1>  
            <Element2>2</Element2>  
            <Element3>3</Element3>  
            <Element4>4</Element4>  
            <Element5>5</Element5>  
        </Root>  
  
Dim xmlTree As XElement = _   
        <Root>  
            <Child1>1</Child1>  
            <Child2>2</Child2>  
            <Child3>3</Child3>  
            <Child4>4</Child4>  
            <Child5>5</Child5>  
        </Root>  
  
Dim child3 As XElement = xmlTree.<Child3>(0)  
child3.ReplaceWith( _  
    From el In srcTree.Elements() _  
    Where (CInt(el) > 3) _  
    Select el)  
  
Console.WriteLine(xmlTree)  
```  
  
 <span data-ttu-id="d621c-431">该示例产生下面的输出：</span><span class="sxs-lookup"><span data-stu-id="d621c-431">This example produces the following output:</span></span>  
  
```xml  
<Root>  
  <Child1>1</Child1>  
  <Child2>2</Child2>  
  <Element4>4</Element4>  
  <Element5>5</Element5>  
  <Child4>4</Child4>  
  <Child5>5</Child5>  
</Root>  
```  
  
 ]]></format>
        </remarks>
        <related type="Article" href="/dotnet/standard/linq/linq-xml-overview"><span data-ttu-id="d621c-432">LINQ to XML 概述</span><span class="sxs-lookup"><span data-stu-id="d621c-432">LINQ to XML overview</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="ToString">
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="d621c-433">返回此节点的 XML，还可以选择禁用格式设置。</span><span class="sxs-lookup"><span data-stu-id="d621c-433">Returns the XML for this node, optionally disabling formatting.</span></span></summary>
        <related type="Article" href="/dotnet/standard/linq/linq-xml-overview"><span data-ttu-id="d621c-434">LINQ to XML 概述</span><span class="sxs-lookup"><span data-stu-id="d621c-434">LINQ to XML overview</span></span></related>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XNode.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="xNode.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="d621c-435">返回此节点的缩进 XML。</span><span class="sxs-lookup"><span data-stu-id="d621c-435">Returns the indented XML for this node.</span></span></summary>
        <returns><span data-ttu-id="d621c-436">包含缩进 XML 的 <see cref="T:System.String" />。</span><span class="sxs-lookup"><span data-stu-id="d621c-436">A <see cref="T:System.String" /> containing the indented XML.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="d621c-437">下面的示例使用此方法检索缩进的 XML。</span><span class="sxs-lookup"><span data-stu-id="d621c-437">The following example uses this method to retrieve indented XML.</span></span>  
  
```csharp  
XElement xmlTree = new XElement("Root",  
    new XElement("Child1", 1)  
);  
Console.WriteLine(xmlTree);  
```  
  
```vb  
Dim xmlTree As XElement = _   
        <Root>  
            <Child1>1</Child1>  
        </Root>  
  
Console.WriteLine(xmlTree)  
```  
  
 <span data-ttu-id="d621c-438">该示例产生下面的输出：</span><span class="sxs-lookup"><span data-stu-id="d621c-438">This example produces the following output:</span></span>  
  
```xml  
<Root>  
  <Child1>1</Child1>  
</Root>  
```  
  
 ]]></format>
        </remarks>
        <related type="Article" href="/dotnet/standard/linq/linq-xml-overview"><span data-ttu-id="d621c-439">LINQ to XML 概述</span><span class="sxs-lookup"><span data-stu-id="d621c-439">LINQ to XML overview</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (System.Xml.Linq.SaveOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToString(valuetype System.Xml.Linq.SaveOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XNode.ToString(System.Xml.Linq.SaveOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (options As SaveOptions) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToString(System::Xml::Linq::SaveOptions options);" />
      <MemberSignature Language="F#" Value="override this.ToString : System.Xml.Linq.SaveOptions -&gt; string" Usage="xNode.ToString options" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="options" Type="System.Xml.Linq.SaveOptions" />
      </Parameters>
      <Docs>
        <param name="options"><span data-ttu-id="d621c-440">指定格式设置行为的 <see cref="T:System.Xml.Linq.SaveOptions" />。</span><span class="sxs-lookup"><span data-stu-id="d621c-440">A <see cref="T:System.Xml.Linq.SaveOptions" /> that specifies formatting behavior.</span></span></param>
        <summary><span data-ttu-id="d621c-441">返回此节点的 XML，还可以选择禁用格式设置。</span><span class="sxs-lookup"><span data-stu-id="d621c-441">Returns the XML for this node, optionally disabling formatting.</span></span></summary>
        <returns><span data-ttu-id="d621c-442">包含 XML 的 <see cref="T:System.String" />。</span><span class="sxs-lookup"><span data-stu-id="d621c-442">A <see cref="T:System.String" /> containing the XML.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="d621c-443">下面的示例使用此方法检索未格式化和格式化的 XML。</span><span class="sxs-lookup"><span data-stu-id="d621c-443">The following example uses this method to retrieve unformatted and formatted XML.</span></span>  
  
```csharp  
XElement root = XElement.Parse("<Root><Child/></Root>");  
Console.WriteLine(root.ToString(SaveOptions.DisableFormatting));  
Console.WriteLine("---");  
Console.WriteLine(root.ToString(SaveOptions.None));  
```  
  
```vb  
Dim root As XElement = <Root>  
                           <Child/>  
                       </Root>  
Console.WriteLine(root.ToString(SaveOptions.DisableFormatting))  
Console.WriteLine("---")  
Console.WriteLine(root.ToString(SaveOptions.None))  
```  
  
 <span data-ttu-id="d621c-444">该示例产生下面的输出：</span><span class="sxs-lookup"><span data-stu-id="d621c-444">This example produces the following output:</span></span>  
  
```  
<Root><Child /></Root>  
---  
<Root>  
  <Child />  
</Root>  
```  
  
 ]]></format>
        </remarks>
        <related type="Article" href="/dotnet/standard/linq/linq-xml-overview"><span data-ttu-id="d621c-445">LINQ to XML 概述</span><span class="sxs-lookup"><span data-stu-id="d621c-445">LINQ to XML overview</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="WriteTo">
      <MemberSignature Language="C#" Value="public abstract void WriteTo (System.Xml.XmlWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void WriteTo(class System.Xml.XmlWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XNode.WriteTo(System.Xml.XmlWriter)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub WriteTo (writer As XmlWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void WriteTo(System::Xml::XmlWriter ^ writer);" />
      <MemberSignature Language="F#" Value="abstract member WriteTo : System.Xml.XmlWriter -&gt; unit" Usage="xNode.WriteTo writer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
      </Parameters>
      <Docs>
        <param name="writer"><span data-ttu-id="d621c-446">此方法将写入其中的 <see cref="T:System.Xml.XmlWriter" />。</span><span class="sxs-lookup"><span data-stu-id="d621c-446">An <see cref="T:System.Xml.XmlWriter" /> into which this method will write.</span></span></param>
        <summary><span data-ttu-id="d621c-447">将此节点写入 <see cref="T:System.Xml.XmlWriter" />。</span><span class="sxs-lookup"><span data-stu-id="d621c-447">Writes this node to an <see cref="T:System.Xml.XmlWriter" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d621c-448">您可以使用此方法编写对非常大的文档进行流式转换的代码。</span><span class="sxs-lookup"><span data-stu-id="d621c-448">You can use this method to write code that does a streaming transform of a very large document.</span></span> <span data-ttu-id="d621c-449">有关详细信息，请参阅 [如何执行大型 XML 文档的流式转换](/dotnet/standard/linq/perform-streaming-transform-large-xml-documents)。</span><span class="sxs-lookup"><span data-stu-id="d621c-449">For more information, see [How to perform streaming transform of large XML documents](/dotnet/standard/linq/perform-streaming-transform-large-xml-documents).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d621c-450">下面的示例创建一个 <xref:System.Xml.XmlWriter> 写入的 <xref:System.Text.StringBuilder> 。</span><span class="sxs-lookup"><span data-stu-id="d621c-450">The following example creates an <xref:System.Xml.XmlWriter> that writes to a <xref:System.Text.StringBuilder>.</span></span> <span data-ttu-id="d621c-451">然后，它使用此方法将两个 XML 树写入编写器。</span><span class="sxs-lookup"><span data-stu-id="d621c-451">It then uses this method to write two XML trees to the writer.</span></span>  
  
```csharp  
StringBuilder sb = new StringBuilder();  
XmlWriterSettings xws = new XmlWriterSettings();  
xws.OmitXmlDeclaration = true;  
xws.Indent = true;  
  
using (XmlWriter xw = XmlWriter.Create(sb, xws)) {  
    xw.WriteStartElement("Root");  
    XElement child1 = new XElement("Child",  
        new XElement("GrandChild", "some content")  
    );  
    child1.WriteTo(xw);  
    XElement child2 = new XElement("AnotherChild",  
        new XElement("GrandChild", "different content")  
    );  
    child2.WriteTo(xw);  
    xw.WriteEndElement();  
}  
Console.WriteLine(sb.ToString());  
```  
  
```vb  
Dim sb As StringBuilder = New StringBuilder()  
Dim xws As XmlWriterSettings = New XmlWriterSettings()  
xws.OmitXmlDeclaration = True  
xws.Indent = True  
  
Using xw = XmlWriter.Create(sb, xws)  
    xw.WriteStartElement("Root")  
    Dim child1 As XElement = <Child>  
                                 <GrandChild>some content</GrandChild>  
                             </Child>  
    child1.WriteTo(xw)  
    Dim child2 As XElement = <AnotherChild>  
                                 <GrandChild>different content</GrandChild>  
                             </AnotherChild>  
    child2.WriteTo(xw)  
    xw.WriteEndElement()  
End Using  
  
Console.WriteLine(sb.ToString())  
```  
  
 <span data-ttu-id="d621c-452">该示例产生下面的输出：</span><span class="sxs-lookup"><span data-stu-id="d621c-452">This example produces the following output:</span></span>  
  
```xml  
<Root>  
  <Child>  
    <GrandChild>some content</GrandChild>  
  </Child>  
  <AnotherChild>  
    <GrandChild>different content</GrandChild>  
  </AnotherChild>  
</Root>  
```  
  
 ]]></format>
        </remarks>
        <related type="Article" href="/dotnet/standard/linq/linq-xml-overview"><span data-ttu-id="d621c-453">LINQ to XML 概述</span><span class="sxs-lookup"><span data-stu-id="d621c-453">LINQ to XML overview</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="WriteToAsync">
      <MemberSignature Language="C#" Value="public abstract System.Threading.Tasks.Task WriteToAsync (System.Xml.XmlWriter writer, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task WriteToAsync(class System.Xml.XmlWriter writer, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XNode.WriteToAsync(System.Xml.XmlWriter,System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function WriteToAsync (writer As XmlWriter, cancellationToken As CancellationToken) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Threading::Tasks::Task ^ WriteToAsync(System::Xml::XmlWriter ^ writer, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="abstract member WriteToAsync : System.Xml.XmlWriter * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="xNode.WriteToAsync (writer, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="writer"><span data-ttu-id="d621c-454">要将当前节点写入其中的编写器。</span><span class="sxs-lookup"><span data-stu-id="d621c-454">The writer to write the current node into.</span></span></param>
        <param name="cancellationToken"><span data-ttu-id="d621c-455">可用于请求异步操作取消的标志。</span><span class="sxs-lookup"><span data-stu-id="d621c-455">A token that can be used to request cancellation of the asynchronous operation.</span></span></param>
        <summary><span data-ttu-id="d621c-456">将当前节点写入到 <see cref="T:System.Xml.XmlWriter" />。</span><span class="sxs-lookup"><span data-stu-id="d621c-456">Writes the current node to an <see cref="T:System.Xml.XmlWriter" />.</span></span></summary>
        <returns><span data-ttu-id="d621c-457">表示异步写入操作的任务。</span><span class="sxs-lookup"><span data-stu-id="d621c-457">A task representing the asynchronous write operation.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
