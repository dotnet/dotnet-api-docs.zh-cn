<Type Name="XContainer" FullName="System.Xml.Linq.XContainer">
  <Metadata><Meta Name="ms.openlocfilehash" Value="e45c3e5515059f5ceb1554e569b9304878bce8e3" /><Meta Name="ms.sourcegitcommit" Value="13a6cb6fba7e05947f15d8d6cc802703ae9c21d5" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-CN" /><Meta Name="ms.lasthandoff" Value="09/18/2020" /><Meta Name="ms.locfileid" Value="90799259" /></Metadata><TypeSignature Language="C#" Value="public abstract class XContainer : System.Xml.Linq.XNode" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit XContainer extends System.Xml.Linq.XNode" />
  <TypeSignature Language="DocId" Value="T:System.Xml.Linq.XContainer" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class XContainer&#xA;Inherits XNode" />
  <TypeSignature Language="C++ CLI" Value="public ref class XContainer abstract : System::Xml::Linq::XNode" />
  <TypeSignature Language="F#" Value="type XContainer = class&#xA;    inherit XNode" />
  <AssemblyInfo>
    <AssemblyName>System.Xml.XDocument</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
    <AssemblyVersion>4.1.2.0</AssemblyVersion>
    <AssemblyVersion>5.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Xml.Linq</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>3.5.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeForwardingChain>
    <TypeForwarding From="System.Xml.Linq" FromVersion="4.0.0.0" To="System.Xml.XDocument" ToVersion="0.0.0.0" FrameworkAlternate="dotnet-uwp-10.0" />
    <TypeForwarding From="netstandard" FromVersion="2.1.0.0" To="System.Xml.XDocument" ToVersion="5.0.0.0" FrameworkAlternate="net-5.0" />
  </TypeForwardingChain>
  <Base>
    <BaseTypeName>System.Xml.Linq.XNode</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary><span data-ttu-id="1bc1c-101">表示可包含其他节点的节点。</span><span class="sxs-lookup"><span data-stu-id="1bc1c-101">Represents a node that can contain other nodes.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1bc1c-102">此类提供一些功能，例如查找下一个或上一个同级节点，或者枚举节点的直接子级。</span><span class="sxs-lookup"><span data-stu-id="1bc1c-102">This class provides functionality such as finding the next or previous sibling node, or enumerating the direct children of a node.</span></span>  
  
 <span data-ttu-id="1bc1c-103">派生自的两个类 <xref:System.Xml.Linq.XContainer> 为 <xref:System.Xml.Linq.XDocument> 和 <xref:System.Xml.Linq.XElement> 。</span><span class="sxs-lookup"><span data-stu-id="1bc1c-103">The two classes that derive from <xref:System.Xml.Linq.XContainer> are <xref:System.Xml.Linq.XDocument> and <xref:System.Xml.Linq.XElement>.</span></span>  
  
 ]]></format>
    </remarks>
    <related type="Article" href="/dotnet/standard/linq/linq-xml-overview"><span data-ttu-id="1bc1c-104">LINQ to XML 概述</span><span class="sxs-lookup"><span data-stu-id="1bc1c-104">LINQ to XML overview</span></span></related>
    <related type="Article" href="/dotnet/standard/linq/chain-axis-method-calls"><span data-ttu-id="1bc1c-105">如何链接轴方法调用</span><span class="sxs-lookup"><span data-stu-id="1bc1c-105">How to chain axis method calls</span></span></related>
  </Docs>
  <Members>
    <MemberGroup MemberName="Add">
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="1bc1c-106">将指定的内容作为子级添加到此 <see cref="T:System.Xml.Linq.XContainer" />。</span><span class="sxs-lookup"><span data-stu-id="1bc1c-106">Adds the specified content as children to this <see cref="T:System.Xml.Linq.XContainer" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1bc1c-107">此方法将新内容添加到的现有内容之后 <xref:System.Xml.Linq.XContainer> 。</span><span class="sxs-lookup"><span data-stu-id="1bc1c-107">This method adds the new content after the existing content of the <xref:System.Xml.Linq.XContainer>.</span></span>  
  
 <span data-ttu-id="1bc1c-108">有关可传递到此函数的有效内容的详细信息，请参阅 [system.xml.linq.xelement> 和 XDocument 对象的有效内容](/dotnet/standard/linq/valid-content-xelement-xdocument-objects)。</span><span class="sxs-lookup"><span data-stu-id="1bc1c-108">For details about the valid content that can be passed to this function, see [Valid Content of XElement and XDocument Objects](/dotnet/standard/linq/valid-content-xelement-xdocument-objects).</span></span>  
  
 <span data-ttu-id="1bc1c-109">此方法将引发 <xref:System.Xml.Linq.XObject.Changed> 和 <xref:System.Xml.Linq.XObject.Changing> 事件。</span><span class="sxs-lookup"><span data-stu-id="1bc1c-109">This method will raise the <xref:System.Xml.Linq.XObject.Changed> and the <xref:System.Xml.Linq.XObject.Changing> events.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="1bc1c-110">下面的示例创建两个 XML 树，然后使用此方法将查询结果添加到其中之一。</span><span class="sxs-lookup"><span data-stu-id="1bc1c-110">The following example creates two XML trees, and then uses this method to add the results of a query to one of them.</span></span>  
  
```csharp  
XElement srcTree = new XElement("Root",  
    new XElement("Element1", 1),  
    new XElement("Element2", 2),  
    new XElement("Element3", 3),  
    new XElement("Element4", 4),  
    new XElement("Element5", 5)  
);  
XElement xmlTree = new XElement("Root",  
    new XElement("NewElement", "Content")  
);  
xmlTree.Add(  
    from el in srcTree.Elements()  
    where (int)el >= 3  
    select el  
);  
Console.WriteLine(xmlTree);  
```  
  
```vb  
Dim srcTree As XElement = _  
        <Root>  
            <Element1>1</Element1>  
            <Element2>2</Element2>  
            <Element3>3</Element3>  
            <Element4>4</Element4>  
            <Element5>5</Element5>  
        </Root>  
Dim xmlTree As XElement = _   
        <Root>  
            <NewElement>Content</NewElement>  
        </Root>  
xmlTree.Add( _  
    From el In srcTree.Elements _  
    Where CInt(el) >= 3 _  
    Select el)  
Console.WriteLine(xmlTree)  
```  
  
 <span data-ttu-id="1bc1c-111">该示例产生下面的输出：</span><span class="sxs-lookup"><span data-stu-id="1bc1c-111">This example produces the following output:</span></span>  
  
```xml  
<Root>  
  <NewElement>Content</NewElement>  
  <Element3>3</Element3>  
  <Element4>4</Element4>  
  <Element5>5</Element5>  
</Root>  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Xml.Linq.XContainer.AddFirst" />
        <altmember cref="M:System.Xml.Linq.XContainer.RemoveNodes" />
        <altmember cref="Overload:System.Xml.Linq.XContainer.ReplaceNodes" />
        <related type="Article" href="/dotnet/standard/linq/linq-xml-overview"><span data-ttu-id="1bc1c-112">LINQ to XML 概述</span><span class="sxs-lookup"><span data-stu-id="1bc1c-112">LINQ to XML overview</span></span></related>
      </Docs>
    </MemberGroup>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public void Add (object content);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Add(object content) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XContainer.Add(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Add (content As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Add(System::Object ^ content);" />
      <MemberSignature Language="F#" Value="member this.Add : obj -&gt; unit" Usage="xContainer.Add content" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="content" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="content"><span data-ttu-id="1bc1c-113">要添加的包含简单内容的内容对象或内容对象集合。</span><span class="sxs-lookup"><span data-stu-id="1bc1c-113">A content object containing simple content or a collection of content objects to be added.</span></span></param>
        <summary><span data-ttu-id="1bc1c-114">将指定的内容添加为此 <see cref="T:System.Xml.Linq.XContainer" /> 的子级。</span><span class="sxs-lookup"><span data-stu-id="1bc1c-114">Adds the specified content as children of this <see cref="T:System.Xml.Linq.XContainer" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1bc1c-115">此方法将新内容添加到的现有内容之后 <xref:System.Xml.Linq.XContainer> 。</span><span class="sxs-lookup"><span data-stu-id="1bc1c-115">This method adds the new content after the existing content of the <xref:System.Xml.Linq.XContainer>.</span></span>  
  
 <span data-ttu-id="1bc1c-116">有关可传递到此函数的有效内容的详细信息，请参阅 [system.xml.linq.xelement> 和 XDocument 对象的有效内容](/dotnet/standard/linq/valid-content-xelement-xdocument-objects)。</span><span class="sxs-lookup"><span data-stu-id="1bc1c-116">For details about the valid content that can be passed to this function, see [Valid Content of XElement and XDocument Objects](/dotnet/standard/linq/valid-content-xelement-xdocument-objects).</span></span>  
  
 <span data-ttu-id="1bc1c-117">此方法将引发 <xref:System.Xml.Linq.XObject.Changed> 和 <xref:System.Xml.Linq.XObject.Changing> 事件。</span><span class="sxs-lookup"><span data-stu-id="1bc1c-117">This method will raise the <xref:System.Xml.Linq.XObject.Changed> and the <xref:System.Xml.Linq.XObject.Changing> events.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="1bc1c-118">下面的示例创建两个 XML 树，然后使用此方法将一个 <xref:System.Xml.Linq.XElement> 对象添加到其中一个。</span><span class="sxs-lookup"><span data-stu-id="1bc1c-118">The following example creates two XML trees, and then uses this method to add an <xref:System.Xml.Linq.XElement> object to one of them.</span></span> <span data-ttu-id="1bc1c-119">它还会将查询结果添加 [!INCLUDE[vbteclinq](~/includes/vbteclinq-md.md)] 到 XML 树中。</span><span class="sxs-lookup"><span data-stu-id="1bc1c-119">It also adds the results of a [!INCLUDE[vbteclinq](~/includes/vbteclinq-md.md)] query to the XML tree.</span></span>  
  
```csharp  
XElement srcTree = new XElement("Root",  
    new XElement("Element1", 1),  
    new XElement("Element2", 2),  
    new XElement("Element3", 3),  
    new XElement("Element4", 4),  
    new XElement("Element5", 5)  
);  
XElement xmlTree = new XElement("Root",  
    new XElement("Child1", 1),  
    new XElement("Child2", 2),  
    new XElement("Child3", 3),  
    new XElement("Child4", 4),  
    new XElement("Child5", 5)  
);  
xmlTree.Add(new XElement("NewChild", "new content"));  
xmlTree.Add(  
    from el in srcTree.Elements()  
    where (int)el > 3  
    select el  
);  
// Even though Child9 does not exist in srcTree, the following statement will not  
// throw an exception, and nothing will be added to xmlTree.  
xmlTree.Add(srcTree.Element("Child9"));  
Console.WriteLine(xmlTree);  
```  
  
```vb  
Dim srcTree As XElement = _   
        <Root>  
            <Element1>1</Element1>  
            <Element2>2</Element2>  
            <Element3>3</Element3>  
            <Element4>4</Element4>  
            <Element5>5</Element5>  
        </Root>  
  
Dim xmlTree As XElement = _   
        <Root>  
            <Child1>1</Child1>  
            <Child2>2</Child2>  
            <Child3>3</Child3>  
            <Child4>4</Child4>  
            <Child5>5</Child5>  
        </Root>  
  
xmlTree.Add(New XElement("NewChild", "new content"))  
xmlTree.Add( _  
    From el In srcTree.Elements() _  
    Where CInt(el) > 3 _  
    Select el _  
)  
' Even though Child9 does not exist in srcTree, the following statement will not  
' throw an exception, and nothing will be added to xmlTree.  
xmlTree.Add(srcTree.<Child9>)  
Console.WriteLine(xmlTree)  
  
```  
  
 <span data-ttu-id="1bc1c-120">该示例产生下面的输出：</span><span class="sxs-lookup"><span data-stu-id="1bc1c-120">This example produces the following output:</span></span>  
  
```xml  
<Root>  
  <Child1>1</Child1>  
  <Child2>2</Child2>  
  <Child3>3</Child3>  
  <Child4>4</Child4>  
  <Child5>5</Child5>  
  <NewChild>new content</NewChild>  
  <Element4>4</Element4>  
  <Element5>5</Element5>  
</Root>  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Xml.Linq.XContainer.AddFirst" />
        <altmember cref="M:System.Xml.Linq.XContainer.RemoveNodes" />
        <altmember cref="Overload:System.Xml.Linq.XContainer.ReplaceNodes" />
        <related type="Article" href="/dotnet/standard/linq/linq-xml-overview"><span data-ttu-id="1bc1c-121">LINQ to XML 概述</span><span class="sxs-lookup"><span data-stu-id="1bc1c-121">LINQ to XML overview</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public void Add (params object[] content);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Add(object[] content) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XContainer.Add(System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub Add (ParamArray content As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Add(... cli::array &lt;System::Object ^&gt; ^ content);" />
      <MemberSignature Language="F#" Value="member this.Add : obj[] -&gt; unit" Usage="xContainer.Add content" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="content" Type="System.Object[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName Language="C#">[System.ParamArray]</AttributeName>
              <AttributeName Language="F#">[&lt;System.ParamArray&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="content"><span data-ttu-id="1bc1c-122">内容对象的参数列表。</span><span class="sxs-lookup"><span data-stu-id="1bc1c-122">A parameter list of content objects.</span></span></param>
        <summary><span data-ttu-id="1bc1c-123">将指定的内容添加为此 <see cref="T:System.Xml.Linq.XContainer" /> 的子级。</span><span class="sxs-lookup"><span data-stu-id="1bc1c-123">Adds the specified content as children of this <see cref="T:System.Xml.Linq.XContainer" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1bc1c-124">此方法将新内容添加到的现有内容之后 <xref:System.Xml.Linq.XContainer> 。</span><span class="sxs-lookup"><span data-stu-id="1bc1c-124">This method adds the new content after the existing content of the <xref:System.Xml.Linq.XContainer>.</span></span>  
  
 <span data-ttu-id="1bc1c-125">有关可传递到此函数的有效内容的详细信息，请参阅 [system.xml.linq.xelement> 和 XDocument 对象的有效内容](/dotnet/standard/linq/valid-content-xelement-xdocument-objects)。</span><span class="sxs-lookup"><span data-stu-id="1bc1c-125">For details about the valid content that can be passed to this function, see [Valid Content of XElement and XDocument Objects](/dotnet/standard/linq/valid-content-xelement-xdocument-objects).</span></span>  
  
 <span data-ttu-id="1bc1c-126">此方法将引发 <xref:System.Xml.Linq.XObject.Changed> 和 <xref:System.Xml.Linq.XObject.Changing> 事件。</span><span class="sxs-lookup"><span data-stu-id="1bc1c-126">This method will raise the <xref:System.Xml.Linq.XObject.Changed> and the <xref:System.Xml.Linq.XObject.Changing> events.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="1bc1c-127">下面的示例创建两个 XML 树，并使用此方法将一个 <xref:System.Xml.Linq.XElement> 对象添加到其中一个。</span><span class="sxs-lookup"><span data-stu-id="1bc1c-127">The following example creates two XML trees, uses this method to add an <xref:System.Xml.Linq.XElement> object to one of them.</span></span> <span data-ttu-id="1bc1c-128">它还会将查询结果添加 [!INCLUDE[vbteclinq](~/includes/vbteclinq-md.md)] 到 XML 树中。</span><span class="sxs-lookup"><span data-stu-id="1bc1c-128">It also adds the results of a [!INCLUDE[vbteclinq](~/includes/vbteclinq-md.md)] query to the XML tree.</span></span>  
  
```csharp  
XElement srcTree = new XElement("Root",  
    new XElement("Element1", 1),  
    new XElement("Element2", 2),  
    new XElement("Element3", 3),  
    new XElement("Element4", 4),  
    new XElement("Element5", 5)  
);  
XElement xmlTree = new XElement("Root",  
    new XElement("Child1", 1),  
    new XElement("Child2", 2),  
    new XElement("Child3", 3),  
    new XElement("Child4", 4),  
    new XElement("Child5", 5)  
);  
xmlTree.Add(new XElement("NewChild", "new content"));  
xmlTree.Add(  
    from el in srcTree.Elements()  
    where (int)el > 3  
    select el  
);  
// Even though Child9 does not exist in srcTree, the following statement will not  
// throw an exception, and nothing will be added to xmlTree  
xmlTree.Add(srcTree.Element("Child9"));  
Console.WriteLine(xmlTree);  
```  
  
```vb  
Dim srcTree As XElement = _   
        <Root>  
            <Element1>1</Element1>  
            <Element2>2</Element2>  
            <Element3>3</Element3>  
            <Element4>4</Element4>  
            <Element5>5</Element5>  
        </Root>  
  
Dim xmlTree As XElement = _  
        <Root>  
            <Child1>1</Child1>  
            <Child2>2</Child2>  
            <Child3>3</Child3>  
            <Child4>4</Child4>  
            <Child5>5</Child5>  
        </Root>  
  
xmlTree.Add(New XElement("NewChild", "new content"))  
xmlTree.Add( _  
    From el In srcTree.Elements() _  
    Where CInt(el) > 3 _  
    Select el _  
)  
' Even though Child9 does not exist in srcTree, the following statement will not  
' throw an exception, and nothing will be added to xmlTree  
xmlTree.Add(srcTree.<Child9>)  
Console.WriteLine(xmlTree)  
```  
  
 <span data-ttu-id="1bc1c-129">该示例产生下面的输出：</span><span class="sxs-lookup"><span data-stu-id="1bc1c-129">This example produces the following output:</span></span>  
  
```xml  
<Root>  
  <Child1>1</Child1>  
  <Child2>2</Child2>  
  <Child3>3</Child3>  
  <Child4>4</Child4>  
  <Child5>5</Child5>  
  <NewChild>new content</NewChild>  
  <Element4>4</Element4>  
  <Element5>5</Element5>  
</Root>  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Xml.Linq.XContainer.AddFirst" />
        <altmember cref="M:System.Xml.Linq.XContainer.RemoveNodes" />
        <altmember cref="Overload:System.Xml.Linq.XContainer.ReplaceNodes" />
        <related type="Article" href="/dotnet/standard/linq/linq-xml-overview"><span data-ttu-id="1bc1c-130">LINQ to XML 概述</span><span class="sxs-lookup"><span data-stu-id="1bc1c-130">LINQ to XML overview</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="AddFirst">
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="1bc1c-131">将指定内容作为此文档或元素的第一个子级添加。</span><span class="sxs-lookup"><span data-stu-id="1bc1c-131">Adds the specified content as the first children of this document or element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1bc1c-132">此方法将新内容添加到的现有内容之前 <xref:System.Xml.Linq.XContainer> 。</span><span class="sxs-lookup"><span data-stu-id="1bc1c-132">This method adds the new content before the existing content of the <xref:System.Xml.Linq.XContainer>.</span></span>  
  
 <span data-ttu-id="1bc1c-133">有关可传递到此函数的有效内容的详细信息，请参阅 [system.xml.linq.xelement> 和 XDocument 对象的有效内容](/dotnet/standard/linq/valid-content-xelement-xdocument-objects)。</span><span class="sxs-lookup"><span data-stu-id="1bc1c-133">For details about the valid content that can be passed to this function, see [Valid Content of XElement and XDocument Objects](/dotnet/standard/linq/valid-content-xelement-xdocument-objects).</span></span>  
  
 <span data-ttu-id="1bc1c-134">此方法将引发 <xref:System.Xml.Linq.XObject.Changed> 和 <xref:System.Xml.Linq.XObject.Changing> 事件。</span><span class="sxs-lookup"><span data-stu-id="1bc1c-134">This method will raise the <xref:System.Xml.Linq.XObject.Changed> and the <xref:System.Xml.Linq.XObject.Changing> events.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="1bc1c-135">下面的示例创建两个 XML 树，然后使用此方法将查询结果添加到其中之一。</span><span class="sxs-lookup"><span data-stu-id="1bc1c-135">The following example creates two XML trees, and then uses this method to add the results of a query to one of them.</span></span>  
  
```csharp  
XElement srcTree = new XElement("Root",  
    new XElement("Element1", 1),  
    new XElement("Element2", 2),  
    new XElement("Element3", 3),  
    new XElement("Element4", 4),  
    new XElement("Element5", 5)  
);  
XElement xmlTree = new XElement("Root",  
    new XElement("NewElement", "Content")  
);  
xmlTree.AddFirst(  
    from el in srcTree.Elements()  
    where (int)el >= 3  
    select el  
);  
Console.WriteLine(xmlTree);  
```  
  
```vb  
Dim srcTree As XElement = _   
        <Root>  
            <Element1>1</Element1>  
            <Element2>2</Element2>  
            <Element3>3</Element3>  
            <Element4>4</Element4>  
            <Element5>5</Element5>  
        </Root>  
Dim xmlTree As XElement = <Root>  
                              <NewElement>Content</NewElement>  
                          </Root>  
xmlTree.AddFirst( _  
    From el In srcTree.Elements _  
    Where CInt(el) >= 3 _  
    Select el)  
Console.WriteLine(xmlTree)  
  
```  
  
 <span data-ttu-id="1bc1c-136">该示例产生下面的输出：</span><span class="sxs-lookup"><span data-stu-id="1bc1c-136">This example produces the following output:</span></span>  
  
```xml  
<Root>  
  <Element3>3</Element3>  
  <Element4>4</Element4>  
  <Element5>5</Element5>  
  <NewElement>Content</NewElement>  
</Root>  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Xml.Linq.XContainer.Add" />
        <altmember cref="M:System.Xml.Linq.XContainer.RemoveNodes" />
        <altmember cref="Overload:System.Xml.Linq.XContainer.ReplaceNodes" />
        <related type="Article" href="/dotnet/standard/linq/linq-xml-overview"><span data-ttu-id="1bc1c-137">LINQ to XML 概述</span><span class="sxs-lookup"><span data-stu-id="1bc1c-137">LINQ to XML overview</span></span></related>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddFirst">
      <MemberSignature Language="C#" Value="public void AddFirst (object content);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddFirst(object content) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XContainer.AddFirst(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddFirst (content As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddFirst(System::Object ^ content);" />
      <MemberSignature Language="F#" Value="member this.AddFirst : obj -&gt; unit" Usage="xContainer.AddFirst content" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="content" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="content"><span data-ttu-id="1bc1c-138">要添加的包含简单内容的内容对象或内容对象集合。</span><span class="sxs-lookup"><span data-stu-id="1bc1c-138">A content object containing simple content or a collection of content objects to be added.</span></span></param>
        <summary><span data-ttu-id="1bc1c-139">将指定内容作为此文档或元素的第一个子级添加。</span><span class="sxs-lookup"><span data-stu-id="1bc1c-139">Adds the specified content as the first children of this document or element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1bc1c-140">此方法将新内容添加到的现有内容之前 <xref:System.Xml.Linq.XContainer> 。</span><span class="sxs-lookup"><span data-stu-id="1bc1c-140">This method adds the new content before the existing content of the <xref:System.Xml.Linq.XContainer>.</span></span>  
  
 <span data-ttu-id="1bc1c-141">有关可传递到此函数的有效内容的详细信息，请参阅 [system.xml.linq.xelement> 和 XDocument 对象的有效内容](/dotnet/standard/linq/valid-content-xelement-xdocument-objects)。</span><span class="sxs-lookup"><span data-stu-id="1bc1c-141">For details about the valid content that can be passed to this function, see [Valid Content of XElement and XDocument Objects](/dotnet/standard/linq/valid-content-xelement-xdocument-objects).</span></span>  
  
 <span data-ttu-id="1bc1c-142">此方法将引发 <xref:System.Xml.Linq.XObject.Changed> 和 <xref:System.Xml.Linq.XObject.Changing> 事件。</span><span class="sxs-lookup"><span data-stu-id="1bc1c-142">This method will raise the <xref:System.Xml.Linq.XObject.Changed> and the <xref:System.Xml.Linq.XObject.Changing> events.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="1bc1c-143">下面的示例创建两个 XML 树，使用此方法将 <xref:System.Xml.Linq.XElement> 对象作为第一个元素添加到其中一个。</span><span class="sxs-lookup"><span data-stu-id="1bc1c-143">The following example creates two XML trees, uses this method to add an <xref:System.Xml.Linq.XElement> object as the first element to one of them.</span></span> <span data-ttu-id="1bc1c-144">它还会将查询结果添加 [!INCLUDE[vbteclinq](~/includes/vbteclinq-md.md)] 到 XML 树中。</span><span class="sxs-lookup"><span data-stu-id="1bc1c-144">It also adds the results of a [!INCLUDE[vbteclinq](~/includes/vbteclinq-md.md)] query to the XML tree.</span></span>  
  
```csharp  
XElement srcTree = new XElement("Root",  
    new XElement("Element1", 1),  
    new XElement("Element2", 2),  
    new XElement("Element3", 3),  
    new XElement("Element4", 4),  
    new XElement("Element5", 5)  
);  
XElement xmlTree = new XElement("Root",  
    new XElement("Child1", 1),  
    new XElement("Child2", 2),  
    new XElement("Child3", 3),  
    new XElement("Child4", 4),  
    new XElement("Child5", 5)  
);  
xmlTree.AddFirst(new XElement("NewChild", "new content"));  
xmlTree.AddFirst(  
    from el in srcTree.Elements()  
    where (int)el > 3  
    select el  
);  
// Even though Child9 does not exist in srcTree, the following statement will not  
// throw an exception, and nothing will be added to xmlTree  
xmlTree.AddFirst(srcTree.Element("Child9"));  
Console.WriteLine(xmlTree);  
```  
  
```vb  
Dim srcTree As XElement = _   
        <Root>  
            <Element1>1</Element1>  
            <Element2>2</Element2>  
            <Element3>3</Element3>  
            <Element4>4</Element4>  
            <Element5>5</Element5>  
        </Root>  
  
Dim xmlTree As XElement = _   
        <Root>  
            <Child1>1</Child1>  
            <Child2>2</Child2>  
            <Child3>3</Child3>  
            <Child4>4</Child4>  
            <Child5>5</Child5>  
        </Root>  
  
xmlTree.AddFirst(New XElement("NewChild", "new content"))  
xmlTree.AddFirst( _  
    From el In srcTree.Elements() _  
    Where CInt(el) > 3 _  
    Select el _  
)  
' Even though Child9 does not exist in srcTree, the following statement will not  
' throw an exception, and nothing will be added to xmlTree  
xmlTree.AddFirst(srcTree.<Child9>)  
Console.WriteLine(xmlTree)  
```  
  
 <span data-ttu-id="1bc1c-145">该示例产生下面的输出：</span><span class="sxs-lookup"><span data-stu-id="1bc1c-145">This example produces the following output:</span></span>  
  
```xml  
<Root>  
  <Element4>4</Element4>  
  <Element5>5</Element5>  
  <NewChild>new content</NewChild>  
  <Child1>1</Child1>  
  <Child2>2</Child2>  
  <Child3>3</Child3>  
  <Child4>4</Child4>  
  <Child5>5</Child5>  
</Root>  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Xml.Linq.XContainer.Add" />
        <altmember cref="M:System.Xml.Linq.XContainer.RemoveNodes" />
        <altmember cref="Overload:System.Xml.Linq.XContainer.ReplaceNodes" />
        <related type="Article" href="/dotnet/standard/linq/linq-xml-overview"><span data-ttu-id="1bc1c-146">LINQ to XML 概述</span><span class="sxs-lookup"><span data-stu-id="1bc1c-146">LINQ to XML overview</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="AddFirst">
      <MemberSignature Language="C#" Value="public void AddFirst (params object[] content);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddFirst(object[] content) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XContainer.AddFirst(System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddFirst (ParamArray content As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddFirst(... cli::array &lt;System::Object ^&gt; ^ content);" />
      <MemberSignature Language="F#" Value="member this.AddFirst : obj[] -&gt; unit" Usage="xContainer.AddFirst content" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="content" Type="System.Object[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName Language="C#">[System.ParamArray]</AttributeName>
              <AttributeName Language="F#">[&lt;System.ParamArray&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="content"><span data-ttu-id="1bc1c-147">内容对象的参数列表。</span><span class="sxs-lookup"><span data-stu-id="1bc1c-147">A parameter list of content objects.</span></span></param>
        <summary><span data-ttu-id="1bc1c-148">将指定内容作为此文档或元素的第一个子级添加。</span><span class="sxs-lookup"><span data-stu-id="1bc1c-148">Adds the specified content as the first children of this document or element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1bc1c-149">此方法将新内容添加到的现有内容之前 <xref:System.Xml.Linq.XContainer> 。</span><span class="sxs-lookup"><span data-stu-id="1bc1c-149">This method adds the new content before the existing content of the <xref:System.Xml.Linq.XContainer>.</span></span>  
  
 <span data-ttu-id="1bc1c-150">有关可传递到此函数的有效内容的详细信息，请参阅 [system.xml.linq.xelement> 和 XDocument 对象的有效内容](/dotnet/standard/linq/valid-content-xelement-xdocument-objects)。</span><span class="sxs-lookup"><span data-stu-id="1bc1c-150">For details about the valid content that can be passed to this function, see [Valid Content of XElement and XDocument Objects](/dotnet/standard/linq/valid-content-xelement-xdocument-objects).</span></span>  
  
 <span data-ttu-id="1bc1c-151">此方法将引发 <xref:System.Xml.Linq.XObject.Changed> 和 <xref:System.Xml.Linq.XObject.Changing> 事件。</span><span class="sxs-lookup"><span data-stu-id="1bc1c-151">This method will raise the <xref:System.Xml.Linq.XObject.Changed> and the <xref:System.Xml.Linq.XObject.Changing> events.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="1bc1c-152">下面的示例创建两个 XML 树，并使用此方法将 <xref:System.Xml.Linq.XElement> 对象作为第一个元素添加到其中一个。</span><span class="sxs-lookup"><span data-stu-id="1bc1c-152">The following example creates two XML trees, and uses this method to add an <xref:System.Xml.Linq.XElement> object as the first element to one of them.</span></span> <span data-ttu-id="1bc1c-153">它还会将查询结果添加 [!INCLUDE[vbteclinq](~/includes/vbteclinq-md.md)] 到 XML 树中。</span><span class="sxs-lookup"><span data-stu-id="1bc1c-153">It also adds the results of a [!INCLUDE[vbteclinq](~/includes/vbteclinq-md.md)] query to the XML tree.</span></span>  
  
```csharp  
XElement srcTree = new XElement("Root",  
    new XElement("Element1", 1),  
    new XElement("Element2", 2),  
    new XElement("Element3", 3),  
    new XElement("Element4", 4),  
    new XElement("Element5", 5)  
);  
XElement xmlTree = new XElement("Root",  
    new XElement("Child1", 1),  
    new XElement("Child2", 2),  
    new XElement("Child3", 3),  
    new XElement("Child4", 4),  
    new XElement("Child5", 5)  
);  
xmlTree.AddFirst(new XElement("NewChild", "new content"));  
xmlTree.AddFirst(  
    from el in srcTree.Elements()  
    where (int)el > 3  
    select el  
);  
// Even though Child9 does not exist in srcTree, the following statement will not  
// throw an exception, and nothing will be added to xmlTree.  
xmlTree.AddFirst(srcTree.Element("Child9"));  
Console.WriteLine(xmlTree);  
```  
  
```vb  
Dim srcTree As XElement = _   
        <Root>  
            <Element1>1</Element1>  
            <Element2>2</Element2>  
            <Element3>3</Element3>  
            <Element4>4</Element4>  
            <Element5>5</Element5>  
        </Root>  
  
Dim xmlTree As XElement = _   
        <Root>  
            <Child1>1</Child1>  
            <Child2>2</Child2>  
            <Child3>3</Child3>  
            <Child4>4</Child4>  
            <Child5>5</Child5>  
        </Root>  
  
xmlTree.AddFirst(New XElement("NewChild", "new content"))  
xmlTree.AddFirst( _  
    From el In srcTree.Elements() _  
    Where CInt(el) > 3 _  
    Select el _  
)  
' Even though Child9 does not exist in srcTree, the following statement will not  
' throw an exception, and nothing will be added to xmlTree.  
xmlTree.AddFirst(srcTree.<Child9>)  
Console.WriteLine(xmlTree)  
```  
  
 <span data-ttu-id="1bc1c-154">该示例产生下面的输出：</span><span class="sxs-lookup"><span data-stu-id="1bc1c-154">This example produces the following output:</span></span>  
  
```xml  
<Root>  
  <Element4>4</Element4>  
  <Element5>5</Element5>  
  <NewChild>new content</NewChild>  
  <Child1>1</Child1>  
  <Child2>2</Child2>  
  <Child3>3</Child3>  
  <Child4>4</Child4>  
  <Child5>5</Child5>  
</Root>  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="1bc1c-155">父级为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="1bc1c-155">The parent is <see langword="null" />.</span></span></exception>
        <altmember cref="Overload:System.Xml.Linq.XContainer.Add" />
        <altmember cref="M:System.Xml.Linq.XContainer.RemoveNodes" />
        <altmember cref="Overload:System.Xml.Linq.XContainer.ReplaceNodes" />
        <related type="Article" href="/dotnet/standard/linq/linq-xml-overview"><span data-ttu-id="1bc1c-156">LINQ to XML 概述</span><span class="sxs-lookup"><span data-stu-id="1bc1c-156">LINQ to XML overview</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="CreateWriter">
      <MemberSignature Language="C#" Value="public System.Xml.XmlWriter CreateWriter ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Xml.XmlWriter CreateWriter() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XContainer.CreateWriter" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateWriter () As XmlWriter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Xml::XmlWriter ^ CreateWriter();" />
      <MemberSignature Language="F#" Value="member this.CreateWriter : unit -&gt; System.Xml.XmlWriter" Usage="xContainer.CreateWriter " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlWriter</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="1bc1c-157">创建可用于将节点添加至 <see cref="T:System.Xml.Linq.XContainer" /> 的 <see cref="T:System.Xml.XmlWriter" />。</span><span class="sxs-lookup"><span data-stu-id="1bc1c-157">Creates an <see cref="T:System.Xml.XmlWriter" /> that can be used to add nodes to the <see cref="T:System.Xml.Linq.XContainer" />.</span></span></summary>
        <returns><span data-ttu-id="1bc1c-158">已准备好写入内容的 <see cref="T:System.Xml.XmlWriter" />。</span><span class="sxs-lookup"><span data-stu-id="1bc1c-158">An <see cref="T:System.Xml.XmlWriter" /> that is ready to have content written to it.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1bc1c-159">序列化时，将从 XML 树中的命名空间特性推断命名空间前缀。</span><span class="sxs-lookup"><span data-stu-id="1bc1c-159">While serializing, namespace prefixes are inferred from the namespace attributes in the XML tree.</span></span>  
  
 <span data-ttu-id="1bc1c-160">有关详细信息，请参阅 [使用 XML 命名空间](/dotnet/standard/linq/namespaces-overview)。</span><span class="sxs-lookup"><span data-stu-id="1bc1c-160">For more information, see [Work with XML Namespaces](/dotnet/standard/linq/namespaces-overview).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="1bc1c-161">可以使用此方法执行 XSLT 转换。</span><span class="sxs-lookup"><span data-stu-id="1bc1c-161">You can use this method to perform an XSLT transformation.</span></span> <span data-ttu-id="1bc1c-162">您可以创建一个 XML 树， <xref:System.Xml.XmlReader> 从 XML 树创建一个，创建一个新文档，然后创建一个 <xref:System.Xml.XmlWriter> 将写入到新文档中的。</span><span class="sxs-lookup"><span data-stu-id="1bc1c-162">You can create an XML tree, create an <xref:System.Xml.XmlReader> from the XML tree, create a new document, and create a <xref:System.Xml.XmlWriter> that will write into the new document.</span></span> <span data-ttu-id="1bc1c-163">然后，可以调用 XSLT 转换，并将和传递 <xref:System.Xml.XmlReader> <xref:System.Xml.XmlWriter> 到转换。</span><span class="sxs-lookup"><span data-stu-id="1bc1c-163">Then, you can invoke the XSLT transformation, passing the <xref:System.Xml.XmlReader> and <xref:System.Xml.XmlWriter> to the transform.</span></span> <span data-ttu-id="1bc1c-164">在转换成功完成后，使用转换的结果，填充新的 XML 树。</span><span class="sxs-lookup"><span data-stu-id="1bc1c-164">After the transformation successfully completes, the new XML tree is populated with the results of the transformation.</span></span>  
  
```csharp  
string xslMarkup = @"<?xml version='1.0'?>  
<xsl:stylesheet xmlns:xsl='http://www.w3.org/1999/XSL/Transform' version='1.0'>  
    <xsl:template match='/Parent'>  
        <Root>  
            <C1><xsl:value-of select='Child1'/></C1>  
            <C2><xsl:value-of select='Child2'/></C2>  
        </Root>  
    </xsl:template>  
</xsl:stylesheet>";  
  
XDocument xmlTree = new XDocument(  
    new XElement("Parent",  
        new XElement("Child1", "Child1 data"),  
        new XElement("Child2", "Child2 data")  
    )  
);  
  
XDocument newTree = new XDocument();  
using (XmlWriter writer = newTree.CreateWriter()) {  
    // Load the style sheet.  
    XslCompiledTransform xslt = new XslCompiledTransform();  
    xslt.Load(XmlReader.Create(new StringReader(xslMarkup)));  
  
    // Execute the transform and output the results to a writer.  
    xslt.Transform(xmlTree.CreateReader(), writer);  
}  
  
Console.WriteLine(newTree);  
```  
  
```vb  
Dim xslMarkup As XDocument = _   
    <?xml version='1.0'?>  
    <xsl:stylesheet xmlns:xsl='http://www.w3.org/1999/XSL/Transform' version='1.0'>  
        <xsl:template match='/Parent'>  
            <Root>  
                <C1><xsl:value-of select='Child1'/></C1>  
                <C2><xsl:value-of select='Child2'/></C2>  
            </Root>  
        </xsl:template>  
    </xsl:stylesheet>  
  
Dim xmlTree As XElement = _   
    <Parent>  
        <Child1>Child1 data</Child1>  
        <Child2>Child2 data</Child2>  
    </Parent>  
  
Dim newTree As XDocument = New XDocument()  
  
Using writer As XmlWriter = newTree.CreateWriter()  
    ' Load the style sheet.  
    Dim xslt As XslCompiledTransform = _  
        New XslCompiledTransform()  
    xslt.Load(xslMarkup.CreateReader())  
  
    ' Execute the transform and output the results to a writer.  
    xslt.Transform(xmlTree.CreateReader(), writer)  
End Using  
  
Console.WriteLine(newTree)  
```  
  
 <span data-ttu-id="1bc1c-165">该示例产生下面的输出：</span><span class="sxs-lookup"><span data-stu-id="1bc1c-165">This example produces the following output:</span></span>  
  
```xml  
<Root>  
  <C1>Child1 data</C1>  
  <C2>Child2 data</C2>  
</Root>  
```  
  
 ]]></format>
        </remarks>
        <related type="Article" href="/dotnet/standard/linq/linq-xml-overview"><span data-ttu-id="1bc1c-166">LINQ to XML 概述</span><span class="sxs-lookup"><span data-stu-id="1bc1c-166">LINQ to XML overview</span></span></related>
        <related type="Article" href="/dotnet/standard/linq/serialize-files-textwriters-xmlwriters"><span data-ttu-id="1bc1c-167">序列化为文件、TextWriter 和 XmlWriter</span><span class="sxs-lookup"><span data-stu-id="1bc1c-167">Serialize to files, TextWriters, and XmlWriters</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="DescendantNodes">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.Xml.Linq.XNode&gt; DescendantNodes ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;class System.Xml.Linq.XNode&gt; DescendantNodes() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XContainer.DescendantNodes" />
      <MemberSignature Language="VB.NET" Value="Public Function DescendantNodes () As IEnumerable(Of XNode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IEnumerable&lt;System::Xml::Linq::XNode ^&gt; ^ DescendantNodes();" />
      <MemberSignature Language="F#" Value="member this.DescendantNodes : unit -&gt; seq&lt;System.Xml.Linq.XNode&gt;" Usage="xContainer.DescendantNodes " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Xml.Linq.XNode&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="1bc1c-168">按文档顺序返回此文档或元素的子代节点集合。</span><span class="sxs-lookup"><span data-stu-id="1bc1c-168">Returns a collection of the descendant nodes for this document or element, in document order.</span></span></summary>
        <returns><span data-ttu-id="1bc1c-169"><see cref="T:System.Xml.Linq.XNode" /> 的 <see cref="T:System.Collections.Generic.IEnumerable`1" />，其中按文档顺序包含 <see cref="T:System.Xml.Linq.XContainer" /> 的子代节点。</span><span class="sxs-lookup"><span data-stu-id="1bc1c-169">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> of <see cref="T:System.Xml.Linq.XNode" /> containing the descendant nodes of the <see cref="T:System.Xml.Linq.XContainer" />, in document order.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1bc1c-170">请注意，属性不被视为中的节点 [!INCLUDE[sqltecxlinq](~/includes/sqltecxlinq-md.md)] ，因此它们将不是此方法返回的集合的一部分。</span><span class="sxs-lookup"><span data-stu-id="1bc1c-170">Note that attributes are not considered to be nodes in [!INCLUDE[sqltecxlinq](~/includes/sqltecxlinq-md.md)], so they will not be part of the collection that is returned by this method.</span></span>  
  
 <span data-ttu-id="1bc1c-171">此方法使用延迟执行。</span><span class="sxs-lookup"><span data-stu-id="1bc1c-171">This method uses deferred execution.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="1bc1c-172">下面的示例创建一个 XML 树，然后循环访问该 <xref:System.Xml.Linq.XContainer.DescendantNodes%2A> 轴。</span><span class="sxs-lookup"><span data-stu-id="1bc1c-172">The following example creates an XML tree, and then iterates through the <xref:System.Xml.Linq.XContainer.DescendantNodes%2A> axis.</span></span>  
  
```csharp  
XElement xmlTree = new XElement("Root",  
    // Attributes are not nodes, so will not be returned by DescendantNodes.  
    new XAttribute("Att1", "AttributeContent"),  
    new XElement("Child",  
        new XElement("GrandChild", "element content")  
    )  
);  
IEnumerable<XNode> dnas =  
    from node in xmlTree.DescendantNodes()  
    select node;  
foreach (XNode node in dnas)  
{  
    if (node is XElement)  
        Console.WriteLine((node as XElement).Name);  
    else  
        Console.WriteLine(node);  
}  
```  
  
```vb  
' Attributes are not nodes, so will not be returned by DescendantNodes.  
Dim xmlTree As XElement = _   
    <Root Att1="AttributeContent">  
        <Child>  
            <GrandChild>element content</GrandChild>  
        </Child>  
    </Root>  
  
Dim dnas = From node In xmlTree.DescendantNodes _  
           Select node  
  
For Each node In dnas  
    If TypeOf node Is XElement Then  
        Console.WriteLine(DirectCast(node, XElement).Name)  
    Else  
        Console.WriteLine(node)  
    End If  
Next  
```  
  
 <span data-ttu-id="1bc1c-173">该示例产生下面的输出：</span><span class="sxs-lookup"><span data-stu-id="1bc1c-173">This example produces the following output:</span></span>  
  
```  
Child  
GrandChild  
element content  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Xml.Linq.XContainer.Descendants" />
        <altmember cref="Overload:System.Xml.Linq.XContainer.Elements" />
        <related type="Article" href="/dotnet/standard/linq/linq-xml-overview"><span data-ttu-id="1bc1c-174">LINQ to XML 概述</span><span class="sxs-lookup"><span data-stu-id="1bc1c-174">LINQ to XML overview</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Descendants">
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="1bc1c-175">按文档顺序返回此文档或元素的子代元素集合。</span><span class="sxs-lookup"><span data-stu-id="1bc1c-175">Returns a collection of the descendant elements for this document or element, in document order.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1bc1c-176">此方法使用延迟执行。</span><span class="sxs-lookup"><span data-stu-id="1bc1c-176">This method uses deferred execution.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Xml.Linq.XContainer.DescendantNodes" />
        <altmember cref="Overload:System.Xml.Linq.XContainer.Elements" />
        <related type="Article" href="/dotnet/standard/linq/linq-xml-overview"><span data-ttu-id="1bc1c-177">LINQ to XML 概述</span><span class="sxs-lookup"><span data-stu-id="1bc1c-177">LINQ to XML overview</span></span></related>
      </Docs>
    </MemberGroup>
    <Member MemberName="Descendants">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.Xml.Linq.XElement&gt; Descendants ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;class System.Xml.Linq.XElement&gt; Descendants() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XContainer.Descendants" />
      <MemberSignature Language="VB.NET" Value="Public Function Descendants () As IEnumerable(Of XElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IEnumerable&lt;System::Xml::Linq::XElement ^&gt; ^ Descendants();" />
      <MemberSignature Language="F#" Value="member this.Descendants : unit -&gt; seq&lt;System.Xml.Linq.XElement&gt;" Usage="xContainer.Descendants " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Xml.Linq.XElement&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="1bc1c-178">按文档顺序返回此文档或元素的子代元素集合。</span><span class="sxs-lookup"><span data-stu-id="1bc1c-178">Returns a collection of the descendant elements for this document or element, in document order.</span></span></summary>
        <returns><span data-ttu-id="1bc1c-179"><see cref="T:System.Xml.Linq.XElement" /> 的 <see cref="T:System.Collections.Generic.IEnumerable`1" />，其中包含 <see cref="T:System.Xml.Linq.XContainer" /> 的子代元素。</span><span class="sxs-lookup"><span data-stu-id="1bc1c-179">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> of <see cref="T:System.Xml.Linq.XElement" /> containing the descendant elements of the <see cref="T:System.Xml.Linq.XContainer" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1bc1c-180">请注意，此方法不会在生成的中返回自身 <xref:System.Collections.Generic.IEnumerable%601> 。</span><span class="sxs-lookup"><span data-stu-id="1bc1c-180">Note that this method will not return itself in the resulting <xref:System.Collections.Generic.IEnumerable%601>.</span></span> <span data-ttu-id="1bc1c-181">查看 <xref:System.Xml.Linq.XElement.DescendantsAndSelf%2A> 是否需要 <xref:System.Xml.Linq.XElement> 在结果中包含当前。</span><span class="sxs-lookup"><span data-stu-id="1bc1c-181">See <xref:System.Xml.Linq.XElement.DescendantsAndSelf%2A> if you need to include the current <xref:System.Xml.Linq.XElement> in the results.</span></span>  
  
 <span data-ttu-id="1bc1c-182">此方法使用延迟执行。</span><span class="sxs-lookup"><span data-stu-id="1bc1c-182">This method uses deferred execution.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="1bc1c-183">下面的示例创建一个 XML 树，然后使用此轴方法来检索子代。</span><span class="sxs-lookup"><span data-stu-id="1bc1c-183">The following example creates an XML tree, and then uses this axis method to retrieve the descendants.</span></span>  
  
```csharp  
XElement xmlTree = new XElement("Root",  
    new XAttribute("Att1", "AttributeContent"),  
    new XElement("Child",  
        new XText("Some text"),  
        new XElement("GrandChild", "element content")  
    )  
);  
IEnumerable<XElement> de =  
    from el in xmlTree.Descendants()  
    select el;  
foreach (XElement el in de)  
    Console.WriteLine(el.Name);  
```  
  
```vb  
' Attributes are not nodes, so will not be returned by DescendantNodes.  
Dim xmlTree As XElement = _  
    <Root Att1="AttributeContent">  
        <Child>Some text  
            <GrandChild>element content</GrandChild>  
        </Child>  
    </Root>  
Dim de = From el In xmlTree.Descendants _  
         Select el  
  
For Each el In de  
    Console.WriteLine(el.Name)  
Next  
```  
  
 <span data-ttu-id="1bc1c-184">该示例产生下面的输出：</span><span class="sxs-lookup"><span data-stu-id="1bc1c-184">This example produces the following output:</span></span>  
  
```  
Child  
GrandChild  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Xml.Linq.XElement.DescendantsAndSelf" />
        <altmember cref="M:System.Xml.Linq.XContainer.DescendantNodes" />
        <altmember cref="Overload:System.Xml.Linq.XContainer.Elements" />
        <related type="Article" href="/dotnet/standard/linq/linq-xml-overview"><span data-ttu-id="1bc1c-185">LINQ to XML 概述</span><span class="sxs-lookup"><span data-stu-id="1bc1c-185">LINQ to XML overview</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Descendants">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.Xml.Linq.XElement&gt; Descendants (System.Xml.Linq.XName name);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;class System.Xml.Linq.XElement&gt; Descendants(class System.Xml.Linq.XName name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XContainer.Descendants(System.Xml.Linq.XName)" />
      <MemberSignature Language="VB.NET" Value="Public Function Descendants (name As XName) As IEnumerable(Of XElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IEnumerable&lt;System::Xml::Linq::XElement ^&gt; ^ Descendants(System::Xml::Linq::XName ^ name);" />
      <MemberSignature Language="F#" Value="member this.Descendants : System.Xml.Linq.XName -&gt; seq&lt;System.Xml.Linq.XElement&gt;" Usage="xContainer.Descendants name" />
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.Xml.Linq.XElement&gt; Descendants (System.Xml.Linq.XName? name);" FrameworkAlternate="net-5.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Xml.Linq.XElement&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Xml.Linq.XName" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="1bc1c-186">要匹配的 <see cref="T:System.Xml.Linq.XName" />。</span><span class="sxs-lookup"><span data-stu-id="1bc1c-186">The <see cref="T:System.Xml.Linq.XName" /> to match.</span></span></param>
        <summary><span data-ttu-id="1bc1c-187">按文档顺序返回此文档或元素的已筛选的子代元素集合。</span><span class="sxs-lookup"><span data-stu-id="1bc1c-187">Returns a filtered collection of the descendant elements for this document or element, in document order.</span></span> <span data-ttu-id="1bc1c-188">集合中仅包括具有匹配 <see cref="T:System.Xml.Linq.XName" /> 的元素。</span><span class="sxs-lookup"><span data-stu-id="1bc1c-188">Only elements that have a matching <see cref="T:System.Xml.Linq.XName" /> are included in the collection.</span></span></summary>
        <returns><span data-ttu-id="1bc1c-189"><see cref="T:System.Xml.Linq.XElement" /> 的 <see cref="T:System.Collections.Generic.IEnumerable`1" />，其中包含与指定 <see cref="T:System.Xml.Linq.XName" /> 相匹配的 <see cref="T:System.Xml.Linq.XContainer" /> 的子代元素。</span><span class="sxs-lookup"><span data-stu-id="1bc1c-189">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> of <see cref="T:System.Xml.Linq.XElement" /> containing the descendant elements of the <see cref="T:System.Xml.Linq.XContainer" /> that match the specified <see cref="T:System.Xml.Linq.XName" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1bc1c-190">此方法使用延迟执行。</span><span class="sxs-lookup"><span data-stu-id="1bc1c-190">This method uses deferred execution.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="1bc1c-191">下面的示例打印元素的所有子代。</span><span class="sxs-lookup"><span data-stu-id="1bc1c-191">The following example prints all descendants of an element.</span></span>  
  
```csharp  
// Attributes are not nodes, so will not be returned by DescendantNodes.  
XElement xmlTree = new XElement("Root",  
    new XAttribute("Att1", "AttributeContent"),  
    new XElement("Child",  
        new XText("Some text"),  
        new XElement("GrandChild", "element content")  
    )  
);  
IEnumerable<XElement> de =  
    from el in xmlTree.Descendants("Child")  
    select el;  
foreach (XElement el in de)  
    Console.WriteLine(el.Name);  
```  
  
```vb  
' Attributes are not nodes, so will not be returned by the descendants axis.  
Dim xmlTree As XElement = _   
    <Root Att1="AttributeContent">  
         <Child>Some text  
             <GrandChild>element content</GrandChild>  
         </Child>  
     </Root>  
  
Dim de = From el In xmlTree...<Child> _  
         Select el  
  
For Each el In de  
    Console.WriteLine(el.Name)  
Next  
```  
  
 <span data-ttu-id="1bc1c-192">该示例产生下面的输出：</span><span class="sxs-lookup"><span data-stu-id="1bc1c-192">This example produces the following output:</span></span>  
  
```  
Child  
```  
  
 <span data-ttu-id="1bc1c-193">下面是同一个示例，但在这种情况下，XML 位于命名空间中。</span><span class="sxs-lookup"><span data-stu-id="1bc1c-193">The following is the same example, but in this case the XML is in a namespace.</span></span> <span data-ttu-id="1bc1c-194">有关详细信息，请参阅 [使用 XML 命名空间](/dotnet/standard/linq/namespaces-overview)。</span><span class="sxs-lookup"><span data-stu-id="1bc1c-194">For more information, see [Work with XML Namespaces](/dotnet/standard/linq/namespaces-overview).</span></span>  
  
```csharp  
// Attributes are not nodes, so will not be returned by DescendantNodes.  
XNamespace aw = "http://www.adventure-works.com";  
XElement xmlTree = new XElement(aw + "Root",  
    new XAttribute(aw + "Att1", "AttributeContent"),  
    new XElement(aw + "Child",  
        new XText("Some text"),  
        new XElement(aw + "GrandChild", "element content")  
    )  
);  
IEnumerable<XElement> de =  
    from el in xmlTree.Descendants(aw + "Child")  
    select el;  
foreach (XElement el in de)  
    Console.WriteLine(el.Name);  
```  
  
```vb  
Imports <xmlns:aw = "http://www.adventure-works.com">  
  
Module Module1  
    Sub Main()  
        ' Attributes are not nodes, so will not be returned by the descendants axis.  
        Dim xmlTree As XElement = _   
            <aw:Root aw:Att1="AttributeContent">  
                 <aw:Child>Some text  
                     <aw:GrandChild>element content</aw:GrandChild>  
                 </aw:Child>  
             </aw:Root>  
  
        Dim de = From el In xmlTree...<aw:Child> _  
                 Select el  
  
        For Each el In de  
            Console.WriteLine(el.Name)  
        Next  
    End Sub  
End Module  
```  
  
 <span data-ttu-id="1bc1c-195">该示例产生下面的输出：</span><span class="sxs-lookup"><span data-stu-id="1bc1c-195">This example produces the following output:</span></span>  
  
```  
{http://www.adventure-works.com}Child  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Xml.Linq.XContainer.DescendantNodes" />
        <altmember cref="Overload:System.Xml.Linq.XContainer.Elements" />
        <related type="Article" href="/dotnet/standard/linq/linq-xml-overview"><span data-ttu-id="1bc1c-196">LINQ to XML 概述</span><span class="sxs-lookup"><span data-stu-id="1bc1c-196">LINQ to XML overview</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Element">
      <MemberSignature Language="C#" Value="public System.Xml.Linq.XElement Element (System.Xml.Linq.XName name);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Xml.Linq.XElement Element(class System.Xml.Linq.XName name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XContainer.Element(System.Xml.Linq.XName)" />
      <MemberSignature Language="VB.NET" Value="Public Function Element (name As XName) As XElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Xml::Linq::XElement ^ Element(System::Xml::Linq::XName ^ name);" />
      <MemberSignature Language="F#" Value="member this.Element : System.Xml.Linq.XName -&gt; System.Xml.Linq.XElement" Usage="xContainer.Element name" />
      <MemberSignature Language="C#" Value="public System.Xml.Linq.XElement? Element (System.Xml.Linq.XName name);" FrameworkAlternate="net-5.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Linq.XElement</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Xml.Linq.XName" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="1bc1c-197">要匹配的 <see cref="T:System.Xml.Linq.XName" />。</span><span class="sxs-lookup"><span data-stu-id="1bc1c-197">The <see cref="T:System.Xml.Linq.XName" /> to match.</span></span></param>
        <summary><span data-ttu-id="1bc1c-198">获取具有指定的 <see cref="T:System.Xml.Linq.XName" /> 的第一个（按文档顺序）子元素。</span><span class="sxs-lookup"><span data-stu-id="1bc1c-198">Gets the first (in document order) child element with the specified <see cref="T:System.Xml.Linq.XName" />.</span></span></summary>
        <returns><span data-ttu-id="1bc1c-199">与指定的 <see cref="T:System.Xml.Linq.XName" /> 相匹配的 <see cref="T:System.Xml.Linq.XElement" />，或者为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="1bc1c-199">A <see cref="T:System.Xml.Linq.XElement" /> that matches the specified <see cref="T:System.Xml.Linq.XName" />, or <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1bc1c-200">`null`如果不存在具有指定名称的元素，则返回。</span><span class="sxs-lookup"><span data-stu-id="1bc1c-200">Returns `null` if there is no element with the specified name.</span></span>  
  
 <span data-ttu-id="1bc1c-201">某些轴方法返回元素或属性的集合。</span><span class="sxs-lookup"><span data-stu-id="1bc1c-201">Some axis methods return collections of elements or attributes.</span></span> <span data-ttu-id="1bc1c-202">此方法只返回一个元素。</span><span class="sxs-lookup"><span data-stu-id="1bc1c-202">This method returns only a single element.</span></span>  
  
 <span data-ttu-id="1bc1c-203">`null`如果找不到具有指定名称的元素，此方法将返回。</span><span class="sxs-lookup"><span data-stu-id="1bc1c-203">This method returns `null` if the element with the specified name is not found.</span></span> <span data-ttu-id="1bc1c-204">所有方法都允许您 (构造函数的构造函数 <xref:System.Xml.Linq.XElement> ， <xref:System.Xml.Linq.XContainer.Add%2A>) 接受 `null` 为有效参数。</span><span class="sxs-lookup"><span data-stu-id="1bc1c-204">All of the methods that allow you to construct elements (the constructor of <xref:System.Xml.Linq.XElement>, <xref:System.Xml.Linq.XContainer.Add%2A>, and so on) accept `null` as a valid argument.</span></span> <span data-ttu-id="1bc1c-205">这使您可以使用一个便利的方法：可以调用此方法作为函数构造的一部分，当且仅当该元素存在于源树中时，该元素将添加到正在构造的 XML 树中。</span><span class="sxs-lookup"><span data-stu-id="1bc1c-205">This allows you to use a convenient idiom: you can call this method as part of functional construction, and the element is added to the XML tree being constructed if and only if the element exists in the source tree.</span></span> <span data-ttu-id="1bc1c-206">下面的示例演示了这种用法。</span><span class="sxs-lookup"><span data-stu-id="1bc1c-206">The following example shows this idiom.</span></span>  
  
 <span data-ttu-id="1bc1c-207">与相比 <xref:System.Xml.Linq.XContainer.Elements%2A> ，此方法不是轴方法。</span><span class="sxs-lookup"><span data-stu-id="1bc1c-207">In contrast to <xref:System.Xml.Linq.XContainer.Elements%2A>, this method is not an axis method.</span></span> <span data-ttu-id="1bc1c-208">它不使用延迟的执行;它在被调用时只返回一个元素。</span><span class="sxs-lookup"><span data-stu-id="1bc1c-208">It does not use deferred execution; it simply returns an element when called.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="1bc1c-209">下面的示例演示了此方法的两种用法。</span><span class="sxs-lookup"><span data-stu-id="1bc1c-209">The following example shows two uses of this method.</span></span> <span data-ttu-id="1bc1c-210">在一种情况下，方法会在中查找元素 `srcTree` 。</span><span class="sxs-lookup"><span data-stu-id="1bc1c-210">In one case, the method finds the element in `srcTree`.</span></span> <span data-ttu-id="1bc1c-211">在第二种情况下，方法在源树中找不到元素，不会向添加元素 `xmlTree` ，也不会引发异常。</span><span class="sxs-lookup"><span data-stu-id="1bc1c-211">In the second case, the method does not find the element in the source tree, no element is added to `xmlTree`, and no exception is thrown.</span></span>  
  
 <span data-ttu-id="1bc1c-212">请注意，Visual Basic 示例使用子 XML 属性。</span><span class="sxs-lookup"><span data-stu-id="1bc1c-212">Note that the Visual Basic example uses the child XML property.</span></span> <span data-ttu-id="1bc1c-213">它还允许 <xref:System.Xml.Linq.XContainer.Element%2A> 直接在 Visual Basic 中使用方法。</span><span class="sxs-lookup"><span data-stu-id="1bc1c-213">It is also allowable to use the <xref:System.Xml.Linq.XContainer.Element%2A> method directly in Visual Basic.</span></span>  
  
```csharp  
XElement srcTree = new XElement("Root",  
    new XElement("Element1", 1),  
    new XElement("Element2", 2),  
    new XElement("Element3", 3),  
    new XElement("Element4", 4),  
    new XElement("Element5", 5)  
);  
XElement xmlTree = new XElement("Root",  
    new XElement("Child1", 1),  
    new XElement("Child2", 2),  
    new XElement("Child3", 3),  
    new XElement("Child4", 4),  
    new XElement("Child5", 5),  
    srcTree.Element("Element3"),  
    // Even though Element9 does not exist in srcTree, the following line  
    // will not throw an exception.  
    srcTree.Element("Element9")  
);  
Console.WriteLine(xmlTree);  
```  
  
```vb  
Dim srcTree As XElement = _   
        <Root>  
            <Element1>1</Element1>  
            <Element2>2</Element2>  
            <Element3>3</Element3>  
            <Element4>4</Element4>  
            <Element5>5</Element5>  
        </Root>  
  
Dim xmlTree As XElement = _  
        <Root>  
            <Child1>1</Child1>  
            <Child2>2</Child2>  
            <Child3>3</Child3>  
            <Child4>4</Child4>  
            <Child5>5</Child5>  
            <%= srcTree.<Element3> %>  
            <%= srcTree.<Element9> %>  
        </Root>  
  
' Even though Element9 does not exist in srcTree, adding it to the tree  
' will not throw an exception.  
  
Console.WriteLine(xmlTree)  
```  
  
 <span data-ttu-id="1bc1c-214">该示例产生下面的输出：</span><span class="sxs-lookup"><span data-stu-id="1bc1c-214">This example produces the following output:</span></span>  
  
```xml  
<Root>  
  <Child1>1</Child1>  
  <Child2>2</Child2>  
  <Child3>3</Child3>  
  <Child4>4</Child4>  
  <Child5>5</Child5>  
  <Element3>3</Element3>  
</Root>  
```  
  
 <span data-ttu-id="1bc1c-215">下面是同一个示例，但在这种情况下，XML 位于命名空间中。</span><span class="sxs-lookup"><span data-stu-id="1bc1c-215">The following is the same example, but in this case the XML is in a namespace.</span></span> <span data-ttu-id="1bc1c-216">有关详细信息，请参阅 [使用 XML 命名空间](/dotnet/standard/linq/namespaces-overview)。</span><span class="sxs-lookup"><span data-stu-id="1bc1c-216">For more information, see [Work with XML Namespaces](/dotnet/standard/linq/namespaces-overview).</span></span>  
  
```csharp  
XNamespace aw = "http://www.adventure-works.com";  
XElement srcTree = new XElement(aw + "Root",  
    new XAttribute(XNamespace.Xmlns + "aw", "http://www.adventure-works.com"),  
    new XElement(aw + "Element1", 1),  
    new XElement(aw + "Element2", 2),  
    new XElement(aw + "Element3", 3),  
    new XElement(aw + "Element4", 4),  
    new XElement(aw + "Element5", 5)  
);  
XElement xmlTree = new XElement(aw + "Root",  
    new XAttribute(XNamespace.Xmlns + "aw", "http://www.adventure-works.com"),  
    new XElement(aw + "Child1", 1),  
    new XElement(aw + "Child2", 2),  
    new XElement(aw + "Child3", 3),  
    new XElement(aw + "Child4", 4),  
    new XElement(aw + "Child5", 5),  
    srcTree.Element(aw + "Element3"),  
    // Even though Element9 does not exist in srcTree, the following line  
    // will not throw an exception.  
    srcTree.Element(aw + "Element9")  
);  
Console.WriteLine(xmlTree);  
```  
  
```vb  
Imports <xmlns:aw="http://www.adventure-works.com">  
  
Module Module1  
    Sub Main()  
        Dim srcTree As XElement = _   
            <aw:Root>  
                <aw:Element1>1</aw:Element1>  
                <aw:Element2>2</aw:Element2>  
                <aw:Element3>3</aw:Element3>  
                <aw:Element4>4</aw:Element4>  
                <aw:Element5>5</aw:Element5>  
            </aw:Root>  
  
        Dim xmlTree As XElement = _  
            <aw:Root>  
                <aw:Child1>1</aw:Child1>  
                <aw:Child2>2</aw:Child2>  
                <aw:Child3>3</aw:Child3>  
                <aw:Child4>4</aw:Child4>  
                <aw:Child5>5</aw:Child5>  
                <%= srcTree.<aw:Element3> %>  
                <%= srcTree.<aw:Element9> %>  
            </aw:Root>  
  
        ' Even though Element9 does not exist in srcTree, adding it to the tree  
        ' will not throw an exception.  
  
        Console.WriteLine(xmlTree)  
    End Sub  
End Module  
```  
  
 <span data-ttu-id="1bc1c-217">该示例产生下面的输出：</span><span class="sxs-lookup"><span data-stu-id="1bc1c-217">This example produces the following output:</span></span>  
  
```xml  
<aw:Root xmlns:aw="http://www.adventure-works.com">  
  <aw:Child1>1</aw:Child1>  
  <aw:Child2>2</aw:Child2>  
  <aw:Child3>3</aw:Child3>  
  <aw:Child4>4</aw:Child4>  
  <aw:Child5>5</aw:Child5>  
  <aw:Element3>3</aw:Element3>  
</aw:Root>  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Xml.Linq.XContainer.Elements" />
        <related type="Article" href="/dotnet/standard/linq/linq-xml-overview"><span data-ttu-id="1bc1c-218">LINQ to XML 概述</span><span class="sxs-lookup"><span data-stu-id="1bc1c-218">LINQ to XML overview</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Elements">
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="1bc1c-219">按文档顺序返回此元素或文档的子元素集合。</span><span class="sxs-lookup"><span data-stu-id="1bc1c-219">Returns a collection of the child elements of this element or document, in document order.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1bc1c-220">此方法使用延迟执行。</span><span class="sxs-lookup"><span data-stu-id="1bc1c-220">This method uses deferred execution.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Xml.Linq.XContainer.Element(System.Xml.Linq.XName)" />
        <altmember cref="Overload:System.Xml.Linq.XContainer.Descendants" />
        <altmember cref="M:System.Xml.Linq.XContainer.DescendantNodes" />
        <related type="Article" href="/dotnet/standard/linq/linq-xml-overview"><span data-ttu-id="1bc1c-221">LINQ to XML 概述</span><span class="sxs-lookup"><span data-stu-id="1bc1c-221">LINQ to XML overview</span></span></related>
      </Docs>
    </MemberGroup>
    <Member MemberName="Elements">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.Xml.Linq.XElement&gt; Elements ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;class System.Xml.Linq.XElement&gt; Elements() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XContainer.Elements" />
      <MemberSignature Language="VB.NET" Value="Public Function Elements () As IEnumerable(Of XElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IEnumerable&lt;System::Xml::Linq::XElement ^&gt; ^ Elements();" />
      <MemberSignature Language="F#" Value="member this.Elements : unit -&gt; seq&lt;System.Xml.Linq.XElement&gt;" Usage="xContainer.Elements " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Xml.Linq.XElement&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="1bc1c-222">按文档顺序返回此元素或文档的子元素集合。</span><span class="sxs-lookup"><span data-stu-id="1bc1c-222">Returns a collection of the child elements of this element or document, in document order.</span></span></summary>
        <returns><span data-ttu-id="1bc1c-223"><see cref="T:System.Xml.Linq.XElement" /> 的 <see cref="T:System.Collections.Generic.IEnumerable`1" />，其中按文档顺序包含此 <see cref="T:System.Xml.Linq.XContainer" /> 的子元素。</span><span class="sxs-lookup"><span data-stu-id="1bc1c-223">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> of <see cref="T:System.Xml.Linq.XElement" /> containing the child elements of this <see cref="T:System.Xml.Linq.XContainer" />, in document order.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1bc1c-224">此方法使用延迟执行。</span><span class="sxs-lookup"><span data-stu-id="1bc1c-224">This method uses deferred execution.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="1bc1c-225">下面的示例创建一个 XML 树，然后使用此轴方法选择一些元素。</span><span class="sxs-lookup"><span data-stu-id="1bc1c-225">The following example creates an XML tree, and then selects some elements using this axis method.</span></span>  
  
```csharp  
XElement xmlTree = new XElement("Root",  
    new XElement("Child1", 1),  
    new XElement("Child2", 2),  
    new XElement("Child3", 3),  
    new XElement("Child4", 4),  
    new XElement("Child5", 5)  
);  
IEnumerable<XElement> elements =  
    from el in xmlTree.Elements()  
    where (int)el <= 3  
    select el;  
foreach (XElement el in elements)  
    Console.WriteLine(el);  
```  
  
```vb  
Dim xmlTree As XElement = _  
        <Root>  
            <Child1>1</Child1>  
            <Child2>2</Child2>  
            <Child3>3</Child3>  
            <Child4>4</Child4>  
            <Child5>5</Child5>  
        </Root>  
  
Dim elements = From el In xmlTree.Elements _  
               Where el.Value <= 3 _  
               Select el  
  
For Each el In elements  
    Console.WriteLine(el)  
Next  
```  
  
 <span data-ttu-id="1bc1c-226">该示例产生下面的输出：</span><span class="sxs-lookup"><span data-stu-id="1bc1c-226">This example produces the following output:</span></span>  
  
```  
<Child1>1</Child1>  
<Child2>2</Child2>  
<Child3>3</Child3>  
```  
  
 <span data-ttu-id="1bc1c-227">下面是同一个示例，但在这种情况下，XML 位于命名空间中。</span><span class="sxs-lookup"><span data-stu-id="1bc1c-227">The following is the same example, but in this case the XML is in a namespace.</span></span> <span data-ttu-id="1bc1c-228">有关详细信息，请参阅 [使用 XML 命名空间](/dotnet/standard/linq/namespaces-overview)。</span><span class="sxs-lookup"><span data-stu-id="1bc1c-228">For more information, see [Work with XML Namespaces](/dotnet/standard/linq/namespaces-overview).</span></span>  
  
```csharp  
XNamespace aw = "http://www.adventure-works.com";  
XElement xmlTree = new XElement(aw + "Root",  
    new XAttribute(XNamespace.Xmlns + "aw", "http://www.adventure-works.com"),  
    new XElement(aw + "Child1", 1),  
    new XElement(aw + "Child2", 2),  
    new XElement(aw + "Child3", 3),  
    new XElement(aw + "Child4", 4),  
    new XElement(aw + "Child5", 5)  
);  
IEnumerable<XElement> elements =  
    from el in xmlTree.Elements()  
    where (int)el <= 3  
    select el;  
foreach (XElement el in elements)  
    Console.WriteLine(el);  
```  
  
```vb  
Imports <xmlns:aw="http://www.adventure-works.com">  
  
Module Module1  
    Sub Main()  
        Dim xmlTree As XElement = _  
            <aw:Root>  
                <aw:Child1>1</aw:Child1>  
                <aw:Child2>2</aw:Child2>  
                <aw:Child3>3</aw:Child3>  
                <aw:Child4>4</aw:Child4>  
                <aw:Child5>5</aw:Child5>  
            </aw:Root>  
  
        Dim elements = From el In xmlTree.Elements _  
                       Where el.Value <= 3 _  
                       Select el  
  
        For Each el In elements  
            Console.WriteLine(el)  
        Next  
    End Sub  
End Module  
```  
  
 <span data-ttu-id="1bc1c-229">该示例产生下面的输出：</span><span class="sxs-lookup"><span data-stu-id="1bc1c-229">This example produces the following output:</span></span>  
  
```  
<aw:Child1 xmlns:aw="http://www.adventure-works.com">1</aw:Child1>  
<aw:Child2 xmlns:aw="http://www.adventure-works.com">2</aw:Child2>  
<aw:Child3 xmlns:aw="http://www.adventure-works.com">3</aw:Child3>  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Xml.Linq.XContainer.Element(System.Xml.Linq.XName)" />
        <altmember cref="Overload:System.Xml.Linq.XContainer.Descendants" />
        <altmember cref="M:System.Xml.Linq.XContainer.DescendantNodes" />
        <related type="Article" href="/dotnet/standard/linq/linq-xml-overview"><span data-ttu-id="1bc1c-230">LINQ to XML 概述</span><span class="sxs-lookup"><span data-stu-id="1bc1c-230">LINQ to XML overview</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Elements">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.Xml.Linq.XElement&gt; Elements (System.Xml.Linq.XName name);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;class System.Xml.Linq.XElement&gt; Elements(class System.Xml.Linq.XName name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XContainer.Elements(System.Xml.Linq.XName)" />
      <MemberSignature Language="VB.NET" Value="Public Function Elements (name As XName) As IEnumerable(Of XElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IEnumerable&lt;System::Xml::Linq::XElement ^&gt; ^ Elements(System::Xml::Linq::XName ^ name);" />
      <MemberSignature Language="F#" Value="member this.Elements : System.Xml.Linq.XName -&gt; seq&lt;System.Xml.Linq.XElement&gt;" Usage="xContainer.Elements name" />
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.Xml.Linq.XElement&gt; Elements (System.Xml.Linq.XName? name);" FrameworkAlternate="net-5.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Xml.Linq.XElement&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Xml.Linq.XName" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="1bc1c-231">要匹配的 <see cref="T:System.Xml.Linq.XName" />。</span><span class="sxs-lookup"><span data-stu-id="1bc1c-231">The <see cref="T:System.Xml.Linq.XName" /> to match.</span></span></param>
        <summary><span data-ttu-id="1bc1c-232">按文档顺序返回此元素或文档的已筛选的子元素集合。</span><span class="sxs-lookup"><span data-stu-id="1bc1c-232">Returns a filtered collection of the child elements of this element or document, in document order.</span></span> <span data-ttu-id="1bc1c-233">集合中仅包括具有匹配 <see cref="T:System.Xml.Linq.XName" /> 的元素。</span><span class="sxs-lookup"><span data-stu-id="1bc1c-233">Only elements that have a matching <see cref="T:System.Xml.Linq.XName" /> are included in the collection.</span></span></summary>
        <returns><span data-ttu-id="1bc1c-234"><see cref="T:System.Xml.Linq.XElement" /> 的 <see cref="T:System.Collections.Generic.IEnumerable`1" />，其中按文档顺序包含具有匹配 <see cref="T:System.Xml.Linq.XName" /> 的 <see cref="T:System.Xml.Linq.XContainer" /> 的子级。</span><span class="sxs-lookup"><span data-stu-id="1bc1c-234">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> of <see cref="T:System.Xml.Linq.XElement" /> containing the children of the <see cref="T:System.Xml.Linq.XContainer" /> that have a matching <see cref="T:System.Xml.Linq.XName" />, in document order.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1bc1c-235">此方法使用延迟执行。</span><span class="sxs-lookup"><span data-stu-id="1bc1c-235">This method uses deferred execution.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="1bc1c-236">下面的示例创建一个 XML 树，然后使用此轴方法选择多个子元素。</span><span class="sxs-lookup"><span data-stu-id="1bc1c-236">The following example creates an XML tree, and then selects several child elements using this axis method.</span></span>  
  
```csharp  
XElement xmlTree = new XElement("Root",  
    new XElement("Type1", 1),  
    new XElement("Type1", 2),  
    new XElement("Type2", 3),  
    new XElement("Type2", 4),  
    new XElement("Type2", 5)  
);  
IEnumerable<XElement> elements =  
    from el in xmlTree.Elements("Type2")  
    select el;  
foreach (XElement el in elements)  
    Console.WriteLine(el);  
```  
  
```vb  
Dim xmlTree As XElement = _   
        <Root>  
            <Type1>1</Type1>  
            <Type1>2</Type1>  
            <Type2>3</Type2>  
            <Type2>4</Type2>  
            <Type2>5</Type2>  
        </Root>  
  
Dim elements = From el In xmlTree.<Type2> _  
               Select el  
  
For Each el In elements  
    Console.WriteLine(el)  
Next  
```  
  
 <span data-ttu-id="1bc1c-237">该示例产生下面的输出：</span><span class="sxs-lookup"><span data-stu-id="1bc1c-237">This example produces the following output:</span></span>  
  
```  
<Type2>3</Type2>  
<Type2>4</Type2>  
<Type2>5</Type2>  
```  
  
 <span data-ttu-id="1bc1c-238">下面是同一个示例，但在这种情况下，XML 位于命名空间中。</span><span class="sxs-lookup"><span data-stu-id="1bc1c-238">The following is the same example, but in this case the XML is in a namespace.</span></span> <span data-ttu-id="1bc1c-239">有关详细信息，请参阅 [使用 XML 命名空间](/dotnet/standard/linq/namespaces-overview)。</span><span class="sxs-lookup"><span data-stu-id="1bc1c-239">For more information, see [Work with XML Namespaces](/dotnet/standard/linq/namespaces-overview).</span></span>  
  
```csharp  
XNamespace aw = "http://www.adventure-works.com";  
XElement xmlTree = new XElement(aw + "Root",  
    new XAttribute(XNamespace.Xmlns + "aw", "http://www.adventure-works.com"),  
    new XElement(aw + "Type1", 1),  
    new XElement(aw + "Type1", 2),  
    new XElement(aw + "Type2", 3),  
    new XElement(aw + "Type2", 4),  
    new XElement(aw + "Type2", 5)  
);  
IEnumerable<XElement> elements =  
    from el in xmlTree.Elements(aw + "Type2")  
    select el;  
foreach (XElement el in elements)  
    Console.WriteLine(el);  
```  
  
```vb  
Imports <xmlns:aw="http://www.adventure-works.com">  
  
Module Module1  
    Sub Main()  
        Dim xmlTree As XElement = _   
            <aw:Root>  
                <aw:Type1>1</aw:Type1>  
                <aw:Type1>2</aw:Type1>  
                <aw:Type2>3</aw:Type2>  
                <aw:Type2>4</aw:Type2>  
                <aw:Type2>5</aw:Type2>  
            </aw:Root>  
  
        Dim elements = From el In xmlTree.<aw:Type2> _  
                       Select el  
  
        For Each el In elements  
            Console.WriteLine(el)  
        Next  
    End Sub  
End Module  
```  
  
 <span data-ttu-id="1bc1c-240">该示例产生下面的输出：</span><span class="sxs-lookup"><span data-stu-id="1bc1c-240">This example produces the following output:</span></span>  
  
```  
<aw:Type2 xmlns:aw="http://www.adventure-works.com">3</aw:Type2>  
<aw:Type2 xmlns:aw="http://www.adventure-works.com">4</aw:Type2>  
<aw:Type2 xmlns:aw="http://www.adventure-works.com">5</aw:Type2>  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Xml.Linq.XContainer.Element(System.Xml.Linq.XName)" />
        <altmember cref="Overload:System.Xml.Linq.XContainer.Descendants" />
        <altmember cref="M:System.Xml.Linq.XContainer.DescendantNodes" />
        <related type="Article" href="/dotnet/standard/linq/linq-xml-overview"><span data-ttu-id="1bc1c-241">LINQ to XML 概述</span><span class="sxs-lookup"><span data-stu-id="1bc1c-241">LINQ to XML overview</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="FirstNode">
      <MemberSignature Language="C#" Value="public System.Xml.Linq.XNode FirstNode { get; }" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xml.Linq.XNode FirstNode" />
      <MemberSignature Language="DocId" Value="P:System.Xml.Linq.XContainer.FirstNode" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property FirstNode As XNode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xml::Linq::XNode ^ FirstNode { System::Xml::Linq::XNode ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.FirstNode : System.Xml.Linq.XNode" Usage="System.Xml.Linq.XContainer.FirstNode" />
      <MemberSignature Language="C#" Value="public System.Xml.Linq.XNode? FirstNode { get; }" FrameworkAlternate="net-5.0" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Linq.XNode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="1bc1c-242">获取此节点的第一个子节点。</span><span class="sxs-lookup"><span data-stu-id="1bc1c-242">Gets the first child node of this node.</span></span></summary>
        <value><span data-ttu-id="1bc1c-243">一个 <see cref="T:System.Xml.Linq.XNode" />，其中包含 <see cref="T:System.Xml.Linq.XContainer" /> 的第一个子节点。</span><span class="sxs-lookup"><span data-stu-id="1bc1c-243">An <see cref="T:System.Xml.Linq.XNode" /> containing the first child node of the <see cref="T:System.Xml.Linq.XContainer" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="1bc1c-244">下面的示例创建一个包含子元素的元素。</span><span class="sxs-lookup"><span data-stu-id="1bc1c-244">The following example creates an element that contains child elements.</span></span> <span data-ttu-id="1bc1c-245">然后，它获取父元素的第一个子节点。</span><span class="sxs-lookup"><span data-stu-id="1bc1c-245">It then gets the first child node of the parent element.</span></span>  
  
```csharp  
XElement xmlTree = new XElement("Root",  
    new XElement("Child1", 1),  
    new XElement("Child2", 2),  
    new XElement("Child3", 3),  
    new XElement("Child4", 4),  
    new XElement("Child5", 5)  
);  
XNode firstNode = xmlTree.FirstNode;  
Console.WriteLine(firstNode);  
```  
  
```vb  
Dim xmlTree As XElement = _   
        <Root>  
            <Child1>1</Child1>  
            <Child2>2</Child2>  
            <Child3>3</Child3>  
            <Child4>4</Child4>  
            <Child5>5</Child5>  
        </Root>  
  
Dim firstNode As XNode = xmlTree.FirstNode  
Console.WriteLine(firstNode)  
```  
  
 <span data-ttu-id="1bc1c-246">该示例产生下面的输出：</span><span class="sxs-lookup"><span data-stu-id="1bc1c-246">This example produces the following output:</span></span>  
  
```xml  
<Child1>1</Child1>  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Xml.Linq.XContainer.LastNode" />
        <altmember cref="M:System.Xml.Linq.XContainer.Nodes" />
        <related type="Article" href="/dotnet/standard/linq/linq-xml-overview"><span data-ttu-id="1bc1c-247">LINQ to XML 概述</span><span class="sxs-lookup"><span data-stu-id="1bc1c-247">LINQ to XML overview</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="LastNode">
      <MemberSignature Language="C#" Value="public System.Xml.Linq.XNode LastNode { get; }" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xml.Linq.XNode LastNode" />
      <MemberSignature Language="DocId" Value="P:System.Xml.Linq.XContainer.LastNode" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LastNode As XNode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xml::Linq::XNode ^ LastNode { System::Xml::Linq::XNode ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.LastNode : System.Xml.Linq.XNode" Usage="System.Xml.Linq.XContainer.LastNode" />
      <MemberSignature Language="C#" Value="public System.Xml.Linq.XNode? LastNode { get; }" FrameworkAlternate="net-5.0" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Linq.XNode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="1bc1c-248">获取此节点的最后一个子节点。</span><span class="sxs-lookup"><span data-stu-id="1bc1c-248">Gets the last child node of this node.</span></span></summary>
        <value><span data-ttu-id="1bc1c-249">一个 <see cref="T:System.Xml.Linq.XNode" />，其中包含 <see cref="T:System.Xml.Linq.XContainer" /> 的最后一个子节点。</span><span class="sxs-lookup"><span data-stu-id="1bc1c-249">An <see cref="T:System.Xml.Linq.XNode" /> containing the last child node of the <see cref="T:System.Xml.Linq.XContainer" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="1bc1c-250">下面的示例创建一个包含子元素的元素。</span><span class="sxs-lookup"><span data-stu-id="1bc1c-250">The following example creates an element that contains child elements.</span></span> <span data-ttu-id="1bc1c-251">然后，它获取父元素的最后一个子节点。</span><span class="sxs-lookup"><span data-stu-id="1bc1c-251">It then gets the last child node of the parent element.</span></span>  
  
```csharp  
XElement xmlTree = new XElement("Root",  
    new XElement("Child1", 1),  
    new XElement("Child2", 2),  
    new XElement("Child3", 3),  
    new XElement("Child4", 4),  
    new XElement("Child5", 5)  
);  
XNode lastNode = xmlTree.LastNode;  
Console.WriteLine(lastNode);  
```  
  
```vb  
Dim xmlTree As XElement = _   
        <Root>  
            <Child1>1</Child1>  
            <Child2>2</Child2>  
            <Child3>3</Child3>  
            <Child4>4</Child4>  
            <Child5>5</Child5>  
        </Root>  
  
Dim lastNode As XNode = xmlTree.LastNode  
Console.WriteLine(lastNode)  
```  
  
 <span data-ttu-id="1bc1c-252">该示例产生下面的输出：</span><span class="sxs-lookup"><span data-stu-id="1bc1c-252">This example produces the following output:</span></span>  
  
```xml  
<Child5>5</Child5>  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Xml.Linq.XContainer.FirstNode" />
        <altmember cref="M:System.Xml.Linq.XContainer.Nodes" />
        <related type="Article" href="/dotnet/standard/linq/linq-xml-overview"><span data-ttu-id="1bc1c-253">LINQ to XML 概述</span><span class="sxs-lookup"><span data-stu-id="1bc1c-253">LINQ to XML overview</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Nodes">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.Xml.Linq.XNode&gt; Nodes ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;class System.Xml.Linq.XNode&gt; Nodes() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XContainer.Nodes" />
      <MemberSignature Language="VB.NET" Value="Public Function Nodes () As IEnumerable(Of XNode)" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IEnumerable&lt;System::Xml::Linq::XNode ^&gt; ^ Nodes();" />
      <MemberSignature Language="F#" Value="member this.Nodes : unit -&gt; seq&lt;System.Xml.Linq.XNode&gt;" Usage="xContainer.Nodes " />
      <MemberSignature Language="VB.NET" Value="Public Iterator Function Nodes () As IEnumerable(Of XNode)" FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.6">
          <AttributeName Language="C#">[System.Runtime.CompilerServices.IteratorStateMachine(typeof(System.Xml.Linq.XContainer/&lt;Nodes&gt;d__1))]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IteratorStateMachine(typeof(System.Xml.Linq.XContainer/&lt;Nodes&gt;d__1))&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.Runtime.CompilerServices.IteratorStateMachine(typeof(System.Xml.Linq.XContainer/&lt;Nodes&gt;d__18))]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IteratorStateMachine(typeof(System.Xml.Linq.XContainer/&lt;Nodes&gt;d__18))&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Xml.Linq.XNode&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="1bc1c-254">按文档顺序返回此元素或文档的子节点集合。</span><span class="sxs-lookup"><span data-stu-id="1bc1c-254">Returns a collection of the child nodes of this element or document, in document order.</span></span></summary>
        <returns><span data-ttu-id="1bc1c-255"><see cref="T:System.Xml.Linq.XNode" /> 的 <see cref="T:System.Collections.Generic.IEnumerable`1" />，其中按文档顺序包含此 <see cref="T:System.Xml.Linq.XContainer" /> 的内容。</span><span class="sxs-lookup"><span data-stu-id="1bc1c-255">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> of <see cref="T:System.Xml.Linq.XNode" /> containing the contents of this <see cref="T:System.Xml.Linq.XContainer" />, in document order.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1bc1c-256">请注意，内容不包括属性。</span><span class="sxs-lookup"><span data-stu-id="1bc1c-256">Note that the content does not include attributes.</span></span> <span data-ttu-id="1bc1c-257">在中 [!INCLUDE[sqltecxlinq](~/includes/sqltecxlinq-md.md)] ，属性不被视为树的节点。</span><span class="sxs-lookup"><span data-stu-id="1bc1c-257">In [!INCLUDE[sqltecxlinq](~/includes/sqltecxlinq-md.md)], attributes are not considered to be nodes of the tree.</span></span> <span data-ttu-id="1bc1c-258">它们是与某个元素关联的名称/值对。</span><span class="sxs-lookup"><span data-stu-id="1bc1c-258">They are name/value pairs associated with an element.</span></span>  
  
 <span data-ttu-id="1bc1c-259">此方法使用延迟执行。</span><span class="sxs-lookup"><span data-stu-id="1bc1c-259">This method uses deferred execution.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="1bc1c-260">下面的示例创建一个 XML 树，其中包含各种类型的节点。</span><span class="sxs-lookup"><span data-stu-id="1bc1c-260">The following example creates an XML tree with a variety of types of nodes.</span></span> <span data-ttu-id="1bc1c-261">然后，它会查询此轴方法以枚举和打印节点。</span><span class="sxs-lookup"><span data-stu-id="1bc1c-261">It then queries this axis method to enumerate and print the nodes.</span></span>  
  
```csharp  
XElement xmlTree = new XElement("Root",  
    new XElement("Child1", 1),  
    new XElement("Child2", 2),  
    new XComment("a comment"),  
    new XElement("Child3", 3),  
    new XElement("Child4", 4),  
    new XText("mixed content"),  
    new XElement("Child5", 5)  
);  
IEnumerable<XNode> nodes =  
    from nd in xmlTree.Nodes()  
    select nd;  
foreach (XNode node in nodes)  
    Console.WriteLine(node);  
```  
  
```vb  
Dim xmlTree As XElement = _   
        <Root>  
            <Child1>1</Child1>  
            <Child2>2</Child2>  
            <!--a comment-->  
            <Child3>3</Child3>  
            <Child4>4</Child4>mixed content<Child5>5</Child5>  
            </Root>  
  
Dim nodes = From nd In xmlTree.Nodes() _  
            Select nd  
  
For Each node In nodes  
    Console.WriteLine(node)  
Next  
```  
  
 <span data-ttu-id="1bc1c-262">该示例产生下面的输出：</span><span class="sxs-lookup"><span data-stu-id="1bc1c-262">This example produces the following output:</span></span>  
  
```  
<Child1>1</Child1>  
<Child2>2</Child2>  
<!--a comment-->  
<Child3>3</Child3>  
<Child4>4</Child4>  
mixed content  
<Child5>5</Child5>  
```  
  
 <span data-ttu-id="1bc1c-263">下面的示例创建一个 XML 树，其中包含各种类型的节点。</span><span class="sxs-lookup"><span data-stu-id="1bc1c-263">The following example creates an XML tree that contains a variety of types of nodes.</span></span> <span data-ttu-id="1bc1c-264">然后枚举树的各个部分，打印节点类型。</span><span class="sxs-lookup"><span data-stu-id="1bc1c-264">It then enumerates through portions of the tree, printing the node types.</span></span>  
  
```csharp  
XDocument xmlTree = new XDocument(  
    new XComment("a comment"),  
    new XProcessingInstruction("xml-stylesheet", "type=\"text/xsl\" href=\"hello.xsl\""),  
    new XElement("Root",  
        new XAttribute("Att", "attContent"),  
        new XElement("Child1",  
            new XCData("CDATA content")  
        ),  
        new XElement("Child2",  
            new XText("Text content")  
        )  
    )  
);  
  
foreach (XNode node in xmlTree.Nodes())  
{  
    Console.WriteLine(node.NodeType);  
    if (node.NodeType == XmlNodeType.Element)  
    {  
        foreach (XAttribute att in ((XElement)node).Attributes())  
            Console.WriteLine(att.NodeType);  
        foreach (XNode node2 in ((XElement)node).Nodes())  
        {  
            Console.WriteLine(node2.NodeType);  
            if (node2.NodeType == XmlNodeType.Element)  
                foreach (XNode node3 in ((XElement)node2).Nodes())  
                    Console.WriteLine(node3.NodeType);  
        }  
    }  
}  
```  
  
```vb  
Dim xmlTree As XDocument = _   
    <?xml version="1.0" encoding="utf-8"?>  
    <!--a comment-->  
    <?xml-stylesheet type='text/xsl' href='hello.xsl'?>  
    <Root Att="attContent">  
        <Child1><![CDATA[CDATA content]]]></format>
        </remarks>
        <altmember cref="M:System.Xml.Linq.XElement.Attributes" />
        <altmember cref="Overload:System.Xml.Linq.XContainer.Descendants" />
        <altmember cref="M:System.Xml.Linq.XContainer.DescendantNodes" />
        <related type="Article" href="/dotnet/standard/linq/linq-xml-overview"><span data-ttu-id="1bc1c-265">LINQ to XML 概述</span><span class="sxs-lookup"><span data-stu-id="1bc1c-265">LINQ to XML overview</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="RemoveNodes">
      <MemberSignature Language="C#" Value="public void RemoveNodes ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RemoveNodes() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XContainer.RemoveNodes" />
      <MemberSignature Language="VB.NET" Value="Public Sub RemoveNodes ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RemoveNodes();" />
      <MemberSignature Language="F#" Value="member this.RemoveNodes : unit -&gt; unit" Usage="xContainer.RemoveNodes " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="1bc1c-266">从此文档或元素中移除子节点。</span><span class="sxs-lookup"><span data-stu-id="1bc1c-266">Removes the child nodes from this document or element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1bc1c-267">如果对包含属性的元素调用此方法，则此方法不会删除属性。</span><span class="sxs-lookup"><span data-stu-id="1bc1c-267">If you call this method on an element that contains attributes, this method will not remove the attributes.</span></span> <span data-ttu-id="1bc1c-268">若要删除元素的属性，请使用 <xref:System.Xml.Linq.XElement.RemoveAttributes%2A> 。</span><span class="sxs-lookup"><span data-stu-id="1bc1c-268">To remove the attributes of an element, use <xref:System.Xml.Linq.XElement.RemoveAttributes%2A>.</span></span>  
  
 <span data-ttu-id="1bc1c-269"><xref:System.Xml.Linq.Extensions.Remove%2A>方法具有相关的功能。</span><span class="sxs-lookup"><span data-stu-id="1bc1c-269">The <xref:System.Xml.Linq.Extensions.Remove%2A> method has related functionality.</span></span> <span data-ttu-id="1bc1c-270">它删除集合中每个节点的子节点。</span><span class="sxs-lookup"><span data-stu-id="1bc1c-270">It removes the child nodes of every node in a collection.</span></span>  
  
 <span data-ttu-id="1bc1c-271">此方法将引发 <xref:System.Xml.Linq.XObject.Changed> 和 <xref:System.Xml.Linq.XObject.Changing> 事件。</span><span class="sxs-lookup"><span data-stu-id="1bc1c-271">This method will raise the <xref:System.Xml.Linq.XObject.Changed> and the <xref:System.Xml.Linq.XObject.Changing> events.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="1bc1c-272">下面的示例创建一个包含一些子节点的 XML 树。</span><span class="sxs-lookup"><span data-stu-id="1bc1c-272">The following example creates an XML tree that contains some child nodes.</span></span> <span data-ttu-id="1bc1c-273">然后，它调用此方法来移除子节点。</span><span class="sxs-lookup"><span data-stu-id="1bc1c-273">It then calls this method to remove the child nodes.</span></span>  
  
```csharp  
XElement xmlTree = new XElement("Root",  
    new XElement("Child1", 1),  
    new XElement("Child2", 2),  
    new XComment("a comment"),  
    new XElement("Child3", 3),  
    new XElement("Child4", 4),  
    new XText("mixed content"),  
    new XElement("Child5", 5)  
);  
xmlTree.RemoveNodes();  
Console.WriteLine(xmlTree);  
```  
  
```vb  
Dim xmltree As XElement = _   
    <Root>  
        <Child1>1</Child1>  
        <Child2>2</Child2>  
        <!--a comment-->  
        <Child3>3</Child3>  
        <Child4>4</Child4>mixed content<Child5>5</Child5>  
    </Root>  
  
xmltree.RemoveNodes()  
Console.WriteLine(xmltree)  
```  
  
 <span data-ttu-id="1bc1c-274">该示例产生下面的输出：</span><span class="sxs-lookup"><span data-stu-id="1bc1c-274">This example produces the following output:</span></span>  
  
```xml  
<Root />  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Xml.Linq.XContainer.Add" />
        <altmember cref="Overload:System.Xml.Linq.XContainer.ReplaceNodes" />
        <related type="Article" href="/dotnet/standard/linq/linq-xml-overview"><span data-ttu-id="1bc1c-275">LINQ to XML 概述</span><span class="sxs-lookup"><span data-stu-id="1bc1c-275">LINQ to XML overview</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReplaceNodes">
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="1bc1c-276">使用指定内容替换此文档或元素的子节点。</span><span class="sxs-lookup"><span data-stu-id="1bc1c-276">Replaces the children nodes of this document or element with the specified content.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1bc1c-277">有关可传递到此函数的有效内容的详细信息，请参阅 [system.xml.linq.xelement> 和 XDocument 对象的有效内容](/dotnet/standard/linq/valid-content-xelement-xdocument-objects)。</span><span class="sxs-lookup"><span data-stu-id="1bc1c-277">For details about the valid content that can be passed to this function, see [Valid Content of XElement and XDocument Objects](/dotnet/standard/linq/valid-content-xelement-xdocument-objects).</span></span>  
  
 <span data-ttu-id="1bc1c-278">此方法将引发 <xref:System.Xml.Linq.XObject.Changed> 和 <xref:System.Xml.Linq.XObject.Changing> 事件。</span><span class="sxs-lookup"><span data-stu-id="1bc1c-278">This method will raise the <xref:System.Xml.Linq.XObject.Changed> and the <xref:System.Xml.Linq.XObject.Changing> events.</span></span>  
  
 <span data-ttu-id="1bc1c-279">此方法具有快照语义。</span><span class="sxs-lookup"><span data-stu-id="1bc1c-279">This method has snapshot semantics.</span></span> <span data-ttu-id="1bc1c-280">它首先创建新内容的副本。</span><span class="sxs-lookup"><span data-stu-id="1bc1c-280">It first creates a copy of the new content.</span></span> <span data-ttu-id="1bc1c-281">然后删除此节点的所有子节点。</span><span class="sxs-lookup"><span data-stu-id="1bc1c-281">It then removes all children nodes of this node.</span></span> <span data-ttu-id="1bc1c-282">最后，它会将新内容添加为子节点。</span><span class="sxs-lookup"><span data-stu-id="1bc1c-282">Finally, it adds the new content as children nodes.</span></span> <span data-ttu-id="1bc1c-283">这意味着您可以使用子节点本身的查询来替换子节点。</span><span class="sxs-lookup"><span data-stu-id="1bc1c-283">This means that you can replace children nodes using a query on the children nodes themselves.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="1bc1c-284">下面的示例创建两个 XML 树，然后使用此方法将其中一个树的内容替换为查询结果。</span><span class="sxs-lookup"><span data-stu-id="1bc1c-284">The following example creates two XML trees, and then uses this method to replace the contents of one of them with the results of a query.</span></span>  
  
```csharp  
XElement root = new XElement("Root",  
    new XElement("Child", 1),  
    new XElement("Child", 2),  
    new XElement("Child", 3),  
    new XElement("Child", 4),  
    new XElement("Child", 5)  
);  
root.ReplaceNodes(  
    from el in root.Elements()  
    where (int)el >= 3  
    select el  
);  
Console.WriteLine(root);  
```  
  
```vb  
Dim root As XElement = _   
    <Root>  
        <Child>1</Child>  
        <Child>2</Child>  
        <Child>3</Child>  
        <Child>4</Child>  
        <Child>5</Child>  
    </Root>  
root.ReplaceNodes( _  
    From el In root.Elements _  
    Where el.Value >= 3 _  
    Select el)  
Console.WriteLine(root)  
```  
  
 <span data-ttu-id="1bc1c-285">该示例产生下面的输出：</span><span class="sxs-lookup"><span data-stu-id="1bc1c-285">This example produces the following output:</span></span>  
  
```xml  
<Root>  
  <Child>3</Child>  
  <Child>4</Child>  
  <Child>5</Child>  
</Root>  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Xml.Linq.XContainer.Add" />
        <altmember cref="M:System.Xml.Linq.XContainer.RemoveNodes" />
        <related type="Article" href="/dotnet/standard/linq/linq-xml-overview"><span data-ttu-id="1bc1c-286">LINQ to XML 概述</span><span class="sxs-lookup"><span data-stu-id="1bc1c-286">LINQ to XML overview</span></span></related>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReplaceNodes">
      <MemberSignature Language="C#" Value="public void ReplaceNodes (object content);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReplaceNodes(object content) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XContainer.ReplaceNodes(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReplaceNodes (content As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ReplaceNodes(System::Object ^ content);" />
      <MemberSignature Language="F#" Value="member this.ReplaceNodes : obj -&gt; unit" Usage="xContainer.ReplaceNodes content" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="content" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="content"><span data-ttu-id="1bc1c-287">用于替换子节点的包含简单内容的内容对象或内容对象集合。</span><span class="sxs-lookup"><span data-stu-id="1bc1c-287">A content object containing simple content or a collection of content objects that replace the children nodes.</span></span></param>
        <summary><span data-ttu-id="1bc1c-288">使用指定内容替换此文档或元素的子节点。</span><span class="sxs-lookup"><span data-stu-id="1bc1c-288">Replaces the children nodes of this document or element with the specified content.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1bc1c-289">有关可传递到此函数的有效内容的详细信息，请参阅 [system.xml.linq.xelement> 和 XDocument 对象的有效内容](/dotnet/standard/linq/valid-content-xelement-xdocument-objects)。</span><span class="sxs-lookup"><span data-stu-id="1bc1c-289">For details about the valid content that can be passed to this function, see [Valid Content of XElement and XDocument Objects](/dotnet/standard/linq/valid-content-xelement-xdocument-objects).</span></span>  
  
 <span data-ttu-id="1bc1c-290">此方法将引发 <xref:System.Xml.Linq.XObject.Changed> 和 <xref:System.Xml.Linq.XObject.Changing> 事件。</span><span class="sxs-lookup"><span data-stu-id="1bc1c-290">This method will raise the <xref:System.Xml.Linq.XObject.Changed> and the <xref:System.Xml.Linq.XObject.Changing> events.</span></span>  
  
 <span data-ttu-id="1bc1c-291">此方法具有快照语义。</span><span class="sxs-lookup"><span data-stu-id="1bc1c-291">This method has snapshot semantics.</span></span> <span data-ttu-id="1bc1c-292">它首先创建新内容的副本。</span><span class="sxs-lookup"><span data-stu-id="1bc1c-292">It first creates a copy of the new content.</span></span> <span data-ttu-id="1bc1c-293">然后删除此节点的所有子节点。</span><span class="sxs-lookup"><span data-stu-id="1bc1c-293">It then removes all children nodes of this node.</span></span> <span data-ttu-id="1bc1c-294">最后，它会将新内容添加为子节点。</span><span class="sxs-lookup"><span data-stu-id="1bc1c-294">Finally, it adds the new content as children nodes.</span></span> <span data-ttu-id="1bc1c-295">这意味着您可以使用子节点本身的查询来替换子节点。</span><span class="sxs-lookup"><span data-stu-id="1bc1c-295">This means that you can replace children nodes using a query on the children nodes themselves.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="1bc1c-296">下面的示例创建一个包含子节点的 XML 树。</span><span class="sxs-lookup"><span data-stu-id="1bc1c-296">The following example creates an XML tree that contains children nodes.</span></span> <span data-ttu-id="1bc1c-297">然后，它将所有子节点替换为单个元素。</span><span class="sxs-lookup"><span data-stu-id="1bc1c-297">It then replaces all of the children nodes with a single element.</span></span>  
  
 <span data-ttu-id="1bc1c-298">若要查看将子节点替换为查询结果的示例 [!INCLUDE[vbteclinq](~/includes/vbteclinq-md.md)] ，请参阅 <xref:System.Xml.Linq.XContainer.ReplaceNodes%2A> 。</span><span class="sxs-lookup"><span data-stu-id="1bc1c-298">To see an example of replacing the children nodes with the results of a [!INCLUDE[vbteclinq](~/includes/vbteclinq-md.md)] query, see <xref:System.Xml.Linq.XContainer.ReplaceNodes%2A>.</span></span>  
  
```csharp  
XElement root = new XElement("Root",  
    new XElement("Child", 1),  
    new XElement("Child", 2),  
    new XElement("Child", 3),  
    new XElement("Child", 4),  
    new XElement("Child", 5)  
);  
root.ReplaceNodes(  
    from el in root.Elements()  
    where (int)el >= 3  
    select el  
);  
Console.WriteLine(root);  
```  
  
```vb  
Dim root As XElement = _   
    <Root>  
        <Child>1</Child>  
        <Child>2</Child>  
        <Child>3</Child>  
        <Child>4</Child>  
        <Child>5</Child>  
    </Root>  
root.ReplaceNodes( _  
    From el In root.Elements _  
    Where el.Value >= 3 _  
    Select el)  
Console.WriteLine(root)  
```  
  
 <span data-ttu-id="1bc1c-299">该示例产生下面的输出：</span><span class="sxs-lookup"><span data-stu-id="1bc1c-299">This example produces the following output:</span></span>  
  
```xml  
<Root>  
  <Child>3</Child>  
  <Child>4</Child>  
  <Child>5</Child>  
</Root>  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Xml.Linq.XContainer.Add" />
        <altmember cref="M:System.Xml.Linq.XContainer.RemoveNodes" />
        <related type="Article" href="/dotnet/standard/linq/linq-xml-overview"><span data-ttu-id="1bc1c-300">LINQ to XML 概述</span><span class="sxs-lookup"><span data-stu-id="1bc1c-300">LINQ to XML overview</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="ReplaceNodes">
      <MemberSignature Language="C#" Value="public void ReplaceNodes (params object[] content);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReplaceNodes(object[] content) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XContainer.ReplaceNodes(System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReplaceNodes (ParamArray content As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ReplaceNodes(... cli::array &lt;System::Object ^&gt; ^ content);" />
      <MemberSignature Language="F#" Value="member this.ReplaceNodes : obj[] -&gt; unit" Usage="xContainer.ReplaceNodes content" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="content" Type="System.Object[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName Language="C#">[System.ParamArray]</AttributeName>
              <AttributeName Language="F#">[&lt;System.ParamArray&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="content"><span data-ttu-id="1bc1c-301">内容对象的参数列表。</span><span class="sxs-lookup"><span data-stu-id="1bc1c-301">A parameter list of content objects.</span></span></param>
        <summary><span data-ttu-id="1bc1c-302">使用指定内容替换此文档或元素的子节点。</span><span class="sxs-lookup"><span data-stu-id="1bc1c-302">Replaces the children nodes of this document or element with the specified content.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1bc1c-303">有关可传递到此函数的有效内容的详细信息，请参阅 [system.xml.linq.xelement> 和 XDocument 对象的有效内容](/dotnet/standard/linq/valid-content-xelement-xdocument-objects)。</span><span class="sxs-lookup"><span data-stu-id="1bc1c-303">For details about the valid content that can be passed to this function, see [Valid Content of XElement and XDocument Objects](/dotnet/standard/linq/valid-content-xelement-xdocument-objects).</span></span>  
  
 <span data-ttu-id="1bc1c-304">此方法将引发 <xref:System.Xml.Linq.XObject.Changed> 和 <xref:System.Xml.Linq.XObject.Changing> 事件。</span><span class="sxs-lookup"><span data-stu-id="1bc1c-304">This method will raise the <xref:System.Xml.Linq.XObject.Changed> and the <xref:System.Xml.Linq.XObject.Changing> events.</span></span>  
  
 <span data-ttu-id="1bc1c-305">此方法具有快照语义。</span><span class="sxs-lookup"><span data-stu-id="1bc1c-305">This method has snapshot semantics.</span></span> <span data-ttu-id="1bc1c-306">它首先创建新内容的副本。</span><span class="sxs-lookup"><span data-stu-id="1bc1c-306">It first creates a copy of the new content.</span></span> <span data-ttu-id="1bc1c-307">然后删除此节点的所有子节点。</span><span class="sxs-lookup"><span data-stu-id="1bc1c-307">It then removes all children nodes of this node.</span></span> <span data-ttu-id="1bc1c-308">最后，它会将新内容添加为子节点。</span><span class="sxs-lookup"><span data-stu-id="1bc1c-308">Finally, it adds the new content as children nodes.</span></span> <span data-ttu-id="1bc1c-309">这意味着您可以使用子节点本身的查询来替换子节点。</span><span class="sxs-lookup"><span data-stu-id="1bc1c-309">This means that you can replace children nodes using a query on the children nodes themselves.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="1bc1c-310">下面的示例创建一个字典和一个 XML 树。</span><span class="sxs-lookup"><span data-stu-id="1bc1c-310">The following example creates a dictionary and an XML tree.</span></span> <span data-ttu-id="1bc1c-311">然后，它将查询字典，将结果投影到 <xref:System.Collections.Generic.IEnumerable%601> 的 <xref:System.Xml.Linq.XElement> ，然后将 XML 树的内容替换为查询结果。</span><span class="sxs-lookup"><span data-stu-id="1bc1c-311">It then queries the dictionary, projects the results to an <xref:System.Collections.Generic.IEnumerable%601> of <xref:System.Xml.Linq.XElement>, and replaces the contents of the XML tree with the results of the query.</span></span>  
  
```csharp  
XElement root = new XElement("Root",  
    new XElement("Child", 1),  
    new XElement("Child", 2),  
    new XElement("Child", 3),  
    new XElement("Child", 4),  
    new XElement("Child", 5)  
);  
root.ReplaceNodes(  
    from el in root.Elements()  
    where (int)el >= 3  
    select el  
);  
Console.WriteLine(root);  
```  
  
```vb  
Dim root As XElement = _   
    <Root>  
        <Child>1</Child>  
        <Child>2</Child>  
        <Child>3</Child>  
        <Child>4</Child>  
        <Child>5</Child>  
    </Root>  
root.ReplaceNodes( _  
    From el In root.Elements _  
    Where el.Value >= 3 _  
    Select el)  
Console.WriteLine(root)  
```  
  
 <span data-ttu-id="1bc1c-312">该示例产生下面的输出：</span><span class="sxs-lookup"><span data-stu-id="1bc1c-312">This example produces the following output:</span></span>  
  
```xml  
<Root>  
  <Child>3</Child>  
  <Child>4</Child>  
  <Child>5</Child>  
</Root>  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Xml.Linq.XContainer.Add" />
        <altmember cref="M:System.Xml.Linq.XContainer.RemoveNodes" />
        <related type="Article" href="/dotnet/standard/linq/linq-xml-overview"><span data-ttu-id="1bc1c-313">LINQ to XML 概述</span><span class="sxs-lookup"><span data-stu-id="1bc1c-313">LINQ to XML overview</span></span></related>
      </Docs>
    </Member>
  </Members>
</Type>
