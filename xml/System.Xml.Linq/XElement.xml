<Type Name="XElement" FullName="System.Xml.Linq.XElement">
  <Metadata><Meta Name="ms.openlocfilehash" Value="137be4da7cedef864f25a64d20d46bd94ec4d939" /><Meta Name="ms.sourcegitcommit" Value="943c8cdbe5b47c6c296a6f4b73038bbd43da0dd2" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-CN" /><Meta Name="ms.lasthandoff" Value="02/12/2021" /><Meta Name="ms.locfileid" Value="100308321" /></Metadata><TypeSignature Language="C#" Value="public class XElement : System.Xml.Linq.XContainer, System.Xml.Serialization.IXmlSerializable" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit XElement extends System.Xml.Linq.XContainer implements class System.Xml.Serialization.IXmlSerializable" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <TypeSignature Language="DocId" Value="T:System.Xml.Linq.XElement" />
  <TypeSignature Language="VB.NET" Value="Public Class XElement&#xA;Inherits XContainer&#xA;Implements IXmlSerializable" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <TypeSignature Language="C++ CLI" Value="public ref class XElement : System::Xml::Linq::XContainer, System::Xml::Serialization::IXmlSerializable" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <TypeSignature Language="F#" Value="type XElement = class&#xA;    inherit XContainer&#xA;    interface IXmlSerializable" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <TypeSignature Language="C#" Value="public class XElement : System.Xml.Linq.XContainer" FrameworkAlternate="netstandard-1.0;netstandard-1.1;netstandard-1.2" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit XElement extends System.Xml.Linq.XContainer" FrameworkAlternate="netstandard-1.0;netstandard-1.1;netstandard-1.2" />
  <TypeSignature Language="VB.NET" Value="Public Class XElement&#xA;Inherits XContainer" FrameworkAlternate="netstandard-1.0;netstandard-1.1;netstandard-1.2" />
  <TypeSignature Language="C++ CLI" Value="public ref class XElement : System::Xml::Linq::XContainer" FrameworkAlternate="netstandard-1.0;netstandard-1.1;netstandard-1.2" />
  <TypeSignature Language="F#" Value="type XElement = class&#xA;    inherit XContainer" FrameworkAlternate="netstandard-1.0;netstandard-1.1;netstandard-1.2" />
  <AssemblyInfo>
    <AssemblyName>System.Xml.XDocument</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
    <AssemblyVersion>4.1.2.0</AssemblyVersion>
    <AssemblyVersion>5.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Xml.Linq</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>3.5.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeForwardingChain>
    <TypeForwarding From="System.Xml.Linq" FromVersion="4.0.0.0" To="System.Xml.XDocument" ToVersion="0.0.0.0" FrameworkAlternate="dotnet-uwp-10.0" />
    <TypeForwarding From="netstandard" FromVersion="2.1.0.0" To="System.Xml.XDocument" ToVersion="5.0.0.0" FrameworkAlternate="net-5.0" />
  </TypeForwardingChain>
  <Base>
    <BaseTypeName>System.Xml.Linq.XContainer</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <InterfaceName>System.Xml.Serialization.IXmlSerializable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="net-5.0">
      <AttributeName Language="C#">[System.ComponentModel.TypeDescriptionProvider("MS.Internal.Xml.Linq.ComponentModel.XTypeDescriptionProvider`1[[System.Xml.Linq.XElement, System.Xml.Linq, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]],System.ComponentModel.TypeConverter")]</AttributeName>
      <AttributeName Language="F#">[&lt;System.ComponentModel.TypeDescriptionProvider("MS.Internal.Xml.Linq.ComponentModel.XTypeDescriptionProvider`1[[System.Xml.Linq.XElement, System.Xml.Linq, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]],System.ComponentModel.TypeConverter")&gt;]</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName Language="C#">[System.Xml.Serialization.XmlSchemaProvider(null, IsAny=true)]</AttributeName>
      <AttributeName Language="F#">[&lt;System.Xml.Serialization.XmlSchemaProvider(null, IsAny=true)&gt;]</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-3.5">
      <AttributeName Language="C#">[System.ComponentModel.TypeDescriptionProvider(typeof(System.Xml.Linq.ComponentModel.XTypeDescriptionProvider`1&lt;System.Xml.Linq.XElement&gt;))]</AttributeName>
      <AttributeName Language="F#">[&lt;System.ComponentModel.TypeDescriptionProvider(typeof(System.Xml.Linq.ComponentModel.XTypeDescriptionProvider`1&lt;System.Xml.Linq.XElement&gt;))&gt;]</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName Language="C#">[System.ComponentModel.TypeDescriptionProvider(typeof(MS.Internal.Xml.Linq.ComponentModel.XTypeDescriptionProvider`1&lt;System.Xml.Linq.XElement&gt;))]</AttributeName>
      <AttributeName Language="F#">[&lt;System.ComponentModel.TypeDescriptionProvider(typeof(MS.Internal.Xml.Linq.ComponentModel.XTypeDescriptionProvider`1&lt;System.Xml.Linq.XElement&gt;))&gt;]</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8">
      <AttributeName Language="C#">[System.Xml.Serialization.XmlTypeConvertor("ConvertForAssignment")]</AttributeName>
      <AttributeName Language="F#">[&lt;System.Xml.Serialization.XmlTypeConvertor("ConvertForAssignment")&gt;]</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="b21d2-101">表示一个 XML 元素。</span><span class="sxs-lookup"><span data-stu-id="b21d2-101">Represents an XML element.</span></span>  <span data-ttu-id="b21d2-102">有关用法信息和示例，请参阅本页的 <see href="https://docs.microsoft.com/dotnet/csharp/programming-guide/concepts/linq/xelement-class-overview">XElement 类概述</see>和“备注”部分。</span><span class="sxs-lookup"><span data-stu-id="b21d2-102">See <see href="https://docs.microsoft.com/dotnet/csharp/programming-guide/concepts/linq/xelement-class-overview">XElement Class Overview</see> and the Remarks section on this page for usage information and examples.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b21d2-103">此类表示 XML 元素，这是基本的 XML 构造。</span><span class="sxs-lookup"><span data-stu-id="b21d2-103">This class represents an XML element, the fundamental XML construct.</span></span>  <span data-ttu-id="b21d2-104">有关其他用法信息，请参阅 [System.xml.linq.xelement> 类概述](/dotnet/csharp/programming-guide/concepts/linq/xelement-class-overview) 。</span><span class="sxs-lookup"><span data-stu-id="b21d2-104">See [XElement Class Overview](/dotnet/csharp/programming-guide/concepts/linq/xelement-class-overview) for other usage information.</span></span>  
  
 <span data-ttu-id="b21d2-105">元素具有 <xref:System.Xml.Linq.XName> 、选择性地包含一个或多个属性，还可以选择包含内容 (有关详细信息，请参阅 <xref:System.Xml.Linq.XContainer.Nodes%2A>) 。</span><span class="sxs-lookup"><span data-stu-id="b21d2-105">An element has an <xref:System.Xml.Linq.XName>, optionally one or more attributes, and can optionally contain content (for more information, see <xref:System.Xml.Linq.XContainer.Nodes%2A>).</span></span>  
  
 <span data-ttu-id="b21d2-106"><xref:System.Xml.Linq.XElement>可以包含以下类型的内容：</span><span class="sxs-lookup"><span data-stu-id="b21d2-106">An <xref:System.Xml.Linq.XElement> can contain the following types of content:</span></span>  
  
-   <xref:System.Xml.Linq.XElement>  
  
-   <xref:System.Xml.Linq.XComment>  
  
-   <xref:System.Xml.Linq.XProcessingInstruction>  
  
-   <xref:System.Xml.Linq.XText>  
  
 <span data-ttu-id="b21d2-107">有关的有效内容的详细信息 <xref:System.Xml.Linq.XElement> ，请参阅 [System.xml.linq.xelement> 和 XDocument 对象的有效内容](/dotnet/standard/linq/valid-content-xelement-xdocument-objects)。</span><span class="sxs-lookup"><span data-stu-id="b21d2-107">For details about the valid content of an <xref:System.Xml.Linq.XElement>, see [Valid Content of XElement and XDocument Objects](/dotnet/standard/linq/valid-content-xelement-xdocument-objects).</span></span>  
  
 <span data-ttu-id="b21d2-108"><xref:System.Xml.Linq.XElement> 派生自 <xref:System.Xml.Linq.XContainer> ，它派生自 <xref:System.Xml.Linq.XNode> 。</span><span class="sxs-lookup"><span data-stu-id="b21d2-108"><xref:System.Xml.Linq.XElement> derives from <xref:System.Xml.Linq.XContainer>, which derives from <xref:System.Xml.Linq.XNode>.</span></span>  
  
 <span data-ttu-id="b21d2-109">某些 <xref:System.Xml.Linq.XElement> 方法可从 XAML 使用。</span><span class="sxs-lookup"><span data-stu-id="b21d2-109">Some <xref:System.Xml.Linq.XElement> methods can be used from XAML.</span></span> <span data-ttu-id="b21d2-110">有关详细信息，请参阅 [LINQ to XML 动态属性](/dotnet/desktop/wpf/data/linq-to-xml-dynamic-properties)。</span><span class="sxs-lookup"><span data-stu-id="b21d2-110">For more information, see [LINQ to XML Dynamic Properties](/dotnet/desktop/wpf/data/linq-to-xml-dynamic-properties).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b21d2-111">下面的示例创建一个 XML 树。</span><span class="sxs-lookup"><span data-stu-id="b21d2-111">The following example creates an XML tree.</span></span> <span data-ttu-id="b21d2-112">新元素的内容来自 LINQ 查询。</span><span class="sxs-lookup"><span data-stu-id="b21d2-112">The content of the new element comes from a LINQ query.</span></span>  
  
```csharp  
XElement xmlTree1 = new XElement("Root",  
    new XElement("Child1", 1),  
    new XElement("Child2", 2),  
    new XElement("Child3", 3),  
    new XElement("Child4", 4),  
    new XElement("Child5", 5),  
    new XElement("Child6", 6)  
);  
  
XElement xmlTree2 = new XElement("Root",  
    from el in xmlTree1.Elements()  
    where((int)el >= 3 && (int)el <= 5)  
    select el  
);  
Console.WriteLine(xmlTree2);  
```  
  
```vb  
Dim xmlTree1 As XElement = _  
        <Root>  
            <Child1>1</Child1>  
            <Child2>2</Child2>  
            <Child3>3</Child3>  
            <Child4>4</Child4>  
            <Child5>5</Child5>  
            <Child6>6</Child6>  
        </Root>  
  
Dim xmlTree2 As XElement = _   
    <Root>  
        <%= From el In xmlTree1.Elements() _  
            Where el.Value >= 3 And el.Value <= 5 _  
            Select el %>  
    </Root>  
  
Console.WriteLine(xmlTree2)  
```  
  
 <span data-ttu-id="b21d2-113">该示例产生下面的输出：</span><span class="sxs-lookup"><span data-stu-id="b21d2-113">This example produces the following output:</span></span>  
  
```xml  
<Root>  
  <Child3>3</Child3>  
  <Child4>4</Child4>  
  <Child5>5</Child5>  
</Root>  
```  
  
 <span data-ttu-id="b21d2-114">下面是同一个示例，但在这种情况下，XML 位于命名空间中。</span><span class="sxs-lookup"><span data-stu-id="b21d2-114">The following is the same example, but in this case the XML is in a namespace.</span></span> <span data-ttu-id="b21d2-115">有关详细信息，请参阅 [使用 XML 命名空间](/dotnet/standard/linq/namespaces-overview)。</span><span class="sxs-lookup"><span data-stu-id="b21d2-115">For more information, see [Work with XML Namespaces](/dotnet/standard/linq/namespaces-overview).</span></span>  
  
```csharp  
XNamespace aw = "http://www.adventure-works.com";  
XElement xmlTree1 = new XElement(aw + "Root",  
    new XElement(aw + "Child1", 1),  
    new XElement(aw + "Child2", 2),  
    new XElement(aw + "Child3", 3),  
    new XElement(aw + "Child4", 4),  
    new XElement(aw + "Child5", 5),  
    new XElement(aw + "Child6", 6)  
);  
  
XElement xmlTree2 = new XElement(aw + "Root",  
    from el in xmlTree1.Elements()  
    where((int)el >= 3 && (int)el <= 5)  
    select el  
);  
Console.WriteLine(xmlTree2);  
```  
  
```vb  
Imports <xmlns="http://www.adventure-works.com">  
  
Module Module1  
    Sub Main()  
        Dim xmlTree1 As XElement = _  
            <Root>  
                <Child1>1</Child1>  
                <Child2>2</Child2>  
                <Child3>3</Child3>  
                <Child4>4</Child4>  
                <Child5>5</Child5>  
                <Child6>6</Child6>  
            </Root>  
  
        Dim xmlTree2 As XElement = _   
            <Root>  
                <%= From el In xmlTree1.Elements() _  
                    Where el.Value >= 3 And el.Value <= 5 _  
                    Select el %>  
            </Root>  
  
        Console.WriteLine(xmlTree2)  
    End SUb  
End Module  
```  
  
 <span data-ttu-id="b21d2-116">该示例产生下面的输出：</span><span class="sxs-lookup"><span data-stu-id="b21d2-116">This example produces the following output:</span></span>  
  
```xml  
<Root xmlns="http://www.adventure-works.com">  
  <Child3>3</Child3>  
  <Child4>4</Child4>  
  <Child5>5</Child5>  
</Root>  
```  
  
 ]]></format>
    </remarks>
    <related type="Article" href="/dotnet/standard/linq/linq-xml-overview"><span data-ttu-id="b21d2-117">LINQ to XML 概述</span><span class="sxs-lookup"><span data-stu-id="b21d2-117">LINQ to XML overview</span></span></related>
    <related type="Article" href="/dotnet/desktop/wpf/data/linq-to-xml-dynamic-properties"><span data-ttu-id="b21d2-118">LINQ to XML 动态属性</span><span class="sxs-lookup"><span data-stu-id="b21d2-118">LINQ to XML Dynamic Properties</span></span></related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="b21d2-119">初始化 <see cref="T:System.Xml.Linq.XElement" /> 类的新实例。</span><span class="sxs-lookup"><span data-stu-id="b21d2-119">Initializes a new instance of the <see cref="T:System.Xml.Linq.XElement" /> class.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b21d2-120">有关可传递到此构造函数的有效内容的详细信息，请参阅 [system.xml.linq.xelement> 和 XDocument 对象的有效内容](/dotnet/standard/linq/valid-content-xelement-xdocument-objects)。</span><span class="sxs-lookup"><span data-stu-id="b21d2-120">For details about the valid content that can be passed to this constructor, see [Valid Content of XElement and XDocument Objects](/dotnet/standard/linq/valid-content-xelement-xdocument-objects).</span></span>  
  
 <span data-ttu-id="b21d2-121">存在从字符串到的隐式转换 <xref:System.Xml.Linq.XName> 。</span><span class="sxs-lookup"><span data-stu-id="b21d2-121">There is an implicit conversion from string to <xref:System.Xml.Linq.XName>.</span></span> <span data-ttu-id="b21d2-122">此构造函数的典型用法是将字符串指定为参数，而不是创建新的 <xref:System.Xml.Linq.XName> 。</span><span class="sxs-lookup"><span data-stu-id="b21d2-122">Typical use of this constructor is to specify a string as the parameter instead of creating a new <xref:System.Xml.Linq.XName>.</span></span>  
  
 <span data-ttu-id="b21d2-123">在命名空间中创建元素时，典型用途是将加法运算符重载用于 <xref:System.Xml.Linq.XNamespace> ，并使用字符串创建 <xref:System.Xml.Linq.XName> 。</span><span class="sxs-lookup"><span data-stu-id="b21d2-123">When creating an element in a namespace, typical use is to use the addition operator overload with an <xref:System.Xml.Linq.XNamespace> and a string to create an <xref:System.Xml.Linq.XName>.</span></span> <span data-ttu-id="b21d2-124">有关详细信息，请参阅 [使用 XML 命名空间](/dotnet/standard/linq/namespaces-overview)。</span><span class="sxs-lookup"><span data-stu-id="b21d2-124">For more information, see [Work with XML Namespaces](/dotnet/standard/linq/namespaces-overview).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b21d2-125">下面的示例创建一个 XML 树。</span><span class="sxs-lookup"><span data-stu-id="b21d2-125">The following example creates an XML tree.</span></span> <span data-ttu-id="b21d2-126">新元素的内容来自 LINQ 查询。</span><span class="sxs-lookup"><span data-stu-id="b21d2-126">The content of the new element comes from a LINQ query.</span></span>  
  
```csharp  
XElement xmlTree1 = new XElement("Root",  
    new XElement("Child", 1),  
    new XElement("Child", 2),  
    new XElement("Child", 3),  
    new XElement("Child", 4),  
    new XElement("Child", 5),  
    new XElement("Child", 6)  
);  
  
XElement xmlTree2 = new XElement("Root",  
    from el in xmlTree1.Elements()  
    where((int)el >= 3 && (int)el <= 5)  
    select el  
);  
Console.WriteLine(xmlTree2);  
```  
  
```vb  
Dim xmlTree1 As XElement = _   
        <Root>  
            <Child>1</Child>  
            <Child>2</Child>  
            <Child>3</Child>  
            <Child>4</Child>  
            <Child>5</Child>  
            <Child>6</Child>  
        </Root>  
  
Dim xmlTree2 As XElement = _  
    <Root>  
        <%= From el In xmlTree1.Elements() _  
            Where el.Value >= 3 And el.Value <= 5 _  
            Select el %>  
    </Root>  
  
Console.WriteLine(xmlTree2)  
```  
  
 <span data-ttu-id="b21d2-127">该示例产生下面的输出：</span><span class="sxs-lookup"><span data-stu-id="b21d2-127">This example produces the following output:</span></span>  
  
```xml  
<Root>  
  <Child>3</Child>  
  <Child>4</Child>  
  <Child>5</Child>  
</Root>  
```  
  
 ]]></format>
        </remarks>
        <related type="Article" href="/dotnet/standard/linq/linq-xml-overview"><span data-ttu-id="b21d2-128">LINQ to XML 概述</span><span class="sxs-lookup"><span data-stu-id="b21d2-128">LINQ to XML overview</span></span></related>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XElement (System.Xml.Linq.XElement other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Xml.Linq.XElement other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XElement.#ctor(System.Xml.Linq.XElement)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (other As XElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XElement(System::Xml::Linq::XElement ^ other);" />
      <MemberSignature Language="F#" Value="new System.Xml.Linq.XElement : System.Xml.Linq.XElement -&gt; System.Xml.Linq.XElement" Usage="new System.Xml.Linq.XElement other" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="other" Type="System.Xml.Linq.XElement" />
      </Parameters>
      <Docs>
        <param name="other"><span data-ttu-id="b21d2-129">要从其复制的 <see cref="T:System.Xml.Linq.XElement" /> 对象。</span><span class="sxs-lookup"><span data-stu-id="b21d2-129">An <see cref="T:System.Xml.Linq.XElement" /> object to copy from.</span></span></param>
        <summary><span data-ttu-id="b21d2-130">从其他 <see cref="T:System.Xml.Linq.XElement" /> 对象初始化 <see cref="T:System.Xml.Linq.XElement" /> 类的新实例。</span><span class="sxs-lookup"><span data-stu-id="b21d2-130">Initializes a new instance of the <see cref="T:System.Xml.Linq.XElement" /> class from another <see cref="T:System.Xml.Linq.XElement" /> object.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b21d2-131">此构造函数生成元素的深层副本。</span><span class="sxs-lookup"><span data-stu-id="b21d2-131">This constructor makes a deep copy of an element.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b21d2-132">下面的示例创建一个 XML 树，创建该树的一个克隆，然后调用 <xref:System.Xml.Linq.XNode.DeepEquals%2A> ，这会测试两个 XML 树是否相等。</span><span class="sxs-lookup"><span data-stu-id="b21d2-132">The following example creates an XML tree, creates a clone of the tree, and then calls <xref:System.Xml.Linq.XNode.DeepEquals%2A>, which tests whether the two XML trees are equal.</span></span>  
  
```csharp  
XElement xmlTree = new XElement("Root",  
    new XAttribute("Att1", 1),  
    new XElement("Child1", 1),  
    new XElement("Child2", 2)  
);  
  
// Create a clone of the tree.  
XElement treeClone = new XElement(xmlTree);  
  
Console.WriteLine("xmlTree = treeClone: {0}", XNode.DeepEquals(xmlTree, treeClone));  
  
// Do some work with xmlTree, perhaps pass it to other methods.  
xmlTree.Add(new XElement("Child3", 3));  
  
Console.WriteLine("xmlTree = treeClone: {0}", XNode.DeepEquals(xmlTree, treeClone));  
```  
  
```vb  
Dim xmlTree As XElement = _  
        <Root Att1="1">  
            <Child1>1</Child1>  
            <Child2>2</Child2>  
        </Root>  
  
' Create a clone of the tree.  
Dim treeClone As XElement = New XElement(xmlTree)  
  
Console.WriteLine("xmlTree = treeClone: {0}", XNode.DeepEquals(xmlTree, treeClone))  
  
' Do some work with xmlTree, perhaps pass it to other methods.  
xmlTree.Add(New XElement("Child3", 3))  
  
Console.WriteLine("xmlTree = treeClone: {0}", XNode.DeepEquals(xmlTree, treeClone))  
```  
  
 <span data-ttu-id="b21d2-133">该示例产生下面的输出：</span><span class="sxs-lookup"><span data-stu-id="b21d2-133">This example produces the following output:</span></span>  
  
```  
xmlTree = treeClone: True  
xmlTree = treeClone: False  
```  
  
 ]]></format>
        </remarks>
        <related type="Article" href="/dotnet/standard/linq/linq-xml-overview"><span data-ttu-id="b21d2-134">LINQ to XML 概述</span><span class="sxs-lookup"><span data-stu-id="b21d2-134">LINQ to XML overview</span></span></related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XElement (System.Xml.Linq.XName name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Xml.Linq.XName name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XElement.#ctor(System.Xml.Linq.XName)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As XName)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XElement(System::Xml::Linq::XName ^ name);" />
      <MemberSignature Language="F#" Value="new System.Xml.Linq.XElement : System.Xml.Linq.XName -&gt; System.Xml.Linq.XElement" Usage="new System.Xml.Linq.XElement name" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="name" Type="System.Xml.Linq.XName" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="b21d2-135">一个包含元素名称的 <see cref="T:System.Xml.Linq.XName" />。</span><span class="sxs-lookup"><span data-stu-id="b21d2-135">An <see cref="T:System.Xml.Linq.XName" /> that contains the name of the element.</span></span></param>
        <summary><span data-ttu-id="b21d2-136">用指定的名称初始化 <see cref="T:System.Xml.Linq.XElement" /> 类的新实例。</span><span class="sxs-lookup"><span data-stu-id="b21d2-136">Initializes a new instance of the <see cref="T:System.Xml.Linq.XElement" /> class with the specified name.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b21d2-137">此构造函数将创建一个不带任何内容且没有属性的元素。</span><span class="sxs-lookup"><span data-stu-id="b21d2-137">This constructor creates an element with no content and no attributes.</span></span>  
  
 <span data-ttu-id="b21d2-138">存在从字符串到的隐式转换 <xref:System.Xml.Linq.XName> 。</span><span class="sxs-lookup"><span data-stu-id="b21d2-138">There is an implicit conversion from string to <xref:System.Xml.Linq.XName>.</span></span> <span data-ttu-id="b21d2-139">此构造函数的典型用法是将字符串指定为参数，而不是创建新的 <xref:System.Xml.Linq.XName> 。</span><span class="sxs-lookup"><span data-stu-id="b21d2-139">Typical use of this constructor is to specify a string as the parameter instead of creating a new <xref:System.Xml.Linq.XName>.</span></span> <span data-ttu-id="b21d2-140">在命名空间中创建元素时，典型用途是将加法运算符重载用于 <xref:System.Xml.Linq.XNamespace> ，并使用字符串创建 <xref:System.Xml.Linq.XName> 。</span><span class="sxs-lookup"><span data-stu-id="b21d2-140">When creating an element in a namespace, typical use is to use the addition operator overload with an <xref:System.Xml.Linq.XNamespace> and a string to create an <xref:System.Xml.Linq.XName>.</span></span> <span data-ttu-id="b21d2-141">有关详细信息，请参阅 [使用 XML 命名空间](/dotnet/standard/linq/namespaces-overview)。</span><span class="sxs-lookup"><span data-stu-id="b21d2-141">For more information, see [Work with XML Namespaces](/dotnet/standard/linq/namespaces-overview).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b21d2-142">下面的示例创建一个无内容的元素。</span><span class="sxs-lookup"><span data-stu-id="b21d2-142">The following example creates an element with no content.</span></span>  
  
```csharp  
XElement el = new XElement("Root");  
Console.WriteLine(el);  
```  
  
```vb  
Dim el As XElement = <Root/>  
Console.WriteLine(el)  
```  
  
 <span data-ttu-id="b21d2-143">该示例产生下面的输出：</span><span class="sxs-lookup"><span data-stu-id="b21d2-143">This example produces the following output:</span></span>  
  
```xml  
<Root />  
```  
  
 <span data-ttu-id="b21d2-144">下面的示例在命名空间中创建不含任何内容的元素。</span><span class="sxs-lookup"><span data-stu-id="b21d2-144">The following example creates an element in a namespace with no content.</span></span> <span data-ttu-id="b21d2-145">有关详细信息，请参阅 [使用 XML 命名空间](/dotnet/standard/linq/namespaces-overview)。</span><span class="sxs-lookup"><span data-stu-id="b21d2-145">For more information, see [Work with XML Namespaces](/dotnet/standard/linq/namespaces-overview).</span></span>  
  
```csharp
XNamespace aw = "http://www.adventure-works.com";  
XElement root = new XElement(aw + "Root");  
Console.WriteLine(root);  
```  
  
```vb  
Imports <xmlns="http://www.adventure-works.com">  
  
Module Module1  
    Sub Main()  
        Dim root = <Root/>  
        Console.WriteLine(root)  
    End Sub  
End Module  
```  
  
 <span data-ttu-id="b21d2-146">该示例产生下面的输出：</span><span class="sxs-lookup"><span data-stu-id="b21d2-146">This example produces the following output:</span></span>  
  
```xml  
<Root xmlns="http://www.adventure-works.com" />  
```  
  
 ]]></format>
        </remarks>
        <related type="Article" href="/dotnet/standard/linq/linq-xml-overview"><span data-ttu-id="b21d2-147">LINQ to XML 概述</span><span class="sxs-lookup"><span data-stu-id="b21d2-147">LINQ to XML overview</span></span></related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XElement (System.Xml.Linq.XStreamingElement other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Xml.Linq.XStreamingElement other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XElement.#ctor(System.Xml.Linq.XStreamingElement)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (other As XStreamingElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XElement(System::Xml::Linq::XStreamingElement ^ other);" />
      <MemberSignature Language="F#" Value="new System.Xml.Linq.XElement : System.Xml.Linq.XStreamingElement -&gt; System.Xml.Linq.XElement" Usage="new System.Xml.Linq.XElement other" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="other" Type="System.Xml.Linq.XStreamingElement" />
      </Parameters>
      <Docs>
        <param name="other"><span data-ttu-id="b21d2-148">一个包含未求值查询的 <see cref="T:System.Xml.Linq.XStreamingElement" />，将对此 <see cref="T:System.Xml.Linq.XElement" /> 的内容循环进行这样的查询。</span><span class="sxs-lookup"><span data-stu-id="b21d2-148">An <see cref="T:System.Xml.Linq.XStreamingElement" /> that contains unevaluated queries that will be iterated for the contents of this <see cref="T:System.Xml.Linq.XElement" />.</span></span></param>
        <summary><span data-ttu-id="b21d2-149">从一个 <see cref="T:System.Xml.Linq.XElement" /> 对象初始化 <see cref="T:System.Xml.Linq.XStreamingElement" /> 类的新实例。</span><span class="sxs-lookup"><span data-stu-id="b21d2-149">Initializes a new instance of the <see cref="T:System.Xml.Linq.XElement" /> class from an <see cref="T:System.Xml.Linq.XStreamingElement" /> object.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b21d2-150">此构造函数循环访问指定的的内容 <xref:System.Xml.Linq.XStreamingElement> ，并创建具有其内容的元素。</span><span class="sxs-lookup"><span data-stu-id="b21d2-150">This constructor iterates through the contents of the specified <xref:System.Xml.Linq.XStreamingElement>, and creates an element with its contents.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b21d2-151">下面的示例创建一个源 XML 树，然后 <xref:System.Xml.Linq.XStreamingElement> 基于源 xml 树上的查询创建一个。</span><span class="sxs-lookup"><span data-stu-id="b21d2-151">The following example creates a source XML tree, and then creates an <xref:System.Xml.Linq.XStreamingElement> from a query on the source XML tree.</span></span> <span data-ttu-id="b21d2-152">然后，它将序列化为 <xref:System.Xml.Linq.XStreamingElement> 控制台，将新元素添加到源 XML 树，然后再次序列化 <xref:System.Xml.Linq.XStreamingElement> 。</span><span class="sxs-lookup"><span data-stu-id="b21d2-152">It then serializes the <xref:System.Xml.Linq.XStreamingElement> to the console, adds a new element to the source XML tree, and then serializes the <xref:System.Xml.Linq.XStreamingElement> again.</span></span> <span data-ttu-id="b21d2-153">您可以看到，新添加到源 XML 树的元素不包含在第一个序列化中，而是在第二个序列中包含。</span><span class="sxs-lookup"><span data-stu-id="b21d2-153">You can see that element newly added to the source XML tree is not included in the first serialization, but is included in the second.</span></span>  
  
```csharp  
XElement src = new XElement("Root",  
                   new XElement("Child1", 1),  
                   new XElement("Child2", 2),  
                   new XElement("Child3", 3)  
               );  
XStreamingElement xse = new XStreamingElement("NewRoot",  
                            from el in src.Elements()  
                            where (int)el >= 2  
                            select el  
                        );  
Console.WriteLine(xse);  
src.Add(new XElement("Child4", 4));  
Console.WriteLine("----");  
Console.WriteLine(xse);  
```  
  
```vb  
Dim src As XElement = _   
        <Root>  
            <Child1>1</Child1>  
            <Child2>2</Child2>  
            <Child3>3</Child3>  
        </Root>  
Dim xse As XStreamingElement = New XStreamingElement("NewRoot", _  
        From el In src.Elements() _  
        Where (CInt(el) >= 2) _  
        Select el _  
)  
Console.WriteLine(xse)  
src.Add(New XElement("Child4", 4))  
Console.WriteLine("----")  
Console.WriteLine(xse)  
```  
  
 <span data-ttu-id="b21d2-154">该示例产生下面的输出：</span><span class="sxs-lookup"><span data-stu-id="b21d2-154">This example produces the following output:</span></span>  
  
```  
<NewRoot>  
  <Child2>2</Child2>  
  <Child3>3</Child3>  
</NewRoot>  
----  
<NewRoot>  
  <Child2>2</Child2>  
  <Child3>3</Child3>  
  <Child4>4</Child4>  
</NewRoot>  
```  
  
 ]]></format>
        </remarks>
        <related type="Article" href="/dotnet/standard/linq/linq-xml-overview"><span data-ttu-id="b21d2-155">LINQ to XML 概述</span><span class="sxs-lookup"><span data-stu-id="b21d2-155">LINQ to XML overview</span></span></related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XElement (System.Xml.Linq.XName name, object content);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Xml.Linq.XName name, object content) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XElement.#ctor(System.Xml.Linq.XName,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As XName, content As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XElement(System::Xml::Linq::XName ^ name, System::Object ^ content);" />
      <MemberSignature Language="F#" Value="new System.Xml.Linq.XElement : System.Xml.Linq.XName * obj -&gt; System.Xml.Linq.XElement" Usage="new System.Xml.Linq.XElement (name, content)" />
      <MemberSignature Language="C#" Value="public XElement (System.Xml.Linq.XName name, object? content);" FrameworkAlternate="net-5.0" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="name" Type="System.Xml.Linq.XName" />
        <Parameter Name="content" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="b21d2-156">一个包含元素名称的 <see cref="T:System.Xml.Linq.XName" />。</span><span class="sxs-lookup"><span data-stu-id="b21d2-156">An <see cref="T:System.Xml.Linq.XName" /> that contains the element name.</span></span></param>
        <param name="content"><span data-ttu-id="b21d2-157">元素的内容。</span><span class="sxs-lookup"><span data-stu-id="b21d2-157">The contents of the element.</span></span></param>
        <summary><span data-ttu-id="b21d2-158">用指定的名称和内容初始化 <see cref="T:System.Xml.Linq.XElement" /> 类的新实例。</span><span class="sxs-lookup"><span data-stu-id="b21d2-158">Initializes a new instance of the <see cref="T:System.Xml.Linq.XElement" /> class with the specified name and content.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b21d2-159">此构造函数使用指定的内容和特性创建一个元素。</span><span class="sxs-lookup"><span data-stu-id="b21d2-159">This constructor creates an element with the specified content and attributes.</span></span>  
  
 <span data-ttu-id="b21d2-160">存在从字符串到的隐式转换 <xref:System.Xml.Linq.XName> 。</span><span class="sxs-lookup"><span data-stu-id="b21d2-160">There is an implicit conversion from string to <xref:System.Xml.Linq.XName>.</span></span> <span data-ttu-id="b21d2-161">此构造函数的典型用法是将字符串指定为参数，而不是创建新的 <xref:System.Xml.Linq.XName> 。</span><span class="sxs-lookup"><span data-stu-id="b21d2-161">Typical use of this constructor is to specify a string as the parameter instead of creating a new <xref:System.Xml.Linq.XName>.</span></span>  
  
 <span data-ttu-id="b21d2-162">在命名空间中创建元素时，典型用途是将加法运算符重载用于 <xref:System.Xml.Linq.XNamespace> ，并使用字符串创建 <xref:System.Xml.Linq.XName> 。</span><span class="sxs-lookup"><span data-stu-id="b21d2-162">When creating an element in a namespace, typical use is to use the addition operator overload with an <xref:System.Xml.Linq.XNamespace> and a string to create an <xref:System.Xml.Linq.XName>.</span></span> <span data-ttu-id="b21d2-163">有关详细信息，请参阅 [使用 XML 命名空间](/dotnet/standard/linq/namespaces-overview)。</span><span class="sxs-lookup"><span data-stu-id="b21d2-163">For more information, see [Work with XML Namespaces](/dotnet/standard/linq/namespaces-overview).</span></span>  
  
 <span data-ttu-id="b21d2-164">有关可传递到此构造函数的有效内容的详细信息，请参阅 [system.xml.linq.xelement> 和 XDocument 对象的有效内容](/dotnet/standard/linq/valid-content-xelement-xdocument-objects)。</span><span class="sxs-lookup"><span data-stu-id="b21d2-164">For details about the valid content that can be passed to this constructor, see [Valid Content of XElement and XDocument Objects](/dotnet/standard/linq/valid-content-xelement-xdocument-objects).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b21d2-165">下面的示例创建一个 XML 树。</span><span class="sxs-lookup"><span data-stu-id="b21d2-165">The following example creates an XML tree.</span></span> <span data-ttu-id="b21d2-166">新元素的内容来自 LINQ 查询。</span><span class="sxs-lookup"><span data-stu-id="b21d2-166">The content of the new element comes from a LINQ query.</span></span>  
  
```csharp  
XElement xmlTree1 = new XElement("Root",  
    new XElement("Child1", 1),  
    new XElement("Child2", 2),  
    new XElement("Child3", 3),  
    new XElement("Child4", 4),  
    new XElement("Child5", 5),  
    new XElement("Child6", 6)  
);  
  
XElement xmlTree2 = new XElement("Root",  
    from el in xmlTree1.Elements()  
    where((int)el >= 3 && (int)el <= 5)  
    select el  
);  
Console.WriteLine(xmlTree2);  
```  
  
```vb  
Dim xmlTree1 As XElement = _   
        <Root>  
            <Child1>1</Child1>  
            <Child2>2</Child2>  
            <Child3>3</Child3>  
            <Child4>4</Child4>  
            <Child5>5</Child5>  
            <Child6>6</Child6>  
        </Root>  
  
Dim xmlTree2 As XElement = _  
    <Root>  
        <%= From el In xmlTree1.Elements() _  
            Where el.Value >= 3 And el.Value <= 5 _  
            Select el %>  
    </Root>  
  
Console.WriteLine(xmlTree2)  
```  
  
 <span data-ttu-id="b21d2-167">该示例产生下面的输出：</span><span class="sxs-lookup"><span data-stu-id="b21d2-167">This example produces the following output:</span></span>  
  
```xml  
<Root>  
  <Child3>3</Child3>  
  <Child4>4</Child4>  
  <Child5>5</Child5>  
</Root>  
```  
  
 <span data-ttu-id="b21d2-168">下面的示例创建一个 XML 树，其中包含各种类型的内容。</span><span class="sxs-lookup"><span data-stu-id="b21d2-168">The following example creates an XML tree with a variety of types of content.</span></span>  
  
```csharp  
XElement root;  
  
// String content:  
root = new XElement("Root", "Some text");  
Console.WriteLine(root);  
  
// XElement object content:  
root = new XElement("Root",   
    new XElement("NewChild", "n")  
);  
Console.WriteLine(root);  
  
// XAttribute object content:  
root = new XElement("Root",   
    new XAttribute("NewAttribute", "n")  
);  
Console.WriteLine(root);  
  
// Double content:  
double dbl = 12.345;  
root = new XElement("Root", dbl);  
Console.WriteLine(root);  
  
// DateTime content:  
DateTime dt = new DateTime(2006, 10, 6, 12, 30, 00);  
root = new XElement("Root", dt);  
Console.WriteLine(root);  
  
// String array content:  
// Any collection other than a collection of XElement or XAttribute objects  
// are converted to strings. The strings are concatenated and added.  
string[] stringArray = {  
    "abc",  
    "def",  
    "ghi"  
};  
root = new XElement("Root", stringArray);  
Console.WriteLine(root);  
  
// XElement object array content:  
XElement[] ellArray = {  
    new XElement("NewChild1", 1),  
    new XElement("NewChild2", 2),  
    new XElement("NewChild3", 3)  
};  
root = new XElement("Root", ellArray);  
Console.WriteLine(root);  
  
// XAttribute object array content:  
XAttribute[] attArray = {  
    new XAttribute("NewAtt1", 1),  
    new XAttribute("NewAtt2", 2),  
    new XAttribute("NewAtt3", 3)  
};  
root = new XElement("Root", attArray);  
Console.WriteLine(root);  
```  
  
```vb  
Dim root As XElement  
  
' String content:  
root = <Root>Some text</Root>  
Console.WriteLine(root)  
  
' XElement object content:  
root = <Root>  
           <NewChild>n</NewChild>  
       </Root>  
Console.WriteLine(root)  
  
' XAttribute object content:  
root = <Root NewAttribute="n"/>  
Console.WriteLine(root)  
  
' Double content:  
Dim dbl As Double = 12.345  
root = <Root><%= dbl %></Root>  
Console.WriteLine(root)  
  
' DateTime content:  
Dim dt As DateTime = New DateTime(2006, 10, 6, 12, 30, 0)  
root = <Root><%= dt %></Root>  
Console.WriteLine(root)  
  
' String array content:  
' Any collection other than a collection of XElement or XAttribute objects  
' are converted to strings. The strings are concatenated and added.  
  
Dim stringArray As String() = { _  
    "abc", _  
    "def", _  
    "ghi" _  
}  
root = <Root><%= stringArray %></Root>  
Console.WriteLine(root)  
  
' XElement object array content:  
Dim ellArray As XElement() = { _  
    <NewChild1>1</NewChild1>, _  
    <NewChild2>2</NewChild2>, _  
    <NewChild3>3</NewChild3> _  
}  
  
root = <Root><%= ellArray %></Root>  
Console.WriteLine(root)  
  
' XAttribute object array content  
Dim attArray As XAttribute() = { _  
    New XAttribute("NewAtt1", 1), _  
    New XAttribute("NewAtt2", 2), _  
    New XAttribute("NewAtt3", 3) _  
}  
root = <Root><%= attArray %></Root>  
Console.WriteLine(root)  
```  
  
 <span data-ttu-id="b21d2-169">该示例产生下面的输出：</span><span class="sxs-lookup"><span data-stu-id="b21d2-169">This example produces the following output:</span></span>  
  
```xml
<Root>Some text</Root>  
<Root>  
  <NewChild>n</NewChild>  
</Root>  
<Root NewAttribute="n" />  
<Root>12.345</Root>  
<Root>2006-10-06T12:30:00</Root>  
<Root>abcdefghi</Root>  
<Root>  
  <NewChild1>1</NewChild1>  
  <NewChild2>2</NewChild2>  
  <NewChild3>3</NewChild3>  
</Root>  
<Root NewAtt1="1" NewAtt2="2" NewAtt3="3" />  
```  
  
 <span data-ttu-id="b21d2-170">下面的示例在命名空间中创建一个 XML 树。</span><span class="sxs-lookup"><span data-stu-id="b21d2-170">The following example creates an XML tree in a namespace.</span></span>  
  
```csharp  
// Create an XML tree in a namespace.  
XNamespace aw = "http://www.adventure-works.com";  
XElement root = new XElement(aw + "Root",  
    new XElement(aw + "Child", "child content")  
);  
Console.WriteLine(root);  
```  
  
```vb  
' Create an XML tree in a namespace.  
Dim root As XElement = _   
    <Root xmlns='http://www.adventure-works.com'>  
        <Child>child content</Child>  
    </Root>  
Console.WriteLine(root)  
```  
  
 <span data-ttu-id="b21d2-171">该示例产生下面的输出：</span><span class="sxs-lookup"><span data-stu-id="b21d2-171">This example produces the following output:</span></span>  
  
```xml  
<Root xmlns="http://www.adventure-works.com">  
  <Child>child content</Child>  
</Root>  
```  
  
 <span data-ttu-id="b21d2-172">下面的示例创建一个带有嵌套命名空间的 XML 树。</span><span class="sxs-lookup"><span data-stu-id="b21d2-172">The following example creates an XML tree with nested namespaces.</span></span>  
  
```csharp  
// Create an XML tree with nested namespaces.  
XNamespace aw = "http://www.adventure-works.com";  
XNamespace fc = "www.fourthcoffee.com";  
XDocument root = new XDocument(  
    new XDeclaration("1.0", "utf-8", "yes"),  
    new XElement(aw + "Root",  
        new XElement(fc + "Child",  
            new XElement(aw + "DifferentChild", "other content")  
        )  
    )  
);  
Console.WriteLine(root);  
```  
  
```vb  
' Create an XML tree with nested namespaces.  
Dim root As XDocument = _   
    <?xml version='1.0'?>  
    <Root xmlns='http://www.adventure-works.com'>  
        <Child xmlns='www.fourthcoffee.com'>  
        <DifferentChild xmlns='http://www.adventure-works.com'>other content</DifferentChild>  
        </Child>  
    </Root>  
Console.WriteLine(root)  
```  
  
 <span data-ttu-id="b21d2-173">该示例产生下面的输出：</span><span class="sxs-lookup"><span data-stu-id="b21d2-173">This example produces the following output:</span></span>  
  
```xml  
<Root xmlns="http://www.adventure-works.com">  
  <Child xmlns="www.fourthcoffee.com">  
    <DifferentChild xmlns="http://www.adventure-works.com">other content</DifferentChild>  
  </Child>  
</Root>  
```  
  
 ]]></format>
        </remarks>
        <related type="Article" href="/dotnet/standard/linq/linq-xml-overview"><span data-ttu-id="b21d2-174">LINQ to XML 概述</span><span class="sxs-lookup"><span data-stu-id="b21d2-174">LINQ to XML overview</span></span></related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XElement (System.Xml.Linq.XName name, params object[] content);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Xml.Linq.XName name, object[] content) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XElement.#ctor(System.Xml.Linq.XName,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As XName, ParamArray content As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XElement(System::Xml::Linq::XName ^ name, ... cli::array &lt;System::Object ^&gt; ^ content);" />
      <MemberSignature Language="F#" Value="new System.Xml.Linq.XElement : System.Xml.Linq.XName * obj[] -&gt; System.Xml.Linq.XElement" Usage="new System.Xml.Linq.XElement (name, content)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="name" Type="System.Xml.Linq.XName" />
        <Parameter Name="content" Type="System.Object[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName Language="C#">[System.ParamArray]</AttributeName>
              <AttributeName Language="F#">[&lt;System.ParamArray&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="b21d2-175">一个包含元素名称的 <see cref="T:System.Xml.Linq.XName" />。</span><span class="sxs-lookup"><span data-stu-id="b21d2-175">An <see cref="T:System.Xml.Linq.XName" /> that contains the element name.</span></span></param>
        <param name="content"><span data-ttu-id="b21d2-176">元素的初始内容。</span><span class="sxs-lookup"><span data-stu-id="b21d2-176">The initial content of the element.</span></span></param>
        <summary><span data-ttu-id="b21d2-177">用指定的名称和内容初始化 <see cref="T:System.Xml.Linq.XElement" /> 类的新实例。</span><span class="sxs-lookup"><span data-stu-id="b21d2-177">Initializes a new instance of the <see cref="T:System.Xml.Linq.XElement" /> class with the specified name and content.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b21d2-178">此构造函数使用指定的内容和特性创建一个元素。</span><span class="sxs-lookup"><span data-stu-id="b21d2-178">This constructor creates an element with the specified content and attributes.</span></span>  
  
 <span data-ttu-id="b21d2-179">存在从字符串到的隐式转换 <xref:System.Xml.Linq.XName> 。</span><span class="sxs-lookup"><span data-stu-id="b21d2-179">There is an implicit conversion from string to <xref:System.Xml.Linq.XName>.</span></span> <span data-ttu-id="b21d2-180">此构造函数的典型用法是将字符串指定为参数，而不是创建新的 <xref:System.Xml.Linq.XName> 。</span><span class="sxs-lookup"><span data-stu-id="b21d2-180">Typical use of this constructor is to specify a string as the parameter instead of creating a new <xref:System.Xml.Linq.XName>.</span></span>  
  
 <span data-ttu-id="b21d2-181">在命名空间中创建元素时，典型用途是将加法运算符重载用于 <xref:System.Xml.Linq.XNamespace> ，并使用字符串创建 <xref:System.Xml.Linq.XName> 。</span><span class="sxs-lookup"><span data-stu-id="b21d2-181">When creating an element in a namespace, typical use is to use the addition operator overload with an <xref:System.Xml.Linq.XNamespace> and a string to create an <xref:System.Xml.Linq.XName>.</span></span> <span data-ttu-id="b21d2-182">有关详细信息，请参阅 [使用 XML 命名空间](/dotnet/standard/linq/namespaces-overview)。</span><span class="sxs-lookup"><span data-stu-id="b21d2-182">For more information, see [Work with XML Namespaces](/dotnet/standard/linq/namespaces-overview).</span></span>  
  
 <span data-ttu-id="b21d2-183">有关可传递到此构造函数的有效内容的详细信息，请参阅 [system.xml.linq.xelement> 和 XDocument 对象的有效内容](/dotnet/standard/linq/valid-content-xelement-xdocument-objects)。</span><span class="sxs-lookup"><span data-stu-id="b21d2-183">For details about the valid content that can be passed to this constructor, see [Valid Content of XElement and XDocument Objects](/dotnet/standard/linq/valid-content-xelement-xdocument-objects).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b21d2-184">下面的示例创建一个 XML 树。</span><span class="sxs-lookup"><span data-stu-id="b21d2-184">The following example creates an XML tree.</span></span> <span data-ttu-id="b21d2-185">新元素的内容来自 LINQ 查询。</span><span class="sxs-lookup"><span data-stu-id="b21d2-185">The content of the new element comes from a LINQ query.</span></span>  
  
```csharp  
XElement xmlTree1 = new XElement("Root",  
    new XElement("Child1", 1),  
    new XElement("Child2", 2),  
    new XElement("Child3", 3),  
    new XElement("Child4", 4),  
    new XElement("Child5", 5),  
    new XElement("Child6", 6)  
);  
  
XElement xmlTree2 = new XElement("Root",  
    from el in xmlTree1.Elements()  
    where((int)el >= 3 && (int)el <= 5)  
    select el  
);  
Console.WriteLine(xmlTree2);  
```  
  
```vb  
Dim xmlTree1 As XElement = _   
        <Root>  
            <Child1>1</Child1>  
            <Child2>2</Child2>  
            <Child3>3</Child3>  
            <Child4>4</Child4>  
            <Child5>5</Child5>  
            <Child6>6</Child6>  
        </Root>  
  
Dim xmlTree2 As XElement = _   
    <Root>  
        <%= From el In xmlTree1.Elements() _  
            Where el.Value >= 3 And el.Value <= 5 _  
            Select el %>  
    </Root>  
  
Console.WriteLine(xmlTree2)  
```  
  
 <span data-ttu-id="b21d2-186">该示例产生下面的输出：</span><span class="sxs-lookup"><span data-stu-id="b21d2-186">This example produces the following output:</span></span>  
  
```xml  
<Root>  
  <Child3>3</Child3>  
  <Child4>4</Child4>  
  <Child5>5</Child5>  
</Root>  
```  
  
 <span data-ttu-id="b21d2-187">下面的示例创建一个 XML 树，其中包含各种类型的内容。</span><span class="sxs-lookup"><span data-stu-id="b21d2-187">The following example creates an XML tree with a variety of types of content.</span></span>  
  
```csharp  
XElement root;  
  
// String content:  
root = new XElement("Root", "Some text");  
Console.WriteLine(root);  
  
// XElement object content:  
root = new XElement("Root",   
    new XElement("NewChild", "n")  
);  
Console.WriteLine(root);  
  
// XAttribute object content:  
root = new XElement("Root",   
    new XAttribute("NewAttribute", "n")  
);  
Console.WriteLine(root);  
  
// Double content:  
double dbl = 12.345;  
root = new XElement("Root", dbl);  
Console.WriteLine(root);  
  
// DateTime content:  
DateTime dt = new DateTime(2006, 10, 6, 12, 30, 00);  
root = new XElement("Root", dt);  
Console.WriteLine(root);  
  
// String array content:  
// Any collection other than a collection of XElement or XAttribute objects  
// are converted to strings. The strings are concatenated and added.  
string[] stringArray = {  
    "abc",  
    "def",  
    "ghi"  
};  
root = new XElement("Root", stringArray);  
Console.WriteLine(root);  
  
// XElement object array content:  
XElement[] ellArray = {  
    new XElement("NewChild1", 1),  
    new XElement("NewChild2", 2),  
    new XElement("NewChild3", 3)  
};  
root = new XElement("Root", ellArray);  
Console.WriteLine(root);  
  
// XAttribute object array content:  
XAttribute[] attArray = {  
    new XAttribute("NewAtt1", 1),  
    new XAttribute("NewAtt2", 2),  
    new XAttribute("NewAtt3", 3)  
};  
root = new XElement("Root", attArray);  
Console.WriteLine(root);  
```  
  
```vb  
Dim root As XElement  
  
' String content:  
root = <Root>Some text</Root>  
Console.WriteLine(root)  
  
' XElement object content:  
root = <Root>  
           <NewChild>n</NewChild>  
       </Root>  
Console.WriteLine(root)  
  
' XAttribute object content:  
root = <Root NewAttribute="n"/>  
Console.WriteLine(root)  
  
' Double content:  
Dim dbl As Double = 12.345  
root = <Root><%= dbl %></Root>  
Console.WriteLine(root)  
  
' DateTime content:  
Dim dt As DateTime = New DateTime(2006, 10, 6, 12, 30, 0)  
root = <Root><%= dt %></Root>  
Console.WriteLine(root)  
  
' String array content:  
' Any collection other than a collection of XElement or XAttribute objects  
' are converted to strings. The strings are concatenated and added.  
  
Dim stringArray As String() = { _  
    "abc", _  
    "def", _  
    "ghi" _  
}  
root = <Root><%= stringArray %></Root>  
Console.WriteLine(root)  
  
' XElement object array content:  
Dim ellArray As XElement() = { _  
    <NewChild1>1</NewChild1>, _  
    <NewChild2>2</NewChild2>, _  
    <NewChild3>3</NewChild3> _  
}  
  
root = <Root><%= ellArray %></Root>  
Console.WriteLine(root)  
  
' XAttribute object array content  
Dim attArray As XAttribute() = { _  
    New XAttribute("NewAtt1", 1), _  
    New XAttribute("NewAtt2", 2), _  
    New XAttribute("NewAtt3", 3) _  
}  
root = <Root><%= attArray %></Root>  
Console.WriteLine(root)  
```  
  
 <span data-ttu-id="b21d2-188">该示例产生下面的输出：</span><span class="sxs-lookup"><span data-stu-id="b21d2-188">This example produces the following output:</span></span>  
  
```xml
<Root>Some text</Root>  
<Root>  
  <NewChild>n</NewChild>  
</Root>  
<Root NewAttribute="n" />  
<Root>12.345</Root>  
<Root>2006-10-06T12:30:00</Root>  
<Root>abcdefghi</Root>  
<Root>  
  <NewChild1>1</NewChild1>  
  <NewChild2>2</NewChild2>  
  <NewChild3>3</NewChild3>  
</Root>  
<Root NewAtt1="1" NewAtt2="2" NewAtt3="3" />  
```  
  
 <span data-ttu-id="b21d2-189">下面的示例在命名空间中创建一个 XML 树。</span><span class="sxs-lookup"><span data-stu-id="b21d2-189">The following example creates an XML tree in a namespace.</span></span>  
  
```csharp  
// Create an XML tree in a namespace.  
XNamespace aw = "http://www.adventure-works.com";  
XElement root = new XElement(aw + "Root",  
    new XElement(aw + "Child", "child content")  
);  
Console.WriteLine(root);  
```  
  
```vb  
' Create an XML tree in a namespace.  
Dim root As XElement = _   
    <Root xmlns='http://www.adventure-works.com'>  
        <Child>child content</Child>  
    </Root>  
Console.WriteLine(root)  
```  
  
 <span data-ttu-id="b21d2-190">该示例产生下面的输出：</span><span class="sxs-lookup"><span data-stu-id="b21d2-190">This example produces the following output:</span></span>  
  
```xml  
<Root xmlns="http://www.adventure-works.com">  
  <Child>child content</Child>  
</Root>  
```  
  
 <span data-ttu-id="b21d2-191">下面的示例创建一个带有嵌套命名空间的 XML 树。</span><span class="sxs-lookup"><span data-stu-id="b21d2-191">The following example creates an XML tree with nested namespaces.</span></span>  
  
```csharp  
// Create an XML tree with nested namespaces.  
XNamespace aw = "http://www.adventure-works.com";  
XNamespace fc = "www.fourthcoffee.com";  
XElement root = new XElement(aw + "Root",  
    new XElement(fc + "Child",  
        new XElement(aw + "DifferentChild", "other content")  
    )  
);  
Console.WriteLine(root);  
```  
  
```vb  
' Create an XML tree with nested namespaces.  
Dim root As XDocument = _   
    <?xml version='1.0'?>  
    <Root xmlns='http://www.adventure-works.com'>  
        <Child xmlns='www.fourthcoffee.com'>  
        <DifferentChild xmlns='http://www.adventure-works.com'>other content</DifferentChild>  
        </Child>  
    </Root>  
Console.WriteLine(root)  
```  
  
 <span data-ttu-id="b21d2-192">该示例产生下面的输出：</span><span class="sxs-lookup"><span data-stu-id="b21d2-192">This example produces the following output:</span></span>  
  
```xml  
<Root xmlns="http://www.adventure-works.com">  
  <Child xmlns="www.fourthcoffee.com">  
    <DifferentChild xmlns="http://www.adventure-works.com">other content</DifferentChild>  
  </Child>  
</Root>  
```  
  
 ]]></format>
        </remarks>
        <related type="Article" href="/dotnet/standard/linq/linq-xml-overview"><span data-ttu-id="b21d2-193">LINQ to XML 概述</span><span class="sxs-lookup"><span data-stu-id="b21d2-193">LINQ to XML overview</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="AncestorsAndSelf">
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="b21d2-194">返回元素集合，其中包含此元素及其上级。</span><span class="sxs-lookup"><span data-stu-id="b21d2-194">Returns a collection of elements that contain this element, and the ancestors of this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b21d2-195">返回的集合中的元素的顺序与文档顺序相反。</span><span class="sxs-lookup"><span data-stu-id="b21d2-195">The elements in the returned collection are in reverse document order.</span></span>  
  
 <span data-ttu-id="b21d2-196">此方法使用延迟执行。</span><span class="sxs-lookup"><span data-stu-id="b21d2-196">This method uses deferred execution.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Xml.Linq.XNode.Ancestors" />
        <related type="Article" href="/dotnet/standard/linq/linq-xml-overview"><span data-ttu-id="b21d2-197">LINQ to XML 概述</span><span class="sxs-lookup"><span data-stu-id="b21d2-197">LINQ to XML overview</span></span></related>
      </Docs>
    </MemberGroup>
    <Member MemberName="AncestorsAndSelf">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.Xml.Linq.XElement&gt; AncestorsAndSelf ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;class System.Xml.Linq.XElement&gt; AncestorsAndSelf() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XElement.AncestorsAndSelf" />
      <MemberSignature Language="VB.NET" Value="Public Function AncestorsAndSelf () As IEnumerable(Of XElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IEnumerable&lt;System::Xml::Linq::XElement ^&gt; ^ AncestorsAndSelf();" />
      <MemberSignature Language="F#" Value="member this.AncestorsAndSelf : unit -&gt; seq&lt;System.Xml.Linq.XElement&gt;" Usage="xElement.AncestorsAndSelf " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Xml.Linq.XElement&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="b21d2-198">返回元素集合，其中包含此元素及其上级。</span><span class="sxs-lookup"><span data-stu-id="b21d2-198">Returns a collection of elements that contain this element, and the ancestors of this element.</span></span></summary>
        <returns><span data-ttu-id="b21d2-199">元素（其中包含此元素及其上级）的 <see cref="T:System.Collections.Generic.IEnumerable`1" /> 的 <see cref="T:System.Xml.Linq.XElement" />。</span><span class="sxs-lookup"><span data-stu-id="b21d2-199">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> of <see cref="T:System.Xml.Linq.XElement" /> of elements that contain this element, and the ancestors of this element.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b21d2-200">返回的集合中的元素的顺序与文档顺序相反。</span><span class="sxs-lookup"><span data-stu-id="b21d2-200">The elements in the returned collection are in reverse document order.</span></span>  
  
 <span data-ttu-id="b21d2-201">此方法使用延迟执行。</span><span class="sxs-lookup"><span data-stu-id="b21d2-201">This method uses deferred execution.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b21d2-202">下面的示例创建一个 XML 树。</span><span class="sxs-lookup"><span data-stu-id="b21d2-202">The following example creates an XML tree.</span></span> <span data-ttu-id="b21d2-203">然后，它查找该 `GrandChild` 元素，然后打印该元素的上级。</span><span class="sxs-lookup"><span data-stu-id="b21d2-203">It then finds the `GrandChild` element, and then prints the ancestors of it.</span></span>  
  
```csharp  
XElement xmlTree = new XElement("Root",  
    new XElement("Child",  
        new XElement("GrandChild", "element content")  
    )  
);  
XElement gc = xmlTree.Element("Child").Element("GrandChild");  
IEnumerable<XElement> aas =  
    from el in gc.AncestorsAndSelf()  
    select el;  
foreach (XElement el in aas)  
    Console.WriteLine(el.Name);  
```  
  
```vb  
Dim xmlTree As XElement = _   
    <Root>  
        <Child>  
            <GrandChild>element content</GrandChild>  
        </Child>  
    </Root>  
  
Dim GC As XElement = xmlTree.<Child>.<GrandChild>(0)  
  
Dim aas As IEnumerable(Of XElement) = _  
    From el In GC.AncestorsAndSelf() _  
    Select el  
  
For Each el In aas  
    Console.WriteLine(el.Name)  
Next  
```  
  
 <span data-ttu-id="b21d2-204">该示例产生下面的输出：</span><span class="sxs-lookup"><span data-stu-id="b21d2-204">This example produces the following output:</span></span>  
  
```  
GrandChild  
Child  
Root  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Xml.Linq.XNode.Ancestors" />
        <related type="Article" href="/dotnet/standard/linq/linq-xml-overview"><span data-ttu-id="b21d2-205">LINQ to XML 概述</span><span class="sxs-lookup"><span data-stu-id="b21d2-205">LINQ to XML overview</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="AncestorsAndSelf">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.Xml.Linq.XElement&gt; AncestorsAndSelf (System.Xml.Linq.XName name);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;class System.Xml.Linq.XElement&gt; AncestorsAndSelf(class System.Xml.Linq.XName name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XElement.AncestorsAndSelf(System.Xml.Linq.XName)" />
      <MemberSignature Language="VB.NET" Value="Public Function AncestorsAndSelf (name As XName) As IEnumerable(Of XElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IEnumerable&lt;System::Xml::Linq::XElement ^&gt; ^ AncestorsAndSelf(System::Xml::Linq::XName ^ name);" />
      <MemberSignature Language="F#" Value="member this.AncestorsAndSelf : System.Xml.Linq.XName -&gt; seq&lt;System.Xml.Linq.XElement&gt;" Usage="xElement.AncestorsAndSelf name" />
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.Xml.Linq.XElement&gt; AncestorsAndSelf (System.Xml.Linq.XName? name);" FrameworkAlternate="net-5.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Xml.Linq.XElement&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Xml.Linq.XName" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="b21d2-206">要匹配的 <see cref="T:System.Xml.Linq.XName" />。</span><span class="sxs-lookup"><span data-stu-id="b21d2-206">The <see cref="T:System.Xml.Linq.XName" /> to match.</span></span></param>
        <summary><span data-ttu-id="b21d2-207">返回经过筛选的元素集合，其中包含此元素及其上级。</span><span class="sxs-lookup"><span data-stu-id="b21d2-207">Returns a filtered collection of elements that contain this element, and the ancestors of this element.</span></span> <span data-ttu-id="b21d2-208">集合中仅包括具有匹配 <see cref="T:System.Xml.Linq.XName" /> 的元素。</span><span class="sxs-lookup"><span data-stu-id="b21d2-208">Only elements that have a matching <see cref="T:System.Xml.Linq.XName" /> are included in the collection.</span></span></summary>
        <returns><span data-ttu-id="b21d2-209"><see cref="T:System.Collections.Generic.IEnumerable`1" /> 的 <see cref="T:System.Xml.Linq.XElement" />，其中包含此元素及其上级。</span><span class="sxs-lookup"><span data-stu-id="b21d2-209">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> of <see cref="T:System.Xml.Linq.XElement" /> that contain this element, and the ancestors of this element.</span></span> <span data-ttu-id="b21d2-210">集合中仅包括具有匹配 <see cref="T:System.Xml.Linq.XName" /> 的元素。</span><span class="sxs-lookup"><span data-stu-id="b21d2-210">Only elements that have a matching <see cref="T:System.Xml.Linq.XName" /> are included in the collection.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b21d2-211">返回的集合中的元素的顺序与文档顺序相反。</span><span class="sxs-lookup"><span data-stu-id="b21d2-211">The elements in the returned collection are in reverse document order.</span></span>  
  
 <span data-ttu-id="b21d2-212">此方法使用延迟执行。</span><span class="sxs-lookup"><span data-stu-id="b21d2-212">This method uses deferred execution.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b21d2-213">下面的示例使用此。</span><span class="sxs-lookup"><span data-stu-id="b21d2-213">The following example uses this .</span></span>  
  
```csharp  
XElement xmlTree = new XElement("Root",  
    new XElement("Child",  
        new XElement("GrandChild", "element content")  
    )  
);  
XElement gc = xmlTree.Element("Child").Element("GrandChild");  
IEnumerable<XElement> aas = gc.AncestorsAndSelf("Child");  
foreach (XElement el in aas)  
    Console.WriteLine(el.Name);  
```  
  
```vb  
Dim xmlTree As XElement = _   
    <Root>  
        <Child>  
            <GrandChild>element content</GrandChild>  
        </Child>  
    </Root>  
  
Dim GC As XElement = xmlTree.<Child>.<GrandChild>(0)  
Dim aas As IEnumerable(Of XElement) = GC.AncestorsAndSelf("Child")  
For Each el In aas  
    Console.WriteLine(el.Name)  
Next  
```  
  
 <span data-ttu-id="b21d2-214">该示例产生下面的输出：</span><span class="sxs-lookup"><span data-stu-id="b21d2-214">This example produces the following output:</span></span>  
  
```  
Child  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Xml.Linq.XNode.Ancestors" />
        <related type="Article" href="/dotnet/standard/linq/linq-xml-overview"><span data-ttu-id="b21d2-215">LINQ to XML 概述</span><span class="sxs-lookup"><span data-stu-id="b21d2-215">LINQ to XML overview</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Attribute">
      <MemberSignature Language="C#" Value="public System.Xml.Linq.XAttribute Attribute (System.Xml.Linq.XName name);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Xml.Linq.XAttribute Attribute(class System.Xml.Linq.XName name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XElement.Attribute(System.Xml.Linq.XName)" />
      <MemberSignature Language="VB.NET" Value="Public Function Attribute (name As XName) As XAttribute" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Xml::Linq::XAttribute ^ Attribute(System::Xml::Linq::XName ^ name);" />
      <MemberSignature Language="F#" Value="member this.Attribute : System.Xml.Linq.XName -&gt; System.Xml.Linq.XAttribute" Usage="xElement.Attribute name" />
      <MemberSignature Language="C#" Value="public System.Xml.Linq.XAttribute? Attribute (System.Xml.Linq.XName name);" FrameworkAlternate="net-5.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Linq.XAttribute</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Xml.Linq.XName" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="b21d2-216">要获取的 <see cref="T:System.Xml.Linq.XName" /> 的 <see cref="T:System.Xml.Linq.XAttribute" />。</span><span class="sxs-lookup"><span data-stu-id="b21d2-216">The <see cref="T:System.Xml.Linq.XName" /> of the <see cref="T:System.Xml.Linq.XAttribute" /> to get.</span></span></param>
        <summary><span data-ttu-id="b21d2-217">返回具有指定 <see cref="T:System.Xml.Linq.XAttribute" /> 的此 <see cref="T:System.Xml.Linq.XElement" /> 的 <see cref="T:System.Xml.Linq.XName" />。</span><span class="sxs-lookup"><span data-stu-id="b21d2-217">Returns the <see cref="T:System.Xml.Linq.XAttribute" /> of this <see cref="T:System.Xml.Linq.XElement" /> that has the specified <see cref="T:System.Xml.Linq.XName" />.</span></span></summary>
        <returns><span data-ttu-id="b21d2-218">具有指定 <see cref="T:System.Xml.Linq.XAttribute" /> 的 <see cref="T:System.Xml.Linq.XName" />；如果没有具有指定名称的属性，则为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="b21d2-218">An <see cref="T:System.Xml.Linq.XAttribute" /> that has the specified <see cref="T:System.Xml.Linq.XName" />; <see langword="null" /> if there is no attribute with the specified name.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b21d2-219">某些 [轴方法](/dotnet/standard/linq/linq-xml-axes-overview) 返回元素或属性的集合。</span><span class="sxs-lookup"><span data-stu-id="b21d2-219">Some [axis methods](/dotnet/standard/linq/linq-xml-axes-overview) return collections of elements or attributes.</span></span> <span data-ttu-id="b21d2-220">此方法只返回一个属性。</span><span class="sxs-lookup"><span data-stu-id="b21d2-220">This method returns only a single attribute.</span></span> <span data-ttu-id="b21d2-221">有时，这称为 *单一实例* (与 *集合*) 不同。</span><span class="sxs-lookup"><span data-stu-id="b21d2-221">Sometimes this is referred to as a *singleton* (in contrast to a *collection*).</span></span>  
  
 <span data-ttu-id="b21d2-222">Visual Basic 用户可以使用集成属性轴检索具有指定名称的属性的值。</span><span class="sxs-lookup"><span data-stu-id="b21d2-222">Visual Basic users can use the integrated attribute axis to retrieve the value of an attribute with a specified name.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b21d2-223">下面的示例创建一个具有特性的元素。</span><span class="sxs-lookup"><span data-stu-id="b21d2-223">The following example creates an element with an attribute.</span></span> <span data-ttu-id="b21d2-224">然后，它使用此方法检索特性。</span><span class="sxs-lookup"><span data-stu-id="b21d2-224">It then retrieves the attribute using this method.</span></span>  
  
```csharp  
XElement xmlTree = new XElement("Root",  
    new XAttribute("Att", "attribute content")  
);  
XAttribute att = xmlTree.Attribute("Att");  
Console.WriteLine(att);  
```  
  
```vb  
Dim xmlTree As XElement = <Root Att="attribute content"/>  
  
Dim att As XAttribute = xmlTree.Attribute("Att")  
Console.WriteLine(att)  
```  
  
 <span data-ttu-id="b21d2-225">该示例产生下面的输出：</span><span class="sxs-lookup"><span data-stu-id="b21d2-225">This example produces the following output:</span></span>  
  
```  
Att="attribute content"  
```  
  
 <span data-ttu-id="b21d2-226">下面是同一个示例，但在这种情况下，XML 位于命名空间中。</span><span class="sxs-lookup"><span data-stu-id="b21d2-226">The following is the same example, but in this case the XML is in a namespace.</span></span> <span data-ttu-id="b21d2-227">有关详细信息，请参阅 [使用 XML 命名空间](/dotnet/standard/linq/namespaces-overview)。</span><span class="sxs-lookup"><span data-stu-id="b21d2-227">For more information, see [Work with XML Namespaces](/dotnet/standard/linq/namespaces-overview).</span></span>  
  
```csharp  
XNamespace aw = "http://www.adventure-works.com";  
XElement xmlTree = new XElement(aw + "Root",  
    new XAttribute(XNamespace.Xmlns + "aw", "http://www.adventure-works.com"),  
    new XAttribute(aw + "Att", "attribute content")  
);  
XAttribute att = xmlTree.Attribute(aw + "Att");  
Console.WriteLine(att);  
```  
  
```vb  
Imports <xmlns:aw="http://www.adventure-works.com">  
  
Module Module1  
    Sub Main()  
        Dim xmlTree As XElement = <aw:Root aw:Att="attribute content"/>  
  
        Dim att As XAttribute = xmlTree.Attribute(GetXmlNamespace(aw) + "Att")  
        Console.WriteLine(att)  
    End Sub  
End Module  
```  
  
 <span data-ttu-id="b21d2-228">该示例产生下面的输出：</span><span class="sxs-lookup"><span data-stu-id="b21d2-228">This example produces the following output:</span></span>  
  
```  
aw:Att="attribute content"  
```  
  
 ]]></format>
        </remarks>
        <related type="Article" href="/dotnet/standard/linq/linq-xml-overview"><span data-ttu-id="b21d2-229">LINQ to XML 概述</span><span class="sxs-lookup"><span data-stu-id="b21d2-229">LINQ to XML overview</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Attributes">
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="b21d2-230">返回此元素的属性集合。</span><span class="sxs-lookup"><span data-stu-id="b21d2-230">Returns a collection of attributes of this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b21d2-231">此方法使用延迟执行。</span><span class="sxs-lookup"><span data-stu-id="b21d2-231">This method uses deferred execution.</span></span>  
  
 ]]></format>
        </remarks>
        <related type="Article" href="/dotnet/standard/linq/linq-xml-overview"><span data-ttu-id="b21d2-232">LINQ to XML 概述</span><span class="sxs-lookup"><span data-stu-id="b21d2-232">LINQ to XML overview</span></span></related>
      </Docs>
    </MemberGroup>
    <Member MemberName="Attributes">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.Xml.Linq.XAttribute&gt; Attributes ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;class System.Xml.Linq.XAttribute&gt; Attributes() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XElement.Attributes" />
      <MemberSignature Language="VB.NET" Value="Public Function Attributes () As IEnumerable(Of XAttribute)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IEnumerable&lt;System::Xml::Linq::XAttribute ^&gt; ^ Attributes();" />
      <MemberSignature Language="F#" Value="member this.Attributes : unit -&gt; seq&lt;System.Xml.Linq.XAttribute&gt;" Usage="xElement.Attributes " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Xml.Linq.XAttribute&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="b21d2-233">返回此元素的属性集合。</span><span class="sxs-lookup"><span data-stu-id="b21d2-233">Returns a collection of attributes of this element.</span></span></summary>
        <returns><span data-ttu-id="b21d2-234">此元素的属性的 <see cref="T:System.Collections.Generic.IEnumerable`1" /> 的 <see cref="T:System.Xml.Linq.XAttribute" />。</span><span class="sxs-lookup"><span data-stu-id="b21d2-234">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> of <see cref="T:System.Xml.Linq.XAttribute" /> of attributes of this element.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b21d2-235">返回的集合中的属性按照添加到元素中的顺序排列。</span><span class="sxs-lookup"><span data-stu-id="b21d2-235">The attributes in the returned collection are in the order that they were added to the element.</span></span> <span data-ttu-id="b21d2-236">如果 XML 树是从 XML 进行分析的，则这些属性将按文档顺序返回。</span><span class="sxs-lookup"><span data-stu-id="b21d2-236">If the XML tree was parsed from XML, the attributes are returned in document order.</span></span>  
  
 <span data-ttu-id="b21d2-237">此方法使用延迟执行。</span><span class="sxs-lookup"><span data-stu-id="b21d2-237">This method uses deferred execution.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b21d2-238">下面的示例创建一个具有两个属性的元素。</span><span class="sxs-lookup"><span data-stu-id="b21d2-238">The following example creates an element with two attributes.</span></span> <span data-ttu-id="b21d2-239">然后，它使用它来检索元素的所有属性。</span><span class="sxs-lookup"><span data-stu-id="b21d2-239">It then uses this  to retrieve all attributes of the element.</span></span>  
  
```csharp  
XElement xmlTree = new XElement("Root",  
    new XAttribute("Att1", "content1"),  
    new XAttribute("Att2", "content2")  
);  
IEnumerable<XAttribute> attList =  
    from at in xmlTree.Attributes()  
    select at;  
foreach (XAttribute att in attList)  
    Console.WriteLine(att);  
```  
  
```vb  
Dim xmlTree As XElement = <Root Att1="content1" Att2="content2"/>  
  
Dim attList As IEnumerable(Of XAttribute) = _  
From at In xmlTree.Attributes() _  
Select at  
  
For Each att In attList  
    Console.WriteLine(att)  
Next  
```  
  
 <span data-ttu-id="b21d2-240">该示例产生下面的输出：</span><span class="sxs-lookup"><span data-stu-id="b21d2-240">This example produces the following output:</span></span>  
  
```  
Att1="content1"  
Att2="content2"  
```  
  
 <span data-ttu-id="b21d2-241">下面是同一个示例，但在这种情况下，XML 位于命名空间中。</span><span class="sxs-lookup"><span data-stu-id="b21d2-241">The following is the same example, but in this case the XML is in a namespace.</span></span> <span data-ttu-id="b21d2-242">有关详细信息，请参阅 [使用 XML 命名空间](/dotnet/standard/linq/namespaces-overview)。</span><span class="sxs-lookup"><span data-stu-id="b21d2-242">For more information, see [Work with XML Namespaces](/dotnet/standard/linq/namespaces-overview).</span></span>  
  
```csharp  
XNamespace aw = "http://www.adventure-works.com";  
XElement xmlTree = new XElement(aw + "Root",  
    new XAttribute(aw + "Att1", "content1"),  
    new XAttribute(aw + "Att2", "content2"),  
    new XAttribute(XNamespace.Xmlns + "aw", "http://www.adventure-works.com")  
);  
IEnumerable<XAttribute> attList =  
    from at in xmlTree.Attributes()  
    select at;  
foreach (XAttribute att in attList)  
    Console.WriteLine(att);  
```  
  
```vb  
Imports <xmlns:aw="http://www.adventure-works.com">  
  
Module Module1  
    Sub Main()  
        Dim xmlTree As XElement = <aw:Root aw:Att1="content1" aw:Att2="content2"/>  
  
        Dim attList As IEnumerable(Of XAttribute) = _  
            From at In xmlTree.Attributes() _  
            Select at  
  
        For Each att In attList  
            Console.WriteLine(att)  
        Next  
    End Sub  
End Module  
```  
  
 <span data-ttu-id="b21d2-243">该示例产生下面的输出：</span><span class="sxs-lookup"><span data-stu-id="b21d2-243">This example produces the following output:</span></span>  
  
```  
aw:Att1="content1"  
aw:Att2="content2"  
xmlns:aw="http://www.adventure-works.com"  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Xml.Linq.XContainer.Elements" />
        <related type="Article" href="/dotnet/standard/linq/linq-xml-overview"><span data-ttu-id="b21d2-244">LINQ to XML 概述</span><span class="sxs-lookup"><span data-stu-id="b21d2-244">LINQ to XML overview</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Attributes">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.Xml.Linq.XAttribute&gt; Attributes (System.Xml.Linq.XName name);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;class System.Xml.Linq.XAttribute&gt; Attributes(class System.Xml.Linq.XName name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XElement.Attributes(System.Xml.Linq.XName)" />
      <MemberSignature Language="VB.NET" Value="Public Function Attributes (name As XName) As IEnumerable(Of XAttribute)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IEnumerable&lt;System::Xml::Linq::XAttribute ^&gt; ^ Attributes(System::Xml::Linq::XName ^ name);" />
      <MemberSignature Language="F#" Value="member this.Attributes : System.Xml.Linq.XName -&gt; seq&lt;System.Xml.Linq.XAttribute&gt;" Usage="xElement.Attributes name" />
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.Xml.Linq.XAttribute&gt; Attributes (System.Xml.Linq.XName? name);" FrameworkAlternate="net-5.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Xml.Linq.XAttribute&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Xml.Linq.XName" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="b21d2-245">要匹配的 <see cref="T:System.Xml.Linq.XName" />。</span><span class="sxs-lookup"><span data-stu-id="b21d2-245">The <see cref="T:System.Xml.Linq.XName" /> to match.</span></span></param>
        <summary><span data-ttu-id="b21d2-246">返回经过筛选的此元素的属性集合。</span><span class="sxs-lookup"><span data-stu-id="b21d2-246">Returns a filtered collection of attributes of this element.</span></span> <span data-ttu-id="b21d2-247">集合中仅包括具有匹配 <see cref="T:System.Xml.Linq.XName" /> 的属性。</span><span class="sxs-lookup"><span data-stu-id="b21d2-247">Only attributes that have a matching <see cref="T:System.Xml.Linq.XName" /> are included in the collection.</span></span></summary>
        <returns><span data-ttu-id="b21d2-248"><see cref="T:System.Collections.Generic.IEnumerable`1" /> 的 <see cref="T:System.Xml.Linq.XAttribute" />，其中包含此元素的属性。</span><span class="sxs-lookup"><span data-stu-id="b21d2-248">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> of <see cref="T:System.Xml.Linq.XAttribute" /> that contains the attributes of this element.</span></span> <span data-ttu-id="b21d2-249">集合中仅包括具有匹配 <see cref="T:System.Xml.Linq.XName" /> 的属性。</span><span class="sxs-lookup"><span data-stu-id="b21d2-249">Only attributes that have a matching <see cref="T:System.Xml.Linq.XName" /> are included in the collection.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b21d2-250">属性名称在元素中必须是唯一的。</span><span class="sxs-lookup"><span data-stu-id="b21d2-250">Attribute names must be unique within an element.</span></span> <span data-ttu-id="b21d2-251">因此，这可能会返回只包含一个属性的集合，或返回一个空集合。</span><span class="sxs-lookup"><span data-stu-id="b21d2-251">Therefore, this  can return either a collection that contains only one attribute, or it can return an empty collection.</span></span>  
  
 <span data-ttu-id="b21d2-252">此方法使用延迟执行。</span><span class="sxs-lookup"><span data-stu-id="b21d2-252">This method uses deferred execution.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b21d2-253">下面的示例使用此。</span><span class="sxs-lookup"><span data-stu-id="b21d2-253">The following example uses this .</span></span>  
  
```csharp  
XElement xmlTree = new XElement("Root",  
    new XAttribute("Att1", "content1"),  
    new XAttribute("Att2", "content2")  
);  
IEnumerable<XAttribute> attList = xmlTree.Attributes("Att1");  
foreach (XAttribute att in attList)  
    Console.WriteLine(att);  
```  
  
```vb  
Dim xmlTree As XElement = <Root Att1="content1" Att2="content2"/>  
  
Dim attList As IEnumerable(Of XAttribute) = xmlTree.Attributes("Att1")  
  
For Each att In attList  
    Console.WriteLine(att)  
Next  
```  
  
 <span data-ttu-id="b21d2-254">该示例产生下面的输出：</span><span class="sxs-lookup"><span data-stu-id="b21d2-254">This example produces the following output:</span></span>  
  
```  
Att1="content1"  
```  
  
 <span data-ttu-id="b21d2-255">下面是同一个示例，但在这种情况下，XML 位于命名空间中。</span><span class="sxs-lookup"><span data-stu-id="b21d2-255">The following is the same example, but in this case the XML is in a namespace.</span></span> <span data-ttu-id="b21d2-256">有关详细信息，请参阅 [使用 XML 命名空间](/dotnet/standard/linq/namespaces-overview)。</span><span class="sxs-lookup"><span data-stu-id="b21d2-256">For more information, see [Work with XML Namespaces](/dotnet/standard/linq/namespaces-overview).</span></span>  
  
```csharp  
XNamespace aw = "http://www.adventure-works.com";  
XElement xmlTree = new XElement(aw + "Root",  
    new XAttribute(XNamespace.Xmlns + "aw", "http://www.adventure-works.com"),  
    new XAttribute(aw + "Att1", "content1"),  
    new XAttribute(aw + "Att2", "content2")  
);  
IEnumerable<XAttribute> attList = xmlTree.Attributes(aw + "Att1");  
foreach (XAttribute att in attList)  
    Console.WriteLine(att);  
```  
  
```vb  
Imports <xmlns:aw="http://www.adventure-works.com">  
  
Module Module1  
    Sub Main()  
        Dim xmlTree As XElement = <aw:Root aw:Att1="content1" aw:Att2="content2"/>  
  
        Dim attList As IEnumerable(Of XAttribute) = xmlTree.Attributes(GetXmlNamespace(aw) + "Att1")  
  
        For Each att In attList  
            Console.WriteLine(att)  
        Next  
    End Sub  
End Module  
```  
  
 <span data-ttu-id="b21d2-257">该示例产生下面的输出：</span><span class="sxs-lookup"><span data-stu-id="b21d2-257">This example produces the following output:</span></span>  
  
```  
aw:Att1="content1"  
```  
  
 ]]></format>
        </remarks>
        <related type="Article" href="/dotnet/standard/linq/linq-xml-overview"><span data-ttu-id="b21d2-258">LINQ to XML 概述</span><span class="sxs-lookup"><span data-stu-id="b21d2-258">LINQ to XML overview</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="DescendantNodesAndSelf">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.Xml.Linq.XNode&gt; DescendantNodesAndSelf ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;class System.Xml.Linq.XNode&gt; DescendantNodesAndSelf() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XElement.DescendantNodesAndSelf" />
      <MemberSignature Language="VB.NET" Value="Public Function DescendantNodesAndSelf () As IEnumerable(Of XNode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IEnumerable&lt;System::Xml::Linq::XNode ^&gt; ^ DescendantNodesAndSelf();" />
      <MemberSignature Language="F#" Value="member this.DescendantNodesAndSelf : unit -&gt; seq&lt;System.Xml.Linq.XNode&gt;" Usage="xElement.DescendantNodesAndSelf " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Xml.Linq.XNode&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="b21d2-259">返回节点的集合，而这些节点包含此元素以及此元素的所有子代节点，并将它们按文档顺序排列。</span><span class="sxs-lookup"><span data-stu-id="b21d2-259">Returns a collection of nodes that contain this element, and all descendant nodes of this element, in document order.</span></span></summary>
        <returns><span data-ttu-id="b21d2-260">一个包含此元素以及此元素的所有子代节点（按文档顺序排列）的 <see cref="T:System.Collections.Generic.IEnumerable`1" /> 的 <see cref="T:System.Xml.Linq.XNode" />。</span><span class="sxs-lookup"><span data-stu-id="b21d2-260">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> of <see cref="T:System.Xml.Linq.XNode" /> that contain this element, and all descendant nodes of this element, in document order.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b21d2-261">此方法使用延迟执行。</span><span class="sxs-lookup"><span data-stu-id="b21d2-261">This method uses deferred execution.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b21d2-262">下面的示例创建一个 XML 树，然后使用此树。</span><span class="sxs-lookup"><span data-stu-id="b21d2-262">The following example creates an XML tree, and then uses this .</span></span>  
  
```csharp  
XElement xmlTree = new XElement("Root",  
    // Attributes are not nodes, so will not be returned by DescendantNodesAndSelf.  
    new XAttribute("Att1", "AttributeContent"),  
    new XElement("Child",  
        new XText("Some text"),  
        new XElement("GrandChild", "element content")  
    )  
);  
IEnumerable<XNode> dnas =  
    from node in xmlTree.DescendantNodesAndSelf()  
    select node;  
foreach (XNode node in dnas)  
{  
    if (node is XElement)  
        Console.WriteLine((node as XElement).Name);  
    else  
        Console.WriteLine(node);  
}  
```  
  
```vb  
Dim xmlTree As XElement = _  
    <Root Att1="AttributeContent">  
        <Child>Some text<GrandChild>element content</GrandChild>  
        </Child>  
    </Root>  
  
Dim dnas As IEnumerable(Of XNode) = _  
    From node In xmlTree.DescendantNodesAndSelf() _  
    Select node  
  
For Each node In dnas  
    If TypeOf node Is XElement Then  
        Console.WriteLine(DirectCast(node, XElement).Name)  
    Else  
        Console.WriteLine(node)  
    End If  
Next  
```  
  
 <span data-ttu-id="b21d2-263">该示例产生下面的输出：</span><span class="sxs-lookup"><span data-stu-id="b21d2-263">This example produces the following output:</span></span>  
  
```  
Root  
Child  
Some text  
GrandChild  
element content  
```  
  
 ]]></format>
        </remarks>
        <related type="Article" href="/dotnet/standard/linq/linq-xml-overview"><span data-ttu-id="b21d2-264">LINQ to XML 概述</span><span class="sxs-lookup"><span data-stu-id="b21d2-264">LINQ to XML overview</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="DescendantsAndSelf">
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="b21d2-265">返回元素的集合，而这些元素包含此元素以及此元素的所有子代元素，并按文档顺序排列它们。</span><span class="sxs-lookup"><span data-stu-id="b21d2-265">Returns a collection of elements that contain this element, and all descendant elements of this element, in document order.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b21d2-266">此方法使用延迟执行。</span><span class="sxs-lookup"><span data-stu-id="b21d2-266">This method uses deferred execution.</span></span>  
  
 ]]></format>
        </remarks>
        <related type="Article" href="/dotnet/standard/linq/linq-xml-overview"><span data-ttu-id="b21d2-267">LINQ to XML 概述</span><span class="sxs-lookup"><span data-stu-id="b21d2-267">LINQ to XML overview</span></span></related>
      </Docs>
    </MemberGroup>
    <Member MemberName="DescendantsAndSelf">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.Xml.Linq.XElement&gt; DescendantsAndSelf ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;class System.Xml.Linq.XElement&gt; DescendantsAndSelf() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XElement.DescendantsAndSelf" />
      <MemberSignature Language="VB.NET" Value="Public Function DescendantsAndSelf () As IEnumerable(Of XElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IEnumerable&lt;System::Xml::Linq::XElement ^&gt; ^ DescendantsAndSelf();" />
      <MemberSignature Language="F#" Value="member this.DescendantsAndSelf : unit -&gt; seq&lt;System.Xml.Linq.XElement&gt;" Usage="xElement.DescendantsAndSelf " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Xml.Linq.XElement&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="b21d2-268">返回元素的集合，而这些元素包含此元素以及此元素的所有子代元素，并按文档顺序排列它们。</span><span class="sxs-lookup"><span data-stu-id="b21d2-268">Returns a collection of elements that contain this element, and all descendant elements of this element, in document order.</span></span></summary>
        <returns><span data-ttu-id="b21d2-269">元素（其中包含此元素以及此元素的所有子代元素，并按文档顺序排列）的 <see cref="T:System.Collections.Generic.IEnumerable`1" /> 的 <see cref="T:System.Xml.Linq.XElement" />。</span><span class="sxs-lookup"><span data-stu-id="b21d2-269">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> of <see cref="T:System.Xml.Linq.XElement" /> of elements that contain this element, and all descendant elements of this element, in document order.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b21d2-270">此方法使用延迟执行。</span><span class="sxs-lookup"><span data-stu-id="b21d2-270">This method uses deferred execution.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b21d2-271">下面的示例创建一个 XML 树，然后使用此树。</span><span class="sxs-lookup"><span data-stu-id="b21d2-271">The following example creates an XML tree, and then uses this .</span></span>  
  
```csharp  
XElement xmlTree = new XElement("Root",  
    new XAttribute("Att1", "AttributeContent"),  
    new XElement("Child",  
        new XText("Some text"),  
        new XElement("GrandChild", "element content")  
    )  
);  
IEnumerable<XElement> das =  
    from el in xmlTree.DescendantsAndSelf()  
    select el;  
foreach (XElement el in das)  
    Console.WriteLine(el.Name);  
```  
  
```vb  
Dim xmlTree As XElement = _  
    <Root Att1="AttributeContent">  
        <Child>Some text  
            <GrandChild>element content</GrandChild>  
        </Child>  
    </Root>  
  
Dim das As IEnumerable(Of XElement) = _  
    From el In xmlTree.DescendantsAndSelf() _  
    Select el  
  
For Each el In das  
    Console.WriteLine(el.Name)  
Next  
```  
  
 <span data-ttu-id="b21d2-272">该示例产生下面的输出：</span><span class="sxs-lookup"><span data-stu-id="b21d2-272">This example produces the following output:</span></span>  
  
```  
Root  
Child  
GrandChild  
```  
  
 ]]></format>
        </remarks>
        <related type="Article" href="/dotnet/standard/linq/linq-xml-overview"><span data-ttu-id="b21d2-273">LINQ to XML 概述</span><span class="sxs-lookup"><span data-stu-id="b21d2-273">LINQ to XML overview</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="DescendantsAndSelf">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.Xml.Linq.XElement&gt; DescendantsAndSelf (System.Xml.Linq.XName name);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;class System.Xml.Linq.XElement&gt; DescendantsAndSelf(class System.Xml.Linq.XName name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XElement.DescendantsAndSelf(System.Xml.Linq.XName)" />
      <MemberSignature Language="VB.NET" Value="Public Function DescendantsAndSelf (name As XName) As IEnumerable(Of XElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IEnumerable&lt;System::Xml::Linq::XElement ^&gt; ^ DescendantsAndSelf(System::Xml::Linq::XName ^ name);" />
      <MemberSignature Language="F#" Value="member this.DescendantsAndSelf : System.Xml.Linq.XName -&gt; seq&lt;System.Xml.Linq.XElement&gt;" Usage="xElement.DescendantsAndSelf name" />
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.Xml.Linq.XElement&gt; DescendantsAndSelf (System.Xml.Linq.XName? name);" FrameworkAlternate="net-5.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Xml.Linq.XElement&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Xml.Linq.XName" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="b21d2-274">要匹配的 <see cref="T:System.Xml.Linq.XName" />。</span><span class="sxs-lookup"><span data-stu-id="b21d2-274">The <see cref="T:System.Xml.Linq.XName" /> to match.</span></span></param>
        <summary><span data-ttu-id="b21d2-275">返回经过筛选的元素集合，这些元素包含此元素以及此元素的所有子代元素，并按文档顺序排列它们。</span><span class="sxs-lookup"><span data-stu-id="b21d2-275">Returns a filtered collection of elements that contain this element, and all descendant elements of this element, in document order.</span></span> <span data-ttu-id="b21d2-276">集合中仅包括具有匹配 <see cref="T:System.Xml.Linq.XName" /> 的元素。</span><span class="sxs-lookup"><span data-stu-id="b21d2-276">Only elements that have a matching <see cref="T:System.Xml.Linq.XName" /> are included in the collection.</span></span></summary>
        <returns><span data-ttu-id="b21d2-277">元素（其中包含此元素以及此元素的所有子代元素，并按文档顺序排列）的 <see cref="T:System.Collections.Generic.IEnumerable`1" /> 的 <see cref="T:System.Xml.Linq.XElement" />。</span><span class="sxs-lookup"><span data-stu-id="b21d2-277">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> of <see cref="T:System.Xml.Linq.XElement" /> that contain this element, and all descendant elements of this element, in document order.</span></span> <span data-ttu-id="b21d2-278">集合中仅包括具有匹配 <see cref="T:System.Xml.Linq.XName" /> 的元素。</span><span class="sxs-lookup"><span data-stu-id="b21d2-278">Only elements that have a matching <see cref="T:System.Xml.Linq.XName" /> are included in the collection.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b21d2-279">此方法使用延迟执行。</span><span class="sxs-lookup"><span data-stu-id="b21d2-279">This method uses deferred execution.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b21d2-280">下面的示例创建一个 XML 树，然后使用此树。</span><span class="sxs-lookup"><span data-stu-id="b21d2-280">The following example creates an XML tree, and then uses this .</span></span>  
  
```csharp  
XElement xmlTree = new XElement("Root",  
    new XAttribute("Att1", "AttributeContent"),  
    new XElement("Child",  
        new XText("Some text"),  
        new XElement("GrandChild", "element content")  
    )  
);  
IEnumerable<XElement> das = xmlTree.DescendantsAndSelf("Child");  
foreach (XElement el in das)  
    Console.WriteLine(el.Name);  
```  
  
```vb  
Dim xmlTree As XElement = _  
    <Root Att1="AttributeContent">  
        <Child>Some text  
            <GrandChild>element content</GrandChild>  
        </Child>  
    </Root>  
  
Dim das As IEnumerable(Of XElement) = xmlTree.DescendantsAndSelf("Child")  
  
For Each el In das  
    Console.WriteLine(el.Name)  
Next  
```  
  
 <span data-ttu-id="b21d2-281">该示例产生下面的输出：</span><span class="sxs-lookup"><span data-stu-id="b21d2-281">This example produces the following output:</span></span>  
  
```  
Child  
```  
  
 ]]></format>
        </remarks>
        <related type="Article" href="/dotnet/standard/linq/linq-xml-overview"><span data-ttu-id="b21d2-282">LINQ to XML 概述</span><span class="sxs-lookup"><span data-stu-id="b21d2-282">LINQ to XML overview</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="EmptySequence">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;System.Xml.Linq.XElement&gt; EmptySequence { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Collections.Generic.IEnumerable`1&lt;class System.Xml.Linq.XElement&gt; EmptySequence" />
      <MemberSignature Language="DocId" Value="P:System.Xml.Linq.XElement.EmptySequence" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property EmptySequence As IEnumerable(Of XElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Collections::Generic::IEnumerable&lt;System::Xml::Linq::XElement ^&gt; ^ EmptySequence { System::Collections::Generic::IEnumerable&lt;System::Xml::Linq::XElement ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.EmptySequence : seq&lt;System.Xml.Linq.XElement&gt;" Usage="System.Xml.Linq.XElement.EmptySequence" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Xml.Linq.XElement&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="b21d2-283">获取空的元素集合。</span><span class="sxs-lookup"><span data-stu-id="b21d2-283">Gets an empty collection of elements.</span></span></summary>
        <value><span data-ttu-id="b21d2-284">一个包含空集合的 <see cref="T:System.Collections.Generic.IEnumerable`1" /> 的 <see cref="T:System.Xml.Linq.XElement" />。</span><span class="sxs-lookup"><span data-stu-id="b21d2-284">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> of <see cref="T:System.Xml.Linq.XElement" /> that contains an empty collection.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b21d2-285">此属性通常由类实现者在编写返回元素集合的方法时使用。</span><span class="sxs-lookup"><span data-stu-id="b21d2-285">This property is typically used by class implementers when writing a method that returns a collection of elements.</span></span> <span data-ttu-id="b21d2-286">如果该方法必须不返回任何元素，则它可以使用此属性来获取空的 <xref:System.Xml.Linq.XElement> 对象集合。</span><span class="sxs-lookup"><span data-stu-id="b21d2-286">If the method must return no elements, it can use this property to get an empty collection of <xref:System.Xml.Linq.XElement> objects.</span></span>  
  
 ]]></format>
        </remarks>
        <related type="Article" href="/dotnet/standard/linq/linq-xml-overview"><span data-ttu-id="b21d2-287">LINQ to XML 概述</span><span class="sxs-lookup"><span data-stu-id="b21d2-287">LINQ to XML overview</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="FirstAttribute">
      <MemberSignature Language="C#" Value="public System.Xml.Linq.XAttribute FirstAttribute { get; }" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xml.Linq.XAttribute FirstAttribute" />
      <MemberSignature Language="DocId" Value="P:System.Xml.Linq.XElement.FirstAttribute" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property FirstAttribute As XAttribute" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xml::Linq::XAttribute ^ FirstAttribute { System::Xml::Linq::XAttribute ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.FirstAttribute : System.Xml.Linq.XAttribute" Usage="System.Xml.Linq.XElement.FirstAttribute" />
      <MemberSignature Language="C#" Value="public System.Xml.Linq.XAttribute? FirstAttribute { get; }" FrameworkAlternate="net-5.0" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Linq.XAttribute</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="b21d2-288">获取此元素的第一个属性。</span><span class="sxs-lookup"><span data-stu-id="b21d2-288">Gets the first attribute of this element.</span></span></summary>
        <value><span data-ttu-id="b21d2-289">一个包含此元素第一个属性的 <see cref="T:System.Xml.Linq.XAttribute" />。</span><span class="sxs-lookup"><span data-stu-id="b21d2-289">An <see cref="T:System.Xml.Linq.XAttribute" /> that contains the first attribute of this element.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b21d2-290">特性按其添加到元素中的顺序存储在元素中。</span><span class="sxs-lookup"><span data-stu-id="b21d2-290">Attributes are stored in the element in the order that they were added to the element.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b21d2-291">下面的示例使用此属性。</span><span class="sxs-lookup"><span data-stu-id="b21d2-291">The following example uses this property.</span></span>  
  
```csharp  
XElement xmlTree = new XElement("Root",  
    new XAttribute("Att1", 1),  
    new XAttribute("Att2", 2),  
    new XAttribute("Att3", 3)  
);  
Console.WriteLine(xmlTree.FirstAttribute);  
```  
  
```vb  
Dim xmlTree As XElement = <Root Att1="1" Att2="2" Att3="3"/>  
Console.WriteLine(xmlTree.FirstAttribute)  
```  
  
 <span data-ttu-id="b21d2-292">该示例产生下面的输出：</span><span class="sxs-lookup"><span data-stu-id="b21d2-292">This example produces the following output:</span></span>  
  
```  
Att1="1"  
```  
  
 ]]></format>
        </remarks>
        <related type="Article" href="/dotnet/standard/linq/linq-xml-overview"><span data-ttu-id="b21d2-293">LINQ to XML 概述</span><span class="sxs-lookup"><span data-stu-id="b21d2-293">LINQ to XML overview</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetDefaultNamespace">
      <MemberSignature Language="C#" Value="public System.Xml.Linq.XNamespace GetDefaultNamespace ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Xml.Linq.XNamespace GetDefaultNamespace() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XElement.GetDefaultNamespace" />
      <MemberSignature Language="VB.NET" Value="Public Function GetDefaultNamespace () As XNamespace" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Xml::Linq::XNamespace ^ GetDefaultNamespace();" />
      <MemberSignature Language="F#" Value="member this.GetDefaultNamespace : unit -&gt; System.Xml.Linq.XNamespace" Usage="xElement.GetDefaultNamespace " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Linq.XNamespace</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="b21d2-294">获取此 <see cref="T:System.Xml.Linq.XNamespace" /> 的默认 <see cref="T:System.Xml.Linq.XElement" />。</span><span class="sxs-lookup"><span data-stu-id="b21d2-294">Gets the default <see cref="T:System.Xml.Linq.XNamespace" /> of this <see cref="T:System.Xml.Linq.XElement" />.</span></span></summary>
        <returns><span data-ttu-id="b21d2-295">一个 <see cref="T:System.Xml.Linq.XNamespace" />，其中包含此 <see cref="T:System.Xml.Linq.XElement" /> 的默认命名空间。</span><span class="sxs-lookup"><span data-stu-id="b21d2-295">An <see cref="T:System.Xml.Linq.XNamespace" /> that contains the default namespace of this <see cref="T:System.Xml.Linq.XElement" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b21d2-296">命名空间声明可以作为属性保留在 XML 树中。</span><span class="sxs-lookup"><span data-stu-id="b21d2-296">Namespace declarations may be persisted as attributes in the XML tree.</span></span> <span data-ttu-id="b21d2-297">这些特殊属性声明命名空间，包括默认命名空间。</span><span class="sxs-lookup"><span data-stu-id="b21d2-297">These special attributes declare namespaces, including default namespaces.</span></span> <span data-ttu-id="b21d2-298">此方法查找声明默认命名空间（如果有）的命名空间声明，并返回 <xref:System.Xml.Linq.XNamespace> 默认命名空间的。</span><span class="sxs-lookup"><span data-stu-id="b21d2-298">This method finds the namespace declaration that declares the default namespace, if there is one, and returns the <xref:System.Xml.Linq.XNamespace> for the default namespace.</span></span>  
  
 <span data-ttu-id="b21d2-299">如果没有声明默认命名空间的属性，则此方法返回 <xref:System.Xml.Linq.XNamespace.None%2A?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="b21d2-299">If there is no attribute that declares the default namespace, then this method returns <xref:System.Xml.Linq.XNamespace.None%2A?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="b21d2-300">使用 c # 创建 XML 树时，即使 XML 树将使用默认命名空间进行序列化，如果该命名空间未在 XML 树中保留为属性，则此方法不会将命名空间报告为默认命名空间。</span><span class="sxs-lookup"><span data-stu-id="b21d2-300">When creating XML trees using C#, even if an XML tree would be serialized with a default namespace, if the namespace is not persisted in the XML tree as an attribute, this method will not report the namespace as the default namespace.</span></span>  
  
 <span data-ttu-id="b21d2-301">当使用 Visual Basic 和 XML 文本创建 XML 树时，如果在默认命名空间中使用 Imports 语句创建 XML，则 Visual Basic 编译器将在树中创建命名空间属性，此方法将报告该命名空间。</span><span class="sxs-lookup"><span data-stu-id="b21d2-301">When creating XML trees using Visual Basic and XML literals, if you create the XML in a default namespace using the Imports statement, then a namespace attribute will be created in the tree by the Visual Basic compiler, and this method will report that namespace.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b21d2-302">下面的示例创建一个具有默认命名空间的 XML 树。</span><span class="sxs-lookup"><span data-stu-id="b21d2-302">The following example creates an XML tree that has a default namespace.</span></span> <span data-ttu-id="b21d2-303">然后，它使用此方法检索默认命名空间。</span><span class="sxs-lookup"><span data-stu-id="b21d2-303">It then uses this method to retrieve the default namespace.</span></span>  
  
```csharp  
String xml = "<root xmlns='http://www.adventure-works.com'/>";  
XElement e = XElement.Parse(xml);  
Console.WriteLine("Default namespace: {0}", e.GetDefaultNamespace());  
```  
  
```vb  
Imports <xmlns="http://www.adventure-works.com">  
  
Module Module1  
    Sub Main()  
        Dim e As XElement = <root/>  
        Console.WriteLine("Default namespace: {0}", e.GetDefaultNamespace())  
    End Sub  
End Module  
```  
  
 <span data-ttu-id="b21d2-304">该示例产生下面的输出：</span><span class="sxs-lookup"><span data-stu-id="b21d2-304">This example produces the following output:</span></span>  
  
```  
Default namespace: http://www.adventure-works.com  
```  
  
 ]]></format>
        </remarks>
        <related type="Article" href="/dotnet/standard/linq/linq-xml-overview"><span data-ttu-id="b21d2-305">LINQ to XML 概述</span><span class="sxs-lookup"><span data-stu-id="b21d2-305">LINQ to XML overview</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetNamespaceOfPrefix">
      <MemberSignature Language="C#" Value="public System.Xml.Linq.XNamespace GetNamespaceOfPrefix (string prefix);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Xml.Linq.XNamespace GetNamespaceOfPrefix(string prefix) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XElement.GetNamespaceOfPrefix(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetNamespaceOfPrefix (prefix As String) As XNamespace" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Xml::Linq::XNamespace ^ GetNamespaceOfPrefix(System::String ^ prefix);" />
      <MemberSignature Language="F#" Value="member this.GetNamespaceOfPrefix : string -&gt; System.Xml.Linq.XNamespace" Usage="xElement.GetNamespaceOfPrefix prefix" />
      <MemberSignature Language="C#" Value="public System.Xml.Linq.XNamespace? GetNamespaceOfPrefix (string prefix);" FrameworkAlternate="net-5.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Linq.XNamespace</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="prefix" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="prefix"><span data-ttu-id="b21d2-306">包含要查找的命名空间前缀的字符串。</span><span class="sxs-lookup"><span data-stu-id="b21d2-306">A string that contains the namespace prefix to look up.</span></span></param>
        <summary><span data-ttu-id="b21d2-307">获取此 <see cref="T:System.Xml.Linq.XElement" /> 的与特定前缀关联的命名空间。</span><span class="sxs-lookup"><span data-stu-id="b21d2-307">Gets the namespace associated with a particular prefix for this <see cref="T:System.Xml.Linq.XElement" />.</span></span></summary>
        <returns><span data-ttu-id="b21d2-308">与此 <see cref="T:System.Xml.Linq.XNamespace" /> 的前缀关联的命名空间的 <see cref="T:System.Xml.Linq.XElement" />。</span><span class="sxs-lookup"><span data-stu-id="b21d2-308">An <see cref="T:System.Xml.Linq.XNamespace" /> for the namespace associated with the prefix for this <see cref="T:System.Xml.Linq.XElement" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b21d2-309">此方法通过 XML 树查找此元素范围内的命名空间属性。</span><span class="sxs-lookup"><span data-stu-id="b21d2-309">This method looks through the XML tree for namespace attributes that are in scope for this element.</span></span> <span data-ttu-id="b21d2-310">命名空间前缀在 XML 树中的命名空间属性中指定。</span><span class="sxs-lookup"><span data-stu-id="b21d2-310">Namespace prefixes are specified in namespace attributes that are in the XML tree.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b21d2-311">下面的示例创建一个 XML 树，该树具有具有关联前缀的命名空间。</span><span class="sxs-lookup"><span data-stu-id="b21d2-311">The following example creates an XML tree that has a namespace with an associated prefix.</span></span> <span data-ttu-id="b21d2-312">然后，它使用此方法检索 <xref:System.Xml.Linq.XNamespace> 前缀的。</span><span class="sxs-lookup"><span data-stu-id="b21d2-312">It then uses this method to retrieve the <xref:System.Xml.Linq.XNamespace> for the prefix.</span></span>  
  
```csharp  
XElement xmlTree = XElement.Parse("<Root xmlns:aw='http://www.adventure-works.com'/>");  
XNamespace awNamespace = xmlTree.GetNamespaceOfPrefix("aw");  
Console.WriteLine("Namespace: {0}", awNamespace);  
```  
  
 <span data-ttu-id="b21d2-313">使用 Visual Basic 时，通常使用 [GetXmlNamespace 运算符](/dotnet/visual-basic/language-reference/operators/getxmlnamespace-operator) 运算符，如下所示</span><span class="sxs-lookup"><span data-stu-id="b21d2-313">When using Visual Basic, you would typically use the [GetXmlNamespace Operator](/dotnet/visual-basic/language-reference/operators/getxmlnamespace-operator) operator, as follows</span></span>  
  
```vb  
Imports <xmlns:aw="http://www.adventure-works.com">  
  
Module Module1  
    Sub Main()  
        Dim xmlTree As XElement = <aw:Root/>  
        Dim awNamespace As XNamespace = GetXmlNamespace(aw)  
        Console.WriteLine("Namespace: {0}", awNamespace)  
    End Sub  
End Module  
```  
  
 <span data-ttu-id="b21d2-314">该示例产生下面的输出：</span><span class="sxs-lookup"><span data-stu-id="b21d2-314">This example produces the following output:</span></span>  
  
```  
Namespace: http://www.adventure-works.com  
```  
  
 ]]></format>
        </remarks>
        <related type="Article" href="/dotnet/standard/linq/linq-xml-overview"><span data-ttu-id="b21d2-315">LINQ to XML 概述</span><span class="sxs-lookup"><span data-stu-id="b21d2-315">LINQ to XML overview</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetPrefixOfNamespace">
      <MemberSignature Language="C#" Value="public string GetPrefixOfNamespace (System.Xml.Linq.XNamespace ns);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetPrefixOfNamespace(class System.Xml.Linq.XNamespace ns) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XElement.GetPrefixOfNamespace(System.Xml.Linq.XNamespace)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetPrefixOfNamespace (ns As XNamespace) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetPrefixOfNamespace(System::Xml::Linq::XNamespace ^ ns);" />
      <MemberSignature Language="F#" Value="member this.GetPrefixOfNamespace : System.Xml.Linq.XNamespace -&gt; string" Usage="xElement.GetPrefixOfNamespace ns" />
      <MemberSignature Language="C#" Value="public string? GetPrefixOfNamespace (System.Xml.Linq.XNamespace ns);" FrameworkAlternate="net-5.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ns" Type="System.Xml.Linq.XNamespace" />
      </Parameters>
      <Docs>
        <param name="ns"><span data-ttu-id="b21d2-316">要查找的 <see cref="T:System.Xml.Linq.XNamespace" />。</span><span class="sxs-lookup"><span data-stu-id="b21d2-316">An <see cref="T:System.Xml.Linq.XNamespace" /> to look up.</span></span></param>
        <summary><span data-ttu-id="b21d2-317">获取与此 <see cref="T:System.Xml.Linq.XElement" /> 的命名空间关联的前缀。</span><span class="sxs-lookup"><span data-stu-id="b21d2-317">Gets the prefix associated with a namespace for this <see cref="T:System.Xml.Linq.XElement" />.</span></span></summary>
        <returns><span data-ttu-id="b21d2-318">一个包含命名空间前缀的 <see cref="T:System.String" />。</span><span class="sxs-lookup"><span data-stu-id="b21d2-318">A <see cref="T:System.String" /> that contains the namespace prefix.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b21d2-319">此方法通过 XML 树查找此元素范围内的命名空间属性。</span><span class="sxs-lookup"><span data-stu-id="b21d2-319">This method looks through the XML tree for namespace attributes that are in scope for this element.</span></span> <span data-ttu-id="b21d2-320">命名空间前缀在 XML 树中的命名空间属性中指定。</span><span class="sxs-lookup"><span data-stu-id="b21d2-320">Namespace prefixes are specified in namespace attributes that are in the XML tree.</span></span>  
  
 <span data-ttu-id="b21d2-321">如果命名空间为默认命名空间，并且没有命名空间的前缀，则此方法返回 null。</span><span class="sxs-lookup"><span data-stu-id="b21d2-321">If the namespace is the default namespace, and there is no prefix for the namespace, then this method returns null.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b21d2-322">下面的示例创建一个包含带有前缀的命名空间的 XML 树。</span><span class="sxs-lookup"><span data-stu-id="b21d2-322">The following example creates an XML tree that contains a namespace with a prefix.</span></span> <span data-ttu-id="b21d2-323">然后，它使用此方法检索命名空间的前缀。</span><span class="sxs-lookup"><span data-stu-id="b21d2-323">It then uses this method to retrieve the prefix for the namespace.</span></span> <span data-ttu-id="b21d2-324">请注意， <xref:System.Xml.Linq.XNamespace> 在调用此方法时，此示例使用从字符串到的隐式转换。</span><span class="sxs-lookup"><span data-stu-id="b21d2-324">Notice that this example uses the implicit conversion from string to <xref:System.Xml.Linq.XNamespace> when calling this method.</span></span>  
  
```csharp  
XElement xmlTree = XElement.Parse("<Root xmlns:aw='http://www.adventure-works.com'/>");  
string prefix = xmlTree.GetPrefixOfNamespace("http://www.adventure-works.com");  
Console.WriteLine("Prefix: {0}", prefix);  
```  
  
```vb  
Imports <xmlns:aw="http://www.adventure-works.com">  
  
Module Module1  
    Sub Main()  
        Dim xmlTree As XElement = <aw:Root/>  
        Dim prefix As String = xmlTree.GetPrefixOfNamespace("http://www.adventure-works.com")  
        Console.WriteLine("Prefix: {0}", prefix)  
    End Sub  
End Module  
```  
  
 <span data-ttu-id="b21d2-325">该示例产生下面的输出：</span><span class="sxs-lookup"><span data-stu-id="b21d2-325">This example produces the following output:</span></span>  
  
```  
Prefix: aw  
```  
  
 ]]></format>
        </remarks>
        <related type="Article" href="/dotnet/standard/linq/linq-xml-overview"><span data-ttu-id="b21d2-326">LINQ to XML 概述</span><span class="sxs-lookup"><span data-stu-id="b21d2-326">LINQ to XML overview</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="HasAttributes">
      <MemberSignature Language="C#" Value="public bool HasAttributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasAttributes" />
      <MemberSignature Language="DocId" Value="P:System.Xml.Linq.XElement.HasAttributes" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HasAttributes As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HasAttributes { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HasAttributes : bool" Usage="System.Xml.Linq.XElement.HasAttributes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="b21d2-327">获取一个值，该值指示此元素是否至少具有一个属性。</span><span class="sxs-lookup"><span data-stu-id="b21d2-327">Gets a value indicating whether this element has at least one attribute.</span></span></summary>
        <value><span data-ttu-id="b21d2-328">如果此元素至少具有一个属性，则为 <see langword="true" />；否则为<see langword="false" /> 。</span><span class="sxs-lookup"><span data-stu-id="b21d2-328"><see langword="true" /> if this element has at least one attribute; otherwise <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="b21d2-329">下面的示例使用此属性。</span><span class="sxs-lookup"><span data-stu-id="b21d2-329">The following example uses this property.</span></span>  
  
```csharp  
XElement xmlTree1 = new XElement("Root",  
    new XAttribute("Att1", 1)  
);  
Console.WriteLine(xmlTree1.HasAttributes);  
XElement xmlTree2 = new XElement("Root");  
Console.WriteLine(xmlTree2.HasAttributes);  
```  
  
```vb  
Dim xmlTree1 As XElement = <Root Att1="1"/>  
Console.WriteLine(xmlTree1.HasAttributes)  
  
Dim xmlTree2 As XElement = <Root/>  
Console.WriteLine(xmlTree2.HasAttributes)  
```  
  
 <span data-ttu-id="b21d2-330">该示例产生下面的输出：</span><span class="sxs-lookup"><span data-stu-id="b21d2-330">This example produces the following output:</span></span>  
  
```  
True  
False  
```  
  
 ]]></format>
        </remarks>
        <related type="Article" href="/dotnet/standard/linq/linq-xml-overview"><span data-ttu-id="b21d2-331">LINQ to XML 概述</span><span class="sxs-lookup"><span data-stu-id="b21d2-331">LINQ to XML overview</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="HasElements">
      <MemberSignature Language="C#" Value="public bool HasElements { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasElements" />
      <MemberSignature Language="DocId" Value="P:System.Xml.Linq.XElement.HasElements" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HasElements As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HasElements { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HasElements : bool" Usage="System.Xml.Linq.XElement.HasElements" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="b21d2-332">获取一个值，该值指示此元素是否至少具有一个子元素。</span><span class="sxs-lookup"><span data-stu-id="b21d2-332">Gets a value indicating whether this element has at least one child element.</span></span></summary>
        <value><span data-ttu-id="b21d2-333">如果此元素至少具有一个子元素，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="b21d2-333"><see langword="true" /> if this element has at least one child element; otherwise <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="b21d2-334">下面的示例使用此属性。</span><span class="sxs-lookup"><span data-stu-id="b21d2-334">The following example uses this property.</span></span>  
  
```csharp  
XElement xmlTree1 = new XElement("Root",  
    new XElement("Child", 1)  
);  
Console.WriteLine(xmlTree1.HasElements);  
XElement xmlTree2 = new XElement("Root", "contents");  
Console.WriteLine(xmlTree2.HasElements);  
```  
  
```vb  
Dim xmlTree1 As XElement = _   
        <Root>  
            <Child>1</Child>  
        </Root>  
Console.WriteLine(xmlTree1.HasElements)  
  
Dim xmlTree2 As XElement = <Root>contents</Root>  
Console.WriteLine(xmlTree2.HasElements)  
```  
  
 <span data-ttu-id="b21d2-335">该示例产生下面的输出：</span><span class="sxs-lookup"><span data-stu-id="b21d2-335">This example produces the following output:</span></span>  
  
```  
True  
False  
```  
  
 ]]></format>
        </remarks>
        <related type="Article" href="/dotnet/standard/linq/linq-xml-overview"><span data-ttu-id="b21d2-336">LINQ to XML 概述</span><span class="sxs-lookup"><span data-stu-id="b21d2-336">LINQ to XML overview</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="IsEmpty">
      <MemberSignature Language="C#" Value="public bool IsEmpty { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsEmpty" />
      <MemberSignature Language="DocId" Value="P:System.Xml.Linq.XElement.IsEmpty" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsEmpty As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsEmpty { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsEmpty : bool" Usage="System.Xml.Linq.XElement.IsEmpty" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="b21d2-337">获取一个值，该值指示此元素是否不包含内容。</span><span class="sxs-lookup"><span data-stu-id="b21d2-337">Gets a value indicating whether this element contains no content.</span></span></summary>
        <value><span data-ttu-id="b21d2-338">如果元素不包含内容，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="b21d2-338"><see langword="true" /> if this element contains no content; otherwise <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b21d2-339">请注意，包含标记之间没有内容的开始标记和结束标记的元素不会被视为空元素。</span><span class="sxs-lookup"><span data-stu-id="b21d2-339">Note that an element that contains a start and end tag with no content between the tags is not considered to be an empty element.</span></span> <span data-ttu-id="b21d2-340">它包含没有长度的内容。</span><span class="sxs-lookup"><span data-stu-id="b21d2-340">It has content with no length.</span></span> <span data-ttu-id="b21d2-341">只有仅包含开始标记的元素表示为终止的空元素，才被视为空元素。</span><span class="sxs-lookup"><span data-stu-id="b21d2-341">Only an element that contains only a start tag, and is expressed as a terminated empty element, is considered to be empty.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b21d2-342">下面的示例创建了各种 XML 树，并显示了每个树的此属性的值。</span><span class="sxs-lookup"><span data-stu-id="b21d2-342">The following example creates a variety of XML trees, and shows the value of this property with each tree.</span></span>  
  
```csharp  
XElement el1 = new XElement("Root");  
Console.WriteLine(el1);  
Console.WriteLine(el1.IsEmpty);  
Console.WriteLine();  
XElement el2 = new XElement("Root", "content");  
Console.WriteLine(el2);  
Console.WriteLine(el2.IsEmpty);  
Console.WriteLine();  
XElement el3 = new XElement("Root", "");  
Console.WriteLine(el3);  
Console.WriteLine(el3.IsEmpty);  
Console.WriteLine();  
el3.ReplaceAll(null);  
Console.WriteLine(el3);  
Console.WriteLine(el3.IsEmpty);  
```  
  
```vb  
Dim el1 As XElement = <Root/>  
Console.WriteLine(el1)  
Console.WriteLine(el1.IsEmpty)  
Console.WriteLine()  
Dim el2 As XElement = <Root>content</Root>  
Console.WriteLine(el2)  
Console.WriteLine(el2.IsEmpty)  
Console.WriteLine()  
Dim el3 As XElement = <Root></Root>  
Console.WriteLine(el3)  
Console.WriteLine(el3.IsEmpty)  
Console.WriteLine()  
el3.ReplaceAll(Nothing)  
Console.WriteLine(el3)  
Console.WriteLine(el3.IsEmpty)  
```  
  
 <span data-ttu-id="b21d2-343">该示例产生下面的输出：</span><span class="sxs-lookup"><span data-stu-id="b21d2-343">This example produces the following output:</span></span>  
  
```  
<Root />  
True  
  
<Root>content</Root>  
False  
  
<Root></Root>  
False  
  
<Root />  
True  
```  
  
 ]]></format>
        </remarks>
        <related type="Article" href="/dotnet/standard/linq/linq-xml-overview"><span data-ttu-id="b21d2-344">LINQ to XML 概述</span><span class="sxs-lookup"><span data-stu-id="b21d2-344">LINQ to XML overview</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="LastAttribute">
      <MemberSignature Language="C#" Value="public System.Xml.Linq.XAttribute LastAttribute { get; }" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xml.Linq.XAttribute LastAttribute" />
      <MemberSignature Language="DocId" Value="P:System.Xml.Linq.XElement.LastAttribute" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LastAttribute As XAttribute" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xml::Linq::XAttribute ^ LastAttribute { System::Xml::Linq::XAttribute ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.LastAttribute : System.Xml.Linq.XAttribute" Usage="System.Xml.Linq.XElement.LastAttribute" />
      <MemberSignature Language="C#" Value="public System.Xml.Linq.XAttribute? LastAttribute { get; }" FrameworkAlternate="net-5.0" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Xml.Linq.XAttribute</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="b21d2-345">获取此元素的最后一个属性。</span><span class="sxs-lookup"><span data-stu-id="b21d2-345">Gets the last attribute of this element.</span></span></summary>
        <value><span data-ttu-id="b21d2-346">一个包含此元素最后一个属性的 <see cref="T:System.Xml.Linq.XAttribute" />。</span><span class="sxs-lookup"><span data-stu-id="b21d2-346">An <see cref="T:System.Xml.Linq.XAttribute" /> that contains the last attribute of this element.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b21d2-347">特性按其添加到元素中的顺序存储在元素中。</span><span class="sxs-lookup"><span data-stu-id="b21d2-347">Attributes are stored in the element in the order that they were added to the element.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b21d2-348">下面的示例创建一个具有三个属性的 XML 树。</span><span class="sxs-lookup"><span data-stu-id="b21d2-348">The following example creates an XML tree with three attributes.</span></span> <span data-ttu-id="b21d2-349">然后，它将最后一个属性写入输出。</span><span class="sxs-lookup"><span data-stu-id="b21d2-349">It then writes the last attribute as output.</span></span>  
  
```csharp  
XElement xmlTree = new XElement("Root",  
    new XAttribute("Att1", 1),  
    new XAttribute("Att2", 2),  
    new XAttribute("Att3", 3)  
);  
Console.WriteLine(xmlTree.LastAttribute);  
```  
  
```vb  
Dim xmlTree As XElement = <Root Att1="1" Att2="2" Att3="3"/>  
Console.WriteLine(xmlTree.LastAttribute)  
```  
  
 <span data-ttu-id="b21d2-350">该示例产生下面的输出：</span><span class="sxs-lookup"><span data-stu-id="b21d2-350">This example produces the following output:</span></span>  
  
```  
Att3="3"  
```  
  
 ]]></format>
        </remarks>
        <related type="Article" href="/dotnet/standard/linq/linq-xml-overview"><span data-ttu-id="b21d2-351">LINQ to XML 概述</span><span class="sxs-lookup"><span data-stu-id="b21d2-351">LINQ to XML overview</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Load">
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="b21d2-352">从 URI 所指定的文件、<see cref="T:System.Xml.Linq.XElement" /> 或 <see cref="T:System.IO.TextReader" /> 创建新 <see cref="T:System.Xml.XmlReader" />。</span><span class="sxs-lookup"><span data-stu-id="b21d2-352">Creates a new <see cref="T:System.Xml.Linq.XElement" /> from a file specified by a URI, from an <see cref="T:System.IO.TextReader" />, or from an <see cref="T:System.Xml.XmlReader" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b21d2-353">您可以使用此方法的重载之一 <xref:System.Xml.Linq.XElement> 从文件、 <xref:System.IO.TextReader> 或加载 <xref:System.Xml.XmlReader> 。</span><span class="sxs-lookup"><span data-stu-id="b21d2-353">You can use one of the overloads of this method to load an <xref:System.Xml.Linq.XElement> from a file, a <xref:System.IO.TextReader>, or an <xref:System.Xml.XmlReader>.</span></span>  
  
 <span data-ttu-id="b21d2-354">若要 <xref:System.Xml.Linq.XElement> 从包含 XML 的字符串创建，请使用 <xref:System.Xml.Linq.XElement.Parse%2A> 。</span><span class="sxs-lookup"><span data-stu-id="b21d2-354">To create an <xref:System.Xml.Linq.XElement> from a string that contains XML, use <xref:System.Xml.Linq.XElement.Parse%2A>.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Xml.Linq.XDocument.Load" />
        <altmember cref="Overload:System.Xml.Linq.XElement.Parse" />
        <related type="Article" href="/dotnet/standard/linq/linq-xml-overview"><span data-ttu-id="b21d2-355">LINQ to XML 概述</span><span class="sxs-lookup"><span data-stu-id="b21d2-355">LINQ to XML overview</span></span></related>
      </Docs>
    </MemberGroup>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static System.Xml.Linq.XElement Load (System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.Linq.XElement Load(class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XElement.Load(System.IO.Stream)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Load (stream As Stream) As XElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Xml::Linq::XElement ^ Load(System::IO::Stream ^ stream);" />
      <MemberSignature Language="F#" Value="static member Load : System.IO.Stream -&gt; System.Xml.Linq.XElement" Usage="System.Xml.Linq.XElement.Load stream" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Xml.Linq.XElement</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="stream"><span data-ttu-id="b21d2-356">包含 XML 数据的流。</span><span class="sxs-lookup"><span data-stu-id="b21d2-356">The stream that contains the XML data.</span></span></param>
        <summary><span data-ttu-id="b21d2-357">使用指定的流创建一个新的 <see cref="T:System.Xml.Linq.XElement" /> 实例。</span><span class="sxs-lookup"><span data-stu-id="b21d2-357">Creates a new <see cref="T:System.Xml.Linq.XElement" /> instance by using the specified stream.</span></span></summary>
        <returns><span data-ttu-id="b21d2-358">一个用于读取流中所包含数据的 <see cref="T:System.Xml.Linq.XElement" /> 对象。</span><span class="sxs-lookup"><span data-stu-id="b21d2-358">An <see cref="T:System.Xml.Linq.XElement" /> object used to read the data that is contained in the stream.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b21d2-359">如果要控制加载选项，请使用 <xref:System.Xml.Linq.XElement.Load%2A> 采用作为参数的重载 <xref:System.Xml.Linq.LoadOptions> 。</span><span class="sxs-lookup"><span data-stu-id="b21d2-359">If you want to control load options, use the <xref:System.Xml.Linq.XElement.Load%2A> overload that takes <xref:System.Xml.Linq.LoadOptions> as a parameter.</span></span>  
  
 <span data-ttu-id="b21d2-360">LINQ to XML 的加载功能是基于生成的 <xref:System.Xml.XmlReader> 。</span><span class="sxs-lookup"><span data-stu-id="b21d2-360">LINQ to XML's loading functionality is built upon <xref:System.Xml.XmlReader>.</span></span> <span data-ttu-id="b21d2-361">因此，你可能会捕获重载方法所引发的任何异常 <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> 和 <xref:System.Xml.XmlReader> 读取和分析文档的方法。</span><span class="sxs-lookup"><span data-stu-id="b21d2-361">Therefore, you might catch any exceptions that are thrown by the <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> overload methods and the <xref:System.Xml.XmlReader> methods that read and parse the document.</span></span>  
  
 <span data-ttu-id="b21d2-362">如果必须修改 <xref:System.Xml.XmlReaderSettings> ，请执行以下步骤：</span><span class="sxs-lookup"><span data-stu-id="b21d2-362">If you have to modify <xref:System.Xml.XmlReaderSettings>, following these steps:</span></span>  
  
1.  <span data-ttu-id="b21d2-363"><xref:System.Xml.XmlReader>通过调用 <xref:System.Xml.XmlReader.Create%2A> 采用作为参数的重载之一来创建 <xref:System.Xml.XmlReaderSettings> 。</span><span class="sxs-lookup"><span data-stu-id="b21d2-363">Create an <xref:System.Xml.XmlReader> by calling one of the <xref:System.Xml.XmlReader.Create%2A> overloads that take <xref:System.Xml.XmlReaderSettings> as a parameter.</span></span>  
  
2.  <span data-ttu-id="b21d2-364">将传递 <xref:System.Xml.XmlReader> 给 <xref:System.Xml.Linq.XElement> <xref:System.Xml.Linq.XElement.Load%2A> 作为参数的重载之一 <xref:System.Xml.XmlReader> 。</span><span class="sxs-lookup"><span data-stu-id="b21d2-364">Pass the <xref:System.Xml.XmlReader> to one of the <xref:System.Xml.Linq.XElement>'s <xref:System.Xml.Linq.XElement.Load%2A> overloads that takes <xref:System.Xml.XmlReader> as a parameter.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static System.Xml.Linq.XElement Load (System.IO.TextReader textReader);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.Linq.XElement Load(class System.IO.TextReader textReader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XElement.Load(System.IO.TextReader)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Load (textReader As TextReader) As XElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Xml::Linq::XElement ^ Load(System::IO::TextReader ^ textReader);" />
      <MemberSignature Language="F#" Value="static member Load : System.IO.TextReader -&gt; System.Xml.Linq.XElement" Usage="System.Xml.Linq.XElement.Load textReader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Xml.Linq.XElement</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="textReader" Type="System.IO.TextReader" />
      </Parameters>
      <Docs>
        <param name="textReader"><span data-ttu-id="b21d2-365">一个从其读取 <see cref="T:System.IO.TextReader" /> 内容的 <see cref="T:System.Xml.Linq.XElement" />。</span><span class="sxs-lookup"><span data-stu-id="b21d2-365">A <see cref="T:System.IO.TextReader" /> that will be read for the <see cref="T:System.Xml.Linq.XElement" /> content.</span></span></param>
        <summary><span data-ttu-id="b21d2-366">从 <see cref="T:System.Xml.Linq.XElement" /> 加载 <see cref="T:System.IO.TextReader" />。</span><span class="sxs-lookup"><span data-stu-id="b21d2-366">Loads an <see cref="T:System.Xml.Linq.XElement" /> from a <see cref="T:System.IO.TextReader" />.</span></span></summary>
        <returns><span data-ttu-id="b21d2-367">一个 <see cref="T:System.Xml.Linq.XElement" />，其中包含从指定的 <see cref="T:System.IO.TextReader" /> 读取的 XML。</span><span class="sxs-lookup"><span data-stu-id="b21d2-367">An <see cref="T:System.Xml.Linq.XElement" /> that contains the XML that was read from the specified <see cref="T:System.IO.TextReader" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b21d2-368">此方法将原始 XML 读入到 XML 树中。</span><span class="sxs-lookup"><span data-stu-id="b21d2-368">This method reads the raw XML into the XML tree.</span></span> <span data-ttu-id="b21d2-369">它将丢弃文件中所有无意义的空白。</span><span class="sxs-lookup"><span data-stu-id="b21d2-369">It discards all insignificant white space in the file.</span></span>  
  
 <span data-ttu-id="b21d2-370">LINQ to XML 的加载功能是基于生成的 <xref:System.Xml.XmlReader> 。</span><span class="sxs-lookup"><span data-stu-id="b21d2-370">LINQ to XML's loading functionality is built upon <xref:System.Xml.XmlReader>.</span></span> <span data-ttu-id="b21d2-371">因此，你可能会捕获重载方法所引发的任何异常 <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> 和 <xref:System.Xml.XmlReader> 读取和分析文档的方法。</span><span class="sxs-lookup"><span data-stu-id="b21d2-371">Therefore, you might catch any exceptions that are thrown by the <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> overload methods and the <xref:System.Xml.XmlReader> methods that read and parse the document.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b21d2-372">下面的示例从加载一个元素 <xref:System.IO.StringReader> 。</span><span class="sxs-lookup"><span data-stu-id="b21d2-372">The following example loads an element from a <xref:System.IO.StringReader>.</span></span>  
  
```csharp  
TextReader sr = new StringReader("<Root><Child/></Root>");  
XElement xmlTree = XElement.Load(sr);  
sr.Close();  
Console.WriteLine(xmlTree);  
```  
  
```vb  
Dim sr As TextReader = New StringReader("<Root><Child/></Root>")  
Dim xmlTree As XElement = XElement.Load(sr)  
sr.Close()  
Console.WriteLine(xmlTree)  
```  
  
 <span data-ttu-id="b21d2-373">该示例产生下面的输出：</span><span class="sxs-lookup"><span data-stu-id="b21d2-373">This example produces the following output:</span></span>  
  
```xml  
<Root>  
  <Child />  
</Root>  
```  
  
 ]]></format>
        </remarks>
        <related type="Article" href="/dotnet/standard/linq/linq-xml-overview"><span data-ttu-id="b21d2-374">LINQ to XML 概述</span><span class="sxs-lookup"><span data-stu-id="b21d2-374">LINQ to XML overview</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static System.Xml.Linq.XElement Load (string uri);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.Linq.XElement Load(string uri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XElement.Load(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Load (uri As String) As XElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Xml::Linq::XElement ^ Load(System::String ^ uri);" />
      <MemberSignature Language="F#" Value="static member Load : string -&gt; System.Xml.Linq.XElement" Usage="System.Xml.Linq.XElement.Load uri" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Xml.Linq.XElement</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uri" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="uri"><span data-ttu-id="b21d2-375">一个 URI 字符串，用来引用要加载到新 <see cref="T:System.Xml.Linq.XElement" /> 中的文件。</span><span class="sxs-lookup"><span data-stu-id="b21d2-375">A URI string referencing the file to load into a new <see cref="T:System.Xml.Linq.XElement" />.</span></span></param>
        <summary><span data-ttu-id="b21d2-376">从文件加载 <see cref="T:System.Xml.Linq.XElement" />。</span><span class="sxs-lookup"><span data-stu-id="b21d2-376">Loads an <see cref="T:System.Xml.Linq.XElement" /> from a file.</span></span></summary>
        <returns><span data-ttu-id="b21d2-377">一个包含指定文件的内容的 <see cref="T:System.Xml.Linq.XElement" />。</span><span class="sxs-lookup"><span data-stu-id="b21d2-377">An <see cref="T:System.Xml.Linq.XElement" /> that contains the contents of the specified file.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b21d2-378">此方法将原始 XML 读入到 XML 树中。</span><span class="sxs-lookup"><span data-stu-id="b21d2-378">This method reads the raw XML into the XML tree.</span></span> <span data-ttu-id="b21d2-379">它将丢弃文件中所有无意义的空白。</span><span class="sxs-lookup"><span data-stu-id="b21d2-379">It discards all insignificant white space in the file.</span></span>  
  
 <span data-ttu-id="b21d2-380">LINQ to XML 的加载功能是基于生成的 <xref:System.Xml.XmlReader> 。</span><span class="sxs-lookup"><span data-stu-id="b21d2-380">LINQ to XML's loading functionality is built upon <xref:System.Xml.XmlReader>.</span></span> <span data-ttu-id="b21d2-381">因此，你可能会捕获重载方法所引发的任何异常 <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> 和 <xref:System.Xml.XmlReader> 读取和分析文档的方法。</span><span class="sxs-lookup"><span data-stu-id="b21d2-381">Therefore, you might catch any exceptions that are thrown by the <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> overload methods and the <xref:System.Xml.XmlReader> methods that read and parse the document.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b21d2-382">下面的示例创建一个 XML 树，并将其保存到文件，然后使用此方法 <xref:System.Xml.Linq.XElement> 从文件中加载。</span><span class="sxs-lookup"><span data-stu-id="b21d2-382">The following example creates an XML tree, saves it to a file, and then uses this method to load the <xref:System.Xml.Linq.XElement> from the file.</span></span>  
  
```csharp  
XElement xmlTree1 = new XElement("Root",  
    new XElement("Child", "content")  
);  
xmlTree1.Save("Tree.xml");  
  
XElement xmlTree2 = XElement.Load("Tree.xml");  
Console.WriteLine(xmlTree2.Name);  
```  
  
```vb  
Dim xmlTree1 As XElement = _   
        <Root>  
            <Child>Content</Child>  
        </Root>  
xmlTree1.Save("Tree.xml")  
  
Dim xmlTree2 As XElement = XElement.Load("Tree.xml")  
Console.WriteLine(xmlTree2.Name)  
```  
  
 <span data-ttu-id="b21d2-383">该示例产生下面的输出：</span><span class="sxs-lookup"><span data-stu-id="b21d2-383">This example produces the following output:</span></span>  
  
```  
Root  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Xml.Linq.XDocument.Load" />
        <altmember cref="Overload:System.Xml.Linq.XElement.Parse" />
        <related type="Article" href="/dotnet/standard/linq/linq-xml-overview"><span data-ttu-id="b21d2-384">LINQ to XML 概述</span><span class="sxs-lookup"><span data-stu-id="b21d2-384">LINQ to XML overview</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static System.Xml.Linq.XElement Load (System.Xml.XmlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.Linq.XElement Load(class System.Xml.XmlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XElement.Load(System.Xml.XmlReader)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Load (reader As XmlReader) As XElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Xml::Linq::XElement ^ Load(System::Xml::XmlReader ^ reader);" />
      <MemberSignature Language="F#" Value="static member Load : System.Xml.XmlReader -&gt; System.Xml.Linq.XElement" Usage="System.Xml.Linq.XElement.Load reader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Xml.Linq.XElement</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="reader"><span data-ttu-id="b21d2-385">一个从其读取 <see cref="T:System.Xml.XmlReader" /> 内容的 <see cref="T:System.Xml.Linq.XElement" />。</span><span class="sxs-lookup"><span data-stu-id="b21d2-385">A <see cref="T:System.Xml.XmlReader" /> that will be read for the content of the <see cref="T:System.Xml.Linq.XElement" />.</span></span></param>
        <summary><span data-ttu-id="b21d2-386">从 <see cref="T:System.Xml.Linq.XElement" /> 加载 <see cref="T:System.Xml.XmlReader" />。</span><span class="sxs-lookup"><span data-stu-id="b21d2-386">Loads an <see cref="T:System.Xml.Linq.XElement" /> from an <see cref="T:System.Xml.XmlReader" />.</span></span></summary>
        <returns><span data-ttu-id="b21d2-387">一个 <see cref="T:System.Xml.Linq.XElement" />，其中包含从指定的 <see cref="T:System.Xml.XmlReader" /> 读取的 XML。</span><span class="sxs-lookup"><span data-stu-id="b21d2-387">An <see cref="T:System.Xml.Linq.XElement" /> that contains the XML that was read from the specified <see cref="T:System.Xml.XmlReader" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b21d2-388">通过 <xref:System.Xml.XmlNodeReader> 从 DOM 文档创建，然后使用 <xref:System.Xml.XmlNodeReader> 创建 <xref:System.Xml.Linq.XElement> ，此方法可用于在 LINQ to XML 树中创建 DOM 文档的副本。</span><span class="sxs-lookup"><span data-stu-id="b21d2-388">By creating an <xref:System.Xml.XmlNodeReader> from a DOM document, and then using the <xref:System.Xml.XmlNodeReader> to create an <xref:System.Xml.Linq.XElement>, this method can be used to create a copy of a DOM document in a LINQ to XML tree.</span></span>  
  
 <span data-ttu-id="b21d2-389">LINQ to XML 的加载功能是基于生成的 <xref:System.Xml.XmlReader> 。</span><span class="sxs-lookup"><span data-stu-id="b21d2-389">LINQ to XML's loading functionality is built upon <xref:System.Xml.XmlReader>.</span></span> <span data-ttu-id="b21d2-390">因此，你可能会捕获重载方法所引发的任何异常 <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> 和 <xref:System.Xml.XmlReader> 读取和分析文档的方法。</span><span class="sxs-lookup"><span data-stu-id="b21d2-390">Therefore, you might catch any exceptions that are thrown by the <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> overload methods and the <xref:System.Xml.XmlReader> methods that read and parse the document.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b21d2-391">下面的示例创建一个 DOM 文档， <xref:System.Xml.XmlNodeReader> 从 DOM 文档创建，然后从读取器实例化树。</span><span class="sxs-lookup"><span data-stu-id="b21d2-391">The following example creates a DOM document, creates an <xref:System.Xml.XmlNodeReader> from the DOM document, instantiates a tree from the reader.</span></span> <span data-ttu-id="b21d2-392">此代码将有效地将 DOM 文档复制到 LINQ to XML 树中。</span><span class="sxs-lookup"><span data-stu-id="b21d2-392">This code effectively copies a DOM document into a LINQ to XML tree.</span></span>  
  
```csharp  
// Create a DOM document with some content.  
XmlDocument doc = new XmlDocument();  
XmlElement child = doc.CreateElement("Child");  
child.InnerText = "child contents";  
XmlElement root = doc.CreateElement("Root");  
root.AppendChild(child);  
doc.AppendChild(root);  
  
// Create a reader and move to the content.  
using (XmlNodeReader nodeReader = new XmlNodeReader(doc)) {  
    // the reader must be in the Interactive state in order to  
    // Create a LINQ to XML tree from it.  
    nodeReader.MoveToContent();  
  
    XElement xRoot = XElement.Load(nodeReader);  
    Console.WriteLine(xRoot);  
}  
```  
  
```vb  
' Create a DOM document with some content.  
Dim doc As XmlDocument = New XmlDocument()  
Dim child As XmlElement = doc.CreateElement("Child")  
child.InnerText = "child contents"  
Dim root As XmlElement = doc.CreateElement("Root")  
root.AppendChild(child)  
doc.AppendChild(root)  
  
' Create a reader and move to the content.  
Using nodeReader = New XmlNodeReader(doc)  
    ' the reader must be in the Interactive state in order to  
    ' Create a LINQ to XML tree from it.  
    nodeReader.MoveToContent()  
  
    Dim xRoot As XElement = XElement.Load(nodeReader)  
    Console.WriteLine(xRoot)  
End Using  
```  
  
 <span data-ttu-id="b21d2-393">该示例产生下面的输出：</span><span class="sxs-lookup"><span data-stu-id="b21d2-393">This example produces the following output:</span></span>  
  
```xml  
<Root>  
  <Child>child contents</Child>  
</Root>  
```  
  
 ]]></format>
        </remarks>
        <related type="Article" href="/dotnet/standard/linq/linq-xml-overview"><span data-ttu-id="b21d2-394">LINQ to XML 概述</span><span class="sxs-lookup"><span data-stu-id="b21d2-394">LINQ to XML overview</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static System.Xml.Linq.XElement Load (System.IO.Stream stream, System.Xml.Linq.LoadOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.Linq.XElement Load(class System.IO.Stream stream, valuetype System.Xml.Linq.LoadOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XElement.Load(System.IO.Stream,System.Xml.Linq.LoadOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Load (stream As Stream, options As LoadOptions) As XElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Xml::Linq::XElement ^ Load(System::IO::Stream ^ stream, System::Xml::Linq::LoadOptions options);" />
      <MemberSignature Language="F#" Value="static member Load : System.IO.Stream * System.Xml.Linq.LoadOptions -&gt; System.Xml.Linq.XElement" Usage="System.Xml.Linq.XElement.Load (stream, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Linq.XElement</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="options" Type="System.Xml.Linq.LoadOptions" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="stream"><span data-ttu-id="b21d2-395">包含 XML 数据的流。</span><span class="sxs-lookup"><span data-stu-id="b21d2-395">The stream containing the XML data.</span></span></param>
        <param name="options"><span data-ttu-id="b21d2-396">一个 <see cref="T:System.Xml.Linq.LoadOptions" /> 对象，指定是否加载基 URI 和行信息。</span><span class="sxs-lookup"><span data-stu-id="b21d2-396">A <see cref="T:System.Xml.Linq.LoadOptions" /> object that specifies whether to load base URI and line information.</span></span></param>
        <summary><span data-ttu-id="b21d2-397">使用指定流创建新的 <see cref="T:System.Xml.Linq.XElement" /> 实例，也可以选择保留空白，设置基 URI 和保留行信息。</span><span class="sxs-lookup"><span data-stu-id="b21d2-397">Creates a new <see cref="T:System.Xml.Linq.XElement" /> instance by using the specified stream, optionally preserving white space, setting the base URI, and retaining line information.</span></span></summary>
        <returns><span data-ttu-id="b21d2-398">一个用于读取流中所包含数据的 <see cref="T:System.Xml.Linq.XElement" /> 对象。</span><span class="sxs-lookup"><span data-stu-id="b21d2-398">An <see cref="T:System.Xml.Linq.XElement" /> object used to read the data that the stream contains.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b21d2-399">LINQ to XML 的加载功能是基于生成的 <xref:System.Xml.XmlReader> 。</span><span class="sxs-lookup"><span data-stu-id="b21d2-399">LINQ to XML's loading functionality is built upon <xref:System.Xml.XmlReader>.</span></span> <span data-ttu-id="b21d2-400">因此，你可能会捕获重载方法所引发的任何异常 <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> 和 <xref:System.Xml.XmlReader> 读取和分析文档的方法。</span><span class="sxs-lookup"><span data-stu-id="b21d2-400">Therefore, you might catch any exceptions that are thrown by the <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> overload methods and the <xref:System.Xml.XmlReader> methods that read and parse the document.</span></span>  
  
 <span data-ttu-id="b21d2-401">如果必须修改 <xref:System.Xml.XmlReaderSettings> ，请执行以下步骤：</span><span class="sxs-lookup"><span data-stu-id="b21d2-401">If you have to modify <xref:System.Xml.XmlReaderSettings>, following these steps:</span></span>  
  
1.  <span data-ttu-id="b21d2-402"><xref:System.Xml.XmlReader>通过调用 <xref:System.Xml.XmlReader.Create%2A> 采用作为参数的重载之一来创建 <xref:System.Xml.XmlReaderSettings> 。</span><span class="sxs-lookup"><span data-stu-id="b21d2-402">Create an <xref:System.Xml.XmlReader> by calling one of the <xref:System.Xml.XmlReader.Create%2A> overloads that take <xref:System.Xml.XmlReaderSettings> as a parameter.</span></span>  
  
2.  <span data-ttu-id="b21d2-403">将传递 <xref:System.Xml.XmlReader> 给 <xref:System.Xml.Linq.XElement> <xref:System.Xml.Linq.XElement.Load%2A> 作为参数的重载之一 <xref:System.Xml.XmlReader> 。</span><span class="sxs-lookup"><span data-stu-id="b21d2-403">Pass the <xref:System.Xml.XmlReader> to one of the <xref:System.Xml.Linq.XElement>'s <xref:System.Xml.Linq.XElement.Load%2A> overloads that takes <xref:System.Xml.XmlReader> as a parameter.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static System.Xml.Linq.XElement Load (System.IO.TextReader textReader, System.Xml.Linq.LoadOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.Linq.XElement Load(class System.IO.TextReader textReader, valuetype System.Xml.Linq.LoadOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XElement.Load(System.IO.TextReader,System.Xml.Linq.LoadOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Load (textReader As TextReader, options As LoadOptions) As XElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Xml::Linq::XElement ^ Load(System::IO::TextReader ^ textReader, System::Xml::Linq::LoadOptions options);" />
      <MemberSignature Language="F#" Value="static member Load : System.IO.TextReader * System.Xml.Linq.LoadOptions -&gt; System.Xml.Linq.XElement" Usage="System.Xml.Linq.XElement.Load (textReader, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Linq.XElement</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="textReader" Type="System.IO.TextReader" />
        <Parameter Name="options" Type="System.Xml.Linq.LoadOptions" />
      </Parameters>
      <Docs>
        <param name="textReader"><span data-ttu-id="b21d2-404">一个从其读取 <see cref="T:System.IO.TextReader" /> 内容的 <see cref="T:System.Xml.Linq.XElement" />。</span><span class="sxs-lookup"><span data-stu-id="b21d2-404">A <see cref="T:System.IO.TextReader" /> that will be read for the <see cref="T:System.Xml.Linq.XElement" /> content.</span></span></param>
        <param name="options"><span data-ttu-id="b21d2-405">一个 <see cref="T:System.Xml.Linq.LoadOptions" />，指定空白行为以及是否加载基 URI 和行信息。</span><span class="sxs-lookup"><span data-stu-id="b21d2-405">A <see cref="T:System.Xml.Linq.LoadOptions" /> that specifies white space behavior, and whether to load base URI and line information.</span></span></param>
        <summary><span data-ttu-id="b21d2-406">从 <see cref="T:System.Xml.Linq.XElement" /> 加载 <see cref="T:System.IO.TextReader" />，还可以选择保留空白和行信息。</span><span class="sxs-lookup"><span data-stu-id="b21d2-406">Loads an <see cref="T:System.Xml.Linq.XElement" /> from a <see cref="T:System.IO.TextReader" />, optionally preserving white space and retaining line information.</span></span></summary>
        <returns><span data-ttu-id="b21d2-407">一个 <see cref="T:System.Xml.Linq.XElement" />，其中包含从指定的 <see cref="T:System.IO.TextReader" /> 读取的 XML。</span><span class="sxs-lookup"><span data-stu-id="b21d2-407">An <see cref="T:System.Xml.Linq.XElement" /> that contains the XML that was read from the specified <see cref="T:System.IO.TextReader" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b21d2-408">如果源 XML 已缩进，则 <xref:System.Xml.Linq.LoadOptions.PreserveWhitespace> 在中设置标志将 `options` 导致读取器读取源 xml 中的所有空格。</span><span class="sxs-lookup"><span data-stu-id="b21d2-408">If the source XML is indented, setting the <xref:System.Xml.Linq.LoadOptions.PreserveWhitespace> flag in `options` causes the reader to read all white space in the source XML.</span></span> <span data-ttu-id="b21d2-409"><xref:System.Xml.Linq.XText>为有效空白和无意义空白创建类型的节点。</span><span class="sxs-lookup"><span data-stu-id="b21d2-409">Nodes of type <xref:System.Xml.Linq.XText> are created for both significant and insignificant white space.</span></span>  
  
 <span data-ttu-id="b21d2-410">如果源 XML 已缩进，则未 <xref:System.Xml.Linq.LoadOptions.PreserveWhitespace> 在中设置标志将 `options` 导致读取器忽略源 xml 中所有无意义的空白。</span><span class="sxs-lookup"><span data-stu-id="b21d2-410">If the source XML is indented, not setting the <xref:System.Xml.Linq.LoadOptions.PreserveWhitespace> flag in `options` causes the reader to ignore all of the insignificant white space in the source XML.</span></span> <span data-ttu-id="b21d2-411">创建 XML 树时无需任何文本节点，无意义的空白。</span><span class="sxs-lookup"><span data-stu-id="b21d2-411">The XML tree is created without any text nodes for insignificant white space.</span></span>  
  
 <span data-ttu-id="b21d2-412">如果未缩进源 XML，则 <xref:System.Xml.Linq.LoadOptions.PreserveWhitespace> 在中设置标志 `options` 不起作用。</span><span class="sxs-lookup"><span data-stu-id="b21d2-412">If the source XML is not indented, setting the <xref:System.Xml.Linq.LoadOptions.PreserveWhitespace> flag in `options` has no effect.</span></span> <span data-ttu-id="b21d2-413">仍保留了有效空白，并且不存在任何可能导致创建更多空白文本节点的无意义空白区域。</span><span class="sxs-lookup"><span data-stu-id="b21d2-413">Significant white space is still preserved, and there are no spans of insignificant white space that could cause the creation of more white space text nodes.</span></span>  
  
 <span data-ttu-id="b21d2-414">有关详细信息，请参阅 [在加载或分析 XML 时保留空白](/dotnet/standard/linq/preserve-white-space-loading-parsing-xml) ，并 [在序列化时保留空白区域](/dotnet/standard/linq/preserve-white-space-serializing)。</span><span class="sxs-lookup"><span data-stu-id="b21d2-414">For more information, see [Preserve white space while loading or parsing XML](/dotnet/standard/linq/preserve-white-space-loading-parsing-xml) and [Preserve white space while serializing](/dotnet/standard/linq/preserve-white-space-serializing).</span></span>  
  
 <span data-ttu-id="b21d2-415">使用 <xref:System.Xml.Linq.XElement.Parse%2A> <xref:System.Xml.Linq.XElement> 从包含 XML 的字符串创建。</span><span class="sxs-lookup"><span data-stu-id="b21d2-415">Use <xref:System.Xml.Linq.XElement.Parse%2A> to create an <xref:System.Xml.Linq.XElement> from a string that contains XML.</span></span>  
  
 <span data-ttu-id="b21d2-416"><xref:System.Xml.Linq.LoadOptions.SetBaseUri>从加载时，设置将不起作用 <xref:System.IO.TextReader> 。</span><span class="sxs-lookup"><span data-stu-id="b21d2-416">Setting <xref:System.Xml.Linq.LoadOptions.SetBaseUri> will have no effect when loading from a <xref:System.IO.TextReader>.</span></span>  
  
 <span data-ttu-id="b21d2-417">如果设置了标志，则会对性能产生负面影响 <xref:System.Xml.Linq.LoadOptions.SetLineInfo> 。</span><span class="sxs-lookup"><span data-stu-id="b21d2-417">There is a performance penalty if you set the <xref:System.Xml.Linq.LoadOptions.SetLineInfo> flag.</span></span>  
  
 <span data-ttu-id="b21d2-418">行信息在加载 XML 文档后立即准确无误。</span><span class="sxs-lookup"><span data-stu-id="b21d2-418">The line information is accurate immediately after loading the XML document.</span></span> <span data-ttu-id="b21d2-419">如果在加载文档后修改 XML 树，行信息可能会变得毫无意义。</span><span class="sxs-lookup"><span data-stu-id="b21d2-419">If you modify the XML tree after loading the document, the line information may become meaningless.</span></span>  
  
 <span data-ttu-id="b21d2-420">LINQ to XML 的加载功能是基于生成的 <xref:System.Xml.XmlReader> 。</span><span class="sxs-lookup"><span data-stu-id="b21d2-420">LINQ to XML's loading functionality is built upon <xref:System.Xml.XmlReader>.</span></span> <span data-ttu-id="b21d2-421">因此，你可能会捕获重载方法所引发的任何异常 <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> 和 <xref:System.Xml.XmlReader> 读取和分析文档的方法。</span><span class="sxs-lookup"><span data-stu-id="b21d2-421">Therefore, you might catch any exceptions that are thrown by the <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> overload methods and the <xref:System.Xml.XmlReader> methods that read and parse the document.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b21d2-422">下面的示例 <xref:System.Xml.Linq.XElement> 通过 <xref:System.IO.StringReader> 两种不同的方式从中加载：保留空白，而不保留空格。</span><span class="sxs-lookup"><span data-stu-id="b21d2-422">The following example loads an <xref:System.Xml.Linq.XElement> from a <xref:System.IO.StringReader> in two different ways: preserving white space, and not preserving white space.</span></span> <span data-ttu-id="b21d2-423">然后，它使用查询来确定生成的 XML 树中的空白节点数。</span><span class="sxs-lookup"><span data-stu-id="b21d2-423">It then uses a query to determine the number of white space nodes in the resulting XML tree.</span></span>  
  
```csharp  
TextReader sr;  
int whiteSpaceNodes;  
  
sr = new StringReader("<Root> <Child> </Child> </Root>");  
XElement xmlTree1 = XElement.Load(sr, LoadOptions.None);  
sr.Close();  
whiteSpaceNodes = xmlTree1  
    .DescendantNodesAndSelf()  
    .OfType<XText>()  
    .Where(tNode => tNode.ToString().Trim().Length == 0)  
    .Count();  
Console.WriteLine("Count of white space nodes (not preserving whitespace): {0}", whiteSpaceNodes);  
  
sr = new StringReader("<Root> <Child> </Child> </Root>");  
XElement xmlTree2 = XElement.Load(sr, LoadOptions.PreserveWhitespace);  
sr.Close();  
whiteSpaceNodes = xmlTree2  
    .DescendantNodesAndSelf()  
    .OfType<XText>()  
    .Where(tNode => tNode.ToString().Trim().Length == 0)  
    .Count();  
Console.WriteLine("Count of white space nodes (preserving whitespace): {0}", whiteSpaceNodes);  
```  
  
```vb  
Dim sr As TextReader  
Dim whiteSpaceNodes As Integer  
  
sr = New StringReader("<Root> <Child> </Child> </Root>")  
Dim xmlTree1 As XElement = XElement.Load(sr, LoadOptions.None)  
sr.Close()  
whiteSpaceNodes = xmlTree1 _  
    .DescendantNodesAndSelf() _  
    .OfType(Of XText)() _  
    .Where(Function(ByVal tNode As XNode) tNode.ToString().Trim().Length = 0) _  
    .Count()  
Console.WriteLine("Count of white space nodes (not preserving whitespace): {0}", whiteSpaceNodes)  
  
sr = New StringReader("<Root> <Child> </Child> </Root>")  
Dim xmlTree2 As XElement = XElement.Load(sr, LoadOptions.PreserveWhitespace)  
sr.Close()  
whiteSpaceNodes = xmlTree2 _  
    .DescendantNodesAndSelf() _  
    .OfType(Of XText)() _  
    .Where(Function(ByVal tNode As XNode) tNode.ToString().Trim().Length = 0) _  
    .Count()  
Console.WriteLine("Count of white space nodes (preserving whitespace): {0}", whiteSpaceNodes)  
```  
  
 <span data-ttu-id="b21d2-424">该示例产生下面的输出：</span><span class="sxs-lookup"><span data-stu-id="b21d2-424">This example produces the following output:</span></span>  
  
```  
Count of white space nodes (not preserving whitespace): 0  
Count of white space nodes (preserving whitespace): 3  
```  
  
 <span data-ttu-id="b21d2-425">下面的示例加载从中加载的行信息 <xref:System.IO.TextReader> 。</span><span class="sxs-lookup"><span data-stu-id="b21d2-425">The following example loads the line information as it loads from the <xref:System.IO.TextReader>.</span></span> <span data-ttu-id="b21d2-426">然后打印行信息。</span><span class="sxs-lookup"><span data-stu-id="b21d2-426">It then prints the line information.</span></span>  
  
```csharp  
TextReader sr = new StringReader(  
@"<Root>  
  <Child>  
    <GrandChild1/>  
    <GrandChild2/>  
  </Child>  
</Root>");  
XElement po = XElement.Load(sr,  
    LoadOptions.SetLineInfo);  
Console.WriteLine("{0}{1}{2}",  
    "Element Name".PadRight(20),  
    "Line".PadRight(5),  
    "Position");  
Console.WriteLine("{0}{1}{2}",  
    "------------".PadRight(20),  
    "----".PadRight(5),  
    "--------");  
foreach (XElement e in po.DescendantsAndSelf())  
    Console.WriteLine("{0}{1}{2}",  
        ("".PadRight(e.Ancestors().Count() * 2) + e.Name).PadRight(20),  
        ((IXmlLineInfo)e).LineNumber.ToString().PadRight(5),  
        ((IXmlLineInfo)e).LinePosition);  
```  
  
```vb  
Dim sr As TextReader = New StringReader( _  
    "<Root>" & Environment.NewLine & _  
    "  <Child>" & Environment.NewLine & _  
    "    <GrandChild1/>" & Environment.NewLine & _  
    "    <GrandChild2/>" & Environment.NewLine & _  
    "  </Child>" & Environment.NewLine & _  
    "</Root>")  
Dim po As XElement = XElement.Load(sr, LoadOptions.SetLineInfo)  
Console.WriteLine("{0}{1}{2}", _  
    "Element Name".PadRight(20), _  
    "Line".PadRight(5), _  
    "Position")  
Console.WriteLine("{0}{1}{2}", _  
    "------------".PadRight(20), _  
    "----".PadRight(5), _  
    "--------")  
For Each e As XElement In po.DescendantsAndSelf()  
    Console.WriteLine("{0}{1}{2}", _  
        ("".PadRight(e.Ancestors().Count() * 2) & e.Name.ToString).PadRight(20), _  
        (DirectCast(e, IXmlLineInfo)).LineNumber.ToString().PadRight(5), _  
        (DirectCast(e, IXmlLineInfo)).LinePosition)  
Next  
```  
  
 <span data-ttu-id="b21d2-427">该示例产生下面的输出：</span><span class="sxs-lookup"><span data-stu-id="b21d2-427">This example produces the following output:</span></span>  
  
```  
Element Name        Line Position  
------------        ---- --------  
Root                1    2  
  Child             2    4  
    GrandChild1     3    6  
    GrandChild2     4    6  
```  
  
 ]]></format>
        </remarks>
        <related type="Article" href="/dotnet/standard/linq/linq-xml-overview"><span data-ttu-id="b21d2-428">LINQ to XML 概述</span><span class="sxs-lookup"><span data-stu-id="b21d2-428">LINQ to XML overview</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static System.Xml.Linq.XElement Load (string uri, System.Xml.Linq.LoadOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.Linq.XElement Load(string uri, valuetype System.Xml.Linq.LoadOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XElement.Load(System.String,System.Xml.Linq.LoadOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Load (uri As String, options As LoadOptions) As XElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Xml::Linq::XElement ^ Load(System::String ^ uri, System::Xml::Linq::LoadOptions options);" />
      <MemberSignature Language="F#" Value="static member Load : string * System.Xml.Linq.LoadOptions -&gt; System.Xml.Linq.XElement" Usage="System.Xml.Linq.XElement.Load (uri, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Linq.XElement</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uri" Type="System.String" />
        <Parameter Name="options" Type="System.Xml.Linq.LoadOptions" />
      </Parameters>
      <Docs>
        <param name="uri"><span data-ttu-id="b21d2-429">一个 URI 字符串，它引用要加载到 <see cref="T:System.Xml.Linq.XElement" /> 中的文件。</span><span class="sxs-lookup"><span data-stu-id="b21d2-429">A URI string referencing the file to load into an <see cref="T:System.Xml.Linq.XElement" />.</span></span></param>
        <param name="options"><span data-ttu-id="b21d2-430">一个 <see cref="T:System.Xml.Linq.LoadOptions" />，指定空白行为以及是否加载基 URI 和行信息。</span><span class="sxs-lookup"><span data-stu-id="b21d2-430">A <see cref="T:System.Xml.Linq.LoadOptions" /> that specifies white space behavior, and whether to load base URI and line information.</span></span></param>
        <summary><span data-ttu-id="b21d2-431">从文件加载 <see cref="T:System.Xml.Linq.XElement" />，还可以选择保留空白、设置基 URI 和保留行信息。</span><span class="sxs-lookup"><span data-stu-id="b21d2-431">Loads an <see cref="T:System.Xml.Linq.XElement" /> from a file, optionally preserving white space, setting the base URI, and retaining line information.</span></span></summary>
        <returns><span data-ttu-id="b21d2-432">一个包含指定文件的内容的 <see cref="T:System.Xml.Linq.XElement" />。</span><span class="sxs-lookup"><span data-stu-id="b21d2-432">An <see cref="T:System.Xml.Linq.XElement" /> that contains the contents of the specified file.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b21d2-433">如果源 XML 已缩进，则 <xref:System.Xml.Linq.LoadOptions.PreserveWhitespace> 在中设置标志将 `options` 导致读取器读取源 xml 中的所有空格。</span><span class="sxs-lookup"><span data-stu-id="b21d2-433">If the source XML is indented, setting the <xref:System.Xml.Linq.LoadOptions.PreserveWhitespace> flag in `options` causes the reader to read all white space in the source XML.</span></span> <span data-ttu-id="b21d2-434"><xref:System.Xml.Linq.XText>为有效空白和无意义空白创建类型的节点。</span><span class="sxs-lookup"><span data-stu-id="b21d2-434">Nodes of type <xref:System.Xml.Linq.XText> are created for both significant and insignificant white space.</span></span>  
  
 <span data-ttu-id="b21d2-435">如果源 XML 已缩进，则未 <xref:System.Xml.Linq.LoadOptions.PreserveWhitespace> 在中设置标志将 `options` 导致读取器忽略源 xml 中所有无意义的空白。</span><span class="sxs-lookup"><span data-stu-id="b21d2-435">If the source XML is indented, not setting the <xref:System.Xml.Linq.LoadOptions.PreserveWhitespace> flag in `options` causes the reader to ignore all of the insignificant white space in the source XML.</span></span> <span data-ttu-id="b21d2-436">创建 XML 树时无需任何文本节点，无意义的空白。</span><span class="sxs-lookup"><span data-stu-id="b21d2-436">The XML tree is created without any text nodes for insignificant white space.</span></span>  
  
 <span data-ttu-id="b21d2-437">如果未缩进源 XML，则 <xref:System.Xml.Linq.LoadOptions.PreserveWhitespace> 在中设置标志 `options` 不起作用。</span><span class="sxs-lookup"><span data-stu-id="b21d2-437">If the source XML is not indented, setting the <xref:System.Xml.Linq.LoadOptions.PreserveWhitespace> flag in `options` has no effect.</span></span> <span data-ttu-id="b21d2-438">仍保留了有效空白，并且不存在任何可能导致创建更多空白文本节点的无意义空白区域。</span><span class="sxs-lookup"><span data-stu-id="b21d2-438">Significant white space is still preserved, and there are no spans of insignificant white space that could cause the creation of more white space text nodes.</span></span>  
  
 <span data-ttu-id="b21d2-439">有关详细信息，请参阅 [在加载或分析 XML 时保留空白](/dotnet/standard/linq/preserve-white-space-loading-parsing-xml) ，并 [在序列化时保留空白区域](/dotnet/standard/linq/preserve-white-space-serializing)。</span><span class="sxs-lookup"><span data-stu-id="b21d2-439">For more information, see [Preserve white space while loading or parsing XML](/dotnet/standard/linq/preserve-white-space-loading-parsing-xml) and [Preserve white space while serializing](/dotnet/standard/linq/preserve-white-space-serializing).</span></span>  
  
 <span data-ttu-id="b21d2-440">使用 <xref:System.Xml.Linq.XElement.Parse%2A> <xref:System.Xml.Linq.XElement> 从包含 XML 的字符串创建。</span><span class="sxs-lookup"><span data-stu-id="b21d2-440">Use <xref:System.Xml.Linq.XElement.Parse%2A> to create an <xref:System.Xml.Linq.XElement> from a string that contains XML.</span></span>  
  
 <span data-ttu-id="b21d2-441">如果设置了和标志，则会降低性能 <xref:System.Xml.Linq.LoadOptions.SetBaseUri> <xref:System.Xml.Linq.LoadOptions.SetLineInfo> 。</span><span class="sxs-lookup"><span data-stu-id="b21d2-441">There is a performance penalty if you set the <xref:System.Xml.Linq.LoadOptions.SetBaseUri> and the <xref:System.Xml.Linq.LoadOptions.SetLineInfo> flags.</span></span>  
  
 <span data-ttu-id="b21d2-442">在加载 XML 文档后，基本 URI 和行信息立即准确无误。</span><span class="sxs-lookup"><span data-stu-id="b21d2-442">The base URI and the line information are accurate immediately after loading the XML document.</span></span> <span data-ttu-id="b21d2-443">如果在加载文档后修改 XML 树，则基本 URI 和行信息可能会变得毫无意义。</span><span class="sxs-lookup"><span data-stu-id="b21d2-443">If you modify the XML tree after loading the document, the base URI and line information may become meaningless.</span></span>  
  
 <span data-ttu-id="b21d2-444">LINQ to XML 的加载功能是基于生成的 <xref:System.Xml.XmlReader> 。</span><span class="sxs-lookup"><span data-stu-id="b21d2-444">LINQ to XML's loading functionality is built upon <xref:System.Xml.XmlReader>.</span></span> <span data-ttu-id="b21d2-445">因此，你可能会捕获重载方法所引发的任何异常 <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> 和 <xref:System.Xml.XmlReader> 读取和分析文档的方法。</span><span class="sxs-lookup"><span data-stu-id="b21d2-445">Therefore, you might catch any exceptions that are thrown by the <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> overload methods and the <xref:System.Xml.XmlReader> methods that read and parse the document.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b21d2-446">下面的示例 <xref:System.Xml.Linq.XElement> 通过两种不同的方式从文件中加载：保留空白，而不保留空格。</span><span class="sxs-lookup"><span data-stu-id="b21d2-446">The following example loads an <xref:System.Xml.Linq.XElement> from a file in two different ways: preserving white space, and not preserving white space.</span></span> <span data-ttu-id="b21d2-447">然后，它使用查询来确定生成的 XML 树中的空白节点数。</span><span class="sxs-lookup"><span data-stu-id="b21d2-447">It then uses a query to determine the number of white space nodes in the resulting XML tree.</span></span>  
  
```csharp  
XElement xmlTree1 = XElement.Parse("<Root> <Child>  </Child> </Root>", LoadOptions.PreserveWhitespace);  
xmlTree1.Save("Tree.xml");  
Console.WriteLine(xmlTree1);  
  
int whiteSpaceNodes;  
XElement xmlTree2 = XElement.Load("Tree.xml",  
    LoadOptions.None);  
whiteSpaceNodes = xmlTree2  
    .DescendantNodesAndSelf()  
    .OfType<XText>()  
    .Where(tNode => tNode.ToString().Trim().Length == 0)  
    .Count();  
Console.WriteLine("Count of white space nodes (not preserving whitespace): {0}", whiteSpaceNodes);  
  
XElement xmlTree3 = XElement.Load("Tree.xml",  
    LoadOptions.PreserveWhitespace);  
whiteSpaceNodes = xmlTree3  
    .DescendantNodesAndSelf()  
    .OfType<XText>()  
    .Where(tNode => tNode.ToString().Trim().Length == 0)  
    .Count();  
Console.WriteLine("Count of white space nodes (preserving whitespace): {0}", whiteSpaceNodes);  
```  
  
```vb  
Dim xmlTree1 As XElement = XElement.Parse("<Root> <Child>  </Child> </Root>", LoadOptions.PreserveWhitespace)  
xmlTree1.Save("Tree.xml")  
Console.WriteLine(xmlTree1)  
  
Dim whiteSpaceNodes As Integer  
Dim xmlTree2 As XElement = XElement.Load("Tree.xml", LoadOptions.None)  
whiteSpaceNodes = xmlTree2 _  
                  .DescendantNodesAndSelf() _  
                  .OfType(Of XText)() _  
                  .Where(Function(ByVal tNode As XNode) tNode.ToString().Trim().Length = 0) _  
                  .Count()  
Console.WriteLine("Count of white space nodes (not preserving whitespace): {0}", whiteSpaceNodes)  
  
Dim xmlTree3 As XElement = XElement.Load("Tree.xml", LoadOptions.PreserveWhitespace)  
whiteSpaceNodes = xmlTree3 _  
                  .DescendantNodesAndSelf() _  
                  .OfType(Of XText)() _  
                  .Where(Function(ByVal tNode As XNode) tNode.ToString().Trim().Length = 0) _  
                  .Count()  
Console.WriteLine("Count of white space nodes (preserving whitespace): {0}", whiteSpaceNodes)  
```  
  
 <span data-ttu-id="b21d2-448">该示例产生下面的输出：</span><span class="sxs-lookup"><span data-stu-id="b21d2-448">This example produces the following output:</span></span>  
  
```  
<Root> <Child>  </Child> </Root>  
Count of white space nodes (not preserving whitespace): 0  
Count of white space nodes (preserving whitespace): 3  
```  
  
 <span data-ttu-id="b21d2-449">下面的示例在加载文件时加载基 URI 和行信息。</span><span class="sxs-lookup"><span data-stu-id="b21d2-449">The following example loads the base URI and line information as it loads the file.</span></span> <span data-ttu-id="b21d2-450">然后打印基本 URI 和行信息。</span><span class="sxs-lookup"><span data-stu-id="b21d2-450">It then prints the base URI and the line information.</span></span>  
  
 <span data-ttu-id="b21d2-451">此示例使用以下资源文件： [示例 XML 文件：典型采购订单 (LINQ to XML) ](/dotnet/standard/linq/sample-xml-file-typical-purchase-order)。</span><span class="sxs-lookup"><span data-stu-id="b21d2-451">This example uses the following resource file: [Sample XML File: Typical Purchase Order (LINQ to XML)](/dotnet/standard/linq/sample-xml-file-typical-purchase-order).</span></span>  
  
```csharp  
XElement po = XElement.Load("PurchaseOrder.xml",  
    LoadOptions.SetBaseUri | LoadOptions.SetLineInfo);  
string[] splitUri = po.BaseUri.Split('/');  
Console.WriteLine("BaseUri: {0}", splitUri[splitUri.Length - 1]);  
Console.WriteLine();  
Console.WriteLine("{0}{1}{2}",  
    "Element Name".PadRight(20),  
    "Line".PadRight(5),  
    "Position");  
Console.WriteLine("{0}{1}{2}",  
    "------------".PadRight(20),  
    "----".PadRight(5),  
    "--------");  
foreach (XElement e in po.DescendantsAndSelf())  
    Console.WriteLine("{0}{1}{2}",  
        ("".PadRight(e.Ancestors().Count() * 2) + e.Name).PadRight(20),  
        ((IXmlLineInfo)e).LineNumber.ToString().PadRight(5),  
        ((IXmlLineInfo)e).LinePosition);  
```  
  
```vb  
Dim po As XElement = XElement.Load("PurchaseOrder.xml", LoadOptions.SetBaseUri Or LoadOptions.SetLineInfo)  
Dim splitUri() As String = po.BaseUri.Split("/")  
Console.WriteLine("BaseUri: {0}", splitUri(splitUri.Length - 1))  
Console.WriteLine()  
Console.WriteLine("{0}{1}{2}", _  
    "Element Name".PadRight(20), _  
    "Line".PadRight(5), _  
    "Position")  
Console.WriteLine("{0}{1}{2}", _  
    "------------".PadRight(20), _  
    "----".PadRight(5), _  
    "--------")  
For Each e As XElement In po.DescendantsAndSelf()  
    Console.WriteLine("{0}{1}{2}", _  
        ("".PadRight(e.Ancestors().Count() * 2) & e.Name.ToString()).PadRight(20), _  
        (DirectCast(e, IXmlLineInfo)).LineNumber.ToString().PadRight(5), _  
        (DirectCast(e, IXmlLineInfo)).LinePosition)  
Next  
```  
  
 <span data-ttu-id="b21d2-452">该示例产生下面的输出：</span><span class="sxs-lookup"><span data-stu-id="b21d2-452">This example produces the following output:</span></span>  
  
```  
BaseUri: PurchaseOrder.xml  
  
Element Name        Line Position  
------------        ---- --------  
PurchaseOrder       2    2  
  Address           3    4  
    Name            4    6  
    Street          5    6  
    City            6    6  
    State           7    6  
    Zip             8    6  
    Country         9    6  
  Address           11   4  
    Name            12   6  
    Street          13   6  
    City            14   6  
    State           15   6  
    Zip             16   6  
    Country         17   6  
  DeliveryNotes     19   4  
  Items             20   4  
    Item            21   6  
      ProductName   22   8  
      Quantity      23   8  
      USPrice       24   8  
      Comment       25   8  
    Item            27   6  
      ProductName   28   8  
      Quantity      29   8  
      USPrice       30   8  
      ShipDate      31   8  
```  
  
 ]]></format>
        </remarks>
        <related type="Article" href="/dotnet/standard/linq/linq-xml-overview"><span data-ttu-id="b21d2-453">LINQ to XML 概述</span><span class="sxs-lookup"><span data-stu-id="b21d2-453">LINQ to XML overview</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static System.Xml.Linq.XElement Load (System.Xml.XmlReader reader, System.Xml.Linq.LoadOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.Linq.XElement Load(class System.Xml.XmlReader reader, valuetype System.Xml.Linq.LoadOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XElement.Load(System.Xml.XmlReader,System.Xml.Linq.LoadOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Load (reader As XmlReader, options As LoadOptions) As XElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Xml::Linq::XElement ^ Load(System::Xml::XmlReader ^ reader, System::Xml::Linq::LoadOptions options);" />
      <MemberSignature Language="F#" Value="static member Load : System.Xml.XmlReader * System.Xml.Linq.LoadOptions -&gt; System.Xml.Linq.XElement" Usage="System.Xml.Linq.XElement.Load (reader, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Linq.XElement</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
        <Parameter Name="options" Type="System.Xml.Linq.LoadOptions" />
      </Parameters>
      <Docs>
        <param name="reader"><span data-ttu-id="b21d2-454">一个从其读取 <see cref="T:System.Xml.XmlReader" /> 内容的 <see cref="T:System.Xml.Linq.XElement" />。</span><span class="sxs-lookup"><span data-stu-id="b21d2-454">A <see cref="T:System.Xml.XmlReader" /> that will be read for the content of the <see cref="T:System.Xml.Linq.XElement" />.</span></span></param>
        <param name="options"><span data-ttu-id="b21d2-455">一个 <see cref="T:System.Xml.Linq.LoadOptions" />，指定空白行为以及是否加载基 URI 和行信息。</span><span class="sxs-lookup"><span data-stu-id="b21d2-455">A <see cref="T:System.Xml.Linq.LoadOptions" /> that specifies white space behavior, and whether to load base URI and line information.</span></span></param>
        <summary><span data-ttu-id="b21d2-456">从 <see cref="T:System.Xml.Linq.XElement" /> 加载 <see cref="T:System.Xml.XmlReader" /> 时，可以选择保留空白、设置基 URI 和保留行信息。</span><span class="sxs-lookup"><span data-stu-id="b21d2-456">Loads an <see cref="T:System.Xml.Linq.XElement" /> from an <see cref="T:System.Xml.XmlReader" />, optionally preserving white space, setting the base URI, and retaining line information.</span></span></summary>
        <returns><span data-ttu-id="b21d2-457">一个 <see cref="T:System.Xml.Linq.XElement" />，其中包含从指定的 <see cref="T:System.Xml.XmlReader" /> 读取的 XML。</span><span class="sxs-lookup"><span data-stu-id="b21d2-457">An <see cref="T:System.Xml.Linq.XElement" /> that contains the XML that was read from the specified <see cref="T:System.Xml.XmlReader" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b21d2-458">通过 <xref:System.Xml.XmlNodeReader> 从 DOM 文档创建，然后使用 <xref:System.Xml.XmlNodeReader> 创建 <xref:System.Xml.Linq.XElement> ，此方法可用于在 LINQ to XML 树中创建 DOM 文档的副本。</span><span class="sxs-lookup"><span data-stu-id="b21d2-458">By creating an <xref:System.Xml.XmlNodeReader> from a DOM document, and then using the <xref:System.Xml.XmlNodeReader> to create an <xref:System.Xml.Linq.XElement>, this method can be used to create a copy of a DOM document in a LINQ to XML tree.</span></span>  
  
 <span data-ttu-id="b21d2-459">使用 <xref:System.Xml.Linq.XElement.Parse%2A> <xref:System.Xml.Linq.XElement> 从包含 XML 的字符串创建。</span><span class="sxs-lookup"><span data-stu-id="b21d2-459">Use <xref:System.Xml.Linq.XElement.Parse%2A> to create an <xref:System.Xml.Linq.XElement> from a string that contains XML.</span></span>  
  
 <span data-ttu-id="b21d2-460"><xref:System.Xml.Linq.LoadOptions.PreserveWhitespace>从加载时，设置无效 <xref:System.Xml.XmlReader> 。</span><span class="sxs-lookup"><span data-stu-id="b21d2-460">Setting <xref:System.Xml.Linq.LoadOptions.PreserveWhitespace> is not valid when loading from a <xref:System.Xml.XmlReader>.</span></span> <span data-ttu-id="b21d2-461"><xref:System.Xml.XmlReader>将配置为读取空白。</span><span class="sxs-lookup"><span data-stu-id="b21d2-461">The <xref:System.Xml.XmlReader> will be configured to either read whitespace or not.</span></span> <span data-ttu-id="b21d2-462">LINQ to XML 树将用读取器所表示的空白节点填充。</span><span class="sxs-lookup"><span data-stu-id="b21d2-462">The LINQ to XML tree will be populated with the whitespace nodes that the reader surfaces.</span></span> <span data-ttu-id="b21d2-463">不管是否设置了，这将是行为 <xref:System.Xml.Linq.LoadOptions.PreserveWhitespace> 。</span><span class="sxs-lookup"><span data-stu-id="b21d2-463">This will be the behavior regardless of whether <xref:System.Xml.Linq.LoadOptions.PreserveWhitespace> is set or not.</span></span>  
  
 <span data-ttu-id="b21d2-464"><xref:System.Xml.XmlReader>可能具有有效的基 URI。</span><span class="sxs-lookup"><span data-stu-id="b21d2-464">The <xref:System.Xml.XmlReader> may have a valid base URI or not.</span></span> <span data-ttu-id="b21d2-465">如果设置 <xref:System.Xml.Linq.LoadOptions.SetBaseUri> 了，则将从报告的基本 uri 的 XML 树中设置基本 uri <xref:System.Xml.XmlReader> 。</span><span class="sxs-lookup"><span data-stu-id="b21d2-465">If you set <xref:System.Xml.Linq.LoadOptions.SetBaseUri>, the base URI will be set in the XML tree from the base URI that is reported by the <xref:System.Xml.XmlReader>.</span></span>  
  
 <span data-ttu-id="b21d2-466"><xref:System.Xml.XmlReader>可能有有效的行信息。</span><span class="sxs-lookup"><span data-stu-id="b21d2-466">The <xref:System.Xml.XmlReader> may have a valid line information or not.</span></span> <span data-ttu-id="b21d2-467">如果设置 <xref:System.Xml.Linq.LoadOptions.SetLineInfo> 了，则将从报告的行信息在 XML 树中设置行信息 <xref:System.Xml.XmlReader> 。</span><span class="sxs-lookup"><span data-stu-id="b21d2-467">If you set <xref:System.Xml.Linq.LoadOptions.SetLineInfo>, the line information will be set in the XML tree from the line information that is reported by the <xref:System.Xml.XmlReader>.</span></span>  
  
 <span data-ttu-id="b21d2-468">如果设置了标志，则会对性能产生负面影响 <xref:System.Xml.Linq.LoadOptions.SetLineInfo> 。</span><span class="sxs-lookup"><span data-stu-id="b21d2-468">There is a performance penalty if you set the <xref:System.Xml.Linq.LoadOptions.SetLineInfo> flag.</span></span>  
  
 <span data-ttu-id="b21d2-469">行信息在加载 XML 文档后立即准确无误。</span><span class="sxs-lookup"><span data-stu-id="b21d2-469">The line information is accurate immediately after loading the XML document.</span></span> <span data-ttu-id="b21d2-470">如果在加载文档后修改 XML 树，行信息可能会变得毫无意义。</span><span class="sxs-lookup"><span data-stu-id="b21d2-470">If you modify the XML tree after loading the document, the line information may become meaningless.</span></span>  
  
 <span data-ttu-id="b21d2-471">LINQ to XML 的加载功能是基于生成的 <xref:System.Xml.XmlReader> 。</span><span class="sxs-lookup"><span data-stu-id="b21d2-471">LINQ to XML's loading functionality is built upon <xref:System.Xml.XmlReader>.</span></span> <span data-ttu-id="b21d2-472">因此，你可能会捕获重载方法所引发的任何异常 <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> 和 <xref:System.Xml.XmlReader> 读取和分析文档的方法。</span><span class="sxs-lookup"><span data-stu-id="b21d2-472">Therefore, you might catch any exceptions that are thrown by the <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> overload methods and the <xref:System.Xml.XmlReader> methods that read and parse the document.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b21d2-473">下面的示例加载从中加载的行信息 <xref:System.Xml.XmlReader> 。</span><span class="sxs-lookup"><span data-stu-id="b21d2-473">The following example loads the line information that it loads from the <xref:System.Xml.XmlReader>.</span></span> <span data-ttu-id="b21d2-474">然后打印行信息。</span><span class="sxs-lookup"><span data-stu-id="b21d2-474">It then prints the line information.</span></span>  
  
```csharp  
string markup =  
@"<Root>  
    <Child>  
        <GrandChild/>  
    </Child>  
</Root>";  
  
// Create a reader and move to the content.  
using (XmlReader nodeReader = XmlReader.Create(new StringReader(markup)))  
{  
    // the reader must be in the Interactive state in order to  
    // Create a LINQ to XML tree from it.  
    nodeReader.MoveToContent();  
  
    XElement xRoot = XElement.Load(nodeReader, LoadOptions.SetLineInfo);  
    Console.WriteLine("{0}{1}{2}",  
        "Element Name".PadRight(20),  
        "Line".PadRight(5),  
        "Position");  
    Console.WriteLine("{0}{1}{2}",  
        "------------".PadRight(20),  
        "----".PadRight(5),  
        "--------");  
    foreach (XElement e in xRoot.DescendantsAndSelf())  
        Console.WriteLine("{0}{1}{2}",  
            ("".PadRight(e.Ancestors().Count() * 2) + e.Name).PadRight(20),  
            ((IXmlLineInfo)e).LineNumber.ToString().PadRight(5),  
            ((IXmlLineInfo)e).LinePosition);  
}  
```  
  
```vb  
Dim markup As String = _  
    "<Root>" & Environment.NewLine & _  
    "    <Child>" & Environment.NewLine & _  
    "        <GrandChild/>" & Environment.NewLine & _  
    "    </Child>" & Environment.NewLine & _  
    "</Root>"  
  
' Create a reader and move to the content.  
Using nodeReader As XmlReader = XmlReader.Create(New StringReader(markup))  
  
    ' the reader must be in the Interactive state in order to  
    ' Create a LINQ to XML tree from it.  
    nodeReader.MoveToContent()  
  
    Dim xRoot As XElement = XElement.Load(nodeReader, LoadOptions.SetLineInfo)  
    Console.WriteLine("{0}{1}{2}", _  
        "Element Name".PadRight(20), _  
        "Line".PadRight(5), _  
        "Position")  
    Console.WriteLine("{0}{1}{2}", _  
        "------------".PadRight(20), _  
        "----".PadRight(5), _  
        "--------")  
    For Each e As XElement In xRoot.DescendantsAndSelf()  
        Console.WriteLine("{0}{1}{2}", _  
            ("".PadRight(e.Ancestors().Count() * 2) & e.Name.ToString).PadRight(20), _  
            (DirectCast(e, IXmlLineInfo)).LineNumber.ToString().PadRight(5), _  
            (DirectCast(e, IXmlLineInfo)).LinePosition)  
    Next  
End Using  
```  
  
 <span data-ttu-id="b21d2-475">该示例产生下面的输出：</span><span class="sxs-lookup"><span data-stu-id="b21d2-475">This example produces the following output:</span></span>  
  
```  
Element Name        Line Position  
------------        ---- --------  
Root                1    2  
  Child             2    6  
    GrandChild      3    10  
```  
  
 ]]></format>
        </remarks>
        <related type="Article" href="/dotnet/standard/linq/linq-xml-overview"><span data-ttu-id="b21d2-476">LINQ to XML 概述</span><span class="sxs-lookup"><span data-stu-id="b21d2-476">LINQ to XML overview</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="LoadAsync">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;System.Xml.Linq.XElement&gt; LoadAsync (System.IO.Stream stream, System.Xml.Linq.LoadOptions options, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;class System.Xml.Linq.XElement&gt; LoadAsync(class System.IO.Stream stream, valuetype System.Xml.Linq.LoadOptions options, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XElement.LoadAsync(System.IO.Stream,System.Xml.Linq.LoadOptions,System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LoadAsync (stream As Stream, options As LoadOptions, cancellationToken As CancellationToken) As Task(Of XElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::Task&lt;System::Xml::Linq::XElement ^&gt; ^ LoadAsync(System::IO::Stream ^ stream, System::Xml::Linq::LoadOptions options, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="static member LoadAsync : System.IO.Stream * System.Xml.Linq.LoadOptions * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;System.Xml.Linq.XElement&gt;" Usage="System.Xml.Linq.XElement.LoadAsync (stream, options, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Xml.Linq.XElement&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="options" Type="System.Xml.Linq.LoadOptions" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="stream"><span data-ttu-id="b21d2-477">包含要读取的原始 XML 的流。</span><span class="sxs-lookup"><span data-stu-id="b21d2-477">The stream containing the raw XML to read.</span></span></param>
        <param name="options"><span data-ttu-id="b21d2-478">枚举值的按位组合，这些枚举值指定用于分析 XML 的加载选项。</span><span class="sxs-lookup"><span data-stu-id="b21d2-478">A bitwise combination of the enumeration values that specify the load options to parse the XML.</span></span></param>
        <param name="cancellationToken"><span data-ttu-id="b21d2-479">可用于请求异步操作取消的标志。</span><span class="sxs-lookup"><span data-stu-id="b21d2-479">A token that can be used to request cancellation of the asynchronous operation.</span></span></param>
        <summary><span data-ttu-id="b21d2-480">以异步方式创建新的 <see cref="T:System.Xml.Linq.XElement" /> 并使用指定的流初始化其基础 XML 树，可以选择保留空格。</span><span class="sxs-lookup"><span data-stu-id="b21d2-480">Asynchronously creates a new <see cref="T:System.Xml.Linq.XElement" /> and initializes its underlying XML tree using the specified stream, optionally preserving white space.</span></span></summary>
        <returns><span data-ttu-id="b21d2-481">包含指定流的内容的新 <see cref="T:System.Xml.Linq.XElement" />。</span><span class="sxs-lookup"><span data-stu-id="b21d2-481">A new <see cref="T:System.Xml.Linq.XElement" /> containing the contents of the specified stream.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="b21d2-482">如果 `options` 设置为 <xref:System.Xml.Linq.LoadOptions.PreserveWhitespace> ，则将 <xref:System.Xml.XmlReaderSettings.IgnoreWhitespace> 属性设置为 `false` 。</span><span class="sxs-lookup"><span data-stu-id="b21d2-482">If `options` is set to <xref:System.Xml.Linq.LoadOptions.PreserveWhitespace>, then the <xref:System.Xml.XmlReaderSettings.IgnoreWhitespace> property is set to `false`.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LoadAsync">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;System.Xml.Linq.XElement&gt; LoadAsync (System.IO.TextReader textReader, System.Xml.Linq.LoadOptions options, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;class System.Xml.Linq.XElement&gt; LoadAsync(class System.IO.TextReader textReader, valuetype System.Xml.Linq.LoadOptions options, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XElement.LoadAsync(System.IO.TextReader,System.Xml.Linq.LoadOptions,System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LoadAsync (textReader As TextReader, options As LoadOptions, cancellationToken As CancellationToken) As Task(Of XElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::Task&lt;System::Xml::Linq::XElement ^&gt; ^ LoadAsync(System::IO::TextReader ^ textReader, System::Xml::Linq::LoadOptions options, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="static member LoadAsync : System.IO.TextReader * System.Xml.Linq.LoadOptions * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;System.Xml.Linq.XElement&gt;" Usage="System.Xml.Linq.XElement.LoadAsync (textReader, options, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Xml.Linq.XElement&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="textReader" Type="System.IO.TextReader" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="options" Type="System.Xml.Linq.LoadOptions" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="textReader"><span data-ttu-id="b21d2-483">包含要读取的原始 XML 的读取器。</span><span class="sxs-lookup"><span data-stu-id="b21d2-483">A reader containing the raw XML to read.</span></span></param>
        <param name="options"><span data-ttu-id="b21d2-484">枚举值的按位组合，这些枚举值指定用于分析 XML 的加载选项。</span><span class="sxs-lookup"><span data-stu-id="b21d2-484">A bitwise combination of the enumeration values that specify the load options to parse the XML.</span></span></param>
        <param name="cancellationToken"><span data-ttu-id="b21d2-485">可用于请求异步操作取消的标志。</span><span class="sxs-lookup"><span data-stu-id="b21d2-485">A token that can be used to request cancellation of the asynchronous operation.</span></span></param>
        <summary><span data-ttu-id="b21d2-486">以异步方式创建新的 <see cref="T:System.Xml.Linq.XElement" /> 并使用指定的文本读取器初始化其基础 XML 树，可以选择保留空格。</span><span class="sxs-lookup"><span data-stu-id="b21d2-486">Asynchronously creates a new <see cref="T:System.Xml.Linq.XElement" /> and initializes its underlying XML tree using the specified text reader, optionally preserving white space.</span></span></summary>
        <returns><span data-ttu-id="b21d2-487">包含指定读取器的内容的新 <see cref="T:System.Xml.Linq.XElement" />。</span><span class="sxs-lookup"><span data-stu-id="b21d2-487">A new <see cref="T:System.Xml.Linq.XElement" /> containing the contents of the specified reader.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="b21d2-488">如果 `options` 设置为 <xref:System.Xml.Linq.LoadOptions.PreserveWhitespace> ，则将 <xref:System.Xml.XmlReaderSettings.IgnoreWhitespace> 属性设置为 `false` 。</span><span class="sxs-lookup"><span data-stu-id="b21d2-488">If `options` is set to <xref:System.Xml.Linq.LoadOptions.PreserveWhitespace>, then the <xref:System.Xml.XmlReaderSettings.IgnoreWhitespace> property is set to `false`.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LoadAsync">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;System.Xml.Linq.XElement&gt; LoadAsync (System.Xml.XmlReader reader, System.Xml.Linq.LoadOptions options, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;class System.Xml.Linq.XElement&gt; LoadAsync(class System.Xml.XmlReader reader, valuetype System.Xml.Linq.LoadOptions options, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XElement.LoadAsync(System.Xml.XmlReader,System.Xml.Linq.LoadOptions,System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LoadAsync (reader As XmlReader, options As LoadOptions, cancellationToken As CancellationToken) As Task(Of XElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::Task&lt;System::Xml::Linq::XElement ^&gt; ^ LoadAsync(System::Xml::XmlReader ^ reader, System::Xml::Linq::LoadOptions options, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="static member LoadAsync : System.Xml.XmlReader * System.Xml.Linq.LoadOptions * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;System.Xml.Linq.XElement&gt;" Usage="System.Xml.Linq.XElement.LoadAsync (reader, options, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Xml.Linq.XElement&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="options" Type="System.Xml.Linq.LoadOptions" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="reader"><span data-ttu-id="b21d2-489">包含要读取的 XML 的读取器。</span><span class="sxs-lookup"><span data-stu-id="b21d2-489">A reader containing the XML to be read.</span></span></param>
        <param name="options"><span data-ttu-id="b21d2-490">枚举值的按位组合，这些枚举值指定用于分析 XML 的加载选项。</span><span class="sxs-lookup"><span data-stu-id="b21d2-490">A bitwise combination of the enumeration values that specify the load options to parse the XML.</span></span></param>
        <param name="cancellationToken"><span data-ttu-id="b21d2-491">可用于请求异步操作取消的标志。</span><span class="sxs-lookup"><span data-stu-id="b21d2-491">A token that can be used to request cancellation of the asynchronous operation.</span></span></param>
        <summary><span data-ttu-id="b21d2-492">以异步方式创建新的 <see cref="T:System.Xml.Linq.XElement" /> 并使用指定的 XML 文本读取器初始化其基础 XML 树，可以选择保留空格。</span><span class="sxs-lookup"><span data-stu-id="b21d2-492">Asynchronously creates a new <see cref="T:System.Xml.Linq.XElement" /> and initializes its underlying XML tree using the specified XML reader, optionally preserving white space.</span></span></summary>
        <returns><span data-ttu-id="b21d2-493">包含指定读取器的内容的新 <see cref="T:System.Xml.Linq.XElement" />。</span><span class="sxs-lookup"><span data-stu-id="b21d2-493">A new <see cref="T:System.Xml.Linq.XElement" /> containing the contents of the specified reader.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public System.Xml.Linq.XName Name { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xml.Linq.XName Name" />
      <MemberSignature Language="DocId" Value="P:System.Xml.Linq.XElement.Name" />
      <MemberSignature Language="VB.NET" Value="Public Property Name As XName" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xml::Linq::XName ^ Name { System::Xml::Linq::XName ^ get(); void set(System::Xml::Linq::XName ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Name : System.Xml.Linq.XName with get, set" Usage="System.Xml.Linq.XElement.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Xml.Linq.XName</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="b21d2-494">获取或设置此元素的名称。</span><span class="sxs-lookup"><span data-stu-id="b21d2-494">Gets or sets the name of this element.</span></span></summary>
        <value><span data-ttu-id="b21d2-495">一个包含此元素的名称的 <see cref="T:System.Xml.Linq.XName" />。</span><span class="sxs-lookup"><span data-stu-id="b21d2-495">An <see cref="T:System.Xml.Linq.XName" /> that contains the name of this element.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b21d2-496">设置此属性将引发 <xref:System.Xml.Linq.XObject.Changed> 和 <xref:System.Xml.Linq.XObject.Changing> 事件。</span><span class="sxs-lookup"><span data-stu-id="b21d2-496">Setting this property will raise the <xref:System.Xml.Linq.XObject.Changed> and the <xref:System.Xml.Linq.XObject.Changing> events.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b21d2-497">下面的示例使用此属性来确定元素的名称。</span><span class="sxs-lookup"><span data-stu-id="b21d2-497">The following example uses this property to determine the name of an element.</span></span>  
  
```csharp  
XElement el1 = new XElement("Root", "content");  
Console.WriteLine(el1.Name);  
  
XNamespace ns = "http://www.adventure-works.com";  
XElement el2 = new XElement(ns + "Root", "content");  
Console.WriteLine(el2.Name);  
Console.WriteLine(el2.Name.Namespace);  
Console.WriteLine(el2.Name.LocalName);  
el2.Name = ns + "NewName";  
Console.WriteLine(el2.Name);  
```  
  
```vb  
Imports <xmlns:aw="http://www.adventure-works.com">  
  
Module Module1  
    Sub Main()  
        Dim el1 As XElement = <Root>content</Root>  
        Console.WriteLine(el1.Name)  
  
        Dim el2 As XElement = <aw:Root>content</aw:Root>  
        Console.WriteLine(el2.Name)  
        Console.WriteLine(el2.Name.Namespace)  
        Console.WriteLine(el2.Name.LocalName)  
        Dim aw as XNamespace = GetXmlNamespace(aw)  
        el2.Name = aw + "NewName"  
        Console.WriteLine(el2.Name)  
    End Sub  
End Module  
```  
  
 <span data-ttu-id="b21d2-498">该示例产生下面的输出：</span><span class="sxs-lookup"><span data-stu-id="b21d2-498">This example produces the following output:</span></span>  
  
```  
Root  
{http://www.adventure-works.com}Root  
http://www.adventure-works.com  
Root  
{http://www.adventure-works.com}NewName  
```  
  
 ]]></format>
        </remarks>
        <related type="Article" href="/dotnet/standard/linq/linq-xml-overview"><span data-ttu-id="b21d2-499">LINQ to XML 概述</span><span class="sxs-lookup"><span data-stu-id="b21d2-499">LINQ to XML overview</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="NodeType">
      <MemberSignature Language="C#" Value="public override System.Xml.XmlNodeType NodeType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Xml.XmlNodeType NodeType" />
      <MemberSignature Language="DocId" Value="P:System.Xml.Linq.XElement.NodeType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property NodeType As XmlNodeType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Xml::XmlNodeType NodeType { System::Xml::XmlNodeType get(); };" />
      <MemberSignature Language="F#" Value="member this.NodeType : System.Xml.XmlNodeType" Usage="System.Xml.Linq.XElement.NodeType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlNodeType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="b21d2-500">获取此节点的节点类型。</span><span class="sxs-lookup"><span data-stu-id="b21d2-500">Gets the node type for this node.</span></span></summary>
        <value><span data-ttu-id="b21d2-501">节点类型。</span><span class="sxs-lookup"><span data-stu-id="b21d2-501">The node type.</span></span> <span data-ttu-id="b21d2-502">对于 <see cref="T:System.Xml.Linq.XElement" /> 对象，此值为 <see cref="F:System.Xml.XmlNodeType.Element" />。</span><span class="sxs-lookup"><span data-stu-id="b21d2-502">For <see cref="T:System.Xml.Linq.XElement" /> objects, this value is <see cref="F:System.Xml.XmlNodeType.Element" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b21d2-503">由于派生自的所有类都 <xref:System.Xml.Linq.XObject> 包含一个 <xref:System.Xml.Linq.XObject.NodeType%2A> 属性，因此你可以编写对的具体子类的集合进行操作的代码 <xref:System.Xml.Linq.XObject> 。</span><span class="sxs-lookup"><span data-stu-id="b21d2-503">Because all classes that derive from <xref:System.Xml.Linq.XObject> contain a <xref:System.Xml.Linq.XObject.NodeType%2A> property, you can write code that operates on collections of concrete subclass of <xref:System.Xml.Linq.XObject>.</span></span> <span data-ttu-id="b21d2-504">然后，你的代码可以测试集合中每个节点的节点类型。</span><span class="sxs-lookup"><span data-stu-id="b21d2-504">Your code can then test for the node type of each node in the collection.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b21d2-505">下面的示例使用此属性来打印元素的节点类型。</span><span class="sxs-lookup"><span data-stu-id="b21d2-505">The following example uses this property to print the node type of an element.</span></span>  
  
```csharp  
XElement el1 = new XElement("Root", "content");  
Console.WriteLine(el1.NodeType);  
Console.WriteLine();  
```  
  
```vb  
Dim el1 As XElement = <Root>content</Root>  
Console.WriteLine(el1.NodeType.ToString())  
Console.WriteLine()  
```  
  
 <span data-ttu-id="b21d2-506">该示例产生下面的输出：</span><span class="sxs-lookup"><span data-stu-id="b21d2-506">This example produces the following output:</span></span>  
  
```  
Element  
```  
  
 ]]></format>
        </remarks>
        <related type="Article" href="/dotnet/standard/linq/linq-xml-overview"><span data-ttu-id="b21d2-507">LINQ to XML 概述</span><span class="sxs-lookup"><span data-stu-id="b21d2-507">LINQ to XML overview</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator bool (System.Xml.Linq.XElement element);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Explicit(class System.Xml.Linq.XElement element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Boolean" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (element As XElement) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator bool(System::Xml::Linq::XElement ^ element);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : System.Xml.Linq.XElement -&gt; bool" Usage="System.Xml.Linq.XElement.op_Explicit element" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Xml.Linq.XElement" />
      </Parameters>
      <Docs>
        <param name="element"><span data-ttu-id="b21d2-508">要强制转换为 <see cref="T:System.Boolean" /> 的 <see cref="T:System.Xml.Linq.XElement" />。</span><span class="sxs-lookup"><span data-stu-id="b21d2-508">The <see cref="T:System.Xml.Linq.XElement" /> to cast to <see cref="T:System.Boolean" />.</span></span></param>
        <summary><span data-ttu-id="b21d2-509">将此 <see cref="T:System.Xml.Linq.XElement" /> 的值强制转换为 <see cref="T:System.Boolean" />。</span><span class="sxs-lookup"><span data-stu-id="b21d2-509">Cast the value of this <see cref="T:System.Xml.Linq.XElement" /> to a <see cref="T:System.Boolean" />.</span></span></summary>
        <returns><span data-ttu-id="b21d2-510">一个 <see cref="T:System.Boolean" />，其中包含此 <see cref="T:System.Xml.Linq.XElement" /> 的内容。</span><span class="sxs-lookup"><span data-stu-id="b21d2-510">A <see cref="T:System.Boolean" /> that contains the content of this <see cref="T:System.Xml.Linq.XElement" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b21d2-511"><xref:System.Boolean>从特性或元素转换为时，允许的值为 "0"、"1" 和在修整和转换为小写后生成 "true" 或 "false" 的任何字符串。</span><span class="sxs-lookup"><span data-stu-id="b21d2-511">When converting to <xref:System.Boolean> from an attribute or element, allowed values are "0", "1", and any string that produces "true" or "false" after trimming and conversion to lower case.</span></span>
  
## Examples  
 <span data-ttu-id="b21d2-512">下面的示例创建一些具有布尔值的元素。</span><span class="sxs-lookup"><span data-stu-id="b21d2-512">The following example creates some elements with boolean values.</span></span> <span data-ttu-id="b21d2-513">然后将其转换为 <xref:System.Boolean> 。</span><span class="sxs-lookup"><span data-stu-id="b21d2-513">It then casts them to <xref:System.Boolean>.</span></span>  
  
```csharp  
XElement root = new XElement("Root",   
    new XElement("BoolValue1", true),  
    new XElement("BoolValue2", false)  
);  
bool bool1 = (bool)root.Element("BoolValue1");  
bool bool2 = (bool)root.Element("BoolValue2");  
Console.WriteLine("(bool)BoolValue1={0}", bool1);  
Console.WriteLine("(bool)BoolValue2={0}", bool2);  
```  
  
```vb  
Dim root As XElement = _   
        <Root>  
            <BoolValue1>true</BoolValue1>  
            <BoolValue2>false</BoolValue2>  
        </Root>  
Dim bool1 As Boolean = CBool(root.Element("BoolValue1"))  
Dim bool2 As Boolean = CBool(root.Element("BoolValue2"))  
Console.WriteLine("(bool)BoolValue1={0}", bool1)  
Console.WriteLine("(bool)BoolValue2={0}", bool2)  
```  
  
 <span data-ttu-id="b21d2-514">该示例产生下面的输出：</span><span class="sxs-lookup"><span data-stu-id="b21d2-514">This example produces the following output:</span></span>  
  
```  
(bool)BoolValue1=True  
(bool)BoolValue2=False  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException"><span data-ttu-id="b21d2-515">元素不包含有效的 <see cref="T:System.Boolean" /> 值。</span><span class="sxs-lookup"><span data-stu-id="b21d2-515">The element does not contain a valid <see cref="T:System.Boolean" /> value.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="b21d2-516"><paramref name="element" /> 参数为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="b21d2-516">The <paramref name="element" /> parameter is <see langword="null" />.</span></span></exception>
        <related type="Article" href="/dotnet/standard/linq/linq-xml-overview"><span data-ttu-id="b21d2-517">LINQ to XML 概述</span><span class="sxs-lookup"><span data-stu-id="b21d2-517">LINQ to XML overview</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator DateTime (System.Xml.Linq.XElement element);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.DateTime op_Explicit(class System.Xml.Linq.XElement element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.DateTime" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (element As XElement) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator DateTime(System::Xml::Linq::XElement ^ element);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : System.Xml.Linq.XElement -&gt; DateTime" Usage="System.Xml.Linq.XElement.op_Explicit element" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Xml.Linq.XElement" />
      </Parameters>
      <Docs>
        <param name="element"><span data-ttu-id="b21d2-518">要强制转换为 <see cref="T:System.DateTime" /> 的 <see cref="T:System.Xml.Linq.XElement" />。</span><span class="sxs-lookup"><span data-stu-id="b21d2-518">The <see cref="T:System.Xml.Linq.XElement" /> to cast to <see cref="T:System.DateTime" />.</span></span></param>
        <summary><span data-ttu-id="b21d2-519">将此 <see cref="T:System.Xml.Linq.XElement" /> 的值强制转换为 <see cref="T:System.DateTime" />。</span><span class="sxs-lookup"><span data-stu-id="b21d2-519">Cast the value of this <see cref="T:System.Xml.Linq.XElement" /> to a <see cref="T:System.DateTime" />.</span></span></summary>
        <returns><span data-ttu-id="b21d2-520">一个 <see cref="T:System.DateTime" />，其中包含此 <see cref="T:System.Xml.Linq.XElement" /> 的内容。</span><span class="sxs-lookup"><span data-stu-id="b21d2-520">A <see cref="T:System.DateTime" /> that contains the content of this <see cref="T:System.Xml.Linq.XElement" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b21d2-521">包含日期和时间内容的属性或元素的值空间与 ISO 8601 中所述的日期和时间密切相关。</span><span class="sxs-lookup"><span data-stu-id="b21d2-521">The value space of an attribute or element that contains date and time content is closely related to the dates and times described in ISO 8601.</span></span> <span data-ttu-id="b21d2-522">当创建包含日期和时间内容的属性或元素时，将根据 W3C 规范设置属性或元素值的格式。</span><span class="sxs-lookup"><span data-stu-id="b21d2-522">When creating an attribute or element that contains date and time content, the attribute or element values are formatted per the W3C specification.</span></span> <span data-ttu-id="b21d2-523">有关更多详细信息，请参阅 W3C 规范。</span><span class="sxs-lookup"><span data-stu-id="b21d2-523">See the W3C specification for more details.</span></span>  
  
 <span data-ttu-id="b21d2-524">从特性或元素强制转换为时，行为是不严格的 <xref:System.DateTime> 。</span><span class="sxs-lookup"><span data-stu-id="b21d2-524">Behavior is lax when casting to a <xref:System.DateTime> from an attribute or element.</span></span> <span data-ttu-id="b21d2-525">即使属性或元素值的格式设置与 W3C 规范的格式完全相同，此值也会相应地转换为 <xref:System.DateTime> 。</span><span class="sxs-lookup"><span data-stu-id="b21d2-525">Even if the attribute or element value is not formatted exactly per the W3C specification, the value is appropriately converted to a <xref:System.DateTime>.</span></span>  
  
 <span data-ttu-id="b21d2-526">此转换运算符使用 <xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType> 从转换 <xref:System.DateTime> 。</span><span class="sxs-lookup"><span data-stu-id="b21d2-526">This conversion operator uses <xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType> to convert from a <xref:System.DateTime>.</span></span>

## Examples  
 <span data-ttu-id="b21d2-527">下面的示例创建一个具有日期和时间内容的元素。</span><span class="sxs-lookup"><span data-stu-id="b21d2-527">The following example creates an element with date and time content.</span></span> <span data-ttu-id="b21d2-528">然后将其转换为 <xref:System.DateTime> 以检索值。</span><span class="sxs-lookup"><span data-stu-id="b21d2-528">It then casts it to <xref:System.DateTime> to retrieve the value.</span></span>  
  
```csharp  
// Behavior is strict when formatting an XML element or attribute from a DateTime,  
// but behavior is lax when casting to a DateTime from an element or attribute.  
XElement root = new XElement("Root", new DateTime(2006, 10, 6, 12, 30, 0));  
Console.WriteLine(root);  
  
// Cast from a strictly formatted XML element.  
DateTime dt = (DateTime)root;  
Console.WriteLine("dt={0}", dt);  
Console.WriteLine("-----");  
  
// If root is formatted in some different way:  
XElement dtElement = new XElement("OrderDate", "October 6, 2006");  
Console.WriteLine(dtElement);  
DateTime orderDate = (DateTime)dtElement;  
Console.WriteLine("orderDate={0:d}", orderDate);  
```  
  
```vb  
' Behavior is strict when formatting an XML element or attribute from a DateTime,  
' but behavior is lax when casting to a DateTime from an element or attribute.  
Dim root As XElement = <Root><%= New DateTime(2006, 10, 6, 12, 30, 0) %></Root>  
Console.WriteLine(root)  
  
' Cast from a strictly formatted XML element.  
Dim dt As DateTime = CType(root, DateTime)  
Console.WriteLine("dt={0}", dt)  
Console.WriteLine("-----")  
  
' If root is formatted in some different way:  
Dim dtElement As XElement = <OrderDate>October 6, 2006</OrderDate>  
Console.WriteLine(dtElement)  
Dim orderDate As DateTime = CType(dtElement, DateTime)  
Console.WriteLine("orderDate={0:d}", orderDate)  
```  
  
 <span data-ttu-id="b21d2-529">该示例产生下面的输出：</span><span class="sxs-lookup"><span data-stu-id="b21d2-529">This example produces the following output:</span></span>  
  
```  
<Root>2006-10-06T12:30:00</Root>  
dt=10/6/2006 12:30:00 PM  
-----  
<OrderDate>October 6, 2006</OrderDate>  
orderDate=10/6/2006  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException"><span data-ttu-id="b21d2-530">元素不包含有效的 <see cref="T:System.DateTime" /> 值。</span><span class="sxs-lookup"><span data-stu-id="b21d2-530">The element does not contain a valid <see cref="T:System.DateTime" /> value.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="b21d2-531"><paramref name="element" /> 参数为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="b21d2-531">The <paramref name="element" /> parameter is <see langword="null" />.</span></span></exception>
        <related type="Article" href="/dotnet/standard/linq/linq-xml-overview"><span data-ttu-id="b21d2-532">LINQ to XML 概述</span><span class="sxs-lookup"><span data-stu-id="b21d2-532">LINQ to XML overview</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator DateTimeOffset (System.Xml.Linq.XElement element);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.DateTimeOffset op_Explicit(class System.Xml.Linq.XElement element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.DateTimeOffset" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (element As XElement) As DateTimeOffset" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator DateTimeOffset(System::Xml::Linq::XElement ^ element);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : System.Xml.Linq.XElement -&gt; DateTimeOffset" Usage="System.Xml.Linq.XElement.op_Explicit element" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTimeOffset</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Xml.Linq.XElement" />
      </Parameters>
      <Docs>
        <param name="element"><span data-ttu-id="b21d2-533">要强制转换为 <see cref="T:System.DateTimeOffset" /> 的 <see cref="T:System.Xml.Linq.XElement" />。</span><span class="sxs-lookup"><span data-stu-id="b21d2-533">The <see cref="T:System.Xml.Linq.XElement" /> to cast to <see cref="T:System.DateTimeOffset" />.</span></span></param>
        <summary><span data-ttu-id="b21d2-534">将此 <see cref="T:System.Xml.Linq.XAttribute" /> 的值强制转换为 <see cref="T:System.DateTimeOffset" />。</span><span class="sxs-lookup"><span data-stu-id="b21d2-534">Cast the value of this <see cref="T:System.Xml.Linq.XAttribute" /> to a <see cref="T:System.DateTimeOffset" />.</span></span></summary>
        <returns><span data-ttu-id="b21d2-535">一个 <see cref="T:System.DateTimeOffset" />，其中包含此 <see cref="T:System.Xml.Linq.XElement" /> 的内容。</span><span class="sxs-lookup"><span data-stu-id="b21d2-535">A <see cref="T:System.DateTimeOffset" /> that contains the content of this <see cref="T:System.Xml.Linq.XElement" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b21d2-536">此转换运算符使用 <xref:System.Xml.XmlConvert> 类来执行转换。</span><span class="sxs-lookup"><span data-stu-id="b21d2-536">This conversion operator uses the <xref:System.Xml.XmlConvert> class to do the conversion.</span></span>  
  
## Examples  
 <span data-ttu-id="b21d2-537">下面的示例创建一个具有日期和时间内容的元素。</span><span class="sxs-lookup"><span data-stu-id="b21d2-537">The following example creates an element with date and time content.</span></span> <span data-ttu-id="b21d2-538">然后，将转换为 <xref:System.DateTimeOffset> 以检索值。</span><span class="sxs-lookup"><span data-stu-id="b21d2-538">It then casts to <xref:System.DateTimeOffset> to retrieve the value.</span></span>  
  
```csharp  
XElement root = new XElement("Root",  
    new XElement("Child", new DateTimeOffset(new DateTime(2006, 10, 6, 12, 30, 0)))  
);  
Console.WriteLine(root);  
  
DateTimeOffset dt = (DateTimeOffset)root.Element("Child");  
Console.WriteLine("dt={0}", dt);  
```  
  
```vb  
Dim root As XElement = _  
    <Root>  
        <Child><%= New DateTimeOffset(New DateTime(2006, 10, 6, 12, 30, 0)) %></Child>  
    </Root>  
Console.WriteLine(root)  
  
Dim dt As DateTimeOffset = CType(root.<Child>(0), DateTimeOffset)  
Console.WriteLine("dt={0}", dt)  
```  
  
 <span data-ttu-id="b21d2-539">该示例产生下面的输出：</span><span class="sxs-lookup"><span data-stu-id="b21d2-539">This example produces the following output:</span></span>  
  
```  
<Root>  
  <Child>2006-10-06T12:30:00-07:00</Child>  
</Root>  
dt=10/6/2006 12:30:00 PM -07:00  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException"><span data-ttu-id="b21d2-540">元素不包含有效的 <see cref="T:System.DateTimeOffset" /> 值。</span><span class="sxs-lookup"><span data-stu-id="b21d2-540">The element does not contain a valid <see cref="T:System.DateTimeOffset" /> value.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="b21d2-541"><paramref name="element" /> 参数为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="b21d2-541">The <paramref name="element" /> parameter is <see langword="null" />.</span></span></exception>
        <related type="Article" href="/dotnet/standard/linq/linq-xml-overview"><span data-ttu-id="b21d2-542">LINQ to XML 概述</span><span class="sxs-lookup"><span data-stu-id="b21d2-542">LINQ to XML overview</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator decimal (System.Xml.Linq.XElement element);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Decimal op_Explicit(class System.Xml.Linq.XElement element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Decimal" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (element As XElement) As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::Decimal(System::Xml::Linq::XElement ^ element);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : System.Xml.Linq.XElement -&gt; decimal" Usage="System.Xml.Linq.XElement.op_Explicit element" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Xml.Linq.XElement" />
      </Parameters>
      <Docs>
        <param name="element"><span data-ttu-id="b21d2-543">要强制转换为 <see cref="T:System.Decimal" /> 的 <see cref="T:System.Xml.Linq.XElement" />。</span><span class="sxs-lookup"><span data-stu-id="b21d2-543">The <see cref="T:System.Xml.Linq.XElement" /> to cast to <see cref="T:System.Decimal" />.</span></span></param>
        <summary><span data-ttu-id="b21d2-544">将此 <see cref="T:System.Xml.Linq.XElement" /> 的值强制转换为 <see cref="T:System.Decimal" />。</span><span class="sxs-lookup"><span data-stu-id="b21d2-544">Cast the value of this <see cref="T:System.Xml.Linq.XElement" /> to a <see cref="T:System.Decimal" />.</span></span></summary>
        <returns><span data-ttu-id="b21d2-545">一个 <see cref="T:System.Decimal" />，其中包含此 <see cref="T:System.Xml.Linq.XElement" /> 的内容。</span><span class="sxs-lookup"><span data-stu-id="b21d2-545">A <see cref="T:System.Decimal" /> that contains the content of this <see cref="T:System.Xml.Linq.XElement" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[
  
## Examples  
 <span data-ttu-id="b21d2-546">下面的示例创建一个具有十进制值的元素。</span><span class="sxs-lookup"><span data-stu-id="b21d2-546">The following example creates an element with a decimal value.</span></span> <span data-ttu-id="b21d2-547">然后，它通过强制转换为来检索特性的值 <xref:System.Decimal> 。</span><span class="sxs-lookup"><span data-stu-id="b21d2-547">It then retrieves the value of the attribute by casting to <xref:System.Decimal>.</span></span>  
  
```csharp  
XElement root = new XElement("Root", "79228162514264337593543950335");  
decimal value = (decimal)root;  
Console.WriteLine("value={0}", value);  
```  
  
```vb  
Dim root As XElement = <Root>79228162514264337593543950335</Root>  
Dim value As Decimal = CDec(root)  
Console.WriteLine("value={0}", value)  
  
```  
  
 <span data-ttu-id="b21d2-548">该示例产生下面的输出：</span><span class="sxs-lookup"><span data-stu-id="b21d2-548">This example produces the following output:</span></span>  
  
```  
value=79228162514264337593543950335  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException"><span data-ttu-id="b21d2-549">元素不包含有效的 <see cref="T:System.Decimal" /> 值。</span><span class="sxs-lookup"><span data-stu-id="b21d2-549">The element does not contain a valid <see cref="T:System.Decimal" /> value.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="b21d2-550"><paramref name="element" /> 参数为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="b21d2-550">The <paramref name="element" /> parameter is <see langword="null" />.</span></span></exception>
        <related type="Article" href="/dotnet/standard/linq/linq-xml-overview"><span data-ttu-id="b21d2-551">LINQ to XML 概述</span><span class="sxs-lookup"><span data-stu-id="b21d2-551">LINQ to XML overview</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator double (System.Xml.Linq.XElement element);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname float64 op_Explicit(class System.Xml.Linq.XElement element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Double" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (element As XElement) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator double(System::Xml::Linq::XElement ^ element);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : System.Xml.Linq.XElement -&gt; double" Usage="System.Xml.Linq.XElement.op_Explicit element" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Xml.Linq.XElement" />
      </Parameters>
      <Docs>
        <param name="element"><span data-ttu-id="b21d2-552">要强制转换为 <see cref="T:System.Double" /> 的 <see cref="T:System.Xml.Linq.XElement" />。</span><span class="sxs-lookup"><span data-stu-id="b21d2-552">The <see cref="T:System.Xml.Linq.XElement" /> to cast to <see cref="T:System.Double" />.</span></span></param>
        <summary><span data-ttu-id="b21d2-553">将此 <see cref="T:System.Xml.Linq.XElement" /> 的值强制转换为 <see cref="T:System.Double" />。</span><span class="sxs-lookup"><span data-stu-id="b21d2-553">Cast the value of this <see cref="T:System.Xml.Linq.XElement" /> to a <see cref="T:System.Double" />.</span></span></summary>
        <returns><span data-ttu-id="b21d2-554">一个 <see cref="T:System.Double" />，其中包含此 <see cref="T:System.Xml.Linq.XElement" /> 的内容。</span><span class="sxs-lookup"><span data-stu-id="b21d2-554">A <see cref="T:System.Double" /> that contains the content of this <see cref="T:System.Xml.Linq.XElement" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
## Examples  
 <span data-ttu-id="b21d2-555">下面的示例创建一个包含内容的属性 `double` 。</span><span class="sxs-lookup"><span data-stu-id="b21d2-555">The following example creates an attribute with `double` content.</span></span> <span data-ttu-id="b21d2-556">然后，它通过强制转换为来检索值 <xref:System.Double> 。</span><span class="sxs-lookup"><span data-stu-id="b21d2-556">It then retrieves the value by casting to <xref:System.Double>.</span></span>  
  
```csharp  
XElement root = new XElement("Root", 1.79769313486231e308);  
double value = (double)root;  
Console.WriteLine("value={0}", value);  
```  
  
```vb  
Dim root As XElement = <Root>1.79769313486231E+308</Root>  
Dim value As Double = CDbl(root)  
Console.WriteLine("value={0}", value)  
```  
  
 <span data-ttu-id="b21d2-557">该示例产生下面的输出：</span><span class="sxs-lookup"><span data-stu-id="b21d2-557">This example produces the following output:</span></span>  
  
```  
value=1.79769313486231E+308  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException"><span data-ttu-id="b21d2-558">元素不包含有效的 <see cref="T:System.Double" /> 值。</span><span class="sxs-lookup"><span data-stu-id="b21d2-558">The element does not contain a valid <see cref="T:System.Double" /> value.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="b21d2-559"><paramref name="element" /> 参数为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="b21d2-559">The <paramref name="element" /> parameter is <see langword="null" />.</span></span></exception>
        <related type="Article" href="/dotnet/standard/linq/linq-xml-overview"><span data-ttu-id="b21d2-560">LINQ to XML 概述</span><span class="sxs-lookup"><span data-stu-id="b21d2-560">LINQ to XML overview</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator Guid (System.Xml.Linq.XElement element);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Guid op_Explicit(class System.Xml.Linq.XElement element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Guid" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (element As XElement) As Guid" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator Guid(System::Xml::Linq::XElement ^ element);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : System.Xml.Linq.XElement -&gt; Guid" Usage="System.Xml.Linq.XElement.op_Explicit element" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Xml.Linq.XElement" />
      </Parameters>
      <Docs>
        <param name="element"><span data-ttu-id="b21d2-561">要强制转换为 <see cref="T:System.Guid" /> 的 <see cref="T:System.Xml.Linq.XElement" />。</span><span class="sxs-lookup"><span data-stu-id="b21d2-561">The <see cref="T:System.Xml.Linq.XElement" /> to cast to <see cref="T:System.Guid" />.</span></span></param>
        <summary><span data-ttu-id="b21d2-562">将此 <see cref="T:System.Xml.Linq.XElement" /> 的值强制转换为 <see cref="T:System.Guid" />。</span><span class="sxs-lookup"><span data-stu-id="b21d2-562">Cast the value of this <see cref="T:System.Xml.Linq.XElement" /> to a <see cref="T:System.Guid" />.</span></span></summary>
        <returns><span data-ttu-id="b21d2-563">一个 <see cref="T:System.Guid" />，其中包含此 <see cref="T:System.Xml.Linq.XElement" /> 的内容。</span><span class="sxs-lookup"><span data-stu-id="b21d2-563">A <see cref="T:System.Guid" /> that contains the content of this <see cref="T:System.Xml.Linq.XElement" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[
  
## Examples  
 <span data-ttu-id="b21d2-564">下面的示例创建一个元素，并将 guid 作为内容。</span><span class="sxs-lookup"><span data-stu-id="b21d2-564">The following example creates an element with a guid as content.</span></span> <span data-ttu-id="b21d2-565">然后，它通过强制转换为来检索值 <xref:System.Guid> 。</span><span class="sxs-lookup"><span data-stu-id="b21d2-565">It then retrieves the value by casting to <xref:System.Guid>.</span></span>  
  
```csharp  
XElement root = new XElement("Root", new Guid("3c1cc55b-baff-4b7a-9d17-077af3aa5730"));  
Guid value = (Guid)root;  
Console.WriteLine("value={0}", value);  
```  
  
```vb  
Dim root As XElement = <Root><%= New Guid("3c1cc55b-baff-4b7a-9d17-077af3aa5730") %></Root>  
Dim value As Guid = CType(root, Guid)  
Console.WriteLine("value={0}", value)  
```  
  
 <span data-ttu-id="b21d2-566">该示例产生下面的输出：</span><span class="sxs-lookup"><span data-stu-id="b21d2-566">This example produces the following output:</span></span>  
  
```  
value=3c1cc55b-baff-4b7a-9d17-077af3aa5730  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException"><span data-ttu-id="b21d2-567">元素不包含有效的 <see cref="T:System.Guid" /> 值。</span><span class="sxs-lookup"><span data-stu-id="b21d2-567">The element does not contain a valid <see cref="T:System.Guid" /> value.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="b21d2-568"><paramref name="element" /> 参数为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="b21d2-568">The <paramref name="element" /> parameter is <see langword="null" />.</span></span></exception>
        <related type="Article" href="/dotnet/standard/linq/linq-xml-overview"><span data-ttu-id="b21d2-569">LINQ to XML 概述</span><span class="sxs-lookup"><span data-stu-id="b21d2-569">LINQ to XML overview</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator int (System.Xml.Linq.XElement element);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname int32 op_Explicit(class System.Xml.Linq.XElement element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Int32" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (element As XElement) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator int(System::Xml::Linq::XElement ^ element);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : System.Xml.Linq.XElement -&gt; int" Usage="System.Xml.Linq.XElement.op_Explicit element" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Xml.Linq.XElement" />
      </Parameters>
      <Docs>
        <param name="element"><span data-ttu-id="b21d2-570">要强制转换为 <see cref="T:System.Int32" /> 的 <see cref="T:System.Xml.Linq.XElement" />。</span><span class="sxs-lookup"><span data-stu-id="b21d2-570">The <see cref="T:System.Xml.Linq.XElement" /> to cast to <see cref="T:System.Int32" />.</span></span></param>
        <summary><span data-ttu-id="b21d2-571">将此 <see cref="T:System.Xml.Linq.XElement" /> 的值强制转换为 <see cref="T:System.Int32" />。</span><span class="sxs-lookup"><span data-stu-id="b21d2-571">Cast the value of this <see cref="T:System.Xml.Linq.XElement" /> to an <see cref="T:System.Int32" />.</span></span></summary>
        <returns><span data-ttu-id="b21d2-572">一个 <see cref="T:System.Int32" />，其中包含此 <see cref="T:System.Xml.Linq.XElement" /> 的内容。</span><span class="sxs-lookup"><span data-stu-id="b21d2-572">A <see cref="T:System.Int32" /> that contains the content of this <see cref="T:System.Xml.Linq.XElement" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[
  
## Examples  
 <span data-ttu-id="b21d2-573">下面的示例创建一个元素，其中包含整数作为内容。</span><span class="sxs-lookup"><span data-stu-id="b21d2-573">The following example creates an element with an integer as content.</span></span> <span data-ttu-id="b21d2-574">然后，它通过强制转换为来检索值 <xref:System.Int32> 。</span><span class="sxs-lookup"><span data-stu-id="b21d2-574">It then retrieves the value by casting to <xref:System.Int32>.</span></span>  
  
```csharp  
XElement root = new XElement("Root", 2147483647);  
int value = (int)root;  
Console.WriteLine("value={0}", value);  
```  
  
```vb  
Dim root As XElement = <Root>2147483647</Root>  
Dim value As Integer = CInt(root)  
Console.WriteLine("value={0}", value)  
```  
  
 <span data-ttu-id="b21d2-575">该示例产生下面的输出：</span><span class="sxs-lookup"><span data-stu-id="b21d2-575">This example produces the following output:</span></span>  
  
```  
value=2147483647  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException"><span data-ttu-id="b21d2-576">元素不包含有效的 <see cref="T:System.Int32" /> 值。</span><span class="sxs-lookup"><span data-stu-id="b21d2-576">The element does not contain a valid <see cref="T:System.Int32" /> value.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="b21d2-577"><paramref name="element" /> 参数为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="b21d2-577">The <paramref name="element" /> parameter is <see langword="null" />.</span></span></exception>
        <related type="Article" href="/dotnet/standard/linq/linq-xml-overview"><span data-ttu-id="b21d2-578">LINQ to XML 概述</span><span class="sxs-lookup"><span data-stu-id="b21d2-578">LINQ to XML overview</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator long (System.Xml.Linq.XElement element);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname int64 op_Explicit(class System.Xml.Linq.XElement element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Int64" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (element As XElement) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator long(System::Xml::Linq::XElement ^ element);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : System.Xml.Linq.XElement -&gt; int64" Usage="System.Xml.Linq.XElement.op_Explicit element" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Xml.Linq.XElement" />
      </Parameters>
      <Docs>
        <param name="element"><span data-ttu-id="b21d2-579">要强制转换为 <see cref="T:System.Int64" /> 的 <see cref="T:System.Xml.Linq.XElement" />。</span><span class="sxs-lookup"><span data-stu-id="b21d2-579">The <see cref="T:System.Xml.Linq.XElement" /> to cast to <see cref="T:System.Int64" />.</span></span></param>
        <summary><span data-ttu-id="b21d2-580">将此 <see cref="T:System.Xml.Linq.XElement" /> 的值强制转换为 <see cref="T:System.Int64" />。</span><span class="sxs-lookup"><span data-stu-id="b21d2-580">Cast the value of this <see cref="T:System.Xml.Linq.XElement" /> to an <see cref="T:System.Int64" />.</span></span></summary>
        <returns><span data-ttu-id="b21d2-581">一个 <see cref="T:System.Int64" />，其中包含此 <see cref="T:System.Xml.Linq.XElement" /> 的内容。</span><span class="sxs-lookup"><span data-stu-id="b21d2-581">A <see cref="T:System.Int64" /> that contains the content of this <see cref="T:System.Xml.Linq.XElement" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[
  
## Examples  
 <span data-ttu-id="b21d2-582">下面的示例创建一个具有长整数作为内容的元素。</span><span class="sxs-lookup"><span data-stu-id="b21d2-582">The following example creates an element with a long integer as content.</span></span> <span data-ttu-id="b21d2-583">然后，它通过强制转换为来检索元素的值 <xref:System.Int64> 。</span><span class="sxs-lookup"><span data-stu-id="b21d2-583">It then retrieves the value of the element by casting to <xref:System.Int64>.</span></span>  
  
```csharp  
XElement root = new XElement("Root", 9223372036854775807);  
long value = (long)root;  
Console.WriteLine("value={0}", value);  
```  
  
```vb  
Dim root As XElement = <Root>9223372036854775807</Root>  
Dim value As Long = CLng(root)  
Console.WriteLine("value={0}", value)  
```  
  
 <span data-ttu-id="b21d2-584">该示例产生下面的输出：</span><span class="sxs-lookup"><span data-stu-id="b21d2-584">This example produces the following output:</span></span>  
  
```  
value=9223372036854775807  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException"><span data-ttu-id="b21d2-585">元素不包含有效的 <see cref="T:System.Int64" /> 值。</span><span class="sxs-lookup"><span data-stu-id="b21d2-585">The element does not contain a valid <see cref="T:System.Int64" /> value.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="b21d2-586"><paramref name="element" /> 参数为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="b21d2-586">The <paramref name="element" /> parameter is <see langword="null" />.</span></span></exception>
        <related type="Article" href="/dotnet/standard/linq/linq-xml-overview"><span data-ttu-id="b21d2-587">LINQ to XML 概述</span><span class="sxs-lookup"><span data-stu-id="b21d2-587">LINQ to XML overview</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator bool? (System.Xml.Linq.XElement element);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Nullable`1&lt;bool&gt; op_Explicit(class System.Xml.Linq.XElement element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Nullable{System.Boolean}" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (element As XElement) As Nullable(Of Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator Nullable&lt;bool&gt;(System::Xml::Linq::XElement ^ element);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : System.Xml.Linq.XElement -&gt; Nullable&lt;bool&gt;" Usage="System.Xml.Linq.XElement.op_Explicit element" />
      <MemberSignature Language="C#" Value="public static explicit operator bool? (System.Xml.Linq.XElement? element);" FrameworkAlternate="net-5.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Boolean&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Xml.Linq.XElement" />
      </Parameters>
      <Docs>
        <param name="element"><span data-ttu-id="b21d2-588">要强制转换为 <see cref="T:System.Boolean" /> 的 <see cref="T:System.Nullable`1" /> 的 <see cref="T:System.Xml.Linq.XElement" />。</span><span class="sxs-lookup"><span data-stu-id="b21d2-588">The <see cref="T:System.Xml.Linq.XElement" /> to cast to <see cref="T:System.Nullable`1" /> of <see cref="T:System.Boolean" />.</span></span></param>
        <summary><span data-ttu-id="b21d2-589">将此 <see cref="T:System.Xml.Linq.XElement" /> 的值强制转换为 <see cref="T:System.Boolean" /> 的 <see cref="T:System.Nullable`1" />。</span><span class="sxs-lookup"><span data-stu-id="b21d2-589">Cast the value of this <see cref="T:System.Xml.Linq.XElement" /> to a <see cref="T:System.Nullable`1" /> of <see cref="T:System.Boolean" />.</span></span></summary>
        <returns><span data-ttu-id="b21d2-590">一个 <see cref="T:System.Boolean" /> 的 <see cref="T:System.Nullable`1" />，其中包含此 <see cref="T:System.Xml.Linq.XElement" /> 的内容。</span><span class="sxs-lookup"><span data-stu-id="b21d2-590">A <see cref="T:System.Nullable`1" /> of <see cref="T:System.Boolean" /> that contains the content of this <see cref="T:System.Xml.Linq.XElement" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b21d2-591"><xref:System.Nullable%601> <xref:System.Boolean> 从特性或元素转换为时，允许的值为 "0"、"1" 和在修整和转换为小写后生成 "true" 或 "false" 的任何字符串。</span><span class="sxs-lookup"><span data-stu-id="b21d2-591">When converting to <xref:System.Nullable%601> of <xref:System.Boolean> from an attribute or element, allowed values are "0", "1", and any string that produces "true" or "false" after trimming and conversion to lower case.</span></span>
  
## Examples  
 <span data-ttu-id="b21d2-592">下面的示例创建一个具有布尔内容的元素。</span><span class="sxs-lookup"><span data-stu-id="b21d2-592">The following example creates an element with boolean content.</span></span> <span data-ttu-id="b21d2-593">然后，它通过强制转换为来检索值 <xref:System.Nullable%601> <xref:System.Boolean> 。</span><span class="sxs-lookup"><span data-stu-id="b21d2-593">It then retrieves the value by casting to <xref:System.Nullable%601> of <xref:System.Boolean>.</span></span>  
  
```csharp  
XElement root = new XElement("Root",   
    new XElement("BoolValue1", true),  
    new XElement("BoolValue2", false));  
bool? bool1 = (bool?)root.Element("BoolValue1");  
bool? bool2 = (bool?)root.Element("BoolValue2");  
Console.WriteLine("Nullable Boolean: value1={0}", bool1);  
Console.WriteLine("Nullable Boolean: value2={0}", bool2);  
```  
  
```vb  
Dim root As XElement = _   
        <Root>  
            <BoolValue1>true</BoolValue1>  
            <BoolValue2>false</BoolValue2>  
        </Root>  
  
Dim value1 As Nullable(Of Boolean) = CType(root.Element("BoolValue1"), Nullable(Of Boolean))  
Dim value2 As Nullable(Of Boolean) = CType(root.Element("BoolValue2"), Nullable(Of Boolean))  
Console.WriteLine("Nullable Boolean: value1={0}", IIf(value1.HasValue, value1.ToString(), "null"))  
Console.WriteLine("Nullable Boolean: value2={0}", IIf(value2.HasValue, value2.ToString(), "null"))  
```  
  
 <span data-ttu-id="b21d2-594">该示例产生下面的输出：</span><span class="sxs-lookup"><span data-stu-id="b21d2-594">This example produces the following output:</span></span>  
  
```  
Nullable Boolean: value1=True  
Nullable Boolean: value2=False  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException"><span data-ttu-id="b21d2-595">元素不是 <see langword="null" /> 且不包含有效的 <see cref="T:System.Boolean" /> 值。</span><span class="sxs-lookup"><span data-stu-id="b21d2-595">The element is not <see langword="null" /> and does not contain a valid <see cref="T:System.Boolean" /> value.</span></span></exception>
        <related type="Article" href="/dotnet/standard/linq/linq-xml-overview"><span data-ttu-id="b21d2-596">LINQ to XML 概述</span><span class="sxs-lookup"><span data-stu-id="b21d2-596">LINQ to XML overview</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator DateTime? (System.Xml.Linq.XElement element);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Nullable`1&lt;valuetype System.DateTime&gt; op_Explicit(class System.Xml.Linq.XElement element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Nullable{System.DateTime}" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (element As XElement) As Nullable(Of DateTime)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator Nullable&lt;DateTime&gt;(System::Xml::Linq::XElement ^ element);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : System.Xml.Linq.XElement -&gt; Nullable&lt;DateTime&gt;" Usage="System.Xml.Linq.XElement.op_Explicit element" />
      <MemberSignature Language="C#" Value="public static explicit operator DateTime? (System.Xml.Linq.XElement? element);" FrameworkAlternate="net-5.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.DateTime&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Xml.Linq.XElement" />
      </Parameters>
      <Docs>
        <param name="element"><span data-ttu-id="b21d2-597">要强制转换为 <see cref="T:System.DateTime" /> 的 <see cref="T:System.Nullable`1" /> 的 <see cref="T:System.Xml.Linq.XElement" />。</span><span class="sxs-lookup"><span data-stu-id="b21d2-597">The <see cref="T:System.Xml.Linq.XElement" /> to cast to <see cref="T:System.Nullable`1" /> of <see cref="T:System.DateTime" />.</span></span></param>
        <summary><span data-ttu-id="b21d2-598">将此 <see cref="T:System.Xml.Linq.XElement" /> 的值强制转换为 <see cref="T:System.DateTime" /> 的 <see cref="T:System.Nullable`1" />。</span><span class="sxs-lookup"><span data-stu-id="b21d2-598">Cast the value of this <see cref="T:System.Xml.Linq.XElement" /> to a <see cref="T:System.Nullable`1" /> of <see cref="T:System.DateTime" />.</span></span></summary>
        <returns><span data-ttu-id="b21d2-599">一个 <see cref="T:System.DateTime" /> 的 <see cref="T:System.Nullable`1" />，其中包含此 <see cref="T:System.Xml.Linq.XElement" /> 的内容。</span><span class="sxs-lookup"><span data-stu-id="b21d2-599">A <see cref="T:System.Nullable`1" /> of <see cref="T:System.DateTime" /> that contains the content of this <see cref="T:System.Xml.Linq.XElement" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b21d2-600">包含日期和时间内容的属性或元素的值空间与 ISO 8601 中所述的日期和时间密切相关。</span><span class="sxs-lookup"><span data-stu-id="b21d2-600">The value space of an attribute or element that contains date and time content is closely related to the dates and times described in ISO 8601.</span></span> <span data-ttu-id="b21d2-601">当创建包含日期和时间内容的属性或元素时，将根据 W3C 规范设置属性或元素值的格式。</span><span class="sxs-lookup"><span data-stu-id="b21d2-601">When creating an attribute or element that contains date and time content, the attribute or element values are formatted per the W3C specification.</span></span> <span data-ttu-id="b21d2-602">有关更多详细信息，请参阅 W3C 规范。</span><span class="sxs-lookup"><span data-stu-id="b21d2-602">See the W3C specification for more details.</span></span>  
  
 <span data-ttu-id="b21d2-603"><xref:System.Nullable%601>从特性或元素强制转换到的时，行为是不严格的 <xref:System.DateTime> 。</span><span class="sxs-lookup"><span data-stu-id="b21d2-603">The behavior is lax when casting to a <xref:System.Nullable%601> of <xref:System.DateTime> from an attribute or element.</span></span> <span data-ttu-id="b21d2-604">即使属性或元素值的格式设置与 W3C 规范的格式完全相同，此值也会相应地转换为 <xref:System.Nullable%601> 的 <xref:System.DateTime> 。</span><span class="sxs-lookup"><span data-stu-id="b21d2-604">Even if the attribute or element value is not formatted exactly per the W3C specification, the value is appropriately converted to a <xref:System.Nullable%601> of <xref:System.DateTime>.</span></span>  
  
 <span data-ttu-id="b21d2-605">此转换运算符使用 <xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType> 从转换 <xref:System.DateTime> 。</span><span class="sxs-lookup"><span data-stu-id="b21d2-605">This conversion operator uses <xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType> to convert from a <xref:System.DateTime>.</span></span>
  
## Examples  
 <span data-ttu-id="b21d2-606">下面的示例创建一个元素，该元素具有作为内容的日期和时间。</span><span class="sxs-lookup"><span data-stu-id="b21d2-606">The following example creates an element with a date and time as content.</span></span> <span data-ttu-id="b21d2-607">然后，它通过强制转换为来检索值 <xref:System.Nullable%601> <xref:System.DateTime> 。</span><span class="sxs-lookup"><span data-stu-id="b21d2-607">It then retrieves the value by casting to <xref:System.Nullable%601> of <xref:System.DateTime>.</span></span>  
  
```csharp
XElement root = new XElement("Root",  
    new XElement("Value", new DateTime(2006, 10, 6, 12, 30, 0))  
);  
DateTime? value = (DateTime?)root.Element("Value");  
Console.WriteLine("Nullable DateTime: value={0}", value == null ? "null" : value.ToString());  
```  
  
```vb  
Dim root As XElement = _   
    <Root>  
        <Value><%= New DateTime(2006, 10, 6, 12, 30, 0) %></Value>  
    </Root>  
Dim value As Nullable(Of DateTime) = CType(root.Element("Value"), Nullable(Of DateTime))  
Console.WriteLine("Nullable DateTime: value={0}", IIf(value.HasValue, value.ToString(), "null"))  
```  
  
 <span data-ttu-id="b21d2-608">该示例产生下面的输出：</span><span class="sxs-lookup"><span data-stu-id="b21d2-608">This example produces the following output:</span></span>  
  
```  
Nullable DateTime: value=10/6/2006 12:30:00 PM  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException"><span data-ttu-id="b21d2-609">元素不是 <see langword="null" /> 且不包含有效的 <see cref="T:System.DateTime" /> 值。</span><span class="sxs-lookup"><span data-stu-id="b21d2-609">The element is not <see langword="null" /> and does not contain a valid <see cref="T:System.DateTime" /> value.</span></span></exception>
        <related type="Article" href="/dotnet/standard/linq/linq-xml-overview"><span data-ttu-id="b21d2-610">LINQ to XML 概述</span><span class="sxs-lookup"><span data-stu-id="b21d2-610">LINQ to XML overview</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator DateTimeOffset? (System.Xml.Linq.XElement element);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; op_Explicit(class System.Xml.Linq.XElement element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Nullable{System.DateTimeOffset}" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (element As XElement) As Nullable(Of DateTimeOffset)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator Nullable&lt;DateTimeOffset&gt;(System::Xml::Linq::XElement ^ element);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : System.Xml.Linq.XElement -&gt; Nullable&lt;DateTimeOffset&gt;" Usage="System.Xml.Linq.XElement.op_Explicit element" />
      <MemberSignature Language="C#" Value="public static explicit operator DateTimeOffset? (System.Xml.Linq.XElement? element);" FrameworkAlternate="net-5.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.DateTimeOffset&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Xml.Linq.XElement" />
      </Parameters>
      <Docs>
        <param name="element"><span data-ttu-id="b21d2-611">强制转换为 <see cref="T:System.Xml.Linq.XElement" /> 类型的 <see cref="T:System.Nullable`1" /> 的 <see cref="T:System.DateTimeOffset" />。</span><span class="sxs-lookup"><span data-stu-id="b21d2-611">The <see cref="T:System.Xml.Linq.XElement" /> to cast to an <see cref="T:System.Nullable`1" /> of <see cref="T:System.DateTimeOffset" />.</span></span></param>
        <summary><span data-ttu-id="b21d2-612">将此 <see cref="T:System.Xml.Linq.XElement" /> 的值强制转换为 <see cref="T:System.DateTimeOffset" /> 的 <see cref="T:System.Nullable`1" />。</span><span class="sxs-lookup"><span data-stu-id="b21d2-612">Cast the value of this <see cref="T:System.Xml.Linq.XElement" /> to a <see cref="T:System.Nullable`1" /> of <see cref="T:System.DateTimeOffset" />.</span></span></summary>
        <returns><span data-ttu-id="b21d2-613">一个 <see cref="T:System.DateTimeOffset" /> 的 <see cref="T:System.Nullable`1" />，其中包含此 <see cref="T:System.Xml.Linq.XElement" /> 的内容。</span><span class="sxs-lookup"><span data-stu-id="b21d2-613">A <see cref="T:System.Nullable`1" /> of <see cref="T:System.DateTimeOffset" /> that contains the content of this <see cref="T:System.Xml.Linq.XElement" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b21d2-614">此转换运算符使用 <xref:System.Xml.XmlConvert> 类来执行转换。</span><span class="sxs-lookup"><span data-stu-id="b21d2-614">This conversion operator uses the <xref:System.Xml.XmlConvert> class to do the conversion.</span></span>
  
## Examples  
 <span data-ttu-id="b21d2-615">下面的示例创建一个具有日期和时间内容的元素。</span><span class="sxs-lookup"><span data-stu-id="b21d2-615">The following example creates an element with date and time content.</span></span> <span data-ttu-id="b21d2-616">然后，将转换为 <xref:System.Nullable%601> 的以 <xref:System.DateTimeOffset> 检索值。</span><span class="sxs-lookup"><span data-stu-id="b21d2-616">It then casts to <xref:System.Nullable%601> of <xref:System.DateTimeOffset> to retrieve the value.</span></span>  
  
```csharp  
XElement root = new XElement("Root",  
    new XElement("Child", new DateTimeOffset(new DateTime(2006, 10, 6, 12, 30, 0)))  
);  
Console.WriteLine(root);  
  
DateTimeOffset? dt = (DateTimeOffset?)root.Element("Child");  
Console.WriteLine("dt={0}", dt);  
```  
  
```vb  
Dim root As XElement = _  
    <Root>  
        <Child><%= New DateTimeOffset(New DateTime(2006, 10, 6, 12, 30, 0)) %></Child>  
    </Root>  
Console.WriteLine(root)  
  
Dim dt As Nullable(Of DateTimeOffset) = CType(root.<Child>(0), Nullable(Of DateTimeOffset))  
Console.WriteLine("dt={0}", dt)  
```  
  
 <span data-ttu-id="b21d2-617">该示例产生下面的输出：</span><span class="sxs-lookup"><span data-stu-id="b21d2-617">This example produces the following output:</span></span>  
  
```  
<Root>  
  <Child>2006-10-06T12:30:00-07:00</Child>  
</Root>  
dt=10/6/2006 12:30:00 PM -07:00  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException"><span data-ttu-id="b21d2-618">元素不是 <see langword="null" /> 且不包含有效的 <see cref="T:System.DateTimeOffset" /> 值。</span><span class="sxs-lookup"><span data-stu-id="b21d2-618">The element is not <see langword="null" /> and does not contain a valid <see cref="T:System.DateTimeOffset" /> value.</span></span></exception>
        <related type="Article" href="/dotnet/standard/linq/linq-xml-overview"><span data-ttu-id="b21d2-619">LINQ to XML 概述</span><span class="sxs-lookup"><span data-stu-id="b21d2-619">LINQ to XML overview</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator decimal? (System.Xml.Linq.XElement element);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Nullable`1&lt;valuetype System.Decimal&gt; op_Explicit(class System.Xml.Linq.XElement element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Nullable{System.Decimal}" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (element As XElement) As Nullable(Of Decimal)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator Nullable&lt;System::Decimal&gt;(System::Xml::Linq::XElement ^ element);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : System.Xml.Linq.XElement -&gt; Nullable&lt;decimal&gt;" Usage="System.Xml.Linq.XElement.op_Explicit element" />
      <MemberSignature Language="C#" Value="public static explicit operator decimal? (System.Xml.Linq.XElement? element);" FrameworkAlternate="net-5.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Decimal&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Xml.Linq.XElement" />
      </Parameters>
      <Docs>
        <param name="element"><span data-ttu-id="b21d2-620">要强制转换为 <see cref="T:System.Decimal" /> 的 <see cref="T:System.Nullable`1" /> 的 <see cref="T:System.Xml.Linq.XElement" />。</span><span class="sxs-lookup"><span data-stu-id="b21d2-620">The <see cref="T:System.Xml.Linq.XElement" /> to cast to <see cref="T:System.Nullable`1" /> of <see cref="T:System.Decimal" />.</span></span></param>
        <summary><span data-ttu-id="b21d2-621">将此 <see cref="T:System.Xml.Linq.XElement" /> 的值强制转换为 <see cref="T:System.Decimal" /> 的 <see cref="T:System.Nullable`1" />。</span><span class="sxs-lookup"><span data-stu-id="b21d2-621">Cast the value of this <see cref="T:System.Xml.Linq.XElement" /> to a <see cref="T:System.Nullable`1" /> of <see cref="T:System.Decimal" />.</span></span></summary>
        <returns><span data-ttu-id="b21d2-622">一个 <see cref="T:System.Decimal" /> 的 <see cref="T:System.Nullable`1" />，其中包含此 <see cref="T:System.Xml.Linq.XElement" /> 的内容。</span><span class="sxs-lookup"><span data-stu-id="b21d2-622">A <see cref="T:System.Nullable`1" /> of <see cref="T:System.Decimal" /> that contains the content of this <see cref="T:System.Xml.Linq.XElement" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[
  
## Examples  
 <span data-ttu-id="b21d2-623">下面的示例创建一个包含 decimal 内容的元素。</span><span class="sxs-lookup"><span data-stu-id="b21d2-623">The following example creates an element with decimal content.</span></span> <span data-ttu-id="b21d2-624">然后，它通过强制转换为来检索值 <xref:System.Nullable%601> <xref:System.Decimal> 。</span><span class="sxs-lookup"><span data-stu-id="b21d2-624">It then retrieves the value by casting to <xref:System.Nullable%601> of <xref:System.Decimal>.</span></span>  
  
```csharp  
XElement root = new XElement("Root",  
    new XElement("Value", "79228162514264337593543950335")  
);  
decimal? value = (decimal?)root.Element("Value");  
Console.WriteLine("Nullable decimal: value={0}", value == null ? "null" : value.ToString());  
```  
  
```vb  
Dim root As XElement = _   
    <Root>  
        <Value>79228162514264337593543950335</Value>  
    </Root>  
Dim value As Nullable(Of Decimal) = CType(root.Element("Value"), Nullable(Of Decimal))  
Console.WriteLine("Nullable decimal: value={0}", IIf(value.HasValue, value.ToString(), "null"))  
```  
  
 <span data-ttu-id="b21d2-625">该示例产生下面的输出：</span><span class="sxs-lookup"><span data-stu-id="b21d2-625">This example produces the following output:</span></span>  
  
```  
Nullable decimal: value=79228162514264337593543950335  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException"><span data-ttu-id="b21d2-626">元素不是 <see langword="null" /> 且不包含有效的 <see cref="T:System.Decimal" /> 值。</span><span class="sxs-lookup"><span data-stu-id="b21d2-626">The element is not <see langword="null" /> and does not contain a valid <see cref="T:System.Decimal" /> value.</span></span></exception>
        <related type="Article" href="/dotnet/standard/linq/linq-xml-overview"><span data-ttu-id="b21d2-627">LINQ to XML 概述</span><span class="sxs-lookup"><span data-stu-id="b21d2-627">LINQ to XML overview</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator double? (System.Xml.Linq.XElement element);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Nullable`1&lt;float64&gt; op_Explicit(class System.Xml.Linq.XElement element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Nullable{System.Double}" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (element As XElement) As Nullable(Of Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator Nullable&lt;double&gt;(System::Xml::Linq::XElement ^ element);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : System.Xml.Linq.XElement -&gt; Nullable&lt;double&gt;" Usage="System.Xml.Linq.XElement.op_Explicit element" />
      <MemberSignature Language="C#" Value="public static explicit operator double? (System.Xml.Linq.XElement? element);" FrameworkAlternate="net-5.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Double&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Xml.Linq.XElement" />
      </Parameters>
      <Docs>
        <param name="element"><span data-ttu-id="b21d2-628">要强制转换为 <see cref="T:System.Double" /> 的 <see cref="T:System.Nullable`1" /> 的 <see cref="T:System.Xml.Linq.XElement" />。</span><span class="sxs-lookup"><span data-stu-id="b21d2-628">The <see cref="T:System.Xml.Linq.XElement" /> to cast to <see cref="T:System.Nullable`1" /> of <see cref="T:System.Double" />.</span></span></param>
        <summary><span data-ttu-id="b21d2-629">将此 <see cref="T:System.Xml.Linq.XElement" /> 的值强制转换为 <see cref="T:System.Double" /> 的 <see cref="T:System.Nullable`1" />。</span><span class="sxs-lookup"><span data-stu-id="b21d2-629">Cast the value of this <see cref="T:System.Xml.Linq.XElement" /> to a <see cref="T:System.Nullable`1" /> of <see cref="T:System.Double" />.</span></span></summary>
        <returns><span data-ttu-id="b21d2-630">一个 <see cref="T:System.Double" /> 的 <see cref="T:System.Nullable`1" />，其中包含此 <see cref="T:System.Xml.Linq.XElement" /> 的内容。</span><span class="sxs-lookup"><span data-stu-id="b21d2-630">A <see cref="T:System.Nullable`1" /> of <see cref="T:System.Double" /> that contains the content of this <see cref="T:System.Xml.Linq.XElement" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Examples  
 <span data-ttu-id="b21d2-631">下面的示例创建一个具有双精度浮点数内容的元素。</span><span class="sxs-lookup"><span data-stu-id="b21d2-631">The following example creates an element with double precision floating point content.</span></span> <span data-ttu-id="b21d2-632">然后，它通过强制转换为来检索值 <xref:System.Nullable%601> <xref:System.Double> 。</span><span class="sxs-lookup"><span data-stu-id="b21d2-632">It then retrieves the value by casting to <xref:System.Nullable%601> of <xref:System.Double>.</span></span>  
  
```csharp  
XElement root = new XElement("Root",  
    new XElement("Value", 1.79769313486231e308)  
);  
double? value = (double?)root.Element("Value");  
Console.WriteLine("Nullable double: value={0}", value == null ? "null" : value.ToString());  
```  
  
```vb  
Dim root As XElement = _  
        <Root>  
            <Value>1.79769313486231e308</Value>  
        </Root>  
  
Dim value As Nullable(Of Double) = CType(root.Element("Value"), Nullable(Of Double))  
Console.WriteLine("Nullable double: value={0}", IIf(value.HasValue, value.ToString(), "null"))  
```  
  
 <span data-ttu-id="b21d2-633">该示例产生下面的输出：</span><span class="sxs-lookup"><span data-stu-id="b21d2-633">This example produces the following output:</span></span>  
  
```  
Nullable double: value=1.79769313486231E+308  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException"><span data-ttu-id="b21d2-634">元素不是 <see langword="null" /> 且不包含有效的 <see cref="T:System.Double" /> 值。</span><span class="sxs-lookup"><span data-stu-id="b21d2-634">The element is not <see langword="null" /> and does not contain a valid <see cref="T:System.Double" /> value.</span></span></exception>
        <related type="Article" href="/dotnet/standard/linq/linq-xml-overview"><span data-ttu-id="b21d2-635">LINQ to XML 概述</span><span class="sxs-lookup"><span data-stu-id="b21d2-635">LINQ to XML overview</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator Guid? (System.Xml.Linq.XElement element);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Nullable`1&lt;valuetype System.Guid&gt; op_Explicit(class System.Xml.Linq.XElement element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Nullable{System.Guid}" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (element As XElement) As Nullable(Of Guid)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator Nullable&lt;Guid&gt;(System::Xml::Linq::XElement ^ element);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : System.Xml.Linq.XElement -&gt; Nullable&lt;Guid&gt;" Usage="System.Xml.Linq.XElement.op_Explicit element" />
      <MemberSignature Language="C#" Value="public static explicit operator Guid? (System.Xml.Linq.XElement? element);" FrameworkAlternate="net-5.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Guid&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Xml.Linq.XElement" />
      </Parameters>
      <Docs>
        <param name="element"><span data-ttu-id="b21d2-636">要强制转换为 <see cref="T:System.Guid" /> 的 <see cref="T:System.Nullable`1" /> 的 <see cref="T:System.Xml.Linq.XElement" />。</span><span class="sxs-lookup"><span data-stu-id="b21d2-636">The <see cref="T:System.Xml.Linq.XElement" /> to cast to <see cref="T:System.Nullable`1" /> of <see cref="T:System.Guid" />.</span></span></param>
        <summary><span data-ttu-id="b21d2-637">将此 <see cref="T:System.Xml.Linq.XElement" /> 的值强制转换为 <see cref="T:System.Guid" /> 的 <see cref="T:System.Nullable`1" />。</span><span class="sxs-lookup"><span data-stu-id="b21d2-637">Cast the value of this <see cref="T:System.Xml.Linq.XElement" /> to a <see cref="T:System.Nullable`1" /> of <see cref="T:System.Guid" />.</span></span></summary>
        <returns><span data-ttu-id="b21d2-638">一个 <see cref="T:System.Guid" /> 的 <see cref="T:System.Nullable`1" />，其中包含此 <see cref="T:System.Xml.Linq.XElement" /> 的内容。</span><span class="sxs-lookup"><span data-stu-id="b21d2-638">A <see cref="T:System.Nullable`1" /> of <see cref="T:System.Guid" /> that contains the content of this <see cref="T:System.Xml.Linq.XElement" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Examples  
 <span data-ttu-id="b21d2-639">下面的示例创建一个具有 guid 内容的元素。</span><span class="sxs-lookup"><span data-stu-id="b21d2-639">The following example creates an element with guid content.</span></span> <span data-ttu-id="b21d2-640">然后，它通过强制转换为来检索值 <xref:System.Nullable%601> <xref:System.Guid> 。</span><span class="sxs-lookup"><span data-stu-id="b21d2-640">It then retrieves the value by casting to <xref:System.Nullable%601> of <xref:System.Guid>.</span></span>  
  
```csharp  
XElement root = new XElement("Root",  
    new XElement("Value", new Guid("3c1cc55b-baff-4b7a-9d17-077af3aa5730"))  
);  
Guid? value = (Guid?)root.Element("Value");  
Console.WriteLine("Nullable Guid: value={0}", value == null ? "null" : value.ToString());  
```  
  
```vb  
Dim root As XElement = _   
    <Root>  
        <Value><%= New Guid("3c1cc55b-baff-4b7a-9d17-077af3aa5730") %></Value>  
    </Root>  
Dim value As Nullable(Of Guid) = CType(root.Element("Value"), Nullable(Of Guid))  
Console.WriteLine("Nullable Guid: value={0}", IIf(value.HasValue, value.ToString(), "null"))  
```  
  
 <span data-ttu-id="b21d2-641">该示例产生下面的输出：</span><span class="sxs-lookup"><span data-stu-id="b21d2-641">This example produces the following output:</span></span>  
  
```  
Nullable Guid: value=3c1cc55b-baff-4b7a-9d17-077af3aa5730  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException"><span data-ttu-id="b21d2-642">元素不是 <see langword="null" /> 且不包含有效的 <see cref="T:System.Guid" /> 值。</span><span class="sxs-lookup"><span data-stu-id="b21d2-642">The element is not <see langword="null" /> and does not contain a valid <see cref="T:System.Guid" /> value.</span></span></exception>
        <related type="Article" href="/dotnet/standard/linq/linq-xml-overview"><span data-ttu-id="b21d2-643">LINQ to XML 概述</span><span class="sxs-lookup"><span data-stu-id="b21d2-643">LINQ to XML overview</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator int? (System.Xml.Linq.XElement element);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Nullable`1&lt;int32&gt; op_Explicit(class System.Xml.Linq.XElement element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Nullable{System.Int32}" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (element As XElement) As Nullable(Of Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator Nullable&lt;int&gt;(System::Xml::Linq::XElement ^ element);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : System.Xml.Linq.XElement -&gt; Nullable&lt;int&gt;" Usage="System.Xml.Linq.XElement.op_Explicit element" />
      <MemberSignature Language="C#" Value="public static explicit operator int? (System.Xml.Linq.XElement? element);" FrameworkAlternate="net-5.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Xml.Linq.XElement" />
      </Parameters>
      <Docs>
        <param name="element"><span data-ttu-id="b21d2-644">要强制转换为 <see cref="T:System.Int32" /> 的 <see cref="T:System.Nullable`1" /> 的 <see cref="T:System.Xml.Linq.XElement" />。</span><span class="sxs-lookup"><span data-stu-id="b21d2-644">The <see cref="T:System.Xml.Linq.XElement" /> to cast to <see cref="T:System.Nullable`1" /> of <see cref="T:System.Int32" />.</span></span></param>
        <summary><span data-ttu-id="b21d2-645">将此 <see cref="T:System.Xml.Linq.XElement" /> 的值强制转换为 <see cref="T:System.Int32" /> 的 <see cref="T:System.Nullable`1" />。</span><span class="sxs-lookup"><span data-stu-id="b21d2-645">Cast the value of this <see cref="T:System.Xml.Linq.XElement" /> to a <see cref="T:System.Nullable`1" /> of <see cref="T:System.Int32" />.</span></span></summary>
        <returns><span data-ttu-id="b21d2-646">一个 <see cref="T:System.Int32" /> 的 <see cref="T:System.Nullable`1" />，其中包含此 <see cref="T:System.Xml.Linq.XElement" /> 的内容。</span><span class="sxs-lookup"><span data-stu-id="b21d2-646">A <see cref="T:System.Nullable`1" /> of <see cref="T:System.Int32" /> that contains the content of this <see cref="T:System.Xml.Linq.XElement" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Examples  
 <span data-ttu-id="b21d2-647">下面的示例创建一个具有无符号整数内容的元素。</span><span class="sxs-lookup"><span data-stu-id="b21d2-647">The following example creates an element with unsigned integer content.</span></span> <span data-ttu-id="b21d2-648">然后，它通过强制转换为来检索值 <xref:System.Nullable%601> <xref:System.Int32> 。</span><span class="sxs-lookup"><span data-stu-id="b21d2-648">It then retrieves the value by casting to <xref:System.Nullable%601> of <xref:System.Int32>.</span></span>  
  
```csharp  
XElement root = new XElement("Root",   
    new XElement("Value", 2147483647)  
);  
int? value = (int?)root.Element("Value");  
Console.WriteLine("Nullable integer: value={0}", value == null ? "null" : value.ToString());  
```  
  
```vb  
Dim root As XElement = _   
        <Root>  
            <Value>2147483647</Value>  
        </Root>  
Dim value As Nullable(Of Integer) = CType(root.Element("Value"), Nullable(Of Integer))  
Console.WriteLine("Nullable integer: value={0}", IIf(value.HasValue, value.ToString(), "null"))  
  
```  
  
 <span data-ttu-id="b21d2-649">该示例产生下面的输出：</span><span class="sxs-lookup"><span data-stu-id="b21d2-649">This example produces the following output:</span></span>  
  
```  
Nullable integer: value=2147483647  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException"><span data-ttu-id="b21d2-650">元素不是 <see langword="null" /> 且不包含有效的 <see cref="T:System.Int32" /> 值。</span><span class="sxs-lookup"><span data-stu-id="b21d2-650">The element is not <see langword="null" /> and does not contain a valid <see cref="T:System.Int32" /> value.</span></span></exception>
        <related type="Article" href="/dotnet/standard/linq/linq-xml-overview"><span data-ttu-id="b21d2-651">LINQ to XML 概述</span><span class="sxs-lookup"><span data-stu-id="b21d2-651">LINQ to XML overview</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator long? (System.Xml.Linq.XElement element);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Nullable`1&lt;int64&gt; op_Explicit(class System.Xml.Linq.XElement element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Nullable{System.Int64}" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (element As XElement) As Nullable(Of Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator Nullable&lt;long&gt;(System::Xml::Linq::XElement ^ element);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : System.Xml.Linq.XElement -&gt; Nullable&lt;int64&gt;" Usage="System.Xml.Linq.XElement.op_Explicit element" />
      <MemberSignature Language="C#" Value="public static explicit operator long? (System.Xml.Linq.XElement? element);" FrameworkAlternate="net-5.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Int64&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Xml.Linq.XElement" />
      </Parameters>
      <Docs>
        <param name="element"><span data-ttu-id="b21d2-652">要强制转换为 <see cref="T:System.Int64" /> 的 <see cref="T:System.Nullable`1" /> 的 <see cref="T:System.Xml.Linq.XElement" />。</span><span class="sxs-lookup"><span data-stu-id="b21d2-652">The <see cref="T:System.Xml.Linq.XElement" /> to cast to <see cref="T:System.Nullable`1" /> of <see cref="T:System.Int64" />.</span></span></param>
        <summary><span data-ttu-id="b21d2-653">将此 <see cref="T:System.Xml.Linq.XElement" /> 的值强制转换为 <see cref="T:System.Int64" /> 的 <see cref="T:System.Nullable`1" />。</span><span class="sxs-lookup"><span data-stu-id="b21d2-653">Cast the value of this <see cref="T:System.Xml.Linq.XElement" /> to a <see cref="T:System.Nullable`1" /> of <see cref="T:System.Int64" />.</span></span></summary>
        <returns><span data-ttu-id="b21d2-654">一个 <see cref="T:System.Int64" /> 的 <see cref="T:System.Nullable`1" />，其中包含此 <see cref="T:System.Xml.Linq.XElement" /> 的内容。</span><span class="sxs-lookup"><span data-stu-id="b21d2-654">A <see cref="T:System.Nullable`1" /> of <see cref="T:System.Int64" /> that contains the content of this <see cref="T:System.Xml.Linq.XElement" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Examples  
 <span data-ttu-id="b21d2-655">下面的示例创建一个具有长整数内容的元素。</span><span class="sxs-lookup"><span data-stu-id="b21d2-655">The following example creates an element with long integer content.</span></span> <span data-ttu-id="b21d2-656">然后，它通过强制转换为来检索值 <xref:System.Nullable%601> <xref:System.Int64> 。</span><span class="sxs-lookup"><span data-stu-id="b21d2-656">It then retrieves the value by casting to <xref:System.Nullable%601> of <xref:System.Int64>.</span></span>  
  
```csharp  
XElement root = new XElement("Root",    
    new XElement("Value", 9223372036854775807)  
);  
ulong? value = (ulong?)root.Element("Value");  
Console.WriteLine("Nullable ulong: value={0}", value == null ? "null" : value.ToString());  
```  
  
```vb  
Dim root As XElement = _   
        <Root>  
            <Value>9223372036854775807</Value>  
        </Root>  
Dim value As Nullable(Of ULong) = CType(root.Element("Value"), Nullable(Of ULong))  
Console.WriteLine("Nullable ulong: value={0}", IIf(value.HasValue, value.ToString(), "null"))  
```  
  
 <span data-ttu-id="b21d2-657">该示例产生下面的输出：</span><span class="sxs-lookup"><span data-stu-id="b21d2-657">This example produces the following output:</span></span>  
  
```  
Nullable ulong: value=9223372036854775807  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException"><span data-ttu-id="b21d2-658">元素不是 <see langword="null" /> 且不包含有效的 <see cref="T:System.Int64" /> 值。</span><span class="sxs-lookup"><span data-stu-id="b21d2-658">The element is not <see langword="null" /> and does not contain a valid <see cref="T:System.Int64" /> value.</span></span></exception>
        <related type="Article" href="/dotnet/standard/linq/linq-xml-overview"><span data-ttu-id="b21d2-659">LINQ to XML 概述</span><span class="sxs-lookup"><span data-stu-id="b21d2-659">LINQ to XML overview</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator float? (System.Xml.Linq.XElement element);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Nullable`1&lt;float32&gt; op_Explicit(class System.Xml.Linq.XElement element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Nullable{System.Single}" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (element As XElement) As Nullable(Of Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator Nullable&lt;float&gt;(System::Xml::Linq::XElement ^ element);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : System.Xml.Linq.XElement -&gt; Nullable&lt;single&gt;" Usage="System.Xml.Linq.XElement.op_Explicit element" />
      <MemberSignature Language="C#" Value="public static explicit operator float? (System.Xml.Linq.XElement? element);" FrameworkAlternate="net-5.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Single&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Xml.Linq.XElement" />
      </Parameters>
      <Docs>
        <param name="element"><span data-ttu-id="b21d2-660">要强制转换为 <see cref="T:System.Single" /> 的 <see cref="T:System.Nullable`1" /> 的 <see cref="T:System.Xml.Linq.XElement" />。</span><span class="sxs-lookup"><span data-stu-id="b21d2-660">The <see cref="T:System.Xml.Linq.XElement" /> to cast to <see cref="T:System.Nullable`1" /> of <see cref="T:System.Single" />.</span></span></param>
        <summary><span data-ttu-id="b21d2-661">将此 <see cref="T:System.Xml.Linq.XElement" /> 的值强制转换为 <see cref="T:System.Single" /> 的 <see cref="T:System.Nullable`1" />。</span><span class="sxs-lookup"><span data-stu-id="b21d2-661">Cast the value of this <see cref="T:System.Xml.Linq.XElement" /> to a <see cref="T:System.Nullable`1" /> of <see cref="T:System.Single" />.</span></span></summary>
        <returns><span data-ttu-id="b21d2-662">一个 <see cref="T:System.Single" /> 的 <see cref="T:System.Nullable`1" />，其中包含此 <see cref="T:System.Xml.Linq.XElement" /> 的内容。</span><span class="sxs-lookup"><span data-stu-id="b21d2-662">A <see cref="T:System.Nullable`1" /> of <see cref="T:System.Single" /> that contains the content of this <see cref="T:System.Xml.Linq.XElement" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Examples  
 <span data-ttu-id="b21d2-663">下面的示例创建一个具有单精度浮点数内容的元素。</span><span class="sxs-lookup"><span data-stu-id="b21d2-663">The following example creates an element with single precision floating point content.</span></span> <span data-ttu-id="b21d2-664">然后，它通过强制转换为来检索值 <xref:System.Nullable%601> <xref:System.Single> 。</span><span class="sxs-lookup"><span data-stu-id="b21d2-664">It then retrieves the value by casting to <xref:System.Nullable%601> of <xref:System.Single>.</span></span>  
  
```csharp  
XElement root = new XElement("Root",   
    new XElement("Value", 3.402823e38)  
);  
float? value = (float?)root.Element("Value");  
Console.WriteLine("Nullable Single: value={0}", value == null ? "null" : value.ToString());  
```  
  
```vb  
Dim root As XElement = _   
        <Root>  
            <Value>3.402823e38</Value>  
        </Root>  
Dim value As Nullable(Of Single) = CType(root.Element("Value"), Nullable(Of Single))  
Console.WriteLine("Nullable Single: value={0}", IIf(value.HasValue, value.ToString(), "null"))  
```  
  
 <span data-ttu-id="b21d2-665">该示例产生下面的输出：</span><span class="sxs-lookup"><span data-stu-id="b21d2-665">This example produces the following output:</span></span>  
  
```  
Nullable Single: value=3.402823E+38  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException"><span data-ttu-id="b21d2-666">元素不是 <see langword="null" /> 且不包含有效的 <see cref="T:System.Single" /> 值。</span><span class="sxs-lookup"><span data-stu-id="b21d2-666">The element is not <see langword="null" /> and does not contain a valid <see cref="T:System.Single" /> value.</span></span></exception>
        <related type="Article" href="/dotnet/standard/linq/linq-xml-overview"><span data-ttu-id="b21d2-667">LINQ to XML 概述</span><span class="sxs-lookup"><span data-stu-id="b21d2-667">LINQ to XML overview</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator TimeSpan? (System.Xml.Linq.XElement element);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Nullable`1&lt;valuetype System.TimeSpan&gt; op_Explicit(class System.Xml.Linq.XElement element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Nullable{System.TimeSpan}" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (element As XElement) As Nullable(Of TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator Nullable&lt;TimeSpan&gt;(System::Xml::Linq::XElement ^ element);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : System.Xml.Linq.XElement -&gt; Nullable&lt;TimeSpan&gt;" Usage="System.Xml.Linq.XElement.op_Explicit element" />
      <MemberSignature Language="C#" Value="public static explicit operator TimeSpan? (System.Xml.Linq.XElement? element);" FrameworkAlternate="net-5.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.TimeSpan&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Xml.Linq.XElement" />
      </Parameters>
      <Docs>
        <param name="element"><span data-ttu-id="b21d2-668">要强制转换为 <see cref="T:System.TimeSpan" /> 的 <see cref="T:System.Nullable`1" /> 的 <see cref="T:System.Xml.Linq.XElement" />。</span><span class="sxs-lookup"><span data-stu-id="b21d2-668">The <see cref="T:System.Xml.Linq.XElement" /> to cast to <see cref="T:System.Nullable`1" /> of <see cref="T:System.TimeSpan" />.</span></span></param>
        <summary><span data-ttu-id="b21d2-669">将此 <see cref="T:System.Xml.Linq.XElement" /> 的值强制转换为 <see cref="T:System.TimeSpan" /> 的 <see cref="T:System.Nullable`1" />。</span><span class="sxs-lookup"><span data-stu-id="b21d2-669">Cast the value of this <see cref="T:System.Xml.Linq.XElement" /> to a <see cref="T:System.Nullable`1" /> of <see cref="T:System.TimeSpan" />.</span></span></summary>
        <returns><span data-ttu-id="b21d2-670">一个 <see cref="T:System.TimeSpan" /> 的 <see cref="T:System.Nullable`1" />，其中包含此 <see cref="T:System.Xml.Linq.XElement" /> 的内容。</span><span class="sxs-lookup"><span data-stu-id="b21d2-670">A <see cref="T:System.Nullable`1" /> of <see cref="T:System.TimeSpan" /> that contains the content of this <see cref="T:System.Xml.Linq.XElement" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b21d2-671">包含时间跨度内容的属性或元素的值空间与持续时间内容密切相关，如 ISO 8601 中所述。</span><span class="sxs-lookup"><span data-stu-id="b21d2-671">The value space of an attribute or element that contains time span content is closely related to duration content as described in ISO 8601.</span></span> <span data-ttu-id="b21d2-672">在创建包含时间跨度内容的属性或元素时，将根据 W3C 规范设置属性或元素值的格式。</span><span class="sxs-lookup"><span data-stu-id="b21d2-672">When creating an attribute or element that contains time span content, the attribute or element values are formatted per the W3C specification.</span></span> <span data-ttu-id="b21d2-673">有关更多详细信息，请参阅 W3C 规范。</span><span class="sxs-lookup"><span data-stu-id="b21d2-673">Please see the W3C specification for more details.</span></span>  
  
 <span data-ttu-id="b21d2-674"><xref:System.Nullable%601>从特性或元素强制转换到的时，行为是不严格的 <xref:System.TimeSpan> 。</span><span class="sxs-lookup"><span data-stu-id="b21d2-674">Behavior is lax when casting to a <xref:System.Nullable%601> of <xref:System.TimeSpan> from an attribute or element.</span></span> <span data-ttu-id="b21d2-675">即使属性或元素值的格式设置与 W3C 规范的格式完全相同，此值也会相应地转换为 <xref:System.Nullable%601> 的 <xref:System.TimeSpan> 。</span><span class="sxs-lookup"><span data-stu-id="b21d2-675">Even if the attribute or element value is not formatted exactly per the W3C specification, the value is appropriately converted to a <xref:System.Nullable%601> of <xref:System.TimeSpan>.</span></span>
  
## Examples  
 <span data-ttu-id="b21d2-676">下面的示例创建一个具有时间跨度内容的元素。</span><span class="sxs-lookup"><span data-stu-id="b21d2-676">The following example creates an element with time span content.</span></span> <span data-ttu-id="b21d2-677">然后，它通过强制转换为来检索值 <xref:System.Nullable%601> <xref:System.TimeSpan> 。</span><span class="sxs-lookup"><span data-stu-id="b21d2-677">It then retrieves the value by casting to <xref:System.Nullable%601> of <xref:System.TimeSpan>.</span></span>  
  
```csharp  
XElement root = new XElement("Root",  
    new XElement("Value", new TimeSpan(1, 5, 30))  
);  
TimeSpan? value = (TimeSpan?)root.Element("Value");  
Console.WriteLine("Nullable TimeSpan: value={0}", value == null ? "null" : value.ToString());  
```  
  
```vb  
Dim root As XElement = _  
    <Root>  
        <Value><%= New TimeSpan(1, 5, 30) %></Value>  
    </Root>  
Dim value As Nullable(Of TimeSpan) = CType(root.Element("Value"), Nullable(Of TimeSpan))  
Console.WriteLine("Nullable TimeSpan: value={0}", IIf(value.HasValue, value.ToString(), "null"))  
```  
  
 <span data-ttu-id="b21d2-678">该示例产生下面的输出：</span><span class="sxs-lookup"><span data-stu-id="b21d2-678">This example produces the following output:</span></span>  
  
```  
Nullable TimeSpan: value=01:05:30  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException"><span data-ttu-id="b21d2-679">元素不是 <see langword="null" /> 且不包含有效的 <see cref="T:System.TimeSpan" /> 值。</span><span class="sxs-lookup"><span data-stu-id="b21d2-679">The element is not <see langword="null" /> and does not contain a valid <see cref="T:System.TimeSpan" /> value.</span></span></exception>
        <related type="Article" href="/dotnet/standard/linq/linq-xml-overview"><span data-ttu-id="b21d2-680">LINQ to XML 概述</span><span class="sxs-lookup"><span data-stu-id="b21d2-680">LINQ to XML overview</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator uint? (System.Xml.Linq.XElement element);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Nullable`1&lt;unsigned int32&gt; op_Explicit(class System.Xml.Linq.XElement element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Nullable{System.UInt32}" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (element As XElement) As Nullable(Of UInteger)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator Nullable&lt;System::UInt32&gt;(System::Xml::Linq::XElement ^ element);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : System.Xml.Linq.XElement -&gt; Nullable&lt;uint32&gt;" Usage="System.Xml.Linq.XElement.op_Explicit element" />
      <MemberSignature Language="C#" Value="public static explicit operator uint? (System.Xml.Linq.XElement? element);" FrameworkAlternate="net-5.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.UInt32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Xml.Linq.XElement" />
      </Parameters>
      <Docs>
        <param name="element"><span data-ttu-id="b21d2-681">要强制转换为 <see cref="T:System.UInt32" /> 的 <see cref="T:System.Nullable`1" /> 的 <see cref="T:System.Xml.Linq.XElement" />。</span><span class="sxs-lookup"><span data-stu-id="b21d2-681">The <see cref="T:System.Xml.Linq.XElement" /> to cast to <see cref="T:System.Nullable`1" /> of <see cref="T:System.UInt32" />.</span></span></param>
        <summary><span data-ttu-id="b21d2-682">将此 <see cref="T:System.Xml.Linq.XElement" /> 的值强制转换为 <see cref="T:System.UInt32" /> 的 <see cref="T:System.Nullable`1" />。</span><span class="sxs-lookup"><span data-stu-id="b21d2-682">Cast the value of this <see cref="T:System.Xml.Linq.XElement" /> to a <see cref="T:System.Nullable`1" /> of <see cref="T:System.UInt32" />.</span></span></summary>
        <returns><span data-ttu-id="b21d2-683">一个 <see cref="T:System.UInt32" /> 的 <see cref="T:System.Nullable`1" />，其中包含此 <see cref="T:System.Xml.Linq.XElement" /> 的内容。</span><span class="sxs-lookup"><span data-stu-id="b21d2-683">A <see cref="T:System.Nullable`1" /> of <see cref="T:System.UInt32" /> that contains the content of this <see cref="T:System.Xml.Linq.XElement" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Examples  
 <span data-ttu-id="b21d2-684">下面的示例创建一个具有无符号整数内容的元素。</span><span class="sxs-lookup"><span data-stu-id="b21d2-684">The following example creates an element with unsigned integer content.</span></span> <span data-ttu-id="b21d2-685">然后，它通过强制转换为来检索值 <xref:System.Nullable%601> <xref:System.UInt32> 。</span><span class="sxs-lookup"><span data-stu-id="b21d2-685">It then retrieves the value by casting to <xref:System.Nullable%601> of <xref:System.UInt32>.</span></span>  
  
```csharp  
XElement root = new XElement("Root",   
    new XElement("Value", 4294967295)  
);  
uint? value = (uint?)root.Element("Value");  
Console.WriteLine("Nullable uint: value={0}", value == null ? "null" : value.ToString());  
```  
  
```vb  
Dim root As XElement = _   
        <Root>  
            <Value>4294967295</Value>  
        </Root>  
Dim value As Nullable(Of UInteger) = CType(root.Element("Value"), Nullable(Of UInteger))  
Console.WriteLine("Nullable uint: value={0}", IIf(value.HasValue, value.ToString(), "null"))  
```  
  
 <span data-ttu-id="b21d2-686">该示例产生下面的输出：</span><span class="sxs-lookup"><span data-stu-id="b21d2-686">This example produces the following output:</span></span>  
  
```  
Nullable uint: value=4294967295  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException"><span data-ttu-id="b21d2-687">元素不是 <see langword="null" /> 且不包含有效的 <see cref="T:System.UInt32" /> 值。</span><span class="sxs-lookup"><span data-stu-id="b21d2-687">The element is not <see langword="null" /> and does not contain a valid <see cref="T:System.UInt32" /> value.</span></span></exception>
        <related type="Article" href="/dotnet/standard/linq/linq-xml-overview"><span data-ttu-id="b21d2-688">LINQ to XML 概述</span><span class="sxs-lookup"><span data-stu-id="b21d2-688">LINQ to XML overview</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator ulong? (System.Xml.Linq.XElement element);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Nullable`1&lt;unsigned int64&gt; op_Explicit(class System.Xml.Linq.XElement element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Nullable{System.UInt64}" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (element As XElement) As Nullable(Of ULong)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator Nullable&lt;System::UInt64&gt;(System::Xml::Linq::XElement ^ element);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : System.Xml.Linq.XElement -&gt; Nullable&lt;uint64&gt;" Usage="System.Xml.Linq.XElement.op_Explicit element" />
      <MemberSignature Language="C#" Value="public static explicit operator ulong? (System.Xml.Linq.XElement? element);" FrameworkAlternate="net-5.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.UInt64&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Xml.Linq.XElement" />
      </Parameters>
      <Docs>
        <param name="element"><span data-ttu-id="b21d2-689">要强制转换为 <see cref="T:System.UInt64" /> 的 <see cref="T:System.Nullable`1" /> 的 <see cref="T:System.Xml.Linq.XElement" />。</span><span class="sxs-lookup"><span data-stu-id="b21d2-689">The <see cref="T:System.Xml.Linq.XElement" /> to cast to <see cref="T:System.Nullable`1" /> of <see cref="T:System.UInt64" />.</span></span></param>
        <summary><span data-ttu-id="b21d2-690">将此 <see cref="T:System.Xml.Linq.XElement" /> 的值强制转换为 <see cref="T:System.UInt64" /> 的 <see cref="T:System.Nullable`1" />。</span><span class="sxs-lookup"><span data-stu-id="b21d2-690">Cast the value of this <see cref="T:System.Xml.Linq.XElement" /> to a <see cref="T:System.Nullable`1" /> of <see cref="T:System.UInt64" />.</span></span></summary>
        <returns><span data-ttu-id="b21d2-691">一个 <see cref="T:System.UInt64" /> 的 <see cref="T:System.Nullable`1" />，其中包含此 <see cref="T:System.Xml.Linq.XElement" /> 的内容。</span><span class="sxs-lookup"><span data-stu-id="b21d2-691">A <see cref="T:System.Nullable`1" /> of <see cref="T:System.UInt64" /> that contains the content of this <see cref="T:System.Xml.Linq.XElement" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Examples  
 <span data-ttu-id="b21d2-692">下面的示例创建一个元素，该元素具有无符号长整数内容。</span><span class="sxs-lookup"><span data-stu-id="b21d2-692">The following example creates an element with unsigned long integer content.</span></span> <span data-ttu-id="b21d2-693">然后，它通过强制转换为来检索值 <xref:System.Nullable%601> <xref:System.UInt64> 。</span><span class="sxs-lookup"><span data-stu-id="b21d2-693">It then retrieves the value by casting to <xref:System.Nullable%601> of <xref:System.UInt64>.</span></span>  
  
```csharp  
XElement root = new XElement("Root",   
    new XElement("Value", 9223372036854775807)  
);  
ulong? value = (ulong?)root.Element("Value");  
Console.WriteLine("Nullable ulong: value={0}", value == null ? "null" : value.ToString());  
```  
  
```vb  
Dim root As XElement = _   
        <Root>  
            <Value>9223372036854775807</Value>  
        </Root>  
  
Dim value As Nullable(Of ULong) = CType(root.Element("Value"), Nullable(Of ULong))  
Console.WriteLine("Nullable ulong: value={0}", IIf(value.HasValue, value.ToString(), "null"))  
```  
  
 <span data-ttu-id="b21d2-694">该示例产生下面的输出：</span><span class="sxs-lookup"><span data-stu-id="b21d2-694">This example produces the following output:</span></span>  
  
```  
Nullable ulong: value=9223372036854775807  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException"><span data-ttu-id="b21d2-695">元素不是 <see langword="null" /> 且不包含有效的 <see cref="T:System.UInt64" /> 值。</span><span class="sxs-lookup"><span data-stu-id="b21d2-695">The element is not <see langword="null" /> and does not contain a valid <see cref="T:System.UInt64" /> value.</span></span></exception>
        <related type="Article" href="/dotnet/standard/linq/linq-xml-overview"><span data-ttu-id="b21d2-696">LINQ to XML 概述</span><span class="sxs-lookup"><span data-stu-id="b21d2-696">LINQ to XML overview</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator float (System.Xml.Linq.XElement element);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname float32 op_Explicit(class System.Xml.Linq.XElement element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Single" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (element As XElement) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator float(System::Xml::Linq::XElement ^ element);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : System.Xml.Linq.XElement -&gt; single" Usage="System.Xml.Linq.XElement.op_Explicit element" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Xml.Linq.XElement" />
      </Parameters>
      <Docs>
        <param name="element"><span data-ttu-id="b21d2-697">要强制转换为 <see cref="T:System.Single" /> 的 <see cref="T:System.Xml.Linq.XElement" />。</span><span class="sxs-lookup"><span data-stu-id="b21d2-697">The <see cref="T:System.Xml.Linq.XElement" /> to cast to <see cref="T:System.Single" />.</span></span></param>
        <summary><span data-ttu-id="b21d2-698">将此 <see cref="T:System.Xml.Linq.XElement" /> 的值强制转换为 <see cref="T:System.Single" />。</span><span class="sxs-lookup"><span data-stu-id="b21d2-698">Cast the value of this <see cref="T:System.Xml.Linq.XElement" /> to a <see cref="T:System.Single" />.</span></span></summary>
        <returns><span data-ttu-id="b21d2-699">一个 <see cref="T:System.Single" />，其中包含此 <see cref="T:System.Xml.Linq.XElement" /> 的内容。</span><span class="sxs-lookup"><span data-stu-id="b21d2-699">A <see cref="T:System.Single" /> that contains the content of this <see cref="T:System.Xml.Linq.XElement" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[
  
## Examples  
 <span data-ttu-id="b21d2-700">下面的示例创建一个具有单精度浮点数内容的元素。</span><span class="sxs-lookup"><span data-stu-id="b21d2-700">The following example creates an element with single precision floating point content.</span></span> <span data-ttu-id="b21d2-701">然后，它通过强制转换为来检索值 <xref:System.Single> 。</span><span class="sxs-lookup"><span data-stu-id="b21d2-701">It then retrieves the value by casting to <xref:System.Single>.</span></span>  
  
```csharp  
XElement root = new XElement("Root", 3.402823e38);  
float value = (float)root;  
Console.WriteLine("value={0}", value);  
```  
  
```vb  
Dim root As XElement = <Root>3.402823E+38</Root>  
Dim value As Single = CSng(root)  
Console.WriteLine("value={0}", value)  
```  
  
 <span data-ttu-id="b21d2-702">该示例产生下面的输出：</span><span class="sxs-lookup"><span data-stu-id="b21d2-702">This example produces the following output:</span></span>  
  
```  
value=3.402823E+38  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException"><span data-ttu-id="b21d2-703">元素不包含有效的 <see cref="T:System.Single" /> 值。</span><span class="sxs-lookup"><span data-stu-id="b21d2-703">The element does not contain a valid <see cref="T:System.Single" /> value.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="b21d2-704"><paramref name="element" /> 参数为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="b21d2-704">The <paramref name="element" /> parameter is <see langword="null" />.</span></span></exception>
        <related type="Article" href="/dotnet/standard/linq/linq-xml-overview"><span data-ttu-id="b21d2-705">LINQ to XML 概述</span><span class="sxs-lookup"><span data-stu-id="b21d2-705">LINQ to XML overview</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator string (System.Xml.Linq.XElement element);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname string op_Explicit(class System.Xml.Linq.XElement element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.String" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (element As XElement) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::String ^(System::Xml::Linq::XElement ^ element);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : System.Xml.Linq.XElement -&gt; string" Usage="System.Xml.Linq.XElement.op_Explicit element" />
      <MemberSignature Language="C#" Value="public static explicit operator string? (System.Xml.Linq.XElement? element);" FrameworkAlternate="net-5.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Xml.Linq.XElement" />
      </Parameters>
      <Docs>
        <param name="element"><span data-ttu-id="b21d2-706">要强制转换为 <see cref="T:System.String" /> 的 <see cref="T:System.Xml.Linq.XElement" />。</span><span class="sxs-lookup"><span data-stu-id="b21d2-706">The <see cref="T:System.Xml.Linq.XElement" /> to cast to <see cref="T:System.String" />.</span></span></param>
        <summary><span data-ttu-id="b21d2-707">将此 <see cref="T:System.Xml.Linq.XElement" /> 的值强制转换为 <see cref="T:System.String" />。</span><span class="sxs-lookup"><span data-stu-id="b21d2-707">Cast the value of this <see cref="T:System.Xml.Linq.XElement" /> to a <see cref="T:System.String" />.</span></span></summary>
        <returns><span data-ttu-id="b21d2-708">一个 <see cref="T:System.String" />，其中包含此 <see cref="T:System.Xml.Linq.XElement" /> 的内容。</span><span class="sxs-lookup"><span data-stu-id="b21d2-708">A <see cref="T:System.String" /> that contains the content of this <see cref="T:System.Xml.Linq.XElement" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b21d2-709">如果 <xref:System.Xml.Linq.XElement> 有子级，则返回该元素的所有文本和子代文本的连接字符串值。</span><span class="sxs-lookup"><span data-stu-id="b21d2-709">If the <xref:System.Xml.Linq.XElement> has children, the concatenated string value of all of the element's text and descendant's text is returned.</span></span>  
  
## Examples  
 <span data-ttu-id="b21d2-710">下面的示例创建一个包含字符串内容的元素。</span><span class="sxs-lookup"><span data-stu-id="b21d2-710">The following example creates an element with string content.</span></span> <span data-ttu-id="b21d2-711">然后，它通过强制转换为来检索值 <xref:System.String> 。</span><span class="sxs-lookup"><span data-stu-id="b21d2-711">It then retrieves the value by casting to <xref:System.String>.</span></span>  
  
```csharp  
XElement root = XElement.Parse("<Root>abc <b>def </b>ghi</Root>");  
Console.WriteLine("(string)root={0}", (string)root);  
```  
  
```vb  
Dim root As XElement = <Root>abc <b>def </b>ghi</Root>  
Console.WriteLine("(string)root={0}", root.Value)  
```  
  
 <span data-ttu-id="b21d2-712">该示例产生下面的输出：</span><span class="sxs-lookup"><span data-stu-id="b21d2-712">This example produces the following output:</span></span>  
  
```  
(string)root=abc def ghi  
```  
  
 ]]></format>
        </remarks>
        <related type="Article" href="/dotnet/standard/linq/linq-xml-overview"><span data-ttu-id="b21d2-713">LINQ to XML 概述</span><span class="sxs-lookup"><span data-stu-id="b21d2-713">LINQ to XML overview</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator TimeSpan (System.Xml.Linq.XElement element);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.TimeSpan op_Explicit(class System.Xml.Linq.XElement element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.TimeSpan" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (element As XElement) As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator TimeSpan(System::Xml::Linq::XElement ^ element);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : System.Xml.Linq.XElement -&gt; TimeSpan" Usage="System.Xml.Linq.XElement.op_Explicit element" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Xml.Linq.XElement" />
      </Parameters>
      <Docs>
        <param name="element"><span data-ttu-id="b21d2-714">要强制转换为 <see cref="T:System.TimeSpan" /> 的 <see cref="T:System.Xml.Linq.XElement" />。</span><span class="sxs-lookup"><span data-stu-id="b21d2-714">The <see cref="T:System.Xml.Linq.XElement" /> to cast to <see cref="T:System.TimeSpan" />.</span></span></param>
        <summary><span data-ttu-id="b21d2-715">将此 <see cref="T:System.Xml.Linq.XElement" /> 的值强制转换为 <see cref="T:System.TimeSpan" />。</span><span class="sxs-lookup"><span data-stu-id="b21d2-715">Cast the value of this <see cref="T:System.Xml.Linq.XElement" /> to a <see cref="T:System.TimeSpan" />.</span></span></summary>
        <returns><span data-ttu-id="b21d2-716">一个 <see cref="T:System.TimeSpan" />，其中包含此 <see cref="T:System.Xml.Linq.XElement" /> 的内容。</span><span class="sxs-lookup"><span data-stu-id="b21d2-716">A <see cref="T:System.TimeSpan" /> that contains the content of this <see cref="T:System.Xml.Linq.XElement" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b21d2-717">包含时间跨度内容的属性或元素的值空间与持续时间内容密切相关，如 ISO 8601 中所述。</span><span class="sxs-lookup"><span data-stu-id="b21d2-717">The value space of an attribute or element that contains time span content is closely related to duration content as described in ISO 8601.</span></span> <span data-ttu-id="b21d2-718">在创建包含时间跨度内容的属性或元素时，将根据 W3C 规范设置属性或元素值的格式。</span><span class="sxs-lookup"><span data-stu-id="b21d2-718">When creating an attribute or element that contains time span content, the attribute or element values are formatted per the W3C specification.</span></span> <span data-ttu-id="b21d2-719">有关更多详细信息，请参阅 W3C 规范。</span><span class="sxs-lookup"><span data-stu-id="b21d2-719">Please see the W3C specification for more details.</span></span>  
  
 <span data-ttu-id="b21d2-720">从特性或元素强制转换为时，行为是不严格的 <xref:System.TimeSpan> 。</span><span class="sxs-lookup"><span data-stu-id="b21d2-720">Behavior is lax when casting to a <xref:System.TimeSpan> from an attribute or element.</span></span> <span data-ttu-id="b21d2-721">即使属性或元素值的格式设置与 W3C 规范的格式完全相同，此值也会相应地转换为 <xref:System.TimeSpan> 。</span><span class="sxs-lookup"><span data-stu-id="b21d2-721">Even if the attribute or element value is not formatted exactly per the W3C specification, the value is appropriately converted to a <xref:System.TimeSpan>.</span></span>
  
## Examples  
 <span data-ttu-id="b21d2-722">下面的示例创建一个具有时间跨度内容的元素。</span><span class="sxs-lookup"><span data-stu-id="b21d2-722">The following example creates an element with time span content.</span></span> <span data-ttu-id="b21d2-723">然后，它通过强制转换为来检索值 <xref:System.TimeSpan> 。</span><span class="sxs-lookup"><span data-stu-id="b21d2-723">It then retrieves the value by casting to <xref:System.TimeSpan>.</span></span>  
  
```csharp  
XElement root = new XElement("Root", new TimeSpan(1, 5, 30));  
TimeSpan value = (TimeSpan)root;  
Console.WriteLine("value={0}", value);  
```  
  
```vb  
Dim root As XElement = <Root><%= New TimeSpan(1, 5, 30) %></Root>  
Dim value As TimeSpan = CType(root, TimeSpan)  
Console.WriteLine("value={0}", value)  
```  
  
 <span data-ttu-id="b21d2-724">该示例产生下面的输出：</span><span class="sxs-lookup"><span data-stu-id="b21d2-724">This example produces the following output:</span></span>  
  
```  
value=01:05:30  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException"><span data-ttu-id="b21d2-725">元素不包含有效的 <see cref="T:System.TimeSpan" /> 值。</span><span class="sxs-lookup"><span data-stu-id="b21d2-725">The element does not contain a valid <see cref="T:System.TimeSpan" /> value.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="b21d2-726"><paramref name="element" /> 参数为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="b21d2-726">The <paramref name="element" /> parameter is <see langword="null" />.</span></span></exception>
        <related type="Article" href="/dotnet/standard/linq/linq-xml-overview"><span data-ttu-id="b21d2-727">LINQ to XML 概述</span><span class="sxs-lookup"><span data-stu-id="b21d2-727">LINQ to XML overview</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator uint (System.Xml.Linq.XElement element);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname unsigned int32 op_Explicit(class System.Xml.Linq.XElement element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.UInt32" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (element As XElement) As UInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::UInt32(System::Xml::Linq::XElement ^ element);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : System.Xml.Linq.XElement -&gt; uint32" Usage="System.Xml.Linq.XElement.op_Explicit element" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Xml.Linq.XElement" />
      </Parameters>
      <Docs>
        <param name="element"><span data-ttu-id="b21d2-728">要强制转换为 <see cref="T:System.UInt32" /> 的 <see cref="T:System.Xml.Linq.XElement" />。</span><span class="sxs-lookup"><span data-stu-id="b21d2-728">The <see cref="T:System.Xml.Linq.XElement" /> to cast to <see cref="T:System.UInt32" />.</span></span></param>
        <summary><span data-ttu-id="b21d2-729">将此 <see cref="T:System.Xml.Linq.XElement" /> 的值强制转换为 <see cref="T:System.UInt32" />。</span><span class="sxs-lookup"><span data-stu-id="b21d2-729">Cast the value of this <see cref="T:System.Xml.Linq.XElement" /> to a <see cref="T:System.UInt32" />.</span></span></summary>
        <returns><span data-ttu-id="b21d2-730">一个 <see cref="T:System.UInt32" />，其中包含此 <see cref="T:System.Xml.Linq.XElement" /> 的内容。</span><span class="sxs-lookup"><span data-stu-id="b21d2-730">A <see cref="T:System.UInt32" /> that contains the content of this <see cref="T:System.Xml.Linq.XElement" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Examples  
 <span data-ttu-id="b21d2-731">下面的示例创建一个具有无符号整数内容的元素。</span><span class="sxs-lookup"><span data-stu-id="b21d2-731">The following example creates an element with unsigned integer content.</span></span> <span data-ttu-id="b21d2-732">然后，它通过强制转换为来检索值 <xref:System.UInt32> 。</span><span class="sxs-lookup"><span data-stu-id="b21d2-732">It then retrieves the value by casting to <xref:System.UInt32>.</span></span>  
  
```csharp  
XElement root = new XElement("Root", 4294967295);  
uint value = (uint)root;  
Console.WriteLine("value={0}", value);  
```  
  
```vb  
Dim root As XElement = <Root>4294967295</Root>  
Dim value As UInteger = CUInt(root)  
Console.WriteLine("value={0}", value)  
```  
  
 <span data-ttu-id="b21d2-733">该示例产生下面的输出：</span><span class="sxs-lookup"><span data-stu-id="b21d2-733">This example produces the following output:</span></span>  
  
```  
value=4294967295  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException"><span data-ttu-id="b21d2-734">元素不包含有效的 <see cref="T:System.UInt32" /> 值。</span><span class="sxs-lookup"><span data-stu-id="b21d2-734">The element does not contain a valid <see cref="T:System.UInt32" /> value.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="b21d2-735"><paramref name="element" /> 参数为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="b21d2-735">The <paramref name="element" /> parameter is <see langword="null" />.</span></span></exception>
        <related type="Article" href="/dotnet/standard/linq/linq-xml-overview"><span data-ttu-id="b21d2-736">LINQ to XML 概述</span><span class="sxs-lookup"><span data-stu-id="b21d2-736">LINQ to XML overview</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator ulong (System.Xml.Linq.XElement element);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname unsigned int64 op_Explicit(class System.Xml.Linq.XElement element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.UInt64" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (element As XElement) As ULong" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::UInt64(System::Xml::Linq::XElement ^ element);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : System.Xml.Linq.XElement -&gt; uint64" Usage="System.Xml.Linq.XElement.op_Explicit element" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Xml.Linq.XElement" />
      </Parameters>
      <Docs>
        <param name="element"><span data-ttu-id="b21d2-737">要强制转换为 <see cref="T:System.UInt64" /> 的 <see cref="T:System.Xml.Linq.XElement" />。</span><span class="sxs-lookup"><span data-stu-id="b21d2-737">The <see cref="T:System.Xml.Linq.XElement" /> to cast to <see cref="T:System.UInt64" />.</span></span></param>
        <summary><span data-ttu-id="b21d2-738">将此 <see cref="T:System.Xml.Linq.XElement" /> 的值强制转换为 <see cref="T:System.UInt64" />。</span><span class="sxs-lookup"><span data-stu-id="b21d2-738">Cast the value of this <see cref="T:System.Xml.Linq.XElement" /> to a <see cref="T:System.UInt64" />.</span></span></summary>
        <returns><span data-ttu-id="b21d2-739">一个 <see cref="T:System.UInt64" />，其中包含此 <see cref="T:System.Xml.Linq.XElement" /> 的内容。</span><span class="sxs-lookup"><span data-stu-id="b21d2-739">A <see cref="T:System.UInt64" /> that contains the content of this <see cref="T:System.Xml.Linq.XElement" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[
  
## Examples  
 <span data-ttu-id="b21d2-740">下面的示例创建一个元素，该元素具有无符号长整数内容。</span><span class="sxs-lookup"><span data-stu-id="b21d2-740">The following example creates an element with unsigned long integer content.</span></span> <span data-ttu-id="b21d2-741">然后，它通过强制转换为来检索值 <xref:System.UInt64> 。</span><span class="sxs-lookup"><span data-stu-id="b21d2-741">It then retrieves the value by casting to <xref:System.UInt64>.</span></span>  
  
```csharp  
XElement root = new XElement("Root", 18446744073709551615);  
ulong value = (ulong)root;  
Console.WriteLine("value={0}", value);  
```  
  
```vb  
Dim root As XElement = <Root>18446744073709551615</Root>  
Dim value As ULong = CULng(root)  
Console.WriteLine("value={0}", value)  
```  
  
 <span data-ttu-id="b21d2-742">该示例产生下面的输出：</span><span class="sxs-lookup"><span data-stu-id="b21d2-742">This example produces the following output:</span></span>  
  
```  
value=18446744073709551615  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException"><span data-ttu-id="b21d2-743">元素不包含有效的 <see cref="T:System.UInt64" /> 值。</span><span class="sxs-lookup"><span data-stu-id="b21d2-743">The element does not contain a valid <see cref="T:System.UInt64" /> value.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="b21d2-744"><paramref name="element" /> 参数为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="b21d2-744">The <paramref name="element" /> parameter is <see langword="null" />.</span></span></exception>
        <related type="Article" href="/dotnet/standard/linq/linq-xml-overview"><span data-ttu-id="b21d2-745">LINQ to XML 概述</span><span class="sxs-lookup"><span data-stu-id="b21d2-745">LINQ to XML overview</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Parse">
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="b21d2-746">从包含 XML 的字符串加载 <see cref="T:System.Xml.Linq.XElement" />，还可以选择保留空白和行信息。</span><span class="sxs-lookup"><span data-stu-id="b21d2-746">Load an <see cref="T:System.Xml.Linq.XElement" /> from a string that contains XML, optionally preserving white space and retaining line information.</span></span></summary>
        <related type="Article" href="/dotnet/standard/linq/linq-xml-overview"><span data-ttu-id="b21d2-747">LINQ to XML 概述</span><span class="sxs-lookup"><span data-stu-id="b21d2-747">LINQ to XML overview</span></span></related>
      </Docs>
    </MemberGroup>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static System.Xml.Linq.XElement Parse (string text);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.Linq.XElement Parse(string text) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XElement.Parse(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (text As String) As XElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Xml::Linq::XElement ^ Parse(System::String ^ text);" />
      <MemberSignature Language="F#" Value="static member Parse : string -&gt; System.Xml.Linq.XElement" Usage="System.Xml.Linq.XElement.Parse text" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Xml.Linq.XElement</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="text" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="text"><span data-ttu-id="b21d2-748">一个包含 XML 的 <see cref="T:System.String" />。</span><span class="sxs-lookup"><span data-stu-id="b21d2-748">A <see cref="T:System.String" /> that contains XML.</span></span></param>
        <summary><span data-ttu-id="b21d2-749">从包含 XML 的字符串加载 <see cref="T:System.Xml.Linq.XElement" />。</span><span class="sxs-lookup"><span data-stu-id="b21d2-749">Load an <see cref="T:System.Xml.Linq.XElement" /> from a string that contains XML.</span></span></summary>
        <returns><span data-ttu-id="b21d2-750">一个使用包含 XML 的字符串填充的 <see cref="T:System.Xml.Linq.XElement" />。</span><span class="sxs-lookup"><span data-stu-id="b21d2-750">An <see cref="T:System.Xml.Linq.XElement" /> populated from the string that contains XML.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b21d2-751">此方法不保留空格。</span><span class="sxs-lookup"><span data-stu-id="b21d2-751">This method does not preserve white space.</span></span> <span data-ttu-id="b21d2-752">如果要保留 XML 树中的空白，请使用 <xref:System.Xml.Linq.XElement.Parse%2A> 采用作为参数的方法的重载 <xref:System.Xml.Linq.LoadOptions> 。</span><span class="sxs-lookup"><span data-stu-id="b21d2-752">If you want to preserve white space in the XML tree, use the overload of the <xref:System.Xml.Linq.XElement.Parse%2A> method that takes <xref:System.Xml.Linq.LoadOptions> as a parameter.</span></span> <span data-ttu-id="b21d2-753">有关详细信息，请参阅 [在加载或分析 XML 时保留空白](/dotnet/standard/linq/preserve-white-space-loading-parsing-xml) ，并 [在序列化时保留空白区域](/dotnet/standard/linq/preserve-white-space-serializing)。</span><span class="sxs-lookup"><span data-stu-id="b21d2-753">For more information, see [Preserve white space while loading or parsing XML](/dotnet/standard/linq/preserve-white-space-loading-parsing-xml) and [Preserve white space while serializing](/dotnet/standard/linq/preserve-white-space-serializing).</span></span>  
  
 <span data-ttu-id="b21d2-754">LINQ to XML 的加载功能是基于生成的 <xref:System.Xml.XmlReader> 。</span><span class="sxs-lookup"><span data-stu-id="b21d2-754">LINQ to XML's loading functionality is built upon <xref:System.Xml.XmlReader>.</span></span> <span data-ttu-id="b21d2-755">因此，你可能会捕获重载方法所引发的任何异常 <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> 和 <xref:System.Xml.XmlReader> 读取和分析文档的方法。</span><span class="sxs-lookup"><span data-stu-id="b21d2-755">Therefore, you might catch any exceptions that are thrown by the <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> overload methods and the <xref:System.Xml.XmlReader> methods that read and parse the document.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b21d2-756">下面的示例创建一个包含 XML 的字符串。</span><span class="sxs-lookup"><span data-stu-id="b21d2-756">The following example creates a string that contains XML.</span></span> <span data-ttu-id="b21d2-757">然后，将该字符串分析为 <xref:System.Xml.Linq.XElement> 。</span><span class="sxs-lookup"><span data-stu-id="b21d2-757">It then parses the string into an <xref:System.Xml.Linq.XElement>.</span></span>  
  
```csharp  
XElement xmlTree = XElement.Parse("<Root> <Child> </Child> </Root>");  
Console.WriteLine(xmlTree);  
```  
  
```vb  
Dim xmlTree As XElement = <Root><Child></Child></Root>  
Console.WriteLine(xmlTree)  
```  
  
 <span data-ttu-id="b21d2-758">该示例产生下面的输出：</span><span class="sxs-lookup"><span data-stu-id="b21d2-758">This example produces the following output:</span></span>  
  
```xml  
<Root>  
  <Child></Child>  
</Root>  
```  
  
 ]]></format>
        </remarks>
        <related type="Article" href="/dotnet/standard/linq/linq-xml-overview"><span data-ttu-id="b21d2-759">LINQ to XML 概述</span><span class="sxs-lookup"><span data-stu-id="b21d2-759">LINQ to XML overview</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static System.Xml.Linq.XElement Parse (string text, System.Xml.Linq.LoadOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.Linq.XElement Parse(string text, valuetype System.Xml.Linq.LoadOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XElement.Parse(System.String,System.Xml.Linq.LoadOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (text As String, options As LoadOptions) As XElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Xml::Linq::XElement ^ Parse(System::String ^ text, System::Xml::Linq::LoadOptions options);" />
      <MemberSignature Language="F#" Value="static member Parse : string * System.Xml.Linq.LoadOptions -&gt; System.Xml.Linq.XElement" Usage="System.Xml.Linq.XElement.Parse (text, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Linq.XElement</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="text" Type="System.String" />
        <Parameter Name="options" Type="System.Xml.Linq.LoadOptions" />
      </Parameters>
      <Docs>
        <param name="text"><span data-ttu-id="b21d2-760">一个包含 XML 的 <see cref="T:System.String" />。</span><span class="sxs-lookup"><span data-stu-id="b21d2-760">A <see cref="T:System.String" /> that contains XML.</span></span></param>
        <param name="options"><span data-ttu-id="b21d2-761">一个 <see cref="T:System.Xml.Linq.LoadOptions" />，指定空白行为以及是否加载基 URI 和行信息。</span><span class="sxs-lookup"><span data-stu-id="b21d2-761">A <see cref="T:System.Xml.Linq.LoadOptions" /> that specifies white space behavior, and whether to load base URI and line information.</span></span></param>
        <summary><span data-ttu-id="b21d2-762">从包含 XML 的字符串加载 <see cref="T:System.Xml.Linq.XElement" />，还可以选择保留空白和行信息。</span><span class="sxs-lookup"><span data-stu-id="b21d2-762">Load an <see cref="T:System.Xml.Linq.XElement" /> from a string that contains XML, optionally preserving white space and retaining line information.</span></span></summary>
        <returns><span data-ttu-id="b21d2-763">一个使用包含 XML 的字符串填充的 <see cref="T:System.Xml.Linq.XElement" />。</span><span class="sxs-lookup"><span data-stu-id="b21d2-763">An <see cref="T:System.Xml.Linq.XElement" /> populated from the string that contains XML.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b21d2-764">如果源 XML 已缩进，则 <xref:System.Xml.Linq.LoadOptions.PreserveWhitespace> 在中设置标志将 `options` 导致读取器读取源 xml 中的所有空格。</span><span class="sxs-lookup"><span data-stu-id="b21d2-764">If the source XML is indented, setting the <xref:System.Xml.Linq.LoadOptions.PreserveWhitespace> flag in `options` causes the reader to read all white space in the source XML.</span></span> <span data-ttu-id="b21d2-765"><xref:System.Xml.Linq.XText>为有效空白和无意义空白创建类型的节点。</span><span class="sxs-lookup"><span data-stu-id="b21d2-765">Nodes of type <xref:System.Xml.Linq.XText> are created for both significant and insignificant white space.</span></span>  
  
 <span data-ttu-id="b21d2-766">如果源 XML 已缩进，则未 <xref:System.Xml.Linq.LoadOptions.PreserveWhitespace> 在中设置标志将 `options` 导致读取器忽略源 xml 中所有无意义的空白。</span><span class="sxs-lookup"><span data-stu-id="b21d2-766">If the source XML is indented, not setting the <xref:System.Xml.Linq.LoadOptions.PreserveWhitespace> flag in `options` causes the reader to ignore all of the insignificant white space in the source XML.</span></span> <span data-ttu-id="b21d2-767">创建 XML 树时无需任何文本节点，无意义的空白。</span><span class="sxs-lookup"><span data-stu-id="b21d2-767">The XML tree is created without any text nodes for insignificant white space.</span></span>  
  
 <span data-ttu-id="b21d2-768">如果未缩进源 XML，则 <xref:System.Xml.Linq.LoadOptions.PreserveWhitespace> 在中设置标志 `options` 不起作用。</span><span class="sxs-lookup"><span data-stu-id="b21d2-768">If the source XML is not indented, setting the <xref:System.Xml.Linq.LoadOptions.PreserveWhitespace> flag in `options` has no effect.</span></span> <span data-ttu-id="b21d2-769">仍保留了有效空白，并且不存在任何可能导致创建更多空白文本节点的无意义空白区域。</span><span class="sxs-lookup"><span data-stu-id="b21d2-769">Significant white space is still preserved, and there are no spans of insignificant white space that could cause the creation of more white space text nodes.</span></span>  
  
 <span data-ttu-id="b21d2-770">有关详细信息，请参阅 [在加载或分析 XML 时保留空白](/dotnet/standard/linq/preserve-white-space-loading-parsing-xml) ，并 [在序列化时保留空白区域](/dotnet/standard/linq/preserve-white-space-serializing)。</span><span class="sxs-lookup"><span data-stu-id="b21d2-770">For more information, see [Preserve white space while loading or parsing XML](/dotnet/standard/linq/preserve-white-space-loading-parsing-xml) and [Preserve white space while serializing](/dotnet/standard/linq/preserve-white-space-serializing).</span></span>  
  
 <span data-ttu-id="b21d2-771">在 <xref:System.Xml.Linq.LoadOptions.SetBaseUri> 从分析时，设置将不起作用 <xref:System.String> 。</span><span class="sxs-lookup"><span data-stu-id="b21d2-771">Setting <xref:System.Xml.Linq.LoadOptions.SetBaseUri> will have no effect when parsing from a <xref:System.String>.</span></span>  
  
 <span data-ttu-id="b21d2-772"><xref:System.Xml.XmlReader>可能有有效的行信息。</span><span class="sxs-lookup"><span data-stu-id="b21d2-772">The <xref:System.Xml.XmlReader> may have a valid line information or not.</span></span> <span data-ttu-id="b21d2-773">如果设置 <xref:System.Xml.Linq.LoadOptions.SetLineInfo> 了，则将从报告的行信息在 XML 树中设置行信息 <xref:System.Xml.XmlReader> 。</span><span class="sxs-lookup"><span data-stu-id="b21d2-773">If you set <xref:System.Xml.Linq.LoadOptions.SetLineInfo>, the line information will be set in the XML tree from the line information that is reported by the <xref:System.Xml.XmlReader>.</span></span>  
  
 <span data-ttu-id="b21d2-774">如果设置了标志，则会对性能产生负面影响 <xref:System.Xml.Linq.LoadOptions.SetLineInfo> 。</span><span class="sxs-lookup"><span data-stu-id="b21d2-774">There is a performance penalty if you set the <xref:System.Xml.Linq.LoadOptions.SetLineInfo> flag.</span></span>  
  
 <span data-ttu-id="b21d2-775">行信息在加载 XML 文档后立即准确无误。</span><span class="sxs-lookup"><span data-stu-id="b21d2-775">The line information is accurate immediately after loading the XML document.</span></span> <span data-ttu-id="b21d2-776">如果在加载文档后修改 XML 树，行信息可能会变得毫无意义。</span><span class="sxs-lookup"><span data-stu-id="b21d2-776">If you modify the XML tree after loading the document, the line information may become meaningless.</span></span>  
  
 <span data-ttu-id="b21d2-777">LINQ to XML 的加载功能是基于生成的 <xref:System.Xml.XmlReader> 。</span><span class="sxs-lookup"><span data-stu-id="b21d2-777">LINQ to XML's loading functionality is built upon <xref:System.Xml.XmlReader>.</span></span> <span data-ttu-id="b21d2-778">因此，你可能会捕获重载方法所引发的任何异常 <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> 和 <xref:System.Xml.XmlReader> 读取和分析文档的方法。</span><span class="sxs-lookup"><span data-stu-id="b21d2-778">Therefore, you might catch any exceptions that are thrown by the <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> overload methods and the <xref:System.Xml.XmlReader> methods that read and parse the document.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b21d2-779">下面的示例 <xref:System.Xml.Linq.XElement> 通过两种不同的方式将字符串分析为：保留空白和不保留空格。</span><span class="sxs-lookup"><span data-stu-id="b21d2-779">The following example parses a string into an <xref:System.Xml.Linq.XElement> in two different ways: preserving white space, and not preserving white space.</span></span> <span data-ttu-id="b21d2-780">然后，它使用查询来确定生成的 XML 树中的空白节点数。</span><span class="sxs-lookup"><span data-stu-id="b21d2-780">It then uses a query to determine the number of white space nodes in the resulting XML tree.</span></span>  
  
```csharp  
int whiteSpaceNodes;  
  
XElement xmlTree1 = XElement.Parse("<Root> <Child> </Child> </Root>",  
    LoadOptions.None);  
whiteSpaceNodes = xmlTree1  
    .DescendantNodesAndSelf()  
    .OfType<XText>()  
    .Where(tNode => tNode.ToString().Trim().Length == 0)  
    .Count();  
Console.WriteLine("Count of white space nodes (not preserving whitespace): {0}",  
    whiteSpaceNodes);  
  
XElement xmlTree2 = XElement.Parse("<Root> <Child> </Child> </Root>",  
    LoadOptions.PreserveWhitespace);  
whiteSpaceNodes = xmlTree2  
    .DescendantNodesAndSelf()  
    .OfType<XText>()  
    .Where(tNode => tNode.ToString().Trim().Length == 0)  
    .Count();  
Console.WriteLine("Count of white space nodes (preserving whitespace): {0}",  
    whiteSpaceNodes);  
```  
  
```vb  
Dim whiteSpaceNodes As Integer  
  
Dim xmlTree1 As XElement = XElement.Parse("<Root> <Child> </Child> </Root>", LoadOptions.None)  
whiteSpaceNodes = xmlTree1 _  
    .DescendantNodesAndSelf() _  
    .OfType(Of XText)() _  
    .Where(Function(ByVal tNode As XNode) tNode.ToString().Trim().Length = 0) _  
    .Count()  
Console.WriteLine("Count of white space nodes (not preserving whitespace): {0}", whiteSpaceNodes)  
  
Dim xmlTree2 As XElement = XElement.Parse("<Root> <Child> </Child> </Root>", LoadOptions.PreserveWhitespace)  
whiteSpaceNodes = xmlTree2 _  
    .DescendantNodesAndSelf() _  
    .OfType(Of XText)() _  
    .Where(Function(ByVal tNode As XNode) tNode.ToString().Trim().Length = 0) _  
    .Count()  
Console.WriteLine("Count of white space nodes (preserving whitespace): {0}", whiteSpaceNodes)  
```  
  
 <span data-ttu-id="b21d2-781">该示例产生下面的输出：</span><span class="sxs-lookup"><span data-stu-id="b21d2-781">This example produces the following output:</span></span>  
  
```  
Count of white space nodes (not preserving whitespace): 0  
Count of white space nodes (preserving whitespace): 3  
```  
  
 <span data-ttu-id="b21d2-782">下面的示例在分析字符串时保留行信息。</span><span class="sxs-lookup"><span data-stu-id="b21d2-782">The following example retains line information as it parses the string.</span></span>  
  
```csharp  
string markup =  
@"<Root>  
    <Child>  
        <GrandChild/>  
    </Child>  
</Root>";  
  
XElement xRoot = XElement.Parse(markup, LoadOptions.SetLineInfo);  
Console.WriteLine("{0}{1}{2}",  
    "Element Name".PadRight(20),  
    "Line".PadRight(5),  
    "Position");  
Console.WriteLine("{0}{1}{2}",  
    "------------".PadRight(20),  
    "----".PadRight(5),  
    "--------");  
foreach (XElement e in xRoot.DescendantsAndSelf())  
    Console.WriteLine("{0}{1}{2}",  
        ("".PadRight(e.Ancestors().Count() * 2) + e.Name).PadRight(20),  
        ((IXmlLineInfo)e).LineNumber.ToString().PadRight(5),  
        ((IXmlLineInfo)e).LinePosition);  
```  
  
```vb  
Dim markup As String = _  
"<Root>" & Environment.NewLine & _  
"    <Child>" & Environment.NewLine & _  
"        <GrandChild/>" & Environment.NewLine & _  
"    </Child>" & Environment.NewLine & _  
"</Root>"  
  
Dim xRoot As XElement = XElement.Parse(markup, LoadOptions.SetLineInfo)  
Console.WriteLine("{0}{1}{2}", _  
    "Element Name".PadRight(20), _  
    "Line".PadRight(5), _  
    "Position")  
Console.WriteLine("{0}{1}{2}", _  
    "------------".PadRight(20), _  
    "----".PadRight(5), _  
    "--------")  
For Each e As XElement In xRoot.DescendantsAndSelf()  
    Console.WriteLine("{0}{1}{2}", _  
        ("".PadRight(e.Ancestors().Count() * 2) & e.Name.ToString).PadRight(20), _  
        DirectCast(e, IXmlLineInfo).LineNumber.ToString().PadRight(5), _  
        DirectCast(e, IXmlLineInfo).LinePosition)  
Next  
```  
  
 <span data-ttu-id="b21d2-783">该示例产生下面的输出：</span><span class="sxs-lookup"><span data-stu-id="b21d2-783">This example produces the following output:</span></span>  
  
```  
Element Name        Line Position  
------------        ---- --------  
Root                1    2  
  Child             2    6  
    GrandChild      3    10  
```  
  
 ]]></format>
        </remarks>
        <related type="Article" href="/dotnet/standard/linq/linq-xml-overview"><span data-ttu-id="b21d2-784">LINQ to XML 概述</span><span class="sxs-lookup"><span data-stu-id="b21d2-784">LINQ to XML overview</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="RemoveAll">
      <MemberSignature Language="C#" Value="public void RemoveAll ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RemoveAll() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XElement.RemoveAll" />
      <MemberSignature Language="VB.NET" Value="Public Sub RemoveAll ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RemoveAll();" />
      <MemberSignature Language="F#" Value="member this.RemoveAll : unit -&gt; unit" Usage="xElement.RemoveAll " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="b21d2-785">从此 <see cref="T:System.Xml.Linq.XElement" /> 中移除节点和属性。</span><span class="sxs-lookup"><span data-stu-id="b21d2-785">Removes nodes and attributes from this <see cref="T:System.Xml.Linq.XElement" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b21d2-786">此方法将引发 <xref:System.Xml.Linq.XObject.Changed> 和 <xref:System.Xml.Linq.XObject.Changing> 事件。</span><span class="sxs-lookup"><span data-stu-id="b21d2-786">This method will raise the <xref:System.Xml.Linq.XObject.Changed> and the <xref:System.Xml.Linq.XObject.Changing> events.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b21d2-787">下面的示例创建一个具有属性和子元素的元素。</span><span class="sxs-lookup"><span data-stu-id="b21d2-787">The following example creates an element with attributes and child elements.</span></span> <span data-ttu-id="b21d2-788">然后，它调用此方法以删除属性和子元素。</span><span class="sxs-lookup"><span data-stu-id="b21d2-788">It then calls this method to remove both the attributes and the child elements.</span></span>  
  
```csharp  
XElement root = new XElement("Root",  
    new XAttribute("Att1", 1),  
    new XAttribute("Att2", 2),  
    new XAttribute("Att3", 3),  
    new XElement("Child1", 1),  
    new XElement("Child2", 2),  
    new XElement("Child3", 3)  
);  
root.RemoveAll();   // removes children elements and attributes of root  
Console.WriteLine(root);  
```  
  
```vb  
Dim root As XElement = _   
        <Root Attr1="1" Attr2="2" Attr3="3">  
            <Child1>1</Child1>  
            <Child2>2</Child2>  
            <Child3>3</Child3>  
        </Root>  
  
root.RemoveAll()   ' removes children elements and attributes of root  
Console.WriteLine(root)  
```  
  
 <span data-ttu-id="b21d2-789">该示例产生下面的输出：</span><span class="sxs-lookup"><span data-stu-id="b21d2-789">This example produces the following output:</span></span>  
  
```xml  
<Root />  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Xml.Linq.XElement.RemoveAttributes" />
        <altmember cref="M:System.Xml.Linq.XContainer.RemoveNodes" />
        <related type="Article" href="/dotnet/standard/linq/linq-xml-overview"><span data-ttu-id="b21d2-790">LINQ to XML 概述</span><span class="sxs-lookup"><span data-stu-id="b21d2-790">LINQ to XML overview</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="RemoveAttributes">
      <MemberSignature Language="C#" Value="public void RemoveAttributes ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RemoveAttributes() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XElement.RemoveAttributes" />
      <MemberSignature Language="VB.NET" Value="Public Sub RemoveAttributes ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RemoveAttributes();" />
      <MemberSignature Language="F#" Value="member this.RemoveAttributes : unit -&gt; unit" Usage="xElement.RemoveAttributes " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="b21d2-791">移除此 <see cref="T:System.Xml.Linq.XElement" /> 的属性。</span><span class="sxs-lookup"><span data-stu-id="b21d2-791">Removes the attributes of this <see cref="T:System.Xml.Linq.XElement" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b21d2-792">此方法将引发 <xref:System.Xml.Linq.XObject.Changed> 和 <xref:System.Xml.Linq.XObject.Changing> 事件。</span><span class="sxs-lookup"><span data-stu-id="b21d2-792">This method will raise the <xref:System.Xml.Linq.XObject.Changed> and the <xref:System.Xml.Linq.XObject.Changing> events.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b21d2-793">下面的示例创建一个具有属性和子元素的元素。</span><span class="sxs-lookup"><span data-stu-id="b21d2-793">The following example creates an element with attributes and child elements.</span></span> <span data-ttu-id="b21d2-794">然后，它调用此方法以删除这些属性。</span><span class="sxs-lookup"><span data-stu-id="b21d2-794">It then calls this method to remove the attributes.</span></span> <span data-ttu-id="b21d2-795">子元素保留。</span><span class="sxs-lookup"><span data-stu-id="b21d2-795">The child elements remain.</span></span>  
  
```csharp  
XElement root = new XElement("Root",  
    new XAttribute("Att1", 1),  
    new XAttribute("Att2", 2),  
    new XAttribute("Att3", 3),  
    new XElement("Child1", 1),  
    new XElement("Child2", 2),  
    new XElement("Child3", 3)  
);  
root.RemoveAttributes();  
Console.WriteLine(root);  
```  
  
```vb  
Dim root As XElement = _   
    <Root Attr1="1" Attr2="2" Attr3="3">  
        <Child1>1</Child1>  
        <Child2>2</Child2>  
        <Child3>3</Child3>  
     </Root>  
  
root.RemoveAttributes()  
Console.WriteLine(root)  
```  
  
 <span data-ttu-id="b21d2-796">该示例产生下面的输出：</span><span class="sxs-lookup"><span data-stu-id="b21d2-796">This example produces the following output:</span></span>  
  
```xml  
<Root>  
  <Child1>1</Child1>  
  <Child2>2</Child2>  
  <Child3>3</Child3>  
</Root>   
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Xml.Linq.XElement.RemoveAttributes" />
        <altmember cref="M:System.Xml.Linq.XElement.RemoveAll" />
        <related type="Article" href="/dotnet/standard/linq/linq-xml-overview"><span data-ttu-id="b21d2-797">LINQ to XML 概述</span><span class="sxs-lookup"><span data-stu-id="b21d2-797">LINQ to XML overview</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReplaceAll">
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="b21d2-798">将此元素的子节点和属性替换为指定的内容。</span><span class="sxs-lookup"><span data-stu-id="b21d2-798">Replaces the child nodes and the attributes of this element with the specified content.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b21d2-799">此方法使用快照语义，也就是说，它会在将当前元素的内容替换为新内容之前创建新内容的单独副本。</span><span class="sxs-lookup"><span data-stu-id="b21d2-799">This method uses snapshot semantics - that is, it creates a separate copy of the new content before replacing the contents of the current element with the new content.</span></span> <span data-ttu-id="b21d2-800">这意味着你可以查询当前元素的内容，并使用查询结果作为指定的新内容。</span><span class="sxs-lookup"><span data-stu-id="b21d2-800">This means that you can query the contents of the current element and use the results of the query as the specified new content.</span></span>  
  
 <span data-ttu-id="b21d2-801">有关可传递到此函数的有效内容的详细信息，请参阅 [system.xml.linq.xelement> 和 XDocument 对象的有效内容](/dotnet/standard/linq/valid-content-xelement-xdocument-objects)。</span><span class="sxs-lookup"><span data-stu-id="b21d2-801">For details about the valid content that can be passed to this function, see [Valid Content of XElement and XDocument Objects](/dotnet/standard/linq/valid-content-xelement-xdocument-objects).</span></span>  
  
 <span data-ttu-id="b21d2-802">此方法将引发 <xref:System.Xml.Linq.XObject.Changed> 和 <xref:System.Xml.Linq.XObject.Changing> 事件。</span><span class="sxs-lookup"><span data-stu-id="b21d2-802">This method will raise the <xref:System.Xml.Linq.XObject.Changed> and the <xref:System.Xml.Linq.XObject.Changing> events.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b21d2-803">下面的示例将 LINQ 查询的结果传递给此方法，并将元素的内容替换为查询结果。</span><span class="sxs-lookup"><span data-stu-id="b21d2-803">The following example passes the results of a LINQ query to this method, replacing the contents of an element with the query results.</span></span> <span data-ttu-id="b21d2-804">它将查询替换其内容的元素。</span><span class="sxs-lookup"><span data-stu-id="b21d2-804">It queries the element that is having its contents replaced.</span></span>  
  
```csharp  
XElement xmlTree = new XElement("Root",  
    new XElement("Data", 1),  
    new XElement("Data", 2),  
    new XElement("Data", 3),  
    new XElement("Data", 4),  
    new XElement("Data", 5)  
);  
  
Console.WriteLine(xmlTree);  
Console.WriteLine("-----");  
  
xmlTree.ReplaceAll(  
    from el in xmlTree.Elements()  
    where (int)el >= 3  
    select new XElement("NewData", (int)el)  
);  
  
Console.WriteLine(xmlTree);  
```  
  
```vb  
Dim xmlTree As XElement = _  
    <Root>  
        <Data>1</Data>  
        <Data>2</Data>  
        <Data>3</Data>  
        <Data>4</Data>  
        <Data>5</Data>  
    </Root>  
  
Console.WriteLine(xmlTree)  
Console.WriteLine("-----")  
  
xmlTree.ReplaceAll( _  
    From el In xmlTree.Elements _  
    Where el.Value >= 3 _  
    Select <NewData><%= el.Value %></NewData> _  
)  
  
Console.WriteLine(xmlTree)  
```  
  
 <span data-ttu-id="b21d2-805">该示例产生下面的输出：</span><span class="sxs-lookup"><span data-stu-id="b21d2-805">This example produces the following output:</span></span>  
  
```  
<Root>  
  <Data>1</Data>  
  <Data>2</Data>  
  <Data>3</Data>  
  <Data>4</Data>  
  <Data>5</Data>  
</Root>  
-----  
<Root>  
  <NewData>3</NewData>  
  <NewData>4</NewData>  
  <NewData>5</NewData>  
</Root>  
```  
  
 ]]></format>
        </remarks>
        <related type="Article" href="/dotnet/standard/linq/linq-xml-overview"><span data-ttu-id="b21d2-806">LINQ to XML 概述</span><span class="sxs-lookup"><span data-stu-id="b21d2-806">LINQ to XML overview</span></span></related>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReplaceAll">
      <MemberSignature Language="C#" Value="public void ReplaceAll (object content);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReplaceAll(object content) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XElement.ReplaceAll(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReplaceAll (content As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ReplaceAll(System::Object ^ content);" />
      <MemberSignature Language="F#" Value="member this.ReplaceAll : obj -&gt; unit" Usage="xElement.ReplaceAll content" />
      <MemberSignature Language="C#" Value="public void ReplaceAll (object? content);" FrameworkAlternate="net-5.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="content" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="content"><span data-ttu-id="b21d2-807">替换此元素的子节点和属性时将使用的内容。</span><span class="sxs-lookup"><span data-stu-id="b21d2-807">The content that will replace the child nodes and attributes of this element.</span></span></param>
        <summary><span data-ttu-id="b21d2-808">将此元素的子节点和属性替换为指定的内容。</span><span class="sxs-lookup"><span data-stu-id="b21d2-808">Replaces the child nodes and the attributes of this element with the specified content.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b21d2-809">此方法首先删除现有内容和属性。</span><span class="sxs-lookup"><span data-stu-id="b21d2-809">This method first removes existing content and attributes.</span></span> <span data-ttu-id="b21d2-810">然后添加指定的 `content` 。</span><span class="sxs-lookup"><span data-stu-id="b21d2-810">It then adds the specified `content`.</span></span>  
  
 <span data-ttu-id="b21d2-811">此方法使用快照语义，也就是说，它会在将当前元素的内容替换为新内容之前创建新内容的单独副本。</span><span class="sxs-lookup"><span data-stu-id="b21d2-811">This method uses snapshot semantics - that is, it creates a separate copy of the new content before replacing the contents of the current element with the new content.</span></span> <span data-ttu-id="b21d2-812">这意味着你可以查询当前元素的内容，并使用查询结果作为指定的新内容。</span><span class="sxs-lookup"><span data-stu-id="b21d2-812">This means that you can query the contents of the current element and use the results of the query as the specified new content.</span></span>  
  
 <span data-ttu-id="b21d2-813">有关可传递到此函数的有效内容的详细信息，请参阅 [system.xml.linq.xelement> 和 XDocument 对象的有效内容](/dotnet/standard/linq/valid-content-xelement-xdocument-objects)。</span><span class="sxs-lookup"><span data-stu-id="b21d2-813">For details about the valid content that can be passed to this function, see [Valid Content of XElement and XDocument Objects](/dotnet/standard/linq/valid-content-xelement-xdocument-objects).</span></span>  
  
 <span data-ttu-id="b21d2-814">此方法将引发 <xref:System.Xml.Linq.XObject.Changed> 和 <xref:System.Xml.Linq.XObject.Changing> 事件。</span><span class="sxs-lookup"><span data-stu-id="b21d2-814">This method will raise the <xref:System.Xml.Linq.XObject.Changed> and the <xref:System.Xml.Linq.XObject.Changing> events.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b21d2-815">下面的示例使用此方法。</span><span class="sxs-lookup"><span data-stu-id="b21d2-815">The following example uses this method.</span></span>  
  
```csharp  
XElement root = new XElement("Root",  
    new XElement("Child", "child content")  
);  
  
// ReplaceAll with an XElement object.  
root.ReplaceAll(new XElement("NewChild", "n"));  
Console.WriteLine(root);  
  
// ReplaceAll with an XAttribute object.  
root.ReplaceAll(new XAttribute("NewAttribute", "n"));  
Console.WriteLine(root);  
  
// ReplaceAll with a string.  
root.ReplaceAll("Some text");  
Console.WriteLine(root);  
  
// ReplaceAll with a double.  
double dbl = 12.345;  
root.ReplaceAll(dbl);  
Console.WriteLine(root);  
  
// ReplaceAll with a DateTime object.  
DateTime dt = new DateTime(2006, 10, 6, 12, 30, 00);  
root.ReplaceAll(dt);  
Console.WriteLine(root);  
  
// ReplaceAll with a string array.  
// Any collection other than a collection of XElement or XAttribute objects  
// are converted to strings. The strings are concatenated and added.  
string[] stringArray = {  
    "abc",  
    "def",  
    "ghi"  
};  
root.ReplaceAll(stringArray);  
Console.WriteLine(root);  
  
// ReplaceAll with an array of XElement objects.  
XElement[] ellArray = {  
    new XElement("NewChild1", 1),  
    new XElement("NewChild2", 2),  
    new XElement("NewChild3", 3)  
};  
root.ReplaceAll(ellArray);  
Console.WriteLine(root);  
  
// ReplaceAll with an array of XAttribute objects.  
XAttribute[] attArray = {  
    new XAttribute("NewAtt1", 1),  
    new XAttribute("NewAtt2", 2),  
    new XAttribute("NewAtt3", 3)  
};  
root.ReplaceAll(attArray);  
Console.WriteLine(root);  
```  
  
```vb  
Dim root As XElement = _   
    <Root>  
        <Child>child content</Child>  
    </Root>  
  
' ReplaceAll with an XElement object.  
root.ReplaceAll(<NewChild>n</NewChild>)  
Console.WriteLine(root)  
  
' ReplaceAll with an XAttribute object.  
root.ReplaceAll(New XAttribute("NewAttribute", "n"))  
Console.WriteLine(root)  
  
' ReplaceAll with a string.  
root.ReplaceAll("Some text")  
Console.WriteLine(root)  
  
' ReplaceAll with a double.  
Dim dbl As Double = 12.345  
root.ReplaceAll(dbl)  
Console.WriteLine(root)  
  
' ReplaceAll with a DateTime object.  
Dim dt As DateTime = New DateTime(2006, 10, 6, 12, 30, 0)  
root.ReplaceAll(dt)  
Console.WriteLine(root)  
  
' ReplaceAll with a string array.  
' Any collection other than a collection of XElement or XAttribute objects  
' are converted to strings. The strings are concatenated and added.  
Dim stringArray As String() = { _  
    "abc", _  
    "def", _  
    "ghi" _  
}  
root.ReplaceAll(stringArray)  
Console.WriteLine(root)  
  
' ReplaceAll with an array of XElement objects.  
Dim ellArray As XElement() = { _  
    New XElement("NewChild1", 1), _  
    New XElement("NewChild2", 2), _  
    New XElement("NewChild3", 3) _  
}  
root.ReplaceAll(ellArray)  
Console.WriteLine(root)  
  
' ReplaceAll with an array of XAttribute objects.  
Dim attArray As XAttribute() = { _  
New XAttribute("NewAtt1", 1), _  
New XAttribute("NewAtt2", 2), _  
New XAttribute("NewAtt3", 3) _  
}  
root.ReplaceAll(attArray)  
Console.WriteLine(root)  
```  
  
 <span data-ttu-id="b21d2-816">该示例产生下面的输出：</span><span class="sxs-lookup"><span data-stu-id="b21d2-816">This example produces the following output:</span></span>  
  
```xml  
<Root>  
  <NewChild>n</NewChild>  
</Root>  
<Root NewAttribute="n" />  
<Root>Some text</Root>  
<Root>12.345</Root>  
<Root>2006-10-06T12:30:00</Root>  
<Root>abcdefghi</Root>  
<Root>  
  <NewChild1>1</NewChild1>  
  <NewChild2>2</NewChild2>  
  <NewChild3>3</NewChild3>  
</Root>  
<Root NewAtt1="1" NewAtt2="2" NewAtt3="3" />  
```  
  
 ]]></format>
        </remarks>
        <related type="Article" href="/dotnet/standard/linq/linq-xml-overview"><span data-ttu-id="b21d2-817">LINQ to XML 概述</span><span class="sxs-lookup"><span data-stu-id="b21d2-817">LINQ to XML overview</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="ReplaceAll">
      <MemberSignature Language="C#" Value="public void ReplaceAll (params object[] content);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReplaceAll(object[] content) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XElement.ReplaceAll(System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReplaceAll (ParamArray content As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ReplaceAll(... cli::array &lt;System::Object ^&gt; ^ content);" />
      <MemberSignature Language="F#" Value="member this.ReplaceAll : obj[] -&gt; unit" Usage="xElement.ReplaceAll content" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="content" Type="System.Object[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName Language="C#">[System.ParamArray]</AttributeName>
              <AttributeName Language="F#">[&lt;System.ParamArray&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="content"><span data-ttu-id="b21d2-818">内容对象的参数列表。</span><span class="sxs-lookup"><span data-stu-id="b21d2-818">A parameter list of content objects.</span></span></param>
        <summary><span data-ttu-id="b21d2-819">将此元素的子节点和属性替换为指定的内容。</span><span class="sxs-lookup"><span data-stu-id="b21d2-819">Replaces the child nodes and the attributes of this element with the specified content.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b21d2-820">此方法首先删除现有内容和属性。</span><span class="sxs-lookup"><span data-stu-id="b21d2-820">This method first removes existing content and attributes.</span></span> <span data-ttu-id="b21d2-821">然后添加指定的 `content` 。</span><span class="sxs-lookup"><span data-stu-id="b21d2-821">It then adds the specified `content`.</span></span>  
  
 <span data-ttu-id="b21d2-822">此方法使用快照语义，也就是说，它会在将当前元素的内容替换为新内容之前创建新内容的单独副本。</span><span class="sxs-lookup"><span data-stu-id="b21d2-822">This method uses snapshot semantics - that is, it creates a separate copy of the new content before replacing the contents of the current element with the new content.</span></span> <span data-ttu-id="b21d2-823">这意味着你可以查询当前元素的内容，并使用查询结果作为指定的新内容。</span><span class="sxs-lookup"><span data-stu-id="b21d2-823">This means that you can query the contents of the current element and use the results of the query as the specified new content.</span></span>  
  
 <span data-ttu-id="b21d2-824">有关可传递到此函数的有效内容的详细信息，请参阅 [system.xml.linq.xelement> 和 XDocument 对象的有效内容](/dotnet/standard/linq/valid-content-xelement-xdocument-objects)。</span><span class="sxs-lookup"><span data-stu-id="b21d2-824">For details about the valid content that can be passed to this function, see [Valid Content of XElement and XDocument Objects](/dotnet/standard/linq/valid-content-xelement-xdocument-objects).</span></span>  
  
 <span data-ttu-id="b21d2-825">此方法将引发 <xref:System.Xml.Linq.XObject.Changed> 和 <xref:System.Xml.Linq.XObject.Changing> 事件。</span><span class="sxs-lookup"><span data-stu-id="b21d2-825">This method will raise the <xref:System.Xml.Linq.XObject.Changed> and the <xref:System.Xml.Linq.XObject.Changing> events.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b21d2-826">下面的示例将 LINQ 查询的结果传递给此方法，并将元素的内容替换为查询结果。</span><span class="sxs-lookup"><span data-stu-id="b21d2-826">The following example passes the results of a LINQ query to this method, replacing the contents of an element with the query results.</span></span>  
  
```csharp  
XElement xmlTree1 = new XElement("Root",  
    new XElement("Child1", 1),  
    new XElement("Child2", 2),  
    new XElement("Child3", 3),  
    new XElement("Child4", 4),  
    new XElement("Child5", 5),  
    new XElement("Child6", 6)  
);  
  
XElement root = new XElement("Root",  
    new XElement("Child", "child content")  
);  
  
root.ReplaceAll(  
    from el in xmlTree1.Elements()  
    where((int)el >= 3 && (int)el <= 5)  
    select el  
);  
Console.WriteLine(root);  
```  
  
```vb  
Dim xmlTree1 As XElement = _   
        <Root>  
            <Child1>1</Child1>  
            <Child2>2</Child2>  
            <Child3>3</Child3>  
            <Child4>4</Child4>  
            <Child5>5</Child5>  
            <Child6>6</Child6>  
        </Root>  
  
Dim root As XElement = <Root>  
                           <Child>child content</Child>  
                       </Root>  
  
root.ReplaceAll( _  
    From el In xmlTree1.Elements() _  
    Where el.Value >= 3 And el.Value <= 5 _  
    Select el _  
)  
  
Console.WriteLine(root)  
```  
  
 <span data-ttu-id="b21d2-827">该示例产生下面的输出：</span><span class="sxs-lookup"><span data-stu-id="b21d2-827">This example produces the following output:</span></span>  
  
```xml  
<Root>  
  <Child3>3</Child3>  
  <Child4>4</Child4>  
  <Child5>5</Child5>  
</Root>  
```  
  
 ]]></format>
        </remarks>
        <related type="Article" href="/dotnet/standard/linq/linq-xml-overview"><span data-ttu-id="b21d2-828">LINQ to XML 概述</span><span class="sxs-lookup"><span data-stu-id="b21d2-828">LINQ to XML overview</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReplaceAttributes">
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="b21d2-829">将此元素的属性替换为指定的内容。</span><span class="sxs-lookup"><span data-stu-id="b21d2-829">Replaces the attributes of this element with the specified content.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b21d2-830">此方法将引发 <xref:System.Xml.Linq.XObject.Changed> 和 <xref:System.Xml.Linq.XObject.Changing> 事件。</span><span class="sxs-lookup"><span data-stu-id="b21d2-830">This method will raise the <xref:System.Xml.Linq.XObject.Changed> and the <xref:System.Xml.Linq.XObject.Changing> events.</span></span>  
  
 <span data-ttu-id="b21d2-831">有关可传递到此函数的有效内容的详细信息，请参阅 [system.xml.linq.xelement> 和 XDocument 对象的有效内容](/dotnet/standard/linq/valid-content-xelement-xdocument-objects)。</span><span class="sxs-lookup"><span data-stu-id="b21d2-831">For details about the valid content that can be passed to this function, see [Valid Content of XElement and XDocument Objects](/dotnet/standard/linq/valid-content-xelement-xdocument-objects).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b21d2-832">下面的示例创建一个具有三个属性的元素。</span><span class="sxs-lookup"><span data-stu-id="b21d2-832">The following example creates an element with three attributes.</span></span> <span data-ttu-id="b21d2-833">然后，它使用此方法将该元素的所有属性替换为单个属性。</span><span class="sxs-lookup"><span data-stu-id="b21d2-833">It then uses this method to replace all of the attributes of the element with a single attribute.</span></span>  
  
```csharp  
XElement root = new XElement("Root",  
    new XAttribute("Att1", 1),  
    new XAttribute("Att2", 2),  
    new XAttribute("Att3", 3)  
);  
root.ReplaceAttributes(  
    new XAttribute("NewAtt1", 101)  
);  
Console.WriteLine(root);  
```  
  
```vb  
Dim root As XElement = <Root Att1="1" Att2="2" Att3="3"/>  
root.ReplaceAttributes(New XAttribute("NewAtt1", 101))  
Console.WriteLine(root)  
```  
  
 <span data-ttu-id="b21d2-834">该示例产生下面的输出：</span><span class="sxs-lookup"><span data-stu-id="b21d2-834">This example produces the following output:</span></span>  
  
```xml  
<Root NewAtt1="101" />  
```  
  
 ]]></format>
        </remarks>
        <related type="Article" href="/dotnet/standard/linq/linq-xml-overview"><span data-ttu-id="b21d2-835">LINQ to XML 概述</span><span class="sxs-lookup"><span data-stu-id="b21d2-835">LINQ to XML overview</span></span></related>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReplaceAttributes">
      <MemberSignature Language="C#" Value="public void ReplaceAttributes (object content);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReplaceAttributes(object content) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XElement.ReplaceAttributes(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReplaceAttributes (content As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ReplaceAttributes(System::Object ^ content);" />
      <MemberSignature Language="F#" Value="member this.ReplaceAttributes : obj -&gt; unit" Usage="xElement.ReplaceAttributes content" />
      <MemberSignature Language="C#" Value="public void ReplaceAttributes (object? content);" FrameworkAlternate="net-5.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="content" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="content"><span data-ttu-id="b21d2-836">替换此元素的属性时将使用的内容。</span><span class="sxs-lookup"><span data-stu-id="b21d2-836">The content that will replace the attributes of this element.</span></span></param>
        <summary><span data-ttu-id="b21d2-837">将此元素的属性替换为指定的内容。</span><span class="sxs-lookup"><span data-stu-id="b21d2-837">Replaces the attributes of this element with the specified content.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b21d2-838">此方法首先删除现有属性。</span><span class="sxs-lookup"><span data-stu-id="b21d2-838">This method first removes existing attributes.</span></span> <span data-ttu-id="b21d2-839">然后添加指定的 `content` 。</span><span class="sxs-lookup"><span data-stu-id="b21d2-839">It then adds the specified `content`.</span></span>  
  
 <span data-ttu-id="b21d2-840">有关可传递到此函数的有效内容的详细信息，请参阅 [system.xml.linq.xelement> 和 XDocument 对象的有效内容](/dotnet/standard/linq/valid-content-xelement-xdocument-objects)。</span><span class="sxs-lookup"><span data-stu-id="b21d2-840">For details about the valid content that can be passed to this function, see [Valid Content of XElement and XDocument Objects](/dotnet/standard/linq/valid-content-xelement-xdocument-objects).</span></span>  
  
 <span data-ttu-id="b21d2-841">此方法将引发 <xref:System.Xml.Linq.XObject.Changed> 和 <xref:System.Xml.Linq.XObject.Changing> 事件。</span><span class="sxs-lookup"><span data-stu-id="b21d2-841">This method will raise the <xref:System.Xml.Linq.XObject.Changed> and the <xref:System.Xml.Linq.XObject.Changing> events.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b21d2-842">下面的示例创建一个具有三个属性的元素。</span><span class="sxs-lookup"><span data-stu-id="b21d2-842">The following example creates an element with three attributes.</span></span> <span data-ttu-id="b21d2-843">然后，它使用此方法将该元素的所有属性替换为单个属性。</span><span class="sxs-lookup"><span data-stu-id="b21d2-843">It then uses this method to replace all of the attributes of the element with a single attribute.</span></span>  
  
```csharp  
XElement root = new XElement("Root",  
    new XAttribute("Att1", 1),  
    new XAttribute("Att2", 2),  
    new XAttribute("Att3", 3)  
);  
root.ReplaceAttributes(  
    new XAttribute("NewAtt1", 101)  
);  
Console.WriteLine(root);  
```  
  
```vb  
Dim root As XElement = <Root Att1="1" Att2="2" Att3="3"/>  
root.ReplaceAttributes(New XAttribute("NewAtt1", 101))  
Console.WriteLine(root)  
```  
  
 <span data-ttu-id="b21d2-844">该示例产生下面的输出：</span><span class="sxs-lookup"><span data-stu-id="b21d2-844">This example produces the following output:</span></span>  
  
```xml  
<Root NewAtt1="101" />  
```  
  
 ]]></format>
        </remarks>
        <related type="Article" href="/dotnet/standard/linq/linq-xml-overview"><span data-ttu-id="b21d2-845">LINQ to XML 概述</span><span class="sxs-lookup"><span data-stu-id="b21d2-845">LINQ to XML overview</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="ReplaceAttributes">
      <MemberSignature Language="C#" Value="public void ReplaceAttributes (params object[] content);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReplaceAttributes(object[] content) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XElement.ReplaceAttributes(System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReplaceAttributes (ParamArray content As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ReplaceAttributes(... cli::array &lt;System::Object ^&gt; ^ content);" />
      <MemberSignature Language="F#" Value="member this.ReplaceAttributes : obj[] -&gt; unit" Usage="xElement.ReplaceAttributes content" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="content" Type="System.Object[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName Language="C#">[System.ParamArray]</AttributeName>
              <AttributeName Language="F#">[&lt;System.ParamArray&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="content"><span data-ttu-id="b21d2-846">内容对象的参数列表。</span><span class="sxs-lookup"><span data-stu-id="b21d2-846">A parameter list of content objects.</span></span></param>
        <summary><span data-ttu-id="b21d2-847">将此元素的属性替换为指定的内容。</span><span class="sxs-lookup"><span data-stu-id="b21d2-847">Replaces the attributes of this element with the specified content.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b21d2-848">此方法首先删除现有属性。</span><span class="sxs-lookup"><span data-stu-id="b21d2-848">This method first removes existing attributes.</span></span> <span data-ttu-id="b21d2-849">然后添加指定的 `content` 。</span><span class="sxs-lookup"><span data-stu-id="b21d2-849">It then adds the specified `content`.</span></span>  
  
 <span data-ttu-id="b21d2-850">有关可传递到此函数的有效内容的详细信息，请参阅 [system.xml.linq.xelement> 和 XDocument 对象的有效内容](/dotnet/standard/linq/valid-content-xelement-xdocument-objects)。</span><span class="sxs-lookup"><span data-stu-id="b21d2-850">For details about the valid content that can be passed to this function, see [Valid Content of XElement and XDocument Objects](/dotnet/standard/linq/valid-content-xelement-xdocument-objects).</span></span>  
  
 <span data-ttu-id="b21d2-851">此方法将引发 <xref:System.Xml.Linq.XObject.Changed> 和 <xref:System.Xml.Linq.XObject.Changing> 事件。</span><span class="sxs-lookup"><span data-stu-id="b21d2-851">This method will raise the <xref:System.Xml.Linq.XObject.Changed> and the <xref:System.Xml.Linq.XObject.Changing> events.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b21d2-852">下面的示例创建一个具有三个属性的元素。</span><span class="sxs-lookup"><span data-stu-id="b21d2-852">The following example creates an element with three attributes.</span></span> <span data-ttu-id="b21d2-853">然后，将属性替换为其他特性。</span><span class="sxs-lookup"><span data-stu-id="b21d2-853">It then replaces the attributes with other attributes.</span></span>  
  
```csharp  
XElement root = new XElement("Root",  
    new XAttribute("Att1", 1),  
    new XAttribute("Att2", 2),  
    new XAttribute("Att3", 3)  
);  
root.ReplaceAttributes(  
    new XAttribute("NewAtt1", 101),  
    new XAttribute("NewAtt2", 102),  
    new XAttribute("NewAtt3", 103)  
);  
Console.WriteLine(root);  
```  
  
```vb  
Dim root As XElement = <Root Att1="1" Att2="2" Att3="3"/>  
root.ReplaceAttributes( _  
New XAttribute("NewAtt1", 101), _  
New XAttribute("NewAtt2", 102), _  
New XAttribute("NewAtt3", 103))  
Console.WriteLine(root)  
```  
  
 <span data-ttu-id="b21d2-854">该示例产生下面的输出：</span><span class="sxs-lookup"><span data-stu-id="b21d2-854">This example produces the following output:</span></span>  
  
```xml  
<Root NewAtt1="101" NewAtt2="102" NewAtt3="103" />  
```  
  
 ]]></format>
        </remarks>
        <related type="Article" href="/dotnet/standard/linq/linq-xml-overview"><span data-ttu-id="b21d2-855">LINQ to XML 概述</span><span class="sxs-lookup"><span data-stu-id="b21d2-855">LINQ to XML overview</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Save">
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="b21d2-856">序列化此元素的基础 XML 树。</span><span class="sxs-lookup"><span data-stu-id="b21d2-856">Serialize this element's underlying XML tree.</span></span> <span data-ttu-id="b21d2-857">可以将输出保存到文件、<see cref="T:System.Xml.XmlTextWriter" />、<see cref="T:System.IO.TextWriter" /> 或 <see cref="T:System.Xml.XmlWriter" />。</span><span class="sxs-lookup"><span data-stu-id="b21d2-857">The output can be saved to a file, an <see cref="T:System.Xml.XmlTextWriter" />, a <see cref="T:System.IO.TextWriter" />, or an <see cref="T:System.Xml.XmlWriter" />.</span></span> <span data-ttu-id="b21d2-858">还可以禁用格式设置（缩进）。</span><span class="sxs-lookup"><span data-stu-id="b21d2-858">Optionally, formatting (indenting) can be disabled.</span></span></summary>
        <related type="Article" href="/dotnet/standard/linq/linq-xml-overview"><span data-ttu-id="b21d2-859">LINQ to XML 概述</span><span class="sxs-lookup"><span data-stu-id="b21d2-859">LINQ to XML overview</span></span></related>
      </Docs>
    </MemberGroup>
    <Member MemberName="Save">
      <MemberSignature Language="C#" Value="public void Save (System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Save(class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XElement.Save(System.IO.Stream)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Save (stream As Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Save(System::IO::Stream ^ stream);" />
      <MemberSignature Language="F#" Value="member this.Save : System.IO.Stream -&gt; unit" Usage="xElement.Save stream" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="stream"><span data-ttu-id="b21d2-860">将此 <see cref="T:System.Xml.Linq.XElement" /> 输出到的流。</span><span class="sxs-lookup"><span data-stu-id="b21d2-860">The stream to output this <see cref="T:System.Xml.Linq.XElement" /> to.</span></span></param>
        <summary><span data-ttu-id="b21d2-861">将此 <see cref="T:System.Xml.Linq.XElement" /> 输出到指定的 <see cref="T:System.IO.Stream" />。</span><span class="sxs-lookup"><span data-stu-id="b21d2-861">Outputs this <see cref="T:System.Xml.Linq.XElement" /> to the specified <see cref="T:System.IO.Stream" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b21d2-862">将缩进序列化的 XML。</span><span class="sxs-lookup"><span data-stu-id="b21d2-862">The serialized XML will be indented.</span></span> <span data-ttu-id="b21d2-863">将删除所有无意义的空白，并会添加额外的空白，以便正确缩进 XML。</span><span class="sxs-lookup"><span data-stu-id="b21d2-863">All insignificant white space will be removed, and additional white space will be added so that the XML will be properly indented.</span></span> <span data-ttu-id="b21d2-864">此方法的行为是不会保留无意义的空白。</span><span class="sxs-lookup"><span data-stu-id="b21d2-864">The behavior of this method is that insignificant white space will not be preserved.</span></span>  
  
 <span data-ttu-id="b21d2-865">如果要控制空白，请使用作为参数的的重载 <xref:System.Xml.Linq.XElement.Save%2A> <xref:System.Xml.Linq.SaveOptions> 。</span><span class="sxs-lookup"><span data-stu-id="b21d2-865">If you want to control white space, use the overload of <xref:System.Xml.Linq.XElement.Save%2A> that takes <xref:System.Xml.Linq.SaveOptions> as a parameter.</span></span> <span data-ttu-id="b21d2-866">使用 <xref:System.Xml.Linq.SaveOptions.DisableFormatting> 选项保存未缩进的 XML。</span><span class="sxs-lookup"><span data-stu-id="b21d2-866">Use the <xref:System.Xml.Linq.SaveOptions.DisableFormatting> option to save unindented XML.</span></span> <span data-ttu-id="b21d2-867">这将导致编写器完全按 XML 树中的表示形式写入所有空格。</span><span class="sxs-lookup"><span data-stu-id="b21d2-867">This will cause the writer to write all white spaces exactly as represented in the XML tree.</span></span>  
  
 <span data-ttu-id="b21d2-868"><xref:System.Xml.Linq.SaveOptions.OmitDuplicateNamespaces>如果要删除重复的命名空间声明，请使用选项。</span><span class="sxs-lookup"><span data-stu-id="b21d2-868">Use the <xref:System.Xml.Linq.SaveOptions.OmitDuplicateNamespaces> option if you want to remove duplicate namespace declarations.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Save">
      <MemberSignature Language="C#" Value="public void Save (System.IO.TextWriter textWriter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Save(class System.IO.TextWriter textWriter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XElement.Save(System.IO.TextWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Save (textWriter As TextWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Save(System::IO::TextWriter ^ textWriter);" />
      <MemberSignature Language="F#" Value="member this.Save : System.IO.TextWriter -&gt; unit" Usage="xElement.Save textWriter" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="textWriter" Type="System.IO.TextWriter" />
      </Parameters>
      <Docs>
        <param name="textWriter"><span data-ttu-id="b21d2-869">将向其中写入 <see cref="T:System.IO.TextWriter" /> 的 <see cref="T:System.Xml.Linq.XElement" />。</span><span class="sxs-lookup"><span data-stu-id="b21d2-869">A <see cref="T:System.IO.TextWriter" /> that the <see cref="T:System.Xml.Linq.XElement" /> will be written to.</span></span></param>
        <summary><span data-ttu-id="b21d2-870">将此元素序列化为 <see cref="T:System.IO.TextWriter" />。</span><span class="sxs-lookup"><span data-stu-id="b21d2-870">Serialize this element to a <see cref="T:System.IO.TextWriter" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b21d2-871">将缩进序列化的 XML。</span><span class="sxs-lookup"><span data-stu-id="b21d2-871">The serialized XML will be indented.</span></span> <span data-ttu-id="b21d2-872">将删除所有无意义的空白，并会添加额外的空白，以便正确缩进 XML。</span><span class="sxs-lookup"><span data-stu-id="b21d2-872">All insignificant white space will be removed, and additional white space will be added so that the XML will be properly indented.</span></span> <span data-ttu-id="b21d2-873">此方法的行为是不会保留空白。</span><span class="sxs-lookup"><span data-stu-id="b21d2-873">The behavior of this method is that white space will not be preserved.</span></span>  
  
 <span data-ttu-id="b21d2-874">如果要控制空白，请使用的重载，以便将 <xref:System.Xml.Linq.XElement.Save%2A> 指定 <xref:System.Xml.Linq.SaveOptions> 为参数。</span><span class="sxs-lookup"><span data-stu-id="b21d2-874">If you want to control white space, use the overload of <xref:System.Xml.Linq.XElement.Save%2A> that allows you to specify <xref:System.Xml.Linq.SaveOptions> as a parameter.</span></span> <span data-ttu-id="b21d2-875">有关详细信息，请参阅 [在加载或分析 XML 时保留空白](/dotnet/standard/linq/preserve-white-space-loading-parsing-xml) ，并 [在序列化时保留空白区域](/dotnet/standard/linq/preserve-white-space-serializing)。</span><span class="sxs-lookup"><span data-stu-id="b21d2-875">For more information, see [Preserve white space while loading or parsing XML](/dotnet/standard/linq/preserve-white-space-loading-parsing-xml) and [Preserve white space while serializing](/dotnet/standard/linq/preserve-white-space-serializing).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b21d2-876">下面的示例创建一个 <xref:System.Xml.Linq.XElement> ，将文档保存到 <xref:System.IO.StringWriter> ，然后将该字符串打印到控制台。</span><span class="sxs-lookup"><span data-stu-id="b21d2-876">The following example creates an <xref:System.Xml.Linq.XElement>, saves the document to a <xref:System.IO.StringWriter>, and then prints the string to the console.</span></span>  
  
```csharp  
XElement root = XElement.Parse(@"<Root> <Child> Text </Child> </Root>");  
using (StringWriter sw = new StringWriter()) {  
    root.Save(sw);  
    Console.WriteLine(sw.ToString());  
}  
```  
  
```vb  
Dim root As XElement = <Root><Child> Text </Child></Root>  
Using sw = New StringWriter()  
    root.Save(sw)  
    Console.WriteLine(sw.ToString())  
End Using  
```  
  
 <span data-ttu-id="b21d2-877">该示例产生下面的输出：</span><span class="sxs-lookup"><span data-stu-id="b21d2-877">This example produces the following output:</span></span>  
  
```xml  
<?xml version="1.0" encoding="utf-16"?>  
<Root>  
  <Child> Text </Child>  
</Root>  
```  
  
 ]]></format>
        </remarks>
        <related type="Article" href="/dotnet/standard/linq/linq-xml-overview"><span data-ttu-id="b21d2-878">LINQ to XML 概述</span><span class="sxs-lookup"><span data-stu-id="b21d2-878">LINQ to XML overview</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Save">
      <MemberSignature Language="C#" Value="public void Save (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Save(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XElement.Save(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Save (fileName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Save(System::String ^ fileName);" />
      <MemberSignature Language="F#" Value="member this.Save : string -&gt; unit" Usage="xElement.Save fileName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="fileName"><span data-ttu-id="b21d2-879">一个包含文件名称的 <see cref="T:System.String" />。</span><span class="sxs-lookup"><span data-stu-id="b21d2-879">A <see cref="T:System.String" /> that contains the name of the file.</span></span></param>
        <summary><span data-ttu-id="b21d2-880">将此元素序列化为文件。</span><span class="sxs-lookup"><span data-stu-id="b21d2-880">Serialize this element to a file.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b21d2-881">将缩进序列化的 XML。</span><span class="sxs-lookup"><span data-stu-id="b21d2-881">The serialized XML will be indented.</span></span> <span data-ttu-id="b21d2-882">将删除所有无意义的空白，并会添加额外的空白，以便正确缩进 XML。</span><span class="sxs-lookup"><span data-stu-id="b21d2-882">All insignificant white space will be removed, and additional white space will be added so that the XML will be properly indented.</span></span> <span data-ttu-id="b21d2-883">此方法的行为是不会保留 XML 树中无意义的空白节点。</span><span class="sxs-lookup"><span data-stu-id="b21d2-883">The behavior of this method is that insignificant white space nodes in the XML tree will not be preserved.</span></span>  
  
 <span data-ttu-id="b21d2-884">如果要控制空白，请使用的重载，以便将 <xref:System.Xml.Linq.XElement.Save%2A> 指定 <xref:System.Xml.Linq.SaveOptions> 为参数。</span><span class="sxs-lookup"><span data-stu-id="b21d2-884">If you want to control white space, use the overload of <xref:System.Xml.Linq.XElement.Save%2A> that allows you to specify <xref:System.Xml.Linq.SaveOptions> as a parameter.</span></span> <span data-ttu-id="b21d2-885">有关详细信息，请参阅 [在加载或分析 XML 时保留空白](/dotnet/standard/linq/preserve-white-space-loading-parsing-xml) ，并 [在序列化时保留空白区域](/dotnet/standard/linq/preserve-white-space-serializing)。</span><span class="sxs-lookup"><span data-stu-id="b21d2-885">For more information, see [Preserve white space while loading or parsing XML](/dotnet/standard/linq/preserve-white-space-loading-parsing-xml) and [Preserve white space while serializing](/dotnet/standard/linq/preserve-white-space-serializing).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b21d2-886">下面的示例创建一个 <xref:System.Xml.Linq.XElement> ，将文档保存到文件，然后将文件打印到控制台。</span><span class="sxs-lookup"><span data-stu-id="b21d2-886">The following example creates an <xref:System.Xml.Linq.XElement>, saves the document to a file, and then prints the file to the console.</span></span>  
  
```csharp  
XElement root = new XElement("Root",  
    new XElement("Child", "child content")  
);  
root.Save("Root.xml");  
string str = File.ReadAllText("Root.xml");  
Console.WriteLine(str);  
```  
  
```vb  
Dim root As XElement = _   
        <Root>  
            <Child>child content</Child>  
        </Root>  
root.Save("Root.xml")  
Dim Str As String = File.ReadAllText("Root.xml")  
Console.WriteLine(Str)  
```  
  
 <span data-ttu-id="b21d2-887">该示例产生下面的输出：</span><span class="sxs-lookup"><span data-stu-id="b21d2-887">This example produces the following output:</span></span>  
  
```xml  
<?xml version="1.0" encoding="utf-8"?>  
<Root>  
  <Child>child content</Child>  
</Root>  
```  
  
 ]]></format>
        </remarks>
        <related type="Article" href="/dotnet/standard/linq/linq-xml-overview"><span data-ttu-id="b21d2-888">LINQ to XML 概述</span><span class="sxs-lookup"><span data-stu-id="b21d2-888">LINQ to XML overview</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Save">
      <MemberSignature Language="C#" Value="public void Save (System.Xml.XmlWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Save(class System.Xml.XmlWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XElement.Save(System.Xml.XmlWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Save (writer As XmlWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Save(System::Xml::XmlWriter ^ writer);" />
      <MemberSignature Language="F#" Value="member this.Save : System.Xml.XmlWriter -&gt; unit" Usage="xElement.Save writer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
      </Parameters>
      <Docs>
        <param name="writer"><span data-ttu-id="b21d2-889">将向其中写入 <see cref="T:System.Xml.XmlWriter" /> 的 <see cref="T:System.Xml.Linq.XElement" />。</span><span class="sxs-lookup"><span data-stu-id="b21d2-889">A <see cref="T:System.Xml.XmlWriter" /> that the <see cref="T:System.Xml.Linq.XElement" /> will be written to.</span></span></param>
        <summary><span data-ttu-id="b21d2-890">将此元素序列化为 <see cref="T:System.Xml.XmlWriter" />。</span><span class="sxs-lookup"><span data-stu-id="b21d2-890">Serialize this element to an <see cref="T:System.Xml.XmlWriter" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="b21d2-891">下面的示例演示如何将一个 <xref:System.Xml.Linq.XElement> 保存到一个 <xref:System.Xml.XmlWriter>。</span><span class="sxs-lookup"><span data-stu-id="b21d2-891">The following example shows how to save an <xref:System.Xml.Linq.XElement> to an <xref:System.Xml.XmlWriter>.</span></span>  
  
```csharp  
StringBuilder sb = new StringBuilder();  
XmlWriterSettings xws = new XmlWriterSettings();  
xws.OmitXmlDeclaration = true;  
using (XmlWriter xw = XmlWriter.Create(sb, xws)) {  
    XElement root = new XElement("Root",  
        new XElement("Child", "child content")  
    );  
    root.Save(xw);  
}  
Console.WriteLine(sb.ToString());  
```  
  
```vb  
Dim sb As StringBuilder = New StringBuilder()  
Dim xws As XmlWriterSettings = New XmlWriterSettings()  
xws.OmitXmlDeclaration = True  
Using xw = XmlWriter.Create(sb, xws)  
    Dim root As XElement = <Root>  
                               <Child>child content</Child>  
                           </Root>  
    root.Save(xw)  
End Using  
Console.WriteLine(sb.ToString())  
```  
  
 <span data-ttu-id="b21d2-892">该示例产生下面的输出：</span><span class="sxs-lookup"><span data-stu-id="b21d2-892">This example produces the following output:</span></span>  
  
```xml  
<Root><Child>child content</Child></Root>  
```  
  
 ]]></format>
        </remarks>
        <related type="Article" href="/dotnet/standard/linq/linq-xml-overview"><span data-ttu-id="b21d2-893">LINQ to XML 概述</span><span class="sxs-lookup"><span data-stu-id="b21d2-893">LINQ to XML overview</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Save">
      <MemberSignature Language="C#" Value="public void Save (System.IO.Stream stream, System.Xml.Linq.SaveOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Save(class System.IO.Stream stream, valuetype System.Xml.Linq.SaveOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XElement.Save(System.IO.Stream,System.Xml.Linq.SaveOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Save (stream As Stream, options As SaveOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Save(System::IO::Stream ^ stream, System::Xml::Linq::SaveOptions options);" />
      <MemberSignature Language="F#" Value="member this.Save : System.IO.Stream * System.Xml.Linq.SaveOptions -&gt; unit" Usage="xElement.Save (stream, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="options" Type="System.Xml.Linq.SaveOptions" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="stream"><span data-ttu-id="b21d2-894">将此 <see cref="T:System.Xml.Linq.XElement" /> 输出到的流。</span><span class="sxs-lookup"><span data-stu-id="b21d2-894">The stream to output this <see cref="T:System.Xml.Linq.XElement" /> to.</span></span></param>
        <param name="options"><span data-ttu-id="b21d2-895">一个 <see cref="T:System.Xml.Linq.SaveOptions" /> 对象，该对象指定格式设置行为。</span><span class="sxs-lookup"><span data-stu-id="b21d2-895">A <see cref="T:System.Xml.Linq.SaveOptions" /> object that specifies formatting behavior.</span></span></param>
        <summary><span data-ttu-id="b21d2-896">将此 <see cref="T:System.Xml.Linq.XElement" /> 输出到指定的 <see cref="T:System.IO.Stream" />，（可选）并指定格式设置行为。</span><span class="sxs-lookup"><span data-stu-id="b21d2-896">Outputs this <see cref="T:System.Xml.Linq.XElement" /> to the specified <see cref="T:System.IO.Stream" />, optionally specifying formatting behavior.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b21d2-897">默认情况下， `options` 设置为 <xref:System.Xml.Linq.SaveOptions.None> 。</span><span class="sxs-lookup"><span data-stu-id="b21d2-897">By default the `options` are set to <xref:System.Xml.Linq.SaveOptions.None>.</span></span> <span data-ttu-id="b21d2-898">此选项将删除所有无关的无意义空格，并添加适当的无意义空白，以便正确缩进 XML。</span><span class="sxs-lookup"><span data-stu-id="b21d2-898">This option will remove all extraneous insignificant white space, and add appropriate insignificant white space so that the XML is properly indented.</span></span>  
  
 <span data-ttu-id="b21d2-899">如果要保存未缩进的 XML，请指定的 <xref:System.Xml.Linq.SaveOptions.DisableFormatting> 标志 `options` 。</span><span class="sxs-lookup"><span data-stu-id="b21d2-899">If you want to save unindented XML, specify the <xref:System.Xml.Linq.SaveOptions.DisableFormatting> flag for `options`.</span></span> <span data-ttu-id="b21d2-900">这将导致编写器完全按 XML 树中的表示形式写入所有空格。</span><span class="sxs-lookup"><span data-stu-id="b21d2-900">This will cause the writer to write all white spaces exactly as represented in the XML tree.</span></span>  
  
 <span data-ttu-id="b21d2-901"><xref:System.Xml.Linq.SaveOptions.OmitDuplicateNamespaces>如果要删除重复的命名空间声明，请使用选项。</span><span class="sxs-lookup"><span data-stu-id="b21d2-901">Use <xref:System.Xml.Linq.SaveOptions.OmitDuplicateNamespaces> option if you want to remove duplicate namespace declarations.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Save">
      <MemberSignature Language="C#" Value="public void Save (System.IO.TextWriter textWriter, System.Xml.Linq.SaveOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Save(class System.IO.TextWriter textWriter, valuetype System.Xml.Linq.SaveOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XElement.Save(System.IO.TextWriter,System.Xml.Linq.SaveOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Save (textWriter As TextWriter, options As SaveOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Save(System::IO::TextWriter ^ textWriter, System::Xml::Linq::SaveOptions options);" />
      <MemberSignature Language="F#" Value="member this.Save : System.IO.TextWriter * System.Xml.Linq.SaveOptions -&gt; unit" Usage="xElement.Save (textWriter, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="textWriter" Type="System.IO.TextWriter" />
        <Parameter Name="options" Type="System.Xml.Linq.SaveOptions" />
      </Parameters>
      <Docs>
        <param name="textWriter"><span data-ttu-id="b21d2-902">要将 XML 输出到的 <see cref="T:System.IO.TextWriter" />。</span><span class="sxs-lookup"><span data-stu-id="b21d2-902">The <see cref="T:System.IO.TextWriter" /> to output the XML to.</span></span></param>
        <param name="options"><span data-ttu-id="b21d2-903">指定格式设置行为的 <see cref="T:System.Xml.Linq.SaveOptions" />。</span><span class="sxs-lookup"><span data-stu-id="b21d2-903">A <see cref="T:System.Xml.Linq.SaveOptions" /> that specifies formatting behavior.</span></span></param>
        <summary><span data-ttu-id="b21d2-904">将此元素序列化为 <see cref="T:System.IO.TextWriter" />，并可以选择禁用格式设置。</span><span class="sxs-lookup"><span data-stu-id="b21d2-904">Serialize this element to a <see cref="T:System.IO.TextWriter" />, optionally disabling formatting.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b21d2-905">如果要保存未缩进的 XML，请指定的 <xref:System.Xml.Linq.SaveOptions.DisableFormatting> 标志 `options` 。</span><span class="sxs-lookup"><span data-stu-id="b21d2-905">If you want to save unindented XML, specify the <xref:System.Xml.Linq.SaveOptions.DisableFormatting> flag for `options`.</span></span> <span data-ttu-id="b21d2-906">这将导致编写器完全按 XML 树中的表示方式写入所有空格。</span><span class="sxs-lookup"><span data-stu-id="b21d2-906">This will cause the writer to write all white space exactly as represented in the XML tree.</span></span>  
  
 <span data-ttu-id="b21d2-907">如果要保存缩进的 XML，请勿 <xref:System.Xml.Linq.SaveOptions.DisableFormatting> 为指定标志 `options` 。</span><span class="sxs-lookup"><span data-stu-id="b21d2-907">If you want to save indented XML, do not specify the <xref:System.Xml.Linq.SaveOptions.DisableFormatting> flag for `options`.</span></span> <span data-ttu-id="b21d2-908">这将删除所有无关的无意义空格，并添加适当的无意义空白，以便正确缩进 XML。</span><span class="sxs-lookup"><span data-stu-id="b21d2-908">This will remove all extraneous insignificant white space, and add appropriate insignificant white space so that the XML is properly indented.</span></span> <span data-ttu-id="b21d2-909">这是默认行为，以及 <xref:System.Xml.Linq.XElement.Save%2A> 不作为参数的方法的重载行为 `options` 。</span><span class="sxs-lookup"><span data-stu-id="b21d2-909">This is the default behavior, and the behavior of the overloads of the <xref:System.Xml.Linq.XElement.Save%2A> methods that do not take `options` as a parameter.</span></span>  
  
 <span data-ttu-id="b21d2-910">有关详细信息，请参阅 [在加载或分析 XML 时保留空白](/dotnet/standard/linq/preserve-white-space-loading-parsing-xml) ，并 [在序列化时保留空白区域](/dotnet/standard/linq/preserve-white-space-serializing)。</span><span class="sxs-lookup"><span data-stu-id="b21d2-910">For more information, see [Preserve white space while loading or parsing XML](/dotnet/standard/linq/preserve-white-space-loading-parsing-xml) and [Preserve white space while serializing](/dotnet/standard/linq/preserve-white-space-serializing).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b21d2-911">下面的示例演示了此方法的两种用法。</span><span class="sxs-lookup"><span data-stu-id="b21d2-911">The following example shows two uses of this method.</span></span> <span data-ttu-id="b21d2-912">第一次使用将保留空白。</span><span class="sxs-lookup"><span data-stu-id="b21d2-912">The first use preserves white space.</span></span> <span data-ttu-id="b21d2-913">第二个序列化 <xref:System.Xml.Linq.XElement> 和格式设置。</span><span class="sxs-lookup"><span data-stu-id="b21d2-913">The second serializes the <xref:System.Xml.Linq.XElement> with formatting.</span></span> <span data-ttu-id="b21d2-914">由于文档在构造中没有空白，因此保留空白将输出 XML 而不进行任何缩进。</span><span class="sxs-lookup"><span data-stu-id="b21d2-914">Because the document has no white space in it as constructed, preserving white space outputs the XML without any indenting.</span></span>  
  
```csharp  
XElement root = XElement.Parse(@"<Root> <Child> Text </Child> </Root>");  
  
using (StringWriter sw = new StringWriter())  
{  
    root.Save(sw, SaveOptions.DisableFormatting);  
    Console.WriteLine(sw.ToString());  
}  
  
Console.WriteLine("=====");  
  
using (StringWriter sw = new StringWriter())  
{  
    root.Save(sw, SaveOptions.None);  
    Console.WriteLine(sw.ToString());  
}  
```  
  
```vb  
Dim root As XElement = <Root><Child> Text </Child></Root>  
  
Using sw = New StringWriter()  
    root.Save(sw, SaveOptions.DisableFormatting)  
    Console.WriteLine(sw.ToString())  
End Using  
  
Console.WriteLine("=====")  
  
Using sw = New StringWriter()  
    root.Save(sw, SaveOptions.None)  
    Console.WriteLine(sw.ToString())  
End Using  
```  
  
 <span data-ttu-id="b21d2-915">该示例产生下面的输出：</span><span class="sxs-lookup"><span data-stu-id="b21d2-915">This example produces the following output:</span></span>  
  
```  
<?xml version="1.0" encoding="utf-16"?><Root><Child> Text </Child></Root>  
=====  
<?xml version="1.0" encoding="utf-16"?>  
<Root>  
  <Child> Text </Child>  
</Root>  
```  
  
 ]]></format>
        </remarks>
        <related type="Article" href="/dotnet/standard/linq/linq-xml-overview"><span data-ttu-id="b21d2-916">LINQ to XML 概述</span><span class="sxs-lookup"><span data-stu-id="b21d2-916">LINQ to XML overview</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Save">
      <MemberSignature Language="C#" Value="public void Save (string fileName, System.Xml.Linq.SaveOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Save(string fileName, valuetype System.Xml.Linq.SaveOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XElement.Save(System.String,System.Xml.Linq.SaveOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Save (fileName As String, options As SaveOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Save(System::String ^ fileName, System::Xml::Linq::SaveOptions options);" />
      <MemberSignature Language="F#" Value="member this.Save : string * System.Xml.Linq.SaveOptions -&gt; unit" Usage="xElement.Save (fileName, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="options" Type="System.Xml.Linq.SaveOptions" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="fileName"><span data-ttu-id="b21d2-917">一个包含文件名称的 <see cref="T:System.String" />。</span><span class="sxs-lookup"><span data-stu-id="b21d2-917">A <see cref="T:System.String" /> that contains the name of the file.</span></span></param>
        <param name="options"><span data-ttu-id="b21d2-918">指定格式设置行为的 <see cref="T:System.Xml.Linq.SaveOptions" />。</span><span class="sxs-lookup"><span data-stu-id="b21d2-918">A <see cref="T:System.Xml.Linq.SaveOptions" /> that specifies formatting behavior.</span></span></param>
        <summary><span data-ttu-id="b21d2-919">将此元素序列化为文件，并可以选择禁用格式设置。</span><span class="sxs-lookup"><span data-stu-id="b21d2-919">Serialize this element to a file, optionally disabling formatting.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b21d2-920">如果要保存未缩进的 XML，请指定的 <xref:System.Xml.Linq.SaveOptions.DisableFormatting> 标志 `options` 。</span><span class="sxs-lookup"><span data-stu-id="b21d2-920">If you want to save unindented XML, specify the <xref:System.Xml.Linq.SaveOptions.DisableFormatting> flag for `options`.</span></span> <span data-ttu-id="b21d2-921">这将导致编写器完全按 XML 树中的表示方式写入所有空格。</span><span class="sxs-lookup"><span data-stu-id="b21d2-921">This will cause the writer to write all white space exactly as represented in the XML tree.</span></span>  
  
 <span data-ttu-id="b21d2-922">如果要保存缩进的 XML，请勿 <xref:System.Xml.Linq.SaveOptions.DisableFormatting> 为指定标志 `options` 。</span><span class="sxs-lookup"><span data-stu-id="b21d2-922">If you want to save indented XML, do not specify the <xref:System.Xml.Linq.SaveOptions.DisableFormatting> flag for `options`.</span></span> <span data-ttu-id="b21d2-923">这将删除所有无关的无意义空格，并添加适当的无意义空白，以便正确缩进 XML。</span><span class="sxs-lookup"><span data-stu-id="b21d2-923">This will remove all extraneous insignificant white space, and add appropriate insignificant white space so that the XML is properly indented.</span></span> <span data-ttu-id="b21d2-924">这是默认行为，以及 <xref:System.Xml.Linq.XElement.Save%2A> 不作为参数的方法的重载行为 `options` 。</span><span class="sxs-lookup"><span data-stu-id="b21d2-924">This is the default behavior, and the behavior of the overloads of the <xref:System.Xml.Linq.XElement.Save%2A> methods that do not take `options` as a parameter.</span></span>  
  
 <span data-ttu-id="b21d2-925">有关详细信息，请参阅 [在加载或分析 XML 时保留空白](/dotnet/standard/linq/preserve-white-space-loading-parsing-xml) ，并 [在序列化时保留空白区域](/dotnet/standard/linq/preserve-white-space-serializing)。</span><span class="sxs-lookup"><span data-stu-id="b21d2-925">For more information, see [Preserve white space while loading or parsing XML](/dotnet/standard/linq/preserve-white-space-loading-parsing-xml) and [Preserve white space while serializing](/dotnet/standard/linq/preserve-white-space-serializing).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b21d2-926">下面的示例演示了此方法的两种用法。</span><span class="sxs-lookup"><span data-stu-id="b21d2-926">The following example shows two uses of this method.</span></span> <span data-ttu-id="b21d2-927">第一次使用将保留空白。</span><span class="sxs-lookup"><span data-stu-id="b21d2-927">The first use preserves white space.</span></span> <span data-ttu-id="b21d2-928">第二个序列化， <xref:System.Xml.Linq.XElement> 并将设置为格式。</span><span class="sxs-lookup"><span data-stu-id="b21d2-928">The second one serializes the <xref:System.Xml.Linq.XElement> with formatting.</span></span>  
  
```csharp  
string str;  
XElement root = XElement.Parse(@"<Root> <Child> Text </Child> </Root>");  
  
root.Save("Root.xml", SaveOptions.DisableFormatting);  
str = File.ReadAllText("Root.xml");  
Console.WriteLine(str);  
  
Console.WriteLine("=====");  
  
root.Save("Root.xml", SaveOptions.None);  
str = File.ReadAllText("Root.xml");  
Console.WriteLine(str);  
```  
  
```vb  
Dim str As String  
Dim root As XElement = <Root><Child> Text </Child></Root>  
  
root.Save("Root.xml", SaveOptions.DisableFormatting)  
str = File.ReadAllText("Root.xml")  
Console.WriteLine(str)  
  
Console.WriteLine("=====")  
  
root.Save("Root.xml", SaveOptions.None)  
str = File.ReadAllText("Root.xml")  
Console.WriteLine(str)  
```  
  
 <span data-ttu-id="b21d2-929">该示例产生下面的输出：</span><span class="sxs-lookup"><span data-stu-id="b21d2-929">This example produces the following output:</span></span>  
  
```  
<?xml version="1.0" encoding="utf-8"?><Root><Child> Text </Child></Root>  
=====  
<?xml version="1.0" encoding="utf-8"?>  
<Root>  
  <Child> Text </Child>  
</Root>  
```  
  
 ]]></format>
        </remarks>
        <related type="Article" href="/dotnet/standard/linq/linq-xml-overview"><span data-ttu-id="b21d2-930">LINQ to XML 概述</span><span class="sxs-lookup"><span data-stu-id="b21d2-930">LINQ to XML overview</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="SaveAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task SaveAsync (System.Xml.XmlWriter writer, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task SaveAsync(class System.Xml.XmlWriter writer, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XElement.SaveAsync(System.Xml.XmlWriter,System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Function SaveAsync (writer As XmlWriter, cancellationToken As CancellationToken) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ SaveAsync(System::Xml::XmlWriter ^ writer, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.SaveAsync : System.Xml.XmlWriter * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="xElement.SaveAsync (writer, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="writer"><span data-ttu-id="b21d2-931">要向其输出 XML 的编写器。</span><span class="sxs-lookup"><span data-stu-id="b21d2-931">The writer to output the XML to.</span></span></param>
        <param name="cancellationToken"><span data-ttu-id="b21d2-932">可用于请求异步操作取消的标志。</span><span class="sxs-lookup"><span data-stu-id="b21d2-932">A token that can be used to request cancellation of the asynchronous operation.</span></span></param>
        <summary><span data-ttu-id="b21d2-933">将此 <see cref="T:System.Xml.Linq.XElement" /> 异步输出到 <see cref="T:System.Xml.XmlWriter" />。</span><span class="sxs-lookup"><span data-stu-id="b21d2-933">Asynchronously outputs this <see cref="T:System.Xml.Linq.XElement" /> to an <see cref="T:System.Xml.XmlWriter" />.</span></span></summary>
        <returns><span data-ttu-id="b21d2-934">表示异步保存操作的任务。</span><span class="sxs-lookup"><span data-stu-id="b21d2-934">A task representing the asynchronous save operation.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SaveAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task SaveAsync (System.IO.Stream stream, System.Xml.Linq.SaveOptions options, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task SaveAsync(class System.IO.Stream stream, valuetype System.Xml.Linq.SaveOptions options, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XElement.SaveAsync(System.IO.Stream,System.Xml.Linq.SaveOptions,System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Function SaveAsync (stream As Stream, options As SaveOptions, cancellationToken As CancellationToken) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ SaveAsync(System::IO::Stream ^ stream, System::Xml::Linq::SaveOptions options, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.SaveAsync : System.IO.Stream * System.Xml.Linq.SaveOptions * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="xElement.SaveAsync (stream, options, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="options" Type="System.Xml.Linq.SaveOptions" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="stream"><span data-ttu-id="b21d2-935">要向其输出 XML 的流。</span><span class="sxs-lookup"><span data-stu-id="b21d2-935">The stream to output the XML to.</span></span></param>
        <param name="options"><span data-ttu-id="b21d2-936">枚举值的按位组合，这些枚举值指定序列化选项。</span><span class="sxs-lookup"><span data-stu-id="b21d2-936">A bitwise combination of the enumeration values that specify the serialization options.</span></span></param>
        <param name="cancellationToken"><span data-ttu-id="b21d2-937">可用于请求异步操作取消的标志。</span><span class="sxs-lookup"><span data-stu-id="b21d2-937">A token that can be used to request cancellation of the asynchronous operation.</span></span></param>
        <summary><span data-ttu-id="b21d2-938">将此 <see cref="T:System.Xml.Linq.XElement" /> 异步输出到 <see cref="T:System.IO.Stream" />。</span><span class="sxs-lookup"><span data-stu-id="b21d2-938">Asynchronously outputs this <see cref="T:System.Xml.Linq.XElement" /> to a <see cref="T:System.IO.Stream" />.</span></span></summary>
        <returns><span data-ttu-id="b21d2-939">表示异步保存操作的任务。</span><span class="sxs-lookup"><span data-stu-id="b21d2-939">A task representing the asynchronous save operation.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SaveAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task SaveAsync (System.IO.TextWriter textWriter, System.Xml.Linq.SaveOptions options, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task SaveAsync(class System.IO.TextWriter textWriter, valuetype System.Xml.Linq.SaveOptions options, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XElement.SaveAsync(System.IO.TextWriter,System.Xml.Linq.SaveOptions,System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Function SaveAsync (textWriter As TextWriter, options As SaveOptions, cancellationToken As CancellationToken) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ SaveAsync(System::IO::TextWriter ^ textWriter, System::Xml::Linq::SaveOptions options, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.SaveAsync : System.IO.TextWriter * System.Xml.Linq.SaveOptions * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="xElement.SaveAsync (textWriter, options, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="textWriter" Type="System.IO.TextWriter" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="options" Type="System.Xml.Linq.SaveOptions" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="textWriter"><span data-ttu-id="b21d2-940">要向其输出 XML 的编写器。</span><span class="sxs-lookup"><span data-stu-id="b21d2-940">The writer to output the XML to.</span></span></param>
        <param name="options"><span data-ttu-id="b21d2-941">枚举值的按位组合，这些枚举值指定序列化选项。</span><span class="sxs-lookup"><span data-stu-id="b21d2-941">A bitwise combination of the enumeration values that specify the serialization options.</span></span></param>
        <param name="cancellationToken"><span data-ttu-id="b21d2-942">可用于请求异步操作取消的标志。</span><span class="sxs-lookup"><span data-stu-id="b21d2-942">A token that can be used to request cancellation of the asynchronous operation.</span></span></param>
        <summary><span data-ttu-id="b21d2-943">将此 <see cref="T:System.Xml.Linq.XElement" /> 异步输出到 <see cref="T:System.IO.TextWriter" />。</span><span class="sxs-lookup"><span data-stu-id="b21d2-943">Asynchronously outputs this <see cref="T:System.Xml.Linq.XElement" /> to a <see cref="T:System.IO.TextWriter" />.</span></span></summary>
        <returns><span data-ttu-id="b21d2-944">表示异步保存操作的任务。</span><span class="sxs-lookup"><span data-stu-id="b21d2-944">A task representing the asynchronous save operation.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetAttributeValue">
      <MemberSignature Language="C#" Value="public void SetAttributeValue (System.Xml.Linq.XName name, object value);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetAttributeValue(class System.Xml.Linq.XName name, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XElement.SetAttributeValue(System.Xml.Linq.XName,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetAttributeValue (name As XName, value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetAttributeValue(System::Xml::Linq::XName ^ name, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="member this.SetAttributeValue : System.Xml.Linq.XName * obj -&gt; unit" Usage="xElement.SetAttributeValue (name, value)" />
      <MemberSignature Language="C#" Value="public void SetAttributeValue (System.Xml.Linq.XName name, object? value);" FrameworkAlternate="net-5.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Xml.Linq.XName" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="b21d2-945">一个 <see cref="T:System.Xml.Linq.XName" />，其中包含要更改的属性的名称。</span><span class="sxs-lookup"><span data-stu-id="b21d2-945">An <see cref="T:System.Xml.Linq.XName" /> that contains the name of the attribute to change.</span></span></param>
        <param name="value"><span data-ttu-id="b21d2-946">分配给属性的值。</span><span class="sxs-lookup"><span data-stu-id="b21d2-946">The value to assign to the attribute.</span></span> <span data-ttu-id="b21d2-947">如果该值为 <see langword="null" />，则移除该属性 (Attribute)。</span><span class="sxs-lookup"><span data-stu-id="b21d2-947">The attribute is removed if the value is <see langword="null" />.</span></span> <span data-ttu-id="b21d2-948">否则，会将值转换为其字符串表示形式，并分配给该属性 (Attribute) 的 <see cref="P:System.Xml.Linq.XAttribute.Value" /> 属性 (Property)。</span><span class="sxs-lookup"><span data-stu-id="b21d2-948">Otherwise, the value is converted to its string representation and assigned to the <see cref="P:System.Xml.Linq.XAttribute.Value" /> property of the attribute.</span></span></param>
        <summary><span data-ttu-id="b21d2-949">设置属性的值、添加属性或移除属性。</span><span class="sxs-lookup"><span data-stu-id="b21d2-949">Sets the value of an attribute, adds an attribute, or removes an attribute.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b21d2-950">此方法旨在使名称/值对的列表易于维护为一组属性。</span><span class="sxs-lookup"><span data-stu-id="b21d2-950">This method is designed to make it easy to maintain a list of name/value pairs as a set of attributes.</span></span> <span data-ttu-id="b21d2-951">维护列表时，需要添加对、修改对或删除对。</span><span class="sxs-lookup"><span data-stu-id="b21d2-951">When maintaining the list, you need to add pairs, modify pairs, or delete pairs.</span></span> <span data-ttu-id="b21d2-952">如果调用此方法时将不存在的名称作为属性传递，则此方法会为你创建一个属性。</span><span class="sxs-lookup"><span data-stu-id="b21d2-952">If you call this method passing a name that does not exist as an attribute, this method creates an attribute for you.</span></span> <span data-ttu-id="b21d2-953">如果调用此方法来传递现有属性的名称，则此方法会将属性的值修改为你指定的值。</span><span class="sxs-lookup"><span data-stu-id="b21d2-953">If you call this method passing the name of an existing attribute, this method modifies the value of the attribute to the value that you specify.</span></span> <span data-ttu-id="b21d2-954">如果传递 `null` 了 `value` ，则此方法将删除该特性。</span><span class="sxs-lookup"><span data-stu-id="b21d2-954">If you pass `null` for `value`, this method removes the attribute.</span></span>  
  
 <span data-ttu-id="b21d2-955">此方法将引发 <xref:System.Xml.Linq.XObject.Changed> 和 <xref:System.Xml.Linq.XObject.Changing> 事件。</span><span class="sxs-lookup"><span data-stu-id="b21d2-955">This method will raise the <xref:System.Xml.Linq.XObject.Changed> and the <xref:System.Xml.Linq.XObject.Changing> events.</span></span>  
  
 <span data-ttu-id="b21d2-956">该值将分配给具有指定名称的属性。</span><span class="sxs-lookup"><span data-stu-id="b21d2-956">The value is assigned to the attribute with the specified name.</span></span> <span data-ttu-id="b21d2-957">如果不存在具有指定名称的属性，则添加新的属性。</span><span class="sxs-lookup"><span data-stu-id="b21d2-957">If no attribute with the specified name exists, a new attribute is added.</span></span> <span data-ttu-id="b21d2-958">如果值为 `null` ，则删除具有指定名称的属性（如果有）。</span><span class="sxs-lookup"><span data-stu-id="b21d2-958">If the value is `null`, the attribute with the specified name, if any, is deleted.</span></span>  
  
 <span data-ttu-id="b21d2-959">有关详细信息，请参阅 [维护名称/值对](/dotnet/standard/linq/maintain-name-value-pairs)。</span><span class="sxs-lookup"><span data-stu-id="b21d2-959">For more information, see [Maintain name-value pairs](/dotnet/standard/linq/maintain-name-value-pairs).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b21d2-960">下面的示例创建一个具有特性的元素。</span><span class="sxs-lookup"><span data-stu-id="b21d2-960">The following example creates an element with an attribute.</span></span> <span data-ttu-id="b21d2-961">然后，它使用此方法来替换属性的内容。</span><span class="sxs-lookup"><span data-stu-id="b21d2-961">It then uses this method to replace the content of the attribute.</span></span>  
  
```csharp  
// Create an element with no content.  
XElement root = new XElement("Root");  
  
// Add some name/value pairs.  
root.SetAttributeValue("Att1", 1);  
root.SetAttributeValue("Att2", 2);  
root.SetAttributeValue("Att3", 3);  
Console.WriteLine(root);  
  
// Modify one of the name/value pairs.  
root.SetAttributeValue("Att2", 22);  
Console.WriteLine(root);  
  
// Remove one of the name/value pairs.  
root.SetAttributeValue("Att3", null);  
Console.WriteLine(root);  
```  
  
```vb  
' Create an element with no content.  
Dim root As XElement = <Root/>  
  
' Add some name/value pairs.  
root.SetAttributeValue("Att1", 1)  
root.SetAttributeValue("Att2", 2)  
root.SetAttributeValue("Att3", 3)  
Console.WriteLine(root)  
  
' Modify one of the name/value pairs.  
root.SetAttributeValue("Att2", 22)  
Console.WriteLine(root)  
  
' Remove one of the name/value pairs.  
root.SetAttributeValue("Att3", Nothing)  
Console.WriteLine(root)  
```  
  
 <span data-ttu-id="b21d2-962">该示例产生下面的输出：</span><span class="sxs-lookup"><span data-stu-id="b21d2-962">This example produces the following output:</span></span>  
  
```  
<Root Att1="1" Att2="2" Att3="3" />  
<Root Att1="1" Att2="22" Att3="3" />  
<Root Att1="1" Att2="22" />  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="b21d2-963"><paramref name="value" /> 是 <see cref="T:System.Xml.Linq.XObject" /> 的一个实例。</span><span class="sxs-lookup"><span data-stu-id="b21d2-963">The <paramref name="value" /> is an instance of <see cref="T:System.Xml.Linq.XObject" />.</span></span></exception>
        <altmember cref="M:System.Xml.Linq.XAttribute.SetValue(System.Object)" />
        <altmember cref="M:System.Xml.Linq.XElement.SetElementValue(System.Xml.Linq.XName,System.Object)" />
        <altmember cref="M:System.Xml.Linq.XElement.SetValue(System.Object)" />
        <related type="Article" href="/dotnet/standard/linq/linq-xml-overview"><span data-ttu-id="b21d2-964">LINQ to XML 概述</span><span class="sxs-lookup"><span data-stu-id="b21d2-964">LINQ to XML overview</span></span></related>
        <related type="Article" href="/dotnet/standard/linq/maintain-name-value-pairs"><span data-ttu-id="b21d2-965">维护名称/值对</span><span class="sxs-lookup"><span data-stu-id="b21d2-965">Maintain name-value pairs</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="SetElementValue">
      <MemberSignature Language="C#" Value="public void SetElementValue (System.Xml.Linq.XName name, object value);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetElementValue(class System.Xml.Linq.XName name, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XElement.SetElementValue(System.Xml.Linq.XName,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetElementValue (name As XName, value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetElementValue(System::Xml::Linq::XName ^ name, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="member this.SetElementValue : System.Xml.Linq.XName * obj -&gt; unit" Usage="xElement.SetElementValue (name, value)" />
      <MemberSignature Language="C#" Value="public void SetElementValue (System.Xml.Linq.XName name, object? value);" FrameworkAlternate="net-5.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Xml.Linq.XName" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="b21d2-966">一个 <see cref="T:System.Xml.Linq.XName" />，其中包含要更改的子元素的名称。</span><span class="sxs-lookup"><span data-stu-id="b21d2-966">An <see cref="T:System.Xml.Linq.XName" /> that contains the name of the child element to change.</span></span></param>
        <param name="value"><span data-ttu-id="b21d2-967">要分配给子元素的值。</span><span class="sxs-lookup"><span data-stu-id="b21d2-967">The value to assign to the child element.</span></span> <span data-ttu-id="b21d2-968">如果值为 <see langword="null" />，则移除子元素。</span><span class="sxs-lookup"><span data-stu-id="b21d2-968">The child element is removed if the value is <see langword="null" />.</span></span> <span data-ttu-id="b21d2-969">否则，会将值转换为其字符串表示形式，并将该值分配给子元素的 <see cref="P:System.Xml.Linq.XElement.Value" /> 属性。</span><span class="sxs-lookup"><span data-stu-id="b21d2-969">Otherwise, the value is converted to its string representation and assigned to the <see cref="P:System.Xml.Linq.XElement.Value" /> property of the child element.</span></span></param>
        <summary><span data-ttu-id="b21d2-970">设置子元素的值、添加子元素或移除子元素。</span><span class="sxs-lookup"><span data-stu-id="b21d2-970">Sets the value of a child element, adds a child element, or removes a child element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b21d2-971">此方法旨在使名称/值对的列表易于维护为一组子元素。</span><span class="sxs-lookup"><span data-stu-id="b21d2-971">This method is designed to make it easy to maintain a list of name/value pairs as a set of children elements.</span></span> <span data-ttu-id="b21d2-972">维护列表时，需要添加对、修改对或删除对。</span><span class="sxs-lookup"><span data-stu-id="b21d2-972">When maintaining the list, you need to add pairs, modify pairs, or delete pairs.</span></span> <span data-ttu-id="b21d2-973">如果调用此方法时将不存在的名称传递为子元素，则此方法将为您创建一个子元素。</span><span class="sxs-lookup"><span data-stu-id="b21d2-973">If you call this method passing a name that does not exist as a child element, this method creates a child element for you.</span></span> <span data-ttu-id="b21d2-974">如果调用此方法来传递现有子元素的名称，则此方法将子元素的值修改为你指定的值。</span><span class="sxs-lookup"><span data-stu-id="b21d2-974">If you call this method passing the name of an existing child element, this method modifies the value of the child element to the value that you specify.</span></span> <span data-ttu-id="b21d2-975">如果传递 `null` ，则 `value` 此方法将移除子元素。</span><span class="sxs-lookup"><span data-stu-id="b21d2-975">If you pass `null` for `value`, this method removes the child element.</span></span>  
  
 <span data-ttu-id="b21d2-976">此方法将引发事件。</span><span class="sxs-lookup"><span data-stu-id="b21d2-976">This method will raise events.</span></span>  
  
 <span data-ttu-id="b21d2-977">该值将分配给具有指定名称的第一个子元素。</span><span class="sxs-lookup"><span data-stu-id="b21d2-977">The value is assigned to the first child element with the specified name.</span></span> <span data-ttu-id="b21d2-978">如果不存在具有指定名称的子元素，则添加新的子元素。</span><span class="sxs-lookup"><span data-stu-id="b21d2-978">If no child element with the specified name exists, a new child element is added.</span></span> <span data-ttu-id="b21d2-979">如果该值为 null，则删除具有指定名称的第一个子元素（如果有）。</span><span class="sxs-lookup"><span data-stu-id="b21d2-979">If the value is null, the first child element with the specified name, if any, is deleted.</span></span>  
  
 <span data-ttu-id="b21d2-980">此方法不会将子节点或特性添加到指定的子元素。</span><span class="sxs-lookup"><span data-stu-id="b21d2-980">This method does not add child nodes or attributes to the specified child element.</span></span> <span data-ttu-id="b21d2-981">如果派生自的任何对象作为传递，则此方法将引发异常 <xref:System.Xml.Linq.XObject> `value` 。</span><span class="sxs-lookup"><span data-stu-id="b21d2-981">This method throws an exception if any object that derives from <xref:System.Xml.Linq.XObject> is passed as `value`.</span></span>  
  
 <span data-ttu-id="b21d2-982">有关详细信息，请参阅 [维护名称/值对](/dotnet/standard/linq/maintain-name-value-pairs)。</span><span class="sxs-lookup"><span data-stu-id="b21d2-982">For more information, see [Maintain name-value pairs](/dotnet/standard/linq/maintain-name-value-pairs).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b21d2-983">下面的示例创建一个具有子元素的元素。</span><span class="sxs-lookup"><span data-stu-id="b21d2-983">The following example creates an element with a child element.</span></span> <span data-ttu-id="b21d2-984">然后，它使用此方法设置子元素的值。</span><span class="sxs-lookup"><span data-stu-id="b21d2-984">It then uses this method to set the value of the child element.</span></span>  
  
```csharp  
// Create an element with no content  
XElement root = new XElement("Root");  
  
// Add some name/value pairs.  
root.SetElementValue("Ele1", 1);  
root.SetElementValue("Ele2", 2);  
root.SetElementValue("Ele3", 3);  
Console.WriteLine(root);  
  
// Modify one of the name/value pairs.  
root.SetElementValue("Ele2", 22);  
Console.WriteLine(root);  
  
// Remove one of the name/value pairs.  
root.SetElementValue("Ele3", null);  
Console.WriteLine(root);  
```  
  
```vb  
' Create an element with no content.  
Dim root As XElement = <Root/>  
  
' Add some name/value pairs.  
root.SetElementValue("Ele1", 1)  
root.SetElementValue("Ele2", 2)  
root.SetElementValue("Ele3", 3)  
Console.WriteLine(root)  
  
' Modify one of the name/value pairs.  
root.SetElementValue("Ele2", 22)  
Console.WriteLine(root)  
  
' Remove one of the name/value pairs.  
root.SetElementValue("Ele3", Nothing)  
Console.WriteLine(root)  
```  
  
 <span data-ttu-id="b21d2-985">该示例产生下面的输出：</span><span class="sxs-lookup"><span data-stu-id="b21d2-985">This example produces the following output:</span></span>  
  
```  
<Root>  
  <Ele1>1</Ele1>  
  <Ele2>2</Ele2>  
  <Ele3>3</Ele3>  
</Root>  
<Root>  
  <Ele1>1</Ele1>  
  <Ele2>22</Ele2>  
  <Ele3>3</Ele3>  
</Root>  
<Root>  
  <Ele1>1</Ele1>  
  <Ele2>22</Ele2>  
</Root>  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="b21d2-986"><paramref name="value" /> 是 <see cref="T:System.Xml.Linq.XObject" /> 的一个实例。</span><span class="sxs-lookup"><span data-stu-id="b21d2-986">The <paramref name="value" /> is an instance of <see cref="T:System.Xml.Linq.XObject" />.</span></span></exception>
        <altmember cref="M:System.Xml.Linq.XAttribute.SetValue(System.Object)" />
        <altmember cref="M:System.Xml.Linq.XElement.SetElementValue(System.Xml.Linq.XName,System.Object)" />
        <altmember cref="M:System.Xml.Linq.XElement.SetValue(System.Object)" />
        <related type="Article" href="/dotnet/standard/linq/linq-xml-overview"><span data-ttu-id="b21d2-987">LINQ to XML 概述</span><span class="sxs-lookup"><span data-stu-id="b21d2-987">LINQ to XML overview</span></span></related>
        <related type="Article" href="/dotnet/standard/linq/maintain-name-value-pairs"><span data-ttu-id="b21d2-988">维护名称/值对</span><span class="sxs-lookup"><span data-stu-id="b21d2-988">Maintain name-value pairs</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XElement.SetValue(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="member this.SetValue : obj -&gt; unit" Usage="xElement.SetValue value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="b21d2-989">要分配给此元素的值。</span><span class="sxs-lookup"><span data-stu-id="b21d2-989">The value to assign to this element.</span></span> <span data-ttu-id="b21d2-990">将值转换为其字符串表示形式，并将此值分配给 <see cref="P:System.Xml.Linq.XElement.Value" /> 属性 (Property)。</span><span class="sxs-lookup"><span data-stu-id="b21d2-990">The value is converted to its string representation and assigned to the <see cref="P:System.Xml.Linq.XElement.Value" /> property.</span></span></param>
        <summary><span data-ttu-id="b21d2-991">设置此元素的值。</span><span class="sxs-lookup"><span data-stu-id="b21d2-991">Sets the value of this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b21d2-992">此方法将引发 <xref:System.Xml.Linq.XObject.Changed> 和 <xref:System.Xml.Linq.XObject.Changing> 事件。</span><span class="sxs-lookup"><span data-stu-id="b21d2-992">This method will raise the <xref:System.Xml.Linq.XObject.Changed> and the <xref:System.Xml.Linq.XObject.Changing> events.</span></span>  
  
 <span data-ttu-id="b21d2-993">传递派生自的类的实例（如）是无效的 <xref:System.Xml.Linq.XObject> <xref:System.Xml.Linq.XElement> 。</span><span class="sxs-lookup"><span data-stu-id="b21d2-993">It is invalid to pass an instance of a class that derives from <xref:System.Xml.Linq.XObject>, such as <xref:System.Xml.Linq.XElement>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b21d2-994">下面的示例创建一个包含子元素的元素。</span><span class="sxs-lookup"><span data-stu-id="b21d2-994">The following example creates an element that contains a child element.</span></span> <span data-ttu-id="b21d2-995">然后，它使用此方法设置元素的值。</span><span class="sxs-lookup"><span data-stu-id="b21d2-995">It then sets the value of the element using this method.</span></span>  
  
```csharp  
XElement root = new XElement("Root",  
    new XElement("Child", "child content")  
);  
root.SetValue("new content");  
Console.WriteLine(root);  
```  
  
```vb  
Dim root As XElement = _   
        <Root>  
            <Child>child content</Child>  
        </Root>  
  
root.SetValue("new content")  
Console.WriteLine(root)  
```  
  
 <span data-ttu-id="b21d2-996">该示例产生下面的输出：</span><span class="sxs-lookup"><span data-stu-id="b21d2-996">This example produces the following output:</span></span>  
  
```xml  
<Root>new content</Root>  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="b21d2-997"><paramref name="value" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="b21d2-997">The <paramref name="value" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="b21d2-998"><paramref name="value" /> 是一个 <see cref="T:System.Xml.Linq.XObject" />。</span><span class="sxs-lookup"><span data-stu-id="b21d2-998">The <paramref name="value" /> is an <see cref="T:System.Xml.Linq.XObject" />.</span></span></exception>
        <altmember cref="M:System.Xml.Linq.XAttribute.SetValue(System.Object)" />
        <altmember cref="M:System.Xml.Linq.XElement.SetAttributeValue(System.Xml.Linq.XName,System.Object)" />
        <altmember cref="M:System.Xml.Linq.XElement.SetValue(System.Object)" />
        <related type="Article" href="/dotnet/standard/linq/linq-xml-overview"><span data-ttu-id="b21d2-999">LINQ to XML 概述</span><span class="sxs-lookup"><span data-stu-id="b21d2-999">LINQ to XML overview</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="System.Xml.Serialization.IXmlSerializable.GetSchema">
      <MemberSignature Language="C#" Value="System.Xml.Schema.XmlSchema IXmlSerializable.GetSchema ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Xml.Schema.XmlSchema System.Xml.Serialization.IXmlSerializable.GetSchema() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XElement.System#Xml#Serialization#IXmlSerializable#GetSchema" />
      <MemberSignature Language="VB.NET" Value="Function GetSchema () As XmlSchema Implements IXmlSerializable.GetSchema" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Xml::Schema::XmlSchema ^ System.Xml.Serialization.IXmlSerializable.GetSchema() = System::Xml::Serialization::IXmlSerializable::GetSchema;" />
      <MemberSignature Language="F#" Value="abstract member System.Xml.Serialization.IXmlSerializable.GetSchema : unit -&gt; System.Xml.Schema.XmlSchema&#xA;override this.System.Xml.Serialization.IXmlSerializable.GetSchema : unit -&gt; System.Xml.Schema.XmlSchema" Usage="xElement.System.Xml.Serialization.IXmlSerializable.GetSchema " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Xml.Serialization.IXmlSerializable.GetSchema</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Schema.XmlSchema</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="b21d2-1000">获取说明此对象的 XML 表示形式的 XML 构架定义。</span><span class="sxs-lookup"><span data-stu-id="b21d2-1000">Gets an XML schema definition that describes the XML representation of this object.</span></span></summary>
        <returns><span data-ttu-id="b21d2-1001">由 <see cref="T:System.Xml.Schema.XmlSchema" /> 方法生成并由 <see cref="M:System.Xml.Serialization.IXmlSerializable.WriteXml(System.Xml.XmlWriter)" /> 方法使用的对象的 XML 表示形式的 <see cref="M:System.Xml.Serialization.IXmlSerializable.ReadXml(System.Xml.XmlReader)" />。</span><span class="sxs-lookup"><span data-stu-id="b21d2-1001">An <see cref="T:System.Xml.Schema.XmlSchema" /> that describes the XML representation of the object that is produced by the <see cref="M:System.Xml.Serialization.IXmlSerializable.WriteXml(System.Xml.XmlWriter)" /> method and consumed by the <see cref="M:System.Xml.Serialization.IXmlSerializable.ReadXml(System.Xml.XmlReader)" /> method.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b21d2-1002">此方法是接口的实现的一部分 <xref:System.Xml.Serialization.IXmlSerializable> 。</span><span class="sxs-lookup"><span data-stu-id="b21d2-1002">This method is part of implementation of the <xref:System.Xml.Serialization.IXmlSerializable> interface.</span></span>  
  
 <span data-ttu-id="b21d2-1003">此方法在内部使用，用于序列化包含 LINQ to XML 对象的对象图。</span><span class="sxs-lookup"><span data-stu-id="b21d2-1003">This method is used internally for serializing object graphs that contain LINQ to XML objects.</span></span> <span data-ttu-id="b21d2-1004">有关序列化包含 LINQ to XML 对象的对象图的示例，请参阅 [序列化包含 system.xml.linq.xelement> 对象的对象](/dotnet/standard/linq/serialize-xmlserializer)图。</span><span class="sxs-lookup"><span data-stu-id="b21d2-1004">For an example of serializing an object graph that contains LINQ to XML objects, see [Serialize object graphs that contain XElement objects](/dotnet/standard/linq/serialize-xmlserializer).</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Xml.Serialization.IXmlSerializable.ReadXml">
      <MemberSignature Language="C#" Value="void IXmlSerializable.ReadXml (System.Xml.XmlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Xml.Serialization.IXmlSerializable.ReadXml(class System.Xml.XmlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XElement.System#Xml#Serialization#IXmlSerializable#ReadXml(System.Xml.XmlReader)" />
      <MemberSignature Language="VB.NET" Value="Sub ReadXml (reader As XmlReader) Implements IXmlSerializable.ReadXml" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Xml.Serialization.IXmlSerializable.ReadXml(System::Xml::XmlReader ^ reader) = System::Xml::Serialization::IXmlSerializable::ReadXml;" />
      <MemberSignature Language="F#" Value="abstract member System.Xml.Serialization.IXmlSerializable.ReadXml : System.Xml.XmlReader -&gt; unit&#xA;override this.System.Xml.Serialization.IXmlSerializable.ReadXml : System.Xml.XmlReader -&gt; unit" Usage="xElement.System.Xml.Serialization.IXmlSerializable.ReadXml reader" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Xml.Serialization.IXmlSerializable.ReadXml(System.Xml.XmlReader)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="reader"><span data-ttu-id="b21d2-1005">要从其反序列化对象的 <see cref="T:System.Xml.XmlReader" />。</span><span class="sxs-lookup"><span data-stu-id="b21d2-1005">The <see cref="T:System.Xml.XmlReader" /> from which the object is deserialized.</span></span></param>
        <summary><span data-ttu-id="b21d2-1006">从其 XML 表示形式生成对象。</span><span class="sxs-lookup"><span data-stu-id="b21d2-1006">Generates an object from its XML representation.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b21d2-1007">此方法是接口的实现的一部分 <xref:System.Xml.Serialization.IXmlSerializable> 。</span><span class="sxs-lookup"><span data-stu-id="b21d2-1007">This method is part of implementation of the <xref:System.Xml.Serialization.IXmlSerializable> interface.</span></span>  
  
 <span data-ttu-id="b21d2-1008">此方法在内部使用，用于序列化包含 LINQ to XML 对象的对象图。</span><span class="sxs-lookup"><span data-stu-id="b21d2-1008">This method is used internally for serializing object graphs that contain LINQ to XML objects.</span></span> <span data-ttu-id="b21d2-1009">有关序列化包含 LINQ to XML 对象的对象图的示例，请参阅 [序列化包含 system.xml.linq.xelement> 对象的对象](/dotnet/standard/linq/serialize-xmlserializer)图。</span><span class="sxs-lookup"><span data-stu-id="b21d2-1009">For an example of serializing an object graph that contains LINQ to XML objects, see [Serialize object graphs that contain XElement objects](/dotnet/standard/linq/serialize-xmlserializer).</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Xml.Serialization.IXmlSerializable.WriteXml">
      <MemberSignature Language="C#" Value="void IXmlSerializable.WriteXml (System.Xml.XmlWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Xml.Serialization.IXmlSerializable.WriteXml(class System.Xml.XmlWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XElement.System#Xml#Serialization#IXmlSerializable#WriteXml(System.Xml.XmlWriter)" />
      <MemberSignature Language="VB.NET" Value="Sub WriteXml (writer As XmlWriter) Implements IXmlSerializable.WriteXml" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Xml.Serialization.IXmlSerializable.WriteXml(System::Xml::XmlWriter ^ writer) = System::Xml::Serialization::IXmlSerializable::WriteXml;" />
      <MemberSignature Language="F#" Value="abstract member System.Xml.Serialization.IXmlSerializable.WriteXml : System.Xml.XmlWriter -&gt; unit&#xA;override this.System.Xml.Serialization.IXmlSerializable.WriteXml : System.Xml.XmlWriter -&gt; unit" Usage="xElement.System.Xml.Serialization.IXmlSerializable.WriteXml writer" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Xml.Serialization.IXmlSerializable.WriteXml(System.Xml.XmlWriter)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="writer"><span data-ttu-id="b21d2-1010">将此对象序列化到的 <see cref="T:System.Xml.XmlWriter" />。</span><span class="sxs-lookup"><span data-stu-id="b21d2-1010">The <see cref="T:System.Xml.XmlWriter" /> to which this object is serialized.</span></span></param>
        <summary><span data-ttu-id="b21d2-1011">将对象转换为其 XML 表示形式。</span><span class="sxs-lookup"><span data-stu-id="b21d2-1011">Converts an object into its XML representation.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b21d2-1012">此方法在内部使用，用于封送包含 LINQ to XML 对象的对象图。</span><span class="sxs-lookup"><span data-stu-id="b21d2-1012">This method is used internally for marshaling object graphs that contain LINQ to XML objects.</span></span> <span data-ttu-id="b21d2-1013">有关序列化包含 LINQ to XML 对象的对象图的示例，请参阅 [序列化包含 system.xml.linq.xelement> 对象的对象](/dotnet/standard/linq/serialize-xmlserializer)图。</span><span class="sxs-lookup"><span data-stu-id="b21d2-1013">For an example of serializing an object graph that contains LINQ to XML objects, see [Serialize object graphs that contain XElement objects](/dotnet/standard/linq/serialize-xmlserializer).</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Value">
      <MemberSignature Language="C#" Value="public string Value { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Value" />
      <MemberSignature Language="DocId" Value="P:System.Xml.Linq.XElement.Value" />
      <MemberSignature Language="VB.NET" Value="Public Property Value As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Value { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Value : string with get, set" Usage="System.Xml.Linq.XElement.Value" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="b21d2-1014">获取或设置此元素的串连文本内容。</span><span class="sxs-lookup"><span data-stu-id="b21d2-1014">Gets or sets the concatenated text contents of this element.</span></span></summary>
        <value><span data-ttu-id="b21d2-1015">一个包含此元素所有文本内容的 <see cref="T:System.String" />。</span><span class="sxs-lookup"><span data-stu-id="b21d2-1015">A <see cref="T:System.String" /> that contains all of the text content of this element.</span></span> <span data-ttu-id="b21d2-1016">如果有多个文本节点，则将其串连起来。</span><span class="sxs-lookup"><span data-stu-id="b21d2-1016">If there are multiple text nodes, they will be concatenated.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b21d2-1017">使用此属性，可获取或设置元素的值。</span><span class="sxs-lookup"><span data-stu-id="b21d2-1017">Using this property, you can get or set the value of an element.</span></span>  
  
 <span data-ttu-id="b21d2-1018">设置此属性将引发 <xref:System.Xml.Linq.XObject.Changed> 和 <xref:System.Xml.Linq.XObject.Changing> 事件。</span><span class="sxs-lookup"><span data-stu-id="b21d2-1018">Setting this property will raise the <xref:System.Xml.Linq.XObject.Changed> and the <xref:System.Xml.Linq.XObject.Changing> events.</span></span>  
  
 <span data-ttu-id="b21d2-1019">如果要获取某个元素的值，但不确定该元素是否存在，更方便的方法是使用显式转换运算符，并将该元素分配给可以为 null 的类型（如 `string` 或） <xref:System.Nullable%601> <xref:System.Int32> 。</span><span class="sxs-lookup"><span data-stu-id="b21d2-1019">If you want to get the value of an element but you are not sure that it exists, it is more convenient to use the explicit conversion operators, and assign the element to a nullable type such as `string` or <xref:System.Nullable%601> of <xref:System.Int32>.</span></span> <span data-ttu-id="b21d2-1020">如果该元素不存在，则将可为 null 的类型设置为 `null` 。</span><span class="sxs-lookup"><span data-stu-id="b21d2-1020">If the element does not exist, the nullable type is set to `null`.</span></span> <span data-ttu-id="b21d2-1021">相反，如果要使用此属性，您必须确保在 <xref:System.Xml.Linq.XContainer.Element%2A> `null` 访问此属性之前该方法不会返回。</span><span class="sxs-lookup"><span data-stu-id="b21d2-1021">By contrast, if you want to use this property, you must make sure that the <xref:System.Xml.Linq.XContainer.Element%2A> method does not return `null` before you access this property.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b21d2-1022">下面的示例使用此属性来检索包含混合内容的元素的文本。</span><span class="sxs-lookup"><span data-stu-id="b21d2-1022">The following example uses this property to retrieve the text of an element with mixed content.</span></span>  
  
```csharp  
XElement el = XElement.Parse("<Root>This is <b>mixed</b> content</Root>");  
Console.WriteLine("{0}", el.Value);  
```  
  
```vb  
Dim el As XElement = <Root>This is <b>mixed</b> content</Root>  
Console.WriteLine("{0}", el.Value)  
```  
  
 <span data-ttu-id="b21d2-1023">该示例产生下面的输出：</span><span class="sxs-lookup"><span data-stu-id="b21d2-1023">This example produces the following output:</span></span>  
  
```  
This is mixed content  
```  
  
 ]]></format>
        </remarks>
        <related type="Article" href="/dotnet/standard/linq/linq-xml-overview"><span data-ttu-id="b21d2-1024">LINQ to XML 概述</span><span class="sxs-lookup"><span data-stu-id="b21d2-1024">LINQ to XML overview</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="WriteTo">
      <MemberSignature Language="C#" Value="public override void WriteTo (System.Xml.XmlWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void WriteTo(class System.Xml.XmlWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XElement.WriteTo(System.Xml.XmlWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub WriteTo (writer As XmlWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void WriteTo(System::Xml::XmlWriter ^ writer);" />
      <MemberSignature Language="F#" Value="override this.WriteTo : System.Xml.XmlWriter -&gt; unit" Usage="xElement.WriteTo writer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
      </Parameters>
      <Docs>
        <param name="writer"><span data-ttu-id="b21d2-1025">此方法将写入其中的 <see cref="T:System.Xml.XmlWriter" />。</span><span class="sxs-lookup"><span data-stu-id="b21d2-1025">An <see cref="T:System.Xml.XmlWriter" /> into which this method will write.</span></span></param>
        <summary><span data-ttu-id="b21d2-1026">将此元素写入 <see cref="T:System.Xml.XmlWriter" />。</span><span class="sxs-lookup"><span data-stu-id="b21d2-1026">Write this element to an <see cref="T:System.Xml.XmlWriter" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="b21d2-1027">下面的示例演示如何将写入 <xref:System.Xml.Linq.XElement> <xref:System.Xml.XmlWriter> 。</span><span class="sxs-lookup"><span data-stu-id="b21d2-1027">The following example shows how to write an <xref:System.Xml.Linq.XElement> to an <xref:System.Xml.XmlWriter>.</span></span> <span data-ttu-id="b21d2-1028">请注意，该示例未编写 XML 声明。</span><span class="sxs-lookup"><span data-stu-id="b21d2-1028">Note that the example did not write an XML declaration.</span></span>  
  
```csharp  
StringBuilder sb = new StringBuilder();  
XmlWriterSettings xws = new XmlWriterSettings();  
xws.OmitXmlDeclaration = true;  
xws.Indent = true;  
  
using (XmlWriter xw = XmlWriter.Create(sb, xws)) {  
    xw.WriteStartElement("Root");  
  
    XElement child1 = new XElement("Child",  
        new XElement("GrandChild", "some content")  
    );  
    child1.WriteTo(xw);  
  
    XElement child2 = new XElement("AnotherChild",  
        new XElement("GrandChild", "different content")  
    );  
    child2.WriteTo(xw);  
  
    xw.WriteEndElement();  
}  
  
Console.WriteLine(sb.ToString());  
```  
  
```vb  
Dim sb As StringBuilder = New StringBuilder()  
Dim xws As XmlWriterSettings = New XmlWriterSettings()  
xws.OmitXmlDeclaration = True  
xws.Indent = True  
  
Using xw = XmlWriter.Create(sb, xws)  
    xw.WriteStartElement("Root")  
    Dim child1 As XElement = _  
        <Child>  
            <GrandChild>some content</GrandChild>  
        </Child>  
    child1.WriteTo(xw)  
    Dim child2 As XElement = _   
        <AnotherChild>  
            <GrandChild>different content</GrandChild>  
        </AnotherChild>  
    child2.WriteTo(xw)  
    xw.WriteEndElement()  
End Using  
  
Console.WriteLine(sb.ToString())  
```  
  
 <span data-ttu-id="b21d2-1029">该示例产生下面的输出：</span><span class="sxs-lookup"><span data-stu-id="b21d2-1029">This example produces the following output:</span></span>  
  
```xml  
<Root>  
  <Child>  
    <GrandChild>some content</GrandChild>  
  </Child>  
  <AnotherChild>  
    <GrandChild>different content</GrandChild>  
  </AnotherChild>  
</Root>  
```  
  
 ]]></format>
        </remarks>
        <related type="Article" href="/dotnet/standard/linq/linq-xml-overview"><span data-ttu-id="b21d2-1030">LINQ to XML 概述</span><span class="sxs-lookup"><span data-stu-id="b21d2-1030">LINQ to XML overview</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="WriteToAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task WriteToAsync (System.Xml.XmlWriter writer, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task WriteToAsync(class System.Xml.XmlWriter writer, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XElement.WriteToAsync(System.Xml.XmlWriter,System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function WriteToAsync (writer As XmlWriter, cancellationToken As CancellationToken) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::Task ^ WriteToAsync(System::Xml::XmlWriter ^ writer, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="override this.WriteToAsync : System.Xml.XmlWriter * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="xElement.WriteToAsync (writer, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="writer"><span data-ttu-id="b21d2-1031">要将此 <see cref="T:System.Xml.Linq.XElement" /> 写入到的编写器。</span><span class="sxs-lookup"><span data-stu-id="b21d2-1031">The writer to write this <see cref="T:System.Xml.Linq.XElement" /> to.</span></span></param>
        <param name="cancellationToken"><span data-ttu-id="b21d2-1032">可用于请求异步操作取消的标志。</span><span class="sxs-lookup"><span data-stu-id="b21d2-1032">A token that can be used to request cancellation of the asynchronous operation.</span></span></param>
        <summary><span data-ttu-id="b21d2-1033">将此 <see cref="T:System.Xml.Linq.XElement" /> 异步写入到指定的编写器。</span><span class="sxs-lookup"><span data-stu-id="b21d2-1033">Asynchronously writes this <see cref="T:System.Xml.Linq.XElement" /> to the specified writer.</span></span></summary>
        <returns><span data-ttu-id="b21d2-1034">表示异步写入操作的任务。</span><span class="sxs-lookup"><span data-stu-id="b21d2-1034">A task representing the asynchronous write operation.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
