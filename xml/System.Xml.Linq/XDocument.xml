<Type Name="XDocument" FullName="System.Xml.Linq.XDocument">
  <Metadata><Meta Name="ms.openlocfilehash" Value="b24f9da5fc9f27d3a6c661397d56c05a12cb3ee7" /><Meta Name="ms.sourcegitcommit" Value="201bc7d7971e1c472a1df08dfeef528a60cec311" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-CN" /><Meta Name="ms.lasthandoff" Value="09/09/2020" /><Meta Name="ms.locfileid" Value="89596759" /></Metadata><TypeSignature Language="C#" Value="public class XDocument : System.Xml.Linq.XContainer" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit XDocument extends System.Xml.Linq.XContainer" />
  <TypeSignature Language="DocId" Value="T:System.Xml.Linq.XDocument" />
  <TypeSignature Language="VB.NET" Value="Public Class XDocument&#xA;Inherits XContainer" />
  <TypeSignature Language="C++ CLI" Value="public ref class XDocument : System::Xml::Linq::XContainer" />
  <TypeSignature Language="F#" Value="type XDocument = class&#xA;    inherit XContainer" />
  <AssemblyInfo>
    <AssemblyName>System.Xml.XDocument</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
    <AssemblyVersion>4.1.2.0</AssemblyVersion>
    <AssemblyVersion>5.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Xml.Linq</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>3.5.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeForwardingChain>
    <TypeForwarding From="System.Xml.Linq" FromVersion="4.0.0.0" To="System.Xml.XDocument" ToVersion="0.0.0.0" FrameworkAlternate="dotnet-uwp-10.0" />
    <TypeForwarding From="netstandard" FromVersion="2.1.0.0" To="System.Xml.XDocument" ToVersion="5.0.0.0" FrameworkAlternate="net-5.0" />
  </TypeForwardingChain>
  <Base>
    <BaseTypeName>System.Xml.Linq.XContainer</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary><span data-ttu-id="e8683-101">表示 XML 文档。</span><span class="sxs-lookup"><span data-stu-id="e8683-101">Represents an XML document.</span></span> <span data-ttu-id="e8683-102">有关 <see cref="T:System.Xml.Linq.XDocument" /> 对象的组件和用法，请参阅 <see href="/dotnet/standard/linq/xdocument-class-overview">XDocument Class Overview</see>。</span><span class="sxs-lookup"><span data-stu-id="e8683-102">For the components and usage of an <see cref="T:System.Xml.Linq.XDocument" /> object, see <see href="/dotnet/standard/linq/xdocument-class-overview">XDocument Class Overview</see>.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8683-103">有关的有效内容的详细信息 <xref:System.Xml.Linq.XDocument> ，请参阅 [System.xml.linq.xelement> 和 XDocument 对象的有效内容](/dotnet/standard/linq/valid-content-xelement-xdocument-objects)。</span><span class="sxs-lookup"><span data-stu-id="e8683-103">For details about the valid content of an <xref:System.Xml.Linq.XDocument>, see [Valid Content of XElement and XDocument Objects](/dotnet/standard/linq/valid-content-xelement-xdocument-objects).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="e8683-104">下面的示例创建一个文档，然后向其中添加注释和一个元素。</span><span class="sxs-lookup"><span data-stu-id="e8683-104">The following example creates a document, and then adds a comment and an element to it.</span></span> <span data-ttu-id="e8683-105">然后，它使用查询结果撰写另一篇文档。</span><span class="sxs-lookup"><span data-stu-id="e8683-105">It then composes another document using the results of a query.</span></span>  
  
```csharp  
XDocument srcTree = new XDocument(  
    new XComment("This is a comment"),  
    new XElement("Root",  
        new XElement("Child1", "data1"),  
        new XElement("Child2", "data2"),  
        new XElement("Child3", "data3"),  
        new XElement("Child2", "data4"),  
        new XElement("Info5", "info5"),  
        new XElement("Info6", "info6"),  
        new XElement("Info7", "info7"),  
        new XElement("Info8", "info8")  
    )  
);  
  
XDocument doc = new XDocument(  
    new XComment("This is a comment"),  
    new XElement("Root",  
        from el in srcTree.Element("Root").Elements()  
        where ((string)el).StartsWith("data")  
        select el  
    )  
);  
Console.WriteLine(doc);  
```  
  
```vb  
Dim srcTree As XDocument = _   
    <?xml version="1.0" encoding="utf-8" standalone="yes"?>  
        <!--This is a comment-->  
        <Root>  
            <Child1>data1</Child1>  
            <Child2>data2</Child2>  
            <Child3>data3</Child3>  
            <Child2>data4</Child2>  
            <Info5>info5</Info5>  
            <Info6>info6</Info6>  
            <Info7>info7</Info7>  
            <Info8>info8</Info8>  
        </Root>  
Dim doc As XDocument = _   
    <?xml version="1.0" encoding="utf-8" standalone="yes"?>  
        <!--This is a comment-->  
        <Root>  
            <%= From el In srcTree.<Root>.Elements _  
                Where CStr(el).StartsWith("data") _  
                Select el %>  
        </Root>  
Console.WriteLine(doc)  
```  
  
 <span data-ttu-id="e8683-106">该示例产生下面的输出：</span><span class="sxs-lookup"><span data-stu-id="e8683-106">This example produces the following output:</span></span>  
  
```xml  
<!--This is a comment-->  
<Root>  
  <Child1>data1</Child1>  
  <Child2>data2</Child2>  
  <Child3>data3</Child3>  
  <Child2>data4</Child2>  
</Root>  
```  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Xml.Linq.XNamespace" />
    <altmember cref="T:System.Xml.Linq.XDeclaration" />
    <altmember cref="T:System.Xml.Linq.XElement" />
    <altmember cref="T:System.Xml.Linq.XNode" />
    <related type="Article" href="/dotnet/standard/linq/linq-xml-overview"><span data-ttu-id="e8683-107">LINQ to XML 概述</span><span class="sxs-lookup"><span data-stu-id="e8683-107">LINQ to XML overview</span></span></related>
    <related type="Article" href="/dotnet/standard/linq/xdocument-class-overview"><span data-ttu-id="e8683-108">XDocument 类概述</span><span class="sxs-lookup"><span data-stu-id="e8683-108">XDocument Class Overview</span></span></related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="e8683-109">初始化 <see cref="T:System.Xml.Linq.XDocument" /> 类的新实例。</span><span class="sxs-lookup"><span data-stu-id="e8683-109">Initializes a new instance of the <see cref="T:System.Xml.Linq.XDocument" /> class.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8683-110">重载的构造函数使你能够创建新的空 <xref:System.Xml.Linq.XDocument> ; 以 <xref:System.Xml.Linq.XDocument> 使用一些指定的初始内容创建，并创建 <xref:System.Xml.Linq.XDocument> 作为另一个对象的副本 <xref:System.Xml.Linq.XDocument> 。</span><span class="sxs-lookup"><span data-stu-id="e8683-110">Overloaded constructors enable you to create a new empty <xref:System.Xml.Linq.XDocument>; to create an <xref:System.Xml.Linq.XDocument> with some specified initial content; and to create an <xref:System.Xml.Linq.XDocument> as a copy of another <xref:System.Xml.Linq.XDocument> object.</span></span>  
  
 <span data-ttu-id="e8683-111">需要您创建 <xref:System.Xml.Linq.XDocument> 的情况不是很多。</span><span class="sxs-lookup"><span data-stu-id="e8683-111">There are not many scenarios that require you to create an <xref:System.Xml.Linq.XDocument>.</span></span> <span data-ttu-id="e8683-112">而是通常使用 <xref:System.Xml.Linq.XElement> 根节点创建 XML 树。</span><span class="sxs-lookup"><span data-stu-id="e8683-112">Instead, you can usually create your XML trees with an <xref:System.Xml.Linq.XElement> root node.</span></span> <span data-ttu-id="e8683-113">除非对创建文档有特定要求（例如，因为必须在顶级创建处理指令和注释，或者必须支持文档类型），否则使用 <xref:System.Xml.Linq.XElement> 作为根节点通常更为方便。</span><span class="sxs-lookup"><span data-stu-id="e8683-113">Unless you have a specific requirement to create a document (for example, because you have to create processing instructions and comments at the top level, or you have to support document types), it is often more convenient to use <xref:System.Xml.Linq.XElement> as your root node.</span></span>  
  
 <span data-ttu-id="e8683-114">有关的有效内容的详细信息 <xref:System.Xml.Linq.XDocument> ，请参阅 [System.xml.linq.xelement> 和 XDocument 对象的有效内容](/dotnet/standard/linq/valid-content-xelement-xdocument-objects)。</span><span class="sxs-lookup"><span data-stu-id="e8683-114">For details about the valid content of an <xref:System.Xml.Linq.XDocument>, see [Valid Content of XElement and XDocument Objects](/dotnet/standard/linq/valid-content-xelement-xdocument-objects).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="e8683-115">下面的示例创建一个文档，然后向其中添加注释和一个元素。</span><span class="sxs-lookup"><span data-stu-id="e8683-115">The following example creates a document, and then adds a comment and an element to it.</span></span> <span data-ttu-id="e8683-116">然后，它使用查询结果撰写另一篇文档。</span><span class="sxs-lookup"><span data-stu-id="e8683-116">It then composes another document using the results of a query.</span></span>  
  
```csharp  
XDocument srcTree = new XDocument(  
    new XComment("This is a comment"),  
    new XElement("Root",  
        new XElement("Child1", "data1"),  
        new XElement("Child2", "data2"),  
        new XElement("Child3", "data3"),  
        new XElement("Child2", "data4"),  
        new XElement("Info5", "info5"),  
        new XElement("Info6", "info6"),  
        new XElement("Info7", "info7"),  
        new XElement("Info8", "info8")  
    )  
);  
  
XDocument doc = new XDocument(  
    new XComment("This is a comment"),  
    new XElement("Root",  
        from el in srcTree.Element("Root").Elements()  
        where ((string)el).StartsWith("data")  
        select el  
    )  
);  
Console.WriteLine(doc);  
```  
  
```vb  
Dim srcTree As XDocument = _   
    <?xml version="1.0" encoding="utf-8" standalone="yes"?>  
        <!--This is a comment-->  
        <Root>  
            <Child1>data1</Child1>  
            <Child2>data2</Child2>  
            <Child3>data3</Child3>  
            <Child2>data4</Child2>  
            <Info5>info5</Info5>  
            <Info6>info6</Info6>  
            <Info7>info7</Info7>  
            <Info8>info8</Info8>  
        </Root>  
Dim doc As XDocument = _   
    <?xml version="1.0" encoding="utf-8" standalone="yes"?>  
        <!--This is a comment-->  
        <Root>  
            <%= From el In srcTree.<Root>.Elements _  
                Where CStr(el).StartsWith("data") _  
                Select el %>  
        </Root>  
Console.WriteLine(doc)  
```  
  
 <span data-ttu-id="e8683-117">该示例产生下面的输出：</span><span class="sxs-lookup"><span data-stu-id="e8683-117">This example produces the following output:</span></span>  
  
```xml  
<!--This is a comment-->  
<Root>  
  <Child1>data1</Child1>  
  <Child2>data2</Child2>  
  <Child3>data3</Child3>  
  <Child2>data4</Child2>  
</Root>  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Xml.Linq.XDocument.Load" />
        <related type="Article" href="/dotnet/standard/linq/linq-xml-overview"><span data-ttu-id="e8683-118">LINQ to XML 概述</span><span class="sxs-lookup"><span data-stu-id="e8683-118">LINQ to XML overview</span></span></related>
        <related type="Article" href="/dotnet/standard/linq/xdocument-class-overview"><span data-ttu-id="e8683-119">XDocument 类概述</span><span class="sxs-lookup"><span data-stu-id="e8683-119">XDocument Class Overview</span></span></related>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XDocument ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XDocument.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XDocument();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="e8683-120">初始化 <see cref="T:System.Xml.Linq.XDocument" /> 类的新实例。</span><span class="sxs-lookup"><span data-stu-id="e8683-120">Initializes a new instance of the <see cref="T:System.Xml.Linq.XDocument" /> class.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8683-121">需要您创建 <xref:System.Xml.Linq.XDocument> 的情况不是很多。</span><span class="sxs-lookup"><span data-stu-id="e8683-121">There are not many scenarios that require you to create an <xref:System.Xml.Linq.XDocument>.</span></span> <span data-ttu-id="e8683-122">而是通常使用 <xref:System.Xml.Linq.XElement> 根节点创建 XML 树。</span><span class="sxs-lookup"><span data-stu-id="e8683-122">Instead, you can usually create your XML trees with an <xref:System.Xml.Linq.XElement> root node.</span></span> <span data-ttu-id="e8683-123">除非对创建文档有特定要求（例如，因为必须在顶级创建处理指令和注释，或者必须支持文档类型），否则使用 <xref:System.Xml.Linq.XElement> 作为根节点通常更为方便。</span><span class="sxs-lookup"><span data-stu-id="e8683-123">Unless you have a specific requirement to create a document (for example, because you have to create processing instructions and comments at the top level, or you have to support document types), it is often more convenient to use <xref:System.Xml.Linq.XElement> as your root node.</span></span>  
  
 <span data-ttu-id="e8683-124">有关的有效内容的详细信息 <xref:System.Xml.Linq.XDocument> ，请参阅 [System.xml.linq.xelement> 和 XDocument 对象的有效内容](/dotnet/standard/linq/valid-content-xelement-xdocument-objects)。</span><span class="sxs-lookup"><span data-stu-id="e8683-124">For details about the valid content of an <xref:System.Xml.Linq.XDocument>, see [Valid Content of XElement and XDocument Objects](/dotnet/standard/linq/valid-content-xelement-xdocument-objects).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="e8683-125">下面的示例创建一个新文档，然后向其中添加注释和一个元素。</span><span class="sxs-lookup"><span data-stu-id="e8683-125">The following example creates a new document, and then adds a comment and an element to it.</span></span>  
  
```csharp  
XDocument doc = new XDocument();  
doc.Add(new XComment("This is a comment"));  
doc.Add(new XElement("Root", "content"));  
Console.WriteLine(doc);  
```  
  
```vb  
Dim doc As XDocument = New XDocument()  
doc.Add(<!--This is a comment-->)  
doc.Add(<Root>content</Root>)  
Console.WriteLine(doc)  
```  
  
 <span data-ttu-id="e8683-126">该示例产生下面的输出：</span><span class="sxs-lookup"><span data-stu-id="e8683-126">This example produces the following output:</span></span>  
  
```xml  
<!--This is a comment-->  
<Root>content</Root>  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Xml.Linq.XDocument.Load" />
        <related type="Article" href="/dotnet/standard/linq/linq-xml-overview"><span data-ttu-id="e8683-127">LINQ to XML 概述</span><span class="sxs-lookup"><span data-stu-id="e8683-127">LINQ to XML overview</span></span></related>
        <related type="Article" href="/dotnet/standard/linq/xdocument-class-overview"><span data-ttu-id="e8683-128">XDocument 类概述</span><span class="sxs-lookup"><span data-stu-id="e8683-128">XDocument Class Overview</span></span></related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XDocument (params object[] content);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object[] content) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XDocument.#ctor(System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (ParamArray content As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XDocument(... cli::array &lt;System::Object ^&gt; ^ content);" />
      <MemberSignature Language="F#" Value="new System.Xml.Linq.XDocument : obj[] -&gt; System.Xml.Linq.XDocument" Usage="new System.Xml.Linq.XDocument content" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="content" Type="System.Object[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName Language="C#">[System.ParamArray]</AttributeName>
              <AttributeName Language="F#">[&lt;System.ParamArray&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="content"><span data-ttu-id="e8683-129">要添加到此文档的内容对象的参数列表。</span><span class="sxs-lookup"><span data-stu-id="e8683-129">A parameter list of content objects to add to this document.</span></span></param>
        <summary><span data-ttu-id="e8683-130">使用指定的内容初始化 <see cref="T:System.Xml.Linq.XDocument" /> 类的新实例。</span><span class="sxs-lookup"><span data-stu-id="e8683-130">Initializes a new instance of the <see cref="T:System.Xml.Linq.XDocument" /> class with the specified content.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8683-131">需要您创建 <xref:System.Xml.Linq.XDocument> 的情况不是很多。</span><span class="sxs-lookup"><span data-stu-id="e8683-131">There are not many scenarios that require you to create an <xref:System.Xml.Linq.XDocument>.</span></span> <span data-ttu-id="e8683-132">而是通常使用 <xref:System.Xml.Linq.XElement> 根节点创建 XML 树。</span><span class="sxs-lookup"><span data-stu-id="e8683-132">Instead, you can usually create your XML trees with an <xref:System.Xml.Linq.XElement> root node.</span></span> <span data-ttu-id="e8683-133">除非对创建文档有特定要求（例如，因为必须在顶级创建处理指令和注释，或者必须支持文档类型），否则使用 <xref:System.Xml.Linq.XElement> 作为根节点通常更为方便。</span><span class="sxs-lookup"><span data-stu-id="e8683-133">Unless you have a specific requirement to create a document (for example, because you have to create processing instructions and comments at the top level, or you have to support document types), it is often more convenient to use <xref:System.Xml.Linq.XElement> as your root node.</span></span>  
  
 <span data-ttu-id="e8683-134">有关的有效内容的详细信息 <xref:System.Xml.Linq.XDocument> ，请参阅 [System.xml.linq.xelement> 和 XDocument 对象的有效内容](/dotnet/standard/linq/valid-content-xelement-xdocument-objects)。</span><span class="sxs-lookup"><span data-stu-id="e8683-134">For details about the valid content of an <xref:System.Xml.Linq.XDocument>, see [Valid Content of XElement and XDocument Objects](/dotnet/standard/linq/valid-content-xelement-xdocument-objects).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="e8683-135">下面的示例创建一个文档，然后向其中添加注释和一个元素。</span><span class="sxs-lookup"><span data-stu-id="e8683-135">The following example creates a document, and then adds a comment and an element to it.</span></span> <span data-ttu-id="e8683-136">然后，它使用查询结果撰写另一篇文档。</span><span class="sxs-lookup"><span data-stu-id="e8683-136">It then composes another document using the results of a query.</span></span>  
  
```csharp  
XDocument srcTree = new XDocument(  
    new XComment("This is a comment"),  
    new XElement("Root",  
        new XElement("Child1", "data1"),  
        new XElement("Child2", "data2"),  
        new XElement("Child3", "data3"),  
        new XElement("Child2", "data4"),  
        new XElement("Info5", "info5"),  
        new XElement("Info6", "info6"),  
        new XElement("Info7", "info7"),  
        new XElement("Info8", "info8")  
    )  
);  
  
XDocument doc = new XDocument(  
    new XComment("This is a comment"),  
    new XElement("Root",  
        from el in srcTree.Element("Root").Elements()  
        where ((string)el).StartsWith("data")  
        select el  
    )  
);  
Console.WriteLine(doc);  
```  
  
```vb  
Dim srcTree As XDocument = _  
    <?xml version="1.0" encoding="utf-8" standalone="yes"?>  
        <!--This is a comment-->  
        <Root>  
            <Child1>data1</Child1>  
            <Child2>data2</Child2>  
            <Child3>data3</Child3>  
            <Child2>data4</Child2>  
            <Info5>info5</Info5>  
            <Info6>info6</Info6>  
            <Info7>info7</Info7>  
            <Info8>info8</Info8>  
        </Root>  
Dim doc As XDocument = _   
    <?xml version="1.0" encoding="utf-8" standalone="yes"?>  
        <!--This is a comment-->  
        <Root>  
            <%= From el In srcTree.<Root>.Elements _  
                Where CStr(el).StartsWith("data") _  
                Select el %>  
        </Root>  
Console.WriteLine(doc)  
```  
  
 <span data-ttu-id="e8683-137">该示例产生下面的输出：</span><span class="sxs-lookup"><span data-stu-id="e8683-137">This example produces the following output:</span></span>  
  
```xml  
<!--This is a comment-->  
<Root>  
  <Child1>data1</Child1>  
  <Child2>data2</Child2>  
  <Child3>data3</Child3>  
  <Child2>data4</Child2>  
</Root>  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Xml.Linq.XDocument.Load" />
        <related type="Article" href="/dotnet/standard/linq/linq-xml-overview"><span data-ttu-id="e8683-138">LINQ to XML 概述</span><span class="sxs-lookup"><span data-stu-id="e8683-138">LINQ to XML overview</span></span></related>
        <related type="Article" href="/dotnet/standard/linq/xdocument-class-overview"><span data-ttu-id="e8683-139">XDocument 类概述</span><span class="sxs-lookup"><span data-stu-id="e8683-139">XDocument Class Overview</span></span></related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XDocument (System.Xml.Linq.XDocument other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Xml.Linq.XDocument other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XDocument.#ctor(System.Xml.Linq.XDocument)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (other As XDocument)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XDocument(System::Xml::Linq::XDocument ^ other);" />
      <MemberSignature Language="F#" Value="new System.Xml.Linq.XDocument : System.Xml.Linq.XDocument -&gt; System.Xml.Linq.XDocument" Usage="new System.Xml.Linq.XDocument other" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="other" Type="System.Xml.Linq.XDocument" />
      </Parameters>
      <Docs>
        <param name="other"><span data-ttu-id="e8683-140">要复制的 <see cref="T:System.Xml.Linq.XDocument" /> 对象。</span><span class="sxs-lookup"><span data-stu-id="e8683-140">The <see cref="T:System.Xml.Linq.XDocument" /> object that will be copied.</span></span></param>
        <summary><span data-ttu-id="e8683-141">从现有的 <see cref="T:System.Xml.Linq.XDocument" /> 对象初始化 <see cref="T:System.Xml.Linq.XDocument" /> 类的新实例。</span><span class="sxs-lookup"><span data-stu-id="e8683-141">Initializes a new instance of the <see cref="T:System.Xml.Linq.XDocument" /> class from an existing <see cref="T:System.Xml.Linq.XDocument" /> object.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8683-142">使用此构造函数可以创建的深层副本 <xref:System.Xml.Linq.XDocument> 。</span><span class="sxs-lookup"><span data-stu-id="e8683-142">You use this constructor to make a deep copy of an <xref:System.Xml.Linq.XDocument>.</span></span>  
  
 <span data-ttu-id="e8683-143">此构造函数遍历参数中指定的文档中的所有节点和属性 `other` ，并创建所有节点的副本，因为它会汇编新初始化的 <xref:System.Xml.Linq.XDocument> 。</span><span class="sxs-lookup"><span data-stu-id="e8683-143">This constructor traverses all nodes and attributes in the document specified in the `other` parameter, and creates copies of all nodes as it assembles the newly initialized <xref:System.Xml.Linq.XDocument>.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Xml.Linq.XDocument.Load" />
        <related type="Article" href="/dotnet/standard/linq/linq-xml-overview"><span data-ttu-id="e8683-144">LINQ to XML 概述</span><span class="sxs-lookup"><span data-stu-id="e8683-144">LINQ to XML overview</span></span></related>
        <related type="Article" href="/dotnet/standard/linq/xdocument-class-overview"><span data-ttu-id="e8683-145">XDocument 类概述</span><span class="sxs-lookup"><span data-stu-id="e8683-145">XDocument Class Overview</span></span></related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XDocument (System.Xml.Linq.XDeclaration declaration, params object[] content);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Xml.Linq.XDeclaration declaration, object[] content) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XDocument.#ctor(System.Xml.Linq.XDeclaration,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (declaration As XDeclaration, ParamArray content As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XDocument(System::Xml::Linq::XDeclaration ^ declaration, ... cli::array &lt;System::Object ^&gt; ^ content);" />
      <MemberSignature Language="F#" Value="new System.Xml.Linq.XDocument : System.Xml.Linq.XDeclaration * obj[] -&gt; System.Xml.Linq.XDocument" Usage="new System.Xml.Linq.XDocument (declaration, content)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="declaration" Type="System.Xml.Linq.XDeclaration" />
        <Parameter Name="content" Type="System.Object[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName Language="C#">[System.ParamArray]</AttributeName>
              <AttributeName Language="F#">[&lt;System.ParamArray&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="declaration"><span data-ttu-id="e8683-146">文档的 <see cref="T:System.Xml.Linq.XDeclaration" />。</span><span class="sxs-lookup"><span data-stu-id="e8683-146">An <see cref="T:System.Xml.Linq.XDeclaration" /> for the document.</span></span></param>
        <param name="content"><span data-ttu-id="e8683-147">文档的内容。</span><span class="sxs-lookup"><span data-stu-id="e8683-147">The content of the document.</span></span></param>
        <summary><span data-ttu-id="e8683-148">用指定的 <see cref="T:System.Xml.Linq.XDocument" /> 和内容初始化 <see cref="T:System.Xml.Linq.XDeclaration" /> 类的新实例。</span><span class="sxs-lookup"><span data-stu-id="e8683-148">Initializes a new instance of the <see cref="T:System.Xml.Linq.XDocument" /> class with the specified <see cref="T:System.Xml.Linq.XDeclaration" /> and content.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8683-149">需要您创建 <xref:System.Xml.Linq.XDocument> 的情况不是很多。</span><span class="sxs-lookup"><span data-stu-id="e8683-149">There are not many scenarios that require you to create an <xref:System.Xml.Linq.XDocument>.</span></span> <span data-ttu-id="e8683-150">而是通常使用 <xref:System.Xml.Linq.XElement> 根节点创建 XML 树。</span><span class="sxs-lookup"><span data-stu-id="e8683-150">Instead, you can usually create your XML trees with an <xref:System.Xml.Linq.XElement> root node.</span></span> <span data-ttu-id="e8683-151">除非对创建文档有特定要求（例如，因为必须在顶级创建处理指令和注释，或者必须支持文档类型），否则使用 <xref:System.Xml.Linq.XElement> 作为根节点通常更为方便。</span><span class="sxs-lookup"><span data-stu-id="e8683-151">Unless you have a specific requirement to create a document (for example, because you have to create processing instructions and comments at the top level, or you have to support document types), it is often more convenient to use <xref:System.Xml.Linq.XElement> as your root node.</span></span>  
  
 <span data-ttu-id="e8683-152">有关的有效内容的详细信息 <xref:System.Xml.Linq.XDocument> ，请参阅 [System.xml.linq.xelement> 和 XDocument 对象的有效内容](/dotnet/standard/linq/valid-content-xelement-xdocument-objects)。</span><span class="sxs-lookup"><span data-stu-id="e8683-152">For details about the valid content of an <xref:System.Xml.Linq.XDocument>, see [Valid Content of XElement and XDocument Objects](/dotnet/standard/linq/valid-content-xelement-xdocument-objects).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="e8683-153">下面的示例使用此构造函数来创建文档。</span><span class="sxs-lookup"><span data-stu-id="e8683-153">The following example uses this constructor to create a document.</span></span>  
  
```csharp  
XDocument srcTree = new XDocument(  
    new XComment("This is a comment"),  
    new XElement("Root",  
        new XElement("Child1", "data1"),  
        new XElement("Child2", "data2"),  
        new XElement("Child3", "data3"),  
        new XElement("Child2", "data4"),  
        new XElement("Info5", "info5"),  
        new XElement("Info6", "info6"),  
        new XElement("Info7", "info7"),  
        new XElement("Info8", "info8")  
    )  
);  
  
XDocument doc = new XDocument(  
    new XDeclaration("1.0", "utf-8", "yes"),  
    new XComment("This is a new comment"),  
    new XElement("Root",  
        from el in srcTree.Element("Root").Elements()  
        where ((string)el).StartsWith("data")  
        select el  
    )  
);  
doc.Save("Test.xml");  
Console.WriteLine(File.ReadAllText("Test.xml"));  
```  
  
```vb  
Dim srcTree As XDocument = _   
    <?xml version="1.0" encoding="utf-8" standalone="yes"?>  
        <!--This is a comment-->  
        <Root>  
            <Child1>data1</Child1>  
            <Child2>data2</Child2>  
            <Child3>data3</Child3>  
            <Child2>data4</Child2>  
            <Info5>info5</Info5>  
            <Info6>info6</Info6>  
            <Info7>info7</Info7>  
            <Info8>info8</Info8>  
        </Root>  
Dim doc As XDocument = _   
    <?xml version="1.0" encoding="utf-8" standalone="yes"?>  
        <!--This is a new comment-->  
        <Root>  
            <%= From el In srcTree.<Root>.Elements _  
                Where CStr(el).StartsWith("data") _  
                Select el %>  
        </Root>  
doc.Save("Test.xml")  
Console.WriteLine(File.ReadAllText("Test.xml"))  
```  
  
 <span data-ttu-id="e8683-154">该示例产生下面的输出：</span><span class="sxs-lookup"><span data-stu-id="e8683-154">This example produces the following output:</span></span>  
  
```xml  
<?xml version="1.0" encoding="utf-8" standalone="yes"?>  
<!--This is a new comment-->  
<Root>  
  <Child1>data1</Child1>  
  <Child2>data2</Child2>  
  <Child3>data3</Child3>  
  <Child2>data4</Child2>  
</Root>  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Xml.Linq.XDocument.Load" />
        <related type="Article" href="/dotnet/standard/linq/linq-xml-overview"><span data-ttu-id="e8683-155">LINQ to XML 概述</span><span class="sxs-lookup"><span data-stu-id="e8683-155">LINQ to XML overview</span></span></related>
        <related type="Article" href="/dotnet/standard/linq/xdocument-class-overview"><span data-ttu-id="e8683-156">XDocument 类概述</span><span class="sxs-lookup"><span data-stu-id="e8683-156">XDocument Class Overview</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Declaration">
      <MemberSignature Language="C#" Value="public System.Xml.Linq.XDeclaration Declaration { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xml.Linq.XDeclaration Declaration" />
      <MemberSignature Language="DocId" Value="P:System.Xml.Linq.XDocument.Declaration" />
      <MemberSignature Language="VB.NET" Value="Public Property Declaration As XDeclaration" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xml::Linq::XDeclaration ^ Declaration { System::Xml::Linq::XDeclaration ^ get(); void set(System::Xml::Linq::XDeclaration ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Declaration : System.Xml.Linq.XDeclaration with get, set" Usage="System.Xml.Linq.XDocument.Declaration" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Xml.Linq.XDeclaration</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="e8683-157">获取或设置此文档的 XML 声明。</span><span class="sxs-lookup"><span data-stu-id="e8683-157">Gets or sets the XML declaration for this document.</span></span></summary>
        <value><span data-ttu-id="e8683-158">一个 <see cref="T:System.Xml.Linq.XDeclaration" />，其中包含此文档的 XML 声明。</span><span class="sxs-lookup"><span data-stu-id="e8683-158">An <see cref="T:System.Xml.Linq.XDeclaration" /> that contains the XML declaration for this document.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8683-159">有时，您必须为文档创建 XML 声明。</span><span class="sxs-lookup"><span data-stu-id="e8683-159">Sometimes you have to create an XML declaration for a document.</span></span> <span data-ttu-id="e8683-160">如果要指示文档是独立的，则必须使用此属性。</span><span class="sxs-lookup"><span data-stu-id="e8683-160">If you want to indicate that a document is standalone, you must use this property.</span></span> <span data-ttu-id="e8683-161">如果要使用 utf-8 以外的编码对文档进行编码，可以通过指定编码 <xref:System.Xml.Linq.XDeclaration> 。</span><span class="sxs-lookup"><span data-stu-id="e8683-161">If you want to encode your document with an encoding other than utf-8, you can specify an encoding through the <xref:System.Xml.Linq.XDeclaration>.</span></span> <span data-ttu-id="e8683-162">编码文档的另一种方法是在 <xref:System.Xml.XmlWriter> 传递到 LINQ to XML 进行写入的上指定编码。</span><span class="sxs-lookup"><span data-stu-id="e8683-162">Another approach for encoding a document is to specify the encoding on an <xref:System.Xml.XmlWriter> that you pass to LINQ to XML for writing.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="e8683-163">下面的示例使用此属性检索文档的 XML 声明。</span><span class="sxs-lookup"><span data-stu-id="e8683-163">The following example uses this property to retrieve the XML declaration of a document.</span></span>  
  
```csharp  
XDocument doc = new XDocument(  
    new XDeclaration("1.0", "utf-8", "yes"),  
    new XComment("This is a comment"),  
    new XElement("Root", "content")  
);  
  
Console.WriteLine(doc.Declaration);  
```  
  
```vb  
Dim doc As XDocument = _  
    <?xml version="1.0" encoding="utf-8" standalone="yes"?>  
        <!--This is a comment-->  
        <Root>content</Root>  
  
Console.WriteLine(doc.Declaration)  
```  
  
 <span data-ttu-id="e8683-164">该示例产生下面的输出：</span><span class="sxs-lookup"><span data-stu-id="e8683-164">This example produces the following output:</span></span>  
  
```  
<?xml version="1.0" encoding="utf-8" standalone="yes"?>  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.Linq.XDeclaration" />
        <related type="Article" href="/dotnet/standard/linq/linq-xml-overview"><span data-ttu-id="e8683-165">LINQ to XML 概述</span><span class="sxs-lookup"><span data-stu-id="e8683-165">LINQ to XML overview</span></span></related>
        <related type="Article" href="/dotnet/standard/linq/read-write-encoded-document"><span data-ttu-id="e8683-166">如何读取和写入编码文档</span><span class="sxs-lookup"><span data-stu-id="e8683-166">How to read and write an encoded document</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="DocumentType">
      <MemberSignature Language="C#" Value="public System.Xml.Linq.XDocumentType DocumentType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xml.Linq.XDocumentType DocumentType" />
      <MemberSignature Language="DocId" Value="P:System.Xml.Linq.XDocument.DocumentType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DocumentType As XDocumentType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xml::Linq::XDocumentType ^ DocumentType { System::Xml::Linq::XDocumentType ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DocumentType : System.Xml.Linq.XDocumentType" Usage="System.Xml.Linq.XDocument.DocumentType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Xml.Linq.XDocumentType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="e8683-167">获取此文档的文档类型定义 (DTD)。</span><span class="sxs-lookup"><span data-stu-id="e8683-167">Gets the Document Type Definition (DTD) for this document.</span></span></summary>
        <value><span data-ttu-id="e8683-168">一个包含此文档 DTD 的 <see cref="T:System.Xml.Linq.XDocumentType" />。</span><span class="sxs-lookup"><span data-stu-id="e8683-168">A <see cref="T:System.Xml.Linq.XDocumentType" /> that contains the DTD for this document.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [!INCLUDE[sqltecxlinq](~/includes/sqltecxlinq-md.md)] <span data-ttu-id="e8683-169">为 Dtd 提供有限的支持。</span><span class="sxs-lookup"><span data-stu-id="e8683-169">provides limited support for DTDs.</span></span>  
  
 <span data-ttu-id="e8683-170">您可以使用包含 DTD 的 XML 文档填充 XML 树。</span><span class="sxs-lookup"><span data-stu-id="e8683-170">You can populate an XML tree with an XML document that contains a DTD.</span></span> <span data-ttu-id="e8683-171">然后，XML 树将包含一个 <xref:System.Xml.Linq.XDocument.DocumentType%2A> 节点。</span><span class="sxs-lookup"><span data-stu-id="e8683-171">The XML tree will then contain a <xref:System.Xml.Linq.XDocument.DocumentType%2A> node.</span></span> <span data-ttu-id="e8683-172">序列化或保存树时，DTD 也将序列化。</span><span class="sxs-lookup"><span data-stu-id="e8683-172">When you serialize or save the tree, the DTD will also be serialized.</span></span> [!INCLUDE[sqltecxlinq](~/includes/sqltecxlinq-md.md)] <span data-ttu-id="e8683-173">将展开 DTD 中的所有实体。</span><span class="sxs-lookup"><span data-stu-id="e8683-173">will expand any entities in the DTD.</span></span> <span data-ttu-id="e8683-174">序列化或保存 XML 树时，不会保存实体引用;相反，节点会随实体文本所替换的实体引用一起保存。</span><span class="sxs-lookup"><span data-stu-id="e8683-174">When you serialize or save the XML tree, the entity references are not saved; instead, the nodes are saved with the entity references replaced by the text of the entity.</span></span>  
  
 <span data-ttu-id="e8683-175">如果 DTD 包含默认属性，则会在 XML 树中以普通属性的形式创建特性。</span><span class="sxs-lookup"><span data-stu-id="e8683-175">If the DTD contains default attributes, the attributes are created in the XML tree as ordinary attributes.</span></span>  
  
 <span data-ttu-id="e8683-176">默认情况下，不 [!INCLUDE[sqltecxlinq](~/includes/sqltecxlinq-md.md)] 会根据文档的 DTD 验证文档。</span><span class="sxs-lookup"><span data-stu-id="e8683-176">By default, [!INCLUDE[sqltecxlinq](~/includes/sqltecxlinq-md.md)] does not validate a document based on its DTD.</span></span> <span data-ttu-id="e8683-177">若要基于 DTD 验证文档，请创建 <xref:System.Xml.XmlReader> 将基于 dtd 进行验证的，然后从创建 XML 树 <xref:System.Xml.XmlReader> 。</span><span class="sxs-lookup"><span data-stu-id="e8683-177">To validate a document based on a DTD, create an <xref:System.Xml.XmlReader> that will validate based on a DTD, and then create an XML tree from the <xref:System.Xml.XmlReader>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="e8683-178">下面的示例创建一个包含的文档 <xref:System.Xml.Linq.XDocumentType> 。</span><span class="sxs-lookup"><span data-stu-id="e8683-178">The following example creates a document that contains an <xref:System.Xml.Linq.XDocumentType>.</span></span>  
  
 <span data-ttu-id="e8683-179">Visual Basic 不支持 XML 文本中的文档类型。</span><span class="sxs-lookup"><span data-stu-id="e8683-179">Visual Basic does not support document types within XML literals.</span></span> <span data-ttu-id="e8683-180">但是，可以通过先使用 XML 文本创建文档，然后 <xref:System.Xml.Linq.XDocumentType> 在 XML 树中的适当位置创建和添加节点，来创建包含文档类型的文档。</span><span class="sxs-lookup"><span data-stu-id="e8683-180">However, it is possible to create a document that contains a document type by first creating the document using XML literals, and then creating and adding an <xref:System.Xml.Linq.XDocumentType> node in the appropriate place in the XML tree.</span></span>  
  
```csharp  
string internalSubset = @"<!ELEMENT Pubs (Book+)>  
<!ELEMENT Book (Title, Author)>  
<!ELEMENT Title (#PCDATA)>  
<!ELEMENT Author (#PCDATA)>";  
  
string target = "xml-stylesheet";  
string data = "href='mystyle.css' title='Compact' type='text/css'";  
  
XDocument doc = new XDocument(  
    new XComment("This is a comment."),  
    new XProcessingInstruction(target, data),  
    new XDocumentType("Pubs", null, null, internalSubset),  
    new XElement("Pubs",   
        new XElement("Book",  
            new XElement("Title", "Artifacts of Roman Civilization"),  
            new XElement("Author", "Moreno, Jordao")  
        ),  
        new XElement("Book",  
            new XElement("Title", "Midieval Tools and Implements"),  
            new XElement("Author", "Gazit, Inbar")  
        )  
    ),  
    new XComment("This is another comment.")  
);  
doc.Declaration = new XDeclaration("1.0", "utf-8", "true");  
Console.WriteLine(doc);  
  
doc.Save("test.xml");  
```  
  
```vb  
Dim internalSubset = _  
        "<!ELEMENT Pubs (Book+)>" & Environment.NewLine & _  
        "<!ELEMENT Book (Title, Author)>" & Environment.NewLine & _  
        "<!ELEMENT Title (#PCDATA)>" & Environment.NewLine & _  
        "<!ELEMENT Author (#PCDATA)>"  
  
Dim doc As XDocument = _  
    <?xml version="1.0" encoding="utf-8" standalone="yes"?>  
    <!--This is a comment.-->  
    <?xml-stylesheet href='mystyle.css' title='Compact' type='text/css'?>  
    <Pubs>  
        <Book>  
            <Title>Artifacts of Roman Civilization</Title>  
            <Author>Moreno, Jordao</Author>  
        </Book>  
        <Book>  
            <Title>Midieval Tools and Implements</Title>  
            <Author>Gazit, Inbar</Author>  
        </Book>  
    </Pubs>  
    <!--This is another comment.-->  
  
doc.Nodes().Skip(1).First().AddAfterSelf(New XDocumentType("Pubs", Nothing, Nothing, internalSubset))  
Console.WriteLine(doc)  
```  
  
 <span data-ttu-id="e8683-181">该示例产生下面的输出：</span><span class="sxs-lookup"><span data-stu-id="e8683-181">This example produces the following output:</span></span>  
  
```xml  
<!--This is a comment.-->  
<?xml-stylesheet href='mystyle.css' title='Compact' type='text/css'?>  
<!DOCTYPE Pubs [<!ELEMENT Pubs (Book+)>  
<!ELEMENT Book (Title, Author)>  
<!ELEMENT Title (#PCDATA)>  
<!ELEMENT Author (#PCDATA)>]>  
<Pubs>  
  <Book>  
    <Title>Artifacts of Roman Civilization</Title>  
    <Author>Moreno, Jordao</Author>  
  </Book>  
  <Book>  
    <Title>Midieval Tools and Implements</Title>  
    <Author>Gazit, Inbar</Author>  
  </Book>  
</Pubs>  
<!--This is another comment.-->  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.Linq.XDocumentType" />
        <altmember cref="P:System.Xml.Linq.XDocument.NodeType" />
        <related type="Article" href="/dotnet/standard/linq/linq-xml-overview"><span data-ttu-id="e8683-182">LINQ to XML 概述</span><span class="sxs-lookup"><span data-stu-id="e8683-182">LINQ to XML overview</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Load">
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="e8683-183">从 URI 所指定的文件、<see cref="T:System.Xml.Linq.XDocument" /> 或 <see cref="T:System.IO.TextReader" /> 创建新 <see cref="T:System.Xml.XmlReader" />。</span><span class="sxs-lookup"><span data-stu-id="e8683-183">Creates a new <see cref="T:System.Xml.Linq.XDocument" /> from a file specified by a URI, from an <see cref="T:System.IO.TextReader" />, or from an <see cref="T:System.Xml.XmlReader" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8683-184">使用此方法的重载之一，你可以 <xref:System.Xml.Linq.XDocument> 从文件、 <xref:System.IO.TextReader> 或加载 <xref:System.Xml.XmlReader> 。</span><span class="sxs-lookup"><span data-stu-id="e8683-184">Using one of the overloads of this method, you can load an <xref:System.Xml.Linq.XDocument> from a file, a <xref:System.IO.TextReader>, or an <xref:System.Xml.XmlReader>.</span></span>  
  
 <span data-ttu-id="e8683-185">若要 <xref:System.Xml.Linq.XDocument> 从包含 XML 的字符串创建，请使用 <xref:System.Xml.Linq.XDocument.Parse%2A> 。</span><span class="sxs-lookup"><span data-stu-id="e8683-185">To create an <xref:System.Xml.Linq.XDocument> from a string that contains XML, use <xref:System.Xml.Linq.XDocument.Parse%2A>.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Xml.Linq.XDocument.Parse" />
        <altmember cref="Overload:System.Xml.Linq.XDocument.Save" />
        <altmember cref="M:System.Xml.Linq.XDocument.WriteTo(System.Xml.XmlWriter)" />
        <related type="Article" href="/dotnet/standard/linq/linq-xml-overview"><span data-ttu-id="e8683-186">LINQ to XML 概述</span><span class="sxs-lookup"><span data-stu-id="e8683-186">LINQ to XML overview</span></span></related>
        <related type="Article" href="/dotnet/standard/linq/query-xdocument-vs-query-xelement"><span data-ttu-id="e8683-187">查询 XDocument 与查询 System.xml.linq.xelement&gt;</span><span class="sxs-lookup"><span data-stu-id="e8683-187">Query an XDocument vs. query an XElement</span></span></related>
      </Docs>
    </MemberGroup>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static System.Xml.Linq.XDocument Load (System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.Linq.XDocument Load(class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XDocument.Load(System.IO.Stream)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Load (stream As Stream) As XDocument" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Xml::Linq::XDocument ^ Load(System::IO::Stream ^ stream);" />
      <MemberSignature Language="F#" Value="static member Load : System.IO.Stream -&gt; System.Xml.Linq.XDocument" Usage="System.Xml.Linq.XDocument.Load stream" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Xml.Linq.XDocument</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="stream"><span data-ttu-id="e8683-188">包含 XML 数据的流。</span><span class="sxs-lookup"><span data-stu-id="e8683-188">The stream that contains the XML data.</span></span></param>
        <summary><span data-ttu-id="e8683-189">使用指定的流创建一个新的 <see cref="T:System.Xml.Linq.XDocument" /> 实例。</span><span class="sxs-lookup"><span data-stu-id="e8683-189">Creates a new <see cref="T:System.Xml.Linq.XDocument" /> instance by using the specified stream.</span></span></summary>
        <returns><span data-ttu-id="e8683-190">一个可读取流中所包含数据的 <see cref="T:System.Xml.Linq.XDocument" /> 对象。</span><span class="sxs-lookup"><span data-stu-id="e8683-190">An <see cref="T:System.Xml.Linq.XDocument" /> object that reads the data that is contained in the stream.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8683-191">如果要控制加载选项，请使用 <xref:System.Xml.Linq.XDocument.Load%2A> 采用作为参数的重载 <xref:System.Xml.Linq.LoadOptions> 。</span><span class="sxs-lookup"><span data-stu-id="e8683-191">If you want to control load options, use the <xref:System.Xml.Linq.XDocument.Load%2A> overload that takes <xref:System.Xml.Linq.LoadOptions> as a parameter.</span></span>  
  
 <span data-ttu-id="e8683-192">LINQ to XML 的加载功能是基于生成的 <xref:System.Xml.XmlReader> 。</span><span class="sxs-lookup"><span data-stu-id="e8683-192">The loading functionality of LINQ to XML is built upon <xref:System.Xml.XmlReader>.</span></span> <span data-ttu-id="e8683-193">因此，你可能会捕获重载方法所引发的任何异常 <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> 和 <xref:System.Xml.XmlReader> 读取和分析文档的方法。</span><span class="sxs-lookup"><span data-stu-id="e8683-193">Therefore, you might catch any exceptions that are thrown by the <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> overload methods and the <xref:System.Xml.XmlReader> methods that read and parse the document.</span></span>  
  
 <span data-ttu-id="e8683-194">如果必须修改，请 <xref:System.Xml.XmlReaderSettings> 执行以下步骤：</span><span class="sxs-lookup"><span data-stu-id="e8683-194">If you have to modify <xref:System.Xml.XmlReaderSettings>, follow these steps:</span></span>  
  
1.  <span data-ttu-id="e8683-195"><xref:System.Xml.XmlReader>通过调用 <xref:System.Xml.XmlReader.Create%2A> 采用作为参数的重载之一来创建 <xref:System.Xml.XmlReaderSettings> 。</span><span class="sxs-lookup"><span data-stu-id="e8683-195">Create an <xref:System.Xml.XmlReader> by calling one of the <xref:System.Xml.XmlReader.Create%2A> overloads that take <xref:System.Xml.XmlReaderSettings> as a parameter.</span></span>  
  
2.  <span data-ttu-id="e8683-196">将传递 <xref:System.Xml.XmlReader> 给 <xref:System.Xml.Linq.XDocument.Load%2A> <xref:System.Xml.Linq.XDocument> 采用作为参数的重载之一 <xref:System.Xml.XmlReader> 。</span><span class="sxs-lookup"><span data-stu-id="e8683-196">Pass the <xref:System.Xml.XmlReader> to one of the <xref:System.Xml.Linq.XDocument.Load%2A> overloads of <xref:System.Xml.Linq.XDocument> that takes <xref:System.Xml.XmlReader> as a parameter.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static System.Xml.Linq.XDocument Load (System.IO.TextReader textReader);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.Linq.XDocument Load(class System.IO.TextReader textReader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XDocument.Load(System.IO.TextReader)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Load (textReader As TextReader) As XDocument" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Xml::Linq::XDocument ^ Load(System::IO::TextReader ^ textReader);" />
      <MemberSignature Language="F#" Value="static member Load : System.IO.TextReader -&gt; System.Xml.Linq.XDocument" Usage="System.Xml.Linq.XDocument.Load textReader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Xml.Linq.XDocument</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="textReader" Type="System.IO.TextReader" />
      </Parameters>
      <Docs>
        <param name="textReader"><span data-ttu-id="e8683-197">一个 <see cref="T:System.IO.TextReader" />，其中包含 <see cref="T:System.Xml.Linq.XDocument" /> 的内容。</span><span class="sxs-lookup"><span data-stu-id="e8683-197">A <see cref="T:System.IO.TextReader" /> that contains the content for the <see cref="T:System.Xml.Linq.XDocument" />.</span></span></param>
        <summary><span data-ttu-id="e8683-198">从 <see cref="T:System.Xml.Linq.XDocument" /> 创建新的 <see cref="T:System.IO.TextReader" />。</span><span class="sxs-lookup"><span data-stu-id="e8683-198">Creates a new <see cref="T:System.Xml.Linq.XDocument" /> from a <see cref="T:System.IO.TextReader" />.</span></span></summary>
        <returns><span data-ttu-id="e8683-199">一个 <see cref="T:System.Xml.Linq.XDocument" />，其中包含指定 <see cref="T:System.IO.TextReader" /> 的内容。</span><span class="sxs-lookup"><span data-stu-id="e8683-199">An <see cref="T:System.Xml.Linq.XDocument" /> that contains the contents of the specified <see cref="T:System.IO.TextReader" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8683-200">LINQ to XML 的加载功能是基于生成的 <xref:System.Xml.XmlReader> 。</span><span class="sxs-lookup"><span data-stu-id="e8683-200">LINQ to XML's loading functionality is built upon <xref:System.Xml.XmlReader>.</span></span> <span data-ttu-id="e8683-201">因此，你可能会捕获重载方法所引发的任何异常 <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> 和 <xref:System.Xml.XmlReader> 读取和分析文档的方法。</span><span class="sxs-lookup"><span data-stu-id="e8683-201">Therefore, you might catch any exceptions that are thrown by the <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> overload methods and the <xref:System.Xml.XmlReader> methods that read and parse the document.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="e8683-202">下面的示例从创建一个文档 <xref:System.IO.StringReader> 。</span><span class="sxs-lookup"><span data-stu-id="e8683-202">The following example creates a document from a <xref:System.IO.StringReader>.</span></span>  
  
```csharp  
TextReader tr = new StringReader("<Root>Content</Root>");  
XDocument doc = XDocument.Load(tr);  
Console.WriteLine(doc);  
```  
  
```vb  
Dim tr As TextReader = New StringReader("<Root>Content</Root>")  
Dim doc As XDocument = XDocument.Load(tr)  
Console.WriteLine(doc)  
```  
  
 <span data-ttu-id="e8683-203">该示例产生下面的输出：</span><span class="sxs-lookup"><span data-stu-id="e8683-203">This example produces the following output:</span></span>  
  
```xml  
<Root>Content</Root>  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Xml.Linq.XDocument.Parse" />
        <altmember cref="Overload:System.Xml.Linq.XDocument.Save" />
        <altmember cref="M:System.Xml.Linq.XDocument.WriteTo(System.Xml.XmlWriter)" />
        <related type="Article" href="/dotnet/standard/linq/linq-xml-overview"><span data-ttu-id="e8683-204">LINQ to XML 概述</span><span class="sxs-lookup"><span data-stu-id="e8683-204">LINQ to XML overview</span></span></related>
        <related type="Article" href="/dotnet/standard/linq/query-xdocument-vs-query-xelement"><span data-ttu-id="e8683-205">查询 XDocument 与查询 System.xml.linq.xelement&gt;</span><span class="sxs-lookup"><span data-stu-id="e8683-205">Query an XDocument vs. query an XElement</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static System.Xml.Linq.XDocument Load (string uri);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.Linq.XDocument Load(string uri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XDocument.Load(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Load (uri As String) As XDocument" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Xml::Linq::XDocument ^ Load(System::String ^ uri);" />
      <MemberSignature Language="F#" Value="static member Load : string -&gt; System.Xml.Linq.XDocument" Usage="System.Xml.Linq.XDocument.Load uri" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Xml.Linq.XDocument</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uri" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="uri"><span data-ttu-id="e8683-206">一个 URI 字符串，它引用要加载到新 <see cref="T:System.Xml.Linq.XDocument" /> 中的文件。</span><span class="sxs-lookup"><span data-stu-id="e8683-206">A URI string that references the file to load into a new <see cref="T:System.Xml.Linq.XDocument" />.</span></span></param>
        <summary><span data-ttu-id="e8683-207">从文件创建新 <see cref="T:System.Xml.Linq.XDocument" />。</span><span class="sxs-lookup"><span data-stu-id="e8683-207">Creates a new <see cref="T:System.Xml.Linq.XDocument" /> from a file.</span></span></summary>
        <returns><span data-ttu-id="e8683-208">一个包含指定文件的内容的 <see cref="T:System.Xml.Linq.XDocument" />。</span><span class="sxs-lookup"><span data-stu-id="e8683-208">An <see cref="T:System.Xml.Linq.XDocument" /> that contains the contents of the specified file.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8683-209">此方法使用基础 <xref:System.Xml.XmlReader> 将 xml 读入 xml 树。</span><span class="sxs-lookup"><span data-stu-id="e8683-209">This method uses an underlying <xref:System.Xml.XmlReader> to read the XML into an XML tree.</span></span>  
  
 <span data-ttu-id="e8683-210">使用 <xref:System.Xml.Linq.XDocument.Parse%2A> <xref:System.Xml.Linq.XDocument> 从包含 XML 的字符串创建。</span><span class="sxs-lookup"><span data-stu-id="e8683-210">Use <xref:System.Xml.Linq.XDocument.Parse%2A> to create an <xref:System.Xml.Linq.XDocument> from a string that contains XML.</span></span>  
  
 <span data-ttu-id="e8683-211">LINQ to XML 的加载功能是基于生成的 <xref:System.Xml.XmlReader> 。</span><span class="sxs-lookup"><span data-stu-id="e8683-211">LINQ to XML's loading functionality is built upon <xref:System.Xml.XmlReader>.</span></span> <span data-ttu-id="e8683-212">因此，你可能会捕获重载方法所引发的任何异常 <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> 和 <xref:System.Xml.XmlReader> 读取和分析文档的方法。</span><span class="sxs-lookup"><span data-stu-id="e8683-212">Therefore, you might catch any exceptions that are thrown by the <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> overload methods and the <xref:System.Xml.XmlReader> methods that read and parse the document.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="e8683-213">下面的示例演示如何 <xref:System.Xml.Linq.XDocument> 从文件加载。</span><span class="sxs-lookup"><span data-stu-id="e8683-213">The following example shows how to load an <xref:System.Xml.Linq.XDocument> from a file.</span></span>  
  
 <span data-ttu-id="e8683-214">此示例使用下面的 XML 文档：</span><span class="sxs-lookup"><span data-stu-id="e8683-214">This example uses the following XML document:</span></span>  
  
 [<span data-ttu-id="e8683-215">示例 XML 文件：典型采购订单 (LINQ to XML)</span><span class="sxs-lookup"><span data-stu-id="e8683-215">Sample XML File: Typical Purchase Order (LINQ to XML)</span></span>](/dotnet/standard/linq/sample-xml-file-typical-purchase-order)  
  
```csharp  
XDocument doc = XDocument.Load("PurchaseOrder.xml");  
Console.WriteLine(doc);  
```  
  
```vb  
Dim doc As XDocument = XDocument.Load("PurchaseOrder.xml")  
Console.WriteLine(doc)  
```  
  
 <span data-ttu-id="e8683-216">该示例产生下面的输出：</span><span class="sxs-lookup"><span data-stu-id="e8683-216">This example produces the following output:</span></span>  
  
```  
<PurchaseOrder PurchaseOrderNumber="99503" OrderDate="1999-10-20">  
  <Address Type="Shipping">  
    <Name>Ellen Adams</Name>  
    <Street>123 Maple Street</Street>  
    <City>Mill Valley</City>  
    <State>CA</State>  
    <Zip>10999</Zip>  
    <Country>USA</Country>  
  </Address>  
  <Address Type="Billing">  
    <Name>Tai Yee</Name>  
    <Street>8 Oak Avenue</Street>  
    <City>Old Town</City>  
    <State>PA</State>  
    <Zip>95819</Zip>  
    <Country>USA</Country>  
  </Address>  
  <DeliveryNotes>Please leave packages in shed by driveway.</DeliveryNotes>  
  <Items>  
    <Item PartNumber="872-AA">  
      <ProductName>Lawnmower</ProductName>  
      <Quantity>1</Quantity>  
      <USPrice>148.95</USPrice>  
      <Comment>Confirm this is electric</Comment>  
    </Item>  
    <Item PartNumber="926-AA">  
      <ProductName>Baby Monitor</ProductName>  
      <Quantity>2</Quantity>  
      <USPrice>39.98</USPrice>  
      <ShipDate>1999-05-21</ShipDate>  
    </Item>  
  </Items>  
</PurchaseOrder>  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Xml.Linq.XDocument.Parse" />
        <altmember cref="Overload:System.Xml.Linq.XDocument.Save" />
        <altmember cref="M:System.Xml.Linq.XDocument.WriteTo(System.Xml.XmlWriter)" />
        <related type="Article" href="/dotnet/standard/linq/linq-xml-overview"><span data-ttu-id="e8683-217">LINQ to XML 概述</span><span class="sxs-lookup"><span data-stu-id="e8683-217">LINQ to XML overview</span></span></related>
        <related type="Article" href="/dotnet/standard/linq/query-xdocument-vs-query-xelement"><span data-ttu-id="e8683-218">查询 XDocument 与查询 System.xml.linq.xelement&gt;</span><span class="sxs-lookup"><span data-stu-id="e8683-218">Query an XDocument vs. query an XElement</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static System.Xml.Linq.XDocument Load (System.Xml.XmlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.Linq.XDocument Load(class System.Xml.XmlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XDocument.Load(System.Xml.XmlReader)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Load (reader As XmlReader) As XDocument" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Xml::Linq::XDocument ^ Load(System::Xml::XmlReader ^ reader);" />
      <MemberSignature Language="F#" Value="static member Load : System.Xml.XmlReader -&gt; System.Xml.Linq.XDocument" Usage="System.Xml.Linq.XDocument.Load reader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Xml.Linq.XDocument</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="reader"><span data-ttu-id="e8683-219">一个 <see cref="T:System.Xml.XmlReader" />，其中包含 <see cref="T:System.Xml.Linq.XDocument" /> 的内容。</span><span class="sxs-lookup"><span data-stu-id="e8683-219">A <see cref="T:System.Xml.XmlReader" /> that contains the content for the <see cref="T:System.Xml.Linq.XDocument" />.</span></span></param>
        <summary><span data-ttu-id="e8683-220">从 <see cref="T:System.Xml.Linq.XDocument" /> 创建新 <see cref="T:System.Xml.XmlReader" />。</span><span class="sxs-lookup"><span data-stu-id="e8683-220">Creates a new <see cref="T:System.Xml.Linq.XDocument" /> from an <see cref="T:System.Xml.XmlReader" />.</span></span></summary>
        <returns><span data-ttu-id="e8683-221">一个 <see cref="T:System.Xml.Linq.XDocument" />，其中包含指定 <see cref="T:System.Xml.XmlReader" /> 的内容。</span><span class="sxs-lookup"><span data-stu-id="e8683-221">An <see cref="T:System.Xml.Linq.XDocument" /> that contains the contents of the specified <see cref="T:System.Xml.XmlReader" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8683-222">此方法的一种可能用途是在 LINQ to XML 树中创建 DOM 文档的副本。</span><span class="sxs-lookup"><span data-stu-id="e8683-222">One possible use for this method is to create a copy of a DOM document in a LINQ to XML tree.</span></span> <span data-ttu-id="e8683-223">为此，请 <xref:System.Xml.XmlNodeReader> 从 DOM 文档创建，然后使用 <xref:System.Xml.XmlNodeReader> 创建 <xref:System.Xml.Linq.XDocument> 。</span><span class="sxs-lookup"><span data-stu-id="e8683-223">To do this, you create an <xref:System.Xml.XmlNodeReader> from a DOM document, and then use the <xref:System.Xml.XmlNodeReader> to create an <xref:System.Xml.Linq.XDocument>.</span></span>  
  
 <span data-ttu-id="e8683-224">LINQ to XML 的加载功能是基于生成的 <xref:System.Xml.XmlReader> 。</span><span class="sxs-lookup"><span data-stu-id="e8683-224">LINQ to XML's loading functionality is built upon <xref:System.Xml.XmlReader>.</span></span> <span data-ttu-id="e8683-225">因此，你可能会捕获重载方法所引发的任何异常 <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> 和 <xref:System.Xml.XmlReader> 读取和分析文档的方法。</span><span class="sxs-lookup"><span data-stu-id="e8683-225">Therefore, you might catch any exceptions that are thrown by the <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> overload methods and the <xref:System.Xml.XmlReader> methods that read and parse the document.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="e8683-226">下面的示例创建一个 DOM 文档， <xref:System.Xml.XmlNodeReader> 从 DOM 文档创建，使用创建一个 <xref:System.Xml.Linq.XDocument> <xref:System.Xml.XmlNodeReader> 。</span><span class="sxs-lookup"><span data-stu-id="e8683-226">The following example creates a DOM document, creates an <xref:System.Xml.XmlNodeReader> from the DOM document, creates an <xref:System.Xml.Linq.XDocument> using the <xref:System.Xml.XmlNodeReader>.</span></span>  
  
```csharp  
// Create a DOM document with some content.  
XmlDocument doc = new XmlDocument();  
XmlElement child = doc.CreateElement("Child");  
child.InnerText = "child contents";  
XmlElement root = doc.CreateElement("Root");  
root.AppendChild(child);  
doc.AppendChild(root);  
  
// create a reader and move to the content  
using (XmlNodeReader nodeReader = new XmlNodeReader(doc)) {  
    // the reader must be in the Interactive state in order to  
    // create a LINQ to XML tree from it.  
    nodeReader.MoveToContent();  
  
    XDocument xRoot = XDocument.Load(nodeReader);  
    Console.WriteLine(xRoot);  
}  
```  
  
```vb  
' Create a DOM document with some content.  
Dim doc As XmlDocument = New XmlDocument()  
Dim child As XmlElement = doc.CreateElement("Child")  
child.InnerText = "child contents"  
Dim root As XmlElement = doc.CreateElement("Root")  
root.AppendChild(child)  
doc.AppendChild(root)  
  
' create a reader and move to the content  
Using nodeReader = New XmlNodeReader(doc)  
    ' the reader must be in the Interactive state in order to  
    ' create a LINQ to XML tree from it.  
    nodeReader.MoveToContent()  
  
    Dim xRoot As XDocument = XDocument.Load(nodeReader)  
    Console.WriteLine(xRoot)  
End Using  
```  
  
 <span data-ttu-id="e8683-227">该示例产生下面的输出：</span><span class="sxs-lookup"><span data-stu-id="e8683-227">This example produces the following output:</span></span>  
  
```xml  
<Root>  
  <Child>child contents</Child>  
</Root>  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Xml.Linq.XDocument.Parse" />
        <altmember cref="Overload:System.Xml.Linq.XDocument.Save" />
        <altmember cref="M:System.Xml.Linq.XDocument.WriteTo(System.Xml.XmlWriter)" />
        <related type="Article" href="/dotnet/standard/linq/linq-xml-overview"><span data-ttu-id="e8683-228">LINQ to XML 概述</span><span class="sxs-lookup"><span data-stu-id="e8683-228">LINQ to XML overview</span></span></related>
        <related type="Article" href="/dotnet/standard/linq/query-xdocument-vs-query-xelement"><span data-ttu-id="e8683-229">查询 XDocument 与查询 System.xml.linq.xelement&gt;</span><span class="sxs-lookup"><span data-stu-id="e8683-229">Query an XDocument vs. query an XElement</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static System.Xml.Linq.XDocument Load (System.IO.Stream stream, System.Xml.Linq.LoadOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.Linq.XDocument Load(class System.IO.Stream stream, valuetype System.Xml.Linq.LoadOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XDocument.Load(System.IO.Stream,System.Xml.Linq.LoadOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Load (stream As Stream, options As LoadOptions) As XDocument" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Xml::Linq::XDocument ^ Load(System::IO::Stream ^ stream, System::Xml::Linq::LoadOptions options);" />
      <MemberSignature Language="F#" Value="static member Load : System.IO.Stream * System.Xml.Linq.LoadOptions -&gt; System.Xml.Linq.XDocument" Usage="System.Xml.Linq.XDocument.Load (stream, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Linq.XDocument</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="options" Type="System.Xml.Linq.LoadOptions" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="stream"><span data-ttu-id="e8683-230">包含 XML 数据的流。</span><span class="sxs-lookup"><span data-stu-id="e8683-230">The stream containing the XML data.</span></span></param>
        <param name="options"><span data-ttu-id="e8683-231">一个 <see cref="T:System.Xml.Linq.LoadOptions" />，指定是否加载基 URI 和行信息。</span><span class="sxs-lookup"><span data-stu-id="e8683-231">A <see cref="T:System.Xml.Linq.LoadOptions" /> that specifies whether to load base URI and line information.</span></span></param>
        <summary><span data-ttu-id="e8683-232">使用指定流创建新的 <see cref="T:System.Xml.Linq.XDocument" /> 实例，也可以选择保留空白，设置基 URI 和保留行信息。</span><span class="sxs-lookup"><span data-stu-id="e8683-232">Creates a new <see cref="T:System.Xml.Linq.XDocument" /> instance by using the specified stream, optionally preserving white space, setting the base URI, and retaining line information.</span></span></summary>
        <returns><span data-ttu-id="e8683-233">一个可读取流中所包含数据的 <see cref="T:System.Xml.Linq.XDocument" /> 对象。</span><span class="sxs-lookup"><span data-stu-id="e8683-233">An <see cref="T:System.Xml.Linq.XDocument" /> object that reads the data that is contained in the stream.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8683-234">LINQ to XML 的加载功能是基于生成的 <xref:System.Xml.XmlReader> 。</span><span class="sxs-lookup"><span data-stu-id="e8683-234">The loading functionality of LINQ to XML is built upon <xref:System.Xml.XmlReader>.</span></span> <span data-ttu-id="e8683-235">因此，你可能会捕获重载方法所引发的任何异常 <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> 和 <xref:System.Xml.XmlReader> 读取和分析文档的方法。</span><span class="sxs-lookup"><span data-stu-id="e8683-235">Therefore, you might catch any exceptions that are thrown by the <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> overload methods and the <xref:System.Xml.XmlReader> methods that read and parse the document.</span></span>  
  
 <span data-ttu-id="e8683-236">如果必须修改，请 <xref:System.Xml.XmlReaderSettings> 执行以下步骤：</span><span class="sxs-lookup"><span data-stu-id="e8683-236">If you have to modify <xref:System.Xml.XmlReaderSettings>, follow these steps:</span></span>  
  
1.  <span data-ttu-id="e8683-237"><xref:System.Xml.XmlReader>通过调用作为参数的重载之一来创建 <xref:System.Xml.XmlReader.Create%2A> <xref:System.Xml.XmlReaderSettings> 。</span><span class="sxs-lookup"><span data-stu-id="e8683-237">Create an <xref:System.Xml.XmlReader> by calling one of the <xref:System.Xml.XmlReader.Create%2A> overloads that takes <xref:System.Xml.XmlReaderSettings> as a parameter.</span></span>  
  
2.  <span data-ttu-id="e8683-238">将传递 <xref:System.Xml.XmlReader> 给 <xref:System.Xml.Linq.XDocument.Load%2A> <xref:System.Xml.Linq.XDocument> 采用作为参数的重载之一 <xref:System.Xml.XmlReader> 。</span><span class="sxs-lookup"><span data-stu-id="e8683-238">Pass the <xref:System.Xml.XmlReader> to one of the <xref:System.Xml.Linq.XDocument.Load%2A> overloads of <xref:System.Xml.Linq.XDocument> that takes <xref:System.Xml.XmlReader> as a parameter.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static System.Xml.Linq.XDocument Load (System.IO.TextReader textReader, System.Xml.Linq.LoadOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.Linq.XDocument Load(class System.IO.TextReader textReader, valuetype System.Xml.Linq.LoadOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XDocument.Load(System.IO.TextReader,System.Xml.Linq.LoadOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Load (textReader As TextReader, options As LoadOptions) As XDocument" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Xml::Linq::XDocument ^ Load(System::IO::TextReader ^ textReader, System::Xml::Linq::LoadOptions options);" />
      <MemberSignature Language="F#" Value="static member Load : System.IO.TextReader * System.Xml.Linq.LoadOptions -&gt; System.Xml.Linq.XDocument" Usage="System.Xml.Linq.XDocument.Load (textReader, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Linq.XDocument</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="textReader" Type="System.IO.TextReader" />
        <Parameter Name="options" Type="System.Xml.Linq.LoadOptions" />
      </Parameters>
      <Docs>
        <param name="textReader"><span data-ttu-id="e8683-239">一个 <see cref="T:System.IO.TextReader" />，其中包含 <see cref="T:System.Xml.Linq.XDocument" /> 的内容。</span><span class="sxs-lookup"><span data-stu-id="e8683-239">A <see cref="T:System.IO.TextReader" /> that contains the content for the <see cref="T:System.Xml.Linq.XDocument" />.</span></span></param>
        <param name="options"><span data-ttu-id="e8683-240">一个 <see cref="T:System.Xml.Linq.LoadOptions" />，指定空白行为以及是否加载基 URI 和行信息。</span><span class="sxs-lookup"><span data-stu-id="e8683-240">A <see cref="T:System.Xml.Linq.LoadOptions" /> that specifies white space behavior, and whether to load base URI and line information.</span></span></param>
        <summary><span data-ttu-id="e8683-241">从 <see cref="T:System.Xml.Linq.XDocument" /> 创建新 <see cref="T:System.IO.TextReader" />，还可以选择保留空白和行信息以及设置基 URI。</span><span class="sxs-lookup"><span data-stu-id="e8683-241">Creates a new <see cref="T:System.Xml.Linq.XDocument" /> from a <see cref="T:System.IO.TextReader" />, optionally preserving white space, setting the base URI, and retaining line information.</span></span></summary>
        <returns><span data-ttu-id="e8683-242">一个 <see cref="T:System.Xml.Linq.XDocument" />，其中包含从指定的 <see cref="T:System.IO.TextReader" /> 读取的 XML。</span><span class="sxs-lookup"><span data-stu-id="e8683-242">An <see cref="T:System.Xml.Linq.XDocument" /> that contains the XML that was read from the specified <see cref="T:System.IO.TextReader" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8683-243">如果源 XML 已缩进，则 <xref:System.Xml.Linq.LoadOptions.PreserveWhitespace> 在中设置标志将 `options` 导致读取器读取源 xml 中的所有空格。</span><span class="sxs-lookup"><span data-stu-id="e8683-243">If the source XML is indented, setting the <xref:System.Xml.Linq.LoadOptions.PreserveWhitespace> flag in `options` causes the reader to read all white space in the source XML.</span></span> <span data-ttu-id="e8683-244"><xref:System.Xml.Linq.XText>为有效空白和无意义空白创建类型的节点。</span><span class="sxs-lookup"><span data-stu-id="e8683-244">Nodes of type <xref:System.Xml.Linq.XText> are created for both significant and insignificant white space.</span></span>  
  
 <span data-ttu-id="e8683-245">如果源 XML 已缩进，则未 <xref:System.Xml.Linq.LoadOptions.PreserveWhitespace> 在中设置标志将 `options` 导致读取器忽略源 xml 中所有无意义的空白。</span><span class="sxs-lookup"><span data-stu-id="e8683-245">If the source XML is indented, not setting the <xref:System.Xml.Linq.LoadOptions.PreserveWhitespace> flag in `options` causes the reader to ignore all of the insignificant white space in the source XML.</span></span> <span data-ttu-id="e8683-246">创建 XML 树时无需任何文本节点，无意义的空白。</span><span class="sxs-lookup"><span data-stu-id="e8683-246">The XML tree is created without any text nodes for insignificant white space.</span></span>  
  
 <span data-ttu-id="e8683-247">如果未缩进源 XML，则 <xref:System.Xml.Linq.LoadOptions.PreserveWhitespace> 在中设置标志 `options` 不起作用。</span><span class="sxs-lookup"><span data-stu-id="e8683-247">If the source XML is not indented, setting the <xref:System.Xml.Linq.LoadOptions.PreserveWhitespace> flag in `options` has no effect.</span></span> <span data-ttu-id="e8683-248">仍保留了有效空白，并且不存在任何可能导致创建更多空白文本节点的无意义空白区域。</span><span class="sxs-lookup"><span data-stu-id="e8683-248">Significant white space is still preserved, and there are no spans of insignificant white space that could cause the creation of more white space text nodes.</span></span>  
  
 <span data-ttu-id="e8683-249">有关详细信息，请参阅 [在加载或分析 XML 时保留空白](/dotnet/standard/linq/preserve-white-space-loading-parsing-xml) ，并 [在序列化时保留空白区域](/dotnet/standard/linq/preserve-white-space-serializing)。</span><span class="sxs-lookup"><span data-stu-id="e8683-249">For more information, see [Preserve white space while loading or parsing XML](/dotnet/standard/linq/preserve-white-space-loading-parsing-xml) and [Preserve white space while serializing](/dotnet/standard/linq/preserve-white-space-serializing).</span></span>  
  
 <span data-ttu-id="e8683-250">使用 <xref:System.Xml.Linq.XDocument.Parse%2A> <xref:System.Xml.Linq.XElement> 从包含 XML 的字符串创建。</span><span class="sxs-lookup"><span data-stu-id="e8683-250">Use <xref:System.Xml.Linq.XDocument.Parse%2A> to create an <xref:System.Xml.Linq.XElement> from a string that contains XML.</span></span>  
  
 <span data-ttu-id="e8683-251"><xref:System.Xml.Linq.LoadOptions.SetBaseUri>从加载时，设置无效 <xref:System.IO.TextReader> 。</span><span class="sxs-lookup"><span data-stu-id="e8683-251">Setting <xref:System.Xml.Linq.LoadOptions.SetBaseUri> is not valid when loading from a <xref:System.IO.TextReader>.</span></span>  
  
 <span data-ttu-id="e8683-252">如果设置了标志，则会对性能产生负面影响 <xref:System.Xml.Linq.LoadOptions.SetLineInfo> 。</span><span class="sxs-lookup"><span data-stu-id="e8683-252">There is a performance penalty if you set the <xref:System.Xml.Linq.LoadOptions.SetLineInfo> flag.</span></span>  
  
 <span data-ttu-id="e8683-253">行信息在加载 XML 文档后立即准确无误。</span><span class="sxs-lookup"><span data-stu-id="e8683-253">The line information is accurate immediately after loading the XML document.</span></span> <span data-ttu-id="e8683-254">如果在加载文档后修改 XML 树，行信息可能会变得毫无意义。</span><span class="sxs-lookup"><span data-stu-id="e8683-254">If you modify the XML tree after loading the document, the line information may become meaningless.</span></span>  
  
 <span data-ttu-id="e8683-255">LINQ to XML 的加载功能是基于生成的 <xref:System.Xml.XmlReader> 。</span><span class="sxs-lookup"><span data-stu-id="e8683-255">LINQ to XML's loading functionality is built upon <xref:System.Xml.XmlReader>.</span></span> <span data-ttu-id="e8683-256">因此，你可能会捕获重载方法所引发的任何异常 <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> 和 <xref:System.Xml.XmlReader> 读取和分析文档的方法。</span><span class="sxs-lookup"><span data-stu-id="e8683-256">Therefore, you might catch any exceptions that are thrown by the <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> overload methods and the <xref:System.Xml.XmlReader> methods that read and parse the document.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="e8683-257">下面的示例从创建一个文档 <xref:System.IO.StringReader> 。</span><span class="sxs-lookup"><span data-stu-id="e8683-257">The following example creates a document from a <xref:System.IO.StringReader>.</span></span>  
  
```csharp  
TextReader sr;  
int whiteSpaceNodes;  
  
sr = new StringReader("<Root> <Child> </Child> </Root>");  
XDocument xmlTree1 = XDocument.Load(sr, LoadOptions.None);  
sr.Close();  
whiteSpaceNodes = xmlTree1  
    .Element("Root")  
    .DescendantNodesAndSelf()  
    .OfType<XText>()  
    .Where(tNode => tNode.ToString().Trim().Length == 0)  
    .Count();  
Console.WriteLine("Count of white space nodes (not preserving whitespace): {0}", whiteSpaceNodes);  
  
sr = new StringReader("<Root> <Child> </Child> </Root>");  
XDocument xmlTree2 = XDocument.Load(sr, LoadOptions.PreserveWhitespace);  
sr.Close();  
whiteSpaceNodes = xmlTree2  
    .Element("Root")  
    .DescendantNodesAndSelf()  
    .OfType<XText>()  
    .Where(tNode => tNode.ToString().Trim().Length == 0)  
    .Count();  
Console.WriteLine("Count of white space nodes (preserving whitespace): {0}", whiteSpaceNodes);  
```  
  
```vb  
Dim sr As TextReader  
Dim whiteSpaceNodes As Integer  
  
sr = New StringReader("<Root> <Child> </Child> </Root>")  
Dim xmlTree1 As XDocument = XDocument.Load(sr, LoadOptions.None)  
sr.Close()  
whiteSpaceNodes = xmlTree1 _  
              .Element("Root") _  
              .DescendantNodesAndSelf() _  
              .OfType(Of XText)() _  
              .Where(Function(ByVal tNode As XNode) tNode. _  
                  ToString().Trim().Length = 0).Count()  
Console.WriteLine("Count of white space nodes (not preserving whitespace): {0}", whiteSpaceNodes)  
  
sr = New StringReader("<Root> <Child> </Child> </Root>")  
Dim xmlTree2 As XDocument = XDocument.Load(sr, LoadOptions.PreserveWhitespace)  
sr.Close()  
whiteSpaceNodes = xmlTree2 _  
              .Element("Root") _  
              .DescendantNodesAndSelf() _  
              .OfType(Of XText)() _  
              .Where(Function(ByVal tNode As XNode) tNode. _  
                  ToString().Trim().Length = 0).Count()  
Console.WriteLine("Count of white space nodes (preserving whitespace): {0}", whiteSpaceNodes)  
```  
  
 <span data-ttu-id="e8683-258">该示例产生下面的输出：</span><span class="sxs-lookup"><span data-stu-id="e8683-258">This example produces the following output:</span></span>  
  
```  
Count of white space nodes (not preserving whitespace): 0  
Count of white space nodes (preserving whitespace): 3  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Xml.Linq.XDocument.Parse" />
        <altmember cref="Overload:System.Xml.Linq.XDocument.Save" />
        <altmember cref="M:System.Xml.Linq.XDocument.WriteTo(System.Xml.XmlWriter)" />
        <related type="Article" href="/dotnet/standard/linq/linq-xml-overview"><span data-ttu-id="e8683-259">LINQ to XML 概述</span><span class="sxs-lookup"><span data-stu-id="e8683-259">LINQ to XML overview</span></span></related>
        <related type="Article" href="/dotnet/standard/linq/query-xdocument-vs-query-xelement"><span data-ttu-id="e8683-260">查询 XDocument 与查询 System.xml.linq.xelement&gt;</span><span class="sxs-lookup"><span data-stu-id="e8683-260">Query an XDocument vs. query an XElement</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static System.Xml.Linq.XDocument Load (string uri, System.Xml.Linq.LoadOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.Linq.XDocument Load(string uri, valuetype System.Xml.Linq.LoadOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XDocument.Load(System.String,System.Xml.Linq.LoadOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Load (uri As String, options As LoadOptions) As XDocument" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Xml::Linq::XDocument ^ Load(System::String ^ uri, System::Xml::Linq::LoadOptions options);" />
      <MemberSignature Language="F#" Value="static member Load : string * System.Xml.Linq.LoadOptions -&gt; System.Xml.Linq.XDocument" Usage="System.Xml.Linq.XDocument.Load (uri, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Linq.XDocument</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uri" Type="System.String" />
        <Parameter Name="options" Type="System.Xml.Linq.LoadOptions" />
      </Parameters>
      <Docs>
        <param name="uri"><span data-ttu-id="e8683-261">一个 URI 字符串，它引用要加载到新 <see cref="T:System.Xml.Linq.XDocument" /> 中的文件。</span><span class="sxs-lookup"><span data-stu-id="e8683-261">A URI string that references the file to load into a new <see cref="T:System.Xml.Linq.XDocument" />.</span></span></param>
        <param name="options"><span data-ttu-id="e8683-262">一个 <see cref="T:System.Xml.Linq.LoadOptions" />，指定空白行为以及是否加载基 URI 和行信息。</span><span class="sxs-lookup"><span data-stu-id="e8683-262">A <see cref="T:System.Xml.Linq.LoadOptions" /> that specifies white space behavior, and whether to load base URI and line information.</span></span></param>
        <summary><span data-ttu-id="e8683-263">从文件创建新 <see cref="T:System.Xml.Linq.XDocument" />，还可以选择保留空白和行信息以及设置基 URI。</span><span class="sxs-lookup"><span data-stu-id="e8683-263">Creates a new <see cref="T:System.Xml.Linq.XDocument" /> from a file, optionally preserving white space, setting the base URI, and retaining line information.</span></span></summary>
        <returns><span data-ttu-id="e8683-264">一个包含指定文件的内容的 <see cref="T:System.Xml.Linq.XDocument" />。</span><span class="sxs-lookup"><span data-stu-id="e8683-264">An <see cref="T:System.Xml.Linq.XDocument" /> that contains the contents of the specified file.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8683-265">如果源 XML 已缩进，则 <xref:System.Xml.Linq.LoadOptions.PreserveWhitespace> 在中设置标志将 `options` 导致读取器读取源 xml 中的所有空格。</span><span class="sxs-lookup"><span data-stu-id="e8683-265">If the source XML is indented, setting the <xref:System.Xml.Linq.LoadOptions.PreserveWhitespace> flag in `options` causes the reader to read all white space in the source XML.</span></span> <span data-ttu-id="e8683-266"><xref:System.Xml.Linq.XText>为有效空白和无意义空白创建类型的节点。</span><span class="sxs-lookup"><span data-stu-id="e8683-266">Nodes of type <xref:System.Xml.Linq.XText> are created for both significant and insignificant white space.</span></span>  
  
 <span data-ttu-id="e8683-267">如果源 XML 已缩进，则未 <xref:System.Xml.Linq.LoadOptions.PreserveWhitespace> 在中设置标志将 `options` 导致读取器忽略源 xml 中所有无意义的空白。</span><span class="sxs-lookup"><span data-stu-id="e8683-267">If the source XML is indented, not setting the <xref:System.Xml.Linq.LoadOptions.PreserveWhitespace> flag in `options` causes the reader to ignore all of the insignificant white space in the source XML.</span></span> <span data-ttu-id="e8683-268">创建 XML 树时无需任何文本节点，无意义的空白。</span><span class="sxs-lookup"><span data-stu-id="e8683-268">The XML tree is created without any text nodes for insignificant white space.</span></span>  
  
 <span data-ttu-id="e8683-269">如果未缩进源 XML，则 <xref:System.Xml.Linq.LoadOptions.PreserveWhitespace> 在中设置标志 `options` 不起作用。</span><span class="sxs-lookup"><span data-stu-id="e8683-269">If the source XML is not indented, setting the <xref:System.Xml.Linq.LoadOptions.PreserveWhitespace> flag in `options` has no effect.</span></span> <span data-ttu-id="e8683-270">仍保留了有效空白，并且不存在任何可能导致创建更多空白文本节点的无意义空白区域。</span><span class="sxs-lookup"><span data-stu-id="e8683-270">Significant white space is still preserved, and there are no spans of insignificant white space that could cause the creation of more white space text nodes.</span></span>  
  
 <span data-ttu-id="e8683-271">有关详细信息，请参阅 [在加载或分析 XML 时保留空白](/dotnet/standard/linq/preserve-white-space-loading-parsing-xml) ，并 [在序列化时保留空白区域](/dotnet/standard/linq/preserve-white-space-serializing)。</span><span class="sxs-lookup"><span data-stu-id="e8683-271">For more information, see [Preserve white space while loading or parsing XML](/dotnet/standard/linq/preserve-white-space-loading-parsing-xml) and [Preserve white space while serializing](/dotnet/standard/linq/preserve-white-space-serializing).</span></span>  
  
 <span data-ttu-id="e8683-272">使用 <xref:System.Xml.Linq.XDocument.Parse%2A> <xref:System.Xml.Linq.XDocument> 从包含 XML 的字符串创建。</span><span class="sxs-lookup"><span data-stu-id="e8683-272">Use <xref:System.Xml.Linq.XDocument.Parse%2A> to create an <xref:System.Xml.Linq.XDocument> from a string that contains XML.</span></span>  
  
 <span data-ttu-id="e8683-273">如果设置了和标志，则会降低性能 <xref:System.Xml.Linq.LoadOptions.SetBaseUri> <xref:System.Xml.Linq.LoadOptions.SetLineInfo> 。</span><span class="sxs-lookup"><span data-stu-id="e8683-273">There is a performance penalty if you set the <xref:System.Xml.Linq.LoadOptions.SetBaseUri> and the <xref:System.Xml.Linq.LoadOptions.SetLineInfo> flags.</span></span>  
  
 <span data-ttu-id="e8683-274">在加载 XML 文档后，基本 URI 和行信息立即准确无误。</span><span class="sxs-lookup"><span data-stu-id="e8683-274">The base URI and the line information are accurate immediately after loading the XML document.</span></span> <span data-ttu-id="e8683-275">如果在加载文档后修改 XML 树，则基本 URI 和行信息可能会变得毫无意义。</span><span class="sxs-lookup"><span data-stu-id="e8683-275">If you modify the XML tree after loading the document, the base URI and line information may become meaningless.</span></span>  
  
 <span data-ttu-id="e8683-276">LINQ to XML 的加载功能是基于生成的 <xref:System.Xml.XmlReader> 。</span><span class="sxs-lookup"><span data-stu-id="e8683-276">LINQ to XML's loading functionality is built upon <xref:System.Xml.XmlReader>.</span></span> <span data-ttu-id="e8683-277">因此，你可能会捕获重载方法所引发的任何异常 <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> 和 <xref:System.Xml.XmlReader> 读取和分析文档的方法。</span><span class="sxs-lookup"><span data-stu-id="e8683-277">Therefore, you might catch any exceptions that are thrown by the <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> overload methods and the <xref:System.Xml.XmlReader> methods that read and parse the document.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="e8683-278">下面的示例演示如何 <xref:System.Xml.Linq.XDocument> 从文件加载。</span><span class="sxs-lookup"><span data-stu-id="e8683-278">The following example shows how to load an <xref:System.Xml.Linq.XDocument> from a file.</span></span>  
  
 <span data-ttu-id="e8683-279">此示例使用下面的 XML 文档：</span><span class="sxs-lookup"><span data-stu-id="e8683-279">This example uses the following XML document:</span></span>  
  
 [<span data-ttu-id="e8683-280">示例 XML 文件：典型采购订单 (LINQ to XML)</span><span class="sxs-lookup"><span data-stu-id="e8683-280">Sample XML File: Typical Purchase Order (LINQ to XML)</span></span>](/dotnet/standard/linq/sample-xml-file-typical-purchase-order)  
  
```csharp  
XDocument doc1 = XDocument.Load("PurchaseOrder.xml", LoadOptions.None);  
Console.WriteLine("nodes if not preserving whitespace: {0}", doc1.DescendantNodes().Count());  
  
XDocument doc2 = XDocument.Load("PurchaseOrder.xml", LoadOptions.PreserveWhitespace);  
Console.WriteLine("nodes if preserving whitespace: {0}", doc2.DescendantNodes().Count());  
```  
  
```vb  
Dim doc1 As XDocument = XDocument.Load("PurchaseOrder.xml", LoadOptions.None)  
Console.WriteLine("nodes if not preserving whitespace: {0}", doc1.DescendantNodes().Count())  
  
Dim doc2 As XDocument = XDocument.Load("PurchaseOrder.xml", LoadOptions.PreserveWhitespace)  
Console.WriteLine("nodes if preserving whitespace: {0}", doc2.DescendantNodes().Count())  
```  
  
 <span data-ttu-id="e8683-281">该示例产生下面的输出：</span><span class="sxs-lookup"><span data-stu-id="e8683-281">This example produces the following output:</span></span>  
  
```  
nodes if not preserving whitespace: 48  
nodes if preserving whitespace: 82  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Xml.Linq.XDocument.Parse" />
        <altmember cref="Overload:System.Xml.Linq.XDocument.Save" />
        <altmember cref="M:System.Xml.Linq.XDocument.WriteTo(System.Xml.XmlWriter)" />
        <related type="Article" href="/dotnet/standard/linq/linq-xml-overview"><span data-ttu-id="e8683-282">LINQ to XML 概述</span><span class="sxs-lookup"><span data-stu-id="e8683-282">LINQ to XML overview</span></span></related>
        <related type="Article" href="/dotnet/standard/linq/query-xdocument-vs-query-xelement"><span data-ttu-id="e8683-283">查询 XDocument 与查询 System.xml.linq.xelement&gt;</span><span class="sxs-lookup"><span data-stu-id="e8683-283">Query an XDocument vs. query an XElement</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static System.Xml.Linq.XDocument Load (System.Xml.XmlReader reader, System.Xml.Linq.LoadOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.Linq.XDocument Load(class System.Xml.XmlReader reader, valuetype System.Xml.Linq.LoadOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XDocument.Load(System.Xml.XmlReader,System.Xml.Linq.LoadOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Load (reader As XmlReader, options As LoadOptions) As XDocument" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Xml::Linq::XDocument ^ Load(System::Xml::XmlReader ^ reader, System::Xml::Linq::LoadOptions options);" />
      <MemberSignature Language="F#" Value="static member Load : System.Xml.XmlReader * System.Xml.Linq.LoadOptions -&gt; System.Xml.Linq.XDocument" Usage="System.Xml.Linq.XDocument.Load (reader, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Linq.XDocument</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
        <Parameter Name="options" Type="System.Xml.Linq.LoadOptions" />
      </Parameters>
      <Docs>
        <param name="reader"><span data-ttu-id="e8683-284">一个从其读取 <see cref="T:System.Xml.XmlReader" /> 内容的 <see cref="T:System.Xml.Linq.XDocument" />。</span><span class="sxs-lookup"><span data-stu-id="e8683-284">A <see cref="T:System.Xml.XmlReader" /> that will be read for the content of the <see cref="T:System.Xml.Linq.XDocument" />.</span></span></param>
        <param name="options"><span data-ttu-id="e8683-285">一个 <see cref="T:System.Xml.Linq.LoadOptions" />，指定是否加载基 URI 和行信息。</span><span class="sxs-lookup"><span data-stu-id="e8683-285">A <see cref="T:System.Xml.Linq.LoadOptions" /> that specifies whether to load base URI and line information.</span></span></param>
        <summary><span data-ttu-id="e8683-286">从 <see cref="T:System.Xml.Linq.XDocument" /> 加载 <see cref="T:System.Xml.XmlReader" />，还可以选择设置基 URI 和保留行信息。</span><span class="sxs-lookup"><span data-stu-id="e8683-286">Loads an <see cref="T:System.Xml.Linq.XDocument" /> from an <see cref="T:System.Xml.XmlReader" />, optionally setting the base URI, and retaining line information.</span></span></summary>
        <returns><span data-ttu-id="e8683-287">一个 <see cref="T:System.Xml.Linq.XDocument" />，其中包含从指定的 <see cref="T:System.Xml.XmlReader" /> 读取的 XML。</span><span class="sxs-lookup"><span data-stu-id="e8683-287">An <see cref="T:System.Xml.Linq.XDocument" /> that contains the XML that was read from the specified <see cref="T:System.Xml.XmlReader" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8683-288">通过 <xref:System.Xml.XmlNodeReader> 从 DOM 文档创建，然后使用 <xref:System.Xml.XmlNodeReader> 创建 <xref:System.Xml.Linq.XElement> ，此方法可用于在 LINQ to XML 树中创建 DOM 文档的副本。</span><span class="sxs-lookup"><span data-stu-id="e8683-288">By creating an <xref:System.Xml.XmlNodeReader> from a DOM document, and then using the <xref:System.Xml.XmlNodeReader> to create an <xref:System.Xml.Linq.XElement>, this method can be used to create a copy of a DOM document in a LINQ to XML tree.</span></span>  
  
 <span data-ttu-id="e8683-289">使用 <xref:System.Xml.Linq.XDocument.Parse%2A> <xref:System.Xml.Linq.XDocument> 从包含 XML 的字符串创建。</span><span class="sxs-lookup"><span data-stu-id="e8683-289">Use <xref:System.Xml.Linq.XDocument.Parse%2A> to create an <xref:System.Xml.Linq.XDocument> from a string that contains XML.</span></span>  
  
 <span data-ttu-id="e8683-290"><xref:System.Xml.Linq.LoadOptions.PreserveWhitespace>从加载时，设置无效 <xref:System.Xml.XmlReader> 。</span><span class="sxs-lookup"><span data-stu-id="e8683-290">Setting <xref:System.Xml.Linq.LoadOptions.PreserveWhitespace> is not valid when loading from a <xref:System.Xml.XmlReader>.</span></span> <span data-ttu-id="e8683-291"><xref:System.Xml.XmlReader>将配置为读取空白。</span><span class="sxs-lookup"><span data-stu-id="e8683-291">The <xref:System.Xml.XmlReader> will be configured to either read whitespace or not.</span></span> <span data-ttu-id="e8683-292">LINQ to XML 树将用读取器所表示的空白节点填充。</span><span class="sxs-lookup"><span data-stu-id="e8683-292">The LINQ to XML tree will be populated with the whitespace nodes that the reader surfaces.</span></span> <span data-ttu-id="e8683-293">不管是否设置了，这将是行为 <xref:System.Xml.Linq.LoadOptions.PreserveWhitespace> 。</span><span class="sxs-lookup"><span data-stu-id="e8683-293">This will be the behavior regardless of whether <xref:System.Xml.Linq.LoadOptions.PreserveWhitespace> is set or not.</span></span>  
  
 <span data-ttu-id="e8683-294"><xref:System.Xml.XmlReader>可能具有有效的基 URI。</span><span class="sxs-lookup"><span data-stu-id="e8683-294">The <xref:System.Xml.XmlReader> may have a valid base URI or not.</span></span> <span data-ttu-id="e8683-295">如果设置 <xref:System.Xml.Linq.LoadOptions.SetBaseUri> 了，则将从报告的基本 uri 的 XML 树中设置基本 uri <xref:System.Xml.XmlReader> 。</span><span class="sxs-lookup"><span data-stu-id="e8683-295">If you set <xref:System.Xml.Linq.LoadOptions.SetBaseUri>, the base URI will be set in the XML tree from the base URI that is reported by the <xref:System.Xml.XmlReader>.</span></span>  
  
 <span data-ttu-id="e8683-296"><xref:System.Xml.XmlReader>可能有有效的行信息。</span><span class="sxs-lookup"><span data-stu-id="e8683-296">The <xref:System.Xml.XmlReader> may have a valid line information or not.</span></span> <span data-ttu-id="e8683-297">如果设置 <xref:System.Xml.Linq.LoadOptions.SetLineInfo> 了，则将从报告的行信息在 XML 树中设置行信息 <xref:System.Xml.XmlReader> 。</span><span class="sxs-lookup"><span data-stu-id="e8683-297">If you set <xref:System.Xml.Linq.LoadOptions.SetLineInfo>, the line information will be set in the XML tree from the line information that is reported by the <xref:System.Xml.XmlReader>.</span></span>  
  
 <span data-ttu-id="e8683-298">如果设置了标志，则会对性能产生负面影响 <xref:System.Xml.Linq.LoadOptions.SetLineInfo> 。</span><span class="sxs-lookup"><span data-stu-id="e8683-298">There is a performance penalty if you set the <xref:System.Xml.Linq.LoadOptions.SetLineInfo> flag.</span></span>  
  
 <span data-ttu-id="e8683-299">行信息在加载 XML 文档后立即准确无误。</span><span class="sxs-lookup"><span data-stu-id="e8683-299">The line information is accurate immediately after loading the XML document.</span></span> <span data-ttu-id="e8683-300">如果在加载文档后修改 XML 树，行信息可能会变得毫无意义。</span><span class="sxs-lookup"><span data-stu-id="e8683-300">If you modify the XML tree after loading the document, the line information may become meaningless.</span></span>  
  
 <span data-ttu-id="e8683-301">LINQ to XML 的加载功能是基于生成的 <xref:System.Xml.XmlReader> 。</span><span class="sxs-lookup"><span data-stu-id="e8683-301">LINQ to XML's loading functionality is built upon <xref:System.Xml.XmlReader>.</span></span> <span data-ttu-id="e8683-302">因此，你可能会捕获重载方法所引发的任何异常 <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> 和 <xref:System.Xml.XmlReader> 读取和分析文档的方法。</span><span class="sxs-lookup"><span data-stu-id="e8683-302">Therefore, you might catch any exceptions that are thrown by the <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> overload methods and the <xref:System.Xml.XmlReader> methods that read and parse the document.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="e8683-303">下面的示例加载从中加载的行信息 <xref:System.Xml.XmlReader> 。</span><span class="sxs-lookup"><span data-stu-id="e8683-303">The following example loads the line information that it loads from the <xref:System.Xml.XmlReader>.</span></span> <span data-ttu-id="e8683-304">然后打印行信息。</span><span class="sxs-lookup"><span data-stu-id="e8683-304">It then prints the line information.</span></span>  
  
```csharp  
string markup =  
@"<Root>  
    <Child>  
        <GrandChild/>  
    </Child>  
</Root>";  
  
// Create a reader and move to the content.  
using (XmlReader nodeReader = XmlReader.Create(new StringReader(markup)))  
{  
    // the reader must be in the Interactive state in order to  
    // Create a LINQ to XML tree from it.  
    nodeReader.MoveToContent();  
  
    XDocument xRoot = XDocument.Load(nodeReader, LoadOptions.SetLineInfo);  
    Console.WriteLine("{0}{1}{2}",  
        "Element Name".PadRight(20),  
        "Line".PadRight(5),  
        "Position");  
    Console.WriteLine("{0}{1}{2}",  
        "------------".PadRight(20),  
        "----".PadRight(5),  
        "--------");  
    foreach (XElement e in xRoot.Elements("Root").DescendantsAndSelf())  
        Console.WriteLine("{0}{1}{2}",  
            ("".PadRight(e.Ancestors().Count() * 2) + e.Name).PadRight(20),  
            ((IXmlLineInfo)e).LineNumber.ToString().PadRight(5),  
            ((IXmlLineInfo)e).LinePosition);  
}  
```  
  
```vb  
Dim markup As String = _  
    "<Root>" & Environment.NewLine & _  
    "    <Child>" & Environment.NewLine & _  
    "        <GrandChild/>" & Environment.NewLine & _  
    "    </Child>" & Environment.NewLine & _  
    "</Root>"  
  
' Create a reader and move to the content.  
Using nodeReader As XmlReader = XmlReader.Create(New StringReader(markup))  
  
    ' The reader must be in the Interactive state in order to  
    ' create a LINQ to XML tree from it.  
    nodeReader.MoveToContent()  
  
    Dim xRoot As XDocument = XDocument.Load(nodeReader, LoadOptions.SetLineInfo)  
    Console.WriteLine("{0}{1}{2}", _  
        "Element Name".PadRight(20), _  
        "Line".PadRight(5), _  
        "Position")  
    Console.WriteLine("{0}{1}{2}", _  
        "------------".PadRight(20), _  
        "----".PadRight(5), _  
        "--------")  
    For Each e As XElement In xRoot.Elements("Root").DescendantsAndSelf()  
        Console.WriteLine("{0}{1}{2}", _  
            ("".PadRight(e.Ancestors().Count() * 2) & e.Name.ToString()).PadRight(20), _  
            (DirectCast(e, IXmlLineInfo)).LineNumber.ToString().PadRight(5), _  
            (DirectCast(e, IXmlLineInfo)).LinePosition)  
    Next  
End Using  
```  
  
 <span data-ttu-id="e8683-305">该示例产生下面的输出：</span><span class="sxs-lookup"><span data-stu-id="e8683-305">This example produces the following output:</span></span>  
  
```  
Element Name        Line Position  
------------        ---- --------  
Root                1    2  
  Child             2    6  
    GrandChild      3    10  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Xml.Linq.XDocument.WriteTo(System.Xml.XmlWriter)" />
        <altmember cref="Overload:System.Xml.Linq.XDocument.Save" />
        <altmember cref="Overload:System.Xml.Linq.XDocument.Parse" />
        <related type="Article" href="/dotnet/standard/linq/linq-xml-overview"><span data-ttu-id="e8683-306">LINQ to XML 概述</span><span class="sxs-lookup"><span data-stu-id="e8683-306">LINQ to XML overview</span></span></related>
        <related type="Article" href="/dotnet/standard/linq/read-write-encoded-document"><span data-ttu-id="e8683-307">如何读取和写入编码文档</span><span class="sxs-lookup"><span data-stu-id="e8683-307">How to read and write an encoded document</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="LoadAsync">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;System.Xml.Linq.XDocument&gt; LoadAsync (System.IO.Stream stream, System.Xml.Linq.LoadOptions options, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;class System.Xml.Linq.XDocument&gt; LoadAsync(class System.IO.Stream stream, valuetype System.Xml.Linq.LoadOptions options, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XDocument.LoadAsync(System.IO.Stream,System.Xml.Linq.LoadOptions,System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LoadAsync (stream As Stream, options As LoadOptions, cancellationToken As CancellationToken) As Task(Of XDocument)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::Task&lt;System::Xml::Linq::XDocument ^&gt; ^ LoadAsync(System::IO::Stream ^ stream, System::Xml::Linq::LoadOptions options, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="static member LoadAsync : System.IO.Stream * System.Xml.Linq.LoadOptions * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;System.Xml.Linq.XDocument&gt;" Usage="System.Xml.Linq.XDocument.LoadAsync (stream, options, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Xml.Linq.XDocument&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="options" Type="System.Xml.Linq.LoadOptions" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="stream"><span data-ttu-id="e8683-308">包含要读入新创建的 <see cref="T:System.Xml.Linq.XDocument" /> 的原始 XML 的流。</span><span class="sxs-lookup"><span data-stu-id="e8683-308">A stream containing the raw XML to read into the newly created <see cref="T:System.Xml.Linq.XDocument" />.</span></span></param>
        <param name="options"><span data-ttu-id="e8683-309">一组加载选项。</span><span class="sxs-lookup"><span data-stu-id="e8683-309">A set of load options.</span></span></param>
        <param name="cancellationToken"><span data-ttu-id="e8683-310">取消标记。</span><span class="sxs-lookup"><span data-stu-id="e8683-310">A cancellation token.</span></span></param>
        <summary><span data-ttu-id="e8683-311">以异步方式创建新的 <see cref="T:System.Xml.Linq.XDocument" /> 并从指定的流初始化其基础 XML 树，可以选择保留空格。</span><span class="sxs-lookup"><span data-stu-id="e8683-311">Asynchronously creates a new <see cref="T:System.Xml.Linq.XDocument" /> and initializes its underlying XML tree from the specified stream, optionally preserving white space.</span></span></summary>
        <returns><span data-ttu-id="e8683-312">包含指定的 <see cref="T:System.IO.Stream" /> 的内容的新 XDocument。</span><span class="sxs-lookup"><span data-stu-id="e8683-312">A new XDocument containing the contents of the specified <see cref="T:System.IO.Stream" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="e8683-313">如果 <xref:System.Xml.Linq.LoadOptions.PreserveWhitespace?displayProperty=nameWithType> 设置了，则将基础 <xref:System.Xml.XmlReaderSettings.IgnoreWhitespace?displayProperty=nameWithType> 属性设置为 `false` 。</span><span class="sxs-lookup"><span data-stu-id="e8683-313">If <xref:System.Xml.Linq.LoadOptions.PreserveWhitespace?displayProperty=nameWithType> is set, the underlying <xref:System.Xml.XmlReaderSettings.IgnoreWhitespace?displayProperty=nameWithType> property is set to `false`.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LoadAsync">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;System.Xml.Linq.XDocument&gt; LoadAsync (System.IO.TextReader textReader, System.Xml.Linq.LoadOptions options, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;class System.Xml.Linq.XDocument&gt; LoadAsync(class System.IO.TextReader textReader, valuetype System.Xml.Linq.LoadOptions options, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XDocument.LoadAsync(System.IO.TextReader,System.Xml.Linq.LoadOptions,System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LoadAsync (textReader As TextReader, options As LoadOptions, cancellationToken As CancellationToken) As Task(Of XDocument)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::Task&lt;System::Xml::Linq::XDocument ^&gt; ^ LoadAsync(System::IO::TextReader ^ textReader, System::Xml::Linq::LoadOptions options, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="static member LoadAsync : System.IO.TextReader * System.Xml.Linq.LoadOptions * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;System.Xml.Linq.XDocument&gt;" Usage="System.Xml.Linq.XDocument.LoadAsync (textReader, options, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Xml.Linq.XDocument&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="textReader" Type="System.IO.TextReader" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="options" Type="System.Xml.Linq.LoadOptions" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="textReader"><span data-ttu-id="e8683-314">包含要读入新创建的 <see cref="T:System.Xml.Linq.XDocument" /> 的原始 XML 的读取器。</span><span class="sxs-lookup"><span data-stu-id="e8683-314">A reader that contains the raw XML to read into the newly created <see cref="T:System.Xml.Linq.XDocument" />.</span></span></param>
        <param name="options"><span data-ttu-id="e8683-315">一组加载选项。</span><span class="sxs-lookup"><span data-stu-id="e8683-315">A set of load options.</span></span></param>
        <param name="cancellationToken"><span data-ttu-id="e8683-316">取消标记。</span><span class="sxs-lookup"><span data-stu-id="e8683-316">A cancellation token.</span></span></param>
        <summary><span data-ttu-id="e8683-317">创建新的 <see cref="T:System.Xml.Linq.XDocument" /> 并使用指定的 <see cref="T:System.IO.TextReader" /> 参数初始化其基础 XML 树，可以选择保留空格。</span><span class="sxs-lookup"><span data-stu-id="e8683-317">Creates a new <see cref="T:System.Xml.Linq.XDocument" /> and initializes its underlying XML tree using the specified <see cref="T:System.IO.TextReader" /> parameter, optionally preserving white space.</span></span></summary>
        <returns><span data-ttu-id="e8683-318">包含指定的 <see cref="T:System.IO.TextReader" /> 的内容的新 XDocument。</span><span class="sxs-lookup"><span data-stu-id="e8683-318">A new XDocument containing the contents of the specified <see cref="T:System.IO.TextReader" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="e8683-319">如果 <xref:System.Xml.Linq.LoadOptions.PreserveWhitespace?displayProperty=nameWithType> 设置了，则将 <xref:System.Xml.XmlReaderSettings.IgnoreWhitespace?displayProperty=nameWithType> 属性设置为 `false` 。</span><span class="sxs-lookup"><span data-stu-id="e8683-319">If <xref:System.Xml.Linq.LoadOptions.PreserveWhitespace?displayProperty=nameWithType> is set, the <xref:System.Xml.XmlReaderSettings.IgnoreWhitespace?displayProperty=nameWithType> property is set to `false`.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LoadAsync">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;System.Xml.Linq.XDocument&gt; LoadAsync (System.Xml.XmlReader reader, System.Xml.Linq.LoadOptions options, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;class System.Xml.Linq.XDocument&gt; LoadAsync(class System.Xml.XmlReader reader, valuetype System.Xml.Linq.LoadOptions options, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XDocument.LoadAsync(System.Xml.XmlReader,System.Xml.Linq.LoadOptions,System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LoadAsync (reader As XmlReader, options As LoadOptions, cancellationToken As CancellationToken) As Task(Of XDocument)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::Task&lt;System::Xml::Linq::XDocument ^&gt; ^ LoadAsync(System::Xml::XmlReader ^ reader, System::Xml::Linq::LoadOptions options, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="static member LoadAsync : System.Xml.XmlReader * System.Xml.Linq.LoadOptions * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;System.Xml.Linq.XDocument&gt;" Usage="System.Xml.Linq.XDocument.LoadAsync (reader, options, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Xml.Linq.XDocument&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="options" Type="System.Xml.Linq.LoadOptions" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="reader"><span data-ttu-id="e8683-320">包含要读入新 <see cref="T:System.Xml.Linq.XDocument" /> 的 XML 的读取器。</span><span class="sxs-lookup"><span data-stu-id="e8683-320">A reader containing the XML to be read into the new <see cref="T:System.Xml.Linq.XDocument" />.</span></span></param>
        <param name="options"><span data-ttu-id="e8683-321">一组加载选项。</span><span class="sxs-lookup"><span data-stu-id="e8683-321">A set of load options.</span></span></param>
        <param name="cancellationToken"><span data-ttu-id="e8683-322">取消标记。</span><span class="sxs-lookup"><span data-stu-id="e8683-322">A cancellation token.</span></span></param>
        <summary><span data-ttu-id="e8683-323">创建包含指定的 <see cref="T:System.Xml.XmlReader" /> 的内容的新 <see cref="T:System.Xml.Linq.XDocument" />。</span><span class="sxs-lookup"><span data-stu-id="e8683-323">Creates a new <see cref="T:System.Xml.Linq.XDocument" /> containing the contents of the specified <see cref="T:System.Xml.XmlReader" />.</span></span></summary>
        <returns><span data-ttu-id="e8683-324">包含指定的 <see cref="T:System.Xml.XmlReader" /> 的内容的新 XDocument。</span><span class="sxs-lookup"><span data-stu-id="e8683-324">A new XDocument containing the contents of the specified <see cref="T:System.Xml.XmlReader" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="NodeType">
      <MemberSignature Language="C#" Value="public override System.Xml.XmlNodeType NodeType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Xml.XmlNodeType NodeType" />
      <MemberSignature Language="DocId" Value="P:System.Xml.Linq.XDocument.NodeType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property NodeType As XmlNodeType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Xml::XmlNodeType NodeType { System::Xml::XmlNodeType get(); };" />
      <MemberSignature Language="F#" Value="member this.NodeType : System.Xml.XmlNodeType" Usage="System.Xml.Linq.XDocument.NodeType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlNodeType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="e8683-325">获取此节点的节点类型。</span><span class="sxs-lookup"><span data-stu-id="e8683-325">Gets the node type for this node.</span></span></summary>
        <value><span data-ttu-id="e8683-326">节点类型。</span><span class="sxs-lookup"><span data-stu-id="e8683-326">The node type.</span></span> <span data-ttu-id="e8683-327">对于 <see cref="T:System.Xml.Linq.XDocument" /> 对象，此值为 <see cref="F:System.Xml.XmlNodeType.Document" />。</span><span class="sxs-lookup"><span data-stu-id="e8683-327">For <see cref="T:System.Xml.Linq.XDocument" /> objects, this value is <see cref="F:System.Xml.XmlNodeType.Document" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8683-328">由于派生自的所有类都 <xref:System.Xml.Linq.XObject> 包含一个 <xref:System.Xml.Linq.XObject.NodeType%2A> 属性，因此你可以编写对对象的集合进行操作的代码，其中每个对象的类型都是的子类 <xref:System.Xml.Linq.XObject> 。</span><span class="sxs-lookup"><span data-stu-id="e8683-328">Because all classes that derive from <xref:System.Xml.Linq.XObject> contain a <xref:System.Xml.Linq.XObject.NodeType%2A> property, you can write code that operates on collections of objects where the type of each is a subclass of <xref:System.Xml.Linq.XObject>.</span></span> <span data-ttu-id="e8683-329">然后，你的代码可以测试集合中每个对象的节点类型。</span><span class="sxs-lookup"><span data-stu-id="e8683-329">Your code can then test for the node type of each object in the collection.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="e8683-330">下面的示例演示如何使用此属性。</span><span class="sxs-lookup"><span data-stu-id="e8683-330">The following example shows the use of this property.</span></span>  
  
```csharp  
// Note that this property uses XmlNodeType, which is in the System.Xml namespace.  
XDocument xmlTree = new XDocument(  
    new XDeclaration("1.0", "utf-8", "yes"),  
    new XElement("Root", "content")  
);  
Console.WriteLine(xmlTree.NodeType);  
```  
  
```vb  
' Note that this property uses XmlNodeType, which is in the System.Xml namespace.  
Dim xmlTree As XDocument = _  
    <?xml version='1.0' encoding='utf-8' standalone='yes'?>  
        <Root>content</Root>  
Console.WriteLine("{0}", xmlTree.NodeType)  
```  
  
 <span data-ttu-id="e8683-331">该示例产生下面的输出：</span><span class="sxs-lookup"><span data-stu-id="e8683-331">This example produces the following output:</span></span>  
  
```  
Document  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlNodeType" />
        <altmember cref="P:System.Xml.Linq.XDocument.DocumentType" />
        <related type="Article" href="/dotnet/standard/linq/linq-xml-overview"><span data-ttu-id="e8683-332">LINQ to XML 概述</span><span class="sxs-lookup"><span data-stu-id="e8683-332">LINQ to XML overview</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Parse">
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="e8683-333">从字符串创建新 <see cref="T:System.Xml.Linq.XDocument" />，还可以选择保留空白和行信息以及设置基 URI。</span><span class="sxs-lookup"><span data-stu-id="e8683-333">Creates a new <see cref="T:System.Xml.Linq.XDocument" /> from a string, optionally preserving white space, setting the base URI, and retaining line information.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8683-334">此方法分析字符串并创建 XML 树。</span><span class="sxs-lookup"><span data-stu-id="e8683-334">This method parses a string and creates an XML tree.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="e8683-335">下面的示例创建一个包含 XML 的字符串。</span><span class="sxs-lookup"><span data-stu-id="e8683-335">The following example creates a string that contains XML.</span></span> <span data-ttu-id="e8683-336">然后，将该字符串分析为 <xref:System.Xml.Linq.XDocument> 。</span><span class="sxs-lookup"><span data-stu-id="e8683-336">It then parses the string into an <xref:System.Xml.Linq.XDocument>.</span></span>  
  
```csharp  
string str =  
@"<?xml version=""1.0""?>  
<!-- comment at the root level -->  
<Root>  
    <Child>Content</Child>  
</Root>";  
XDocument doc = XDocument.Parse(str);  
Console.WriteLine(doc);  
```  
  
```vb  
Dim str As String = _  
    "<?xml version= '1.0'?>" & _  
    "<!-- comment at the root level -->" & _  
    "<Root>" & _  
    "  <Child>Content</Child>" & _  
    "</Root>"  
  
Dim doc As XDocument = XDocument.Parse(str)  
Console.WriteLine(doc)  
```  
  
 <span data-ttu-id="e8683-337">该示例产生下面的输出：</span><span class="sxs-lookup"><span data-stu-id="e8683-337">This example produces the following output:</span></span>  
  
```xml  
<!-- comment at the root level -->  
<Root>  
  <Child>Content</Child>  
</Root>  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Xml.Linq.XDocument.Load" />
        <altmember cref="Overload:System.Xml.Linq.XDocument.Save" />
        <altmember cref="M:System.Xml.Linq.XDocument.WriteTo(System.Xml.XmlWriter)" />
        <related type="Article" href="/dotnet/standard/linq/linq-xml-overview"><span data-ttu-id="e8683-338">LINQ to XML 概述</span><span class="sxs-lookup"><span data-stu-id="e8683-338">LINQ to XML overview</span></span></related>
        <related type="Article" href="/dotnet/standard/linq/parse-string"><span data-ttu-id="e8683-339">如何对字符串进行分析</span><span class="sxs-lookup"><span data-stu-id="e8683-339">How to parse a string</span></span></related>
      </Docs>
    </MemberGroup>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static System.Xml.Linq.XDocument Parse (string text);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.Linq.XDocument Parse(string text) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XDocument.Parse(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (text As String) As XDocument" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Xml::Linq::XDocument ^ Parse(System::String ^ text);" />
      <MemberSignature Language="F#" Value="static member Parse : string -&gt; System.Xml.Linq.XDocument" Usage="System.Xml.Linq.XDocument.Parse text" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Xml.Linq.XDocument</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="text" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="text"><span data-ttu-id="e8683-340">包含 XML 的字符串。</span><span class="sxs-lookup"><span data-stu-id="e8683-340">A string that contains XML.</span></span></param>
        <summary><span data-ttu-id="e8683-341">从字符串创建新 <see cref="T:System.Xml.Linq.XDocument" />。</span><span class="sxs-lookup"><span data-stu-id="e8683-341">Creates a new <see cref="T:System.Xml.Linq.XDocument" /> from a string.</span></span></summary>
        <returns><span data-ttu-id="e8683-342">一个使用包含 XML 的字符串填充的 <see cref="T:System.Xml.Linq.XDocument" />。</span><span class="sxs-lookup"><span data-stu-id="e8683-342">An <see cref="T:System.Xml.Linq.XDocument" /> populated from the string that contains XML.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8683-343">此方法不保留空格。</span><span class="sxs-lookup"><span data-stu-id="e8683-343">This method does not preserve white space.</span></span> <span data-ttu-id="e8683-344">如果要保留 XML 树中的空白，请使用作为参数的的重载 <xref:System.Xml.Linq.XDocument.Parse%2A> <xref:System.Xml.Linq.LoadOptions> 。</span><span class="sxs-lookup"><span data-stu-id="e8683-344">If you want to preserve white space in the XML tree, use the overload of <xref:System.Xml.Linq.XDocument.Parse%2A> that takes <xref:System.Xml.Linq.LoadOptions> as a parameter.</span></span>  
  
 <span data-ttu-id="e8683-345">有关详细信息，请参阅 [在加载或分析 XML 时保留空白](/dotnet/standard/linq/preserve-white-space-loading-parsing-xml) ，并 [在序列化时保留空白区域](/dotnet/standard/linq/preserve-white-space-serializing)。</span><span class="sxs-lookup"><span data-stu-id="e8683-345">For more information, see [Preserve white space while loading or parsing XML](/dotnet/standard/linq/preserve-white-space-loading-parsing-xml) and [Preserve white space while serializing](/dotnet/standard/linq/preserve-white-space-serializing).</span></span>  
  
 <span data-ttu-id="e8683-346">LINQ to XML 的加载功能是基于生成的 <xref:System.Xml.XmlReader> 。</span><span class="sxs-lookup"><span data-stu-id="e8683-346">LINQ to XML's loading functionality is built upon <xref:System.Xml.XmlReader>.</span></span> <span data-ttu-id="e8683-347">因此，你可能会捕获重载方法所引发的任何异常 <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> 和 <xref:System.Xml.XmlReader> 读取和分析文档的方法。</span><span class="sxs-lookup"><span data-stu-id="e8683-347">Therefore, you might catch any exceptions that are thrown by the <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> overload methods and the <xref:System.Xml.XmlReader> methods that read and parse the document.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="e8683-348">下面的示例创建一个包含 XML 的字符串。</span><span class="sxs-lookup"><span data-stu-id="e8683-348">The following example creates a string that contains XML.</span></span> <span data-ttu-id="e8683-349">然后，将该字符串分析为 <xref:System.Xml.Linq.XDocument> 。</span><span class="sxs-lookup"><span data-stu-id="e8683-349">It then parses the string into an <xref:System.Xml.Linq.XDocument>.</span></span>  
  
```csharp  
string str =  
@"<?xml version=""1.0""?>  
<!-- comment at the root level -->  
<Root>  
    <Child>Content</Child>  
</Root>";  
XDocument doc = XDocument.Parse(str);  
Console.WriteLine(doc);  
```  
  
```vb  
Dim str As String = _  
    "<?xml version= '1.0'?>" & _  
    "<!-- comment at the root level -->" & _  
    "<Root>" & _  
    "  <Child>Content</Child>" & _  
    "</Root>"  
  
Dim doc As XDocument = XDocument.Parse(str)  
Console.WriteLine(doc)  
```  
  
 <span data-ttu-id="e8683-350">该示例产生下面的输出：</span><span class="sxs-lookup"><span data-stu-id="e8683-350">This example produces the following output:</span></span>  
  
```xml  
<!-- comment at the root level -->  
<Root>  
  <Child>Content</Child>  
</Root>  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Xml.Linq.XDocument.Load" />
        <altmember cref="Overload:System.Xml.Linq.XDocument.Save" />
        <altmember cref="M:System.Xml.Linq.XDocument.WriteTo(System.Xml.XmlWriter)" />
        <related type="Article" href="/dotnet/standard/linq/linq-xml-overview"><span data-ttu-id="e8683-351">LINQ to XML 概述</span><span class="sxs-lookup"><span data-stu-id="e8683-351">LINQ to XML overview</span></span></related>
        <related type="Article" href="/dotnet/standard/linq/parse-string"><span data-ttu-id="e8683-352">如何对字符串进行分析</span><span class="sxs-lookup"><span data-stu-id="e8683-352">How to parse a string</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static System.Xml.Linq.XDocument Parse (string text, System.Xml.Linq.LoadOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.Linq.XDocument Parse(string text, valuetype System.Xml.Linq.LoadOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XDocument.Parse(System.String,System.Xml.Linq.LoadOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (text As String, options As LoadOptions) As XDocument" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Xml::Linq::XDocument ^ Parse(System::String ^ text, System::Xml::Linq::LoadOptions options);" />
      <MemberSignature Language="F#" Value="static member Parse : string * System.Xml.Linq.LoadOptions -&gt; System.Xml.Linq.XDocument" Usage="System.Xml.Linq.XDocument.Parse (text, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Linq.XDocument</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="text" Type="System.String" />
        <Parameter Name="options" Type="System.Xml.Linq.LoadOptions" />
      </Parameters>
      <Docs>
        <param name="text"><span data-ttu-id="e8683-353">包含 XML 的字符串。</span><span class="sxs-lookup"><span data-stu-id="e8683-353">A string that contains XML.</span></span></param>
        <param name="options"><span data-ttu-id="e8683-354">一个 <see cref="T:System.Xml.Linq.LoadOptions" />，指定空白行为以及是否加载基 URI 和行信息。</span><span class="sxs-lookup"><span data-stu-id="e8683-354">A <see cref="T:System.Xml.Linq.LoadOptions" /> that specifies white space behavior, and whether to load base URI and line information.</span></span></param>
        <summary><span data-ttu-id="e8683-355">从字符串创建新 <see cref="T:System.Xml.Linq.XDocument" />，还可以选择保留空白和行信息以及设置基 URI。</span><span class="sxs-lookup"><span data-stu-id="e8683-355">Creates a new <see cref="T:System.Xml.Linq.XDocument" /> from a string, optionally preserving white space, setting the base URI, and retaining line information.</span></span></summary>
        <returns><span data-ttu-id="e8683-356">一个使用包含 XML 的字符串填充的 <see cref="T:System.Xml.Linq.XDocument" />。</span><span class="sxs-lookup"><span data-stu-id="e8683-356">An <see cref="T:System.Xml.Linq.XDocument" /> populated from the string that contains XML.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8683-357">如果源 XML 已缩进，则 <xref:System.Xml.Linq.LoadOptions.PreserveWhitespace> 在中设置标志将 `options` 导致读取器读取源 xml 中的所有空格。</span><span class="sxs-lookup"><span data-stu-id="e8683-357">If the source XML is indented, setting the <xref:System.Xml.Linq.LoadOptions.PreserveWhitespace> flag in `options` causes the reader to read all white space in the source XML.</span></span> <span data-ttu-id="e8683-358"><xref:System.Xml.Linq.XText>为有效空白和无意义空白创建类型的节点。</span><span class="sxs-lookup"><span data-stu-id="e8683-358">Nodes of type <xref:System.Xml.Linq.XText> are created for both significant and insignificant white space.</span></span>  
  
 <span data-ttu-id="e8683-359">如果源 XML 已缩进，则未 <xref:System.Xml.Linq.LoadOptions.PreserveWhitespace> 在中设置标志将 `options` 导致读取器忽略源 xml 中所有无意义的空白。</span><span class="sxs-lookup"><span data-stu-id="e8683-359">If the source XML is indented, not setting the <xref:System.Xml.Linq.LoadOptions.PreserveWhitespace> flag in `options` causes the reader to ignore all of the insignificant white space in the source XML.</span></span> <span data-ttu-id="e8683-360">创建 XML 树时无需任何文本节点，无意义的空白。</span><span class="sxs-lookup"><span data-stu-id="e8683-360">The XML tree is created without any text nodes for insignificant white space.</span></span>  
  
 <span data-ttu-id="e8683-361">如果未缩进源 XML，则 <xref:System.Xml.Linq.LoadOptions.PreserveWhitespace> 在中设置标志 `options` 不起作用。</span><span class="sxs-lookup"><span data-stu-id="e8683-361">If the source XML is not indented, setting the <xref:System.Xml.Linq.LoadOptions.PreserveWhitespace> flag in `options` has no effect.</span></span> <span data-ttu-id="e8683-362">仍保留了有效空白，并且不存在任何可能导致创建更多空白文本节点的无意义空白区域。</span><span class="sxs-lookup"><span data-stu-id="e8683-362">Significant white space is still preserved, and there are no spans of insignificant white space that could cause the creation of more white space text nodes.</span></span>  
  
 <span data-ttu-id="e8683-363">有关详细信息，请参阅 [在加载或分析 XML 时保留空白](/dotnet/standard/linq/preserve-white-space-loading-parsing-xml) ，并 [在序列化时保留空白区域](/dotnet/standard/linq/preserve-white-space-serializing)。</span><span class="sxs-lookup"><span data-stu-id="e8683-363">For more information, see [Preserve white space while loading or parsing XML](/dotnet/standard/linq/preserve-white-space-loading-parsing-xml) and [Preserve white space while serializing](/dotnet/standard/linq/preserve-white-space-serializing).</span></span>  
  
 <span data-ttu-id="e8683-364"><xref:System.Xml.Linq.LoadOptions.SetBaseUri>从分析时，设置无效 <xref:System.String> 。</span><span class="sxs-lookup"><span data-stu-id="e8683-364">Setting <xref:System.Xml.Linq.LoadOptions.SetBaseUri> is not valid when parsing from a <xref:System.String>.</span></span>  
  
 <span data-ttu-id="e8683-365">如果设置了标志，则会对性能产生负面影响 <xref:System.Xml.Linq.LoadOptions.SetLineInfo> 。</span><span class="sxs-lookup"><span data-stu-id="e8683-365">There is a performance penalty if you set the <xref:System.Xml.Linq.LoadOptions.SetLineInfo> flag.</span></span>  
  
 <span data-ttu-id="e8683-366">行信息在加载 XML 文档后立即准确无误。</span><span class="sxs-lookup"><span data-stu-id="e8683-366">The line information is accurate immediately after loading the XML document.</span></span> <span data-ttu-id="e8683-367">如果在加载文档后修改 XML 树，行信息可能会变得毫无意义。</span><span class="sxs-lookup"><span data-stu-id="e8683-367">If you modify the XML tree after loading the document, the line information may become meaningless.</span></span>  
  
 <span data-ttu-id="e8683-368">LINQ to XML 的加载功能是基于生成的 <xref:System.Xml.XmlReader> 。</span><span class="sxs-lookup"><span data-stu-id="e8683-368">LINQ to XML's loading functionality is built upon <xref:System.Xml.XmlReader>.</span></span> <span data-ttu-id="e8683-369">因此，你可能会捕获重载方法所引发的任何异常 <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> 和 <xref:System.Xml.XmlReader> 读取和分析文档的方法。</span><span class="sxs-lookup"><span data-stu-id="e8683-369">Therefore, you might catch any exceptions that are thrown by the <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> overload methods and the <xref:System.Xml.XmlReader> methods that read and parse the document.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="e8683-370">下面的示例将字符串分析为 <xref:System.Xml.Linq.XDocument> 。</span><span class="sxs-lookup"><span data-stu-id="e8683-370">The following example parses a string into an <xref:System.Xml.Linq.XDocument>.</span></span>  
  
```csharp  
string str =  
@"<?xml version=""1.0""?>  
<!-- comment at the root level -->  
<Root>  
    <Child>Content</Child>  
</Root>";  
XDocument doc1 = XDocument.Parse(str, LoadOptions.PreserveWhitespace);  
Console.WriteLine("nodes when preserving whitespace: {0}", doc1.DescendantNodes().Count());  
XDocument doc2 = XDocument.Parse(str, LoadOptions.None);  
Console.WriteLine("nodes when not preserving whitespace: {0}", doc2.DescendantNodes().Count());  
```  
  
```vb  
Dim str As String = _  
"<?xml version= '1.0'?>" & Environment.NewLine & _  
"<!-- comment at the root level -->" & Environment.NewLine & _  
"<Root>" & Environment.NewLine & _  
"    <Child>Content</Child>"  & Environment.NewLine & _  
"</Root>"  
  
Dim doc1 As XDocument = XDocument.Parse(str, LoadOptions.PreserveWhitespace)  
Console.WriteLine("nodes when preserving whitespace: {0}", doc1.DescendantNodes().Count())  
Dim doc2 As XDocument = XDocument.Parse(str, LoadOptions.None)  
Console.WriteLine("nodes when not preserving whitespace: {0}", doc2.DescendantNodes().Count())  
```  
  
 <span data-ttu-id="e8683-371">该示例产生下面的输出：</span><span class="sxs-lookup"><span data-stu-id="e8683-371">This example produces the following output:</span></span>  
  
```  
nodes when preserving whitespace: 8  
nodes when not preserving whitespace: 4  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Xml.Linq.XDocument.Load" />
        <altmember cref="Overload:System.Xml.Linq.XDocument.Save" />
        <altmember cref="M:System.Xml.Linq.XDocument.WriteTo(System.Xml.XmlWriter)" />
        <related type="Article" href="/dotnet/standard/linq/linq-xml-overview"><span data-ttu-id="e8683-372">LINQ to XML 概述</span><span class="sxs-lookup"><span data-stu-id="e8683-372">LINQ to XML overview</span></span></related>
        <related type="Article" href="/dotnet/standard/linq/parse-string"><span data-ttu-id="e8683-373">如何对字符串进行分析</span><span class="sxs-lookup"><span data-stu-id="e8683-373">How to parse a string</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Root">
      <MemberSignature Language="C#" Value="public System.Xml.Linq.XElement Root { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xml.Linq.XElement Root" />
      <MemberSignature Language="DocId" Value="P:System.Xml.Linq.XDocument.Root" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Root As XElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xml::Linq::XElement ^ Root { System::Xml::Linq::XElement ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Root : System.Xml.Linq.XElement" Usage="System.Xml.Linq.XDocument.Root" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Xml.Linq.XElement</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="e8683-374">获取此文档的 XML 树的根元素。</span><span class="sxs-lookup"><span data-stu-id="e8683-374">Gets the root element of the XML Tree for this document.</span></span></summary>
        <value><span data-ttu-id="e8683-375">XML 树的根 <see cref="T:System.Xml.Linq.XElement" />。</span><span class="sxs-lookup"><span data-stu-id="e8683-375">The root <see cref="T:System.Xml.Linq.XElement" /> of the XML tree.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8683-376">当您想要 [!INCLUDE[sqltecxlinq](~/includes/sqltecxlinq-md.md)] 在将查询编写为根树的同一上下文中编写查询时，此属性很有用 <xref:System.Xml.Linq.XElement> 。</span><span class="sxs-lookup"><span data-stu-id="e8683-376">This property is useful when you want to compose [!INCLUDE[sqltecxlinq](~/includes/sqltecxlinq-md.md)] queries in the same context as when composing them for a tree rooted in <xref:System.Xml.Linq.XElement>.</span></span> <span data-ttu-id="e8683-377">有关更多详细信息，请参阅 [查询 XDocument 与查询 system.xml.linq.xelement>](/dotnet/standard/linq/query-xdocument-vs-query-xelement) 。</span><span class="sxs-lookup"><span data-stu-id="e8683-377">See [Query an XDocument vs. query an XElement](/dotnet/standard/linq/query-xdocument-vs-query-xelement) for more details.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="e8683-378">下面的示例使用此属性获取文档的根元素。</span><span class="sxs-lookup"><span data-stu-id="e8683-378">The following example uses this property to get the root element of a document.</span></span>  
  
```csharp  
XDocument doc = new XDocument(  
    new XComment("This is a comment."),  
    new XElement("Pubs",   
        new XElement("Book",  
            new XElement("Title", "Artifacts of Roman Civilization"),  
            new XElement("Author", "Moreno, Jordao")  
        ),  
        new XElement("Book",  
            new XElement("Title", "Midieval Tools and Implements"),  
            new XElement("Author", "Gazit, Inbar")  
        )  
    ),  
    new XComment("This is another comment.")  
);  
Console.WriteLine(doc.Root.Name.ToString());  
```  
  
```vb  
Dim doc As XDocument = _  
    <?xml version="1.0" encoding="utf-8" standalone="yes"?>  
    <!--This is a comment.-->  
    <Pubs>  
        <Book>  
            <Title>Artifacts of Roman Civilization</Title>  
            <Author>Moreno, Jordao</Author>  
        </Book>  
        <Book>  
            <Title>Midieval Tools and Implements</Title>  
            <Author>Gazit, Inbar</Author>  
        </Book>  
        <!--This is another comment.-->  
    </Pubs>  
  
Console.WriteLine(doc.Root.Name.ToString())  
```  
  
 <span data-ttu-id="e8683-379">该示例产生下面的输出：</span><span class="sxs-lookup"><span data-stu-id="e8683-379">This example produces the following output:</span></span>  
  
```  
Pubs  
```  
  
 ]]></format>
        </remarks>
        <related type="Article" href="/dotnet/standard/linq/linq-xml-overview"><span data-ttu-id="e8683-380">LINQ to XML 概述</span><span class="sxs-lookup"><span data-stu-id="e8683-380">LINQ to XML overview</span></span></related>
        <related type="Article" href="/dotnet/standard/linq/find-all-nodes-namespace"><span data-ttu-id="e8683-381">如何查找命名空间中的所有节点</span><span class="sxs-lookup"><span data-stu-id="e8683-381">How to find all nodes in a namespace</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Save">
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="e8683-382">将此 <see cref="T:System.Xml.Linq.XDocument" /> 序列化为文件、<see cref="T:System.IO.TextWriter" /> 或 <see cref="T:System.Xml.XmlWriter" />。</span><span class="sxs-lookup"><span data-stu-id="e8683-382">Serializes this <see cref="T:System.Xml.Linq.XDocument" /> to a file, a <see cref="T:System.IO.TextWriter" />, or an <see cref="T:System.Xml.XmlWriter" />.</span></span></summary>
        <altmember cref="M:System.Xml.Linq.XDocument.WriteTo(System.Xml.XmlWriter)" />
        <altmember cref="Overload:System.Xml.Linq.XDocument.Load" />
        <altmember cref="Overload:System.Xml.Linq.XDocument.Parse" />
        <related type="Article" href="/dotnet/standard/linq/linq-xml-overview"><span data-ttu-id="e8683-383">LINQ to XML 概述</span><span class="sxs-lookup"><span data-stu-id="e8683-383">LINQ to XML overview</span></span></related>
        <related type="Article" href="/dotnet/standard/linq/read-write-encoded-document"><span data-ttu-id="e8683-384">如何读取和写入编码文档</span><span class="sxs-lookup"><span data-stu-id="e8683-384">How to read and write an encoded document</span></span></related>
      </Docs>
    </MemberGroup>
    <Member MemberName="Save">
      <MemberSignature Language="C#" Value="public void Save (System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Save(class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XDocument.Save(System.IO.Stream)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Save (stream As Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Save(System::IO::Stream ^ stream);" />
      <MemberSignature Language="F#" Value="member this.Save : System.IO.Stream -&gt; unit" Usage="xDocument.Save stream" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="stream"><span data-ttu-id="e8683-385">将此 <see cref="T:System.Xml.Linq.XDocument" /> 输出到的流。</span><span class="sxs-lookup"><span data-stu-id="e8683-385">The stream to output this <see cref="T:System.Xml.Linq.XDocument" /> to.</span></span></param>
        <summary><span data-ttu-id="e8683-386">将此 <see cref="T:System.Xml.Linq.XDocument" /> 输出到指定的 <see cref="T:System.IO.Stream" />。</span><span class="sxs-lookup"><span data-stu-id="e8683-386">Outputs this <see cref="T:System.Xml.Linq.XDocument" /> to the specified <see cref="T:System.IO.Stream" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8683-387">将缩进序列化的 XML。</span><span class="sxs-lookup"><span data-stu-id="e8683-387">The serialized XML will be indented.</span></span> <span data-ttu-id="e8683-388">将删除所有无意义的空白，并会添加额外的空白，以便正确缩进 XML。</span><span class="sxs-lookup"><span data-stu-id="e8683-388">All insignificant white space will be removed, and additional white space will be added so that the XML will be properly indented.</span></span> <span data-ttu-id="e8683-389">此方法的行为是不会保留无意义的空白。</span><span class="sxs-lookup"><span data-stu-id="e8683-389">The behavior of this method is that insignificant white space will not be preserved.</span></span>  
  
 <span data-ttu-id="e8683-390">如果要控制空白，请使用作为参数的的重载 <xref:System.Xml.Linq.XDocument.Save%2A> <xref:System.Xml.Linq.SaveOptions> 。</span><span class="sxs-lookup"><span data-stu-id="e8683-390">If you want to control white space, use the overload of <xref:System.Xml.Linq.XDocument.Save%2A> that takes <xref:System.Xml.Linq.SaveOptions> as a parameter.</span></span> <span data-ttu-id="e8683-391">使用 <xref:System.Xml.Linq.SaveOptions.DisableFormatting> 选项保存未缩进的 XML。</span><span class="sxs-lookup"><span data-stu-id="e8683-391">Use the <xref:System.Xml.Linq.SaveOptions.DisableFormatting> option to save unindented XML.</span></span> <span data-ttu-id="e8683-392">这将导致编写器完全按 XML 树中的表示形式写入所有空格。</span><span class="sxs-lookup"><span data-stu-id="e8683-392">This will cause the writer to write all white spaces exactly as represented in the XML tree.</span></span>  
  
 <span data-ttu-id="e8683-393"><xref:System.Xml.Linq.SaveOptions.OmitDuplicateNamespaces>如果要删除重复的命名空间声明，请使用选项。</span><span class="sxs-lookup"><span data-stu-id="e8683-393">Use <xref:System.Xml.Linq.SaveOptions.OmitDuplicateNamespaces> option if you want to remove duplicate namespace declarations.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Save">
      <MemberSignature Language="C#" Value="public void Save (System.IO.TextWriter textWriter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Save(class System.IO.TextWriter textWriter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XDocument.Save(System.IO.TextWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Save (textWriter As TextWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Save(System::IO::TextWriter ^ textWriter);" />
      <MemberSignature Language="F#" Value="member this.Save : System.IO.TextWriter -&gt; unit" Usage="xDocument.Save textWriter" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="textWriter" Type="System.IO.TextWriter" />
      </Parameters>
      <Docs>
        <param name="textWriter"><span data-ttu-id="e8683-394">将向其中写入 <see cref="T:System.IO.TextWriter" /> 的 <see cref="T:System.Xml.Linq.XDocument" />。</span><span class="sxs-lookup"><span data-stu-id="e8683-394">A <see cref="T:System.IO.TextWriter" /> that the <see cref="T:System.Xml.Linq.XDocument" /> will be written to.</span></span></param>
        <summary><span data-ttu-id="e8683-395">将此 <see cref="T:System.Xml.Linq.XDocument" /> 序列化为 <see cref="T:System.IO.TextWriter" />。</span><span class="sxs-lookup"><span data-stu-id="e8683-395">Serialize this <see cref="T:System.Xml.Linq.XDocument" /> to a <see cref="T:System.IO.TextWriter" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8683-396">将缩进序列化的 XML。</span><span class="sxs-lookup"><span data-stu-id="e8683-396">The serialized XML will be indented.</span></span> <span data-ttu-id="e8683-397">将删除所有无意义的空白，并会添加额外的空白，以便正确缩进 XML。</span><span class="sxs-lookup"><span data-stu-id="e8683-397">All insignificant white space will be removed, and additional white space will be added so that the XML will be properly indented.</span></span> <span data-ttu-id="e8683-398">此方法的行为是不会保留无意义的空白。</span><span class="sxs-lookup"><span data-stu-id="e8683-398">The behavior of this method is that insignificant white space will not be preserved.</span></span>  
  
 <span data-ttu-id="e8683-399">如果要控制空白，请使用作为参数的的重载 <xref:System.Xml.Linq.XDocument.Save%2A> <xref:System.Xml.Linq.SaveOptions> 。</span><span class="sxs-lookup"><span data-stu-id="e8683-399">If you want to control white space, use the overload of <xref:System.Xml.Linq.XDocument.Save%2A> that takes <xref:System.Xml.Linq.SaveOptions> as a parameter.</span></span> <span data-ttu-id="e8683-400">有关详细信息，请参阅 [在加载或分析 XML 时保留空白](/dotnet/standard/linq/preserve-white-space-loading-parsing-xml) ，并 [在序列化时保留空白区域](/dotnet/standard/linq/preserve-white-space-serializing)。</span><span class="sxs-lookup"><span data-stu-id="e8683-400">For more information, see [Preserve white space while loading or parsing XML](/dotnet/standard/linq/preserve-white-space-loading-parsing-xml) and [Preserve white space while serializing](/dotnet/standard/linq/preserve-white-space-serializing).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="e8683-401">下面的示例创建一个 <xref:System.Xml.Linq.XDocument> ，将文档保存到 <xref:System.IO.StringWriter> ，然后将该字符串打印到控制台。</span><span class="sxs-lookup"><span data-stu-id="e8683-401">The following example creates an <xref:System.Xml.Linq.XDocument>, saves the document to a <xref:System.IO.StringWriter>, and then prints the string to the console.</span></span>  
  
```csharp  
StringBuilder sb = new StringBuilder();  
  
XDocument doc = new XDocument(  
    new XElement("Root",  
        new XElement("Child", "content")  
    )  
);  
TextWriter tr = new StringWriter(sb);  
doc.Save(tr);  
Console.WriteLine(sb.ToString());  
```  
  
```vb  
Dim sb As StringBuilder = New StringBuilder()  
  
Dim doc As XDocument = _   
    <?xml version="1.0" encoding="utf-8"?>  
        <Root><Child>content</Child></Root>  
  
Dim tr As TextWriter = New StringWriter(sb)  
doc.Save(tr)  
Console.WriteLine(sb.ToString())  
```  
  
 <span data-ttu-id="e8683-402">该示例产生下面的输出：</span><span class="sxs-lookup"><span data-stu-id="e8683-402">This example produces the following output:</span></span>  
  
```xml  
<?xml version="1.0" encoding="utf-16"?>  
<Root>  
  <Child>content</Child>  
</Root>  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Xml.Linq.XDocument.WriteTo(System.Xml.XmlWriter)" />
        <altmember cref="Overload:System.Xml.Linq.XDocument.Load" />
        <altmember cref="Overload:System.Xml.Linq.XDocument.Parse" />
        <related type="Article" href="/dotnet/standard/linq/linq-xml-overview"><span data-ttu-id="e8683-403">LINQ to XML 概述</span><span class="sxs-lookup"><span data-stu-id="e8683-403">LINQ to XML overview</span></span></related>
        <related type="Article" href="/dotnet/standard/linq/read-write-encoded-document"><span data-ttu-id="e8683-404">如何读取和写入编码文档</span><span class="sxs-lookup"><span data-stu-id="e8683-404">How to read and write an encoded document</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Save">
      <MemberSignature Language="C#" Value="public void Save (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Save(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XDocument.Save(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Save (fileName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Save(System::String ^ fileName);" />
      <MemberSignature Language="F#" Value="member this.Save : string -&gt; unit" Usage="xDocument.Save fileName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="fileName"><span data-ttu-id="e8683-405">一个包含文件名称的字符串。</span><span class="sxs-lookup"><span data-stu-id="e8683-405">A string that contains the name of the file.</span></span></param>
        <summary><span data-ttu-id="e8683-406">序列化此 <see cref="T:System.Xml.Linq.XDocument" /> 到文件，如果该文件存在，则覆盖现有的文件。</span><span class="sxs-lookup"><span data-stu-id="e8683-406">Serialize this <see cref="T:System.Xml.Linq.XDocument" /> to a file, overwriting an existing file, if it exists.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8683-407">将缩进序列化的 XML。</span><span class="sxs-lookup"><span data-stu-id="e8683-407">The serialized XML will be indented.</span></span> <span data-ttu-id="e8683-408">将删除所有无意义的空白，并会添加额外的空白，以便正确缩进 XML。</span><span class="sxs-lookup"><span data-stu-id="e8683-408">All insignificant white space will be removed, and additional white space will be added so that the XML will be properly indented.</span></span> <span data-ttu-id="e8683-409">此方法的行为是不会保留无意义的空白。</span><span class="sxs-lookup"><span data-stu-id="e8683-409">The behavior of this method is that insignificant white space will not be preserved.</span></span>  
  
 <span data-ttu-id="e8683-410">如果要控制空白，请使用作为参数的的重载 <xref:System.Xml.Linq.XDocument.Save%2A> <xref:System.Xml.Linq.SaveOptions> 。</span><span class="sxs-lookup"><span data-stu-id="e8683-410">If you want to control white space, use the overload of <xref:System.Xml.Linq.XDocument.Save%2A> that takes <xref:System.Xml.Linq.SaveOptions> as a parameter.</span></span> <span data-ttu-id="e8683-411">有关详细信息，请参阅 [在加载或分析 XML 时保留空白](/dotnet/standard/linq/preserve-white-space-loading-parsing-xml) ，并 [在序列化时保留空白区域](/dotnet/standard/linq/preserve-white-space-serializing)。</span><span class="sxs-lookup"><span data-stu-id="e8683-411">For more information, see [Preserve white space while loading or parsing XML](/dotnet/standard/linq/preserve-white-space-loading-parsing-xml) and [Preserve white space while serializing](/dotnet/standard/linq/preserve-white-space-serializing).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="e8683-412">下面的示例创建一个 <xref:System.Xml.Linq.XDocument> ，将文档保存到文件，然后将文件打印到控制台。</span><span class="sxs-lookup"><span data-stu-id="e8683-412">The following example creates an <xref:System.Xml.Linq.XDocument>, saves the document to a file, and then prints the file to the console.</span></span>  
  
```csharp  
XDocument doc = new XDocument(  
    new XElement("Root",  
        new XElement("Child", "content")  
    )  
);  
doc.Save("Root.xml");  
Console.WriteLine(File.ReadAllText("Root.xml"));  
```  
  
```vb  
Dim doc As XDocument = _   
    <?xml version="1.0" encoding="utf-8"?>  
        <Root><Child>content</Child></Root>  
  
doc.Save("Root.xml")  
Console.WriteLine(File.ReadAllText("Root.xml"))  
```  
  
 <span data-ttu-id="e8683-413">该示例产生下面的输出：</span><span class="sxs-lookup"><span data-stu-id="e8683-413">This example produces the following output:</span></span>  
  
```xml  
<?xml version="1.0" encoding="utf-8"?>  
<Root>  
  <Child>content</Child>  
</Root>  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Xml.Linq.XDocument.WriteTo(System.Xml.XmlWriter)" />
        <altmember cref="Overload:System.Xml.Linq.XDocument.Load" />
        <altmember cref="Overload:System.Xml.Linq.XDocument.Parse" />
        <related type="Article" href="/dotnet/standard/linq/linq-xml-overview"><span data-ttu-id="e8683-414">LINQ to XML 概述</span><span class="sxs-lookup"><span data-stu-id="e8683-414">LINQ to XML overview</span></span></related>
        <related type="Article" href="/dotnet/standard/linq/read-write-encoded-document"><span data-ttu-id="e8683-415">如何读取和写入编码文档</span><span class="sxs-lookup"><span data-stu-id="e8683-415">How to read and write an encoded document</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Save">
      <MemberSignature Language="C#" Value="public void Save (System.Xml.XmlWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Save(class System.Xml.XmlWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XDocument.Save(System.Xml.XmlWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Save (writer As XmlWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Save(System::Xml::XmlWriter ^ writer);" />
      <MemberSignature Language="F#" Value="member this.Save : System.Xml.XmlWriter -&gt; unit" Usage="xDocument.Save writer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
      </Parameters>
      <Docs>
        <param name="writer"><span data-ttu-id="e8683-416">将向其中写入 <see cref="T:System.Xml.XmlWriter" /> 的 <see cref="T:System.Xml.Linq.XDocument" />。</span><span class="sxs-lookup"><span data-stu-id="e8683-416">A <see cref="T:System.Xml.XmlWriter" /> that the <see cref="T:System.Xml.Linq.XDocument" /> will be written to.</span></span></param>
        <summary><span data-ttu-id="e8683-417">将此 <see cref="T:System.Xml.Linq.XDocument" /> 序列化为 <see cref="T:System.Xml.XmlWriter" />。</span><span class="sxs-lookup"><span data-stu-id="e8683-417">Serialize this <see cref="T:System.Xml.Linq.XDocument" /> to an <see cref="T:System.Xml.XmlWriter" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="e8683-418">下面的示例演示如何将一个 <xref:System.Xml.Linq.XDocument> 保存到一个 <xref:System.Xml.XmlWriter>。</span><span class="sxs-lookup"><span data-stu-id="e8683-418">The following example shows how to save an <xref:System.Xml.Linq.XDocument> to an <xref:System.Xml.XmlWriter>.</span></span>  
  
```csharp  
StringBuilder sb = new StringBuilder();  
XmlWriterSettings xws = new XmlWriterSettings();  
xws.OmitXmlDeclaration = true;  
xws.Indent = true;  
  
using (XmlWriter xw = XmlWriter.Create(sb, xws)) {  
    XDocument doc = new XDocument(  
        new XElement("Child",  
            new XElement("GrandChild", "some content")  
        )  
    );  
    doc.Save(xw);  
}  
  
Console.WriteLine(sb.ToString());  
```  
  
```vb  
Dim sb As StringBuilder = New StringBuilder()  
Dim xws As XmlWriterSettings = New XmlWriterSettings()  
xws.OmitXmlDeclaration = True  
xws.Indent = True  
  
Using xw = XmlWriter.Create(sb, xws)  
    Dim doc As XDocument = New XDocument(<Child><GrandChild>some content</GrandChild></Child>)  
    doc.Save(xw)  
  
End Using  
  
Console.WriteLine(sb.ToString())  
```  
  
 <span data-ttu-id="e8683-419">该示例产生下面的输出：</span><span class="sxs-lookup"><span data-stu-id="e8683-419">This example produces the following output:</span></span>  
  
```xml  
<Child>  
  <GrandChild>some content</GrandChild>  
</Child>  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Xml.Linq.XDocument.WriteTo(System.Xml.XmlWriter)" />
        <altmember cref="Overload:System.Xml.Linq.XDocument.Load" />
        <altmember cref="Overload:System.Xml.Linq.XDocument.Parse" />
        <related type="Article" href="/dotnet/standard/linq/linq-xml-overview"><span data-ttu-id="e8683-420">LINQ to XML 概述</span><span class="sxs-lookup"><span data-stu-id="e8683-420">LINQ to XML overview</span></span></related>
        <related type="Article" href="/dotnet/standard/linq/read-write-encoded-document"><span data-ttu-id="e8683-421">如何读取和写入编码文档</span><span class="sxs-lookup"><span data-stu-id="e8683-421">How to read and write an encoded document</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Save">
      <MemberSignature Language="C#" Value="public void Save (System.IO.Stream stream, System.Xml.Linq.SaveOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Save(class System.IO.Stream stream, valuetype System.Xml.Linq.SaveOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XDocument.Save(System.IO.Stream,System.Xml.Linq.SaveOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Save (stream As Stream, options As SaveOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Save(System::IO::Stream ^ stream, System::Xml::Linq::SaveOptions options);" />
      <MemberSignature Language="F#" Value="member this.Save : System.IO.Stream * System.Xml.Linq.SaveOptions -&gt; unit" Usage="xDocument.Save (stream, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="options" Type="System.Xml.Linq.SaveOptions" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="stream"><span data-ttu-id="e8683-422">将此 <see cref="T:System.Xml.Linq.XDocument" /> 输出到的流。</span><span class="sxs-lookup"><span data-stu-id="e8683-422">The stream to output this <see cref="T:System.Xml.Linq.XDocument" /> to.</span></span></param>
        <param name="options"><span data-ttu-id="e8683-423">指定格式设置行为的 <see cref="T:System.Xml.Linq.SaveOptions" />。</span><span class="sxs-lookup"><span data-stu-id="e8683-423">A <see cref="T:System.Xml.Linq.SaveOptions" /> that specifies formatting behavior.</span></span></param>
        <summary><span data-ttu-id="e8683-424">将此 <see cref="T:System.Xml.Linq.XDocument" /> 输出到指定的 <see cref="T:System.IO.Stream" />，（可选）并指定格式设置行为。</span><span class="sxs-lookup"><span data-stu-id="e8683-424">Outputs this <see cref="T:System.Xml.Linq.XDocument" /> to the specified <see cref="T:System.IO.Stream" />, optionally specifying formatting behavior.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8683-425">默认情况下， `options` 设置为 <xref:System.Xml.Linq.SaveOptions.None> 。</span><span class="sxs-lookup"><span data-stu-id="e8683-425">By default the `options` are set to <xref:System.Xml.Linq.SaveOptions.None>.</span></span> <span data-ttu-id="e8683-426">此选项将删除所有无关的无意义空格，并添加适当的无意义空白，以便正确缩进 XML。</span><span class="sxs-lookup"><span data-stu-id="e8683-426">This option will remove all extraneous insignificant white space, and add appropriate insignificant white space so that the XML is properly indented.</span></span>  
  
 <span data-ttu-id="e8683-427">如果要保存未缩进的 XML，请指定的 <xref:System.Xml.Linq.SaveOptions.DisableFormatting> 标志 `options` 。</span><span class="sxs-lookup"><span data-stu-id="e8683-427">If you want to save unindented XML, specify the <xref:System.Xml.Linq.SaveOptions.DisableFormatting> flag for `options`.</span></span> <span data-ttu-id="e8683-428">这将导致编写器完全按 XML 树中的表示形式写入所有空格。</span><span class="sxs-lookup"><span data-stu-id="e8683-428">This will cause the writer to write all white spaces exactly as represented in the XML tree.</span></span>  
  
 <span data-ttu-id="e8683-429"><xref:System.Xml.Linq.SaveOptions.OmitDuplicateNamespaces>如果要删除重复的命名空间声明，请使用选项。</span><span class="sxs-lookup"><span data-stu-id="e8683-429">Use <xref:System.Xml.Linq.SaveOptions.OmitDuplicateNamespaces> option if you want to remove duplicate namespace declarations.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Save">
      <MemberSignature Language="C#" Value="public void Save (System.IO.TextWriter textWriter, System.Xml.Linq.SaveOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Save(class System.IO.TextWriter textWriter, valuetype System.Xml.Linq.SaveOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XDocument.Save(System.IO.TextWriter,System.Xml.Linq.SaveOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Save (textWriter As TextWriter, options As SaveOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Save(System::IO::TextWriter ^ textWriter, System::Xml::Linq::SaveOptions options);" />
      <MemberSignature Language="F#" Value="member this.Save : System.IO.TextWriter * System.Xml.Linq.SaveOptions -&gt; unit" Usage="xDocument.Save (textWriter, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="textWriter" Type="System.IO.TextWriter" />
        <Parameter Name="options" Type="System.Xml.Linq.SaveOptions" />
      </Parameters>
      <Docs>
        <param name="textWriter"><span data-ttu-id="e8683-430">要将 XML 输出到的 <see cref="T:System.IO.TextWriter" />。</span><span class="sxs-lookup"><span data-stu-id="e8683-430">The <see cref="T:System.IO.TextWriter" /> to output the XML to.</span></span></param>
        <param name="options"><span data-ttu-id="e8683-431">指定格式设置行为的 <see cref="T:System.Xml.Linq.SaveOptions" />。</span><span class="sxs-lookup"><span data-stu-id="e8683-431">A <see cref="T:System.Xml.Linq.SaveOptions" /> that specifies formatting behavior.</span></span></param>
        <summary><span data-ttu-id="e8683-432">将此 <see cref="T:System.Xml.Linq.XDocument" /> 序列化为 <see cref="T:System.IO.TextWriter" />，还可以选择禁用格式设置。</span><span class="sxs-lookup"><span data-stu-id="e8683-432">Serialize this <see cref="T:System.Xml.Linq.XDocument" /> to a <see cref="T:System.IO.TextWriter" />, optionally disabling formatting.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8683-433">如果要保存未缩进的 XML，请指定的 <xref:System.Xml.Linq.SaveOptions.DisableFormatting> 标志 `options` 。</span><span class="sxs-lookup"><span data-stu-id="e8683-433">If you want to save unindented XML, specify the <xref:System.Xml.Linq.SaveOptions.DisableFormatting> flag for `options`.</span></span> <span data-ttu-id="e8683-434">这将导致编写器完全按 XML 树中的表示方式写入所有空格。</span><span class="sxs-lookup"><span data-stu-id="e8683-434">This will cause the writer to write all white space exactly as represented in the XML tree.</span></span>  
  
 <span data-ttu-id="e8683-435">如果要保存缩进的 XML，请勿 <xref:System.Xml.Linq.SaveOptions.DisableFormatting> 为指定标志 `options` 。</span><span class="sxs-lookup"><span data-stu-id="e8683-435">If you want to save indented XML, do not specify the <xref:System.Xml.Linq.SaveOptions.DisableFormatting> flag for `options`.</span></span> <span data-ttu-id="e8683-436">这将删除所有无关的无意义空格，并添加适当的无意义空白，以便正确缩进 XML。</span><span class="sxs-lookup"><span data-stu-id="e8683-436">This will remove all extraneous insignificant white space, and add appropriate insignificant white space so that the XML is properly indented.</span></span> <span data-ttu-id="e8683-437">这是默认行为，以及 <xref:System.Xml.Linq.XDocument.Save%2A> 不作为参数的方法的重载行为 `options` 。</span><span class="sxs-lookup"><span data-stu-id="e8683-437">This is the default behavior, and the behavior of the overloads of the <xref:System.Xml.Linq.XDocument.Save%2A> methods that do not take `options` as a parameter.</span></span>  
  
 <span data-ttu-id="e8683-438">有关详细信息，请参阅 [在加载或分析 XML 时保留空白](/dotnet/standard/linq/preserve-white-space-loading-parsing-xml) ，并 [在序列化时保留空白区域](/dotnet/standard/linq/preserve-white-space-serializing)。</span><span class="sxs-lookup"><span data-stu-id="e8683-438">For more information, see [Preserve white space while loading or parsing XML](/dotnet/standard/linq/preserve-white-space-loading-parsing-xml) and [Preserve white space while serializing](/dotnet/standard/linq/preserve-white-space-serializing).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="e8683-439">下面的示例演示了此方法的两种用法。</span><span class="sxs-lookup"><span data-stu-id="e8683-439">The following example shows two uses of this method.</span></span> <span data-ttu-id="e8683-440">第一次使用将 <xref:System.Xml.Linq.XDocument> 和格式序列化。</span><span class="sxs-lookup"><span data-stu-id="e8683-440">The first use serializes the <xref:System.Xml.Linq.XDocument> with formatting.</span></span> <span data-ttu-id="e8683-441">第二个保留空白。</span><span class="sxs-lookup"><span data-stu-id="e8683-441">The second preserves white space.</span></span> <span data-ttu-id="e8683-442">由于文档在构造中没有空白，因此保留空白将输出 XML 而不进行任何缩进。</span><span class="sxs-lookup"><span data-stu-id="e8683-442">Because the document has no white space in it as constructed, preserving white space outputs the XML without any indenting.</span></span>  
  
```csharp  
XDocument doc = new XDocument(  
    new XElement("Root",  
        new XElement("Child", "content")  
    )  
);  
StringBuilder sb1 = new StringBuilder();  
using (StringWriter sr1 = new StringWriter(sb1)) {  
    doc.Save(sr1, SaveOptions.None);  
    Console.WriteLine(sb1.ToString());  
}  
  
StringBuilder sb2 = new StringBuilder();  
using (StringWriter sr2 = new StringWriter(sb2)) {  
    doc.Save(sr2, SaveOptions.DisableFormatting);  
    Console.WriteLine(sb2.ToString());  
}  
```  
  
```vb  
Dim doc As XDocument = _   
    <?xml version="1.0" encoding="utf-8"?>  
        <Root><Child>content</Child></Root>  
  
Dim sb1 As StringBuilder = New StringBuilder()  
  
Using sr1 = New StringWriter(sb1)  
    doc.Save(sr1, SaveOptions.None)  
    Console.WriteLine(sb1.ToString())  
End Using  
  
Dim sb2 As StringBuilder = New StringBuilder()  
  
Using sr2 = New StringWriter(sb2)  
    doc.Save(sr2, SaveOptions.DisableFormatting)  
    Console.WriteLine(sb2.ToString())  
End Using  
```  
  
 <span data-ttu-id="e8683-443">该示例产生下面的输出：</span><span class="sxs-lookup"><span data-stu-id="e8683-443">This example produces the following output:</span></span>  
  
```  
<?xml version="1.0" encoding="utf-16"?>  
<Root>  
  <Child>content</Child>  
</Root>  
<?xml version="1.0" encoding="utf-16"?><Root><Child>content</Child></Root>  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Xml.Linq.XDocument.WriteTo(System.Xml.XmlWriter)" />
        <altmember cref="Overload:System.Xml.Linq.XDocument.Load" />
        <altmember cref="Overload:System.Xml.Linq.XDocument.Parse" />
        <related type="Article" href="/dotnet/standard/linq/linq-xml-overview"><span data-ttu-id="e8683-444">LINQ to XML 概述</span><span class="sxs-lookup"><span data-stu-id="e8683-444">LINQ to XML overview</span></span></related>
        <related type="Article" href="/dotnet/standard/linq/read-write-encoded-document"><span data-ttu-id="e8683-445">如何读取和写入编码文档</span><span class="sxs-lookup"><span data-stu-id="e8683-445">How to read and write an encoded document</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Save">
      <MemberSignature Language="C#" Value="public void Save (string fileName, System.Xml.Linq.SaveOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Save(string fileName, valuetype System.Xml.Linq.SaveOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XDocument.Save(System.String,System.Xml.Linq.SaveOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Save (fileName As String, options As SaveOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Save(System::String ^ fileName, System::Xml::Linq::SaveOptions options);" />
      <MemberSignature Language="F#" Value="member this.Save : string * System.Xml.Linq.SaveOptions -&gt; unit" Usage="xDocument.Save (fileName, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="options" Type="System.Xml.Linq.SaveOptions" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="fileName"><span data-ttu-id="e8683-446">一个包含文件名称的字符串。</span><span class="sxs-lookup"><span data-stu-id="e8683-446">A string that contains the name of the file.</span></span></param>
        <param name="options"><span data-ttu-id="e8683-447">指定格式设置行为的 <see cref="T:System.Xml.Linq.SaveOptions" />。</span><span class="sxs-lookup"><span data-stu-id="e8683-447">A <see cref="T:System.Xml.Linq.SaveOptions" /> that specifies formatting behavior.</span></span></param>
        <summary><span data-ttu-id="e8683-448">将此 <see cref="T:System.Xml.Linq.XDocument" /> 序列化为文件，还可以选择禁用格式设置。</span><span class="sxs-lookup"><span data-stu-id="e8683-448">Serialize this <see cref="T:System.Xml.Linq.XDocument" /> to a file, optionally disabling formatting.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e8683-449">如果要保存未缩进的 XML，请指定的 <xref:System.Xml.Linq.SaveOptions.DisableFormatting> 标志 `options` 。</span><span class="sxs-lookup"><span data-stu-id="e8683-449">If you want to save unindented XML, specify the <xref:System.Xml.Linq.SaveOptions.DisableFormatting> flag for `options`.</span></span> <span data-ttu-id="e8683-450">这将导致编写器完全按 XML 树中的表示方式写入所有空格。</span><span class="sxs-lookup"><span data-stu-id="e8683-450">This will cause the writer to write all white space exactly as represented in the XML tree.</span></span>  
  
 <span data-ttu-id="e8683-451">如果要保存缩进的 XML，请勿 <xref:System.Xml.Linq.SaveOptions.DisableFormatting> 为指定标志 `options` 。</span><span class="sxs-lookup"><span data-stu-id="e8683-451">If you want to save indented XML, do not specify the <xref:System.Xml.Linq.SaveOptions.DisableFormatting> flag for `options`.</span></span> <span data-ttu-id="e8683-452">这将删除所有无关的无意义空格，并添加适当的无意义空白，以便正确缩进 XML。</span><span class="sxs-lookup"><span data-stu-id="e8683-452">This will remove all extraneous insignificant white space, and add appropriate insignificant white space so that the XML is properly indented.</span></span> <span data-ttu-id="e8683-453">这是默认行为，以及 <xref:System.Xml.Linq.XDocument.Save%2A> 不作为参数的方法的重载行为 `options` 。</span><span class="sxs-lookup"><span data-stu-id="e8683-453">This is the default behavior, and the behavior of the overloads of the <xref:System.Xml.Linq.XDocument.Save%2A> methods that do not take `options` as a parameter.</span></span>  
  
 <span data-ttu-id="e8683-454">有关详细信息，请参阅 [在加载或分析 XML 时保留空白](/dotnet/standard/linq/preserve-white-space-loading-parsing-xml) ，并 [在序列化时保留空白区域](/dotnet/standard/linq/preserve-white-space-serializing)。</span><span class="sxs-lookup"><span data-stu-id="e8683-454">For more information, see [Preserve white space while loading or parsing XML](/dotnet/standard/linq/preserve-white-space-loading-parsing-xml) and [Preserve white space while serializing](/dotnet/standard/linq/preserve-white-space-serializing).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="e8683-455">下面的示例演示了此方法的两种用法。</span><span class="sxs-lookup"><span data-stu-id="e8683-455">The following example shows two uses of this method.</span></span> <span data-ttu-id="e8683-456">第一次使用将保留空白。</span><span class="sxs-lookup"><span data-stu-id="e8683-456">The first use preserves white space.</span></span> <span data-ttu-id="e8683-457">第二个 <xref:System.Xml.Linq.XDocument> 用缩进序列化。</span><span class="sxs-lookup"><span data-stu-id="e8683-457">The second one serializes the <xref:System.Xml.Linq.XDocument> with indenting.</span></span>  
  
```csharp  
XDocument doc = new XDocument(  
    new XElement("Root",  
        new XElement("Child", "content")  
    )  
);  
doc.Save("Root1.xml", SaveOptions.DisableFormatting);  
Console.WriteLine(File.ReadAllText("Root1.xml"));  
doc.Save("Root2.xml", SaveOptions.None);  
Console.WriteLine(File.ReadAllText("Root2.xml"));  
```  
  
```vb  
Dim doc As XDocument = _   
    <?xml version="1.0" encoding="utf-8"?>  
        <Root><Child>content</Child></Root>  
  
doc.Save("Root1.xml", SaveOptions.DisableFormatting)  
Console.WriteLine(File.ReadAllText("Root1.xml"))  
doc.Save("Root2.xml", SaveOptions.None)  
Console.WriteLine(File.ReadAllText("Root2.xml"))  
```  
  
 <span data-ttu-id="e8683-458">该示例产生下面的输出：</span><span class="sxs-lookup"><span data-stu-id="e8683-458">This example produces the following output:</span></span>  
  
```  
<?xml version="1.0" encoding="utf-8"?><Root><Child>content</Child></Root>  
<?xml version="1.0" encoding="utf-8"?>  
<Root>  
  <Child>content</Child>  
</Root>  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Xml.Linq.XDocument.WriteTo(System.Xml.XmlWriter)" />
        <altmember cref="Overload:System.Xml.Linq.XDocument.Load" />
        <altmember cref="Overload:System.Xml.Linq.XDocument.Parse" />
        <related type="Article" href="/dotnet/standard/linq/linq-xml-overview"><span data-ttu-id="e8683-459">LINQ to XML 概述</span><span class="sxs-lookup"><span data-stu-id="e8683-459">LINQ to XML overview</span></span></related>
        <related type="Article" href="/dotnet/standard/linq/read-write-encoded-document"><span data-ttu-id="e8683-460">如何：读取和写入编码的文档</span><span class="sxs-lookup"><span data-stu-id="e8683-460">How to: Read and Write an Encoded Document</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="SaveAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task SaveAsync (System.Xml.XmlWriter writer, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task SaveAsync(class System.Xml.XmlWriter writer, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XDocument.SaveAsync(System.Xml.XmlWriter,System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Function SaveAsync (writer As XmlWriter, cancellationToken As CancellationToken) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ SaveAsync(System::Xml::XmlWriter ^ writer, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.SaveAsync : System.Xml.XmlWriter * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="xDocument.SaveAsync (writer, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="writer"><span data-ttu-id="e8683-461">要向其输出 XML 的编写器。</span><span class="sxs-lookup"><span data-stu-id="e8683-461">The writer to output the XML to.</span></span></param>
        <param name="cancellationToken"><span data-ttu-id="e8683-462">取消标记。</span><span class="sxs-lookup"><span data-stu-id="e8683-462">A cancellation token.</span></span></param>
        <summary><span data-ttu-id="e8683-463">将此 <see cref="T:System.Xml.Linq.XDocument" /> 写入到 <see cref="T:System.Xml.XmlWriter" />。</span><span class="sxs-lookup"><span data-stu-id="e8683-463">Writes this <see cref="T:System.Xml.Linq.XDocument" /> to an <see cref="T:System.Xml.XmlWriter" />.</span></span></summary>
        <returns><span data-ttu-id="e8683-464">表示异步保存操作的任务。</span><span class="sxs-lookup"><span data-stu-id="e8683-464">A task representing the asynchronous save operation.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SaveAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task SaveAsync (System.IO.Stream stream, System.Xml.Linq.SaveOptions options, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task SaveAsync(class System.IO.Stream stream, valuetype System.Xml.Linq.SaveOptions options, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XDocument.SaveAsync(System.IO.Stream,System.Xml.Linq.SaveOptions,System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Function SaveAsync (stream As Stream, options As SaveOptions, cancellationToken As CancellationToken) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ SaveAsync(System::IO::Stream ^ stream, System::Xml::Linq::SaveOptions options, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.SaveAsync : System.IO.Stream * System.Xml.Linq.SaveOptions * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="xDocument.SaveAsync (stream, options, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="options" Type="System.Xml.Linq.SaveOptions" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="stream"><span data-ttu-id="e8683-465">要向其写入 XML 的流。</span><span class="sxs-lookup"><span data-stu-id="e8683-465">The stream to write the XML to.</span></span></param>
        <param name="options"><span data-ttu-id="e8683-466">一组加载选项。</span><span class="sxs-lookup"><span data-stu-id="e8683-466">A set of load options.</span></span></param>
        <param name="cancellationToken"><span data-ttu-id="e8683-467">取消标记。</span><span class="sxs-lookup"><span data-stu-id="e8683-467">A cancellation token.</span></span></param>
        <summary><span data-ttu-id="e8683-468">将此 <see cref="T:System.Xml.Linq.XDocument" /> 输出到 <see cref="T:System.IO.Stream" />。</span><span class="sxs-lookup"><span data-stu-id="e8683-468">Output this <see cref="T:System.Xml.Linq.XDocument" /> to a <see cref="T:System.IO.Stream" />.</span></span></summary>
        <returns><span data-ttu-id="e8683-469">表示异步保存操作的任务。</span><span class="sxs-lookup"><span data-stu-id="e8683-469">A task representing the asynchronous save operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  

## Remarks

<span data-ttu-id="e8683-470">如果 <xref:System.Xml.Linq.SaveOptions.DisableFormatting?displayProperty=nameWithType> 设置了，则不缩进输出。</span><span class="sxs-lookup"><span data-stu-id="e8683-470">If <xref:System.Xml.Linq.SaveOptions.DisableFormatting?displayProperty=nameWithType> is set, the output is not indented.</span></span> <span data-ttu-id="e8683-471">如果 <xref:System.Xml.Linq.SaveOptions.OmitDuplicateNamespaces?displayProperty=nameWithType> 设置了，则将移除重复的命名空间声明。</span><span class="sxs-lookup"><span data-stu-id="e8683-471">If <xref:System.Xml.Linq.SaveOptions.OmitDuplicateNamespaces?displayProperty=nameWithType> is set, duplicate namespace declarations will be removed.</span></span>

         ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SaveAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task SaveAsync (System.IO.TextWriter textWriter, System.Xml.Linq.SaveOptions options, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task SaveAsync(class System.IO.TextWriter textWriter, valuetype System.Xml.Linq.SaveOptions options, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XDocument.SaveAsync(System.IO.TextWriter,System.Xml.Linq.SaveOptions,System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Function SaveAsync (textWriter As TextWriter, options As SaveOptions, cancellationToken As CancellationToken) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ SaveAsync(System::IO::TextWriter ^ textWriter, System::Xml::Linq::SaveOptions options, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.SaveAsync : System.IO.TextWriter * System.Xml.Linq.SaveOptions * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="xDocument.SaveAsync (textWriter, options, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="textWriter" Type="System.IO.TextWriter" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="options" Type="System.Xml.Linq.SaveOptions" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="textWriter"><span data-ttu-id="e8683-472">要向其输出 XML 的文本编写器。</span><span class="sxs-lookup"><span data-stu-id="e8683-472">The text writer to output the XML to.</span></span></param>
        <param name="options"><span data-ttu-id="e8683-473">一组加载选项。</span><span class="sxs-lookup"><span data-stu-id="e8683-473">A set of load options.</span></span></param>
        <param name="cancellationToken"><span data-ttu-id="e8683-474">取消标记。</span><span class="sxs-lookup"><span data-stu-id="e8683-474">A cancellation token.</span></span></param>
        <summary><span data-ttu-id="e8683-475">将此 <see cref="T:System.Xml.Linq.XDocument" /> 写入到 <see cref="T:System.IO.TextWriter" />。</span><span class="sxs-lookup"><span data-stu-id="e8683-475">Writes this <see cref="T:System.Xml.Linq.XDocument" /> to a <see cref="T:System.IO.TextWriter" />.</span></span></summary>
        <returns><span data-ttu-id="e8683-476">表示异步保存操作的任务。</span><span class="sxs-lookup"><span data-stu-id="e8683-476">A task representing the asynchronous save operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="e8683-477">如果 <xref:System.Xml.Linq.SaveOptions.DisableFormatting?displayProperty=nameWithType> 设置了，则不缩进输出。</span><span class="sxs-lookup"><span data-stu-id="e8683-477">If <xref:System.Xml.Linq.SaveOptions.DisableFormatting?displayProperty=nameWithType> is set, the output is not indented.</span></span> <span data-ttu-id="e8683-478">如果 <xref:System.Xml.Linq.SaveOptions.OmitDuplicateNamespaces?displayProperty=nameWithType> 设置了，则将移除重复的命名空间声明。</span><span class="sxs-lookup"><span data-stu-id="e8683-478">If <xref:System.Xml.Linq.SaveOptions.OmitDuplicateNamespaces?displayProperty=nameWithType> is set, duplicate namespace declarations will be removed.</span></span>

           ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteTo">
      <MemberSignature Language="C#" Value="public override void WriteTo (System.Xml.XmlWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void WriteTo(class System.Xml.XmlWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XDocument.WriteTo(System.Xml.XmlWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub WriteTo (writer As XmlWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void WriteTo(System::Xml::XmlWriter ^ writer);" />
      <MemberSignature Language="F#" Value="override this.WriteTo : System.Xml.XmlWriter -&gt; unit" Usage="xDocument.WriteTo writer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
      </Parameters>
      <Docs>
        <param name="writer"><span data-ttu-id="e8683-479">此方法将写入其中的 <see cref="T:System.Xml.XmlWriter" />。</span><span class="sxs-lookup"><span data-stu-id="e8683-479">An <see cref="T:System.Xml.XmlWriter" /> into which this method will write.</span></span></param>
        <summary><span data-ttu-id="e8683-480">将此文档写入 <see cref="T:System.Xml.XmlWriter" />。</span><span class="sxs-lookup"><span data-stu-id="e8683-480">Write this document to an <see cref="T:System.Xml.XmlWriter" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="e8683-481">下面的示例演示如何将写入 <xref:System.Xml.Linq.XDocument> <xref:System.Xml.XmlWriter> 。</span><span class="sxs-lookup"><span data-stu-id="e8683-481">The following example shows how to write an <xref:System.Xml.Linq.XDocument> to an <xref:System.Xml.XmlWriter>.</span></span> <span data-ttu-id="e8683-482">请注意，该示例未编写 XML 声明。</span><span class="sxs-lookup"><span data-stu-id="e8683-482">Note that the example did not write an XML declaration.</span></span>  
  
```csharp  
StringBuilder sb = new StringBuilder();  
XmlWriterSettings xws = new XmlWriterSettings();  
xws.OmitXmlDeclaration = true;  
xws.Indent = true;  
  
using (XmlWriter xw = XmlWriter.Create(sb, xws))  
{  
    XDocument doc = new XDocument(  
        new XElement("Child",  
            new XElement("GrandChild", "some content")  
        )  
    );  
    doc.WriteTo(xw);  
}  
  
Console.WriteLine(sb.ToString());  
```  
  
```vb  
Dim sb As StringBuilder = New StringBuilder()  
Dim xws As XmlWriterSettings = New XmlWriterSettings()  
xws.OmitXmlDeclaration = True  
xws.Indent = True  
  
Using xw = XmlWriter.Create(sb, xws)  
    Dim doc As XDocument = New XDocument(<Child><GrandChild>some content</GrandChild></Child>)  
    doc.WriteTo(xw)  
End Using  
  
Console.WriteLine(sb.ToString())  
```  
  
 <span data-ttu-id="e8683-483">该示例产生下面的输出：</span><span class="sxs-lookup"><span data-stu-id="e8683-483">This example produces the following output:</span></span>  
  
```xml  
<Child>  
  <GrandChild>some content</GrandChild>  
</Child>  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Xml.Linq.XDocument.Save" />
        <altmember cref="Overload:System.Xml.Linq.XDocument.Load" />
        <altmember cref="Overload:System.Xml.Linq.XDocument.Parse" />
        <related type="Article" href="/dotnet/standard/linq/linq-xml-overview"><span data-ttu-id="e8683-484">LINQ to XML 概述</span><span class="sxs-lookup"><span data-stu-id="e8683-484">LINQ to XML overview</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="WriteToAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task WriteToAsync (System.Xml.XmlWriter writer, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task WriteToAsync(class System.Xml.XmlWriter writer, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XDocument.WriteToAsync(System.Xml.XmlWriter,System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function WriteToAsync (writer As XmlWriter, cancellationToken As CancellationToken) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::Task ^ WriteToAsync(System::Xml::XmlWriter ^ writer, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="override this.WriteToAsync : System.Xml.XmlWriter * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="xDocument.WriteToAsync (writer, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="writer"><span data-ttu-id="e8683-485">要输出此 <see cref="T:System.Xml.Linq.XDocument" /> 的内容的编写器。</span><span class="sxs-lookup"><span data-stu-id="e8683-485">The writer to output the content of this <see cref="T:System.Xml.Linq.XDocument" />.</span></span></param>
        <param name="cancellationToken"><span data-ttu-id="e8683-486">取消标记。</span><span class="sxs-lookup"><span data-stu-id="e8683-486">A cancellation token.</span></span></param>
        <summary><span data-ttu-id="e8683-487">将此 XDocument 的基础 XML 树写入指定的 <see cref="T:System.Xml.XmlWriter" />。</span><span class="sxs-lookup"><span data-stu-id="e8683-487">Writes this XDocument's underlying XML tree to the specified <see cref="T:System.Xml.XmlWriter" />.</span></span></summary>
        <returns><span data-ttu-id="e8683-488">表示异步写入操作的任务。</span><span class="sxs-lookup"><span data-stu-id="e8683-488">A task representing the asynchronous write operation.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
