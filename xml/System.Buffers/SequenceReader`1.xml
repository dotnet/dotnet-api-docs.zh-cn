<Type Name="SequenceReader&lt;T&gt;" FullName="System.Buffers.SequenceReader&lt;T&gt;">
  <Metadata><Meta Name="ms.openlocfilehash" Value="7746aef461bdf3e8df9228ed94ea367bfb0beeca" /><Meta Name="ms.sourcegitcommit" Value="ec905a25e6dd05a6a3ffa7f30bf59f3095a8cd67" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-CN" /><Meta Name="ms.lasthandoff" Value="09/01/2020" /><Meta Name="ms.locfileid" Value="89248936" /></Metadata><TypeSignature Language="C#" Value="public struct SequenceReader&lt;T&gt; where T : struct" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi sealed beforefieldinit SequenceReader`1&lt;struct .ctor (class System.ValueType, class System.IEquatable`1&lt;!T&gt;) T&gt; extends System.ValueType" />
  <TypeSignature Language="DocId" Value="T:System.Buffers.SequenceReader`1" />
  <TypeSignature Language="VB.NET" Value="Public Structure SequenceReader(Of T)" />
  <TypeSignature Language="C++ CLI" Value="generic &lt;typename T&gt;&#xA; where T : value classpublic value class SequenceReader" />
  <TypeSignature Language="F#" Value="type SequenceReader&lt;'T (requires 'T : struct)&gt; = struct" />
  <AssemblyInfo>
    <AssemblyName>System.Memory</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
    <AssemblyVersion>5.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeForwardingChain>
    <TypeForwarding From="netstandard" FromVersion="2.1.0.0" To="System.Memory" ToVersion="5.0.0.0" FrameworkAlternate="net-5.0" />
  </TypeForwardingChain>
  <TypeParameters>
    <TypeParameter Name="T">
      <Constraints>
        <ParameterAttribute>DefaultConstructorConstraint</ParameterAttribute>
        <ParameterAttribute>NotNullableValueTypeConstraint</ParameterAttribute>
        <BaseTypeName>System.ValueType</BaseTypeName>
        <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
      </Constraints>
    </TypeParameter>
  </TypeParameters>
  <Base>
    <BaseTypeName>System.ValueType</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netcore-3.0;netcore-3.1;netstandard-2.1">
      <AttributeName Language="C#">[System.Runtime.CompilerServices.IsByRefLike]</AttributeName>
      <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsByRefLike&gt;]</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <typeparam name="T"><span data-ttu-id="32529-101">只读序列的类型。</span><span class="sxs-lookup"><span data-stu-id="32529-101">The type of the read-only sequence.</span></span></typeparam>
    <summary><span data-ttu-id="32529-102">提供从 <see cref="T:System.Buffers.ReadOnlySequence`1" /> 读取二进制数据和文本数据的方法，重点关注性能和最小或零堆分配。</span><span class="sxs-lookup"><span data-stu-id="32529-102">Provides methods for reading binary and text data out of a <see cref="T:System.Buffers.ReadOnlySequence`1" /> with a focus on performance and minimal or zero heap allocations.</span></span></summary>
    <remarks>To be added.</remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SequenceReader (System.Buffers.ReadOnlySequence&lt;T&gt; sequence);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Buffers.ReadOnlySequence`1&lt;!T&gt; sequence) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.SequenceReader`1.#ctor(System.Buffers.ReadOnlySequence{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (sequence As ReadOnlySequence(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SequenceReader(System::Buffers::ReadOnlySequence&lt;T&gt; sequence);" />
      <MemberSignature Language="F#" Value="new System.Buffers.SequenceReader&lt;'T (requires 'T : struct)&gt; : System.Buffers.ReadOnlySequence&lt;'T (requires 'T : struct)&gt; -&gt; System.Buffers.SequenceReader&lt;'T (requires 'T : struct)&gt;" Usage="new System.Buffers.SequenceReader&lt;'T (requires 'T : struct)&gt; sequence" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="sequence" Type="System.Buffers.ReadOnlySequence&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="sequence"><span data-ttu-id="32529-103">用于创建 <see cref="T:System.Buffers.SequenceReader`1" /> 的只读序列。</span><span class="sxs-lookup"><span data-stu-id="32529-103">The read-only sequence over which to create the <see cref="T:System.Buffers.SequenceReader`1" />.</span></span></param>
        <summary><span data-ttu-id="32529-104">根据给定 <see cref="T:System.Buffers.ReadOnlySequence`1" /> 创建 <see cref="T:System.Buffers.SequenceReader`1" />。</span><span class="sxs-lookup"><span data-stu-id="32529-104">Creates a <see cref="T:System.Buffers.SequenceReader`1" /> over a given <see cref="T:System.Buffers.ReadOnlySequence`1" />.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Advance">
      <MemberSignature Language="C#" Value="public void Advance (long count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Advance(int64 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.SequenceReader`1.Advance(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Advance (count As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Advance(long count);" />
      <MemberSignature Language="F#" Value="member this.Advance : int64 -&gt; unit" Usage="sequenceReader.Advance count" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="count" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="count"><span data-ttu-id="32529-105">要前进的项数。</span><span class="sxs-lookup"><span data-stu-id="32529-105">The number of items to advance.</span></span></param>
        <summary><span data-ttu-id="32529-106">将读取器向前移动指定的项数。</span><span class="sxs-lookup"><span data-stu-id="32529-106">Moves the reader ahead a specified number of items.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AdvancePast">
      <MemberSignature Language="C#" Value="public long AdvancePast (T value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int64 AdvancePast(!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.SequenceReader`1.AdvancePast(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function AdvancePast (value As T) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; long AdvancePast(T value);" />
      <MemberSignature Language="F#" Value="member this.AdvancePast : 'T -&gt; int64" Usage="sequenceReader.AdvancePast value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="32529-107">读取器要向前越过的值。</span><span class="sxs-lookup"><span data-stu-id="32529-107">The value past which the reader is to advance.</span></span></param>
        <summary><span data-ttu-id="32529-108">向前跳过具有给定 <paramref name="value" /> 的连续实例。</span><span class="sxs-lookup"><span data-stu-id="32529-108">Advances past consecutive instances of the given <paramref name="value" />.</span></span></summary>
        <returns><span data-ttu-id="32529-109">读取器前进的位置数。</span><span class="sxs-lookup"><span data-stu-id="32529-109">The number of positions the reader has advanced.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AdvancePastAny">
      <MemberSignature Language="C#" Value="public long AdvancePastAny (ReadOnlySpan&lt;T&gt; values);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int64 AdvancePastAny(valuetype System.ReadOnlySpan`1&lt;!T&gt; values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.SequenceReader`1.AdvancePastAny(System.ReadOnlySpan{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function AdvancePastAny (values As ReadOnlySpan(Of T)) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; long AdvancePastAny(ReadOnlySpan&lt;T&gt; values);" />
      <MemberSignature Language="F#" Value="member this.AdvancePastAny : ReadOnlySpan&lt;'T (requires 'T : struct)&gt; -&gt; int64" Usage="sequenceReader.AdvancePastAny values" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="values" Type="System.ReadOnlySpan&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="values"><span data-ttu-id="32529-110">要跳过的值。</span><span class="sxs-lookup"><span data-stu-id="32529-110">The values to be skipped.</span></span></param>
        <summary><span data-ttu-id="32529-111">跳过具有任何指定 <paramref name="values" /> 的连续实例。</span><span class="sxs-lookup"><span data-stu-id="32529-111">Skips consecutive instances of any of the specified <paramref name="values" />.</span></span></summary>
        <returns><span data-ttu-id="32529-112">读取器前进的位置数。</span><span class="sxs-lookup"><span data-stu-id="32529-112">The number of positions the reader has advanced.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AdvancePastAny">
      <MemberSignature Language="C#" Value="public long AdvancePastAny (T value0, T value1);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int64 AdvancePastAny(!T value0, !T value1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.SequenceReader`1.AdvancePastAny(`0,`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function AdvancePastAny (value0 As T, value1 As T) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; long AdvancePastAny(T value0, T value1);" />
      <MemberSignature Language="F#" Value="member this.AdvancePastAny : 'T * 'T -&gt; int64" Usage="sequenceReader.AdvancePastAny (value0, value1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value0" Type="T" />
        <Parameter Name="value1" Type="T" />
      </Parameters>
      <Docs>
        <param name="value0"><span data-ttu-id="32529-113">要跳过的第一个值。</span><span class="sxs-lookup"><span data-stu-id="32529-113">The first value to skip.</span></span></param>
        <param name="value1"><span data-ttu-id="32529-114">要跳过的第二个值。</span><span class="sxs-lookup"><span data-stu-id="32529-114">The second value to skip.</span></span></param>
        <summary><span data-ttu-id="32529-115">向前跳过具有两个指定值之一的连续实例。</span><span class="sxs-lookup"><span data-stu-id="32529-115">Advances past consecutive instances of either of two specified values.</span></span></summary>
        <returns><span data-ttu-id="32529-116">读取器前进的位置数。</span><span class="sxs-lookup"><span data-stu-id="32529-116">The number of positions the reader has advanced.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AdvancePastAny">
      <MemberSignature Language="C#" Value="public long AdvancePastAny (T value0, T value1, T value2);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int64 AdvancePastAny(!T value0, !T value1, !T value2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.SequenceReader`1.AdvancePastAny(`0,`0,`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function AdvancePastAny (value0 As T, value1 As T, value2 As T) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; long AdvancePastAny(T value0, T value1, T value2);" />
      <MemberSignature Language="F#" Value="member this.AdvancePastAny : 'T * 'T * 'T -&gt; int64" Usage="sequenceReader.AdvancePastAny (value0, value1, value2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value0" Type="T" />
        <Parameter Name="value1" Type="T" />
        <Parameter Name="value2" Type="T" />
      </Parameters>
      <Docs>
        <param name="value0"><span data-ttu-id="32529-117">要跳过的第一个值。</span><span class="sxs-lookup"><span data-stu-id="32529-117">The first value to skip.</span></span></param>
        <param name="value1"><span data-ttu-id="32529-118">要跳过的第二个值。</span><span class="sxs-lookup"><span data-stu-id="32529-118">The second value to skip.</span></span></param>
        <param name="value2"><span data-ttu-id="32529-119">要跳过的第三个值。</span><span class="sxs-lookup"><span data-stu-id="32529-119">The third value to skip.</span></span></param>
        <summary><span data-ttu-id="32529-120">向前跳过具有三个指定值之一的连续实例。</span><span class="sxs-lookup"><span data-stu-id="32529-120">Advances past consecutive instances of any of three specified values.</span></span></summary>
        <returns><span data-ttu-id="32529-121">读取器前进的位置数。</span><span class="sxs-lookup"><span data-stu-id="32529-121">The number of positions the reader has advanced.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AdvancePastAny">
      <MemberSignature Language="C#" Value="public long AdvancePastAny (T value0, T value1, T value2, T value3);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int64 AdvancePastAny(!T value0, !T value1, !T value2, !T value3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.SequenceReader`1.AdvancePastAny(`0,`0,`0,`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function AdvancePastAny (value0 As T, value1 As T, value2 As T, value3 As T) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; long AdvancePastAny(T value0, T value1, T value2, T value3);" />
      <MemberSignature Language="F#" Value="member this.AdvancePastAny : 'T * 'T * 'T * 'T -&gt; int64" Usage="sequenceReader.AdvancePastAny (value0, value1, value2, value3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value0" Type="T" />
        <Parameter Name="value1" Type="T" />
        <Parameter Name="value2" Type="T" />
        <Parameter Name="value3" Type="T" />
      </Parameters>
      <Docs>
        <param name="value0"><span data-ttu-id="32529-122">要跳过的第一个值。</span><span class="sxs-lookup"><span data-stu-id="32529-122">The first value to skip.</span></span></param>
        <param name="value1"><span data-ttu-id="32529-123">要跳过的第二个值。</span><span class="sxs-lookup"><span data-stu-id="32529-123">The second value to skip.</span></span></param>
        <param name="value2"><span data-ttu-id="32529-124">要跳过的第三个值。</span><span class="sxs-lookup"><span data-stu-id="32529-124">The third value to skip.</span></span></param>
        <param name="value3"><span data-ttu-id="32529-125">要跳过的第四个值。</span><span class="sxs-lookup"><span data-stu-id="32529-125">The fourth value to skip.</span></span></param>
        <summary><span data-ttu-id="32529-126">向前跳过具有四个指定值之一的连续实例。</span><span class="sxs-lookup"><span data-stu-id="32529-126">Advances past consecutive instances of any of four specified values.</span></span></summary>
        <returns><span data-ttu-id="32529-127">读取器前进的位置数。</span><span class="sxs-lookup"><span data-stu-id="32529-127">The number of positions the reader has advanced.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AdvanceToEnd">
      <MemberSignature Language="C#" Value="public void AdvanceToEnd ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AdvanceToEnd() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.SequenceReader`1.AdvanceToEnd" />
      <MemberSignature Language="VB.NET" Value="Public Sub AdvanceToEnd ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AdvanceToEnd();" />
      <MemberSignature Language="F#" Value="member this.AdvanceToEnd : unit -&gt; unit" Usage="sequenceReader.AdvanceToEnd " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="32529-128">将读取器移动到序列末尾。</span><span class="sxs-lookup"><span data-stu-id="32529-128">Moves the reader to the end of the sequence.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Consumed">
      <MemberSignature Language="C#" Value="public long Consumed { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Consumed" />
      <MemberSignature Language="DocId" Value="P:System.Buffers.SequenceReader`1.Consumed" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Consumed As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long Consumed { long get(); };" />
      <MemberSignature Language="F#" Value="member this.Consumed : int64" Usage="System.Buffers.SequenceReader&lt;'T (requires 'T : struct)&gt;.Consumed" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-3.0;netcore-3.1;netstandard-2.1">
          <AttributeName Language="C#">[get: System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="32529-129">获取由读取器处理的 <typeparamref name="T" /> 值总数。</span><span class="sxs-lookup"><span data-stu-id="32529-129">Gets the total number of <typeparamref name="T" /> values processed by the reader.</span></span></summary>
        <value><span data-ttu-id="32529-130">读取器处理的值的总数。</span><span class="sxs-lookup"><span data-stu-id="32529-130">The total number of values processed by the reader.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CurrentSpan">
      <MemberSignature Language="C#" Value="public ReadOnlySpan&lt;T&gt; CurrentSpan { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.ReadOnlySpan`1&lt;!T&gt; CurrentSpan" />
      <MemberSignature Language="DocId" Value="P:System.Buffers.SequenceReader`1.CurrentSpan" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CurrentSpan As ReadOnlySpan(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property ReadOnlySpan&lt;T&gt; CurrentSpan { ReadOnlySpan&lt;T&gt; get(); };" />
      <MemberSignature Language="F#" Value="member this.CurrentSpan : ReadOnlySpan&lt;'T (requires 'T : struct)&gt;" Usage="System.Buffers.SequenceReader&lt;'T (requires 'T : struct)&gt;.CurrentSpan" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-3.0;netcore-3.1;netstandard-2.1">
          <AttributeName Language="C#">[get: System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="32529-131">获取 <see cref="T:System.Span`1" />，它包含 <see cref="P:System.Buffers.SequenceReader`1.Sequence" /> 中的当前段。</span><span class="sxs-lookup"><span data-stu-id="32529-131">Gets a <see cref="T:System.Span`1" /> that contains the current segment in the <see cref="P:System.Buffers.SequenceReader`1.Sequence" />.</span></span></summary>
        <value><span data-ttu-id="32529-132">一个包含序列中的当前段的范围。</span><span class="sxs-lookup"><span data-stu-id="32529-132">A span that contains the current segment in the sequence.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CurrentSpanIndex">
      <MemberSignature Language="C#" Value="public int CurrentSpanIndex { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 CurrentSpanIndex" />
      <MemberSignature Language="DocId" Value="P:System.Buffers.SequenceReader`1.CurrentSpanIndex" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CurrentSpanIndex As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int CurrentSpanIndex { int get(); };" />
      <MemberSignature Language="F#" Value="member this.CurrentSpanIndex : int" Usage="System.Buffers.SequenceReader&lt;'T (requires 'T : struct)&gt;.CurrentSpanIndex" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-3.0;netcore-3.1;netstandard-2.1">
          <AttributeName Language="C#">[get: System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="32529-133">获取 <see cref="P:System.Buffers.SequenceReader`1.CurrentSpan" /> 中的索引。</span><span class="sxs-lookup"><span data-stu-id="32529-133">Gets the index in the <see cref="P:System.Buffers.SequenceReader`1.CurrentSpan" />.</span></span></summary>
        <value><span data-ttu-id="32529-134">中的索引 <see cref="P:System.Buffers.SequenceReader`1.CurrentSpan" /> 。</span><span class="sxs-lookup"><span data-stu-id="32529-134">The index in the <see cref="P:System.Buffers.SequenceReader`1.CurrentSpan" />.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="End">
      <MemberSignature Language="C#" Value="public bool End { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool End" />
      <MemberSignature Language="DocId" Value="P:System.Buffers.SequenceReader`1.End" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property End As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool End { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.End : bool" Usage="System.Buffers.SequenceReader&lt;'T (requires 'T : struct)&gt;.End" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-3.0;netcore-3.1;netstandard-2.1">
          <AttributeName Language="C#">[get: System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="32529-135">获取一个值，该值指示 <see cref="P:System.Buffers.SequenceReader`1.Sequence" /> 中是否不再有数据。</span><span class="sxs-lookup"><span data-stu-id="32529-135">Gets a value that indicates whether there is no more data in the <see cref="P:System.Buffers.SequenceReader`1.Sequence" />.</span></span></summary>
        <value><span data-ttu-id="32529-136"><see langword="true" /> 如果中没有更多数据 <see cref="P:System.Buffers.SequenceReader`1.Sequence" /> ，则为; 否则为 <see langword="false" /> 。</span><span class="sxs-lookup"><span data-stu-id="32529-136"><see langword="true" /> when there is no more data in the <see cref="P:System.Buffers.SequenceReader`1.Sequence" />; otherwise, <see langword="false" />.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsNext">
      <MemberSignature Language="C#" Value="public bool IsNext (ReadOnlySpan&lt;T&gt; next, bool advancePast = false);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsNext(valuetype System.ReadOnlySpan`1&lt;!T&gt; next, bool advancePast) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.SequenceReader`1.IsNext(System.ReadOnlySpan{`0},System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsNext (next As ReadOnlySpan(Of T), Optional advancePast As Boolean = false) As Boolean" />
      <MemberSignature Language="F#" Value="member this.IsNext : ReadOnlySpan&lt;'T (requires 'T : struct)&gt; * bool -&gt; bool" Usage="sequenceReader.IsNext (next, advancePast)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="next" Type="System.ReadOnlySpan&lt;T&gt;" />
        <Parameter Name="advancePast" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="next"><span data-ttu-id="32529-137">要与下一项进行比较的范围。</span><span class="sxs-lookup"><span data-stu-id="32529-137">The span to compare the next items to.</span></span></param>
        <param name="advancePast"><span data-ttu-id="32529-138">若要跳过 <paramref name="next" /> 值（如果发现了这些值），则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="32529-138"><see langword="true" /> to move past the <paramref name="next" /> values if they are found; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="32529-139">检查在只读范围中指定的值是否是序列中的下一个值。</span><span class="sxs-lookup"><span data-stu-id="32529-139">Checks whether the values specified in a read-only span are next in the sequence.</span></span></summary>
        <returns><span data-ttu-id="32529-140">如果这些值是序列中的后续值，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="32529-140"><see langword="true" /> if the values are next in sequence; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsNext">
      <MemberSignature Language="C#" Value="public bool IsNext (T next, bool advancePast = false);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsNext(!T next, bool advancePast) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.SequenceReader`1.IsNext(`0,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsNext (next As T, Optional advancePast As Boolean = false) As Boolean" />
      <MemberSignature Language="F#" Value="member this.IsNext : 'T * bool -&gt; bool" Usage="sequenceReader.IsNext (next, advancePast)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="next" Type="T" />
        <Parameter Name="advancePast" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="next"><span data-ttu-id="32529-141">要与下一项进行比较的值。</span><span class="sxs-lookup"><span data-stu-id="32529-141">The value to compare the next items to.</span></span></param>
        <param name="advancePast"><span data-ttu-id="32529-142">若要跳过 <paramref name="next" /> 值（如果发现了这些值），则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="32529-142"><see langword="true" /> to move past the <paramref name="next" /> values if they are found; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="32529-143">检查指定值是否是序列中的下一个值。</span><span class="sxs-lookup"><span data-stu-id="32529-143">Checks whether a specified value is next in the sequence.</span></span></summary>
        <returns><span data-ttu-id="32529-144">如果这些值是序列中的后续值，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="32529-144"><see langword="true" /> if the values are next in sequence; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Length">
      <MemberSignature Language="C#" Value="public long Length { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Length" />
      <MemberSignature Language="DocId" Value="P:System.Buffers.SequenceReader`1.Length" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Length As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long Length { long get(); };" />
      <MemberSignature Language="F#" Value="member this.Length : int64" Usage="System.Buffers.SequenceReader&lt;'T (requires 'T : struct)&gt;.Length" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-3.0;netcore-3.1;netstandard-2.1">
          <AttributeName Language="C#">[get: System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="32529-145">获取读取器的 <see cref="P:System.Buffers.SequenceReader`1.Sequence" /> 中的项数。</span><span class="sxs-lookup"><span data-stu-id="32529-145">Gets the count of items in the reader's <see cref="P:System.Buffers.SequenceReader`1.Sequence" />.</span></span></summary>
        <value><span data-ttu-id="32529-146">读取器中项的计数 <see cref="P:System.Buffers.SequenceReader`1.Sequence" /> 。</span><span class="sxs-lookup"><span data-stu-id="32529-146">The count of items in the reader's <see cref="P:System.Buffers.SequenceReader`1.Sequence" />.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Position">
      <MemberSignature Language="C#" Value="public SequencePosition Position { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.SequencePosition Position" />
      <MemberSignature Language="DocId" Value="P:System.Buffers.SequenceReader`1.Position" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Position As SequencePosition" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property SequencePosition Position { SequencePosition get(); };" />
      <MemberSignature Language="F#" Value="member this.Position : SequencePosition" Usage="System.Buffers.SequenceReader&lt;'T (requires 'T : struct)&gt;.Position" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-3.0;netcore-3.1;netstandard-2.1">
          <AttributeName Language="C#">[get: System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.SequencePosition</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="32529-147">获取 <see cref="P:System.Buffers.SequenceReader`1.Sequence" /> 中的当前位置。</span><span class="sxs-lookup"><span data-stu-id="32529-147">Gets the current position in the <see cref="P:System.Buffers.SequenceReader`1.Sequence" />.</span></span></summary>
        <value><span data-ttu-id="32529-148">中的当前位置 <see cref="P:System.Buffers.SequenceReader`1.Sequence" /> 。</span><span class="sxs-lookup"><span data-stu-id="32529-148">The current position in the <see cref="P:System.Buffers.SequenceReader`1.Sequence" />.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Remaining">
      <MemberSignature Language="C#" Value="public long Remaining { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Remaining" />
      <MemberSignature Language="DocId" Value="P:System.Buffers.SequenceReader`1.Remaining" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Remaining As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long Remaining { long get(); };" />
      <MemberSignature Language="F#" Value="member this.Remaining : int64" Usage="System.Buffers.SequenceReader&lt;'T (requires 'T : struct)&gt;.Remaining" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-3.0;netcore-3.1;netstandard-2.1">
          <AttributeName Language="C#">[get: System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="32529-149">获取读取器的 <see cref="P:System.Buffers.SequenceReader`1.Sequence" /> 中的剩余项。</span><span class="sxs-lookup"><span data-stu-id="32529-149">Gets  the remaining items in the reader's <see cref="P:System.Buffers.SequenceReader`1.Sequence" />.</span></span></summary>
        <value><span data-ttu-id="32529-150">读取器的剩余项 <see cref="P:System.Buffers.SequenceReader`1.Sequence" /></span><span class="sxs-lookup"><span data-stu-id="32529-150">The remaining items in the reader's <see cref="P:System.Buffers.SequenceReader`1.Sequence" /></span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Rewind">
      <MemberSignature Language="C#" Value="public void Rewind (long count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Rewind(int64 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.SequenceReader`1.Rewind(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Rewind (count As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Rewind(long count);" />
      <MemberSignature Language="F#" Value="member this.Rewind : int64 -&gt; unit" Usage="sequenceReader.Rewind count" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="count" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="count"><span data-ttu-id="32529-151">项数。</span><span class="sxs-lookup"><span data-stu-id="32529-151">The number of items.</span></span></param>
        <summary><span data-ttu-id="32529-152">将读取器向后移动指定的项数。</span><span class="sxs-lookup"><span data-stu-id="32529-152">Moves the reader back the specified number of items.</span></span></summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="32529-153"><paramref name="count" /> 为负数或大于 <see cref="P:System.Buffers.SequenceReader`1.Consumed" />。</span><span class="sxs-lookup"><span data-stu-id="32529-153"><paramref name="count" /> is negative or greater than <see cref="P:System.Buffers.SequenceReader`1.Consumed" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Sequence">
      <MemberSignature Language="C#" Value="public System.Buffers.ReadOnlySequence&lt;T&gt; Sequence { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Buffers.ReadOnlySequence`1&lt;!T&gt; Sequence" />
      <MemberSignature Language="DocId" Value="P:System.Buffers.SequenceReader`1.Sequence" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Sequence As ReadOnlySequence(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Buffers::ReadOnlySequence&lt;T&gt; Sequence { System::Buffers::ReadOnlySequence&lt;T&gt; get(); };" />
      <MemberSignature Language="F#" Value="member this.Sequence : System.Buffers.ReadOnlySequence&lt;'T (requires 'T : struct)&gt;" Usage="System.Buffers.SequenceReader&lt;'T (requires 'T : struct)&gt;.Sequence" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-3.0;netcore-3.1;netstandard-2.1">
          <AttributeName Language="C#">[get: System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Buffers.ReadOnlySequence&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="32529-154">获取读取器的基础 <see cref="T:System.Buffers.ReadOnlySequence`1" />。</span><span class="sxs-lookup"><span data-stu-id="32529-154">Gets the underlying <see cref="T:System.Buffers.ReadOnlySequence`1" /> for the reader.</span></span></summary>
        <value><span data-ttu-id="32529-155">读取器的基础只读序列。</span><span class="sxs-lookup"><span data-stu-id="32529-155">The underlying read-only sequence for the reader.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryAdvanceTo">
      <MemberSignature Language="C#" Value="public bool TryAdvanceTo (T delimiter, bool advancePastDelimiter = true);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryAdvanceTo(!T delimiter, bool advancePastDelimiter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.SequenceReader`1.TryAdvanceTo(`0,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryAdvanceTo (delimiter As T, Optional advancePastDelimiter As Boolean = true) As Boolean" />
      <MemberSignature Language="F#" Value="member this.TryAdvanceTo : 'T * bool -&gt; bool" Usage="sequenceReader.TryAdvanceTo (delimiter, advancePastDelimiter)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delimiter" Type="T" />
        <Parameter Name="advancePastDelimiter" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="delimiter"><span data-ttu-id="32529-156">要搜索的分隔符。</span><span class="sxs-lookup"><span data-stu-id="32529-156">The delimiter to search for.</span></span></param>
        <param name="advancePastDelimiter"><span data-ttu-id="32529-157">若要越过 <paramref name="delimiter" />（如果已发现），则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="32529-157"><see langword="true" /> to move past the <paramref name="delimiter" /> if it is found; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="32529-158">搜索指定的分隔符，并在找到该分隔符后向前越过它（可选）。</span><span class="sxs-lookup"><span data-stu-id="32529-158">Searches for a specified delimiter and optionally advances past it if it is found.</span></span></summary>
        <returns><span data-ttu-id="32529-159">如果发现了给定 <paramref name="delimiter" />，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="32529-159"><see langword="true" /> if the given <paramref name="delimiter" /> was found; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryAdvanceToAny">
      <MemberSignature Language="C#" Value="public bool TryAdvanceToAny (ReadOnlySpan&lt;T&gt; delimiters, bool advancePastDelimiter = true);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryAdvanceToAny(valuetype System.ReadOnlySpan`1&lt;!T&gt; delimiters, bool advancePastDelimiter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.SequenceReader`1.TryAdvanceToAny(System.ReadOnlySpan{`0},System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryAdvanceToAny (delimiters As ReadOnlySpan(Of T), Optional advancePastDelimiter As Boolean = true) As Boolean" />
      <MemberSignature Language="F#" Value="member this.TryAdvanceToAny : ReadOnlySpan&lt;'T (requires 'T : struct)&gt; * bool -&gt; bool" Usage="sequenceReader.TryAdvanceToAny (delimiters, advancePastDelimiter)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delimiters" Type="System.ReadOnlySpan&lt;T&gt;" />
        <Parameter Name="advancePastDelimiter" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="delimiters"><span data-ttu-id="32529-160">要搜索的分隔符。</span><span class="sxs-lookup"><span data-stu-id="32529-160">The delimiters to search for.</span></span></param>
        <param name="advancePastDelimiter"><span data-ttu-id="32529-161">若要跳过具有任意给定 <paramref name="delimiters" /> 的第一个实例，则为 <see langword="true" />；若不跳过分隔符，则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="32529-161"><see langword="true" /> to move past the first instance of any of the given <paramref name="delimiters" />; <see langword="false" /> to not move past the delimiter.</span></span></param>
        <summary><span data-ttu-id="32529-162">搜索大量指定分隔符中的任意分隔符，并向前越过找到的第一个分隔符（可选）。</span><span class="sxs-lookup"><span data-stu-id="32529-162">Searches for any of a number of specified delimiters and optionally advances past the first one to be found.</span></span></summary>
        <returns><span data-ttu-id="32529-163">如果发现了任意给定 <paramref name="delimiters" />，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="32529-163"><see langword="true" /> if any of the given <paramref name="delimiters" /> was found; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryCopyTo">
      <MemberSignature Language="C#" Value="public bool TryCopyTo (Span&lt;T&gt; destination);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryCopyTo(valuetype System.Span`1&lt;!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.SequenceReader`1.TryCopyTo(System.Span{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function TryCopyTo (destination As Span(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryCopyTo(Span&lt;T&gt; destination);" />
      <MemberSignature Language="F#" Value="member this.TryCopyTo : Span&lt;'T (requires 'T : struct)&gt; -&gt; bool" Usage="sequenceReader.TryCopyTo destination" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-3.0;netcore-3.1;netstandard-2.1">
          <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="destination"><span data-ttu-id="32529-164">要复制到的目标范围。</span><span class="sxs-lookup"><span data-stu-id="32529-164">Destination span to copy to.</span></span></param>
        <summary><span data-ttu-id="32529-165">如果有足够的数据来填充目标范围，则将当前位置的数据复制到目标范围。</span><span class="sxs-lookup"><span data-stu-id="32529-165">Copies data from the current position to the given destination span if there is enough data to fill it.</span></span></summary>
        <returns><span data-ttu-id="32529-166">如果有足够的数据来完全填充 <paramref name="destination" /> 范围，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="32529-166"><see langword="true" /> if there is enough data to completely fill the <paramref name="destination" /> span; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="32529-167">如果可能，此方法会将固定量的数据输出到序列中。</span><span class="sxs-lookup"><span data-stu-id="32529-167">This method copies a fixed amount of data out of the sequence if possible.</span></span> <span data-ttu-id="32529-168">它不会推进读者。</span><span class="sxs-lookup"><span data-stu-id="32529-168">It does not advance the reader.</span></span> <span data-ttu-id="32529-169">若要预先查找特定的数据流，请使用  <xref:System.Buffers.SequenceReader`1.IsNext(System.ReadOnlySpan{`0},System.Boolean)> 。</span><span class="sxs-lookup"><span data-stu-id="32529-169">To look ahead for a specific stream of data, use  <xref:System.Buffers.SequenceReader`1.IsNext(System.ReadOnlySpan{`0},System.Boolean)>.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryPeek">
      <MemberSignature Language="C#" Value="public bool TryPeek (out T value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryPeek([out] !T&amp; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.SequenceReader`1.TryPeek(`0@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryPeek (ByRef value As T) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryPeek([Runtime::InteropServices::Out] T % value);" />
      <MemberSignature Language="F#" Value="member this.TryPeek : 'T -&gt; bool" Usage="sequenceReader.TryPeek value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-3.0;netcore-3.1;netstandard-2.1">
          <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="T" RefType="out" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="32529-170">下一个值，或默认值（如果在读取器末尾）。</span><span class="sxs-lookup"><span data-stu-id="32529-170">The next value, or the default value if at the end of the reader.</span></span></param>
        <summary><span data-ttu-id="32529-171">查看下一个值，而不前移读取器。</span><span class="sxs-lookup"><span data-stu-id="32529-171">Peeks at the next value without advancing the reader.</span></span></summary>
        <returns><span data-ttu-id="32529-172">如果读取器未在其末尾且查看操作成功，则为 <see langword="true" />；如果在读取器末尾，则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="32529-172"><see langword="true" /> if the reader is not at its end and the peek operation succeeded; <see langword="false" /> if at the end of the reader.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryPeek">
      <MemberSignature Language="C#" Value="public bool TryPeek (long offset, out T value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryPeek(int64 offset, [out] !T&amp; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.SequenceReader`1.TryPeek(System.Int64,`0@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryPeek (offset As Long, ByRef value As T) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryPeek(long offset, [Runtime::InteropServices::Out] T % value);" />
      <MemberSignature Language="F#" Value="member this.TryPeek : int64 * 'T -&gt; bool" Usage="sequenceReader.TryPeek (offset, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="offset" Type="System.Int64" Index="0" FrameworkAlternate="net-5.0" />
        <Parameter Name="value" Type="T" RefType="out" Index="1" FrameworkAlternate="net-5.0" />
      </Parameters>
      <Docs>
        <param name="offset"><span data-ttu-id="32529-173">当前位置的偏移量。</span><span class="sxs-lookup"><span data-stu-id="32529-173">The offset from current position.</span></span></param>
        <param name="value"><span data-ttu-id="32529-174">下一个值，或默认值（如果在读取器末尾）。</span><span class="sxs-lookup"><span data-stu-id="32529-174">The next value, or the default value if at the end of the reader.</span></span></param>
        <summary><span data-ttu-id="32529-175">查看指定偏移量处的下一个值，而不前移读取器。</span><span class="sxs-lookup"><span data-stu-id="32529-175">Peeks at the next value at the specified offset without advancing the reader.</span></span></summary>
        <returns><span data-ttu-id="32529-176">如果读取器未在其末尾且查看操作成功，则为 <see langword="true" />；如果在读取器末尾，则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="32529-176"><see langword="true" /> if the reader is not at its end and the peek operation succeeded; <see langword="false" /> if at the end of the reader.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryRead">
      <MemberSignature Language="C#" Value="public bool TryRead (out T value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryRead([out] !T&amp; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.SequenceReader`1.TryRead(`0@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryRead (ByRef value As T) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryRead([Runtime::InteropServices::Out] T % value);" />
      <MemberSignature Language="F#" Value="member this.TryRead : 'T -&gt; bool" Usage="sequenceReader.TryRead value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="T" RefType="out" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="32529-177">下一个值，或默认值（如果在读取器末尾）。</span><span class="sxs-lookup"><span data-stu-id="32529-177">The next value, or the default value if at the end of the reader.</span></span></param>
        <summary><span data-ttu-id="32529-178">读取下一个值，并前移读取器。</span><span class="sxs-lookup"><span data-stu-id="32529-178">Reads the next value and advance the reader.</span></span></summary>
        <returns><span data-ttu-id="32529-179">如果读取器未在其末尾且读取操作成功，则为 <see langword="true" />；如果在读取器末尾，则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="32529-179"><see langword="true" /> if the reader is not at its end and the read operation succeeded; <see langword="false" /> if at the end of the reader.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryReadTo">
      <MemberSignature Language="C#" Value="public bool TryReadTo (out System.Buffers.ReadOnlySequence&lt;T&gt; sequence, ReadOnlySpan&lt;T&gt; delimiter, bool advancePastDelimiter = true);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryReadTo([out] valuetype System.Buffers.ReadOnlySequence`1&lt;!T&gt;&amp; sequence, valuetype System.ReadOnlySpan`1&lt;!T&gt; delimiter, bool advancePastDelimiter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.SequenceReader`1.TryReadTo(System.Buffers.ReadOnlySequence{`0}@,System.ReadOnlySpan{`0},System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryReadTo (ByRef sequence As ReadOnlySequence(Of T), delimiter As ReadOnlySpan(Of T), Optional advancePastDelimiter As Boolean = true) As Boolean" />
      <MemberSignature Language="F#" Value="member this.TryReadTo : ReadOnlySequence * ReadOnlySpan&lt;'T (requires 'T : struct)&gt; * bool -&gt; bool" Usage="sequenceReader.TryReadTo (sequence, delimiter, advancePastDelimiter)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sequence" Type="System.Buffers.ReadOnlySequence&lt;T&gt;" RefType="out" />
        <Parameter Name="delimiter" Type="System.ReadOnlySpan&lt;T&gt;" />
        <Parameter Name="advancePastDelimiter" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="sequence"><span data-ttu-id="32529-180">当方法返回时，包含读取的数据（如果有）。</span><span class="sxs-lookup"><span data-stu-id="32529-180">When the method returns, contains the data read, if any.</span></span></param>
        <param name="delimiter"><span data-ttu-id="32529-181">一个只读范围，包含一个或多个分隔符。</span><span class="sxs-lookup"><span data-stu-id="32529-181">A read-only span that contains one or more delimiters.</span></span></param>
        <param name="advancePastDelimiter"><span data-ttu-id="32529-182">若要跳过 <paramref name="delimiter" />（如果已发现），则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="32529-182"><see langword="true" /> to move past the <paramref name="delimiter" /> if found; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="32529-183">尝试读取数据，直到指定为只读范围的整个分隔符匹配。</span><span class="sxs-lookup"><span data-stu-id="32529-183">Tries to read data until the entire delimiter specified as a read-only span matches.</span></span></summary>
        <returns><span data-ttu-id="32529-184">如果发现了 <paramref name="delimiter" />，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="32529-184"><see langword="true" /> if the <paramref name="delimiter" /> was found; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryReadTo">
      <MemberSignature Language="C#" Value="public bool TryReadTo (out System.Buffers.ReadOnlySequence&lt;T&gt; sequence, T delimiter, bool advancePastDelimiter = true);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryReadTo([out] valuetype System.Buffers.ReadOnlySequence`1&lt;!T&gt;&amp; sequence, !T delimiter, bool advancePastDelimiter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.SequenceReader`1.TryReadTo(System.Buffers.ReadOnlySequence{`0}@,`0,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryReadTo (ByRef sequence As ReadOnlySequence(Of T), delimiter As T, Optional advancePastDelimiter As Boolean = true) As Boolean" />
      <MemberSignature Language="F#" Value="member this.TryReadTo : ReadOnlySequence * 'T * bool -&gt; bool" Usage="sequenceReader.TryReadTo (sequence, delimiter, advancePastDelimiter)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sequence" Type="System.Buffers.ReadOnlySequence&lt;T&gt;" RefType="out" />
        <Parameter Name="delimiter" Type="T" />
        <Parameter Name="advancePastDelimiter" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="sequence"><span data-ttu-id="32529-185">当方法返回时，包含读取的数据（如果有）。</span><span class="sxs-lookup"><span data-stu-id="32529-185">When the method returns, contains the data read, if any.</span></span></param>
        <param name="delimiter"><span data-ttu-id="32529-186">要查找的分隔符。</span><span class="sxs-lookup"><span data-stu-id="32529-186">The delimiter to look for.</span></span></param>
        <param name="advancePastDelimiter"><span data-ttu-id="32529-187">若要跳过 <paramref name="delimiter" />（如果已发现），则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="32529-187"><see langword="true" /> to move past the <paramref name="delimiter" /> if found; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="32529-188">尝试读取给定 <paramref name="delimiter" /> 之前的所有内容。</span><span class="sxs-lookup"><span data-stu-id="32529-188">Tries to read everything up to the given <paramref name="delimiter" />.</span></span></summary>
        <returns><span data-ttu-id="32529-189">如果发现了 <paramref name="delimiter" />，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="32529-189"><see langword="true" /> if the <paramref name="delimiter" /> was found; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryReadTo">
      <MemberSignature Language="C#" Value="public bool TryReadTo (out ReadOnlySpan&lt;T&gt; sequence, ReadOnlySpan&lt;T&gt; delimiter, bool advancePastDelimiter = true);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryReadTo([out] valuetype System.ReadOnlySpan`1&lt;!T&gt;&amp; sequence, valuetype System.ReadOnlySpan`1&lt;!T&gt; delimiter, bool advancePastDelimiter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.SequenceReader`1.TryReadTo(System.ReadOnlySpan{`0}@,System.ReadOnlySpan{`0},System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryReadTo (ByRef sequence As ReadOnlySpan(Of T), delimiter As ReadOnlySpan(Of T), Optional advancePastDelimiter As Boolean = true) As Boolean" />
      <MemberSignature Language="F#" Value="member this.TryReadTo : ReadOnlySpan * ReadOnlySpan&lt;'T (requires 'T : struct)&gt; * bool -&gt; bool" Usage="sequenceReader.TryReadTo (sequence, delimiter, advancePastDelimiter)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sequence" Type="System.ReadOnlySpan&lt;T&gt;" RefType="out" Index="0" FrameworkAlternate="net-5.0" />
        <Parameter Name="delimiter" Type="System.ReadOnlySpan&lt;T&gt;" Index="1" FrameworkAlternate="net-5.0" />
        <Parameter Name="advancePastDelimiter" Type="System.Boolean" Index="2" FrameworkAlternate="net-5.0" />
      </Parameters>
      <Docs>
        <param name="sequence">To be added.</param>
        <param name="delimiter">To be added.</param>
        <param name="advancePastDelimiter">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryReadTo">
      <MemberSignature Language="C#" Value="public bool TryReadTo (out ReadOnlySpan&lt;T&gt; span, T delimiter, bool advancePastDelimiter = true);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryReadTo([out] valuetype System.ReadOnlySpan`1&lt;!T&gt;&amp; span, !T delimiter, bool advancePastDelimiter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.SequenceReader`1.TryReadTo(System.ReadOnlySpan{`0}@,`0,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryReadTo (ByRef span As ReadOnlySpan(Of T), delimiter As T, Optional advancePastDelimiter As Boolean = true) As Boolean" />
      <MemberSignature Language="F#" Value="member this.TryReadTo : ReadOnlySpan * 'T * bool -&gt; bool" Usage="sequenceReader.TryReadTo (span, delimiter, advancePastDelimiter)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="span" Type="System.ReadOnlySpan&lt;T&gt;" RefType="out" />
        <Parameter Name="delimiter" Type="T" />
        <Parameter Name="advancePastDelimiter" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="span"><span data-ttu-id="32529-190">当方法返回时，包含读取的数据（如果有）。</span><span class="sxs-lookup"><span data-stu-id="32529-190">When the method returns, contains the data read, if any.</span></span></param>
        <param name="delimiter"><span data-ttu-id="32529-191">要查找的分隔符。</span><span class="sxs-lookup"><span data-stu-id="32529-191">The delimiter to look for.</span></span></param>
        <param name="advancePastDelimiter"><span data-ttu-id="32529-192">若要跳过 <paramref name="delimiter" />（如果已发现），则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="32529-192"><see langword="true" /> to move past the <paramref name="delimiter" /> if found; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="32529-193">尝试读取给定 <paramref name="delimiter" /> 之前的所有内容。</span><span class="sxs-lookup"><span data-stu-id="32529-193">Tries to read everything up to the given <paramref name="delimiter" />.</span></span></summary>
        <returns><span data-ttu-id="32529-194">如果发现了 <paramref name="delimiter" />，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="32529-194"><see langword="true" /> if the <paramref name="delimiter" /> was found; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryReadTo">
      <MemberSignature Language="C#" Value="public bool TryReadTo (out System.Buffers.ReadOnlySequence&lt;T&gt; sequence, T delimiter, T delimiterEscape, bool advancePastDelimiter = true);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryReadTo([out] valuetype System.Buffers.ReadOnlySequence`1&lt;!T&gt;&amp; sequence, !T delimiter, !T delimiterEscape, bool advancePastDelimiter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.SequenceReader`1.TryReadTo(System.Buffers.ReadOnlySequence{`0}@,`0,`0,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryReadTo (ByRef sequence As ReadOnlySequence(Of T), delimiter As T, delimiterEscape As T, Optional advancePastDelimiter As Boolean = true) As Boolean" />
      <MemberSignature Language="F#" Value="member this.TryReadTo : ReadOnlySequence * 'T * 'T * bool -&gt; bool" Usage="sequenceReader.TryReadTo (sequence, delimiter, delimiterEscape, advancePastDelimiter)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sequence" Type="System.Buffers.ReadOnlySequence&lt;T&gt;" RefType="out" />
        <Parameter Name="delimiter" Type="T" />
        <Parameter Name="delimiterEscape" Type="T" />
        <Parameter Name="advancePastDelimiter" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="sequence"><span data-ttu-id="32529-195">当方法返回时，包含读取的数据（如果有）。</span><span class="sxs-lookup"><span data-stu-id="32529-195">When the method returns, contains the data read, if any.</span></span></param>
        <param name="delimiter"><span data-ttu-id="32529-196">要查找的分隔符。</span><span class="sxs-lookup"><span data-stu-id="32529-196">The delimiter to look for.</span></span></param>
        <param name="delimiterEscape"><span data-ttu-id="32529-197">一个值，指示将跳过紧跟 <paramref name="delimiter" /> 之后的项。</span><span class="sxs-lookup"><span data-stu-id="32529-197">A value that indicates that an immediately following <paramref name="delimiter" /> is to be skipped.</span></span></param>
        <param name="advancePastDelimiter"><span data-ttu-id="32529-198">若要跳过 <paramref name="delimiter" />（如果已发现），则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="32529-198"><see langword="true" /> to move past the <paramref name="delimiter" /> if found; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="32529-199">尝试读取给定 <paramref name="delimiter" /> 之前的所有内容，忽略前面为 <paramref name="delimiterEscape" /> 的分隔符。</span><span class="sxs-lookup"><span data-stu-id="32529-199">Tries to read everything up to the given <paramref name="delimiter" />, ignoring delimiters that are preceded by <paramref name="delimiterEscape" />.</span></span></summary>
        <returns><span data-ttu-id="32529-200">如果发现了 <paramref name="delimiter" />，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="32529-200"><see langword="true" /> if the <paramref name="delimiter" /> was found; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryReadTo">
      <MemberSignature Language="C#" Value="public bool TryReadTo (out ReadOnlySpan&lt;T&gt; span, T delimiter, T delimiterEscape, bool advancePastDelimiter = true);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryReadTo([out] valuetype System.ReadOnlySpan`1&lt;!T&gt;&amp; span, !T delimiter, !T delimiterEscape, bool advancePastDelimiter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.SequenceReader`1.TryReadTo(System.ReadOnlySpan{`0}@,`0,`0,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryReadTo (ByRef span As ReadOnlySpan(Of T), delimiter As T, delimiterEscape As T, Optional advancePastDelimiter As Boolean = true) As Boolean" />
      <MemberSignature Language="F#" Value="member this.TryReadTo : ReadOnlySpan * 'T * 'T * bool -&gt; bool" Usage="sequenceReader.TryReadTo (span, delimiter, delimiterEscape, advancePastDelimiter)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="span" Type="System.ReadOnlySpan&lt;T&gt;" RefType="out" />
        <Parameter Name="delimiter" Type="T" />
        <Parameter Name="delimiterEscape" Type="T" />
        <Parameter Name="advancePastDelimiter" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="span"><span data-ttu-id="32529-201">当方法返回时，包含读取的数据（如果有）。</span><span class="sxs-lookup"><span data-stu-id="32529-201">When the method returns, contains the data read, if any.</span></span></param>
        <param name="delimiter"><span data-ttu-id="32529-202">要查找的分隔符。</span><span class="sxs-lookup"><span data-stu-id="32529-202">The delimiter to look for.</span></span></param>
        <param name="delimiterEscape"><span data-ttu-id="32529-203">一个值，指示将跳过紧跟 <paramref name="delimiter" /> 之后的项。</span><span class="sxs-lookup"><span data-stu-id="32529-203">A value that indicates that an immediately following <paramref name="delimiter" /> is to be skipped.</span></span></param>
        <param name="advancePastDelimiter"><span data-ttu-id="32529-204">若要跳过 <paramref name="delimiter" />（如果已发现），则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="32529-204"><see langword="true" /> to move past the <paramref name="delimiter" /> if found; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="32529-205">尝试读取给定 <paramref name="delimiter" /> 之前的所有内容，忽略前面为 <paramref name="delimiterEscape" /> 的分隔符。</span><span class="sxs-lookup"><span data-stu-id="32529-205">Tries to read everything up to the given <paramref name="delimiter" />, ignoring delimiters that are preceded by <paramref name="delimiterEscape" />.</span></span></summary>
        <returns><span data-ttu-id="32529-206">如果发现了 <paramref name="delimiter" />，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="32529-206"><see langword="true" /> if the <paramref name="delimiter" /> was found; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryReadToAny">
      <MemberSignature Language="C#" Value="public bool TryReadToAny (out System.Buffers.ReadOnlySequence&lt;T&gt; sequence, ReadOnlySpan&lt;T&gt; delimiters, bool advancePastDelimiter = true);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryReadToAny([out] valuetype System.Buffers.ReadOnlySequence`1&lt;!T&gt;&amp; sequence, valuetype System.ReadOnlySpan`1&lt;!T&gt; delimiters, bool advancePastDelimiter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.SequenceReader`1.TryReadToAny(System.Buffers.ReadOnlySequence{`0}@,System.ReadOnlySpan{`0},System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryReadToAny (ByRef sequence As ReadOnlySequence(Of T), delimiters As ReadOnlySpan(Of T), Optional advancePastDelimiter As Boolean = true) As Boolean" />
      <MemberSignature Language="F#" Value="member this.TryReadToAny : ReadOnlySequence * ReadOnlySpan&lt;'T (requires 'T : struct)&gt; * bool -&gt; bool" Usage="sequenceReader.TryReadToAny (sequence, delimiters, advancePastDelimiter)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sequence" Type="System.Buffers.ReadOnlySequence&lt;T&gt;" RefType="out" />
        <Parameter Name="delimiters" Type="System.ReadOnlySpan&lt;T&gt;" />
        <Parameter Name="advancePastDelimiter" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="sequence"><span data-ttu-id="32529-207">当方法返回时，包含读取的数据（如果有）。</span><span class="sxs-lookup"><span data-stu-id="32529-207">When the method returns, contains the data read, if any.</span></span></param>
        <param name="delimiters"><span data-ttu-id="32529-208">要查找的分隔符。</span><span class="sxs-lookup"><span data-stu-id="32529-208">The delimiters to look for.</span></span></param>
        <param name="advancePastDelimiter"><span data-ttu-id="32529-209">若要跳过找到的第一个具有给定 <paramref name="delimiters" /> 的实例，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="32529-209"><see langword="true" /> to move past the first found instance of any of the given <paramref name="delimiters" />; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="32529-210">尝试读取指定的任意 <paramref name="delimiters" /> 之前的所有内容。</span><span class="sxs-lookup"><span data-stu-id="32529-210">Tries to read everything up to any of the specified <paramref name="delimiters" />.</span></span></summary>
        <returns><span data-ttu-id="32529-211">如果发现任何 <see langword="false" />，则为 <see langword="true" />；否则为 <paramref name="delimiters" />。</span><span class="sxs-lookup"><span data-stu-id="32529-211"><see langword="true" /> if any of the <paramref name="delimiters" /> were found; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryReadToAny">
      <MemberSignature Language="C#" Value="public bool TryReadToAny (out ReadOnlySpan&lt;T&gt; span, ReadOnlySpan&lt;T&gt; delimiters, bool advancePastDelimiter = true);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryReadToAny([out] valuetype System.ReadOnlySpan`1&lt;!T&gt;&amp; span, valuetype System.ReadOnlySpan`1&lt;!T&gt; delimiters, bool advancePastDelimiter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.SequenceReader`1.TryReadToAny(System.ReadOnlySpan{`0}@,System.ReadOnlySpan{`0},System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryReadToAny (ByRef span As ReadOnlySpan(Of T), delimiters As ReadOnlySpan(Of T), Optional advancePastDelimiter As Boolean = true) As Boolean" />
      <MemberSignature Language="F#" Value="member this.TryReadToAny : ReadOnlySpan * ReadOnlySpan&lt;'T (requires 'T : struct)&gt; * bool -&gt; bool" Usage="sequenceReader.TryReadToAny (span, delimiters, advancePastDelimiter)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="span" Type="System.ReadOnlySpan&lt;T&gt;" RefType="out" />
        <Parameter Name="delimiters" Type="System.ReadOnlySpan&lt;T&gt;" />
        <Parameter Name="advancePastDelimiter" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="span"><span data-ttu-id="32529-212">当方法返回时，包含读取的数据（如果有）。</span><span class="sxs-lookup"><span data-stu-id="32529-212">When the method returns, contains the data read, if any.</span></span></param>
        <param name="delimiters"><span data-ttu-id="32529-213">要查找的分隔符。</span><span class="sxs-lookup"><span data-stu-id="32529-213">The delimiters to look for.</span></span></param>
        <param name="advancePastDelimiter"><span data-ttu-id="32529-214">若要跳过找到的第一个具有给定 <paramref name="delimiters" /> 的实例，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="32529-214"><see langword="true" /> to move past the first found instance of any of the given <paramref name="delimiters" />; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="32529-215">尝试读取指定的任意 <paramref name="delimiters" /> 之前的所有内容。</span><span class="sxs-lookup"><span data-stu-id="32529-215">Tries to read everything up to any of the specified <paramref name="delimiters" />.</span></span></summary>
        <returns><span data-ttu-id="32529-216">如果发现任何 <see langword="false" />，则为 <see langword="true" />；否则为 <paramref name="delimiters" />。</span><span class="sxs-lookup"><span data-stu-id="32529-216"><see langword="true" /> if any of the <paramref name="delimiters" /> were found; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UnreadSequence">
      <MemberSignature Language="C#" Value="public System.Buffers.ReadOnlySequence&lt;T&gt; UnreadSequence { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Buffers.ReadOnlySequence`1&lt;!T&gt; UnreadSequence" />
      <MemberSignature Language="DocId" Value="P:System.Buffers.SequenceReader`1.UnreadSequence" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property UnreadSequence As ReadOnlySequence(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Buffers::ReadOnlySequence&lt;T&gt; UnreadSequence { System::Buffers::ReadOnlySequence&lt;T&gt; get(); };" />
      <MemberSignature Language="F#" Value="member this.UnreadSequence : System.Buffers.ReadOnlySequence&lt;'T (requires 'T : struct)&gt;" Usage="System.Buffers.SequenceReader&lt;'T (requires 'T : struct)&gt;.UnreadSequence" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Buffers.ReadOnlySequence&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="32529-217">获取 <see cref="P:System.Buffers.SequenceReader`1.Sequence" /> 的未读取部分。</span><span class="sxs-lookup"><span data-stu-id="32529-217">Gets the unread portion of the <see cref="P:System.Buffers.SequenceReader`1.Sequence" />.</span></span></summary>
        <value><span data-ttu-id="32529-218">的未读部分 <see cref="P:System.Buffers.SequenceReader`1.Sequence" /> 。</span><span class="sxs-lookup"><span data-stu-id="32529-218">The unread portion of the <see cref="P:System.Buffers.SequenceReader`1.Sequence" />.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UnreadSpan">
      <MemberSignature Language="C#" Value="public ReadOnlySpan&lt;T&gt; UnreadSpan { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.ReadOnlySpan`1&lt;!T&gt; UnreadSpan" />
      <MemberSignature Language="DocId" Value="P:System.Buffers.SequenceReader`1.UnreadSpan" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property UnreadSpan As ReadOnlySpan(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property ReadOnlySpan&lt;T&gt; UnreadSpan { ReadOnlySpan&lt;T&gt; get(); };" />
      <MemberSignature Language="F#" Value="member this.UnreadSpan : ReadOnlySpan&lt;'T (requires 'T : struct)&gt;" Usage="System.Buffers.SequenceReader&lt;'T (requires 'T : struct)&gt;.UnreadSpan" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-3.0;netcore-3.1;netstandard-2.1">
          <AttributeName Language="C#">[get: System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="32529-219">获取 <see cref="P:System.Buffers.SequenceReader`1.CurrentSpan" /> 的未读取部分。</span><span class="sxs-lookup"><span data-stu-id="32529-219">Gets the unread portion of the <see cref="P:System.Buffers.SequenceReader`1.CurrentSpan" />.</span></span></summary>
        <value><span data-ttu-id="32529-220">的未读部分 <see cref="P:System.Buffers.SequenceReader`1.CurrentSpan" /> 。</span><span class="sxs-lookup"><span data-stu-id="32529-220">The unread portion of the <see cref="P:System.Buffers.SequenceReader`1.CurrentSpan" />.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
