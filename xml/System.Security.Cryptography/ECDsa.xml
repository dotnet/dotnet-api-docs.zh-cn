<Type Name="ECDsa" FullName="System.Security.Cryptography.ECDsa">
  <Metadata><Meta Name="ms.openlocfilehash" Value="53ff4f656cba17ecb9dc914ebbc80bad64799ba0" /><Meta Name="ms.sourcegitcommit" Value="33529b5cc32683b91d3422992fb4dc422f85782b" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-CN" /><Meta Name="ms.lasthandoff" Value="08/17/2020" /><Meta Name="ms.locfileid" Value="88267238" /></Metadata><TypeSignature Language="C#" Value="public abstract class ECDsa : System.Security.Cryptography.AsymmetricAlgorithm" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit ECDsa extends System.Security.Cryptography.AsymmetricAlgorithm" />
  <TypeSignature Language="DocId" Value="T:System.Security.Cryptography.ECDsa" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class ECDsa&#xA;Inherits AsymmetricAlgorithm" />
  <TypeSignature Language="C++ CLI" Value="public ref class ECDsa abstract : System::Security::Cryptography::AsymmetricAlgorithm" />
  <TypeSignature Language="F#" Value="type ECDsa = class&#xA;    inherit AsymmetricAlgorithm" />
  <AssemblyInfo>
    <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.3.0.0</AssemblyVersion>
    <AssemblyVersion>4.3.1.0</AssemblyVersion>
    <AssemblyVersion>4.3.2.0</AssemblyVersion>
    <AssemblyVersion>5.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Core</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>3.5.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeForwardingChain>
    <TypeForwarding From="netstandard" FromVersion="2.1.0.0" To="System.Security.Cryptography.Algorithms" ToVersion="5.0.0.0" FrameworkAlternate="net-5.0" />
  </TypeForwardingChain>
  <Base>
    <BaseTypeName>System.Security.Cryptography.AsymmetricAlgorithm</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary><span data-ttu-id="f2b80-101">提供用于封装椭圆曲线数字签名算法 (ECDSA) 的抽象基类。</span><span class="sxs-lookup"><span data-stu-id="f2b80-101">Provides an abstract base class that encapsulates the Elliptic Curve Digital Signature Algorithm (ECDSA).</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f2b80-102">此类用作派生的抽象基类 <xref:System.Security.Cryptography.ECDsaCng> 。</span><span class="sxs-lookup"><span data-stu-id="f2b80-102">This class serves as the abstract base class for <xref:System.Security.Cryptography.ECDsaCng> derivations.</span></span>  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected ECDsa ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDsa.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; ECDsa();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.3.0.0</AssemblyVersion>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
        <AssemblyVersion>4.3.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="f2b80-103">初始化 <see cref="T:System.Security.Cryptography.ECDsa" /> 类的新实例。</span><span class="sxs-lookup"><span data-stu-id="f2b80-103">Initializes a new instance of the <see cref="T:System.Security.Cryptography.ECDsa" /> class.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f2b80-104">此构造函数由派生自类的类调用 <xref:System.Security.Cryptography.ECDsa> 。</span><span class="sxs-lookup"><span data-stu-id="f2b80-104">This constructor is called by classes that derive from the <xref:System.Security.Cryptography.ECDsa> class.</span></span> <span data-ttu-id="f2b80-105"><xref:System.Security.Cryptography.ECDsaCng>类是当前支持的唯一实现 [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] 。</span><span class="sxs-lookup"><span data-stu-id="f2b80-105">The <xref:System.Security.Cryptography.ECDsaCng> class is the only implementation currently supported by the [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)].</span></span> <span data-ttu-id="f2b80-106">你可以提供自己的自定义实现。</span><span class="sxs-lookup"><span data-stu-id="f2b80-106">You may provide your own custom implementation.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Create">
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.3.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="f2b80-107">创建椭圆曲线数字签名算法 (ECDSA) 的实现的一个新实例。</span><span class="sxs-lookup"><span data-stu-id="f2b80-107">Creates a new instance of an implementation of the Elliptic Curve Digital Signature Algorithm (ECDSA).</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Security.Cryptography.ECDsa Create ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Security.Cryptography.ECDsa Create() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDsa.Create" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create () As ECDsa" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Security::Cryptography::ECDsa ^ Create();" />
      <MemberSignature Language="F#" Value="static member Create : unit -&gt; System.Security.Cryptography.ECDsa" Usage="System.Security.Cryptography.ECDsa.Create " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.3.0.0</AssemblyVersion>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
        <AssemblyVersion>4.3.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.ECDsa</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="f2b80-108">创建椭圆曲线数字签名算法 (ECDSA) 的默认实现的一个新实例。</span><span class="sxs-lookup"><span data-stu-id="f2b80-108">Creates a new instance of the default implementation of the Elliptic Curve Digital Signature Algorithm (ECDSA).</span></span></summary>
        <returns><span data-ttu-id="f2b80-109">此类的默认实现 (<see cref="T:System.Security.Cryptography.ECDsaCng" />) 的新实例。</span><span class="sxs-lookup"><span data-stu-id="f2b80-109">A new instance of the default implementation (<see cref="T:System.Security.Cryptography.ECDsaCng" />) of this class.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Security.Cryptography.ECDsa Create (System.Security.Cryptography.ECCurve curve);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Security.Cryptography.ECDsa Create(valuetype System.Security.Cryptography.ECCurve curve) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDsa.Create(System.Security.Cryptography.ECCurve)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (curve As ECCurve) As ECDsa" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Security::Cryptography::ECDsa ^ Create(System::Security::Cryptography::ECCurve curve);" />
      <MemberSignature Language="F#" Value="static member Create : System.Security.Cryptography.ECCurve -&gt; System.Security.Cryptography.ECDsa" Usage="System.Security.Cryptography.ECDsa.Create curve" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.3.0.0</AssemblyVersion>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
        <AssemblyVersion>4.3.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netstandard-2.0">
          <AttributeName Language="C#">[System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.ECDsa</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="curve" Type="System.Security.Cryptography.ECCurve" Index="0" FrameworkAlternate="net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8" />
      </Parameters>
      <Docs>
        <param name="curve"><span data-ttu-id="f2b80-110">要用于密钥生成的曲线。</span><span class="sxs-lookup"><span data-stu-id="f2b80-110">The curve to use for key generation.</span></span></param>
        <summary><span data-ttu-id="f2b80-111">使用通过指定曲线新生成的密钥，创建椭圆曲线数字签名算法 (ECDSA) 的默认实现的新实例。</span><span class="sxs-lookup"><span data-stu-id="f2b80-111">Creates a new instance of the default implementation of the Elliptic Curve Digital Signature Algorithm (ECDSA) with a newly generated key over the specified curve.</span></span></summary>
        <returns><span data-ttu-id="f2b80-112">此类的默认实现 (<see cref="T:System.Security.Cryptography.ECDsaCng" />) 的新实例。</span><span class="sxs-lookup"><span data-stu-id="f2b80-112">A new instance of the default implementation (<see cref="T:System.Security.Cryptography.ECDsaCng" />) of this class.</span></span></returns>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Security.Cryptography.ECDsa.GenerateKey(System.Security.Cryptography.ECCurve)" />
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Security.Cryptography.ECDsa Create (System.Security.Cryptography.ECParameters parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Security.Cryptography.ECDsa Create(valuetype System.Security.Cryptography.ECParameters parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDsa.Create(System.Security.Cryptography.ECParameters)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (parameters As ECParameters) As ECDsa" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Security::Cryptography::ECDsa ^ Create(System::Security::Cryptography::ECParameters parameters);" />
      <MemberSignature Language="F#" Value="static member Create : System.Security.Cryptography.ECParameters -&gt; System.Security.Cryptography.ECDsa" Usage="System.Security.Cryptography.ECDsa.Create parameters" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.3.0.0</AssemblyVersion>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
        <AssemblyVersion>4.3.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netstandard-2.0">
          <AttributeName Language="C#">[System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.ECDsa</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="parameters" Type="System.Security.Cryptography.ECParameters" Index="0" FrameworkAlternate="net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8" />
      </Parameters>
      <Docs>
        <param name="parameters"><span data-ttu-id="f2b80-113">表示要使用的密钥的参数。</span><span class="sxs-lookup"><span data-stu-id="f2b80-113">The parameters representing the key to use.</span></span></param>
        <summary><span data-ttu-id="f2b80-114">通过将指定参数用作密钥，创建椭圆曲线数字签名算法 (ECDSA) 的默认实现的新实例。</span><span class="sxs-lookup"><span data-stu-id="f2b80-114">Creates a new instance of the default implementation of the Elliptic Curve Digital Signature Algorithm (ECDSA) using the specified parameters as the key.</span></span></summary>
        <returns><span data-ttu-id="f2b80-115">此类的默认实现 (<see cref="T:System.Security.Cryptography.ECDsaCng" />) 的新实例。</span><span class="sxs-lookup"><span data-stu-id="f2b80-115">A new instance of the default implementation (<see cref="T:System.Security.Cryptography.ECDsaCng" />) of this class.</span></span></returns>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Security.Cryptography.ECDsa.ImportParameters(System.Security.Cryptography.ECParameters)" />
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Security.Cryptography.ECDsa? Create (string algorithm);" FrameworkAlternate="net-5.0" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Security.Cryptography.ECDsa Create(string algorithm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDsa.Create(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (algorithm As String) As ECDsa" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Security::Cryptography::ECDsa ^ Create(System::String ^ algorithm);" />
      <MemberSignature Language="F#" Value="static member Create : string -&gt; System.Security.Cryptography.ECDsa" Usage="System.Security.Cryptography.ECDsa.Create algorithm" />
      <MemberSignature Language="C#" Value="public static System.Security.Cryptography.ECDsa Create (string algorithm);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.3.0.0</AssemblyVersion>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
        <AssemblyVersion>4.3.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.ECDsa</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="algorithm" Type="System.String" Index="0" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="algorithm"><span data-ttu-id="f2b80-116">ECDSA 实现的名称。</span><span class="sxs-lookup"><span data-stu-id="f2b80-116">The name of an ECDSA implementation.</span></span> <span data-ttu-id="f2b80-117">以下字符串指的是同一个实现，它是当前 [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] 中支持的唯一实现。</span><span class="sxs-lookup"><span data-stu-id="f2b80-117">The following strings all refer to the same implementation, which is the only implementation currently supported in the [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)]:</span></span> 
<span data-ttu-id="f2b80-118">- "ECDsa"</span><span class="sxs-lookup"><span data-stu-id="f2b80-118">- "ECDsa"</span></span> 
<span data-ttu-id="f2b80-119">- "ECDsaCng"</span><span class="sxs-lookup"><span data-stu-id="f2b80-119">- "ECDsaCng"</span></span> 
<span data-ttu-id="f2b80-120">- "System.Security.Cryptography.ECDsaCng"</span><span class="sxs-lookup"><span data-stu-id="f2b80-120">- "System.Security.Cryptography.ECDsaCng"</span></span> 
<span data-ttu-id="f2b80-121">也可以提供自定义 ECDSA 实现的名称。</span><span class="sxs-lookup"><span data-stu-id="f2b80-121">You can also provide the name of a custom ECDSA implementation.</span></span></param>
        <summary><span data-ttu-id="f2b80-122">创建椭圆曲线数字签名算法 (ECDSA) 的指定实现的一个新实例。</span><span class="sxs-lookup"><span data-stu-id="f2b80-122">Creates a new instance of the specified implementation of the Elliptic Curve Digital Signature Algorithm (ECDSA).</span></span></summary>
        <returns><span data-ttu-id="f2b80-123">此类的指定实现的新实例。</span><span class="sxs-lookup"><span data-stu-id="f2b80-123">A new instance of the specified implementation of this class.</span></span> <span data-ttu-id="f2b80-124">如果指定的算法名称没有映射到 ECDSA 实现，则此方法返回 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="f2b80-124">If the specified algorithm name does not map to an ECDSA implementation, this method returns <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f2b80-125">如果您开发自己的 <xref:System.Security.Cryptography.ECDsa> 对象实现，则可以使用 <xref:System.Security.Cryptography.ECDsa.Create%28System.String%29> 方法重载来创建指定您的实现的自定义 `algorithm` 字符串。</span><span class="sxs-lookup"><span data-stu-id="f2b80-125">If you develop your own implementation of an <xref:System.Security.Cryptography.ECDsa> object, you can use the <xref:System.Security.Cryptography.ECDsa.Create%28System.String%29> method overload to create a custom `algorithm` string that specifies your implementation.</span></span>  
  
 <span data-ttu-id="f2b80-126">如果为参数指定自定义值 `algorithm` ，则 <xref:System.Security.Cryptography.CryptoConfig> 对象将使用它来确定是否可以创建 ECDSA 对象。</span><span class="sxs-lookup"><span data-stu-id="f2b80-126">If you specify a custom value for the `algorithm` parameter, the <xref:System.Security.Cryptography.CryptoConfig> object will use it to determine whether an ECDSA object can be created.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f2b80-127"><paramref name="algorithm" /> 参数为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="f2b80-127">The <paramref name="algorithm" /> parameter is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ExportECPrivateKey">
      <MemberSignature Language="C#" Value="public virtual byte[] ExportECPrivateKey ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance unsigned int8[] ExportECPrivateKey() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDsa.ExportECPrivateKey" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ExportECPrivateKey () As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Byte&gt; ^ ExportECPrivateKey();" />
      <MemberSignature Language="F#" Value="abstract member ExportECPrivateKey : unit -&gt; byte[]&#xA;override this.ExportECPrivateKey : unit -&gt; byte[]" Usage="eCDsa.ExportECPrivateKey " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
        <AssemblyVersion>4.3.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="f2b80-128">以 ECPrivateKey 格式导出当前密钥。</span><span class="sxs-lookup"><span data-stu-id="f2b80-128">Exports the current key in the ECPrivateKey format.</span></span></summary>
        <returns><span data-ttu-id="f2b80-129">一个字节数组，它包含此密钥的 ECPrivateKey 表示形式。</span><span class="sxs-lookup"><span data-stu-id="f2b80-129">A byte array containing the ECPrivateKey representation of this key.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException"><span data-ttu-id="f2b80-130">未能导出密钥。</span><span class="sxs-lookup"><span data-stu-id="f2b80-130">The key could not be exported.</span></span></exception>
        <altmember cref="Overload:System.Security.Cryptography.ECDsa.TryExportECPrivateKey" />
      </Docs>
    </Member>
    <Member MemberName="ExportExplicitParameters">
      <MemberSignature Language="C#" Value="public virtual System.Security.Cryptography.ECParameters ExportExplicitParameters (bool includePrivateParameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Security.Cryptography.ECParameters ExportExplicitParameters(bool includePrivateParameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDsa.ExportExplicitParameters(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ExportExplicitParameters (includePrivateParameters As Boolean) As ECParameters" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Security::Cryptography::ECParameters ExportExplicitParameters(bool includePrivateParameters);" />
      <MemberSignature Language="F#" Value="abstract member ExportExplicitParameters : bool -&gt; System.Security.Cryptography.ECParameters&#xA;override this.ExportExplicitParameters : bool -&gt; System.Security.Cryptography.ECParameters" Usage="eCDsa.ExportExplicitParameters includePrivateParameters" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.3.0.0</AssemblyVersion>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
        <AssemblyVersion>4.3.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netstandard-2.0">
          <AttributeName Language="C#">[System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.ECParameters</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="includePrivateParameters" Type="System.Boolean" Index="0" FrameworkAlternate="net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8" />
      </Parameters>
      <Docs>
        <param name="includePrivateParameters"><span data-ttu-id="f2b80-131">若要包含专用参数，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="f2b80-131"><see langword="true" /> to include private parameters; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="f2b80-132">在派生类中替代时，导出椭圆曲线的显式参数。</span><span class="sxs-lookup"><span data-stu-id="f2b80-132">When overridden in a derived class, exports the explicit parameters for an elliptic curve.</span></span></summary>
        <returns><span data-ttu-id="f2b80-133">表示此项在曲线上的点的参数（使用显式曲线格式）。</span><span class="sxs-lookup"><span data-stu-id="f2b80-133">The parameters representing the point on the curve for this key, using the explicit curve format.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="f2b80-134">派生方法必须重写此方法。</span><span class="sxs-lookup"><span data-stu-id="f2b80-134">A derived class must override this method.</span></span></exception>
        <altmember cref="T:System.Security.Cryptography.ECCurve" />
        <altmember cref="T:System.Security.Cryptography.ECParameters" />
      </Docs>
    </Member>
    <Member MemberName="ExportParameters">
      <MemberSignature Language="C#" Value="public virtual System.Security.Cryptography.ECParameters ExportParameters (bool includePrivateParameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Security.Cryptography.ECParameters ExportParameters(bool includePrivateParameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDsa.ExportParameters(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ExportParameters (includePrivateParameters As Boolean) As ECParameters" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Security::Cryptography::ECParameters ExportParameters(bool includePrivateParameters);" />
      <MemberSignature Language="F#" Value="abstract member ExportParameters : bool -&gt; System.Security.Cryptography.ECParameters&#xA;override this.ExportParameters : bool -&gt; System.Security.Cryptography.ECParameters" Usage="eCDsa.ExportParameters includePrivateParameters" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.3.0.0</AssemblyVersion>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
        <AssemblyVersion>4.3.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netstandard-2.0">
          <AttributeName Language="C#">[System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.ECParameters</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="includePrivateParameters" Type="System.Boolean" Index="0" FrameworkAlternate="net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8" />
      </Parameters>
      <Docs>
        <param name="includePrivateParameters"><span data-ttu-id="f2b80-135">若要包含专用参数，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="f2b80-135"><see langword="true" /> to include private parameters; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="f2b80-136">在派生类中替代时，导出椭圆曲线的已命名或显式参数。</span><span class="sxs-lookup"><span data-stu-id="f2b80-136">When overridden in a derived class, exports the named or explicit parameters for an elliptic curve.</span></span> <span data-ttu-id="f2b80-137">如果曲线具有一个名称，则 <see cref="F:System.Security.Cryptography.ECParameters.Curve" /> 字段包含已命名的曲线参数，否则将包含显式参数。</span><span class="sxs-lookup"><span data-stu-id="f2b80-137">If the curve has a name, the <see cref="F:System.Security.Cryptography.ECParameters.Curve" /> field contains named curve parameters, otherwise it         contains explicit parameters.</span></span></summary>
        <returns><span data-ttu-id="f2b80-138">表示此项在曲线上的点的参数。</span><span class="sxs-lookup"><span data-stu-id="f2b80-138">The parameters representing the point on the curve for this key.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="f2b80-139">派生方法必须重写此方法。</span><span class="sxs-lookup"><span data-stu-id="f2b80-139">A derived class must override this method.</span></span></exception>
        <altmember cref="T:System.Security.Cryptography.ECCurve" />
        <altmember cref="T:System.Security.Cryptography.ECParameters" />
        <altmember cref="F:System.Security.Cryptography.ECParameters.Curve" />
      </Docs>
    </Member>
    <Member MemberName="FromXmlString">
      <MemberSignature Language="C#" Value="public override void FromXmlString (string xmlString);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void FromXmlString(string xmlString) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDsa.FromXmlString(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub FromXmlString (xmlString As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void FromXmlString(System::String ^ xmlString);" />
      <MemberSignature Language="F#" Value="override this.FromXmlString : string -&gt; unit" Usage="eCDsa.FromXmlString xmlString" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.3.0.0</AssemblyVersion>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
        <AssemblyVersion>4.3.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="xmlString" Type="System.String" Index="0" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="xmlString"><span data-ttu-id="f2b80-140">用于重新构造 <see cref="T:System.Security.Cryptography.AsymmetricAlgorithm" /> 对象的 XML 字符串。</span><span class="sxs-lookup"><span data-stu-id="f2b80-140">The XML string to use to reconstruct the <see cref="T:System.Security.Cryptography.AsymmetricAlgorithm" /> object.</span></span></param>
        <summary><span data-ttu-id="f2b80-141">在所有情况下均引发此方法。</span><span class="sxs-lookup"><span data-stu-id="f2b80-141">This method throws in all cases.</span></span></summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotImplementedException"><span data-ttu-id="f2b80-142">在所有情况下。</span><span class="sxs-lookup"><span data-stu-id="f2b80-142">In all cases.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GenerateKey">
      <MemberSignature Language="C#" Value="public virtual void GenerateKey (System.Security.Cryptography.ECCurve curve);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GenerateKey(valuetype System.Security.Cryptography.ECCurve curve) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDsa.GenerateKey(System.Security.Cryptography.ECCurve)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub GenerateKey (curve As ECCurve)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void GenerateKey(System::Security::Cryptography::ECCurve curve);" />
      <MemberSignature Language="F#" Value="abstract member GenerateKey : System.Security.Cryptography.ECCurve -&gt; unit&#xA;override this.GenerateKey : System.Security.Cryptography.ECCurve -&gt; unit" Usage="eCDsa.GenerateKey curve" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.3.0.0</AssemblyVersion>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
        <AssemblyVersion>4.3.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netstandard-2.0">
          <AttributeName Language="C#">[System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="curve" Type="System.Security.Cryptography.ECCurve" Index="0" FrameworkAlternate="net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8" />
      </Parameters>
      <Docs>
        <param name="curve"><span data-ttu-id="f2b80-143">用于生成密钥的曲线。</span><span class="sxs-lookup"><span data-stu-id="f2b80-143">The curve to use to generate the key.</span></span></param>
        <summary><span data-ttu-id="f2b80-144">在派生类中替换时，为指定曲线生成新的临时公钥/私钥对，替换当前密钥。</span><span class="sxs-lookup"><span data-stu-id="f2b80-144">When overridden in a derived class, generates a new ephemeral public/private key pair for the specified curve, replacing the current key.</span></span></summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="f2b80-145">派生方法必须重写此方法。</span><span class="sxs-lookup"><span data-stu-id="f2b80-145">A derived class must override this method.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetMaxSignatureSize">
      <MemberSignature Language="C#" Value="public int GetMaxSignatureSize (System.Security.Cryptography.DSASignatureFormat signatureFormat);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetMaxSignatureSize(valuetype System.Security.Cryptography.DSASignatureFormat signatureFormat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDsa.GetMaxSignatureSize(System.Security.Cryptography.DSASignatureFormat)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMaxSignatureSize (signatureFormat As DSASignatureFormat) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetMaxSignatureSize(System::Security::Cryptography::DSASignatureFormat signatureFormat);" />
      <MemberSignature Language="F#" Value="member this.GetMaxSignatureSize : System.Security.Cryptography.DSASignatureFormat -&gt; int" Usage="eCDsa.GetMaxSignatureSize signatureFormat" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="signatureFormat" Type="System.Security.Cryptography.DSASignatureFormat" Index="0" FrameworkAlternate="net-5.0" />
      </Parameters>
      <Docs>
        <param name="signatureFormat"><span data-ttu-id="f2b80-146">签名的编码格式。</span><span class="sxs-lookup"><span data-stu-id="f2b80-146">The encoding format for a signature.</span></span></param>
        <summary><span data-ttu-id="f2b80-147">获取此密钥按指定格式生成的签名的最大尺寸（以字节为单位）。</span><span class="sxs-lookup"><span data-stu-id="f2b80-147">Gets the largest size, in bytes, for a signature produced by this key in the indicated format.</span></span></summary>
        <returns><span data-ttu-id="f2b80-148">此密钥按指定格式生成的签名的最大尺寸（以字节为单位）。</span><span class="sxs-lookup"><span data-stu-id="f2b80-148">The largest size, in bytes, for a signature produced by this key in the indicated format.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="f2b80-149"><paramref name="signatureFormat" /> 不是已知格式。</span><span class="sxs-lookup"><span data-stu-id="f2b80-149"><paramref name="signatureFormat" /> is not a known format.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="HashData">
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.3.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="f2b80-150">计算二进制数据的哈希值。</span><span class="sxs-lookup"><span data-stu-id="f2b80-150">Computes the hash value of binary data.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="HashData">
      <MemberSignature Language="C#" Value="protected virtual byte[] HashData (System.IO.Stream data, System.Security.Cryptography.HashAlgorithmName hashAlgorithm);" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance unsigned int8[] HashData(class System.IO.Stream data, valuetype System.Security.Cryptography.HashAlgorithmName hashAlgorithm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDsa.HashData(System.IO.Stream,System.Security.Cryptography.HashAlgorithmName)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function HashData (data As Stream, hashAlgorithm As HashAlgorithmName) As Byte()" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual cli::array &lt;System::Byte&gt; ^ HashData(System::IO::Stream ^ data, System::Security::Cryptography::HashAlgorithmName hashAlgorithm);" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member HashData : System.IO.Stream * System.Security.Cryptography.HashAlgorithmName -&gt; byte[]&#xA;override this.HashData : System.IO.Stream * System.Security.Cryptography.HashAlgorithmName -&gt; byte[]" Usage="eCDsa.HashData (data, hashAlgorithm)" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C#" Value="protected abstract byte[] HashData (System.IO.Stream data, System.Security.Cryptography.HashAlgorithmName hashAlgorithm);" FrameworkAlternate="netcore-1.0;netcore-1.1;netstandard-1.4;netstandard-1.6" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function HashData (data As Stream, hashAlgorithm As HashAlgorithmName) As Byte()" FrameworkAlternate="netcore-1.0;netcore-1.1;netstandard-1.4;netstandard-1.6" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract cli::array &lt;System::Byte&gt; ^ HashData(System::IO::Stream ^ data, System::Security::Cryptography::HashAlgorithmName hashAlgorithm);" FrameworkAlternate="netcore-1.0;netcore-1.1;netstandard-1.4;netstandard-1.6" />
      <MemberSignature Language="F#" Value="abstract member HashData : System.IO.Stream * System.Security.Cryptography.HashAlgorithmName -&gt; byte[]" Usage="eCDsa.HashData (data, hashAlgorithm)" FrameworkAlternate="netcore-1.0;netcore-1.1;netstandard-1.4;netstandard-1.6" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.3.0.0</AssemblyVersion>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
        <AssemblyVersion>4.3.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.IO.Stream" Index="0" FrameworkAlternate="net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="hashAlgorithm" Type="System.Security.Cryptography.HashAlgorithmName" Index="1" FrameworkAlternate="net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="data"><span data-ttu-id="f2b80-151">要进行哈希处理的二进制流。</span><span class="sxs-lookup"><span data-stu-id="f2b80-151">The binary stream to hash.</span></span></param>
        <param name="hashAlgorithm"><span data-ttu-id="f2b80-152">要用于对数据进行哈希处理的算法。</span><span class="sxs-lookup"><span data-stu-id="f2b80-152">The algorithm to use to hash the data.</span></span></param>
        <summary><span data-ttu-id="f2b80-153">在派生类中进行重写后，通过使用指定的哈希算法计算指定二进制流的哈希值。</span><span class="sxs-lookup"><span data-stu-id="f2b80-153">When overridden in a derived class, computes the hash value of the specified binary stream by using the specified hashing algorithm.</span></span></summary>
        <returns><span data-ttu-id="f2b80-154">经过哈希处理的数据。</span><span class="sxs-lookup"><span data-stu-id="f2b80-154">The hashed data.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotImplementedException"><span data-ttu-id="f2b80-155">派生方法必须重写此方法。</span><span class="sxs-lookup"><span data-stu-id="f2b80-155">A derived class must override this method.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="HashData">
      <MemberSignature Language="C#" Value="protected virtual byte[] HashData (byte[] data, int offset, int count, System.Security.Cryptography.HashAlgorithmName hashAlgorithm);" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance unsigned int8[] HashData(unsigned int8[] data, int32 offset, int32 count, valuetype System.Security.Cryptography.HashAlgorithmName hashAlgorithm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDsa.HashData(System.Byte[],System.Int32,System.Int32,System.Security.Cryptography.HashAlgorithmName)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function HashData (data As Byte(), offset As Integer, count As Integer, hashAlgorithm As HashAlgorithmName) As Byte()" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual cli::array &lt;System::Byte&gt; ^ HashData(cli::array &lt;System::Byte&gt; ^ data, int offset, int count, System::Security::Cryptography::HashAlgorithmName hashAlgorithm);" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member HashData : byte[] * int * int * System.Security.Cryptography.HashAlgorithmName -&gt; byte[]&#xA;override this.HashData : byte[] * int * int * System.Security.Cryptography.HashAlgorithmName -&gt; byte[]" Usage="eCDsa.HashData (data, offset, count, hashAlgorithm)" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C#" Value="protected abstract byte[] HashData (byte[] data, int offset, int count, System.Security.Cryptography.HashAlgorithmName hashAlgorithm);" FrameworkAlternate="netcore-1.0;netcore-1.1;netstandard-1.4;netstandard-1.6" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function HashData (data As Byte(), offset As Integer, count As Integer, hashAlgorithm As HashAlgorithmName) As Byte()" FrameworkAlternate="netcore-1.0;netcore-1.1;netstandard-1.4;netstandard-1.6" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract cli::array &lt;System::Byte&gt; ^ HashData(cli::array &lt;System::Byte&gt; ^ data, int offset, int count, System::Security::Cryptography::HashAlgorithmName hashAlgorithm);" FrameworkAlternate="netcore-1.0;netcore-1.1;netstandard-1.4;netstandard-1.6" />
      <MemberSignature Language="F#" Value="abstract member HashData : byte[] * int * int * System.Security.Cryptography.HashAlgorithmName -&gt; byte[]" Usage="eCDsa.HashData (data, offset, count, hashAlgorithm)" FrameworkAlternate="netcore-1.0;netcore-1.1;netstandard-1.4;netstandard-1.6" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.3.0.0</AssemblyVersion>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
        <AssemblyVersion>4.3.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Byte[]" Index="0" FrameworkAlternate="net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="hashAlgorithm" Type="System.Security.Cryptography.HashAlgorithmName" Index="3" FrameworkAlternate="net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="data"><span data-ttu-id="f2b80-156">要进行哈希处理的数据。</span><span class="sxs-lookup"><span data-stu-id="f2b80-156">The data to be hashed.</span></span></param>
        <param name="offset"><span data-ttu-id="f2b80-157"><paramref name="data" /> 中要进行哈希处理的第一个字节的索引。</span><span class="sxs-lookup"><span data-stu-id="f2b80-157">The index of the first byte in <paramref name="data" /> to be hashed.</span></span></param>
        <param name="count"><span data-ttu-id="f2b80-158">要进行哈希处理的字节数。</span><span class="sxs-lookup"><span data-stu-id="f2b80-158">The number of bytes to hash.</span></span></param>
        <param name="hashAlgorithm"><span data-ttu-id="f2b80-159">要用于对数据进行哈希处理的算法。</span><span class="sxs-lookup"><span data-stu-id="f2b80-159">The algorithm to use to hash the data.</span></span></param>
        <summary><span data-ttu-id="f2b80-160">在派生类中进行重写后，通过使用指定的哈希算法计算字节数组指定部分的哈希值。</span><span class="sxs-lookup"><span data-stu-id="f2b80-160">When overridden in a derived class, computes the hash value of the specified portion of a byte array by using the specified hashing algorithm.</span></span></summary>
        <returns><span data-ttu-id="f2b80-161">经过哈希处理的数据。</span><span class="sxs-lookup"><span data-stu-id="f2b80-161">The hashed data.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotImplementedException"><span data-ttu-id="f2b80-162">派生方法必须重写此方法。</span><span class="sxs-lookup"><span data-stu-id="f2b80-162">A derived class must override this method.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ImportECPrivateKey">
      <MemberSignature Language="C#" Value="public virtual void ImportECPrivateKey (ReadOnlySpan&lt;byte&gt; source, out int bytesRead);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ImportECPrivateKey(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source, [out] int32&amp; bytesRead) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDsa.ImportECPrivateKey(System.ReadOnlySpan{System.Byte},System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub ImportECPrivateKey (source As ReadOnlySpan(Of Byte), ByRef bytesRead As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ImportECPrivateKey(ReadOnlySpan&lt;System::Byte&gt; source, [Runtime::InteropServices::Out] int % bytesRead);" />
      <MemberSignature Language="F#" Value="abstract member ImportECPrivateKey : ReadOnlySpan&lt;byte&gt; * int -&gt; unit&#xA;override this.ImportECPrivateKey : ReadOnlySpan&lt;byte&gt; * int -&gt; unit" Usage="eCDsa.ImportECPrivateKey (source, bytesRead)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
        <AssemblyVersion>4.3.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="0" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netstandard-2.1" />
        <Parameter Name="bytesRead" Type="System.Int32" RefType="out" Index="1" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="source"><span data-ttu-id="f2b80-163">ASN.1-BER 编码中 ECPrivateKey 结构的字节。</span><span class="sxs-lookup"><span data-stu-id="f2b80-163">The bytes of an ECPrivateKey structure in the ASN.1-BER encoding.</span></span></param>
        <param name="bytesRead"><span data-ttu-id="f2b80-164">此方法返回时，包含一个指示从 <paramref name="source" /> 中读取的字节数的值。</span><span class="sxs-lookup"><span data-stu-id="f2b80-164">When this method returns, contains a value that indicates the number of bytes read from <paramref name="source" />.</span></span> <span data-ttu-id="f2b80-165">该参数未经初始化即被处理。</span><span class="sxs-lookup"><span data-stu-id="f2b80-165">This parameter is treated as uninitialized.</span></span></param>
        <summary><span data-ttu-id="f2b80-166">从 ECPrivateKey 结构中导入公共/私有密钥对，替换此对象的密钥。</span><span class="sxs-lookup"><span data-stu-id="f2b80-166">Imports the public/private keypair from an ECPrivateKey structure, replacing the keys for this object.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f2b80-167">此方法仅支持 ECPrivateKey 的 BER/CER/DER) 编码的二进制 (。</span><span class="sxs-lookup"><span data-stu-id="f2b80-167">This method only supports the binary (BER/CER/DER) encoding of ECPrivateKey.</span></span>
<span data-ttu-id="f2b80-168">如果值采用 Base64 编码或 PEM 文本格式，则调用方必须在调用此方法之前对内容进行 Base64 编码。</span><span class="sxs-lookup"><span data-stu-id="f2b80-168">If the value is Base64-encoded or in the PEM text format, the caller must Base64-decode the contents before calling this method.</span></span>
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException"><span data-ttu-id="f2b80-169"><paramref name="source" /> 的内容不表示 ASN.1-BER 编码的 PKCS#8 ECPrivateKey 结构。</span><span class="sxs-lookup"><span data-stu-id="f2b80-169">The contents of <paramref name="source" /> do not represent an ASN.1-BER-encoded PKCS#8 ECPrivateKey structure.</span></span>

<span data-ttu-id="f2b80-170">- 或 -</span><span class="sxs-lookup"><span data-stu-id="f2b80-170">-or-</span></span>

<span data-ttu-id="f2b80-171">密钥导入失败。</span><span class="sxs-lookup"><span data-stu-id="f2b80-171">The key import failed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ImportEncryptedPkcs8PrivateKey">
      <MemberSignature Language="C#" Value="public override void ImportEncryptedPkcs8PrivateKey (ReadOnlySpan&lt;byte&gt; passwordBytes, ReadOnlySpan&lt;byte&gt; source, out int bytesRead);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void ImportEncryptedPkcs8PrivateKey(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; passwordBytes, valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source, [out] int32&amp; bytesRead) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDsa.ImportEncryptedPkcs8PrivateKey(System.ReadOnlySpan{System.Byte},System.ReadOnlySpan{System.Byte},System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub ImportEncryptedPkcs8PrivateKey (passwordBytes As ReadOnlySpan(Of Byte), source As ReadOnlySpan(Of Byte), ByRef bytesRead As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void ImportEncryptedPkcs8PrivateKey(ReadOnlySpan&lt;System::Byte&gt; passwordBytes, ReadOnlySpan&lt;System::Byte&gt; source, [Runtime::InteropServices::Out] int % bytesRead);" />
      <MemberSignature Language="F#" Value="override this.ImportEncryptedPkcs8PrivateKey : ReadOnlySpan&lt;byte&gt; * ReadOnlySpan&lt;byte&gt; * int -&gt; unit" Usage="eCDsa.ImportEncryptedPkcs8PrivateKey (passwordBytes, source, bytesRead)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
        <AssemblyVersion>4.3.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="passwordBytes" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="0" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="1" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
        <Parameter Name="bytesRead" Type="System.Int32" RefType="out" Index="2" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="passwordBytes"><span data-ttu-id="f2b80-172">解密密钥材料时用作密码的字节。</span><span class="sxs-lookup"><span data-stu-id="f2b80-172">The bytes to use as a password when decrypting the key material.</span></span></param>
        <param name="source"><span data-ttu-id="f2b80-173">ASN.1-BER 编码中 PKCS#8 EncryptedPrivateKeyInfo 结构的字节。</span><span class="sxs-lookup"><span data-stu-id="f2b80-173">The bytes of a PKCS#8 EncryptedPrivateKeyInfo structure in the ASN.1-BER encoding.</span></span></param>
        <param name="bytesRead"><span data-ttu-id="f2b80-174">此方法返回时，包含一个指示从 <paramref name="source" /> 中读取的字节数的值。</span><span class="sxs-lookup"><span data-stu-id="f2b80-174">When this method returns, contains a value that indicates the number of bytes read from <paramref name="source" />.</span></span> <span data-ttu-id="f2b80-175">该参数未经初始化即被处理。</span><span class="sxs-lookup"><span data-stu-id="f2b80-175">This parameter is treated as uninitialized.</span></span></param>
        <summary><span data-ttu-id="f2b80-176">使用基于字节的密码解密之后，从 PKCS#8 EncryptedPrivateKeyInfo 结构中导入公/私钥对，以替换此对象的密钥。</span><span class="sxs-lookup"><span data-stu-id="f2b80-176">Imports the public/private keypair from a PKCS#8 EncryptedPrivateKeyInfo structure after decrypting with a byte-based password, replacing the keys for this object.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f2b80-177">密码字节直接传递到密钥派生函数 (KDF) 由 EncryptedPrivateKeyInfo 内容指示的算法使用。</span><span class="sxs-lookup"><span data-stu-id="f2b80-177">The password bytes are passed directly into the Key Derivation Function (KDF) used by the algorithm indicated by the EncryptedPrivateKeyInfo contents.</span></span>
<span data-ttu-id="f2b80-178">这样，在使用 PBKDF2 处理密码时，与使用 UTF-8 以外的文本编码的其他系统兼容， (基于密码的密钥派生函数 2) 。</span><span class="sxs-lookup"><span data-stu-id="f2b80-178">This enables compatibility with other systems which use a text encoding other than UTF-8 when processing passwords with PBKDF2 (Password-Based Key Derivation Function 2).</span></span>
<span data-ttu-id="f2b80-179">此方法仅支持 EncryptedPrivateKeyInfo 的 BER/CER/DER) 编码的二进制 (。</span><span class="sxs-lookup"><span data-stu-id="f2b80-179">This method only supports the binary (BER/CER/DER) encoding of EncryptedPrivateKeyInfo.</span></span>
<span data-ttu-id="f2b80-180">如果值采用 Base64 编码或 PEM 文本格式，则调用方必须在调用此方法之前对内容进行 Base64 编码。</span><span class="sxs-lookup"><span data-stu-id="f2b80-180">If the value is Base64-encoded or in the PEM text format, the caller must Base64-decode the contents before calling this method.</span></span>
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException"><span data-ttu-id="f2b80-181">密码不正确。</span><span class="sxs-lookup"><span data-stu-id="f2b80-181">The password is incorrect.</span></span>

<span data-ttu-id="f2b80-182">- 或 -</span><span class="sxs-lookup"><span data-stu-id="f2b80-182">-or-</span></span>

<span data-ttu-id="f2b80-183"><paramref name="source" /> 的内容表示要应用的密钥派生功能 (KDF) 是旧的 PKCS#12 KDF，需要基于 <see cref="T:System.Char" /> 的密码。</span><span class="sxs-lookup"><span data-stu-id="f2b80-183">The contents of <paramref name="source" /> indicate the Key Derivation Function (KDF) to apply is the legacy PKCS#12 KDF, which requires <see cref="T:System.Char" />-based passwords.</span></span>

<span data-ttu-id="f2b80-184">- 或 -</span><span class="sxs-lookup"><span data-stu-id="f2b80-184">-or-</span></span>

<span data-ttu-id="f2b80-185"><paramref name="source" /> 的内容不表示 ASN.1-BER 编码的 PKCS#8 EncryptedPrivateKeyInfo 结构。</span><span class="sxs-lookup"><span data-stu-id="f2b80-185">The contents of <paramref name="source" /> do not represent an ASN.1-BER-encoded PKCS#8 EncryptedPrivateKeyInfo structure.</span></span>

<span data-ttu-id="f2b80-186">- 或 -</span><span class="sxs-lookup"><span data-stu-id="f2b80-186">-or-</span></span>

<span data-ttu-id="f2b80-187"><paramref name="source" /> 的内容指示密钥用于此实例表示的算法以外的算法。</span><span class="sxs-lookup"><span data-stu-id="f2b80-187">The contents of <paramref name="source" /> indicate the key is for an algorithm other than the algorithm represented by this instance.</span></span>

<span data-ttu-id="f2b80-188">- 或 -</span><span class="sxs-lookup"><span data-stu-id="f2b80-188">-or-</span></span>

<span data-ttu-id="f2b80-189"><paramref name="source" /> 的内容表示密钥采用的格式不受支持。</span><span class="sxs-lookup"><span data-stu-id="f2b80-189">The contents of <paramref name="source" /> represent the key in a format that is not supported.</span></span>

<span data-ttu-id="f2b80-190">- 或 -</span><span class="sxs-lookup"><span data-stu-id="f2b80-190">-or-</span></span>

<span data-ttu-id="f2b80-191">特定于算法的密钥导入失败。</span><span class="sxs-lookup"><span data-stu-id="f2b80-191">The algorithm-specific key import failed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ImportEncryptedPkcs8PrivateKey">
      <MemberSignature Language="C#" Value="public override void ImportEncryptedPkcs8PrivateKey (ReadOnlySpan&lt;char&gt; password, ReadOnlySpan&lt;byte&gt; source, out int bytesRead);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void ImportEncryptedPkcs8PrivateKey(valuetype System.ReadOnlySpan`1&lt;char&gt; password, valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source, [out] int32&amp; bytesRead) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDsa.ImportEncryptedPkcs8PrivateKey(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Byte},System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub ImportEncryptedPkcs8PrivateKey (password As ReadOnlySpan(Of Char), source As ReadOnlySpan(Of Byte), ByRef bytesRead As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void ImportEncryptedPkcs8PrivateKey(ReadOnlySpan&lt;char&gt; password, ReadOnlySpan&lt;System::Byte&gt; source, [Runtime::InteropServices::Out] int % bytesRead);" />
      <MemberSignature Language="F#" Value="override this.ImportEncryptedPkcs8PrivateKey : ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;byte&gt; * int -&gt; unit" Usage="eCDsa.ImportEncryptedPkcs8PrivateKey (password, source, bytesRead)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
        <AssemblyVersion>4.3.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="password" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="1" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
        <Parameter Name="bytesRead" Type="System.Int32" RefType="out" Index="2" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="password"><span data-ttu-id="f2b80-192">用于解密密钥材料的密码。</span><span class="sxs-lookup"><span data-stu-id="f2b80-192">The password to use for decrypting the key material.</span></span></param>
        <param name="source"><span data-ttu-id="f2b80-193">ASN.1-BER 编码中 PKCS#8 EncryptedPrivateKeyInfo 结构的字节。</span><span class="sxs-lookup"><span data-stu-id="f2b80-193">The bytes of a PKCS#8 EncryptedPrivateKeyInfo structure in the ASN.1-BER encoding.</span></span></param>
        <param name="bytesRead"><span data-ttu-id="f2b80-194">此方法返回时，包含一个指示从 <paramref name="source" /> 中读取的字节数的值。</span><span class="sxs-lookup"><span data-stu-id="f2b80-194">When this method returns, contains a value that indicates the number of bytes read from <paramref name="source" />.</span></span> <span data-ttu-id="f2b80-195">该参数未经初始化即被处理。</span><span class="sxs-lookup"><span data-stu-id="f2b80-195">This parameter is treated as uninitialized.</span></span></param>
        <summary><span data-ttu-id="f2b80-196">使用基于字符的密码解密之后，从 PKCS#8 EncryptedPrivateKeyInfo 结构中导入公/私钥对，以替换此对象的密钥。</span><span class="sxs-lookup"><span data-stu-id="f2b80-196">Imports the public/private keypair from a PKCS#8 EncryptedPrivateKeyInfo structure after decrypting with a char-based password, replacing the keys for this object.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f2b80-197">如果的内容 `source` 指示使用 PBKDF1 (基于密码的密钥派生函数 1) 或 PBKDF2 (基于密码的密钥派生函数 2) 的算法，则密码将通过 utf-8 编码转换为字节。</span><span class="sxs-lookup"><span data-stu-id="f2b80-197">When the contents of `source` indicate an algorithm that uses PBKDF1 (Password-Based Key Derivation Function 1) or PBKDF2 (Password-Based Key Derivation Function 2), the password is converted to bytes via the UTF-8 encoding.</span></span>
<span data-ttu-id="f2b80-198">此方法仅支持 EncryptedPrivateKeyInfo 的 BER/CER/DER) 编码的二进制 (。</span><span class="sxs-lookup"><span data-stu-id="f2b80-198">This method only supports the binary (BER/CER/DER) encoding of EncryptedPrivateKeyInfo.</span></span>
<span data-ttu-id="f2b80-199">如果值采用 Base64 编码或 PEM 文本格式，则调用方必须在调用此方法之前对内容进行 Base64 编码。</span><span class="sxs-lookup"><span data-stu-id="f2b80-199">If the value is Base64-encoded or in the PEM text format, the caller must Base64-decode the contents before calling this method.</span></span>
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException"><span data-ttu-id="f2b80-200">密码不正确。</span><span class="sxs-lookup"><span data-stu-id="f2b80-200">The password is incorrect.</span></span>

<span data-ttu-id="f2b80-201">- 或 -</span><span class="sxs-lookup"><span data-stu-id="f2b80-201">-or-</span></span>

<span data-ttu-id="f2b80-202"><paramref name="source" /> 的内容不表示 ASN.1-BER 编码的 PKCS#8 EncryptedPrivateKeyInfo 结构。</span><span class="sxs-lookup"><span data-stu-id="f2b80-202">The contents of <paramref name="source" /> do not represent an ASN.1-BER-encoded PKCS#8 EncryptedPrivateKeyInfo structure.</span></span>

<span data-ttu-id="f2b80-203">- 或 -</span><span class="sxs-lookup"><span data-stu-id="f2b80-203">-or-</span></span>

<span data-ttu-id="f2b80-204"><paramref name="source" /> 的内容指示密钥用于此实例表示的算法以外的算法。</span><span class="sxs-lookup"><span data-stu-id="f2b80-204">The contents of <paramref name="source" /> indicate the key is for an algorithm other than the algorithm represented by this instance.</span></span>

<span data-ttu-id="f2b80-205">- 或 -</span><span class="sxs-lookup"><span data-stu-id="f2b80-205">-or-</span></span>

<span data-ttu-id="f2b80-206"><paramref name="source" /> 的内容表示密钥采用的格式不受支持。</span><span class="sxs-lookup"><span data-stu-id="f2b80-206">The contents of <paramref name="source" /> represent the key in a format that is not supported.</span></span>

<span data-ttu-id="f2b80-207">- 或 -</span><span class="sxs-lookup"><span data-stu-id="f2b80-207">-or-</span></span>

<span data-ttu-id="f2b80-208">特定于算法的密钥导入失败。</span><span class="sxs-lookup"><span data-stu-id="f2b80-208">The algorithm-specific key import failed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ImportFromEncryptedPem">
      <MemberSignature Language="C#" Value="public override void ImportFromEncryptedPem (ReadOnlySpan&lt;char&gt; input, ReadOnlySpan&lt;byte&gt; passwordBytes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void ImportFromEncryptedPem(valuetype System.ReadOnlySpan`1&lt;char&gt; input, valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; passwordBytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDsa.ImportFromEncryptedPem(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub ImportFromEncryptedPem (input As ReadOnlySpan(Of Char), passwordBytes As ReadOnlySpan(Of Byte))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void ImportFromEncryptedPem(ReadOnlySpan&lt;char&gt; input, ReadOnlySpan&lt;System::Byte&gt; passwordBytes);" />
      <MemberSignature Language="F#" Value="override this.ImportFromEncryptedPem : ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;byte&gt; -&gt; unit" Usage="eCDsa.ImportFromEncryptedPem (input, passwordBytes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="net-5.0" />
        <Parameter Name="passwordBytes" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="1" FrameworkAlternate="net-5.0" />
      </Parameters>
      <Docs>
        <param name="input"><span data-ttu-id="f2b80-209">要导入的加密密钥的 PEM 文本。</span><span class="sxs-lookup"><span data-stu-id="f2b80-209">The PEM text of the encrypted key to import.</span></span></param>
        <param name="passwordBytes"><span data-ttu-id="f2b80-210">解密密钥材料时用作密码的字节。</span><span class="sxs-lookup"><span data-stu-id="f2b80-210">The bytes to use as a password when decrypting the key material.</span></span></param>
        <summary><span data-ttu-id="f2b80-211">导入已加密的 RFC 7468 PEM 编码的私钥，替换此对象的密钥。</span><span class="sxs-lookup"><span data-stu-id="f2b80-211">Imports an encrypted RFC 7468 PEM-encoded private key, replacing the keys for this object.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

 <span data-ttu-id="f2b80-212">密码字节直接传递到密钥派生函数 (KDF) 使用的算法所使用的算法 `pbeParameters` 。</span><span class="sxs-lookup"><span data-stu-id="f2b80-212">The password bytes are passed directly into the Key Derivation Function (KDF) used by the algorithm indicated by `pbeParameters`.</span></span> <span data-ttu-id="f2b80-213">这样，在使用 PBKDF2 处理密码时，与使用 UTF-8 以外的文本编码的其他系统兼容， (基于密码的密钥派生函数 2) 。</span><span class="sxs-lookup"><span data-stu-id="f2b80-213">This enables compatibility with other systems that use a text encoding other than UTF-8 when processing passwords with PBKDF2 (Password-Based Key Derivation Function 2).</span></span>
 

 <span data-ttu-id="f2b80-214">不支持或格式不正确的 PEM 编码对象将被忽略。</span><span class="sxs-lookup"><span data-stu-id="f2b80-214">Unsupported or malformed PEM-encoded objects will be ignored.</span></span> <span data-ttu-id="f2b80-215">如果找到多个受支持的 PEM 标签，则会引发异常，以防当键不明确时导入密钥。</span><span class="sxs-lookup"><span data-stu-id="f2b80-215">If multiple supported PEM labels are found, an exception is thrown to prevent importing a key when the key is ambiguous.</span></span>
 

<span data-ttu-id="f2b80-216">此方法支持 `ENCRYPTED PRIVATE KEY` PEM 标签。</span><span class="sxs-lookup"><span data-stu-id="f2b80-216">This method supports the `ENCRYPTED PRIVATE KEY` PEM label.</span></span>



          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="f2b80-217"><paramref name="input" /> 不包含带有可识别标签的 PEM 编码的密钥。</span><span class="sxs-lookup"><span data-stu-id="f2b80-217"><paramref name="input" /> does not contain a PEM-encoded key with a recognized label.</span></span>

<span data-ttu-id="f2b80-218">- 或 -</span><span class="sxs-lookup"><span data-stu-id="f2b80-218">-or-</span></span>

<span data-ttu-id="f2b80-219"><paramref name="input" /> 包含多个带有可识别标签的 PEM 编码的密钥。</span><span class="sxs-lookup"><span data-stu-id="f2b80-219"><paramref name="input" /> contains multiple PEM-encoded keys with a recognized label.</span></span></exception>
        <exception cref="T:System.Security.Cryptography.CryptographicException"><span data-ttu-id="f2b80-220">密码不正确。</span><span class="sxs-lookup"><span data-stu-id="f2b80-220">The password is incorrect.</span></span>

<span data-ttu-id="f2b80-221">- 或 -</span><span class="sxs-lookup"><span data-stu-id="f2b80-221">-or-</span></span> 
<span data-ttu-id="f2b80-222"><paramref name="input" /> 中 PEM 文本的 Base-64 解码的内容不表示 ASN.1-BER 编码的 PKCS#8 EncryptedPrivateKeyInfo 结构。</span><span class="sxs-lookup"><span data-stu-id="f2b80-222">The base-64 decoded contents of the PEM text from <paramref name="input" /> do not represent an ASN.1-BER-encoded PKCS#8 EncryptedPrivateKeyInfo structure.</span></span>

<span data-ttu-id="f2b80-223">- 或 -</span><span class="sxs-lookup"><span data-stu-id="f2b80-223">-or-</span></span>

<span data-ttu-id="f2b80-224"><paramref name="input" /> 中 PEM 文本的 Base-64 解码的内容指示密钥用于此实例表示的算法以外的算法。</span><span class="sxs-lookup"><span data-stu-id="f2b80-224">The base-64 decoded contents of the PEM text from <paramref name="input" /> indicate the key is for an algorithm other than the algorithm represented by this instance.</span></span>

<span data-ttu-id="f2b80-225">- 或 -</span><span class="sxs-lookup"><span data-stu-id="f2b80-225">-or-</span></span>

<span data-ttu-id="f2b80-226"><paramref name="input" /> 中 PEM 文本的 Base-64 解码的内容表示密钥采用的格式不受支持。</span><span class="sxs-lookup"><span data-stu-id="f2b80-226">The base-64 decoded contents of the PEM text from <paramref name="input" /> represent the key in a format that is not supported.</span></span>

<span data-ttu-id="f2b80-227">- 或 -</span><span class="sxs-lookup"><span data-stu-id="f2b80-227">-or-</span></span>

<span data-ttu-id="f2b80-228">特定于算法的密钥导入失败。</span><span class="sxs-lookup"><span data-stu-id="f2b80-228">The algorithm-specific key import failed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ImportFromEncryptedPem">
      <MemberSignature Language="C#" Value="public override void ImportFromEncryptedPem (ReadOnlySpan&lt;char&gt; input, ReadOnlySpan&lt;char&gt; password);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void ImportFromEncryptedPem(valuetype System.ReadOnlySpan`1&lt;char&gt; input, valuetype System.ReadOnlySpan`1&lt;char&gt; password) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDsa.ImportFromEncryptedPem(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub ImportFromEncryptedPem (input As ReadOnlySpan(Of Char), password As ReadOnlySpan(Of Char))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void ImportFromEncryptedPem(ReadOnlySpan&lt;char&gt; input, ReadOnlySpan&lt;char&gt; password);" />
      <MemberSignature Language="F#" Value="override this.ImportFromEncryptedPem : ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; -&gt; unit" Usage="eCDsa.ImportFromEncryptedPem (input, password)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="net-5.0" />
        <Parameter Name="password" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="1" FrameworkAlternate="net-5.0" />
      </Parameters>
      <Docs>
        <param name="input"><span data-ttu-id="f2b80-229">要导入的加密密钥的 PEM 文本。</span><span class="sxs-lookup"><span data-stu-id="f2b80-229">The PEM text of the encrypted key to import.</span></span></param>
        <param name="password"><span data-ttu-id="f2b80-230">用于解密密钥材料的密码。</span><span class="sxs-lookup"><span data-stu-id="f2b80-230">The password to use for decrypting the key material.</span></span></param>
        <summary><span data-ttu-id="f2b80-231">导入已加密的 RFC 7468 PEM 编码的私钥，替换此对象的密钥。</span><span class="sxs-lookup"><span data-stu-id="f2b80-231">Imports an encrypted RFC 7468 PEM-encoded private key, replacing the keys for this object.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

 <span data-ttu-id="f2b80-232">如果64的已解码内容 `input` 指示使用 PBKDF1 (基于密码的密钥派生函数 1) 或 PBKDF2 (基于密码的密钥派生函数 2) 的算法，则密码将通过 utf-8 编码转换为字节。</span><span class="sxs-lookup"><span data-stu-id="f2b80-232">When the base-64 decoded contents of `input` indicate an algorithm that uses PBKDF1 (Password-Based Key Derivation Function 1) or PBKDF2 (Password-Based Key Derivation Function 2), the password is converted to bytes via the UTF-8 encoding.</span></span>
 

 <span data-ttu-id="f2b80-233">不支持或格式不正确的 PEM 编码对象将被忽略。</span><span class="sxs-lookup"><span data-stu-id="f2b80-233">Unsupported or malformed PEM-encoded objects will be ignored.</span></span> <span data-ttu-id="f2b80-234">如果找到多个受支持的 PEM 标签，则会引发异常，以防当键不明确时导入密钥。</span><span class="sxs-lookup"><span data-stu-id="f2b80-234">If multiple supported PEM labels are found, an exception is thrown to prevent importing a key when the key is ambiguous.</span></span>
 

<span data-ttu-id="f2b80-235">此方法支持 `ENCRYPTED PRIVATE KEY` PEM 标签。</span><span class="sxs-lookup"><span data-stu-id="f2b80-235">This method supports the `ENCRYPTED PRIVATE KEY` PEM label.</span></span>



          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="f2b80-236"><paramref name="input" /> 不包含带有可识别标签的 PEM 编码的密钥。</span><span class="sxs-lookup"><span data-stu-id="f2b80-236"><paramref name="input" /> does not contain a PEM-encoded key with a recognized label.</span></span>

<span data-ttu-id="f2b80-237">- 或 -</span><span class="sxs-lookup"><span data-stu-id="f2b80-237">-or-</span></span>

<span data-ttu-id="f2b80-238"><paramref name="input" /> 包含多个带有可识别标签的 PEM 编码的密钥。</span><span class="sxs-lookup"><span data-stu-id="f2b80-238"><paramref name="input" /> contains multiple PEM-encoded keys with a recognized label.</span></span></exception>
        <exception cref="T:System.Security.Cryptography.CryptographicException"><span data-ttu-id="f2b80-239">密码不正确。</span><span class="sxs-lookup"><span data-stu-id="f2b80-239">The password is incorrect.</span></span>

<span data-ttu-id="f2b80-240">- 或 -</span><span class="sxs-lookup"><span data-stu-id="f2b80-240">-or-</span></span>

<span data-ttu-id="f2b80-241"><paramref name="input" /> 中 PEM 文本的 Base-64 解码的内容不表示 ASN.1-BER 编码的 PKCS#8 EncryptedPrivateKeyInfo 结构。</span><span class="sxs-lookup"><span data-stu-id="f2b80-241">The base-64 decoded contents of the PEM text from <paramref name="input" /> do not represent an ASN.1-BER-encoded PKCS#8 EncryptedPrivateKeyInfo structure.</span></span>

<span data-ttu-id="f2b80-242">- 或 -</span><span class="sxs-lookup"><span data-stu-id="f2b80-242">-or-</span></span>

<span data-ttu-id="f2b80-243"><paramref name="input" /> 中 PEM 文本的 Base-64 解码的内容指示密钥用于此实例表示的算法以外的算法。</span><span class="sxs-lookup"><span data-stu-id="f2b80-243">The base-64 decoded contents of the PEM text from <paramref name="input" /> indicate the key is for an algorithm other than the algorithm represented by this instance.</span></span>

<span data-ttu-id="f2b80-244">- 或 -</span><span class="sxs-lookup"><span data-stu-id="f2b80-244">-or-</span></span>

<span data-ttu-id="f2b80-245"><paramref name="input" /> 中 PEM 文本的 Base-64 解码的内容表示密钥采用的格式不受支持。</span><span class="sxs-lookup"><span data-stu-id="f2b80-245">The base-64 decoded contents of the PEM text from <paramref name="input" /> represent the key in a format that is not supported.</span></span>

<span data-ttu-id="f2b80-246">- 或 -</span><span class="sxs-lookup"><span data-stu-id="f2b80-246">-or-</span></span>

<span data-ttu-id="f2b80-247">特定于算法的密钥导入失败。</span><span class="sxs-lookup"><span data-stu-id="f2b80-247">The algorithm-specific key import failed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ImportFromPem">
      <MemberSignature Language="C#" Value="public override void ImportFromPem (ReadOnlySpan&lt;char&gt; input);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void ImportFromPem(valuetype System.ReadOnlySpan`1&lt;char&gt; input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDsa.ImportFromPem(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub ImportFromPem (input As ReadOnlySpan(Of Char))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void ImportFromPem(ReadOnlySpan&lt;char&gt; input);" />
      <MemberSignature Language="F#" Value="override this.ImportFromPem : ReadOnlySpan&lt;char&gt; -&gt; unit" Usage="eCDsa.ImportFromPem input" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="net-5.0" />
      </Parameters>
      <Docs>
        <param name="input"><span data-ttu-id="f2b80-248">要导入的密钥的 PEM 文本。</span><span class="sxs-lookup"><span data-stu-id="f2b80-248">The PEM text of the key to import.</span></span></param>
        <summary><span data-ttu-id="f2b80-249">导入 RFC 7468 PEM 编码的密钥，替换此对象的密钥。</span><span class="sxs-lookup"><span data-stu-id="f2b80-249">Imports an RFC 7468 PEM-encoded key, replacing the keys for this object.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

 <span data-ttu-id="f2b80-250">不支持或格式不正确的 PEM 编码对象将被忽略。</span><span class="sxs-lookup"><span data-stu-id="f2b80-250">Unsupported or malformed PEM-encoded objects will be ignored.</span></span> <span data-ttu-id="f2b80-251">如果找到多个受支持的 PEM 标签，则会引发异常，以防止在键不明确时导入密钥。</span><span class="sxs-lookup"><span data-stu-id="f2b80-251">If multiple supported PEM labels are found, an exception is raised to prevent importing a key when the key is ambiguous.</span></span>
 

 <span data-ttu-id="f2b80-252">此方法支持以下 PEM 标签：  </span><span class="sxs-lookup"><span data-stu-id="f2b80-252">This method supports the following PEM labels:  </span></span><list type="bullet"><item><description><span data-ttu-id="f2b80-253">公钥</span><span class="sxs-lookup"><span data-stu-id="f2b80-253">PUBLIC KEY</span></span></description></item><item><description><span data-ttu-id="f2b80-254">私钥</span><span class="sxs-lookup"><span data-stu-id="f2b80-254">PRIVATE KEY</span></span></description></item><item><description><span data-ttu-id="f2b80-255">EC 私钥</span><span class="sxs-lookup"><span data-stu-id="f2b80-255">EC PRIVATE KEY</span></span></description></item></list>



          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="f2b80-256"><paramref name="input" /> 不包含带有可识别标签的 PEM 编码的密钥。</span><span class="sxs-lookup"><span data-stu-id="f2b80-256"><paramref name="input" /> does not contain a PEM-encoded key with a recognized label.</span></span>

<span data-ttu-id="f2b80-257">- 或 -</span><span class="sxs-lookup"><span data-stu-id="f2b80-257">-or-</span></span>

<span data-ttu-id="f2b80-258"><paramref name="input" /> 包含多个带有可识别标签的 PEM 编码的密钥。</span><span class="sxs-lookup"><span data-stu-id="f2b80-258"><paramref name="input" /> contains multiple PEM-encoded keys with a recognized label.</span></span>

<span data-ttu-id="f2b80-259">- 或 -</span><span class="sxs-lookup"><span data-stu-id="f2b80-259">-or-</span></span>

<span data-ttu-id="f2b80-260"><paramref name="input" /> 包含已加密的 PEM 编码的密钥。</span><span class="sxs-lookup"><span data-stu-id="f2b80-260"><paramref name="input" /> contains an encrypted PEM-encoded key.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ImportParameters">
      <MemberSignature Language="C#" Value="public virtual void ImportParameters (System.Security.Cryptography.ECParameters parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ImportParameters(valuetype System.Security.Cryptography.ECParameters parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDsa.ImportParameters(System.Security.Cryptography.ECParameters)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub ImportParameters (parameters As ECParameters)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ImportParameters(System::Security::Cryptography::ECParameters parameters);" />
      <MemberSignature Language="F#" Value="abstract member ImportParameters : System.Security.Cryptography.ECParameters -&gt; unit&#xA;override this.ImportParameters : System.Security.Cryptography.ECParameters -&gt; unit" Usage="eCDsa.ImportParameters parameters" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.3.0.0</AssemblyVersion>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
        <AssemblyVersion>4.3.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netstandard-2.0">
          <AttributeName Language="C#">[System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="parameters" Type="System.Security.Cryptography.ECParameters" Index="0" FrameworkAlternate="net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8" />
      </Parameters>
      <Docs>
        <param name="parameters"><span data-ttu-id="f2b80-261">曲线的参数。</span><span class="sxs-lookup"><span data-stu-id="f2b80-261">The curve parameters.</span></span></param>
        <summary><span data-ttu-id="f2b80-262">当在派生类中重写时，导入指定的参数。</span><span class="sxs-lookup"><span data-stu-id="f2b80-262">When overridden in a derived class, imports the specified parameters.</span></span></summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="f2b80-263">派生方法必须重写此方法。</span><span class="sxs-lookup"><span data-stu-id="f2b80-263">A derived class must override this method.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ImportPkcs8PrivateKey">
      <MemberSignature Language="C#" Value="public override void ImportPkcs8PrivateKey (ReadOnlySpan&lt;byte&gt; source, out int bytesRead);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void ImportPkcs8PrivateKey(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source, [out] int32&amp; bytesRead) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDsa.ImportPkcs8PrivateKey(System.ReadOnlySpan{System.Byte},System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub ImportPkcs8PrivateKey (source As ReadOnlySpan(Of Byte), ByRef bytesRead As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void ImportPkcs8PrivateKey(ReadOnlySpan&lt;System::Byte&gt; source, [Runtime::InteropServices::Out] int % bytesRead);" />
      <MemberSignature Language="F#" Value="override this.ImportPkcs8PrivateKey : ReadOnlySpan&lt;byte&gt; * int -&gt; unit" Usage="eCDsa.ImportPkcs8PrivateKey (source, bytesRead)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
        <AssemblyVersion>4.3.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="0" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
        <Parameter Name="bytesRead" Type="System.Int32" RefType="out" Index="1" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="source"><span data-ttu-id="f2b80-264">ASN.1-BER 编码中 PKCS#8 PrivateKeyInfo 结构的字节。</span><span class="sxs-lookup"><span data-stu-id="f2b80-264">The bytes of a PKCS#8 PrivateKeyInfo structure in the ASN.1-BER encoding.</span></span></param>
        <param name="bytesRead"><span data-ttu-id="f2b80-265">此方法返回时，包含一个指示从 <paramref name="source" /> 中读取的字节数的值。</span><span class="sxs-lookup"><span data-stu-id="f2b80-265">When this method returns, contains a value that indicates the number of bytes read from <paramref name="source" />.</span></span> <span data-ttu-id="f2b80-266">该参数未经初始化即被处理。</span><span class="sxs-lookup"><span data-stu-id="f2b80-266">This parameter is treated as uninitialized.</span></span></param>
        <summary><span data-ttu-id="f2b80-267">解密后，从 PKCS#8 PrivateKeyInfo 结构中导入公/私钥对，以替换此对象的密钥。</span><span class="sxs-lookup"><span data-stu-id="f2b80-267">Imports the public/private keypair from a PKCS#8 PrivateKeyInfo structure after decryption, replacing the keys for this object.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f2b80-268">此方法仅支持 PrivateKeyInfo 的 BER/CER/DER) 编码的二进制 (。</span><span class="sxs-lookup"><span data-stu-id="f2b80-268">This method only supports the binary (BER/CER/DER) encoding of PrivateKeyInfo.</span></span>
<span data-ttu-id="f2b80-269">如果值采用 Base64 编码或 PEM 文本格式，则调用方必须在调用此方法之前对内容进行 Base64 编码。</span><span class="sxs-lookup"><span data-stu-id="f2b80-269">If the value is Base64-encoded or in the PEM text format, the caller must Base64-decode the contents before calling this method.</span></span>
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException"><span data-ttu-id="f2b80-270"><paramref name="source" /> 的内容不表示 ASN.1-BER 编码的 PKCS#8 PrivateKeyInfo 结构。</span><span class="sxs-lookup"><span data-stu-id="f2b80-270">The contents of <paramref name="source" /> do not represent an ASN.1-BER-encoded PKCS#8 PrivateKeyInfo structure.</span></span>

<span data-ttu-id="f2b80-271">- 或 -</span><span class="sxs-lookup"><span data-stu-id="f2b80-271">-or-</span></span>

<span data-ttu-id="f2b80-272"><paramref name="source" /> 的内容指示密钥用于此实例表示的算法以外的算法。</span><span class="sxs-lookup"><span data-stu-id="f2b80-272">The contents of <paramref name="source" /> indicate the key is for an algorithm other than the algorithm represented by this instance.</span></span>

<span data-ttu-id="f2b80-273">- 或 -</span><span class="sxs-lookup"><span data-stu-id="f2b80-273">-or-</span></span>

<span data-ttu-id="f2b80-274"><paramref name="source" /> 的内容表示密钥采用的格式不受支持。</span><span class="sxs-lookup"><span data-stu-id="f2b80-274">The contents of <paramref name="source" /> represent the key in a format that is not supported.</span></span>

<span data-ttu-id="f2b80-275">- 或 -</span><span class="sxs-lookup"><span data-stu-id="f2b80-275">-or-</span></span>

<span data-ttu-id="f2b80-276">特定于算法的密钥导入失败。</span><span class="sxs-lookup"><span data-stu-id="f2b80-276">The algorithm-specific key import failed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ImportSubjectPublicKeyInfo">
      <MemberSignature Language="C#" Value="public override void ImportSubjectPublicKeyInfo (ReadOnlySpan&lt;byte&gt; source, out int bytesRead);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void ImportSubjectPublicKeyInfo(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source, [out] int32&amp; bytesRead) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDsa.ImportSubjectPublicKeyInfo(System.ReadOnlySpan{System.Byte},System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub ImportSubjectPublicKeyInfo (source As ReadOnlySpan(Of Byte), ByRef bytesRead As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void ImportSubjectPublicKeyInfo(ReadOnlySpan&lt;System::Byte&gt; source, [Runtime::InteropServices::Out] int % bytesRead);" />
      <MemberSignature Language="F#" Value="override this.ImportSubjectPublicKeyInfo : ReadOnlySpan&lt;byte&gt; * int -&gt; unit" Usage="eCDsa.ImportSubjectPublicKeyInfo (source, bytesRead)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
        <AssemblyVersion>4.3.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="0" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
        <Parameter Name="bytesRead" Type="System.Int32" RefType="out" Index="1" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="source"><span data-ttu-id="f2b80-277">ASN.1-DER 编码中的 X.509 SubjectPublicKeyInfo 结构的字节。</span><span class="sxs-lookup"><span data-stu-id="f2b80-277">The bytes of an X.509 SubjectPublicKeyInfo structure in the ASN.1-DER encoding.</span></span></param>
        <param name="bytesRead"><span data-ttu-id="f2b80-278">此方法返回时，包含一个指示从 <paramref name="source" /> 中读取的字节数的值。</span><span class="sxs-lookup"><span data-stu-id="f2b80-278">When this method returns, contains a value that indicates the number of bytes read from <paramref name="source" />.</span></span> <span data-ttu-id="f2b80-279">该参数未经初始化即被处理。</span><span class="sxs-lookup"><span data-stu-id="f2b80-279">This parameter is treated as uninitialized.</span></span></param>
        <summary><span data-ttu-id="f2b80-280">解密后，从 X.509 SubjectPublicKeyInfo 结构中导入公钥，以替换此对象的密钥。</span><span class="sxs-lookup"><span data-stu-id="f2b80-280">Imports the public key from an X.509 SubjectPublicKeyInfo structure after decryption, replacing the keys for this object.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f2b80-281">此方法仅支持 SubjectPublicKeyInfo 的二进制 (DER) 编码。</span><span class="sxs-lookup"><span data-stu-id="f2b80-281">This method only supports the binary (DER) encoding of SubjectPublicKeyInfo.</span></span>
<span data-ttu-id="f2b80-282">如果值采用 Base64 编码或 PEM 文本格式，则调用方必须在调用此方法之前对内容进行 Base64 编码。</span><span class="sxs-lookup"><span data-stu-id="f2b80-282">If the value is Base64-encoded or in the PEM text format, the caller must Base64-decode the contents before calling this method.</span></span>
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException"><span data-ttu-id="f2b80-283"><paramref name="source" /> 的内容不表示 ASN.1-DER 编码的 X.509 SubjectPublicKeyInfo 结构。</span><span class="sxs-lookup"><span data-stu-id="f2b80-283">The contents of <paramref name="source" /> do not represent an ASN.1-DER-encoded X.509 SubjectPublicKeyInfo structure.</span></span>

<span data-ttu-id="f2b80-284">- 或 -</span><span class="sxs-lookup"><span data-stu-id="f2b80-284">-or-</span></span>

<span data-ttu-id="f2b80-285"><paramref name="source" /> 的内容指示密钥用于此实例表示的算法以外的算法。</span><span class="sxs-lookup"><span data-stu-id="f2b80-285">The contents of <paramref name="source" /> indicate the key is for an algorithm other than the algorithm represented by this instance.</span></span>

<span data-ttu-id="f2b80-286">- 或 -</span><span class="sxs-lookup"><span data-stu-id="f2b80-286">-or-</span></span>

<span data-ttu-id="f2b80-287"><paramref name="source" /> 的内容表示密钥采用的格式不受支持。</span><span class="sxs-lookup"><span data-stu-id="f2b80-287">The contents of <paramref name="source" /> represent the key in a format that is not supported.</span></span>

<span data-ttu-id="f2b80-288">- 或 -</span><span class="sxs-lookup"><span data-stu-id="f2b80-288">-or-</span></span>

<span data-ttu-id="f2b80-289">特定于算法的密钥导入失败。</span><span class="sxs-lookup"><span data-stu-id="f2b80-289">The algorithm-specific key import failed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="KeyExchangeAlgorithm">
      <MemberSignature Language="C#" Value="public override string? KeyExchangeAlgorithm { get; }" FrameworkAlternate="net-5.0" />
      <MemberSignature Language="ILAsm" Value=".property instance string KeyExchangeAlgorithm" />
      <MemberSignature Language="DocId" Value="P:System.Security.Cryptography.ECDsa.KeyExchangeAlgorithm" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property KeyExchangeAlgorithm As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ KeyExchangeAlgorithm { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.KeyExchangeAlgorithm : string" Usage="System.Security.Cryptography.ECDsa.KeyExchangeAlgorithm" />
      <MemberSignature Language="C#" Value="public override string KeyExchangeAlgorithm { get; }" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.3.0.0</AssemblyVersion>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
        <AssemblyVersion>4.3.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f2b80-290">获取密钥交换算法的名称。</span><span class="sxs-lookup"><span data-stu-id="f2b80-290">Gets the name of the key exchange algorithm.</span></span></summary>
        <value><span data-ttu-id="f2b80-291">总是为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="f2b80-291">Always <see langword="null" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f2b80-292">此属性继承自 <xref:System.Security.Cryptography.AsymmetricAlgorithm> 基类。</span><span class="sxs-lookup"><span data-stu-id="f2b80-292">This property is inherited from the <xref:System.Security.Cryptography.AsymmetricAlgorithm> base class.</span></span>  
  
 <span data-ttu-id="f2b80-293">椭圆曲线数字签名算法 (ECDSA) 用于数字签名生成;它不用于密钥派生，因此，此属性返回 `null` 。</span><span class="sxs-lookup"><span data-stu-id="f2b80-293">The Elliptic Curve Digital Signature Algorithm (ECDSA) is used for digital signature generation; it is not used for key derivation Therefore, this property returns `null`.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SignatureAlgorithm">
      <MemberSignature Language="C#" Value="public override string? SignatureAlgorithm { get; }" FrameworkAlternate="net-5.0" />
      <MemberSignature Language="ILAsm" Value=".property instance string SignatureAlgorithm" />
      <MemberSignature Language="DocId" Value="P:System.Security.Cryptography.ECDsa.SignatureAlgorithm" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property SignatureAlgorithm As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ SignatureAlgorithm { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SignatureAlgorithm : string" Usage="System.Security.Cryptography.ECDsa.SignatureAlgorithm" />
      <MemberSignature Language="C#" Value="public override string SignatureAlgorithm { get; }" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.3.0.0</AssemblyVersion>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
        <AssemblyVersion>4.3.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f2b80-294">获取签名算法的名称。</span><span class="sxs-lookup"><span data-stu-id="f2b80-294">Gets the name of the signature algorithm.</span></span></summary>
        <value><span data-ttu-id="f2b80-295">字符串“ECDsa”。</span><span class="sxs-lookup"><span data-stu-id="f2b80-295">The string "ECDsa".</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="SignData">
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.3.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="f2b80-296">计算指定数据的哈希值，并对其进行签名。</span><span class="sxs-lookup"><span data-stu-id="f2b80-296">Computes the hash value of the specified data and signs it.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SignData">
      <MemberSignature Language="C#" Value="public virtual byte[] SignData (byte[] data, System.Security.Cryptography.HashAlgorithmName hashAlgorithm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance unsigned int8[] SignData(unsigned int8[] data, valuetype System.Security.Cryptography.HashAlgorithmName hashAlgorithm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDsa.SignData(System.Byte[],System.Security.Cryptography.HashAlgorithmName)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function SignData (data As Byte(), hashAlgorithm As HashAlgorithmName) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Byte&gt; ^ SignData(cli::array &lt;System::Byte&gt; ^ data, System::Security::Cryptography::HashAlgorithmName hashAlgorithm);" />
      <MemberSignature Language="F#" Value="abstract member SignData : byte[] * System.Security.Cryptography.HashAlgorithmName -&gt; byte[]&#xA;override this.SignData : byte[] * System.Security.Cryptography.HashAlgorithmName -&gt; byte[]" Usage="eCDsa.SignData (data, hashAlgorithm)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.3.0.0</AssemblyVersion>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
        <AssemblyVersion>4.3.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Byte[]" Index="0" FrameworkAlternate="net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="hashAlgorithm" Type="System.Security.Cryptography.HashAlgorithmName" Index="1" FrameworkAlternate="net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="data"><span data-ttu-id="f2b80-297">要为其计算哈希的输入数据。</span><span class="sxs-lookup"><span data-stu-id="f2b80-297">The input data for which to compute the hash.</span></span></param>
        <param name="hashAlgorithm"><span data-ttu-id="f2b80-298">要用于创建哈希值的哈希算法。</span><span class="sxs-lookup"><span data-stu-id="f2b80-298">The hash algorithm to use to create the hash value.</span></span></param>
        <summary><span data-ttu-id="f2b80-299">使用指定的哈希算法计算指定字节数组的哈希值，并对生成的哈希值进行签名。</span><span class="sxs-lookup"><span data-stu-id="f2b80-299">Computes the hash value of the specified byte array using the specified hash algorithm and signs the resulting hash value.</span></span></summary>
        <returns><span data-ttu-id="f2b80-300">指定数据的 ECDSA 签名。</span><span class="sxs-lookup"><span data-stu-id="f2b80-300">The ECDSA signature for the specified data.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f2b80-301"><paramref name="data" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="f2b80-301"><paramref name="data" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="f2b80-302"><paramref name="hashAlgorithm" />.<see cref="P:System.Security.Cryptography.HashAlgorithmName.Name" /></span><span class="sxs-lookup"><span data-stu-id="f2b80-302"><paramref name="hashAlgorithm" />.<see cref="P:System.Security.Cryptography.HashAlgorithmName.Name" /></span></span> <span data-ttu-id="f2b80-303">为 <see langword="null" /> 或 <see cref="F:System.String.Empty" />。</span><span class="sxs-lookup"><span data-stu-id="f2b80-303">is <see langword="null" /> or <see cref="F:System.String.Empty" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="SignData">
      <MemberSignature Language="C#" Value="public virtual byte[] SignData (System.IO.Stream data, System.Security.Cryptography.HashAlgorithmName hashAlgorithm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance unsigned int8[] SignData(class System.IO.Stream data, valuetype System.Security.Cryptography.HashAlgorithmName hashAlgorithm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDsa.SignData(System.IO.Stream,System.Security.Cryptography.HashAlgorithmName)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function SignData (data As Stream, hashAlgorithm As HashAlgorithmName) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Byte&gt; ^ SignData(System::IO::Stream ^ data, System::Security::Cryptography::HashAlgorithmName hashAlgorithm);" />
      <MemberSignature Language="F#" Value="abstract member SignData : System.IO.Stream * System.Security.Cryptography.HashAlgorithmName -&gt; byte[]&#xA;override this.SignData : System.IO.Stream * System.Security.Cryptography.HashAlgorithmName -&gt; byte[]" Usage="eCDsa.SignData (data, hashAlgorithm)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.3.0.0</AssemblyVersion>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
        <AssemblyVersion>4.3.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.IO.Stream" Index="0" FrameworkAlternate="net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="hashAlgorithm" Type="System.Security.Cryptography.HashAlgorithmName" Index="1" FrameworkAlternate="net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="data"><span data-ttu-id="f2b80-304">要为其计算哈希的输入流。</span><span class="sxs-lookup"><span data-stu-id="f2b80-304">The input stream for which to compute the hash.</span></span></param>
        <param name="hashAlgorithm"><span data-ttu-id="f2b80-305">要用于创建哈希值的哈希算法。</span><span class="sxs-lookup"><span data-stu-id="f2b80-305">The hash algorithm to use to create the hash value.</span></span></param>
        <summary><span data-ttu-id="f2b80-306">使用指定的哈希算法计算指定流的哈希值，并对生成的哈希值进行签名。</span><span class="sxs-lookup"><span data-stu-id="f2b80-306">Computes the hash value of the specified stream using the specified hash algorithm and signs the resulting hash value.</span></span></summary>
        <returns><span data-ttu-id="f2b80-307">指定数据的 ECDSA 签名。</span><span class="sxs-lookup"><span data-stu-id="f2b80-307">The ECDSA signature for the specified data.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f2b80-308"><paramref name="data" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="f2b80-308"><paramref name="data" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="f2b80-309"><paramref name="hashAlgorithm" />.<see cref="P:System.Security.Cryptography.HashAlgorithmName.Name" /></span><span class="sxs-lookup"><span data-stu-id="f2b80-309"><paramref name="hashAlgorithm" />.<see cref="P:System.Security.Cryptography.HashAlgorithmName.Name" /></span></span> <span data-ttu-id="f2b80-310">为 <see langword="null" /> 或 <see cref="F:System.String.Empty" />。</span><span class="sxs-lookup"><span data-stu-id="f2b80-310">is <see langword="null" /> or <see cref="F:System.String.Empty" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="SignData">
      <MemberSignature Language="C#" Value="public byte[] SignData (byte[] data, System.Security.Cryptography.HashAlgorithmName hashAlgorithm, System.Security.Cryptography.DSASignatureFormat signatureFormat);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8[] SignData(unsigned int8[] data, valuetype System.Security.Cryptography.HashAlgorithmName hashAlgorithm, valuetype System.Security.Cryptography.DSASignatureFormat signatureFormat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDsa.SignData(System.Byte[],System.Security.Cryptography.HashAlgorithmName,System.Security.Cryptography.DSASignatureFormat)" />
      <MemberSignature Language="VB.NET" Value="Public Function SignData (data As Byte(), hashAlgorithm As HashAlgorithmName, signatureFormat As DSASignatureFormat) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Byte&gt; ^ SignData(cli::array &lt;System::Byte&gt; ^ data, System::Security::Cryptography::HashAlgorithmName hashAlgorithm, System::Security::Cryptography::DSASignatureFormat signatureFormat);" />
      <MemberSignature Language="F#" Value="member this.SignData : byte[] * System.Security.Cryptography.HashAlgorithmName * System.Security.Cryptography.DSASignatureFormat -&gt; byte[]" Usage="eCDsa.SignData (data, hashAlgorithm, signatureFormat)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Byte[]" Index="0" FrameworkAlternate="net-5.0" />
        <Parameter Name="hashAlgorithm" Type="System.Security.Cryptography.HashAlgorithmName" Index="1" FrameworkAlternate="net-5.0" />
        <Parameter Name="signatureFormat" Type="System.Security.Cryptography.DSASignatureFormat" Index="2" FrameworkAlternate="net-5.0" />
      </Parameters>
      <Docs>
        <param name="data"><span data-ttu-id="f2b80-311">要签名的数据。</span><span class="sxs-lookup"><span data-stu-id="f2b80-311">The data to sign.</span></span></param>
        <param name="hashAlgorithm"><span data-ttu-id="f2b80-312">要用于创建哈希值的哈希算法。</span><span class="sxs-lookup"><span data-stu-id="f2b80-312">The hash algorithm to use to create the hash value.</span></span></param>
        <param name="signatureFormat"><span data-ttu-id="f2b80-313">要用于签名的编码格式。</span><span class="sxs-lookup"><span data-stu-id="f2b80-313">The encoding format to use for the signature.</span></span></param>
        <summary><span data-ttu-id="f2b80-314">计算指定数据的哈希值，并使用指定的签名格式对其进行签名。</span><span class="sxs-lookup"><span data-stu-id="f2b80-314">Computes the hash value of the specified data and signs it using the specified signature format.</span></span></summary>
        <returns><span data-ttu-id="f2b80-315">指定数据的 ECDSA 签名。</span><span class="sxs-lookup"><span data-stu-id="f2b80-315">The ECDSA signature for the specified data.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f2b80-316"><paramref name="data" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="f2b80-316"><paramref name="data" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="f2b80-317"><paramref name="signatureFormat" /> 不是已知格式。</span><span class="sxs-lookup"><span data-stu-id="f2b80-317"><paramref name="signatureFormat" /> is not a known format.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="f2b80-318"><paramref name="hashAlgorithm" /> 具有 <see langword="null" /> 或空的 <see cref="P:System.Security.Cryptography.HashAlgorithmName.Name" />。</span><span class="sxs-lookup"><span data-stu-id="f2b80-318"><paramref name="hashAlgorithm" /> has a <see langword="null" /> or empty <see cref="P:System.Security.Cryptography.HashAlgorithmName.Name" />.</span></span></exception>
        <exception cref="T:System.Security.Cryptography.CryptographicException"><span data-ttu-id="f2b80-319">哈希处理或签名时出错。</span><span class="sxs-lookup"><span data-stu-id="f2b80-319">An error occurred in the hashing or signing operation.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="SignData">
      <MemberSignature Language="C#" Value="public byte[] SignData (System.IO.Stream data, System.Security.Cryptography.HashAlgorithmName hashAlgorithm, System.Security.Cryptography.DSASignatureFormat signatureFormat);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8[] SignData(class System.IO.Stream data, valuetype System.Security.Cryptography.HashAlgorithmName hashAlgorithm, valuetype System.Security.Cryptography.DSASignatureFormat signatureFormat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDsa.SignData(System.IO.Stream,System.Security.Cryptography.HashAlgorithmName,System.Security.Cryptography.DSASignatureFormat)" />
      <MemberSignature Language="VB.NET" Value="Public Function SignData (data As Stream, hashAlgorithm As HashAlgorithmName, signatureFormat As DSASignatureFormat) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Byte&gt; ^ SignData(System::IO::Stream ^ data, System::Security::Cryptography::HashAlgorithmName hashAlgorithm, System::Security::Cryptography::DSASignatureFormat signatureFormat);" />
      <MemberSignature Language="F#" Value="member this.SignData : System.IO.Stream * System.Security.Cryptography.HashAlgorithmName * System.Security.Cryptography.DSASignatureFormat -&gt; byte[]" Usage="eCDsa.SignData (data, hashAlgorithm, signatureFormat)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.IO.Stream" Index="0" FrameworkAlternate="net-5.0" />
        <Parameter Name="hashAlgorithm" Type="System.Security.Cryptography.HashAlgorithmName" Index="1" FrameworkAlternate="net-5.0" />
        <Parameter Name="signatureFormat" Type="System.Security.Cryptography.DSASignatureFormat" Index="2" FrameworkAlternate="net-5.0" />
      </Parameters>
      <Docs>
        <param name="data"><span data-ttu-id="f2b80-320">要签名的数据。</span><span class="sxs-lookup"><span data-stu-id="f2b80-320">The data to sign.</span></span></param>
        <param name="hashAlgorithm"><span data-ttu-id="f2b80-321">要用于创建哈希值的哈希算法。</span><span class="sxs-lookup"><span data-stu-id="f2b80-321">The hash algorithm to use to create the hash value.</span></span></param>
        <param name="signatureFormat"><span data-ttu-id="f2b80-322">要用于签名的编码格式。</span><span class="sxs-lookup"><span data-stu-id="f2b80-322">The encoding format to use for the signature.</span></span></param>
        <summary><span data-ttu-id="f2b80-323">计算指定数据的哈希值，并使用指定的签名格式对其进行签名。</span><span class="sxs-lookup"><span data-stu-id="f2b80-323">Computes the hash value of the specified data and signs it using the specified signature format.</span></span></summary>
        <returns><span data-ttu-id="f2b80-324">指定数据的 ECDSA 签名。</span><span class="sxs-lookup"><span data-stu-id="f2b80-324">The ECDSA signature for the specified data.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f2b80-325"><paramref name="data" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="f2b80-325"><paramref name="data" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="f2b80-326"><paramref name="signatureFormat" /> 不是已知格式。</span><span class="sxs-lookup"><span data-stu-id="f2b80-326"><paramref name="signatureFormat" /> is not a known format.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="f2b80-327"><paramref name="hashAlgorithm" /> 具有 <see langword="null" /> 或空的 <see cref="P:System.Security.Cryptography.HashAlgorithmName.Name" />。</span><span class="sxs-lookup"><span data-stu-id="f2b80-327"><paramref name="hashAlgorithm" /> has a <see langword="null" /> or empty <see cref="P:System.Security.Cryptography.HashAlgorithmName.Name" />.</span></span></exception>
        <exception cref="T:System.Security.Cryptography.CryptographicException"><span data-ttu-id="f2b80-328">哈希处理或签名时出错。</span><span class="sxs-lookup"><span data-stu-id="f2b80-328">An error occurred in the hashing or signing operation.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="SignData">
      <MemberSignature Language="C#" Value="public virtual byte[] SignData (byte[] data, int offset, int count, System.Security.Cryptography.HashAlgorithmName hashAlgorithm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance unsigned int8[] SignData(unsigned int8[] data, int32 offset, int32 count, valuetype System.Security.Cryptography.HashAlgorithmName hashAlgorithm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDsa.SignData(System.Byte[],System.Int32,System.Int32,System.Security.Cryptography.HashAlgorithmName)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function SignData (data As Byte(), offset As Integer, count As Integer, hashAlgorithm As HashAlgorithmName) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Byte&gt; ^ SignData(cli::array &lt;System::Byte&gt; ^ data, int offset, int count, System::Security::Cryptography::HashAlgorithmName hashAlgorithm);" />
      <MemberSignature Language="F#" Value="abstract member SignData : byte[] * int * int * System.Security.Cryptography.HashAlgorithmName -&gt; byte[]&#xA;override this.SignData : byte[] * int * int * System.Security.Cryptography.HashAlgorithmName -&gt; byte[]" Usage="eCDsa.SignData (data, offset, count, hashAlgorithm)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.3.0.0</AssemblyVersion>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
        <AssemblyVersion>4.3.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Byte[]" Index="0" FrameworkAlternate="net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="hashAlgorithm" Type="System.Security.Cryptography.HashAlgorithmName" Index="3" FrameworkAlternate="net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="data"><span data-ttu-id="f2b80-329">要为其计算哈希的输入数据。</span><span class="sxs-lookup"><span data-stu-id="f2b80-329">The input data for which to compute the hash.</span></span></param>
        <param name="offset"><span data-ttu-id="f2b80-330">数组中自其开始使用数据的偏移量。</span><span class="sxs-lookup"><span data-stu-id="f2b80-330">The offset into the array at which to begin using data.</span></span></param>
        <param name="count"><span data-ttu-id="f2b80-331">数组中用作数据的字节数。</span><span class="sxs-lookup"><span data-stu-id="f2b80-331">The number of bytes in the array to use as data.</span></span></param>
        <param name="hashAlgorithm"><span data-ttu-id="f2b80-332">要用于创建哈希值的哈希算法。</span><span class="sxs-lookup"><span data-stu-id="f2b80-332">The hash algorithm to use to create the hash value.</span></span></param>
        <summary><span data-ttu-id="f2b80-333">使用指定的哈希算法计算指定字节数组的一个部分的哈希值，并对生成的哈希值进行签名。</span><span class="sxs-lookup"><span data-stu-id="f2b80-333">Computes the hash value of a portion of the specified byte array using the specified hash algorithm and signs the resulting hash value.</span></span></summary>
        <returns><span data-ttu-id="f2b80-334">指定数据的 ECDSA 签名。</span><span class="sxs-lookup"><span data-stu-id="f2b80-334">The ECDSA signature for the specified data.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f2b80-335"><paramref name="data" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="f2b80-335"><paramref name="data" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="f2b80-336"><paramref name="hashAlgorithm" />.<see cref="P:System.Security.Cryptography.HashAlgorithmName.Name" /></span><span class="sxs-lookup"><span data-stu-id="f2b80-336"><paramref name="hashAlgorithm" />.<see cref="P:System.Security.Cryptography.HashAlgorithmName.Name" /></span></span> <span data-ttu-id="f2b80-337">为 <see langword="null" /> 或 <see cref="F:System.String.Empty" />。</span><span class="sxs-lookup"><span data-stu-id="f2b80-337">is <see langword="null" /> or <see cref="F:System.String.Empty" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="f2b80-338"><paramref name="offset" /> 小于零。</span><span class="sxs-lookup"><span data-stu-id="f2b80-338"><paramref name="offset" /> is less than zero.</span></span>  
  
<span data-ttu-id="f2b80-339">- 或 -</span><span class="sxs-lookup"><span data-stu-id="f2b80-339">-or-</span></span> 
 <span data-ttu-id="f2b80-340"><paramref name="count" /> 小于零。</span><span class="sxs-lookup"><span data-stu-id="f2b80-340"><paramref name="count" /> is less than zero.</span></span>  
  
<span data-ttu-id="f2b80-341">- 或 -</span><span class="sxs-lookup"><span data-stu-id="f2b80-341">-or-</span></span> 
 <span data-ttu-id="f2b80-342"><paramref name="offset" /> + <paramref name="count" /> - 1 会导致超出 <paramref name="data" /> 上限的索引。</span><span class="sxs-lookup"><span data-stu-id="f2b80-342"><paramref name="offset" /> + <paramref name="count" /> - 1 results in an index that is beyond the upper bound of <paramref name="data" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="SignData">
      <MemberSignature Language="C#" Value="public byte[] SignData (byte[] data, int offset, int count, System.Security.Cryptography.HashAlgorithmName hashAlgorithm, System.Security.Cryptography.DSASignatureFormat signatureFormat);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8[] SignData(unsigned int8[] data, int32 offset, int32 count, valuetype System.Security.Cryptography.HashAlgorithmName hashAlgorithm, valuetype System.Security.Cryptography.DSASignatureFormat signatureFormat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDsa.SignData(System.Byte[],System.Int32,System.Int32,System.Security.Cryptography.HashAlgorithmName,System.Security.Cryptography.DSASignatureFormat)" />
      <MemberSignature Language="VB.NET" Value="Public Function SignData (data As Byte(), offset As Integer, count As Integer, hashAlgorithm As HashAlgorithmName, signatureFormat As DSASignatureFormat) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Byte&gt; ^ SignData(cli::array &lt;System::Byte&gt; ^ data, int offset, int count, System::Security::Cryptography::HashAlgorithmName hashAlgorithm, System::Security::Cryptography::DSASignatureFormat signatureFormat);" />
      <MemberSignature Language="F#" Value="member this.SignData : byte[] * int * int * System.Security.Cryptography.HashAlgorithmName * System.Security.Cryptography.DSASignatureFormat -&gt; byte[]" Usage="eCDsa.SignData (data, offset, count, hashAlgorithm, signatureFormat)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Byte[]" Index="0" FrameworkAlternate="net-5.0" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="net-5.0" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="net-5.0" />
        <Parameter Name="hashAlgorithm" Type="System.Security.Cryptography.HashAlgorithmName" Index="3" FrameworkAlternate="net-5.0" />
        <Parameter Name="signatureFormat" Type="System.Security.Cryptography.DSASignatureFormat" Index="4" FrameworkAlternate="net-5.0" />
      </Parameters>
      <Docs>
        <param name="data"><span data-ttu-id="f2b80-343">要签名的数据。</span><span class="sxs-lookup"><span data-stu-id="f2b80-343">The data to sign.</span></span></param>
        <param name="offset"><span data-ttu-id="f2b80-344"><paramref name="data" /> 中自其开始使用哈希处理的偏移量。</span><span class="sxs-lookup"><span data-stu-id="f2b80-344">The offset into <paramref name="data" /> at which to begin hashing.</span></span></param>
        <param name="count"><span data-ttu-id="f2b80-345">要从 <paramref name="data" /> 中读取的字节数。</span><span class="sxs-lookup"><span data-stu-id="f2b80-345">The number of bytes to read from <paramref name="data" />.</span></span></param>
        <param name="hashAlgorithm"><span data-ttu-id="f2b80-346">要用于创建哈希值的哈希算法。</span><span class="sxs-lookup"><span data-stu-id="f2b80-346">The hash algorithm to use to create the hash value.</span></span></param>
        <param name="signatureFormat"><span data-ttu-id="f2b80-347">要用于签名的编码格式。</span><span class="sxs-lookup"><span data-stu-id="f2b80-347">The encoding format to use for the signature.</span></span></param>
        <summary><span data-ttu-id="f2b80-348">计算指定数据的哈希值，并使用指定的签名格式对其进行签名。</span><span class="sxs-lookup"><span data-stu-id="f2b80-348">Computes the hash value of the specified data and signs it using the specified signature format.</span></span></summary>
        <returns><span data-ttu-id="f2b80-349">指定数据的 ECDSA 签名。</span><span class="sxs-lookup"><span data-stu-id="f2b80-349">The ECDSA signature for the specified data.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f2b80-350"><paramref name="data" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="f2b80-350"><paramref name="data" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="f2b80-351"><paramref name="signatureFormat" /> 不是已知格式。</span><span class="sxs-lookup"><span data-stu-id="f2b80-351"><paramref name="signatureFormat" /> is not a known format.</span></span>
 
<span data-ttu-id="f2b80-352">- 或 -</span><span class="sxs-lookup"><span data-stu-id="f2b80-352">-or-</span></span> 
 <span data-ttu-id="f2b80-353"><paramref name="offset" /> 小于零。</span><span class="sxs-lookup"><span data-stu-id="f2b80-353"><paramref name="offset" /> is less than zero.</span></span>
 
<span data-ttu-id="f2b80-354">- 或 -</span><span class="sxs-lookup"><span data-stu-id="f2b80-354">-or-</span></span> 
 <span data-ttu-id="f2b80-355"><paramref name="count" /> 小于零。</span><span class="sxs-lookup"><span data-stu-id="f2b80-355"><paramref name="count" /> is less than zero.</span></span>
 
<span data-ttu-id="f2b80-356">- 或 -</span><span class="sxs-lookup"><span data-stu-id="f2b80-356">-or-</span></span> 
 <span data-ttu-id="f2b80-357"><paramref name="offset" /> + <paramref name="count" /> - 1 会导致超出 <paramref name="data" /> 上限的索引。</span><span class="sxs-lookup"><span data-stu-id="f2b80-357"><paramref name="offset" /> + <paramref name="count" /> - 1 results in an index that is beyond the upper bound of <paramref name="data" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="f2b80-358"><paramref name="hashAlgorithm" /> 具有 <see langword="null" /> 或空的 <see cref="P:System.Security.Cryptography.HashAlgorithmName.Name" />。</span><span class="sxs-lookup"><span data-stu-id="f2b80-358"><paramref name="hashAlgorithm" /> has a <see langword="null" /> or empty <see cref="P:System.Security.Cryptography.HashAlgorithmName.Name" />.</span></span></exception>
        <exception cref="T:System.Security.Cryptography.CryptographicException"><span data-ttu-id="f2b80-359">哈希处理或签名时出错。</span><span class="sxs-lookup"><span data-stu-id="f2b80-359">An error occurred in the hashing or signing operation.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="SignDataCore">
      <MemberSignature Language="C#" Value="protected virtual byte[] SignDataCore (System.IO.Stream data, System.Security.Cryptography.HashAlgorithmName hashAlgorithm, System.Security.Cryptography.DSASignatureFormat signatureFormat);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance unsigned int8[] SignDataCore(class System.IO.Stream data, valuetype System.Security.Cryptography.HashAlgorithmName hashAlgorithm, valuetype System.Security.Cryptography.DSASignatureFormat signatureFormat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDsa.SignDataCore(System.IO.Stream,System.Security.Cryptography.HashAlgorithmName,System.Security.Cryptography.DSASignatureFormat)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function SignDataCore (data As Stream, hashAlgorithm As HashAlgorithmName, signatureFormat As DSASignatureFormat) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual cli::array &lt;System::Byte&gt; ^ SignDataCore(System::IO::Stream ^ data, System::Security::Cryptography::HashAlgorithmName hashAlgorithm, System::Security::Cryptography::DSASignatureFormat signatureFormat);" />
      <MemberSignature Language="F#" Value="abstract member SignDataCore : System.IO.Stream * System.Security.Cryptography.HashAlgorithmName * System.Security.Cryptography.DSASignatureFormat -&gt; byte[]&#xA;override this.SignDataCore : System.IO.Stream * System.Security.Cryptography.HashAlgorithmName * System.Security.Cryptography.DSASignatureFormat -&gt; byte[]" Usage="eCDsa.SignDataCore (data, hashAlgorithm, signatureFormat)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.IO.Stream" Index="0" FrameworkAlternate="net-5.0" />
        <Parameter Name="hashAlgorithm" Type="System.Security.Cryptography.HashAlgorithmName" Index="1" FrameworkAlternate="net-5.0" />
        <Parameter Name="signatureFormat" Type="System.Security.Cryptography.DSASignatureFormat" Index="2" FrameworkAlternate="net-5.0" />
      </Parameters>
      <Docs>
        <param name="data"><span data-ttu-id="f2b80-360">要签名的数据。</span><span class="sxs-lookup"><span data-stu-id="f2b80-360">The data to sign.</span></span></param>
        <param name="hashAlgorithm"><span data-ttu-id="f2b80-361">要用于创建哈希值的哈希算法。</span><span class="sxs-lookup"><span data-stu-id="f2b80-361">The hash algorithm to use to create the hash value.</span></span></param>
        <param name="signatureFormat"><span data-ttu-id="f2b80-362">要用于签名的编码格式。</span><span class="sxs-lookup"><span data-stu-id="f2b80-362">The encoding format to use for the signature.</span></span></param>
        <summary><span data-ttu-id="f2b80-363">计算指定数据的哈希值，并使用指定的签名格式对其进行签名。</span><span class="sxs-lookup"><span data-stu-id="f2b80-363">Computes the hash value of the specified data and signs it using the specified signature format.</span></span></summary>
        <returns><span data-ttu-id="f2b80-364">指定数据的 ECDSA 签名。</span><span class="sxs-lookup"><span data-stu-id="f2b80-364">The ECDSA signature for the specified data.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException"><span data-ttu-id="f2b80-365">哈希处理或签名时出错。</span><span class="sxs-lookup"><span data-stu-id="f2b80-365">An error occurred in the hashing or signing operation.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="SignDataCore">
      <MemberSignature Language="C#" Value="protected virtual byte[]? SignDataCore (ReadOnlySpan&lt;byte&gt; data, System.Security.Cryptography.HashAlgorithmName hashAlgorithm, System.Security.Cryptography.DSASignatureFormat signatureFormat);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance unsigned int8[] SignDataCore(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; data, valuetype System.Security.Cryptography.HashAlgorithmName hashAlgorithm, valuetype System.Security.Cryptography.DSASignatureFormat signatureFormat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDsa.SignDataCore(System.ReadOnlySpan{System.Byte},System.Security.Cryptography.HashAlgorithmName,System.Security.Cryptography.DSASignatureFormat)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function SignDataCore (data As ReadOnlySpan(Of Byte), hashAlgorithm As HashAlgorithmName, signatureFormat As DSASignatureFormat) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual cli::array &lt;System::Byte&gt; ^ SignDataCore(ReadOnlySpan&lt;System::Byte&gt; data, System::Security::Cryptography::HashAlgorithmName hashAlgorithm, System::Security::Cryptography::DSASignatureFormat signatureFormat);" />
      <MemberSignature Language="F#" Value="abstract member SignDataCore : ReadOnlySpan&lt;byte&gt; * System.Security.Cryptography.HashAlgorithmName * System.Security.Cryptography.DSASignatureFormat -&gt; byte[]&#xA;override this.SignDataCore : ReadOnlySpan&lt;byte&gt; * System.Security.Cryptography.HashAlgorithmName * System.Security.Cryptography.DSASignatureFormat -&gt; byte[]" Usage="eCDsa.SignDataCore (data, hashAlgorithm, signatureFormat)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="0" FrameworkAlternate="net-5.0" />
        <Parameter Name="hashAlgorithm" Type="System.Security.Cryptography.HashAlgorithmName" Index="1" FrameworkAlternate="net-5.0" />
        <Parameter Name="signatureFormat" Type="System.Security.Cryptography.DSASignatureFormat" Index="2" FrameworkAlternate="net-5.0" />
      </Parameters>
      <Docs>
        <param name="data"><span data-ttu-id="f2b80-366">要签名的数据。</span><span class="sxs-lookup"><span data-stu-id="f2b80-366">The data to sign.</span></span></param>
        <param name="hashAlgorithm"><span data-ttu-id="f2b80-367">要用于创建哈希值的哈希算法。</span><span class="sxs-lookup"><span data-stu-id="f2b80-367">The hash algorithm to use to create the hash value.</span></span></param>
        <param name="signatureFormat"><span data-ttu-id="f2b80-368">要用于签名的编码格式。</span><span class="sxs-lookup"><span data-stu-id="f2b80-368">The encoding format to use for the signature.</span></span></param>
        <summary><span data-ttu-id="f2b80-369">计算指定数据的哈希值，并使用指定的签名格式对其进行签名。</span><span class="sxs-lookup"><span data-stu-id="f2b80-369">Computes the hash value of the specified data and signs it using the specified signature format.</span></span></summary>
        <returns><span data-ttu-id="f2b80-370">指定数据的 ECDSA 签名。</span><span class="sxs-lookup"><span data-stu-id="f2b80-370">The ECDSA signature for the specified data.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException"><span data-ttu-id="f2b80-371">哈希处理或签名时出错。</span><span class="sxs-lookup"><span data-stu-id="f2b80-371">An error occurred in the hashing or signing operation.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="SignHash">
      <MemberSignature Language="C#" Value="public abstract byte[] SignHash (byte[] hash);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance unsigned int8[] SignHash(unsigned int8[] hash) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDsa.SignHash(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function SignHash (hash As Byte()) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;System::Byte&gt; ^ SignHash(cli::array &lt;System::Byte&gt; ^ hash);" />
      <MemberSignature Language="F#" Value="abstract member SignHash : byte[] -&gt; byte[]" Usage="eCDsa.SignHash hash" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.3.0.0</AssemblyVersion>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
        <AssemblyVersion>4.3.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="hash" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="hash"><span data-ttu-id="f2b80-372">待签名数据的哈希值。</span><span class="sxs-lookup"><span data-stu-id="f2b80-372">The hash value of the data that is being signed.</span></span></param>
        <summary><span data-ttu-id="f2b80-373">为指定的哈希值生成数字签名。</span><span class="sxs-lookup"><span data-stu-id="f2b80-373">Generates a digital signature for the specified hash value.</span></span></summary>
        <returns><span data-ttu-id="f2b80-374">指定哈希值的数字签名。</span><span class="sxs-lookup"><span data-stu-id="f2b80-374">A digital signature for the specified hash value.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f2b80-375"><paramref name="hash" /> 参数为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="f2b80-375">The <paramref name="hash" /> parameter is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="SignHash">
      <MemberSignature Language="C#" Value="public byte[] SignHash (byte[] hash, System.Security.Cryptography.DSASignatureFormat signatureFormat);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8[] SignHash(unsigned int8[] hash, valuetype System.Security.Cryptography.DSASignatureFormat signatureFormat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDsa.SignHash(System.Byte[],System.Security.Cryptography.DSASignatureFormat)" />
      <MemberSignature Language="VB.NET" Value="Public Function SignHash (hash As Byte(), signatureFormat As DSASignatureFormat) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Byte&gt; ^ SignHash(cli::array &lt;System::Byte&gt; ^ hash, System::Security::Cryptography::DSASignatureFormat signatureFormat);" />
      <MemberSignature Language="F#" Value="member this.SignHash : byte[] * System.Security.Cryptography.DSASignatureFormat -&gt; byte[]" Usage="eCDsa.SignHash (hash, signatureFormat)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="hash" Type="System.Byte[]" Index="0" FrameworkAlternate="net-5.0" />
        <Parameter Name="signatureFormat" Type="System.Security.Cryptography.DSASignatureFormat" Index="1" FrameworkAlternate="net-5.0" />
      </Parameters>
      <Docs>
        <param name="hash"><span data-ttu-id="f2b80-376">要签名的哈希值。</span><span class="sxs-lookup"><span data-stu-id="f2b80-376">The hash value to sign.</span></span></param>
        <param name="signatureFormat"><span data-ttu-id="f2b80-377">要用于签名的编码格式。</span><span class="sxs-lookup"><span data-stu-id="f2b80-377">The encoding format to use for the signature.</span></span></param>
        <summary><span data-ttu-id="f2b80-378">采用指定格式为指定的哈希值计算 ECDSA 签名。</span><span class="sxs-lookup"><span data-stu-id="f2b80-378">Computes the ECDSA signature for the specified hash value in the indicated format.</span></span></summary>
        <returns><span data-ttu-id="f2b80-379">指定数据的 ECDSA 签名。</span><span class="sxs-lookup"><span data-stu-id="f2b80-379">The ECDSA signature for the specified data.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f2b80-380"><paramref name="hash" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="f2b80-380"><paramref name="hash" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="f2b80-381"><paramref name="signatureFormat" /> 不是已知格式。</span><span class="sxs-lookup"><span data-stu-id="f2b80-381"><paramref name="signatureFormat" /> is not a known format.</span></span></exception>
        <exception cref="T:System.Security.Cryptography.CryptographicException"><span data-ttu-id="f2b80-382">签名时出错。</span><span class="sxs-lookup"><span data-stu-id="f2b80-382">An error occurred in the signing operation.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="SignHashCore">
      <MemberSignature Language="C#" Value="protected virtual byte[]? SignHashCore (ReadOnlySpan&lt;byte&gt; hash, System.Security.Cryptography.DSASignatureFormat signatureFormat);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance unsigned int8[] SignHashCore(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; hash, valuetype System.Security.Cryptography.DSASignatureFormat signatureFormat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDsa.SignHashCore(System.ReadOnlySpan{System.Byte},System.Security.Cryptography.DSASignatureFormat)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function SignHashCore (hash As ReadOnlySpan(Of Byte), signatureFormat As DSASignatureFormat) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual cli::array &lt;System::Byte&gt; ^ SignHashCore(ReadOnlySpan&lt;System::Byte&gt; hash, System::Security::Cryptography::DSASignatureFormat signatureFormat);" />
      <MemberSignature Language="F#" Value="abstract member SignHashCore : ReadOnlySpan&lt;byte&gt; * System.Security.Cryptography.DSASignatureFormat -&gt; byte[]&#xA;override this.SignHashCore : ReadOnlySpan&lt;byte&gt; * System.Security.Cryptography.DSASignatureFormat -&gt; byte[]" Usage="eCDsa.SignHashCore (hash, signatureFormat)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="hash" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="0" FrameworkAlternate="net-5.0" />
        <Parameter Name="signatureFormat" Type="System.Security.Cryptography.DSASignatureFormat" Index="1" FrameworkAlternate="net-5.0" />
      </Parameters>
      <Docs>
        <param name="hash"><span data-ttu-id="f2b80-383">要签名的哈希值。</span><span class="sxs-lookup"><span data-stu-id="f2b80-383">The hash value to sign.</span></span></param>
        <param name="signatureFormat"><span data-ttu-id="f2b80-384">要用于签名的编码格式。</span><span class="sxs-lookup"><span data-stu-id="f2b80-384">The encoding format to use for the signature.</span></span></param>
        <summary><span data-ttu-id="f2b80-385">采用指定格式为指定的哈希值计算 ECDSA 签名。</span><span class="sxs-lookup"><span data-stu-id="f2b80-385">Computes the ECDSA signature for the specified hash value in the indicated format.</span></span></summary>
        <returns><span data-ttu-id="f2b80-386">指定数据的 ECDSA 签名。</span><span class="sxs-lookup"><span data-stu-id="f2b80-386">The ECDSA signature for the specified data.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException"><span data-ttu-id="f2b80-387">签名时出错。</span><span class="sxs-lookup"><span data-stu-id="f2b80-387">An error occurred in the signing operation.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ToXmlString">
      <MemberSignature Language="C#" Value="public override string ToXmlString (bool includePrivateParameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToXmlString(bool includePrivateParameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDsa.ToXmlString(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToXmlString (includePrivateParameters As Boolean) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToXmlString(bool includePrivateParameters);" />
      <MemberSignature Language="F#" Value="override this.ToXmlString : bool -&gt; string" Usage="eCDsa.ToXmlString includePrivateParameters" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.3.0.0</AssemblyVersion>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
        <AssemblyVersion>4.3.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="includePrivateParameters" Type="System.Boolean" Index="0" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="includePrivateParameters"><span data-ttu-id="f2b80-388">若要包含专用参数，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="f2b80-388"><see langword="true" /> to include private parameters; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="f2b80-389">在所有情况下均引发此方法。</span><span class="sxs-lookup"><span data-stu-id="f2b80-389">This method throws in all cases.</span></span></summary>
        <returns><span data-ttu-id="f2b80-390">此方法不返回值。</span><span class="sxs-lookup"><span data-stu-id="f2b80-390">This method does not return a value.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotImplementedException"><span data-ttu-id="f2b80-391">在所有情况下。</span><span class="sxs-lookup"><span data-stu-id="f2b80-391">In all cases.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="TryExportECPrivateKey">
      <MemberSignature Language="C#" Value="public virtual bool TryExportECPrivateKey (Span&lt;byte&gt; destination, out int bytesWritten);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryExportECPrivateKey(valuetype System.Span`1&lt;unsigned int8&gt; destination, [out] int32&amp; bytesWritten) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDsa.TryExportECPrivateKey(System.Span{System.Byte},System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function TryExportECPrivateKey (destination As Span(Of Byte), ByRef bytesWritten As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool TryExportECPrivateKey(Span&lt;System::Byte&gt; destination, [Runtime::InteropServices::Out] int % bytesWritten);" />
      <MemberSignature Language="F#" Value="abstract member TryExportECPrivateKey : Span&lt;byte&gt; * int -&gt; bool&#xA;override this.TryExportECPrivateKey : Span&lt;byte&gt; * int -&gt; bool" Usage="eCDsa.TryExportECPrivateKey (destination, bytesWritten)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
        <AssemblyVersion>4.3.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" Index="0" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netstandard-2.1" />
        <Parameter Name="bytesWritten" Type="System.Int32" RefType="out" Index="1" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="destination"><span data-ttu-id="f2b80-392">用于接收 ECPrivateKey 数据的字节范围。</span><span class="sxs-lookup"><span data-stu-id="f2b80-392">The byte span to receive the ECPrivateKey data.</span></span></param>
        <param name="bytesWritten"><span data-ttu-id="f2b80-393">此方法返回时，包含一个指示写入 <paramref name="destination" /> 的字节数的值。</span><span class="sxs-lookup"><span data-stu-id="f2b80-393">When this method returns, contains a value that indicates the number of bytes written to <paramref name="destination" />.</span></span> <span data-ttu-id="f2b80-394">该参数未经初始化即被处理。</span><span class="sxs-lookup"><span data-stu-id="f2b80-394">This parameter is treated as uninitialized.</span></span></param>
        <summary><span data-ttu-id="f2b80-395">尝试以 ECPrivateKey 格式将当前密钥导入所提供的缓冲区。</span><span class="sxs-lookup"><span data-stu-id="f2b80-395">Attempts to export the current key in the ECPrivateKey format into a provided buffer.</span></span></summary>
        <returns><span data-ttu-id="f2b80-396">如果 <paramref name="destination" /> 具有足够的大小以接收输出，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="f2b80-396"><see langword="true" /> if <paramref name="destination" /> is big enough to receive the output; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException"><span data-ttu-id="f2b80-397">未能导出密钥。</span><span class="sxs-lookup"><span data-stu-id="f2b80-397">The key could not be exported.</span></span></exception>
        <altmember cref="M:System.Security.Cryptography.ECDsa.ExportECPrivateKey" />
      </Docs>
    </Member>
    <Member MemberName="TryExportEncryptedPkcs8PrivateKey">
      <MemberSignature Language="C#" Value="public override bool TryExportEncryptedPkcs8PrivateKey (ReadOnlySpan&lt;byte&gt; passwordBytes, System.Security.Cryptography.PbeParameters? pbeParameters, Span&lt;byte&gt; destination, out int bytesWritten);" FrameworkAlternate="net-5.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool TryExportEncryptedPkcs8PrivateKey(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; passwordBytes, class System.Security.Cryptography.PbeParameters pbeParameters, valuetype System.Span`1&lt;unsigned int8&gt; destination, [out] int32&amp; bytesWritten) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDsa.TryExportEncryptedPkcs8PrivateKey(System.ReadOnlySpan{System.Byte},System.Security.Cryptography.PbeParameters,System.Span{System.Byte},System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function TryExportEncryptedPkcs8PrivateKey (passwordBytes As ReadOnlySpan(Of Byte), pbeParameters As PbeParameters, destination As Span(Of Byte), ByRef bytesWritten As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool TryExportEncryptedPkcs8PrivateKey(ReadOnlySpan&lt;System::Byte&gt; passwordBytes, System::Security::Cryptography::PbeParameters ^ pbeParameters, Span&lt;System::Byte&gt; destination, [Runtime::InteropServices::Out] int % bytesWritten);" />
      <MemberSignature Language="F#" Value="override this.TryExportEncryptedPkcs8PrivateKey : ReadOnlySpan&lt;byte&gt; * System.Security.Cryptography.PbeParameters * Span&lt;byte&gt; * int -&gt; bool" Usage="eCDsa.TryExportEncryptedPkcs8PrivateKey (passwordBytes, pbeParameters, destination, bytesWritten)" />
      <MemberSignature Language="C#" Value="public override bool TryExportEncryptedPkcs8PrivateKey (ReadOnlySpan&lt;byte&gt; passwordBytes, System.Security.Cryptography.PbeParameters pbeParameters, Span&lt;byte&gt; destination, out int bytesWritten);" FrameworkAlternate="netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
        <AssemblyVersion>4.3.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="passwordBytes" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="0" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
        <Parameter Name="pbeParameters" Type="System.Security.Cryptography.PbeParameters" Index="1" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" Index="2" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
        <Parameter Name="bytesWritten" Type="System.Int32" RefType="out" Index="3" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="passwordBytes"><span data-ttu-id="f2b80-398">加密密钥材料时用作密码的字节。</span><span class="sxs-lookup"><span data-stu-id="f2b80-398">The bytes to use as a password when encrypting the key material.</span></span></param>
        <param name="pbeParameters"><span data-ttu-id="f2b80-399">加密密钥材料时使用的基于密码加密 (PBE) 参数。</span><span class="sxs-lookup"><span data-stu-id="f2b80-399">The password-based encryption (PBE) parameters to use when encrypting the key material.</span></span></param>
        <param name="destination"><span data-ttu-id="f2b80-400">接收 PKCS#8 EncryptedPrivateKeyInfo 数据的字节范围。</span><span class="sxs-lookup"><span data-stu-id="f2b80-400">The byte span to receive the PKCS#8 EncryptedPrivateKeyInfo data.</span></span></param>
        <param name="bytesWritten"><span data-ttu-id="f2b80-401">此方法返回时，包含一个指示写入 <paramref name="destination" /> 的字节数的值。</span><span class="sxs-lookup"><span data-stu-id="f2b80-401">When this method returns, contains a value that indicates the number of bytes written to <paramref name="destination" />.</span></span> <span data-ttu-id="f2b80-402">该参数未经初始化即被处理。</span><span class="sxs-lookup"><span data-stu-id="f2b80-402">This parameter is treated as uninitialized.</span></span></param>
        <summary><span data-ttu-id="f2b80-403">尝试使用基于字节的密码以 PKCS#8 EncryptedPrivateKeyInfo 格式将当前密钥导出到所提供的缓冲区。</span><span class="sxs-lookup"><span data-stu-id="f2b80-403">Attempts to export the current key in the PKCS#8 EncryptedPrivateKeyInfo format into a provided buffer, using a byte-based password.</span></span></summary>
        <returns><span data-ttu-id="f2b80-404">如果 <paramref name="destination" /> 具有足够的大小以接收输出，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="f2b80-404"><see langword="true" /> if <paramref name="destination" /> is big enough to receive the output; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f2b80-405">密码字节直接传递到密钥派生函数 (KDF) 使用的算法所使用的算法 `pbeParameters` 。</span><span class="sxs-lookup"><span data-stu-id="f2b80-405">The password bytes are passed directly into the Key Derivation Function (KDF) used by the algorithm indicated by `pbeParameters`.</span></span>
<span data-ttu-id="f2b80-406">这样，在使用 PBKDF2 处理密码时，与使用 UTF-8 以外的文本编码的其他系统兼容， (基于密码的密钥派生函数 2) 。</span><span class="sxs-lookup"><span data-stu-id="f2b80-406">This enables compatibility with other systems which use a text encoding other than UTF-8 when processing passwords with PBKDF2 (Password-Based Key Derivation Function 2).</span></span>
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException"><span data-ttu-id="f2b80-407">未能导出密钥。</span><span class="sxs-lookup"><span data-stu-id="f2b80-407">The key could not be exported.</span></span>

<span data-ttu-id="f2b80-408">- 或 -</span><span class="sxs-lookup"><span data-stu-id="f2b80-408">-or-</span></span>

<span data-ttu-id="f2b80-409"><paramref name="pbeParameters" /> 指示应使用需要基于 <see cref="T:System.Char" /> 密码的 <see cref="F:System.Security.Cryptography.PbeEncryptionAlgorithm.TripleDes3KeyPkcs12" />。</span><span class="sxs-lookup"><span data-stu-id="f2b80-409"><paramref name="pbeParameters" /> indicates that <see cref="F:System.Security.Cryptography.PbeEncryptionAlgorithm.TripleDes3KeyPkcs12" /> should be used, which requires <see cref="T:System.Char" />-based passwords.</span></span></exception>
        <altmember cref="Overload:System.Security.Cryptography.AsymmetricAlgorithm.ExportEncryptedPkcs8PrivateKey" />
      </Docs>
    </Member>
    <Member MemberName="TryExportEncryptedPkcs8PrivateKey">
      <MemberSignature Language="C#" Value="public override bool TryExportEncryptedPkcs8PrivateKey (ReadOnlySpan&lt;char&gt; password, System.Security.Cryptography.PbeParameters? pbeParameters, Span&lt;byte&gt; destination, out int bytesWritten);" FrameworkAlternate="net-5.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool TryExportEncryptedPkcs8PrivateKey(valuetype System.ReadOnlySpan`1&lt;char&gt; password, class System.Security.Cryptography.PbeParameters pbeParameters, valuetype System.Span`1&lt;unsigned int8&gt; destination, [out] int32&amp; bytesWritten) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDsa.TryExportEncryptedPkcs8PrivateKey(System.ReadOnlySpan{System.Char},System.Security.Cryptography.PbeParameters,System.Span{System.Byte},System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function TryExportEncryptedPkcs8PrivateKey (password As ReadOnlySpan(Of Char), pbeParameters As PbeParameters, destination As Span(Of Byte), ByRef bytesWritten As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool TryExportEncryptedPkcs8PrivateKey(ReadOnlySpan&lt;char&gt; password, System::Security::Cryptography::PbeParameters ^ pbeParameters, Span&lt;System::Byte&gt; destination, [Runtime::InteropServices::Out] int % bytesWritten);" />
      <MemberSignature Language="F#" Value="override this.TryExportEncryptedPkcs8PrivateKey : ReadOnlySpan&lt;char&gt; * System.Security.Cryptography.PbeParameters * Span&lt;byte&gt; * int -&gt; bool" Usage="eCDsa.TryExportEncryptedPkcs8PrivateKey (password, pbeParameters, destination, bytesWritten)" />
      <MemberSignature Language="C#" Value="public override bool TryExportEncryptedPkcs8PrivateKey (ReadOnlySpan&lt;char&gt; password, System.Security.Cryptography.PbeParameters pbeParameters, Span&lt;byte&gt; destination, out int bytesWritten);" FrameworkAlternate="netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
        <AssemblyVersion>4.3.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="password" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
        <Parameter Name="pbeParameters" Type="System.Security.Cryptography.PbeParameters" Index="1" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" Index="2" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
        <Parameter Name="bytesWritten" Type="System.Int32" RefType="out" Index="3" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="password"><span data-ttu-id="f2b80-410">加密密钥材料时使用的密码。</span><span class="sxs-lookup"><span data-stu-id="f2b80-410">The password to use when encrypting the key material.</span></span></param>
        <param name="pbeParameters"><span data-ttu-id="f2b80-411">加密密钥材料时使用的基于密码加密 (PBE) 参数。</span><span class="sxs-lookup"><span data-stu-id="f2b80-411">The password-based encryption (PBE) parameters to use when encrypting the key material.</span></span></param>
        <param name="destination"><span data-ttu-id="f2b80-412">接收 PKCS#8 EncryptedPrivateKeyInfo 数据的字节范围。</span><span class="sxs-lookup"><span data-stu-id="f2b80-412">The byte span to receive the PKCS#8 EncryptedPrivateKeyInfo data.</span></span></param>
        <param name="bytesWritten"><span data-ttu-id="f2b80-413">此方法返回时，包含一个指示写入 <paramref name="destination" /> 的字节数的值。</span><span class="sxs-lookup"><span data-stu-id="f2b80-413">When this method returns, contains a value that indicates the number of bytes written to <paramref name="destination" />.</span></span> <span data-ttu-id="f2b80-414">该参数未经初始化即被处理。</span><span class="sxs-lookup"><span data-stu-id="f2b80-414">This parameter is treated as uninitialized.</span></span></param>
        <summary><span data-ttu-id="f2b80-415">尝试使用基于字符的密码以 PKCS#8 EncryptedPrivateKeyInfo 格式将当前密钥导入所提供的缓冲区。</span><span class="sxs-lookup"><span data-stu-id="f2b80-415">Attempts to export the current key in the PKCS#8 EncryptedPrivateKeyInfo format into a provided buffer, using a char-based password.</span></span></summary>
        <returns><span data-ttu-id="f2b80-416">如果 <paramref name="destination" /> 具有足够的大小以接收输出，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="f2b80-416"><see langword="true" /> if <paramref name="destination" /> is big enough to receive the output; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f2b80-417">当 `pbeParameters` 指示使用 PBKDF2 (基于密码的密钥派生函数 2) 的算法时，密码将通过 utf-8 编码转换为字节。</span><span class="sxs-lookup"><span data-stu-id="f2b80-417">When `pbeParameters` indicates an algorithm that uses PBKDF2 (Password-Based Key Derivation Function 2), the password is converted to bytes via the UTF-8 encoding.</span></span>
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException"><span data-ttu-id="f2b80-418">未能导出密钥。</span><span class="sxs-lookup"><span data-stu-id="f2b80-418">The key could not be exported.</span></span></exception>
        <altmember cref="Overload:System.Security.Cryptography.AsymmetricAlgorithm.ExportEncryptedPkcs8PrivateKey" />
      </Docs>
    </Member>
    <Member MemberName="TryExportPkcs8PrivateKey">
      <MemberSignature Language="C#" Value="public override bool TryExportPkcs8PrivateKey (Span&lt;byte&gt; destination, out int bytesWritten);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool TryExportPkcs8PrivateKey(valuetype System.Span`1&lt;unsigned int8&gt; destination, [out] int32&amp; bytesWritten) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDsa.TryExportPkcs8PrivateKey(System.Span{System.Byte},System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function TryExportPkcs8PrivateKey (destination As Span(Of Byte), ByRef bytesWritten As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool TryExportPkcs8PrivateKey(Span&lt;System::Byte&gt; destination, [Runtime::InteropServices::Out] int % bytesWritten);" />
      <MemberSignature Language="F#" Value="override this.TryExportPkcs8PrivateKey : Span&lt;byte&gt; * int -&gt; bool" Usage="eCDsa.TryExportPkcs8PrivateKey (destination, bytesWritten)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
        <AssemblyVersion>4.3.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" Index="0" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
        <Parameter Name="bytesWritten" Type="System.Int32" RefType="out" Index="1" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="destination"><span data-ttu-id="f2b80-419">接收 PKCS#8 PrivateKeyInfo 数据的字节范围。</span><span class="sxs-lookup"><span data-stu-id="f2b80-419">The byte span to receive the PKCS#8 PrivateKeyInfo data.</span></span></param>
        <param name="bytesWritten"><span data-ttu-id="f2b80-420">此方法返回时，包含一个指示写入 <paramref name="destination" /> 的字节数的值。</span><span class="sxs-lookup"><span data-stu-id="f2b80-420">When this method returns, contains a value that indicates the number of bytes written to <paramref name="destination" />.</span></span> <span data-ttu-id="f2b80-421">该参数未经初始化即被处理。</span><span class="sxs-lookup"><span data-stu-id="f2b80-421">This parameter is treated as uninitialized.</span></span></param>
        <summary><span data-ttu-id="f2b80-422">尝试以 PKCS#8 PrivateKeyInfo 格式将当前密钥导出到所提供的缓冲区。</span><span class="sxs-lookup"><span data-stu-id="f2b80-422">Attempts to export the current key in the PKCS#8 PrivateKeyInfo format into a provided buffer.</span></span></summary>
        <returns><span data-ttu-id="f2b80-423">如果 <paramref name="destination" /> 具有足够的大小以接收输出，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="f2b80-423"><see langword="true" /> if <paramref name="destination" /> is big enough to receive the output; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException"><span data-ttu-id="f2b80-424">未能导出密钥。</span><span class="sxs-lookup"><span data-stu-id="f2b80-424">The key could not be exported.</span></span></exception>
        <altmember cref="Overload:System.Security.Cryptography.AsymmetricAlgorithm.ExportPkcs8PrivateKey" />
      </Docs>
    </Member>
    <Member MemberName="TryExportSubjectPublicKeyInfo">
      <MemberSignature Language="C#" Value="public override bool TryExportSubjectPublicKeyInfo (Span&lt;byte&gt; destination, out int bytesWritten);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool TryExportSubjectPublicKeyInfo(valuetype System.Span`1&lt;unsigned int8&gt; destination, [out] int32&amp; bytesWritten) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDsa.TryExportSubjectPublicKeyInfo(System.Span{System.Byte},System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function TryExportSubjectPublicKeyInfo (destination As Span(Of Byte), ByRef bytesWritten As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool TryExportSubjectPublicKeyInfo(Span&lt;System::Byte&gt; destination, [Runtime::InteropServices::Out] int % bytesWritten);" />
      <MemberSignature Language="F#" Value="override this.TryExportSubjectPublicKeyInfo : Span&lt;byte&gt; * int -&gt; bool" Usage="eCDsa.TryExportSubjectPublicKeyInfo (destination, bytesWritten)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
        <AssemblyVersion>4.3.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" Index="0" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
        <Parameter Name="bytesWritten" Type="System.Int32" RefType="out" Index="1" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="destination"><span data-ttu-id="f2b80-425">接收 X.509 SubjectPublicKeyInfo 数据的字节范围。</span><span class="sxs-lookup"><span data-stu-id="f2b80-425">The byte span to receive the X.509 SubjectPublicKeyInfo data.</span></span></param>
        <param name="bytesWritten"><span data-ttu-id="f2b80-426">此方法返回时，包含一个指示写入 <paramref name="destination" /> 的字节数的值。</span><span class="sxs-lookup"><span data-stu-id="f2b80-426">When this method returns, contains a value that indicates the number of bytes written to <paramref name="destination" />.</span></span> <span data-ttu-id="f2b80-427">该参数未经初始化即被处理。</span><span class="sxs-lookup"><span data-stu-id="f2b80-427">This parameter is treated as uninitialized.</span></span></param>
        <summary><span data-ttu-id="f2b80-428">尝试以 X.509 SubjectPublicKeyInfo 格式将当前密钥导出到所提供的缓冲区。</span><span class="sxs-lookup"><span data-stu-id="f2b80-428">Attempts to export the current key in the X.509 SubjectPublicKeyInfo format into a provided buffer.</span></span></summary>
        <returns><span data-ttu-id="f2b80-429">如果 <paramref name="destination" /> 具有足够的大小以接收输出，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="f2b80-429"><see langword="true" /> if <paramref name="destination" /> is big enough to receive the output; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException"><span data-ttu-id="f2b80-430">未能导出密钥。</span><span class="sxs-lookup"><span data-stu-id="f2b80-430">The key could not be exported.</span></span></exception>
        <altmember cref="Overload:System.Security.Cryptography.AsymmetricAlgorithm.ExportSubjectPublicKeyInfo" />
      </Docs>
    </Member>
    <Member MemberName="TryHashData">
      <MemberSignature Language="C#" Value="protected virtual bool TryHashData (ReadOnlySpan&lt;byte&gt; data, Span&lt;byte&gt; destination, System.Security.Cryptography.HashAlgorithmName hashAlgorithm, out int bytesWritten);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool TryHashData(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; data, valuetype System.Span`1&lt;unsigned int8&gt; destination, valuetype System.Security.Cryptography.HashAlgorithmName hashAlgorithm, [out] int32&amp; bytesWritten) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDsa.TryHashData(System.ReadOnlySpan{System.Byte},System.Span{System.Byte},System.Security.Cryptography.HashAlgorithmName,System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function TryHashData (data As ReadOnlySpan(Of Byte), destination As Span(Of Byte), hashAlgorithm As HashAlgorithmName, ByRef bytesWritten As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool TryHashData(ReadOnlySpan&lt;System::Byte&gt; data, Span&lt;System::Byte&gt; destination, System::Security::Cryptography::HashAlgorithmName hashAlgorithm, [Runtime::InteropServices::Out] int % bytesWritten);" />
      <MemberSignature Language="F#" Value="abstract member TryHashData : ReadOnlySpan&lt;byte&gt; * Span&lt;byte&gt; * System.Security.Cryptography.HashAlgorithmName * int -&gt; bool&#xA;override this.TryHashData : ReadOnlySpan&lt;byte&gt; * Span&lt;byte&gt; * System.Security.Cryptography.HashAlgorithmName * int -&gt; bool" Usage="eCDsa.TryHashData (data, destination, hashAlgorithm, bytesWritten)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
        <AssemblyVersion>4.3.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="0" FrameworkAlternate="net-5.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1" />
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" Index="1" FrameworkAlternate="net-5.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1" />
        <Parameter Name="hashAlgorithm" Type="System.Security.Cryptography.HashAlgorithmName" Index="2" FrameworkAlternate="net-5.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1" />
        <Parameter Name="bytesWritten" Type="System.Int32" RefType="out" Index="3" FrameworkAlternate="net-5.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="data"><span data-ttu-id="f2b80-431">要进行哈希处理的数据。</span><span class="sxs-lookup"><span data-stu-id="f2b80-431">The data to be hashed.</span></span></param>
        <param name="destination"><span data-ttu-id="f2b80-432">要接收哈希值的缓冲区。</span><span class="sxs-lookup"><span data-stu-id="f2b80-432">The buffer to receive the hash value.</span></span></param>
        <param name="hashAlgorithm"><span data-ttu-id="f2b80-433">要用于对数据进行哈希处理的算法。</span><span class="sxs-lookup"><span data-stu-id="f2b80-433">The algorithm to use to hash the data.</span></span></param>
        <param name="bytesWritten"><span data-ttu-id="f2b80-434">此方法返回时，为写入 <paramref name="destination" /> 的字节总数。</span><span class="sxs-lookup"><span data-stu-id="f2b80-434">When this method returns, the total number of bytes written into <paramref name="destination" />.</span></span> <span data-ttu-id="f2b80-435">该参数未经初始化即被处理。</span><span class="sxs-lookup"><span data-stu-id="f2b80-435">This parameter is treated as uninitialized.</span></span></param>
        <summary><span data-ttu-id="f2b80-436">尝试使用指定的哈希算法，将指定的只读字节范围的哈希值计算入提供的目标。</span><span class="sxs-lookup"><span data-stu-id="f2b80-436">Attempts to compute the hash value of the specified read-only span of bytes into the provided destination by using the specified hashing algorithm.</span></span></summary>
        <returns><span data-ttu-id="f2b80-437">如果 <paramref name="destination" /> 不够长，无法接收哈希值，则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="f2b80-437"><see langword="false" /> if <paramref name="destination" /> is not long enough to receive the hash value.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

<span data-ttu-id="f2b80-438">此方法的默认实现是调用 <xref:System.Security.Cryptography.ECDsa.HashData(System.Byte[],System.Int32,System.Int32,System.Security.Cryptography.HashAlgorithmName)> ，并将结果复制到 `destination` 。</span><span class="sxs-lookup"><span data-stu-id="f2b80-438">The default implementation of this method is to call <xref:System.Security.Cryptography.ECDsa.HashData(System.Byte[],System.Int32,System.Int32,System.Security.Cryptography.HashAlgorithmName)> and copy the result to `destination`.</span></span>
<span data-ttu-id="f2b80-439">派生类型应重写此方法，以避免中间数组创建。</span><span class="sxs-lookup"><span data-stu-id="f2b80-439">Derived types should override this method to avoid the intermediate array creation.</span></span>
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TrySignData">
      <MemberSignature Language="C#" Value="public virtual bool TrySignData (ReadOnlySpan&lt;byte&gt; data, Span&lt;byte&gt; destination, System.Security.Cryptography.HashAlgorithmName hashAlgorithm, out int bytesWritten);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TrySignData(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; data, valuetype System.Span`1&lt;unsigned int8&gt; destination, valuetype System.Security.Cryptography.HashAlgorithmName hashAlgorithm, [out] int32&amp; bytesWritten) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDsa.TrySignData(System.ReadOnlySpan{System.Byte},System.Span{System.Byte},System.Security.Cryptography.HashAlgorithmName,System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function TrySignData (data As ReadOnlySpan(Of Byte), destination As Span(Of Byte), hashAlgorithm As HashAlgorithmName, ByRef bytesWritten As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool TrySignData(ReadOnlySpan&lt;System::Byte&gt; data, Span&lt;System::Byte&gt; destination, System::Security::Cryptography::HashAlgorithmName hashAlgorithm, [Runtime::InteropServices::Out] int % bytesWritten);" />
      <MemberSignature Language="F#" Value="abstract member TrySignData : ReadOnlySpan&lt;byte&gt; * Span&lt;byte&gt; * System.Security.Cryptography.HashAlgorithmName * int -&gt; bool&#xA;override this.TrySignData : ReadOnlySpan&lt;byte&gt; * Span&lt;byte&gt; * System.Security.Cryptography.HashAlgorithmName * int -&gt; bool" Usage="eCDsa.TrySignData (data, destination, hashAlgorithm, bytesWritten)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
        <AssemblyVersion>4.3.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="0" FrameworkAlternate="net-5.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1" />
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" Index="1" FrameworkAlternate="net-5.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1" />
        <Parameter Name="hashAlgorithm" Type="System.Security.Cryptography.HashAlgorithmName" Index="2" FrameworkAlternate="net-5.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1" />
        <Parameter Name="bytesWritten" Type="System.Int32" RefType="out" Index="3" FrameworkAlternate="net-5.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="data"><span data-ttu-id="f2b80-440">要签名的数据。</span><span class="sxs-lookup"><span data-stu-id="f2b80-440">The data to be signed.</span></span></param>
        <param name="destination"><span data-ttu-id="f2b80-441">要接收签名的缓冲区。</span><span class="sxs-lookup"><span data-stu-id="f2b80-441">The buffer to receive the signature.</span></span></param>
        <param name="hashAlgorithm"><span data-ttu-id="f2b80-442">用于对签名的数据进行哈希处理的算法。</span><span class="sxs-lookup"><span data-stu-id="f2b80-442">The algorithm to use to hash the data for signing.</span></span></param>
        <param name="bytesWritten"><span data-ttu-id="f2b80-443">此方法返回时，为写入 <paramref name="destination" /> 的字节总数。</span><span class="sxs-lookup"><span data-stu-id="f2b80-443">When this method returns, the total number of bytes written into <paramref name="destination" />.</span></span> <span data-ttu-id="f2b80-444">该参数未经初始化即被处理。</span><span class="sxs-lookup"><span data-stu-id="f2b80-444">This parameter is treated as uninitialized.</span></span></param>
        <summary><span data-ttu-id="f2b80-445">尝试使用指定的哈希算法和当前密钥，将指定的只读字节范围的 ECDSA 数字签名计算入提供的目标。</span><span class="sxs-lookup"><span data-stu-id="f2b80-445">Attempts to compute the ECDSA digital signature for the specified read-only span of bytes into the provided destination by using the specified hashing algorithm and the current key.</span></span></summary>
        <returns><span data-ttu-id="f2b80-446">如果 <paramref name="destination" /> 不够长，无法接收签名，则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="f2b80-446"><see langword="false" /> if <paramref name="destination" /> is not long enough to receive the signature.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TrySignData">
      <MemberSignature Language="C#" Value="public bool TrySignData (ReadOnlySpan&lt;byte&gt; data, Span&lt;byte&gt; destination, System.Security.Cryptography.HashAlgorithmName hashAlgorithm, System.Security.Cryptography.DSASignatureFormat signatureFormat, out int bytesWritten);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TrySignData(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; data, valuetype System.Span`1&lt;unsigned int8&gt; destination, valuetype System.Security.Cryptography.HashAlgorithmName hashAlgorithm, valuetype System.Security.Cryptography.DSASignatureFormat signatureFormat, [out] int32&amp; bytesWritten) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDsa.TrySignData(System.ReadOnlySpan{System.Byte},System.Span{System.Byte},System.Security.Cryptography.HashAlgorithmName,System.Security.Cryptography.DSASignatureFormat,System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TrySignData (data As ReadOnlySpan(Of Byte), destination As Span(Of Byte), hashAlgorithm As HashAlgorithmName, signatureFormat As DSASignatureFormat, ByRef bytesWritten As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TrySignData(ReadOnlySpan&lt;System::Byte&gt; data, Span&lt;System::Byte&gt; destination, System::Security::Cryptography::HashAlgorithmName hashAlgorithm, System::Security::Cryptography::DSASignatureFormat signatureFormat, [Runtime::InteropServices::Out] int % bytesWritten);" />
      <MemberSignature Language="F#" Value="member this.TrySignData : ReadOnlySpan&lt;byte&gt; * Span&lt;byte&gt; * System.Security.Cryptography.HashAlgorithmName * System.Security.Cryptography.DSASignatureFormat * int -&gt; bool" Usage="eCDsa.TrySignData (data, destination, hashAlgorithm, signatureFormat, bytesWritten)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="0" FrameworkAlternate="net-5.0" />
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" Index="1" FrameworkAlternate="net-5.0" />
        <Parameter Name="hashAlgorithm" Type="System.Security.Cryptography.HashAlgorithmName" Index="2" FrameworkAlternate="net-5.0" />
        <Parameter Name="signatureFormat" Type="System.Security.Cryptography.DSASignatureFormat" Index="3" FrameworkAlternate="net-5.0" />
        <Parameter Name="bytesWritten" Type="System.Int32" RefType="out" Index="4" FrameworkAlternate="net-5.0" />
      </Parameters>
      <Docs>
        <param name="data"><span data-ttu-id="f2b80-447">要进行哈希处理和签名的数据。</span><span class="sxs-lookup"><span data-stu-id="f2b80-447">The data to hash and sign.</span></span></param>
        <param name="destination"><span data-ttu-id="f2b80-448">要接收签名的缓冲区。</span><span class="sxs-lookup"><span data-stu-id="f2b80-448">The buffer to receive the signature.</span></span></param>
        <param name="hashAlgorithm"><span data-ttu-id="f2b80-449">要用于创建哈希值的哈希算法。</span><span class="sxs-lookup"><span data-stu-id="f2b80-449">The hash algorithm to use to create the hash value.</span></span></param>
        <param name="signatureFormat"><span data-ttu-id="f2b80-450">要用于签名的编码格式。</span><span class="sxs-lookup"><span data-stu-id="f2b80-450">The encoding format to use for the signature.</span></span></param>
        <param name="bytesWritten"><span data-ttu-id="f2b80-451">此方法返回时，包含一个指示写入 <paramref name="destination" /> 的字节数的值。</span><span class="sxs-lookup"><span data-stu-id="f2b80-451">When this method returns, contains a value that indicates the number of bytes written to <paramref name="destination" />.</span></span> <span data-ttu-id="f2b80-452">该参数未经初始化即被处理。</span><span class="sxs-lookup"><span data-stu-id="f2b80-452">This parameter is treated as uninitialized.</span></span></param>
        <summary><span data-ttu-id="f2b80-453">尝试在提供的缓冲区中以指定的格式为指定的数据创建 ECDSA 签名。</span><span class="sxs-lookup"><span data-stu-id="f2b80-453">Attempts to create the ECDSA signature for the specified data in the indicated format into the provided buffer.</span></span></summary>
        <returns><span data-ttu-id="f2b80-454">如果 <paramref name="destination" /> 的大小足以接收签名，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="f2b80-454"><see langword="true" /> if <paramref name="destination" /> is big enough to receive the signature; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="f2b80-455"><paramref name="signatureFormat" /> 不是已知格式。</span><span class="sxs-lookup"><span data-stu-id="f2b80-455"><paramref name="signatureFormat" /> is not a known format.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="f2b80-456"><paramref name="hashAlgorithm" /> 具有 <see langword="null" /> 或空的 <see cref="P:System.Security.Cryptography.HashAlgorithmName.Name" />。</span><span class="sxs-lookup"><span data-stu-id="f2b80-456"><paramref name="hashAlgorithm" /> has a <see langword="null" /> or empty <see cref="P:System.Security.Cryptography.HashAlgorithmName.Name" />.</span></span></exception>
        <exception cref="T:System.Security.Cryptography.CryptographicException"><span data-ttu-id="f2b80-457">签名时出错。</span><span class="sxs-lookup"><span data-stu-id="f2b80-457">An error occurred in the signing operation.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="TrySignDataCore">
      <MemberSignature Language="C#" Value="protected virtual bool TrySignDataCore (ReadOnlySpan&lt;byte&gt; data, Span&lt;byte&gt; destination, System.Security.Cryptography.HashAlgorithmName hashAlgorithm, System.Security.Cryptography.DSASignatureFormat signatureFormat, out int bytesWritten);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool TrySignDataCore(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; data, valuetype System.Span`1&lt;unsigned int8&gt; destination, valuetype System.Security.Cryptography.HashAlgorithmName hashAlgorithm, valuetype System.Security.Cryptography.DSASignatureFormat signatureFormat, [out] int32&amp; bytesWritten) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDsa.TrySignDataCore(System.ReadOnlySpan{System.Byte},System.Span{System.Byte},System.Security.Cryptography.HashAlgorithmName,System.Security.Cryptography.DSASignatureFormat,System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function TrySignDataCore (data As ReadOnlySpan(Of Byte), destination As Span(Of Byte), hashAlgorithm As HashAlgorithmName, signatureFormat As DSASignatureFormat, ByRef bytesWritten As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool TrySignDataCore(ReadOnlySpan&lt;System::Byte&gt; data, Span&lt;System::Byte&gt; destination, System::Security::Cryptography::HashAlgorithmName hashAlgorithm, System::Security::Cryptography::DSASignatureFormat signatureFormat, [Runtime::InteropServices::Out] int % bytesWritten);" />
      <MemberSignature Language="F#" Value="abstract member TrySignDataCore : ReadOnlySpan&lt;byte&gt; * Span&lt;byte&gt; * System.Security.Cryptography.HashAlgorithmName * System.Security.Cryptography.DSASignatureFormat * int -&gt; bool&#xA;override this.TrySignDataCore : ReadOnlySpan&lt;byte&gt; * Span&lt;byte&gt; * System.Security.Cryptography.HashAlgorithmName * System.Security.Cryptography.DSASignatureFormat * int -&gt; bool" Usage="eCDsa.TrySignDataCore (data, destination, hashAlgorithm, signatureFormat, bytesWritten)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="0" FrameworkAlternate="net-5.0" />
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" Index="1" FrameworkAlternate="net-5.0" />
        <Parameter Name="hashAlgorithm" Type="System.Security.Cryptography.HashAlgorithmName" Index="2" FrameworkAlternate="net-5.0" />
        <Parameter Name="signatureFormat" Type="System.Security.Cryptography.DSASignatureFormat" Index="3" FrameworkAlternate="net-5.0" />
        <Parameter Name="bytesWritten" Type="System.Int32" RefType="out" Index="4" FrameworkAlternate="net-5.0" />
      </Parameters>
      <Docs>
        <param name="data"><span data-ttu-id="f2b80-458">要进行哈希处理和签名的数据。</span><span class="sxs-lookup"><span data-stu-id="f2b80-458">The data to hash and sign.</span></span></param>
        <param name="destination"><span data-ttu-id="f2b80-459">要接收签名的缓冲区。</span><span class="sxs-lookup"><span data-stu-id="f2b80-459">The buffer to receive the signature.</span></span></param>
        <param name="hashAlgorithm"><span data-ttu-id="f2b80-460">要用于创建哈希值的哈希算法。</span><span class="sxs-lookup"><span data-stu-id="f2b80-460">The hash algorithm to use to create the hash value.</span></span></param>
        <param name="signatureFormat"><span data-ttu-id="f2b80-461">要用于签名的编码格式。</span><span class="sxs-lookup"><span data-stu-id="f2b80-461">The encoding format to use for the signature.</span></span></param>
        <param name="bytesWritten"><span data-ttu-id="f2b80-462">此方法返回时，包含一个指示写入 <paramref name="destination" /> 的字节数的值。</span><span class="sxs-lookup"><span data-stu-id="f2b80-462">When this method returns, contains a value that indicates the number of bytes written to <paramref name="destination" />.</span></span> <span data-ttu-id="f2b80-463">该参数未经初始化即被处理。</span><span class="sxs-lookup"><span data-stu-id="f2b80-463">This parameter is treated as uninitialized.</span></span></param>
        <summary><span data-ttu-id="f2b80-464">尝试在提供的缓冲区中以指定的格式为指定的数据创建 ECDSA 签名。</span><span class="sxs-lookup"><span data-stu-id="f2b80-464">Attempts to create the ECDSA signature for the specified data in the indicated format into the provided buffer.</span></span></summary>
        <returns><span data-ttu-id="f2b80-465">如果 <paramref name="destination" /> 的大小足以接收签名，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="f2b80-465"><see langword="true" /> if <paramref name="destination" /> is big enough to receive the signature; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException"><span data-ttu-id="f2b80-466">签名时出错。</span><span class="sxs-lookup"><span data-stu-id="f2b80-466">An error occurred in the signing operation.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="TrySignHash">
      <MemberSignature Language="C#" Value="public virtual bool TrySignHash (ReadOnlySpan&lt;byte&gt; hash, Span&lt;byte&gt; destination, out int bytesWritten);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TrySignHash(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; hash, valuetype System.Span`1&lt;unsigned int8&gt; destination, [out] int32&amp; bytesWritten) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDsa.TrySignHash(System.ReadOnlySpan{System.Byte},System.Span{System.Byte},System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function TrySignHash (hash As ReadOnlySpan(Of Byte), destination As Span(Of Byte), ByRef bytesWritten As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool TrySignHash(ReadOnlySpan&lt;System::Byte&gt; hash, Span&lt;System::Byte&gt; destination, [Runtime::InteropServices::Out] int % bytesWritten);" />
      <MemberSignature Language="F#" Value="abstract member TrySignHash : ReadOnlySpan&lt;byte&gt; * Span&lt;byte&gt; * int -&gt; bool&#xA;override this.TrySignHash : ReadOnlySpan&lt;byte&gt; * Span&lt;byte&gt; * int -&gt; bool" Usage="eCDsa.TrySignHash (hash, destination, bytesWritten)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
        <AssemblyVersion>4.3.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="hash" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="0" FrameworkAlternate="net-5.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1" />
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" Index="1" FrameworkAlternate="net-5.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1" />
        <Parameter Name="bytesWritten" Type="System.Int32" RefType="out" Index="2" FrameworkAlternate="net-5.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="hash"><span data-ttu-id="f2b80-467">待签名数据的哈希值。</span><span class="sxs-lookup"><span data-stu-id="f2b80-467">The hash value of the data that is being signed.</span></span></param>
        <param name="destination"><span data-ttu-id="f2b80-468">要接收签名的缓冲区。</span><span class="sxs-lookup"><span data-stu-id="f2b80-468">The buffer to receive the signature.</span></span></param>
        <param name="bytesWritten"><span data-ttu-id="f2b80-469">此方法返回时，为写入 <paramref name="destination" /> 的字节总数。</span><span class="sxs-lookup"><span data-stu-id="f2b80-469">When this method returns, the total number of bytes written into <paramref name="destination" />.</span></span> <span data-ttu-id="f2b80-470">该参数未经初始化即被处理。</span><span class="sxs-lookup"><span data-stu-id="f2b80-470">This parameter is treated as uninitialized.</span></span></param>
        <summary><span data-ttu-id="f2b80-471">尝试使用当前密钥，将指定的表示数据哈希只读字节范围的 ECDSA 数字签名计算入提供的目标。</span><span class="sxs-lookup"><span data-stu-id="f2b80-471">Attempts to compute the ECDSA digital signature for the specified read-only span of bytes representing a data hash into the provided destination by using the current key.</span></span></summary>
        <returns><span data-ttu-id="f2b80-472">如果 <paramref name="destination" /> 不够长，无法接收签名，则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="f2b80-472"><see langword="false" /> if <paramref name="destination" /> is not long enough to receive the signature.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TrySignHash">
      <MemberSignature Language="C#" Value="public bool TrySignHash (ReadOnlySpan&lt;byte&gt; hash, Span&lt;byte&gt; destination, System.Security.Cryptography.DSASignatureFormat signatureFormat, out int bytesWritten);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TrySignHash(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; hash, valuetype System.Span`1&lt;unsigned int8&gt; destination, valuetype System.Security.Cryptography.DSASignatureFormat signatureFormat, [out] int32&amp; bytesWritten) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDsa.TrySignHash(System.ReadOnlySpan{System.Byte},System.Span{System.Byte},System.Security.Cryptography.DSASignatureFormat,System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TrySignHash (hash As ReadOnlySpan(Of Byte), destination As Span(Of Byte), signatureFormat As DSASignatureFormat, ByRef bytesWritten As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TrySignHash(ReadOnlySpan&lt;System::Byte&gt; hash, Span&lt;System::Byte&gt; destination, System::Security::Cryptography::DSASignatureFormat signatureFormat, [Runtime::InteropServices::Out] int % bytesWritten);" />
      <MemberSignature Language="F#" Value="member this.TrySignHash : ReadOnlySpan&lt;byte&gt; * Span&lt;byte&gt; * System.Security.Cryptography.DSASignatureFormat * int -&gt; bool" Usage="eCDsa.TrySignHash (hash, destination, signatureFormat, bytesWritten)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="hash" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="0" FrameworkAlternate="net-5.0" />
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" Index="1" FrameworkAlternate="net-5.0" />
        <Parameter Name="signatureFormat" Type="System.Security.Cryptography.DSASignatureFormat" Index="2" FrameworkAlternate="net-5.0" />
        <Parameter Name="bytesWritten" Type="System.Int32" RefType="out" Index="3" FrameworkAlternate="net-5.0" />
      </Parameters>
      <Docs>
        <param name="hash"><span data-ttu-id="f2b80-473">要签名的哈希值。</span><span class="sxs-lookup"><span data-stu-id="f2b80-473">The hash value to sign.</span></span></param>
        <param name="destination"><span data-ttu-id="f2b80-474">要接收签名的缓冲区。</span><span class="sxs-lookup"><span data-stu-id="f2b80-474">The buffer to receive the signature.</span></span></param>
        <param name="signatureFormat"><span data-ttu-id="f2b80-475">要用于签名的编码格式。</span><span class="sxs-lookup"><span data-stu-id="f2b80-475">The encoding format to use for the signature.</span></span></param>
        <param name="bytesWritten"><span data-ttu-id="f2b80-476">此方法返回时，包含一个指示写入 <paramref name="destination" /> 的字节数的值。</span><span class="sxs-lookup"><span data-stu-id="f2b80-476">When this method returns, contains a value that indicates the number of bytes written to <paramref name="destination" />.</span></span> <span data-ttu-id="f2b80-477">该参数未经初始化即被处理。</span><span class="sxs-lookup"><span data-stu-id="f2b80-477">This parameter is treated as uninitialized.</span></span></param>
        <summary><span data-ttu-id="f2b80-478">尝试在提供的缓冲区中以指定的格式为指定的哈希值创建 ECDSA 签名。</span><span class="sxs-lookup"><span data-stu-id="f2b80-478">Attempts to create the ECDSA signature for the specified hash value in the indicated format into the provided buffer.</span></span></summary>
        <returns><span data-ttu-id="f2b80-479">如果 <paramref name="destination" /> 的大小足以接收签名，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="f2b80-479"><see langword="true" /> if <paramref name="destination" /> is big enough to receive the signature; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="f2b80-480"><paramref name="signatureFormat" /> 不是已知格式。</span><span class="sxs-lookup"><span data-stu-id="f2b80-480"><paramref name="signatureFormat" /> is not a known format.</span></span></exception>
        <exception cref="T:System.Security.Cryptography.CryptographicException"><span data-ttu-id="f2b80-481">签名时出错。</span><span class="sxs-lookup"><span data-stu-id="f2b80-481">An error occurred in the signing operation.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="TrySignHashCore">
      <MemberSignature Language="C#" Value="protected virtual bool TrySignHashCore (ReadOnlySpan&lt;byte&gt; hash, Span&lt;byte&gt; destination, System.Security.Cryptography.DSASignatureFormat signatureFormat, out int bytesWritten);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool TrySignHashCore(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; hash, valuetype System.Span`1&lt;unsigned int8&gt; destination, valuetype System.Security.Cryptography.DSASignatureFormat signatureFormat, [out] int32&amp; bytesWritten) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDsa.TrySignHashCore(System.ReadOnlySpan{System.Byte},System.Span{System.Byte},System.Security.Cryptography.DSASignatureFormat,System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function TrySignHashCore (hash As ReadOnlySpan(Of Byte), destination As Span(Of Byte), signatureFormat As DSASignatureFormat, ByRef bytesWritten As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool TrySignHashCore(ReadOnlySpan&lt;System::Byte&gt; hash, Span&lt;System::Byte&gt; destination, System::Security::Cryptography::DSASignatureFormat signatureFormat, [Runtime::InteropServices::Out] int % bytesWritten);" />
      <MemberSignature Language="F#" Value="abstract member TrySignHashCore : ReadOnlySpan&lt;byte&gt; * Span&lt;byte&gt; * System.Security.Cryptography.DSASignatureFormat * int -&gt; bool&#xA;override this.TrySignHashCore : ReadOnlySpan&lt;byte&gt; * Span&lt;byte&gt; * System.Security.Cryptography.DSASignatureFormat * int -&gt; bool" Usage="eCDsa.TrySignHashCore (hash, destination, signatureFormat, bytesWritten)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="hash" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="0" FrameworkAlternate="net-5.0" />
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" Index="1" FrameworkAlternate="net-5.0" />
        <Parameter Name="signatureFormat" Type="System.Security.Cryptography.DSASignatureFormat" Index="2" FrameworkAlternate="net-5.0" />
        <Parameter Name="bytesWritten" Type="System.Int32" RefType="out" Index="3" FrameworkAlternate="net-5.0" />
      </Parameters>
      <Docs>
        <param name="hash"><span data-ttu-id="f2b80-482">要签名的哈希值。</span><span class="sxs-lookup"><span data-stu-id="f2b80-482">The hash value to sign.</span></span></param>
        <param name="destination"><span data-ttu-id="f2b80-483">要接收签名的缓冲区。</span><span class="sxs-lookup"><span data-stu-id="f2b80-483">The buffer to receive the signature.</span></span></param>
        <param name="signatureFormat"><span data-ttu-id="f2b80-484">要用于签名的编码格式。</span><span class="sxs-lookup"><span data-stu-id="f2b80-484">The encoding format to use for the signature.</span></span></param>
        <param name="bytesWritten"><span data-ttu-id="f2b80-485">此方法返回时，包含一个指示写入 <paramref name="destination" /> 的字节数的值。</span><span class="sxs-lookup"><span data-stu-id="f2b80-485">When this method returns, contains a value that indicates the number of bytes written to <paramref name="destination" />.</span></span> <span data-ttu-id="f2b80-486">该参数未经初始化即被处理。</span><span class="sxs-lookup"><span data-stu-id="f2b80-486">This parameter is treated as uninitialized.</span></span></param>
        <summary><span data-ttu-id="f2b80-487">尝试在提供的缓冲区中以指定的格式为指定的哈希值创建 ECDSA 签名。</span><span class="sxs-lookup"><span data-stu-id="f2b80-487">Attempts to create the ECDSA signature for the specified hash value in the indicated format into the provided buffer.</span></span></summary>
        <returns><span data-ttu-id="f2b80-488">如果 <paramref name="destination" /> 的大小足以接收签名，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="f2b80-488"><see langword="true" /> if <paramref name="destination" /> is big enough to receive the signature; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException"><span data-ttu-id="f2b80-489">签名时出错。</span><span class="sxs-lookup"><span data-stu-id="f2b80-489">An error occurred in the signing operation.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="VerifyData">
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.3.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="f2b80-490">验证数字签名是否适用于当前密钥和使用指定的哈希算法提供的数据。</span><span class="sxs-lookup"><span data-stu-id="f2b80-490">Verifies that a digital signature is appropriate for the current key and provided data with a specified hash algorithm.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="VerifyData">
      <MemberSignature Language="C#" Value="public bool VerifyData (byte[] data, byte[] signature, System.Security.Cryptography.HashAlgorithmName hashAlgorithm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool VerifyData(unsigned int8[] data, unsigned int8[] signature, valuetype System.Security.Cryptography.HashAlgorithmName hashAlgorithm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDsa.VerifyData(System.Byte[],System.Byte[],System.Security.Cryptography.HashAlgorithmName)" />
      <MemberSignature Language="VB.NET" Value="Public Function VerifyData (data As Byte(), signature As Byte(), hashAlgorithm As HashAlgorithmName) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool VerifyData(cli::array &lt;System::Byte&gt; ^ data, cli::array &lt;System::Byte&gt; ^ signature, System::Security::Cryptography::HashAlgorithmName hashAlgorithm);" />
      <MemberSignature Language="F#" Value="member this.VerifyData : byte[] * byte[] * System.Security.Cryptography.HashAlgorithmName -&gt; bool" Usage="eCDsa.VerifyData (data, signature, hashAlgorithm)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.3.0.0</AssemblyVersion>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
        <AssemblyVersion>4.3.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Byte[]" Index="0" FrameworkAlternate="net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="signature" Type="System.Byte[]" Index="1" FrameworkAlternate="net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="hashAlgorithm" Type="System.Security.Cryptography.HashAlgorithmName" Index="2" FrameworkAlternate="net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="data"><span data-ttu-id="f2b80-491">已签名的数据。</span><span class="sxs-lookup"><span data-stu-id="f2b80-491">The signed data.</span></span></param>
        <param name="signature"><span data-ttu-id="f2b80-492">要验证的签名数据。</span><span class="sxs-lookup"><span data-stu-id="f2b80-492">The signature data to be verified.</span></span></param>
        <param name="hashAlgorithm"><span data-ttu-id="f2b80-493">要用于创建数据哈希值的哈希算法。</span><span class="sxs-lookup"><span data-stu-id="f2b80-493">The hash algorithm used to create the hash value of the data.</span></span></param>
        <summary><span data-ttu-id="f2b80-494">验证数字签名是否适用于当前密钥和使用指定的哈希算法提供的数据。</span><span class="sxs-lookup"><span data-stu-id="f2b80-494">Verifies that a digital signature is appropriate for the current key and provided data with a specified hash algorithm.</span></span></summary>
        <returns><span data-ttu-id="f2b80-495">如果签名有效，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="f2b80-495"><see langword="true" /> if the signature is valid; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f2b80-496"><paramref name="data" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="f2b80-496"><paramref name="data" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="f2b80-497">- 或 -</span><span class="sxs-lookup"><span data-stu-id="f2b80-497">-or-</span></span> 
 <span data-ttu-id="f2b80-498"><paramref name="signature" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="f2b80-498"><paramref name="signature" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="f2b80-499"><paramref name="hashAlgorithm" />.<see cref="P:System.Security.Cryptography.HashAlgorithmName.Name" /></span><span class="sxs-lookup"><span data-stu-id="f2b80-499"><paramref name="hashAlgorithm" />.<see cref="P:System.Security.Cryptography.HashAlgorithmName.Name" /></span></span> <span data-ttu-id="f2b80-500">为 <see langword="null" /> 或 <see cref="F:System.String.Empty" />。</span><span class="sxs-lookup"><span data-stu-id="f2b80-500">is <see langword="null" /> or <see cref="F:System.String.Empty" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="VerifyData">
      <MemberSignature Language="C#" Value="public bool VerifyData (System.IO.Stream data, byte[] signature, System.Security.Cryptography.HashAlgorithmName hashAlgorithm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool VerifyData(class System.IO.Stream data, unsigned int8[] signature, valuetype System.Security.Cryptography.HashAlgorithmName hashAlgorithm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDsa.VerifyData(System.IO.Stream,System.Byte[],System.Security.Cryptography.HashAlgorithmName)" />
      <MemberSignature Language="VB.NET" Value="Public Function VerifyData (data As Stream, signature As Byte(), hashAlgorithm As HashAlgorithmName) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool VerifyData(System::IO::Stream ^ data, cli::array &lt;System::Byte&gt; ^ signature, System::Security::Cryptography::HashAlgorithmName hashAlgorithm);" />
      <MemberSignature Language="F#" Value="member this.VerifyData : System.IO.Stream * byte[] * System.Security.Cryptography.HashAlgorithmName -&gt; bool" Usage="eCDsa.VerifyData (data, signature, hashAlgorithm)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.3.0.0</AssemblyVersion>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
        <AssemblyVersion>4.3.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.IO.Stream" Index="0" FrameworkAlternate="net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="signature" Type="System.Byte[]" Index="1" FrameworkAlternate="net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="hashAlgorithm" Type="System.Security.Cryptography.HashAlgorithmName" Index="2" FrameworkAlternate="net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="data"><span data-ttu-id="f2b80-501">已签名的数据。</span><span class="sxs-lookup"><span data-stu-id="f2b80-501">The signed data.</span></span></param>
        <param name="signature"><span data-ttu-id="f2b80-502">要验证的签名数据。</span><span class="sxs-lookup"><span data-stu-id="f2b80-502">The signature data to be verified.</span></span></param>
        <param name="hashAlgorithm"><span data-ttu-id="f2b80-503">要用于创建数据哈希值的哈希算法。</span><span class="sxs-lookup"><span data-stu-id="f2b80-503">The hash algorithm used to create the hash value of the data.</span></span></param>
        <summary><span data-ttu-id="f2b80-504">验证数字签名是否适用于当前密钥和使用指定的哈希算法提供的数据。</span><span class="sxs-lookup"><span data-stu-id="f2b80-504">Verifies that a digital signature is appropriate for the current key and provided data with a specified hash algorithm.</span></span></summary>
        <returns><span data-ttu-id="f2b80-505">如果签名有效，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="f2b80-505"><see langword="true" /> if the signature is valid; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f2b80-506"><paramref name="data" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="f2b80-506"><paramref name="data" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="f2b80-507">- 或 -</span><span class="sxs-lookup"><span data-stu-id="f2b80-507">-or-</span></span> 
 <span data-ttu-id="f2b80-508"><paramref name="signature" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="f2b80-508"><paramref name="signature" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="f2b80-509"><paramref name="hashAlgorithm" />.<see cref="P:System.Security.Cryptography.HashAlgorithmName.Name" /></span><span class="sxs-lookup"><span data-stu-id="f2b80-509"><paramref name="hashAlgorithm" />.<see cref="P:System.Security.Cryptography.HashAlgorithmName.Name" /></span></span> <span data-ttu-id="f2b80-510">为 <see langword="null" /> 或 <see cref="F:System.String.Empty" />。</span><span class="sxs-lookup"><span data-stu-id="f2b80-510">is <see langword="null" /> or <see cref="F:System.String.Empty" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="VerifyData">
      <MemberSignature Language="C#" Value="public virtual bool VerifyData (ReadOnlySpan&lt;byte&gt; data, ReadOnlySpan&lt;byte&gt; signature, System.Security.Cryptography.HashAlgorithmName hashAlgorithm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool VerifyData(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; data, valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; signature, valuetype System.Security.Cryptography.HashAlgorithmName hashAlgorithm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDsa.VerifyData(System.ReadOnlySpan{System.Byte},System.ReadOnlySpan{System.Byte},System.Security.Cryptography.HashAlgorithmName)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function VerifyData (data As ReadOnlySpan(Of Byte), signature As ReadOnlySpan(Of Byte), hashAlgorithm As HashAlgorithmName) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool VerifyData(ReadOnlySpan&lt;System::Byte&gt; data, ReadOnlySpan&lt;System::Byte&gt; signature, System::Security::Cryptography::HashAlgorithmName hashAlgorithm);" />
      <MemberSignature Language="F#" Value="abstract member VerifyData : ReadOnlySpan&lt;byte&gt; * ReadOnlySpan&lt;byte&gt; * System.Security.Cryptography.HashAlgorithmName -&gt; bool&#xA;override this.VerifyData : ReadOnlySpan&lt;byte&gt; * ReadOnlySpan&lt;byte&gt; * System.Security.Cryptography.HashAlgorithmName -&gt; bool" Usage="eCDsa.VerifyData (data, signature, hashAlgorithm)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
        <AssemblyVersion>4.3.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="0" FrameworkAlternate="net-5.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1" />
        <Parameter Name="signature" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="1" FrameworkAlternate="net-5.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1" />
        <Parameter Name="hashAlgorithm" Type="System.Security.Cryptography.HashAlgorithmName" Index="2" FrameworkAlternate="net-5.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="data"><span data-ttu-id="f2b80-511">已签名的数据。</span><span class="sxs-lookup"><span data-stu-id="f2b80-511">The signed data.</span></span></param>
        <param name="signature"><span data-ttu-id="f2b80-512">要验证的签名。</span><span class="sxs-lookup"><span data-stu-id="f2b80-512">The signature to be verified.</span></span></param>
        <param name="hashAlgorithm"><span data-ttu-id="f2b80-513">要用于创建数据哈希值的哈希算法。</span><span class="sxs-lookup"><span data-stu-id="f2b80-513">The hash algorithm used to create the hash value of the data.</span></span></param>
        <summary><span data-ttu-id="f2b80-514">验证数字签名是否适用于当前密钥和使用指定的哈希算法提供的数据。</span><span class="sxs-lookup"><span data-stu-id="f2b80-514">Verifies that a digital signature is appropriate for the current key and provided data with a specified hash algorithm.</span></span></summary>
        <returns><span data-ttu-id="f2b80-515">如果签名有效，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="f2b80-515"><see langword="true" /> if the signature is valid; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="f2b80-516"><paramref name="hashAlgorithm" />.<see cref="P:System.Security.Cryptography.HashAlgorithmName.Name" /></span><span class="sxs-lookup"><span data-stu-id="f2b80-516"><paramref name="hashAlgorithm" />.<see cref="P:System.Security.Cryptography.HashAlgorithmName.Name" /></span></span> <span data-ttu-id="f2b80-517">为 <see langword="null" /> 或 <see cref="F:System.String.Empty" />。</span><span class="sxs-lookup"><span data-stu-id="f2b80-517">is <see langword="null" /> or <see cref="F:System.String.Empty" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="VerifyData">
      <MemberSignature Language="C#" Value="public bool VerifyData (byte[] data, byte[] signature, System.Security.Cryptography.HashAlgorithmName hashAlgorithm, System.Security.Cryptography.DSASignatureFormat signatureFormat);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool VerifyData(unsigned int8[] data, unsigned int8[] signature, valuetype System.Security.Cryptography.HashAlgorithmName hashAlgorithm, valuetype System.Security.Cryptography.DSASignatureFormat signatureFormat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDsa.VerifyData(System.Byte[],System.Byte[],System.Security.Cryptography.HashAlgorithmName,System.Security.Cryptography.DSASignatureFormat)" />
      <MemberSignature Language="VB.NET" Value="Public Function VerifyData (data As Byte(), signature As Byte(), hashAlgorithm As HashAlgorithmName, signatureFormat As DSASignatureFormat) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool VerifyData(cli::array &lt;System::Byte&gt; ^ data, cli::array &lt;System::Byte&gt; ^ signature, System::Security::Cryptography::HashAlgorithmName hashAlgorithm, System::Security::Cryptography::DSASignatureFormat signatureFormat);" />
      <MemberSignature Language="F#" Value="member this.VerifyData : byte[] * byte[] * System.Security.Cryptography.HashAlgorithmName * System.Security.Cryptography.DSASignatureFormat -&gt; bool" Usage="eCDsa.VerifyData (data, signature, hashAlgorithm, signatureFormat)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Byte[]" Index="0" FrameworkAlternate="net-5.0" />
        <Parameter Name="signature" Type="System.Byte[]" Index="1" FrameworkAlternate="net-5.0" />
        <Parameter Name="hashAlgorithm" Type="System.Security.Cryptography.HashAlgorithmName" Index="2" FrameworkAlternate="net-5.0" />
        <Parameter Name="signatureFormat" Type="System.Security.Cryptography.DSASignatureFormat" Index="3" FrameworkAlternate="net-5.0" />
      </Parameters>
      <Docs>
        <param name="data"><span data-ttu-id="f2b80-518">已签名的数据。</span><span class="sxs-lookup"><span data-stu-id="f2b80-518">The signed data.</span></span></param>
        <param name="signature"><span data-ttu-id="f2b80-519">要验证的签名。</span><span class="sxs-lookup"><span data-stu-id="f2b80-519">The signature to verify.</span></span></param>
        <param name="hashAlgorithm"><span data-ttu-id="f2b80-520">用于对验证过程的数据进行哈希处理的哈希算法。</span><span class="sxs-lookup"><span data-stu-id="f2b80-520">The hash algorithm used to hash the data for the verification process.</span></span></param>
        <param name="signatureFormat"><span data-ttu-id="f2b80-521"><paramref name="signature" /> 的编码格式。</span><span class="sxs-lookup"><span data-stu-id="f2b80-521">The encoding format for <paramref name="signature" />.</span></span></param>
        <summary><span data-ttu-id="f2b80-522">验证数字签名对于所提供的数据是否有效。</span><span class="sxs-lookup"><span data-stu-id="f2b80-522">Verifies that a digital signature is valid for the provided data.</span></span></summary>
        <returns><span data-ttu-id="f2b80-523">如果数字签名对所提供的数据有效，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="f2b80-523"><see langword="true" /> if the digital signature is valid for the provided data; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f2b80-524"><paramref name="data" /> 或 <paramref name="signature" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="f2b80-524"><paramref name="data" /> or <paramref name="signature" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="f2b80-525"><paramref name="signatureFormat" /> 不是已知格式。</span><span class="sxs-lookup"><span data-stu-id="f2b80-525"><paramref name="signatureFormat" /> is not a known format.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="f2b80-526"><paramref name="hashAlgorithm" /> 具有 <see langword="null" /> 或空的 <see cref="P:System.Security.Cryptography.HashAlgorithmName.Name" />。</span><span class="sxs-lookup"><span data-stu-id="f2b80-526"><paramref name="hashAlgorithm" /> has a <see langword="null" /> or empty <see cref="P:System.Security.Cryptography.HashAlgorithmName.Name" />.</span></span></exception>
        <exception cref="T:System.Security.Cryptography.CryptographicException"><span data-ttu-id="f2b80-527">哈希处理或验证时出错。</span><span class="sxs-lookup"><span data-stu-id="f2b80-527">An error occurred in the hashing or verification operation.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="VerifyData">
      <MemberSignature Language="C#" Value="public bool VerifyData (System.IO.Stream data, byte[] signature, System.Security.Cryptography.HashAlgorithmName hashAlgorithm, System.Security.Cryptography.DSASignatureFormat signatureFormat);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool VerifyData(class System.IO.Stream data, unsigned int8[] signature, valuetype System.Security.Cryptography.HashAlgorithmName hashAlgorithm, valuetype System.Security.Cryptography.DSASignatureFormat signatureFormat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDsa.VerifyData(System.IO.Stream,System.Byte[],System.Security.Cryptography.HashAlgorithmName,System.Security.Cryptography.DSASignatureFormat)" />
      <MemberSignature Language="VB.NET" Value="Public Function VerifyData (data As Stream, signature As Byte(), hashAlgorithm As HashAlgorithmName, signatureFormat As DSASignatureFormat) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool VerifyData(System::IO::Stream ^ data, cli::array &lt;System::Byte&gt; ^ signature, System::Security::Cryptography::HashAlgorithmName hashAlgorithm, System::Security::Cryptography::DSASignatureFormat signatureFormat);" />
      <MemberSignature Language="F#" Value="member this.VerifyData : System.IO.Stream * byte[] * System.Security.Cryptography.HashAlgorithmName * System.Security.Cryptography.DSASignatureFormat -&gt; bool" Usage="eCDsa.VerifyData (data, signature, hashAlgorithm, signatureFormat)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.IO.Stream" Index="0" FrameworkAlternate="net-5.0" />
        <Parameter Name="signature" Type="System.Byte[]" Index="1" FrameworkAlternate="net-5.0" />
        <Parameter Name="hashAlgorithm" Type="System.Security.Cryptography.HashAlgorithmName" Index="2" FrameworkAlternate="net-5.0" />
        <Parameter Name="signatureFormat" Type="System.Security.Cryptography.DSASignatureFormat" Index="3" FrameworkAlternate="net-5.0" />
      </Parameters>
      <Docs>
        <param name="data"><span data-ttu-id="f2b80-528">已签名的数据。</span><span class="sxs-lookup"><span data-stu-id="f2b80-528">The signed data.</span></span></param>
        <param name="signature"><span data-ttu-id="f2b80-529">要验证的签名。</span><span class="sxs-lookup"><span data-stu-id="f2b80-529">The signature to verify.</span></span></param>
        <param name="hashAlgorithm"><span data-ttu-id="f2b80-530">用于对验证过程的数据进行哈希处理的哈希算法。</span><span class="sxs-lookup"><span data-stu-id="f2b80-530">The hash algorithm used to hash the data for the verification process.</span></span></param>
        <param name="signatureFormat"><span data-ttu-id="f2b80-531"><paramref name="signature" /> 的编码格式。</span><span class="sxs-lookup"><span data-stu-id="f2b80-531">The encoding format for <paramref name="signature" />.</span></span></param>
        <summary><span data-ttu-id="f2b80-532">验证数字签名对于所提供的数据是否有效。</span><span class="sxs-lookup"><span data-stu-id="f2b80-532">Verifies that a digital signature is valid for the provided data.</span></span></summary>
        <returns><span data-ttu-id="f2b80-533">如果数字签名对所提供的数据有效，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="f2b80-533"><see langword="true" /> if the digital signature is valid for the provided data; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f2b80-534"><paramref name="data" /> 或 <paramref name="signature" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="f2b80-534"><paramref name="data" /> or <paramref name="signature" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="f2b80-535"><paramref name="signatureFormat" /> 不是已知格式。</span><span class="sxs-lookup"><span data-stu-id="f2b80-535"><paramref name="signatureFormat" /> is not a known format.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="f2b80-536"><paramref name="hashAlgorithm" /> 具有 <see langword="null" /> 或空的 <see cref="P:System.Security.Cryptography.HashAlgorithmName.Name" />。</span><span class="sxs-lookup"><span data-stu-id="f2b80-536"><paramref name="hashAlgorithm" /> has a <see langword="null" /> or empty <see cref="P:System.Security.Cryptography.HashAlgorithmName.Name" />.</span></span></exception>
        <exception cref="T:System.Security.Cryptography.CryptographicException"><span data-ttu-id="f2b80-537">哈希处理或验证时出错。</span><span class="sxs-lookup"><span data-stu-id="f2b80-537">An error occurred in the hashing or verification operation.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="VerifyData">
      <MemberSignature Language="C#" Value="public bool VerifyData (ReadOnlySpan&lt;byte&gt; data, ReadOnlySpan&lt;byte&gt; signature, System.Security.Cryptography.HashAlgorithmName hashAlgorithm, System.Security.Cryptography.DSASignatureFormat signatureFormat);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool VerifyData(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; data, valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; signature, valuetype System.Security.Cryptography.HashAlgorithmName hashAlgorithm, valuetype System.Security.Cryptography.DSASignatureFormat signatureFormat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDsa.VerifyData(System.ReadOnlySpan{System.Byte},System.ReadOnlySpan{System.Byte},System.Security.Cryptography.HashAlgorithmName,System.Security.Cryptography.DSASignatureFormat)" />
      <MemberSignature Language="VB.NET" Value="Public Function VerifyData (data As ReadOnlySpan(Of Byte), signature As ReadOnlySpan(Of Byte), hashAlgorithm As HashAlgorithmName, signatureFormat As DSASignatureFormat) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool VerifyData(ReadOnlySpan&lt;System::Byte&gt; data, ReadOnlySpan&lt;System::Byte&gt; signature, System::Security::Cryptography::HashAlgorithmName hashAlgorithm, System::Security::Cryptography::DSASignatureFormat signatureFormat);" />
      <MemberSignature Language="F#" Value="member this.VerifyData : ReadOnlySpan&lt;byte&gt; * ReadOnlySpan&lt;byte&gt; * System.Security.Cryptography.HashAlgorithmName * System.Security.Cryptography.DSASignatureFormat -&gt; bool" Usage="eCDsa.VerifyData (data, signature, hashAlgorithm, signatureFormat)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="0" FrameworkAlternate="net-5.0" />
        <Parameter Name="signature" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="1" FrameworkAlternate="net-5.0" />
        <Parameter Name="hashAlgorithm" Type="System.Security.Cryptography.HashAlgorithmName" Index="2" FrameworkAlternate="net-5.0" />
        <Parameter Name="signatureFormat" Type="System.Security.Cryptography.DSASignatureFormat" Index="3" FrameworkAlternate="net-5.0" />
      </Parameters>
      <Docs>
        <param name="data"><span data-ttu-id="f2b80-538">已签名的数据。</span><span class="sxs-lookup"><span data-stu-id="f2b80-538">The signed data.</span></span></param>
        <param name="signature"><span data-ttu-id="f2b80-539">要验证的签名。</span><span class="sxs-lookup"><span data-stu-id="f2b80-539">The signature to verify.</span></span></param>
        <param name="hashAlgorithm"><span data-ttu-id="f2b80-540">用于对验证过程的数据进行哈希处理的哈希算法。</span><span class="sxs-lookup"><span data-stu-id="f2b80-540">The hash algorithm used to hash the data for the verification process.</span></span></param>
        <param name="signatureFormat"><span data-ttu-id="f2b80-541"><paramref name="signature" /> 的编码格式。</span><span class="sxs-lookup"><span data-stu-id="f2b80-541">The encoding format for <paramref name="signature" />.</span></span></param>
        <summary><span data-ttu-id="f2b80-542">验证数字签名对于所提供的数据是否有效。</span><span class="sxs-lookup"><span data-stu-id="f2b80-542">Verifies that a digital signature is valid for the provided data.</span></span></summary>
        <returns><span data-ttu-id="f2b80-543">如果数字签名对所提供的数据有效，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="f2b80-543"><see langword="true" /> if the digital signature is valid for the provided data; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="f2b80-544"><paramref name="signatureFormat" /> 不是已知格式。</span><span class="sxs-lookup"><span data-stu-id="f2b80-544"><paramref name="signatureFormat" /> is not a known format.</span></span></exception>
        <exception cref="T:System.Security.Cryptography.CryptographicException"><span data-ttu-id="f2b80-545">哈希处理或验证时出错。</span><span class="sxs-lookup"><span data-stu-id="f2b80-545">An error occurred in the hashing or verification operation.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="VerifyData">
      <MemberSignature Language="C#" Value="public virtual bool VerifyData (byte[] data, int offset, int count, byte[] signature, System.Security.Cryptography.HashAlgorithmName hashAlgorithm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool VerifyData(unsigned int8[] data, int32 offset, int32 count, unsigned int8[] signature, valuetype System.Security.Cryptography.HashAlgorithmName hashAlgorithm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDsa.VerifyData(System.Byte[],System.Int32,System.Int32,System.Byte[],System.Security.Cryptography.HashAlgorithmName)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function VerifyData (data As Byte(), offset As Integer, count As Integer, signature As Byte(), hashAlgorithm As HashAlgorithmName) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool VerifyData(cli::array &lt;System::Byte&gt; ^ data, int offset, int count, cli::array &lt;System::Byte&gt; ^ signature, System::Security::Cryptography::HashAlgorithmName hashAlgorithm);" />
      <MemberSignature Language="F#" Value="abstract member VerifyData : byte[] * int * int * byte[] * System.Security.Cryptography.HashAlgorithmName -&gt; bool&#xA;override this.VerifyData : byte[] * int * int * byte[] * System.Security.Cryptography.HashAlgorithmName -&gt; bool" Usage="eCDsa.VerifyData (data, offset, count, signature, hashAlgorithm)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.3.0.0</AssemblyVersion>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
        <AssemblyVersion>4.3.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Byte[]" Index="0" FrameworkAlternate="net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="signature" Type="System.Byte[]" Index="3" FrameworkAlternate="net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="hashAlgorithm" Type="System.Security.Cryptography.HashAlgorithmName" Index="4" FrameworkAlternate="net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="data"><span data-ttu-id="f2b80-546">已签名的数据。</span><span class="sxs-lookup"><span data-stu-id="f2b80-546">The signed data.</span></span></param>
        <param name="offset"><span data-ttu-id="f2b80-547">开始计算哈希的起始索引。</span><span class="sxs-lookup"><span data-stu-id="f2b80-547">The starting index at which to compute the hash.</span></span></param>
        <param name="count"><span data-ttu-id="f2b80-548">要进行哈希处理的字节数。</span><span class="sxs-lookup"><span data-stu-id="f2b80-548">The number of bytes to hash.</span></span></param>
        <param name="signature"><span data-ttu-id="f2b80-549">要验证的签名数据。</span><span class="sxs-lookup"><span data-stu-id="f2b80-549">The signature data to be verified.</span></span></param>
        <param name="hashAlgorithm"><span data-ttu-id="f2b80-550">要用于创建数据哈希值的哈希算法。</span><span class="sxs-lookup"><span data-stu-id="f2b80-550">The hash algorithm used to create the hash value of the data.</span></span></param>
        <summary><span data-ttu-id="f2b80-551">使用指定的哈希算法验证数字签名是否适用于当前密钥和提供的数据部分。</span><span class="sxs-lookup"><span data-stu-id="f2b80-551">Verifies that a digital signature is appropriate for the current key and provided portion of data with a specified hash algorithm.</span></span></summary>
        <returns><span data-ttu-id="f2b80-552">如果签名有效，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="f2b80-552"><see langword="true" /> if the signature is valid; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f2b80-553"><paramref name="data" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="f2b80-553"><paramref name="data" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="f2b80-554">- 或 -</span><span class="sxs-lookup"><span data-stu-id="f2b80-554">-or-</span></span> 
 <span data-ttu-id="f2b80-555"><paramref name="signature" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="f2b80-555"><paramref name="signature" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="f2b80-556"><paramref name="hashAlgorithm" />.<see cref="P:System.Security.Cryptography.HashAlgorithmName.Name" /></span><span class="sxs-lookup"><span data-stu-id="f2b80-556"><paramref name="hashAlgorithm" />.<see cref="P:System.Security.Cryptography.HashAlgorithmName.Name" /></span></span> <span data-ttu-id="f2b80-557">为 <see langword="null" /> 或 <see cref="F:System.String.Empty" />。</span><span class="sxs-lookup"><span data-stu-id="f2b80-557">is <see langword="null" /> or <see cref="F:System.String.Empty" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="f2b80-558"><paramref name="offset" /> 小于零。</span><span class="sxs-lookup"><span data-stu-id="f2b80-558"><paramref name="offset" /> is less than zero.</span></span>  
  
<span data-ttu-id="f2b80-559">- 或 -</span><span class="sxs-lookup"><span data-stu-id="f2b80-559">-or-</span></span> 
 <span data-ttu-id="f2b80-560"><paramref name="count" /> 小于零。</span><span class="sxs-lookup"><span data-stu-id="f2b80-560"><paramref name="count" /> is less than zero.</span></span>  
  
<span data-ttu-id="f2b80-561">- 或 -</span><span class="sxs-lookup"><span data-stu-id="f2b80-561">-or-</span></span> 
 <span data-ttu-id="f2b80-562"><paramref name="offset" /> + <paramref name="count" /> - 1 会导致超出 <paramref name="data" /> 上限的索引。</span><span class="sxs-lookup"><span data-stu-id="f2b80-562"><paramref name="offset" /> + <paramref name="count" /> - 1 results in an index that is beyond the upper bound of <paramref name="data" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="VerifyData">
      <MemberSignature Language="C#" Value="public bool VerifyData (byte[] data, int offset, int count, byte[] signature, System.Security.Cryptography.HashAlgorithmName hashAlgorithm, System.Security.Cryptography.DSASignatureFormat signatureFormat);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool VerifyData(unsigned int8[] data, int32 offset, int32 count, unsigned int8[] signature, valuetype System.Security.Cryptography.HashAlgorithmName hashAlgorithm, valuetype System.Security.Cryptography.DSASignatureFormat signatureFormat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDsa.VerifyData(System.Byte[],System.Int32,System.Int32,System.Byte[],System.Security.Cryptography.HashAlgorithmName,System.Security.Cryptography.DSASignatureFormat)" />
      <MemberSignature Language="VB.NET" Value="Public Function VerifyData (data As Byte(), offset As Integer, count As Integer, signature As Byte(), hashAlgorithm As HashAlgorithmName, signatureFormat As DSASignatureFormat) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool VerifyData(cli::array &lt;System::Byte&gt; ^ data, int offset, int count, cli::array &lt;System::Byte&gt; ^ signature, System::Security::Cryptography::HashAlgorithmName hashAlgorithm, System::Security::Cryptography::DSASignatureFormat signatureFormat);" />
      <MemberSignature Language="F#" Value="member this.VerifyData : byte[] * int * int * byte[] * System.Security.Cryptography.HashAlgorithmName * System.Security.Cryptography.DSASignatureFormat -&gt; bool" Usage="eCDsa.VerifyData (data, offset, count, signature, hashAlgorithm, signatureFormat)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Byte[]" Index="0" FrameworkAlternate="net-5.0" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="net-5.0" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="net-5.0" />
        <Parameter Name="signature" Type="System.Byte[]" Index="3" FrameworkAlternate="net-5.0" />
        <Parameter Name="hashAlgorithm" Type="System.Security.Cryptography.HashAlgorithmName" Index="4" FrameworkAlternate="net-5.0" />
        <Parameter Name="signatureFormat" Type="System.Security.Cryptography.DSASignatureFormat" Index="5" FrameworkAlternate="net-5.0" />
      </Parameters>
      <Docs>
        <param name="data"><span data-ttu-id="f2b80-563">包含已签名数据的数组。</span><span class="sxs-lookup"><span data-stu-id="f2b80-563">An array that contains the signed data.</span></span></param>
        <param name="offset"><span data-ttu-id="f2b80-564"><paramref name="data" /> 的已签名部分的起始索引。</span><span class="sxs-lookup"><span data-stu-id="f2b80-564">The starting index of the signed portion of <paramref name="data" />.</span></span></param>
        <param name="count"><span data-ttu-id="f2b80-565">已签名的 <paramref name="data" /> 的字节数。</span><span class="sxs-lookup"><span data-stu-id="f2b80-565">The number of bytes in <paramref name="data" /> that were signed.</span></span></param>
        <param name="signature"><span data-ttu-id="f2b80-566">要验证的签名。</span><span class="sxs-lookup"><span data-stu-id="f2b80-566">The signature to verify.</span></span></param>
        <param name="hashAlgorithm"><span data-ttu-id="f2b80-567">用于对验证过程的数据进行哈希处理的哈希算法。</span><span class="sxs-lookup"><span data-stu-id="f2b80-567">The hash algorithm used to hash the data for the verification process.</span></span></param>
        <param name="signatureFormat"><span data-ttu-id="f2b80-568"><paramref name="signature" /> 的编码格式。</span><span class="sxs-lookup"><span data-stu-id="f2b80-568">The encoding format for <paramref name="signature" />.</span></span></param>
        <summary><span data-ttu-id="f2b80-569">验证数字签名对于所提供的数据是否有效。</span><span class="sxs-lookup"><span data-stu-id="f2b80-569">Verifies that a digital signature is valid for the provided data.</span></span></summary>
        <returns><span data-ttu-id="f2b80-570">如果数字签名对所提供的数据有效，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="f2b80-570"><see langword="true" /> if the digital signature is valid for the provided data; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f2b80-571"><paramref name="data" /> 或 <paramref name="signature" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="f2b80-571"><paramref name="data" /> or <paramref name="signature" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="f2b80-572"><paramref name="signatureFormat" /> 不是已知格式。</span><span class="sxs-lookup"><span data-stu-id="f2b80-572"><paramref name="signatureFormat" /> is not a known format.</span></span>
 
<span data-ttu-id="f2b80-573">- 或 -</span><span class="sxs-lookup"><span data-stu-id="f2b80-573">-or-</span></span> 
 <span data-ttu-id="f2b80-574"><paramref name="offset" /> 小于零。</span><span class="sxs-lookup"><span data-stu-id="f2b80-574"><paramref name="offset" /> is less than zero.</span></span>
 
<span data-ttu-id="f2b80-575">- 或 -</span><span class="sxs-lookup"><span data-stu-id="f2b80-575">-or-</span></span> 
 <span data-ttu-id="f2b80-576"><paramref name="count" /> 小于零。</span><span class="sxs-lookup"><span data-stu-id="f2b80-576"><paramref name="count" /> is less than zero.</span></span>
 
<span data-ttu-id="f2b80-577">- 或 -</span><span class="sxs-lookup"><span data-stu-id="f2b80-577">-or-</span></span> 
 <span data-ttu-id="f2b80-578"><paramref name="offset" /> + <paramref name="count" /> - 1 会导致超出 <paramref name="data" /> 上限的索引。</span><span class="sxs-lookup"><span data-stu-id="f2b80-578"><paramref name="offset" /> + <paramref name="count" /> - 1 results in an index that is beyond the upper bound of <paramref name="data" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="f2b80-579"><paramref name="hashAlgorithm" /> 具有 <see langword="null" /> 或空的 <see cref="P:System.Security.Cryptography.HashAlgorithmName.Name" />。</span><span class="sxs-lookup"><span data-stu-id="f2b80-579"><paramref name="hashAlgorithm" /> has a <see langword="null" /> or empty <see cref="P:System.Security.Cryptography.HashAlgorithmName.Name" />.</span></span></exception>
        <exception cref="T:System.Security.Cryptography.CryptographicException"><span data-ttu-id="f2b80-580">哈希处理或验证时出错。</span><span class="sxs-lookup"><span data-stu-id="f2b80-580">An error occurred in the hashing or verification operation.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="VerifyDataCore">
      <MemberSignature Language="C#" Value="protected virtual bool VerifyDataCore (System.IO.Stream? data, ReadOnlySpan&lt;byte&gt; signature, System.Security.Cryptography.HashAlgorithmName hashAlgorithm, System.Security.Cryptography.DSASignatureFormat signatureFormat);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool VerifyDataCore(class System.IO.Stream data, valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; signature, valuetype System.Security.Cryptography.HashAlgorithmName hashAlgorithm, valuetype System.Security.Cryptography.DSASignatureFormat signatureFormat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDsa.VerifyDataCore(System.IO.Stream,System.ReadOnlySpan{System.Byte},System.Security.Cryptography.HashAlgorithmName,System.Security.Cryptography.DSASignatureFormat)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function VerifyDataCore (data As Stream, signature As ReadOnlySpan(Of Byte), hashAlgorithm As HashAlgorithmName, signatureFormat As DSASignatureFormat) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool VerifyDataCore(System::IO::Stream ^ data, ReadOnlySpan&lt;System::Byte&gt; signature, System::Security::Cryptography::HashAlgorithmName hashAlgorithm, System::Security::Cryptography::DSASignatureFormat signatureFormat);" />
      <MemberSignature Language="F#" Value="abstract member VerifyDataCore : System.IO.Stream * ReadOnlySpan&lt;byte&gt; * System.Security.Cryptography.HashAlgorithmName * System.Security.Cryptography.DSASignatureFormat -&gt; bool&#xA;override this.VerifyDataCore : System.IO.Stream * ReadOnlySpan&lt;byte&gt; * System.Security.Cryptography.HashAlgorithmName * System.Security.Cryptography.DSASignatureFormat -&gt; bool" Usage="eCDsa.VerifyDataCore (data, signature, hashAlgorithm, signatureFormat)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.IO.Stream" Index="0" FrameworkAlternate="net-5.0" />
        <Parameter Name="signature" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="1" FrameworkAlternate="net-5.0" />
        <Parameter Name="hashAlgorithm" Type="System.Security.Cryptography.HashAlgorithmName" Index="2" FrameworkAlternate="net-5.0" />
        <Parameter Name="signatureFormat" Type="System.Security.Cryptography.DSASignatureFormat" Index="3" FrameworkAlternate="net-5.0" />
      </Parameters>
      <Docs>
        <param name="data"><span data-ttu-id="f2b80-581">已签名的数据。</span><span class="sxs-lookup"><span data-stu-id="f2b80-581">The signed data.</span></span></param>
        <param name="signature"><span data-ttu-id="f2b80-582">要验证的签名。</span><span class="sxs-lookup"><span data-stu-id="f2b80-582">The signature to verify.</span></span></param>
        <param name="hashAlgorithm"><span data-ttu-id="f2b80-583">用于对验证过程的数据进行哈希处理的哈希算法。</span><span class="sxs-lookup"><span data-stu-id="f2b80-583">The hash algorithm used to hash the data for the verification process.</span></span></param>
        <param name="signatureFormat"><span data-ttu-id="f2b80-584"><paramref name="signature" /> 的编码格式。</span><span class="sxs-lookup"><span data-stu-id="f2b80-584">The encoding format for <paramref name="signature" />.</span></span></param>
        <summary><span data-ttu-id="f2b80-585">验证数字签名对于所提供的数据是否有效。</span><span class="sxs-lookup"><span data-stu-id="f2b80-585">Verifies that a digital signature is valid for the provided data.</span></span></summary>
        <returns><span data-ttu-id="f2b80-586">如果数字签名对所提供的数据有效，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="f2b80-586"><see langword="true" /> if the digital signature is valid for the provided data; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException"><span data-ttu-id="f2b80-587">哈希处理或验证时出错。</span><span class="sxs-lookup"><span data-stu-id="f2b80-587">An error occurred in the hashing or verification operation.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="VerifyDataCore">
      <MemberSignature Language="C#" Value="protected virtual bool VerifyDataCore (ReadOnlySpan&lt;byte&gt; data, ReadOnlySpan&lt;byte&gt; signature, System.Security.Cryptography.HashAlgorithmName hashAlgorithm, System.Security.Cryptography.DSASignatureFormat signatureFormat);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool VerifyDataCore(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; data, valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; signature, valuetype System.Security.Cryptography.HashAlgorithmName hashAlgorithm, valuetype System.Security.Cryptography.DSASignatureFormat signatureFormat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDsa.VerifyDataCore(System.ReadOnlySpan{System.Byte},System.ReadOnlySpan{System.Byte},System.Security.Cryptography.HashAlgorithmName,System.Security.Cryptography.DSASignatureFormat)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function VerifyDataCore (data As ReadOnlySpan(Of Byte), signature As ReadOnlySpan(Of Byte), hashAlgorithm As HashAlgorithmName, signatureFormat As DSASignatureFormat) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool VerifyDataCore(ReadOnlySpan&lt;System::Byte&gt; data, ReadOnlySpan&lt;System::Byte&gt; signature, System::Security::Cryptography::HashAlgorithmName hashAlgorithm, System::Security::Cryptography::DSASignatureFormat signatureFormat);" />
      <MemberSignature Language="F#" Value="abstract member VerifyDataCore : ReadOnlySpan&lt;byte&gt; * ReadOnlySpan&lt;byte&gt; * System.Security.Cryptography.HashAlgorithmName * System.Security.Cryptography.DSASignatureFormat -&gt; bool&#xA;override this.VerifyDataCore : ReadOnlySpan&lt;byte&gt; * ReadOnlySpan&lt;byte&gt; * System.Security.Cryptography.HashAlgorithmName * System.Security.Cryptography.DSASignatureFormat -&gt; bool" Usage="eCDsa.VerifyDataCore (data, signature, hashAlgorithm, signatureFormat)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="0" FrameworkAlternate="net-5.0" />
        <Parameter Name="signature" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="1" FrameworkAlternate="net-5.0" />
        <Parameter Name="hashAlgorithm" Type="System.Security.Cryptography.HashAlgorithmName" Index="2" FrameworkAlternate="net-5.0" />
        <Parameter Name="signatureFormat" Type="System.Security.Cryptography.DSASignatureFormat" Index="3" FrameworkAlternate="net-5.0" />
      </Parameters>
      <Docs>
        <param name="data"><span data-ttu-id="f2b80-588">已签名的数据。</span><span class="sxs-lookup"><span data-stu-id="f2b80-588">The signed data.</span></span></param>
        <param name="signature"><span data-ttu-id="f2b80-589">要验证的签名。</span><span class="sxs-lookup"><span data-stu-id="f2b80-589">The signature to verify.</span></span></param>
        <param name="hashAlgorithm"><span data-ttu-id="f2b80-590">用于对验证过程的数据进行哈希处理的哈希算法。</span><span class="sxs-lookup"><span data-stu-id="f2b80-590">The hash algorithm used to hash the data for the verification process.</span></span></param>
        <param name="signatureFormat"><span data-ttu-id="f2b80-591"><paramref name="signature" /> 的编码格式。</span><span class="sxs-lookup"><span data-stu-id="f2b80-591">The encoding format for <paramref name="signature" />.</span></span></param>
        <summary><span data-ttu-id="f2b80-592">验证数字签名对于所提供的数据是否有效。</span><span class="sxs-lookup"><span data-stu-id="f2b80-592">Verifies that a digital signature is valid for the provided data.</span></span></summary>
        <returns><span data-ttu-id="f2b80-593">如果数字签名对所提供的数据有效，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="f2b80-593"><see langword="true" /> if the digital signature is valid for the provided data; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException"><span data-ttu-id="f2b80-594">哈希处理或验证时出错。</span><span class="sxs-lookup"><span data-stu-id="f2b80-594">An error occurred in the hashing or verification operation.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="VerifyHash">
      <MemberSignature Language="C#" Value="public abstract bool VerifyHash (byte[] hash, byte[] signature);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool VerifyHash(unsigned int8[] hash, unsigned int8[] signature) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDsa.VerifyHash(System.Byte[],System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function VerifyHash (hash As Byte(), signature As Byte()) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract bool VerifyHash(cli::array &lt;System::Byte&gt; ^ hash, cli::array &lt;System::Byte&gt; ^ signature);" />
      <MemberSignature Language="F#" Value="abstract member VerifyHash : byte[] * byte[] -&gt; bool" Usage="eCDsa.VerifyHash (hash, signature)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.3.0.0</AssemblyVersion>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
        <AssemblyVersion>4.3.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="hash" Type="System.Byte[]" />
        <Parameter Name="signature" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="hash"><span data-ttu-id="f2b80-595">待验证的数据的哈希值。</span><span class="sxs-lookup"><span data-stu-id="f2b80-595">The hash value of the data to be verified.</span></span></param>
        <param name="signature"><span data-ttu-id="f2b80-596">要结合哈希值验证的数据的数字签名。</span><span class="sxs-lookup"><span data-stu-id="f2b80-596">The digital signature of the data to be verified against the hash value.</span></span></param>
        <summary><span data-ttu-id="f2b80-597">验证数字签名是否适用于当前密钥和提供的数据哈希。</span><span class="sxs-lookup"><span data-stu-id="f2b80-597">Verifies that a digital signature is appropriate for the current key and provided data hash.</span></span></summary>
        <returns><span data-ttu-id="f2b80-598">如果签名有效，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="f2b80-598"><see langword="true" /> if the signature is valid; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f2b80-599"><paramref name="hash" /> 或 <paramref name="signature" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="f2b80-599"><paramref name="hash" /> or <paramref name="signature" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="VerifyHash">
      <MemberSignature Language="C#" Value="public virtual bool VerifyHash (ReadOnlySpan&lt;byte&gt; hash, ReadOnlySpan&lt;byte&gt; signature);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool VerifyHash(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; hash, valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; signature) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDsa.VerifyHash(System.ReadOnlySpan{System.Byte},System.ReadOnlySpan{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function VerifyHash (hash As ReadOnlySpan(Of Byte), signature As ReadOnlySpan(Of Byte)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool VerifyHash(ReadOnlySpan&lt;System::Byte&gt; hash, ReadOnlySpan&lt;System::Byte&gt; signature);" />
      <MemberSignature Language="F#" Value="abstract member VerifyHash : ReadOnlySpan&lt;byte&gt; * ReadOnlySpan&lt;byte&gt; -&gt; bool&#xA;override this.VerifyHash : ReadOnlySpan&lt;byte&gt; * ReadOnlySpan&lt;byte&gt; -&gt; bool" Usage="eCDsa.VerifyHash (hash, signature)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
        <AssemblyVersion>4.3.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="hash" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="0" FrameworkAlternate="net-5.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1" />
        <Parameter Name="signature" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="1" FrameworkAlternate="net-5.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="hash"><span data-ttu-id="f2b80-600">待验证的数据的哈希值。</span><span class="sxs-lookup"><span data-stu-id="f2b80-600">The hash value of the data to be verified.</span></span></param>
        <param name="signature"><span data-ttu-id="f2b80-601">要结合哈希值验证的数据的数字签名。</span><span class="sxs-lookup"><span data-stu-id="f2b80-601">The digital signature of the data to be verified against the hash value.</span></span></param>
        <summary><span data-ttu-id="f2b80-602">验证数字签名是否适用于当前密钥和提供的数据哈希。</span><span class="sxs-lookup"><span data-stu-id="f2b80-602">Verifies that a digital signature is appropriate for the current key and provided data hash.</span></span></summary>
        <returns><span data-ttu-id="f2b80-603">如果签名有效，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="f2b80-603"><see langword="true" /> if the signature is valid; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="VerifyHash">
      <MemberSignature Language="C#" Value="public bool VerifyHash (byte[] hash, byte[] signature, System.Security.Cryptography.DSASignatureFormat signatureFormat);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool VerifyHash(unsigned int8[] hash, unsigned int8[] signature, valuetype System.Security.Cryptography.DSASignatureFormat signatureFormat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDsa.VerifyHash(System.Byte[],System.Byte[],System.Security.Cryptography.DSASignatureFormat)" />
      <MemberSignature Language="VB.NET" Value="Public Function VerifyHash (hash As Byte(), signature As Byte(), signatureFormat As DSASignatureFormat) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool VerifyHash(cli::array &lt;System::Byte&gt; ^ hash, cli::array &lt;System::Byte&gt; ^ signature, System::Security::Cryptography::DSASignatureFormat signatureFormat);" />
      <MemberSignature Language="F#" Value="member this.VerifyHash : byte[] * byte[] * System.Security.Cryptography.DSASignatureFormat -&gt; bool" Usage="eCDsa.VerifyHash (hash, signature, signatureFormat)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="hash" Type="System.Byte[]" Index="0" FrameworkAlternate="net-5.0" />
        <Parameter Name="signature" Type="System.Byte[]" Index="1" FrameworkAlternate="net-5.0" />
        <Parameter Name="signatureFormat" Type="System.Security.Cryptography.DSASignatureFormat" Index="2" FrameworkAlternate="net-5.0" />
      </Parameters>
      <Docs>
        <param name="hash"><span data-ttu-id="f2b80-604">已签名的哈希。</span><span class="sxs-lookup"><span data-stu-id="f2b80-604">The signed hash.</span></span></param>
        <param name="signature"><span data-ttu-id="f2b80-605">要验证的签名。</span><span class="sxs-lookup"><span data-stu-id="f2b80-605">The signature to verify.</span></span></param>
        <param name="signatureFormat"><span data-ttu-id="f2b80-606"><paramref name="signature" /> 的编码格式。</span><span class="sxs-lookup"><span data-stu-id="f2b80-606">The encoding format for <paramref name="signature" />.</span></span></param>
        <summary><span data-ttu-id="f2b80-607">验证数字签名对于所提供的哈希是否有效。</span><span class="sxs-lookup"><span data-stu-id="f2b80-607">Verifies that a digital signature is valid for the provided hash.</span></span></summary>
        <returns><span data-ttu-id="f2b80-608">如果数字签名对所提供的数据有效，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="f2b80-608"><see langword="true" /> if the digital signature is valid for the provided data; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f2b80-609"><paramref name="hash" /> 或 <paramref name="signature" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="f2b80-609"><paramref name="hash" /> or <paramref name="signature" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="f2b80-610"><paramref name="signatureFormat" /> 不是已知格式。</span><span class="sxs-lookup"><span data-stu-id="f2b80-610"><paramref name="signatureFormat" /> is not a known format.</span></span></exception>
        <exception cref="T:System.Security.Cryptography.CryptographicException"><span data-ttu-id="f2b80-611">验证时出错。</span><span class="sxs-lookup"><span data-stu-id="f2b80-611">An error occurred in the verification operation.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="VerifyHash">
      <MemberSignature Language="C#" Value="public bool VerifyHash (ReadOnlySpan&lt;byte&gt; hash, ReadOnlySpan&lt;byte&gt; signature, System.Security.Cryptography.DSASignatureFormat signatureFormat);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool VerifyHash(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; hash, valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; signature, valuetype System.Security.Cryptography.DSASignatureFormat signatureFormat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDsa.VerifyHash(System.ReadOnlySpan{System.Byte},System.ReadOnlySpan{System.Byte},System.Security.Cryptography.DSASignatureFormat)" />
      <MemberSignature Language="VB.NET" Value="Public Function VerifyHash (hash As ReadOnlySpan(Of Byte), signature As ReadOnlySpan(Of Byte), signatureFormat As DSASignatureFormat) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool VerifyHash(ReadOnlySpan&lt;System::Byte&gt; hash, ReadOnlySpan&lt;System::Byte&gt; signature, System::Security::Cryptography::DSASignatureFormat signatureFormat);" />
      <MemberSignature Language="F#" Value="member this.VerifyHash : ReadOnlySpan&lt;byte&gt; * ReadOnlySpan&lt;byte&gt; * System.Security.Cryptography.DSASignatureFormat -&gt; bool" Usage="eCDsa.VerifyHash (hash, signature, signatureFormat)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="hash" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="0" FrameworkAlternate="net-5.0" />
        <Parameter Name="signature" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="1" FrameworkAlternate="net-5.0" />
        <Parameter Name="signatureFormat" Type="System.Security.Cryptography.DSASignatureFormat" Index="2" FrameworkAlternate="net-5.0" />
      </Parameters>
      <Docs>
        <param name="hash"><span data-ttu-id="f2b80-612">已签名的哈希。</span><span class="sxs-lookup"><span data-stu-id="f2b80-612">The signed hash.</span></span></param>
        <param name="signature"><span data-ttu-id="f2b80-613">要验证的签名。</span><span class="sxs-lookup"><span data-stu-id="f2b80-613">The signature to verify.</span></span></param>
        <param name="signatureFormat"><span data-ttu-id="f2b80-614"><paramref name="signature" /> 的编码格式。</span><span class="sxs-lookup"><span data-stu-id="f2b80-614">The encoding format for <paramref name="signature" />.</span></span></param>
        <summary><span data-ttu-id="f2b80-615">验证数字签名对于所提供的哈希是否有效。</span><span class="sxs-lookup"><span data-stu-id="f2b80-615">Verifies that a digital signature is valid for the provided hash.</span></span></summary>
        <returns><span data-ttu-id="f2b80-616">如果数字签名对所提供的数据有效，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="f2b80-616"><see langword="true" /> if the digital signature is valid for the provided data; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="f2b80-617"><paramref name="signatureFormat" /> 不是已知格式。</span><span class="sxs-lookup"><span data-stu-id="f2b80-617"><paramref name="signatureFormat" /> is not a known format.</span></span></exception>
        <exception cref="T:System.Security.Cryptography.CryptographicException"><span data-ttu-id="f2b80-618">验证时出错。</span><span class="sxs-lookup"><span data-stu-id="f2b80-618">An error occurred in the verification operation.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="VerifyHashCore">
      <MemberSignature Language="C#" Value="protected virtual bool VerifyHashCore (ReadOnlySpan&lt;byte&gt; hash, ReadOnlySpan&lt;byte&gt; signature, System.Security.Cryptography.DSASignatureFormat signatureFormat);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool VerifyHashCore(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; hash, valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; signature, valuetype System.Security.Cryptography.DSASignatureFormat signatureFormat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDsa.VerifyHashCore(System.ReadOnlySpan{System.Byte},System.ReadOnlySpan{System.Byte},System.Security.Cryptography.DSASignatureFormat)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function VerifyHashCore (hash As ReadOnlySpan(Of Byte), signature As ReadOnlySpan(Of Byte), signatureFormat As DSASignatureFormat) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool VerifyHashCore(ReadOnlySpan&lt;System::Byte&gt; hash, ReadOnlySpan&lt;System::Byte&gt; signature, System::Security::Cryptography::DSASignatureFormat signatureFormat);" />
      <MemberSignature Language="F#" Value="abstract member VerifyHashCore : ReadOnlySpan&lt;byte&gt; * ReadOnlySpan&lt;byte&gt; * System.Security.Cryptography.DSASignatureFormat -&gt; bool&#xA;override this.VerifyHashCore : ReadOnlySpan&lt;byte&gt; * ReadOnlySpan&lt;byte&gt; * System.Security.Cryptography.DSASignatureFormat -&gt; bool" Usage="eCDsa.VerifyHashCore (hash, signature, signatureFormat)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="hash" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="0" FrameworkAlternate="net-5.0" />
        <Parameter Name="signature" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="1" FrameworkAlternate="net-5.0" />
        <Parameter Name="signatureFormat" Type="System.Security.Cryptography.DSASignatureFormat" Index="2" FrameworkAlternate="net-5.0" />
      </Parameters>
      <Docs>
        <param name="hash"><span data-ttu-id="f2b80-619">已签名的哈希。</span><span class="sxs-lookup"><span data-stu-id="f2b80-619">The signed hash.</span></span></param>
        <param name="signature"><span data-ttu-id="f2b80-620">要验证的签名。</span><span class="sxs-lookup"><span data-stu-id="f2b80-620">The signature to verify.</span></span></param>
        <param name="signatureFormat"><span data-ttu-id="f2b80-621"><paramref name="signature" /> 的编码格式。</span><span class="sxs-lookup"><span data-stu-id="f2b80-621">The encoding format for <paramref name="signature" />.</span></span></param>
        <summary><span data-ttu-id="f2b80-622">验证数字签名对于所提供的哈希是否有效。</span><span class="sxs-lookup"><span data-stu-id="f2b80-622">Verifies that a digital signature is valid for the provided hash.</span></span></summary>
        <returns><span data-ttu-id="f2b80-623">如果数字签名对所提供的数据有效，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="f2b80-623"><see langword="true" /> if the digital signature is valid for the provided data; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException"><span data-ttu-id="f2b80-624">验证时出错。</span><span class="sxs-lookup"><span data-stu-id="f2b80-624">An error occurred in the verification operation.</span></span></exception>
      </Docs>
    </Member>
  </Members>
</Type>
