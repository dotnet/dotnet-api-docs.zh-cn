<Type Name="PemEncoding" FullName="System.Security.Cryptography.PemEncoding">
  <Metadata><Meta Name="ms.openlocfilehash" Value="08ae1fc5427a8a2fb18e73b9eb70a3cd4a2aac9c" /><Meta Name="ms.sourcegitcommit" Value="ec905a25e6dd05a6a3ffa7f30bf59f3095a8cd67" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-CN" /><Meta Name="ms.lasthandoff" Value="09/01/2020" /><Meta Name="ms.locfileid" Value="89250379" /></Metadata><TypeSignature Language="C#" Value="public static class PemEncoding" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit PemEncoding extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Security.Cryptography.PemEncoding" />
  <TypeSignature Language="VB.NET" Value="Public Class PemEncoding" />
  <TypeSignature Language="C++ CLI" Value="public ref class PemEncoding abstract sealed" />
  <TypeSignature Language="F#" Value="type PemEncoding = class" />
  <AssemblyInfo>
    <AssemblyName>System.Security.Cryptography.Encoding</AssemblyName>
    <AssemblyVersion>5.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary><span data-ttu-id="595a3-101">提供用于读写 PEM（隐私增强邮件）文本编码的 IETF RFC 7468 子集的方法。</span><span class="sxs-lookup"><span data-stu-id="595a3-101">Provides methods for reading and writing the IETF RFC 7468 subset of PEM (Privacy-Enhanced Mail) textual encodings.</span></span>
<span data-ttu-id="595a3-102">此类不能被继承。</span><span class="sxs-lookup"><span data-stu-id="595a3-102">This class cannot be inherited.</span></span></summary>
    <remarks>To be added.</remarks>
  </Docs>
  <Members>
    <Member MemberName="Find">
      <MemberSignature Language="C#" Value="public static System.Security.Cryptography.PemFields Find (ReadOnlySpan&lt;char&gt; pemData);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Security.Cryptography.PemFields Find(valuetype System.ReadOnlySpan`1&lt;char&gt; pemData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.PemEncoding.Find(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Find (pemData As ReadOnlySpan(Of Char)) As PemFields" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Security::Cryptography::PemFields Find(ReadOnlySpan&lt;char&gt; pemData);" />
      <MemberSignature Language="F#" Value="static member Find : ReadOnlySpan&lt;char&gt; -&gt; System.Security.Cryptography.PemFields" Usage="System.Security.Cryptography.PemEncoding.Find pemData" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Encoding</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.PemFields</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pemData" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
      </Parameters>
      <Docs>
        <param name="pemData"><span data-ttu-id="595a3-103">包含 PEM 编码数据的文本。</span><span class="sxs-lookup"><span data-stu-id="595a3-103">The text containing the PEM-encoded data.</span></span></param>
        <summary><span data-ttu-id="595a3-104">查找第一个 PEM 编码的数据。</span><span class="sxs-lookup"><span data-stu-id="595a3-104">Finds the first PEM-encoded data.</span></span></summary>
        <returns><span data-ttu-id="595a3-105">用于指定编码数据的位置、标签和数据位置的值。</span><span class="sxs-lookup"><span data-stu-id="595a3-105">A value that specifies the location, label, and data location of the encoded data.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

IETF RFC 7468 permits different decoding rules. <span data-ttu-id="595a3-107">此方法始终使用宽松规则。</span><span class="sxs-lookup"><span data-stu-id="595a3-107">This method always uses lax rules.</span></span>

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="595a3-108"><paramref name="pemData" /> 不包含格式正确的 PEM 编码值。</span><span class="sxs-lookup"><span data-stu-id="595a3-108"><paramref name="pemData" /> does not contain a well-formed PEM-encoded value.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetEncodedSize">
      <MemberSignature Language="C#" Value="public static int GetEncodedSize (int labelLength, int dataLength);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetEncodedSize(int32 labelLength, int32 dataLength) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.PemEncoding.GetEncodedSize(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEncodedSize (labelLength As Integer, dataLength As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int GetEncodedSize(int labelLength, int dataLength);" />
      <MemberSignature Language="F#" Value="static member GetEncodedSize : int * int -&gt; int" Usage="System.Security.Cryptography.PemEncoding.GetEncodedSize (labelLength, dataLength)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Encoding</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="labelLength" Type="System.Int32" />
        <Parameter Name="dataLength" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="labelLength"><span data-ttu-id="595a3-109">标签的长度（以字符为单位）。</span><span class="sxs-lookup"><span data-stu-id="595a3-109">The length of the label, in characters.</span></span></param>
        <param name="dataLength"><span data-ttu-id="595a3-110">数据的长度（以字节为单位）。</span><span class="sxs-lookup"><span data-stu-id="595a3-110">The length of the data, in bytes.</span></span></param>
        <summary><span data-ttu-id="595a3-111">根据给定的标签和二进制数据的长度，确定 PEM 编码值的长度（以字符为单位）。</span><span class="sxs-lookup"><span data-stu-id="595a3-111">Determines the length of a PEM-encoded value, in characters, given the length of a label and binary data.</span></span></summary>
        <returns><span data-ttu-id="595a3-112">编码的 PEM 中的字符数。</span><span class="sxs-lookup"><span data-stu-id="595a3-112">The number of characters in the encoded PEM.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="595a3-113"><paramref name="labelLength" /> 是负值。</span><span class="sxs-lookup"><span data-stu-id="595a3-113"><paramref name="labelLength" /> is a negative value.</span></span>

<span data-ttu-id="595a3-114">- 或 -</span><span class="sxs-lookup"><span data-stu-id="595a3-114">-or-</span></span>

<span data-ttu-id="595a3-115"><paramref name="dataLength" /> 是负值。</span><span class="sxs-lookup"><span data-stu-id="595a3-115"><paramref name="dataLength" /> is a negative value.</span></span>

<span data-ttu-id="595a3-116">- 或 -</span><span class="sxs-lookup"><span data-stu-id="595a3-116">-or-</span></span>

<span data-ttu-id="595a3-117"><paramref name="labelLength" /> 超出了可用的最大标签长度。</span><span class="sxs-lookup"><span data-stu-id="595a3-117"><paramref name="labelLength" /> exceeds the maximum possible label length.</span></span>

<span data-ttu-id="595a3-118">- 或 -</span><span class="sxs-lookup"><span data-stu-id="595a3-118">-or-</span></span>

<span data-ttu-id="595a3-119"><paramref name="dataLength" /> 超出了可用的编码数据长度。</span><span class="sxs-lookup"><span data-stu-id="595a3-119"><paramref name="dataLength" /> exceeds the maximum possible encoded data length.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="595a3-120">PEM 编码值的长度大于 <see cref="F:System.Int32.MaxValue" />。</span><span class="sxs-lookup"><span data-stu-id="595a3-120">The length of the PEM-encoded value is larger than <see cref="F:System.Int32.MaxValue" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="TryFind">
      <MemberSignature Language="C#" Value="public static bool TryFind (ReadOnlySpan&lt;char&gt; pemData, out System.Security.Cryptography.PemFields fields);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryFind(valuetype System.ReadOnlySpan`1&lt;char&gt; pemData, [out] valuetype System.Security.Cryptography.PemFields&amp; fields) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.PemEncoding.TryFind(System.ReadOnlySpan{System.Char},System.Security.Cryptography.PemFields@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryFind (pemData As ReadOnlySpan(Of Char), ByRef fields As PemFields) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryFind(ReadOnlySpan&lt;char&gt; pemData, [Runtime::InteropServices::Out] System::Security::Cryptography::PemFields % fields);" />
      <MemberSignature Language="F#" Value="static member TryFind : ReadOnlySpan&lt;char&gt; * PemFields -&gt; bool" Usage="System.Security.Cryptography.PemEncoding.TryFind (pemData, fields)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Encoding</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pemData" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="fields" Type="System.Security.Cryptography.PemFields" RefType="out" />
      </Parameters>
      <Docs>
        <param name="pemData"><span data-ttu-id="595a3-121">包含 PEM 编码数据的文本。</span><span class="sxs-lookup"><span data-stu-id="595a3-121">The text containing the PEM-encoded data.</span></span></param>
        <param name="fields"><span data-ttu-id="595a3-122">此方法返回时，包含一个指定已编码数据的位置、标签和数据位置的值；或者，如果找不到 PEM 编码的数据，则包含一个指定这些位置为空的值。</span><span class="sxs-lookup"><span data-stu-id="595a3-122">When this method returns, contains a value that specifies the location, label, and data location of the encoded data; or, if no PEM-encoded data is found, a value that specifies those locations as empty.</span></span>

          <span data-ttu-id="595a3-123">该参数未经初始化即被处理。</span><span class="sxs-lookup"><span data-stu-id="595a3-123">This parameter is treated as uninitialized.</span></span></param>
        <summary><span data-ttu-id="595a3-124">尝试查找第一个 PEM 编码的数据。</span><span class="sxs-lookup"><span data-stu-id="595a3-124">Attempts to find the first PEM-encoded data.</span></span></summary>
        <returns><span data-ttu-id="595a3-125">如果已找到 PEM 编码的数据，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="595a3-125"><see langword="true" /> if PEM-encoded data was found; otherwise <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

IETF RFC 7468 permits different decoding rules. <span data-ttu-id="595a3-127">此方法始终使用宽松规则。</span><span class="sxs-lookup"><span data-stu-id="595a3-127">This method always uses lax rules.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryWrite">
      <MemberSignature Language="C#" Value="public static bool TryWrite (ReadOnlySpan&lt;char&gt; label, ReadOnlySpan&lt;byte&gt; data, Span&lt;char&gt; destination, out int charsWritten);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryWrite(valuetype System.ReadOnlySpan`1&lt;char&gt; label, valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; data, valuetype System.Span`1&lt;char&gt; destination, [out] int32&amp; charsWritten) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.PemEncoding.TryWrite(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Byte},System.Span{System.Char},System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryWrite (label As ReadOnlySpan(Of Char), data As ReadOnlySpan(Of Byte), destination As Span(Of Char), ByRef charsWritten As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryWrite(ReadOnlySpan&lt;char&gt; label, ReadOnlySpan&lt;System::Byte&gt; data, Span&lt;char&gt; destination, [Runtime::InteropServices::Out] int % charsWritten);" />
      <MemberSignature Language="F#" Value="static member TryWrite : ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;byte&gt; * Span&lt;char&gt; * int -&gt; bool" Usage="System.Security.Cryptography.PemEncoding.TryWrite (label, data, destination, charsWritten)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Encoding</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="label" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="data" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
        <Parameter Name="destination" Type="System.Span&lt;System.Char&gt;" />
        <Parameter Name="charsWritten" Type="System.Int32" RefType="out" />
      </Parameters>
      <Docs>
        <param name="label"><span data-ttu-id="595a3-128">要写入的标签。</span><span class="sxs-lookup"><span data-stu-id="595a3-128">The label to write.</span></span></param>
        <param name="data"><span data-ttu-id="595a3-129">要写入的数据。</span><span class="sxs-lookup"><span data-stu-id="595a3-129">The data to write.</span></span></param>
        <param name="destination"><span data-ttu-id="595a3-130">用于接收 PEM 编码的文本的缓冲区。</span><span class="sxs-lookup"><span data-stu-id="595a3-130">The buffer to receive the PEM-encoded text.</span></span></param>
        <param name="charsWritten"><span data-ttu-id="595a3-131">此方法返回时，此参数包含写入到 <paramref name="destination" /> 中的字符数。</span><span class="sxs-lookup"><span data-stu-id="595a3-131">When this method returns, this parameter contains the number of characters written to <paramref name="destination" />.</span></span> <span data-ttu-id="595a3-132">该参数未经初始化即被处理。</span><span class="sxs-lookup"><span data-stu-id="595a3-132">This parameter is treated as uninitialized.</span></span></param>
        <summary><span data-ttu-id="595a3-133">尝试将提供的数据和标签作为 PEM 编码的数据写入到所提供的缓冲区中。</span><span class="sxs-lookup"><span data-stu-id="595a3-133">Tries to write the provided data and label as PEM-encoded data into a provided buffer.</span></span></summary>
        <returns><span data-ttu-id="595a3-134">如果 <paramref name="destination" /> 大到足以包含 PEM 编码的文本，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="595a3-134"><see langword="true" /> if <paramref name="destination" /> is large enough to contain the PEM-encoded text, otherwise <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

This method always wraps the base-64 encoded text to 64 characters, per the recommended wrapping of IETF RFC 7468. <span data-ttu-id="595a3-136">Unix 样式的行尾用于分行符。</span><span class="sxs-lookup"><span data-stu-id="595a3-136">Unix-style line endings are used for line breaks.</span></span>

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="595a3-137"><paramref name="label" /> 超出了可用的最大标签长度。</span><span class="sxs-lookup"><span data-stu-id="595a3-137"><paramref name="label" /> exceeds the maximum possible label length.</span></span>

<span data-ttu-id="595a3-138">- 或 -</span><span class="sxs-lookup"><span data-stu-id="595a3-138">-or-</span></span>

<span data-ttu-id="595a3-139"><paramref name="data" /> 超出了可用的编码数据长度。</span><span class="sxs-lookup"><span data-stu-id="595a3-139"><paramref name="data" /> exceeds the maximum possible encoded data length.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="595a3-140">生成的 PEM 编码的文本大于 <see cref="F:System.Int32.MaxValue" />。</span><span class="sxs-lookup"><span data-stu-id="595a3-140">The resulting PEM-encoded text is larger than <see cref="F:System.Int32.MaxValue" />.</span></span>

<span data-ttu-id="595a3-141">- 或 -</span><span class="sxs-lookup"><span data-stu-id="595a3-141">-or-</span></span>

<span data-ttu-id="595a3-142"><paramref name="label" /> 包含无效字符。</span><span class="sxs-lookup"><span data-stu-id="595a3-142"><paramref name="label" /> contains invalid characters.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public static char[]? Write (ReadOnlySpan&lt;char&gt; label, ReadOnlySpan&lt;byte&gt; data);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig char[] Write(valuetype System.ReadOnlySpan`1&lt;char&gt; label, valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.PemEncoding.Write(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Write (label As ReadOnlySpan(Of Char), data As ReadOnlySpan(Of Byte)) As Char()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;char&gt; ^ Write(ReadOnlySpan&lt;char&gt; label, ReadOnlySpan&lt;System::Byte&gt; data);" />
      <MemberSignature Language="F#" Value="static member Write : ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;byte&gt; -&gt; char[]" Usage="System.Security.Cryptography.PemEncoding.Write (label, data)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Encoding</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="label" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="data" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
      </Parameters>
      <Docs>
        <param name="label"><span data-ttu-id="595a3-143">要编码的标签。</span><span class="sxs-lookup"><span data-stu-id="595a3-143">The label to encode.</span></span></param>
        <param name="data"><span data-ttu-id="595a3-144">要编码的数据。</span><span class="sxs-lookup"><span data-stu-id="595a3-144">The data to encode.</span></span></param>
        <summary><span data-ttu-id="595a3-145">通过给定的标签和数据创建一个编码的 PEM。</span><span class="sxs-lookup"><span data-stu-id="595a3-145">Creates an encoded PEM with the given label and data.</span></span></summary>
        <returns><span data-ttu-id="595a3-146">已编码 PEM 的字符数组。</span><span class="sxs-lookup"><span data-stu-id="595a3-146">A character array of the encoded PEM.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="595a3-147">此方法始终按建议的 RFC-7468 包装将64编码文本封装为64个字符。</span><span class="sxs-lookup"><span data-stu-id="595a3-147">This method always wraps the base-64 encoded text to 64 characters, per the recommended wrapping of RFC-7468.</span></span> <span data-ttu-id="595a3-148">Unix 样式的行尾用于分行符。</span><span class="sxs-lookup"><span data-stu-id="595a3-148">Unix-style line endings are used for line breaks.</span></span>

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="595a3-149"><paramref name="label" /> 超出了可用的最大标签长度。</span><span class="sxs-lookup"><span data-stu-id="595a3-149"><paramref name="label" /> exceeds the maximum possible label length.</span></span>

<span data-ttu-id="595a3-150">- 或 -</span><span class="sxs-lookup"><span data-stu-id="595a3-150">-or-</span></span>

<span data-ttu-id="595a3-151"><paramref name="data" /> 超出了可用的编码数据长度。</span><span class="sxs-lookup"><span data-stu-id="595a3-151"><paramref name="data" /> exceeds the maximum possible encoded data length.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="595a3-152">生成的 PEM 编码的文本大于 <see cref="F:System.Int32.MaxValue" />。</span><span class="sxs-lookup"><span data-stu-id="595a3-152">The resulting PEM-encoded text is larger than <see cref="F:System.Int32.MaxValue" />.</span></span>

<span data-ttu-id="595a3-153">- 或 -</span><span class="sxs-lookup"><span data-stu-id="595a3-153">-or-</span></span>

<span data-ttu-id="595a3-154"><paramref name="label" /> 包含无效字符。</span><span class="sxs-lookup"><span data-stu-id="595a3-154"><paramref name="label" /> contains invalid characters.</span></span></exception>
      </Docs>
    </Member>
  </Members>
</Type>
