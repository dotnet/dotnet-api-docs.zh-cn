<Type Name="ExceptionDispatchInfo" FullName="System.Runtime.ExceptionServices.ExceptionDispatchInfo">
  <Metadata><Meta Name="ms.openlocfilehash" Value="b3d6d53abc9946d1c93faa17ebb848a0924677aa" /><Meta Name="ms.sourcegitcommit" Value="9a0316374d19cc78674994106d073aa5ef1bd5f3" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-CN" /><Meta Name="ms.lasthandoff" Value="11/10/2020" /><Meta Name="ms.locfileid" Value="94465480" /></Metadata><TypeSignature Language="C#" Value="public sealed class ExceptionDispatchInfo" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit ExceptionDispatchInfo extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Runtime.ExceptionServices.ExceptionDispatchInfo" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class ExceptionDispatchInfo" />
  <TypeSignature Language="C++ CLI" Value="public ref class ExceptionDispatchInfo sealed" />
  <TypeSignature Language="F#" Value="type ExceptionDispatchInfo = class" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
    <AssemblyVersion>4.2.2.0</AssemblyVersion>
    <AssemblyVersion>5.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeForwardingChain>
    <TypeForwarding From="mscorlib" FromVersion="4.0.0.0" To="System.Runtime" ToVersion="0.0.0.0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0" />
    <TypeForwarding From="netstandard" FromVersion="2.1.0.0" To="System.Runtime" ToVersion="5.0.0.0" FrameworkAlternate="net-5.0" />
  </TypeForwardingChain>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary><span data-ttu-id="9f2a4-101">表示在代码中的某个特定点捕获其状态的异常。</span><span class="sxs-lookup"><span data-stu-id="9f2a4-101">Represents an exception whose state is captured at a certain point in code.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9f2a4-102"><xref:System.Runtime.ExceptionServices.ExceptionDispatchInfo>对象存储异常在捕获时所包含的堆栈跟踪信息和 Watson 信息。</span><span class="sxs-lookup"><span data-stu-id="9f2a4-102">The <xref:System.Runtime.ExceptionServices.ExceptionDispatchInfo> object stores the stack trace information and Watson information that the exception contains at the point where it is captured.</span></span> <span data-ttu-id="9f2a4-103">异常可以在另一次引发，还可以通过调用 <xref:System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw%2A?displayProperty=nameWithType> 方法引发。</span><span class="sxs-lookup"><span data-stu-id="9f2a4-103">The exception can be thrown at another time and possibly on another thread by calling the <xref:System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="9f2a4-104">异常的引发方式是它从捕获到该方法的捕获点流向 <xref:System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw%2A> 。</span><span class="sxs-lookup"><span data-stu-id="9f2a4-104">The exception is thrown as if it had flowed from the point where it was captured to the point where the <xref:System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw%2A> method is called.</span></span>  
  
 <span data-ttu-id="9f2a4-105"><xref:System.Runtime.ExceptionServices.ExceptionDispatchInfo> 无法进行序列化，并且不用于跨应用程序域边界。</span><span class="sxs-lookup"><span data-stu-id="9f2a4-105"><xref:System.Runtime.ExceptionServices.ExceptionDispatchInfo> cannot be serialized and is not intended to cross application domain boundaries.</span></span>  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="Capture">
      <MemberSignature Language="C#" Value="public static System.Runtime.ExceptionServices.ExceptionDispatchInfo Capture (Exception source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.ExceptionServices.ExceptionDispatchInfo Capture(class System.Exception source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.ExceptionServices.ExceptionDispatchInfo.Capture(System.Exception)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Capture (source As Exception) As ExceptionDispatchInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::ExceptionServices::ExceptionDispatchInfo ^ Capture(Exception ^ source);" />
      <MemberSignature Language="F#" Value="static member Capture : Exception -&gt; System.Runtime.ExceptionServices.ExceptionDispatchInfo" Usage="System.Runtime.ExceptionServices.ExceptionDispatchInfo.Capture source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.ExceptionServices.ExceptionDispatchInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Exception" />
      </Parameters>
      <Docs>
        <param name="source"><span data-ttu-id="9f2a4-106">由一个返回的对象表示且状态被捕获的异常。</span><span class="sxs-lookup"><span data-stu-id="9f2a4-106">The exception whose state is captured, and which is represented by the returned object.</span></span></param>
        <summary><span data-ttu-id="9f2a4-107">创建 <see cref="T:System.Runtime.ExceptionServices.ExceptionDispatchInfo" /> 对象，此对象在代码当前点表示指定异常。</span><span class="sxs-lookup"><span data-stu-id="9f2a4-107">Creates an <see cref="T:System.Runtime.ExceptionServices.ExceptionDispatchInfo" /> object that represents the specified exception at the current point in code.</span></span></summary>
        <returns><span data-ttu-id="9f2a4-108">表示代码中当前点的指定异常的对象。</span><span class="sxs-lookup"><span data-stu-id="9f2a4-108">An object that represents the specified exception at the current point in code.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9f2a4-109">您可以在 <xref:System.Runtime.ExceptionServices.ExceptionDispatchInfo> 另一次使用此方法返回的对象，并可能在另一个线程上重新引发指定的异常，就好像该异常在被捕获到重新引发它的点处为止。</span><span class="sxs-lookup"><span data-stu-id="9f2a4-109">You can use the <xref:System.Runtime.ExceptionServices.ExceptionDispatchInfo> object that is returned by this method at another time and possibly on another thread to rethrow the specified exception, as if the exception had flowed from this point where it was captured to the point where it is rethrown.</span></span>  
  
 <span data-ttu-id="9f2a4-110">如果异常在捕获时处于活动状态，则会存储异常中包含的当前堆栈跟踪信息和 Watson 信息。</span><span class="sxs-lookup"><span data-stu-id="9f2a4-110">If the exception is active when it is captured, the current stack trace information and Watson information that is contained in the exception is stored.</span></span>  <span data-ttu-id="9f2a4-111">如果它处于非活动状态，即，如果尚未引发它，则它将不会有任何堆栈跟踪信息或 Watson 信息。</span><span class="sxs-lookup"><span data-stu-id="9f2a4-111">If it is inactive, that is, if it has not been thrown, it will not have any stack trace information or Watson information.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="9f2a4-112"><paramref name="source" /> 上声明的默认值为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="9f2a4-112"><paramref name="source" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="SetCurrentStackTrace">
      <MemberSignature Language="C#" Value="public static Exception SetCurrentStackTrace (Exception source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Exception SetCurrentStackTrace(class System.Exception source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.ExceptionServices.ExceptionDispatchInfo.SetCurrentStackTrace(System.Exception)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SetCurrentStackTrace (source As Exception) As Exception" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Exception ^ SetCurrentStackTrace(Exception ^ source);" />
      <MemberSignature Language="F#" Value="static member SetCurrentStackTrace : Exception -&gt; Exception" Usage="System.Runtime.ExceptionServices.ExceptionDispatchInfo.SetCurrentStackTrace source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Exception</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Exception" Index="0" FrameworkAlternate="net-5.0" />
      </Parameters>
      <Docs>
        <param name="source"><span data-ttu-id="9f2a4-113">未引发的异常。</span><span class="sxs-lookup"><span data-stu-id="9f2a4-113">The unthrown exception.</span></span></param>
        <summary><span data-ttu-id="9f2a4-114">将当前堆栈跟踪存储到指定的 <see cref="T:System.Exception" /> 实例中。</span><span class="sxs-lookup"><span data-stu-id="9f2a4-114">Stores the current stack trace into the specified <see cref="T:System.Exception" /> instance.</span></span></summary>
        <returns><span data-ttu-id="9f2a4-115">包含堆栈跟踪的 <paramref name="source" /> 异常实例。</span><span class="sxs-lookup"><span data-stu-id="9f2a4-115">The <paramref name="source" /> exception instance with the stack trace included.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SourceException">
      <MemberSignature Language="C#" Value="public Exception SourceException { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Exception SourceException" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.ExceptionServices.ExceptionDispatchInfo.SourceException" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SourceException As Exception" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Exception ^ SourceException { Exception ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SourceException : Exception" Usage="System.Runtime.ExceptionServices.ExceptionDispatchInfo.SourceException" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Exception</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="9f2a4-116">获取被当前实例表示的异常。</span><span class="sxs-lookup"><span data-stu-id="9f2a4-116">Gets the exception that is represented by the current instance.</span></span></summary>
        <value><span data-ttu-id="9f2a4-117">被当前实例表示的异常。</span><span class="sxs-lookup"><span data-stu-id="9f2a4-117">The exception that is represented by the current instance.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9f2a4-118">此属性由任务并行库用来合并对象中的多个异常 <xref:System.AggregateException> 。</span><span class="sxs-lookup"><span data-stu-id="9f2a4-118">This property is used by the Task Parallel Library, for example, to combine multiple exceptions in an <xref:System.AggregateException> object.</span></span> <span data-ttu-id="9f2a4-119">不应由应用程序代码使用。</span><span class="sxs-lookup"><span data-stu-id="9f2a4-119">It is not intended to be used by application code.</span></span> <span data-ttu-id="9f2a4-120">使用 <xref:System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw%2A> 方法还原捕获的异常的状态并引发它。</span><span class="sxs-lookup"><span data-stu-id="9f2a4-120">Use the <xref:System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw%2A> method to restore the state of the captured exception and throw it.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Throw">
      <MemberSignature Language="C#" Value="public void Throw ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Throw() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw" />
      <MemberSignature Language="VB.NET" Value="Public Sub Throw ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Throw();" />
      <MemberSignature Language="F#" Value="member this.Throw : unit -&gt; unit" Usage="exceptionDispatchInfo.Throw " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netstandard-2.1">
          <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.DoesNotReturn]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.DoesNotReturn&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="9f2a4-121">恢复捕获异常时保存的状态后，引发由当前 <see cref="T:System.Runtime.ExceptionServices.ExceptionDispatchInfo" /> 对象表示的异常。</span><span class="sxs-lookup"><span data-stu-id="9f2a4-121">Throws the exception that is represented by the current <see cref="T:System.Runtime.ExceptionServices.ExceptionDispatchInfo" /> object, after restoring the state that was saved when the exception was captured.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9f2a4-122">如果还原了异常，则会在堆栈跟踪中插入以下字符串，以指示还原点： "来自引发异常的上一个位置的堆栈跟踪结束"。</span><span class="sxs-lookup"><span data-stu-id="9f2a4-122">When the exception is restored, the following string is inserted in the stack trace to indicate the restore point: "End of stack trace from the previous location where the exception was thrown".</span></span> <span data-ttu-id="9f2a4-123">这类似于在堆栈跟踪中指出的内部异常或封送异常。</span><span class="sxs-lookup"><span data-stu-id="9f2a4-123">This is similar to the way inner exceptions or marshaled exceptions are indicated in stack traces.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Throw">
      <MemberSignature Language="C#" Value="public static void Throw (Exception source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Throw(class System.Exception source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw(System.Exception)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Throw (source As Exception)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Throw(Exception ^ source);" />
      <MemberSignature Language="F#" Value="static member Throw : Exception -&gt; unit" Usage="System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-3.0;netcore-3.1;netstandard-2.1">
          <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.DoesNotReturn]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.DoesNotReturn&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Exception" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="source"><span data-ttu-id="9f2a4-124">捕获其状态、然后重新引发的异常。</span><span class="sxs-lookup"><span data-stu-id="9f2a4-124">The exception whose state is captured, then rethrown.</span></span></param>
        <summary><span data-ttu-id="9f2a4-125">引发源异常，同时保留原始 Watson 信息，并增加（而不是替换）原始堆栈跟踪。</span><span class="sxs-lookup"><span data-stu-id="9f2a4-125">Throws the source exception, maintaining the original Watson information and augmenting rather than replacing the original stack trace.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
