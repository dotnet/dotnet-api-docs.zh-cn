<Type Name="InvalidOperationException" FullName="System.InvalidOperationException">
  <Metadata><Meta Name="ms.openlocfilehash" Value="8e5b88534b2f23e65ad3b6910ea2d568c570c616" /><Meta Name="ms.sourcegitcommit" Value="b53d35b4a410c949742abd4c6a989d1af5357bca" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-CN" /><Meta Name="ms.lasthandoff" Value="07/21/2020" /><Meta Name="ms.locfileid" Value="86601365" /></Metadata><TypeSignature Language="C#" Value="public class InvalidOperationException : Exception" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit InvalidOperationException extends System.Exception" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
  <TypeSignature Language="DocId" Value="T:System.InvalidOperationException" />
  <TypeSignature Language="VB.NET" Value="Public Class InvalidOperationException&#xA;Inherits Exception" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
  <TypeSignature Language="C++ CLI" Value="public ref class InvalidOperationException : Exception" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
  <TypeSignature Language="F#" Value="type InvalidOperationException = class&#xA;    inherit Exception" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
  <TypeSignature Language="C#" Value="public class InvalidOperationException : SystemException" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit InvalidOperationException extends System.SystemException" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1" />
  <TypeSignature Language="VB.NET" Value="Public Class InvalidOperationException&#xA;Inherits SystemException" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <TypeSignature Language="C++ CLI" Value="public ref class InvalidOperationException : SystemException" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <TypeSignature Language="F#" Value="type InvalidOperationException = class&#xA;    inherit SystemException" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit InvalidOperationException extends System.SystemException" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
    <AssemblyVersion>4.2.2.0</AssemblyVersion>
    <AssemblyVersion>5.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeForwardingChain>
    <TypeForwarding From="mscorlib" FromVersion="4.0.0.0" To="System.Runtime" ToVersion="0.0.0.0" FrameworkAlternate="dotnet-uwp-10.0" />
    <TypeForwarding From="netstandard" FromVersion="2.1.0.0" To="System.Runtime" ToVersion="5.0.0.0" FrameworkAlternate="net-5.0" />
  </TypeForwardingChain>
  <Base>
    <BaseTypeName>System.Exception</BaseTypeName>
    <BaseTypeName FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">System.SystemException</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName Language="C#">[System.Serializable]</AttributeName>
      <AttributeName Language="F#">[&lt;System.Serializable&gt;]</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName Language="C#">[System.Runtime.InteropServices.ComVisible(true)]</AttributeName>
      <AttributeName Language="F#">[&lt;System.Runtime.InteropServices.ComVisible(true)&gt;]</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>当方法调用对于对象的当前状态无效时引发的异常。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.InvalidOperationException> 如果调用方法失败是由无效参数以外的其他原因导致的，则使用。 通常，当对象的状态不支持方法调用时，将引发此异常。 例如， <xref:System.InvalidOperationException> 以下方法会引发异常：  
  
-   <xref:System.Collections.IEnumerator.MoveNext%2A?displayProperty=nameWithType> 如果在创建枚举器后修改集合的对象，则为。 有关详细信息，请参阅 [循环访问集合](#Iterating)。  
  
-   <xref:System.Resources.ResourceSet.GetString%2A?displayProperty=nameWithType> 如果在执行方法调用前关闭资源集，则为。  
  
-   <xref:System.Xml.Linq.XContainer.Add%2A?displayProperty=nameWithType>如果要添加的对象将导致结构不正确的 XML 文档，则为。  
  
-   尝试从非主线程或 UI 线程的线程操作 UI 的方法。  
  
> [!IMPORTANT]
>  由于 <xref:System.InvalidOperationException> 在各种情况下可能会引发异常，因此请务必阅读属性返回的异常消息 <xref:System.Exception.Message%2A> 。  
  
 本部分内容：  
  
 [InvalidOperationException 异常的一些常见原因](#Causes)   
 [从非 UI 线程更新 UI 线程](#UI)  
 [在循环访问集合时更改集合](#Iterating)  
 [对其对象无法进行比较的数组或集合进行排序](#Sorting)  
 [将 &lt; 为 null 的 null T 转换 &gt; 为其基础类型](#Nullable)   
 [对空集合调用 system.exception 方法](#Empty)  
 [对没有一个元素的序列调用 SingleOrDefault 或可枚举的。](#Single)  
 [动态跨应用程序域字段访问](#Emit)  
[引发 InvalidOperationException 异常](#Throwing)  
[杂项信息](#Misc)  
  
<a name="Causes"></a>   
## <a name="some-common-causes-of-invalidoperationexception-exceptions"></a>InvalidOperationException 异常的一些常见原因  
 以下部分介绍了在应用中引发异常的一些常见情况 <xref:System.InvalidOperationException> 。 处理问题的方式取决于具体情况。 但大多数情况下，异常是由开发人员错误导致的，并且 <xref:System.InvalidOperationException> 可能会预计和避免异常。  
  
<a name="UI"></a>   
### <a name="updating-a-ui-thread-from-a-non-ui-thread"></a>从非 UI 线程更新 UI 线程  
 通常，工作线程用于执行一些后台工作，其中涉及收集要在应用程序的用户界面中显示的数据。 但是， 大多数 GUI (图形用户界面) 应用程序 .NET Framework 框架（如 Windows 窗体和 Windows Presentation Foundation (WPF) ），只允许从创建和管理 UI 的线程 (主线程或 UI 线程) 。 <xref:System.InvalidOperationException>当你尝试从 ui 线程之外的其他线程访问 ui 元素时，将引发。  下表显示了异常消息的文本。  
  
|应用程序类型|消息|  
|----------------------|-------------|  
|WPF 应用|**调用线程无法访问此对象，因为它属于其他线程所有。**|  
|UWP 应用|**应用程序调用了为另一个线程封送的接口。**|  
|Windows 窗体应用|**跨线程操作无效：从不是在其上创建它的线程访问控件 "TextBox1"。**|  
  
 .NET Framework 的 UI 框架实现了一个 *调度* 程序模式，该模式包括一个方法，用于检查 ui 线程上是否正在执行对 ui 线程成员的调用，以及用于计划对 ui 线程的调用的其他方法：  
  
-   在 WPF 应用程序中，调用 <xref:System.Windows.Threading.Dispatcher.CheckAccess%2A?displayProperty=nameWithType> 方法以确定方法是否正在非 UI 线程上运行。 `true`如果方法在 UI 线程上运行，则返回 `false` ; 否则返回。 调用方法的重载之一 <xref:System.Windows.Threading.Dispatcher.Invoke%2A?displayProperty=nameWithType> 来计划对 UI 线程的调用。  
  
-   在 UWP 应用中，检查 <xref:Windows.UI.Core.CoreDispatcher.HasThreadAccess?displayProperty=nameWithType> 属性以确定某个方法是否正在非 UI 线程上运行。 调用 <xref:Windows.UI.Core.CoreDispatcher.RunAsync%2A?displayProperty=nameWithType> 方法以执行用于更新 UI 线程的委托。 
  
-   在 Windows 窗体应用中，请使用 <xref:System.Windows.Forms.Control.InvokeRequired%2A?displayProperty=nameWithType> 属性来确定某个方法是否正在非 UI 线程上运行。 调用方法的重载之一 <xref:System.Windows.Forms.Control.Invoke%2A?displayProperty=nameWithType> 来执行更新 UI 线程的委托。  
  
 下面的示例说明 <xref:System.InvalidOperationException> 当你尝试从创建它的线程以外的线程更新 UI 元素时引发的异常。  每个示例都需要创建两个控件：  
  
-   名为的文本框控件 `textBox1` 。  在 Windows 窗体应用程序中，应将其 <xref:System.Windows.Forms.TextBox.Multiline%2A> 属性设置为 `true` 。  
  
-   名为的按钮控件 `threadExampleBtn` 。 该示例 `ThreadsExampleBtn_Click` 为按钮的事件提供了一个处理程序 `Click` 。  
  
 在每种情况下， `threadExampleBtn_Click` 事件处理程序都会 `DoSomeWork` 两次调用方法。 第一个调用同步运行并成功运行。 但第二次调用时，由于它在线程池线程上以异步方式运行，因此尝试从非 UI 线程更新 UI。 这会导致 <xref:System.InvalidOperationException> 异常。  
  
 WPF 和 UWP 应用  
 [!code-csharp[System.InvalidOperationException.Threading.WPF1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Invalidoperationexception.threading.wpf1/cs/MainWindow.xaml.cs#1)]
 [!code-vb[System.InvalidOperationException.Threading.WPF1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Invalidoperationexception.threading.wpf1/vb/MainWindow.xaml.vb#1)]  
  
 以下版本的方法可 `DoSomeWork` 消除 WPF 应用中的异常。  
  
 [!code-csharp[System.InvalidOperationException.Threading.WPF2#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Invalidoperationexception.threading.wpf2/cs/MainWindowDispatcher.xaml.cs#3)]
 [!code-vb[System.InvalidOperationException.Threading.WPF2#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Invalidoperationexception.threading.wpf2/vb/MainWindowDispatcher.xaml.vb#3)]  
  
 以下版本的 `DoSomeWork` 方法消除了 UWP 应用中的异常。  
  
 [!code-csharp[System.InvalidOperationException.Threading.UWP#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.invalidoperationexception.threading.uwp/cs/MainPage.xaml.cs#4)]
 [!code-vb[System.InvalidOperationException.Threading.UWP#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.invalidoperationexception.threading.uwp/vb/MainPage.xaml.vb#4)]  
  
 Windows 窗体应用  
 [!code-csharp[System.InvalidOperationException.Threading.WF#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Invalidoperationexception.threading.wf/cs/Form1.cs#2)]
 [!code-vb[System.InvalidOperationException.Threading.WF#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Invalidoperationexception.threading.wf/vb/Form1.vb#2)]  
  
 以下版本的 `DoSomeWork` 方法消除了 Windows 窗体应用中的异常。  
  
 [!code-csharp[System.InvalidOperationException.Threading.WF2#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Invalidoperationexception.threading.wf2/cs/Form1.cs#5)]
 [!code-vb[System.InvalidOperationException.Threading.WF2#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Invalidoperationexception.threading.wf2/vb/Form1.vb#5)]  
  
<a name="Iterating"></a>   
### <a name="changing-a-collection-while-iterating-it"></a>在循环访问集合时更改集合  
 `foreach`C # 中的语句或 `For Each` Visual Basic 中的语句用于循环访问集合的成员，并读取或修改其各个元素。 但是，它不能用于添加或删除集合中的项。 执行此操作  <xref:System.InvalidOperationException> 会引发异常，其中包含类似于 "**集合已修改;枚举操作可能无法执行。**"  
  
 下面的示例循环访问整数的集合，尝试将每个整数的平方添加到集合中。 该示例 <xref:System.InvalidOperationException> 通过首次调用 <xref:System.Collections.Generic.List%601.Add%2A?displayProperty=nameWithType> 方法引发。  
  
 [!code-csharp[System.InvalidOperationException#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.invalidoperationexception/cs/Iterating1.cs#1)]
 [!code-vb[System.InvalidOperationException#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.invalidoperationexception/vb/Iterating1.vb#1)]  
  
 可以通过以下两种方式之一消除异常：具体取决于应用程序逻辑：  
  
-   如果在循环访问时必须将元素添加到集合中，则可以使用 `for` 语句而不是或来循环访问元素 `foreach` `For Each` 。 下面的示例使用 for 语句将集合中的数字的平方添加到集合中。  
  
     :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.invalidoperationexception/cs/Iterating2.cs" interactive="try-dotnet" id="Snippet2":::
     :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.invalidoperationexception/vb/Iterating2.vb" id="Snippet2":::
  
     请注意，在循环访问集合之前，必须先建立迭代数，方法是在循环中使用计数器，该计数器会将 `Count` 数组中的元素数量赋给一个变量，并使用它来确定循环的上限，并通过将数组中的元素数量赋给变量并使用它来确定循环的上限。 否则，如果在每次迭代时向集合中添加了一个元素，则会导致无限循环。  
  
-   如果在循环访问集合时不需要向集合添加元素，则可以存储要添加到临时集合中的元素，在循环访问完成后添加这些元素。  下面的示例使用此方法将集合中的数字的平方添加到临时集合，然后将这些集合合并为单个数组对象。  
  
     :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.invalidoperationexception/cs/Iterating3.cs" interactive="try-dotnet" id="Snippet3":::
     :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.invalidoperationexception/vb/Iterating3.vb" id="Snippet3":::
  
<a name="Sorting"></a>   
### <a name="sorting-an-array-or-collection-whose-objects-cannot-be-compared"></a>对其对象无法进行比较的数组或集合进行排序  
 一般用途的排序方法（如 <xref:System.Array.Sort%28System.Array%29?displayProperty=nameWithType> 方法或 <xref:System.Collections.Generic.List%601.Sort?displayProperty=nameWithType> 方法）通常要求至少一个要排序的对象实现 <xref:System.IComparable%601> 或 <xref:System.IComparable> 接口。 如果不是，则无法对集合或数组进行排序，并且该方法将引发  <xref:System.InvalidOperationException> 异常。 下面的示例定义了一个 `Person` 类，将两个 `Person` 对象存储在一个泛型 <xref:System.Collections.Generic.List%601> 对象中，并尝试对它们进行排序。 如示例的输出所示，对方法的调用将 <xref:System.Collections.Generic.List%601.Sort?displayProperty=nameWithType> 引发 <xref:System.InvalidOperationException> 。  
  
 [!code-csharp[System.InvalidOperationException#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.invalidoperationexception/cs/List_Sort1.cs#12)]
 [!code-vb[System.InvalidOperationException#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.invalidoperationexception/vb/List_Sort1.vb#12)]  
  
 可以通过以下三种方式之一消除异常：  
  
-   如果可以拥有尝试排序的类型 (也就是说，如果控制其源代码) ，则可以对其进行修改以实现 <xref:System.IComparable%601> 或 <xref:System.IComparable> 接口。 这要求您实现 <xref:System.IComparable%601.CompareTo%2A?displayProperty=nameWithType> 或 <xref:System.IComparable.CompareTo%2A> 方法。 将接口实现添加到现有类型不是一项重大更改。  
  
     下面的示例使用此方法为类提供一个 <xref:System.IComparable%601> 实现 `Person` 。 你仍可以调用集合或数组的常规排序方法，如示例中的输出所示，该集合将成功排序。  
  
     :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.invalidoperationexception/cs/List_Sort2.cs" interactive="try-dotnet" id="Snippet13":::
     :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.invalidoperationexception/vb/List_Sort2.vb" id="Snippet13"::: 
  
-   如果您无法修改您尝试进行排序的类型的源代码，则可以定义一个实现接口的特殊用途的排序类 <xref:System.Collections.Generic.IComparer%601> 。  可以调用 `Sort` 包含参数的方法的重载  <xref:System.Collections.Generic.IComparer%601> 。 如果要开发可基于多个条件对对象进行排序的专用排序类，则此方法特别有用。  
  
     下面的示例通过开发 `PersonComparer` 用于对集合进行排序的自定义类来使用方法 `Person` 。  然后，它将此类的一个实例传递给 <xref:System.Collections.Generic.List%601.Sort%28System.Collections.Generic.IComparer%7B%600%7D%29?displayProperty=nameWithType> 方法。  
  
     :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.invalidoperationexception/cs/List_Sort3.cs" interactive="try-dotnet" id="Snippet14":::
     :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.invalidoperationexception/vb/List_Sort3.vb" id="Snippet14":::
  
-   如果无法修改您尝试排序的类型的源代码，则可以创建一个  <xref:System.Comparison%601> 委托来执行排序。 委托签名为  
  
    ```vb  
    Function Comparison(Of T)(x As T, y As T) As Integer  
    ```  
  
    ```csharp  
    int Comparison<T>(T x, T y)  
    ```  
  
     下面的示例通过定义  `PersonComparison` 与委托签名匹配的方法来使用方法  <xref:System.Comparison%601> 。  然后，它将此委托传递给 <xref:System.Collections.Generic.List%601.Sort%28System.Comparison%7B%600%7D%29?displayProperty=nameWithType> 方法。  
  
     :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.invalidoperationexception/cs/List_Sort4.cs" interactive="try-dotnet" id="Snippet15":::
     :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.invalidoperationexception/vb/List_Sort4.vb" id="Snippet15":::
  
<a name="Nullable"></a>   
### <a name="casting-a-nullablet-that-is-null-to-its-underlying-type"></a>将 \<T> 为 null 的 null 值强制转换为其基础类型  
 如果尝试强制转换为 <xref:System.Nullable%601> 其基础类型的值，则会 `null` 引发 <xref:System.InvalidOperationException> 异常并显示错误消息 "**可以为 null 的对象必须具有值。**  
  
 下面的示例 <xref:System.InvalidOperationException> 在尝试循环访问包含值的数组时引发了异常 `Nullable(Of Integer)` 。  
  
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.invalidoperationexception/cs/Nullable1.cs" id="Snippet4":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.invalidoperationexception/vb/Nullable1.vb" id="Snippet4":::  
  
 若要防止发生此异常：  
  
-   使用 <xref:System.Nullable%601.HasValue%2A?displayProperty=nameWithType> 属性来仅选择那些不是的元素 `null` 。  
  
-   调用 <xref:System.Nullable%601.GetValueOrDefault%2A?displayProperty=nameWithType> 重载之一，为值提供默认值 `null` 。  
  
 下面的示例执行此两个方法来避免  <xref:System.InvalidOperationException> 异常。  
  
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.invalidoperationexception/cs/Nullable2.cs" interactive="try-dotnet" id="Snippet5":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.invalidoperationexception/vb/Nullable2.vb" id="Snippet5"::: 
  
<a name="Empty"></a>   
### <a name="calling-a-systemlinqenumerable-method-on-an-empty-collection"></a>对空集合调用 system.exception 方法  
 <xref:System.Linq.Enumerable.Aggregate%2A?displayProperty=nameWithType>、、 <xref:System.Linq.Enumerable.Average%2A?displayProperty=nameWithType> 、、、、 <xref:System.Linq.Enumerable.First%2A?displayProperty=nameWithType> <xref:System.Linq.Enumerable.Last%2A?displayProperty=nameWithType> <xref:System.Linq.Enumerable.Max%2A?displayProperty=nameWithType> <xref:System.Linq.Enumerable.Min%2A?displayProperty=nameWithType> <xref:System.Linq.Enumerable.Single%2A?displayProperty=nameWithType> 和方法对 <xref:System.Linq.Enumerable.SingleOrDefault%2A?displayProperty=nameWithType> 序列执行操作并返回单个结果。   <xref:System.InvalidOperationException>如果序列为空，而其他重载返回，则这些方法的某些重载会引发异常 `null` 。 <xref:System.Linq.Enumerable.SingleOrDefault%2A?displayProperty=nameWithType>当序列包含多个元素时，该方法也会引发 <xref:System.InvalidOperationException> 异常。  
  
> [!NOTE]
>  引发异常的大多数方法 <xref:System.InvalidOperationException> 都是重载。 请确保了解所选重载的行为。  
  
 下表列出了 <xref:System.InvalidOperationException> 由对某些方法的调用引发的异常对象的异常消息 <xref:System.Linq.Enumerable?displayProperty=nameWithType> 。  
  
|方法|消息|  
|------------|-------------|  
|`Aggregate` <br /> `Average` <br /> `Last` <br /> `Max` <br /> `Min`|**序列不包含任何元素**|  
|`First`|**序列不包含匹配元素**|  
|`Single` <br /> `SingleOrDefault`|**序列包含多个匹配元素**|  
  
 消除或处理异常的方式取决于应用程序的假设和所调用的特定方法。  
  
-   如果在不检查空序列的情况下有意调用这些方法之一，则假设序列不为空，且空序列是意外的匹配项。 在这种情况下，会适当捕获或重新引发异常。  
  
-   如果无法检查是否存在空序列，则可以调用重载的重载之一 <xref:System.Linq.Enumerable.Any%2A?displayProperty=nameWithType> 来确定序列是否包含任何元素。  
  
    > [!TIP]
    >  <xref:System.Linq.Enumerable.Any%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Boolean%7D%29?displayProperty=nameWithType>如果要处理的数据可能包含大量元素或生成序列的操作非常昂贵，则在生成序列之前调用方法可以提高性能。  
  
-   如果调用了方法（如、 <xref:System.Linq.Enumerable.First%2A?displayProperty=nameWithType> 或） <xref:System.Linq.Enumerable.Last%2A?displayProperty=nameWithType> <xref:System.Linq.Enumerable.Single%2A?displayProperty=nameWithType> ，则可以替换 <xref:System.Linq.Enumerable.FirstOrDefault%2A?displayProperty=nameWithType> <xref:System.Linq.Enumerable.LastOrDefault%2A?displayProperty=nameWithType>  <xref:System.Linq.Enumerable.SingleOrDefault%2A?displayProperty=nameWithType> 返回默认值（而不是序列的成员）的替代方法，如、或。  
  
 这些示例提供更多详细信息。  
  
 下面的示例使用 <xref:System.Linq.Enumerable.Average%2A?displayProperty=nameWithType> 方法计算其值大于4的序列的平均值。 由于原始数组中没有值超过4，因此序列中不包含任何值，并且该方法将引发 <xref:System.InvalidOperationException> 异常。  
  
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.invalidoperationexception/cs/Enumerable1.cs" id="Snippet6":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.invalidoperationexception/vb/Enumerable1.vb" id="Snippet6"::: 
  
 在 <xref:System.Linq.Enumerable.Any%2A> 调用处理序列的方法之前，可以通过调用方法来确定序列是否包含任何元素，从而消除此异常，如下面的示例所示。  
  
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.invalidoperationexception/cs/Enumerable2.cs" interactive="try-dotnet" id="Snippet7":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.invalidoperationexception/vb/Enumerable2.vb" id="Snippet7"::: 
  
 <xref:System.Linq.Enumerable.First%2A?displayProperty=nameWithType>方法返回序列中的第一项，或序列中满足指定条件的第一个元素。 如果序列为空，因此不包含第一个元素，则会引发 <xref:System.InvalidOperationException> 异常。  
  
 在下面的示例中， <xref:System.Linq.Enumerable.First%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Boolean%7D%29?displayProperty=nameWithType> 方法引发 <xref:System.InvalidOperationException> 异常，因为 dbQueryResults 数组不包含大于4的元素。  
  
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.invalidoperationexception/cs/Enumerable3.cs" id="Snippet8":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.invalidoperationexception/vb/Enumerable3.vb" id="Snippet8":::
  
 您可以调用 <xref:System.Linq.Enumerable.FirstOrDefault%2A?displayProperty=nameWithType> 方法，而不是 <xref:System.Linq.Enumerable.First%2A?displayProperty=nameWithType> 返回指定值或默认值。 如果该方法未在序列中找到第一个元素，则它将返回该数据类型的默认值。  `null`对于引用类型，默认值为 0; 对于数值数据类型，默认值为零; <xref:System.DateTime.MinValue?displayProperty=nameWithType> 对于类型，则为 <xref:System.DateTime> 。  
  
> [!NOTE]
>  解释该方法返回的值 <xref:System.Linq.Enumerable.FirstOrDefault%2A?displayProperty=nameWithType> 通常是很复杂的，因为该类型的默认值可以是序列中的有效值。 在这种情况下，在 <xref:System.Linq.Enumerable.Any%2A?displayProperty=nameWithType> 调用方法之前，调用方法来确定序列是否具有有效的成员 <xref:System.Linq.Enumerable.First%2A?displayProperty=nameWithType> 。  
  
 下面的示例调用  <xref:System.Linq.Enumerable.FirstOrDefault%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Boolean%7D%29?displayProperty=nameWithType> 方法，以防止在 <xref:System.InvalidOperationException> 上一个示例中引发的异常。  
  
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.invalidoperationexception/cs/Enumerable4.cs" interactive="try-dotnet" id="Snippet9":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.invalidoperationexception/vb/Enumerable4.vb" id="Snippet9"::: 
  
<a name="Single"></a>   
### <a name="calling-enumerablesingle-or-enumerablesingleordefault-on-a-sequence-without-one-element"></a>对没有一个元素的序列调用 SingleOrDefault 或可枚举的。  
 <xref:System.Linq.Enumerable.Single%2A?displayProperty=nameWithType>方法返回序列中的唯一元素，或序列中满足指定条件的唯一元素。    如果序列中没有元素，或者如果有多个元素，则该方法将引发 <xref:System.InvalidOperationException> 异常。  
  
 <xref:System.Linq.Enumerable.SingleOrDefault%2A?displayProperty=nameWithType>如果序列不包含任何元素，则可以使用方法返回默认值，而不是引发异常。 但是， <xref:System.Linq.Enumerable.SingleOrDefault%2A?displayProperty=nameWithType> <xref:System.InvalidOperationException> 当序列包含多个元素时，该方法仍会引发异常。  
  
 下表列出了 <xref:System.InvalidOperationException> 由对和方法的调用引发的异常对象的异常 <xref:System.Linq.Enumerable.Single%2A?displayProperty=nameWithType> 消息 <xref:System.Linq.Enumerable.SingleOrDefault%2A?displayProperty=nameWithType> 。  
  
|方法|消息|  
|------------|-------------|  
|`Single`|**序列不包含匹配元素**|  
|`Single` <br /> `SingleOrDefault`|**序列包含多个匹配元素**|  
  
 在下面的示例中，对方法的调用将 <xref:System.Linq.Enumerable.Single%2A?displayProperty=nameWithType> 引发 <xref:System.InvalidOperationException> 异常，因为序列没有大于4的元素。  
  
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.invalidoperationexception/cs/Enumerable5.cs" id="Snippet10":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.invalidoperationexception/vb/Enumerable5.vb" id="Snippet10"::: 
  
 下面的示例尝试 <xref:System.InvalidOperationException> 通过调用方法来防止序列为空时引发的异常 <xref:System.Linq.Enumerable.SingleOrDefault%2A?displayProperty=nameWithType> 。 但是，因为此序列返回多个值大于2的元素，所以它还会引发 <xref:System.InvalidOperationException> 异常。  
  
 [!code-csharp[System.InvalidOperationException#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.invalidoperationexception/cs/Enumerable6.cs#11)]
 [!code-vb[System.InvalidOperationException#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.invalidoperationexception/vb/Enumerable6.vb#11)]  
  
 调用 <xref:System.Linq.Enumerable.Single%2A?displayProperty=nameWithType> 方法假设序列或满足指定条件的序列只包含一个元素。  <xref:System.Linq.Enumerable.SingleOrDefault%2A?displayProperty=nameWithType> 假设序列包含零个或一个结果，但没有其他结果。 如果此假设在您的部分中是有意的，并且不满足这些条件，则会重新引发或捕获产生的结果 <xref:System.InvalidOperationException> 。 否则，或者，如果您希望在某些频率下发生无效的条件，则应考虑使用其他 <xref:System.Linq.Enumerable> 方法，例如 <xref:System.Linq.Enumerable.FirstOrDefault%2A> 或 <xref:System.Linq.Enumerable.Where%2A> 。  
  
<a name="Emit"></a>   
### <a name="dynamic-cross-application-domain-field-access"></a>动态跨应用程序域字段访问  
 <xref:System.Reflection.Emit.OpCodes.Ldflda?displayProperty=nameWithType> <xref:System.InvalidOperationException> 如果包含您尝试检索其地址的字段所在的对象不在执行您的代码的应用程序域中，则 Microsoft 中间语言 (MSIL) 指令会引发异常。 字段的地址只能从它所在的应用程序域进行访问。  
  
<a name="Throwing"></a>   
## <a name="throwing-an-invalidoperationexception-exception"></a>引发 InvalidOperationException 异常  
 <xref:System.InvalidOperationException>仅当对象的状态出于某种原因不支持特定方法调用时，才应引发异常。 也就是说，方法调用在某些环境或上下文中有效，但在其他情况下无效。  
  
 如果方法调用失败是由无效参数引起的，则 <xref:System.ArgumentException> <xref:System.ArgumentNullException> <xref:System.ArgumentOutOfRangeException> 应改为引发或其派生类之一或。  
  
<a name="Misc"></a>   
## <a name="miscellaneous-information"></a>其他信息  
 <xref:System.InvalidOperationException> 使用 HRESULT COR_E_INVALIDOPERATION，其值为0x80131509。  
  
 有关实例的初始属性值的列表<xref:System.InvalidOperationException>，请参阅<xref:System.InvalidOperationException.%23ctor%2A>构造函数。  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Exception" />
    <altmember cref="T:System.Collections.IEnumerator" />
    <altmember cref="T:System.Resources.ResourceSet" />
    <related type="Article" href="/dotnet/standard/exceptions/">处理和引发异常</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>初始化 <see cref="T:System.InvalidOperationException" /> 类的新实例。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public InvalidOperationException ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.InvalidOperationException.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; InvalidOperationException();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>初始化 <see cref="T:System.InvalidOperationException" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此构造函数将 <xref:System.Exception.Message%2A> 新实例的属性初始化为系统提供的描述错误的消息，例如 "无法执行请求的操作"。 此消息会考虑当前系统区域性。  
  
 下表显示了 <xref:System.InvalidOperationException> 实例的初始属性值。  
  
|properties|值|  
|--------------|-----------|  
|<xref:System.Exception.InnerException%2A>|空引用（在 Visual Basic 中为 `Nothing`）。|  
|<xref:System.Exception.Message%2A>|本地化的错误消息字符串。|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public InvalidOperationException (string message);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string message) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.InvalidOperationException.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (message As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; InvalidOperationException(System::String ^ message);" />
      <MemberSignature Language="F#" Value="new InvalidOperationException : string -&gt; InvalidOperationException" Usage="new System.InvalidOperationException message" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="message">描述错误的消息。</param>
        <summary>用指定的错误消息初始化 <see cref="T:System.InvalidOperationException" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此构造函数 <xref:System.Exception.Message%2A?displayProperty=nameWithType> 使用参数初始化新异常的属性 `message` 。 `message` 的内容设计为易于理解。 此构造函数的调用方需要确保此字符串已针对当前系统区域性进行了本地化。  
  
 下表显示了 <xref:System.InvalidOperationException> 实例的初始属性值。  
  
|properties|值|  
|--------------|-----------|  
|<xref:System.Exception.InnerException%2A>|空引用（在 Visual Basic 中为 `Nothing`）。|  
|<xref:System.Exception.Message%2A>|错误消息字符串。|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected InvalidOperationException (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.InvalidOperationException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; InvalidOperationException(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="new InvalidOperationException : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; InvalidOperationException" Usage="new System.InvalidOperationException (info, context)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="info">承载序列化对象数据的对象。</param>
        <param name="context">关于来源和目标的上下文信息</param>
        <summary>用序列化数据初始化 <see cref="T:System.InvalidOperationException" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在反序列化期间调用此构造函数以重新构造在流上传输的异常对象。 有关详细信息，请参阅 [XML 和 SOAP 序列化](/dotnet/standard/serialization/xml-and-soap-serialization)。  
  
 ]]></format>
        </remarks>
        <related type="Article" href="/dotnet/standard/serialization/xml-and-soap-serialization">XML 和 SOAP 序列化</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public InvalidOperationException (string message, Exception innerException);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string message, class System.Exception innerException) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.InvalidOperationException.#ctor(System.String,System.Exception)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (message As String, innerException As Exception)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; InvalidOperationException(System::String ^ message, Exception ^ innerException);" />
      <MemberSignature Language="F#" Value="new InvalidOperationException : string * Exception -&gt; InvalidOperationException" Usage="new System.InvalidOperationException (message, innerException)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="innerException" Type="System.Exception" />
      </Parameters>
      <Docs>
        <param name="message">解释异常原因的错误消息。</param>
        <param name="innerException">导致当前异常的异常。 如果 <paramref name="innerException" /> 参数不是 null 引用（在 Visual Basic 中为 <see langword="Nothing" />），则在处理内部异常的 <see langword="catch" /> 块中引发当前异常。</param>
        <summary>使用指定的错误消息和对作为此异常原因的内部异常的引用来初始化 <see cref="T:System.InvalidOperationException" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 因前一个异常而直接引发的异常应在 <xref:System.Exception.InnerException%2A> 属性中包含对前一个异常的引用。 <xref:System.Exception.InnerException%2A> 属性返回传递到构造函数中的相同值，或者如果 `Nothing` 属性不向构造函数提供内部异常值，则为空引用（在 Visual Basic 中为 <xref:System.Exception.InnerException%2A>）。  
  
 下表显示了 <xref:System.InvalidOperationException> 实例的初始属性值。  
  
|properties|“值”|  
|--------------|-----------|  
|<xref:System.Exception.InnerException%2A>|内部异常引用。|  
|<xref:System.Exception.Message%2A>|错误消息字符串。|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Exception" />
        <related type="Article" href="/dotnet/standard/exceptions/">处理和引发异常</related>
      </Docs>
    </Member>
  </Members>
</Type>
