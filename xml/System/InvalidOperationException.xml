<Type Name="InvalidOperationException" FullName="System.InvalidOperationException">
  <Metadata><Meta Name="ms.openlocfilehash" Value="14c082b0650f796e3c985949a7783a7b12771f92" /><Meta Name="ms.sourcegitcommit" Value="11d168140aa8fade0768c2a9dde3e3bcacfdfb7d" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-CN" /><Meta Name="ms.lasthandoff" Value="05/27/2020" /><Meta Name="ms.locfileid" Value="83956899" /></Metadata><TypeSignature Language="C#" Value="public class InvalidOperationException : Exception" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit InvalidOperationException extends System.Exception" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
  <TypeSignature Language="DocId" Value="T:System.InvalidOperationException" />
  <TypeSignature Language="VB.NET" Value="Public Class InvalidOperationException&#xA;Inherits Exception" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
  <TypeSignature Language="C++ CLI" Value="public ref class InvalidOperationException : Exception" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
  <TypeSignature Language="F#" Value="type InvalidOperationException = class&#xA;    inherit Exception" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
  <TypeSignature Language="C#" Value="public class InvalidOperationException : SystemException" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit InvalidOperationException extends System.SystemException" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1" />
  <TypeSignature Language="VB.NET" Value="Public Class InvalidOperationException&#xA;Inherits SystemException" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <TypeSignature Language="C++ CLI" Value="public ref class InvalidOperationException : SystemException" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <TypeSignature Language="F#" Value="type InvalidOperationException = class&#xA;    inherit SystemException" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit InvalidOperationException extends System.SystemException" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
    <AssemblyVersion>4.2.2.0</AssemblyVersion>
    <AssemblyVersion>5.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeForwardingChain>
    <TypeForwarding From="mscorlib" FromVersion="4.0.0.0" To="System.Runtime" ToVersion="0.0.0.0" FrameworkAlternate="dotnet-uwp-10.0" />
    <TypeForwarding From="netstandard" FromVersion="2.1.0.0" To="System.Runtime" ToVersion="5.0.0.0" FrameworkAlternate="net-5.0" />
  </TypeForwardingChain>
  <Base>
    <BaseTypeName>System.Exception</BaseTypeName>
    <BaseTypeName FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">System.SystemException</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>当方法调用对于对象的当前状态无效时引发的异常。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果调用方法失败是由除无效参数以外的其他原因导致的，则使用 <xref:System.InvalidOperationException>。 通常，当对象的状态不支持方法调用时，将引发此异常。 例如，方法会引发 <xref:System.InvalidOperationException> 异常，如下所示：  
  
-   <xref:System.Collections.IEnumerator.MoveNext%2A?displayProperty=nameWithType> 如果在创建枚举器后修改集合的对象，则为。 有关详细信息，请参阅[循环访问集合](#Iterating)。  
  
-   如果在执行方法调用前关闭资源集，则 <xref:System.Resources.ResourceSet.GetString%2A?displayProperty=nameWithType>。  
  
-   <xref:System.Xml.Linq.XContainer.Add%2A?displayProperty=nameWithType>，如果要添加的对象将导致结构不正确的 XML 文档，则为。  
  
-   尝试从非主线程或 UI 线程的线程操作 UI 的方法。  
  
> [!IMPORTANT]
>  由于在各种情况下都可能引发 <xref:System.InvalidOperationException> 异常，因此请务必阅读 <xref:System.Exception.Message%2A> 属性返回的异常消息。  
  
 本节内容：  
  
 [InvalidOperationException 异常的一些常见原因](#Causes)   
 [从非 UI 线程更新 UI 线程](#UI)  
 [在循环访问集合时更改集合](#Iterating)  
 [对其对象无法进行比较的数组或集合进行排序](#Sorting)  
 将为[null 的可为 null&lt;t&gt; 转换为其基础类型](#Nullable)   
 [对空集合调用 system.exception 方法](#Empty)  
 [对没有一个元素的序列调用 SingleOrDefault 或可枚举的。](#Single)  
 [动态跨应用程序域字段访问](#Emit)  
[引发 InvalidOperationException 异常](#Throwing)  
[杂项信息](#Misc)  
  
<a name="Causes"></a>   
## <a name="some-common-causes-of-invalidoperationexception-exceptions"></a>InvalidOperationException 异常的一些常见原因  
 以下各节说明了在应用程序中引发 <xref:System.InvalidOperationException> 异常的一些常见情况。 处理问题的方式取决于具体情况。 但最常见的情况是，开发人员出现错误，并且可以预见和避免 <xref:System.InvalidOperationException> 异常。  
  
<a name="UI"></a>   
### <a name="updating-a-ui-thread-from-a-non-ui-thread"></a>从非 UI 线程更新 UI 线程  
 通常，工作线程用于执行一些后台工作，其中涉及收集要在应用程序的用户界面中显示的数据。 但是， 大多数 .NET Framework 的 GUI （图形用户界面）应用程序框架（如 Windows 窗体和 Windows Presentation Foundation （WPF））只允许从创建和管理 UI 的线程（主线程或 UI 线程）访问 GUI 对象。 尝试从 UI 线程之外的其他线程访问 UI 元素时，将引发 <xref:System.InvalidOperationException>。  下表显示了异常消息的文本。  
  
|“应用程序类型”|Message|  
|----------------------|-------------|  
|WPF 应用|**调用线程无法访问此对象，因为另一个线程拥有该对象。**|  
|UWP 应用|**应用程序调用了为另一个线程封送的接口。**|  
|Windows 窗体应用|**跨线程操作无效：从不是在其上创建它的线程访问控件 "TextBox1"。**|  
  
 .NET Framework 的 UI 框架实现了一个*调度*程序模式，该模式包括一个方法，用于检查 ui 线程上是否正在执行对 ui 线程成员的调用，以及用于计划对 ui 线程的调用的其他方法：  
  
-   在 WPF 应用程序中，调用 <xref:System.Windows.Threading.Dispatcher.CheckAccess%2A?displayProperty=nameWithType> 方法来确定某个方法是否正在非 UI 线程上运行。 如果方法在 UI 线程上运行 `false`，则它将返回 `true`; 否则返回。 调用 <xref:System.Windows.Threading.Dispatcher.Invoke%2A?displayProperty=nameWithType> 方法的重载之一来计划对 UI 线程的调用。  
  
-   在 UWP 应用中，检查 <xref:Windows.UI.Core.CoreDispatcher.HasThreadAccess?displayProperty=nameWithType> 属性以确定某个方法是否正在非 UI 线程上运行。 调用 <xref:Windows.UI.Core.CoreDispatcher.RunAsync%2A?displayProperty=nameWithType> 方法，以执行可更新 UI 线程的委托。 
  
-   在 Windows 窗体应用中，使用 <xref:System.Windows.Forms.Control.InvokeRequired%2A?displayProperty=nameWithType> 属性来确定某个方法是否正在非 UI 线程上运行。 调用 <xref:System.Windows.Forms.Control.Invoke%2A?displayProperty=nameWithType> 方法的重载之一来执行更新 UI 线程的委托。  
  
 下面的示例演示当你尝试从创建它的线程以外的线程更新 UI 元素时引发的 <xref:System.InvalidOperationException> 异常。  每个示例都需要创建两个控件：  
  
-   名为 `textBox1`的文本框控件。  在 Windows 窗体应用程序中，应将其 <xref:System.Windows.Forms.TextBox.Multiline%2A> 属性设置为 "`true`"。  
  
-   名为 `threadExampleBtn`的按钮控件。 该示例为按钮的 `Click` 事件提供处理程序 `ThreadsExampleBtn_Click`。  
  
 在每种情况下，`threadExampleBtn_Click` 事件处理程序都会两次调用 `DoSomeWork` 方法。 第一个调用同步运行并成功运行。 但第二次调用时，由于它在线程池线程上以异步方式运行，因此尝试从非 UI 线程更新 UI。 这会导致 <xref:System.InvalidOperationException> 异常。  
  
 WPF 和 UWP 应用  
 [!code-csharp[System.InvalidOperationException.Threading.WPF1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Invalidoperationexception.threading.wpf1/cs/MainWindow.xaml.cs#1)]
 [!code-vb[System.InvalidOperationException.Threading.WPF1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Invalidoperationexception.threading.wpf1/vb/MainWindow.xaml.vb#1)]  
  
 以下版本的 `DoSomeWork` 方法可消除 WPF 应用程序中的异常。  
  
 [!code-csharp[System.InvalidOperationException.Threading.WPF2#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Invalidoperationexception.threading.wpf2/cs/MainWindowDispatcher.xaml.cs#3)]
 [!code-vb[System.InvalidOperationException.Threading.WPF2#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Invalidoperationexception.threading.wpf2/vb/MainWindowDispatcher.xaml.vb#3)]  
  
 以下版本的 `DoSomeWork` 方法可消除 UWP 应用中的异常。  
  
 [!code-csharp[System.InvalidOperationException.Threading.UWP#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.invalidoperationexception.threading.uwp/cs/MainPage.xaml.cs#4)]
 [!code-vb[System.InvalidOperationException.Threading.UWP#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.invalidoperationexception.threading.uwp/vb/MainPage.xaml.vb#4)]  
  
 Windows 窗体应用  
 [!code-csharp[System.InvalidOperationException.Threading.WF#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Invalidoperationexception.threading.wf/cs/Form1.cs#2)]
 [!code-vb[System.InvalidOperationException.Threading.WF#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Invalidoperationexception.threading.wf/vb/Form1.vb#2)]  
  
 以下版本的 `DoSomeWork` 方法消除了 Windows 窗体应用中的异常。  
  
 [!code-csharp[System.InvalidOperationException.Threading.WF2#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Invalidoperationexception.threading.wf2/cs/Form1.cs#5)]
 [!code-vb[System.InvalidOperationException.Threading.WF2#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Invalidoperationexception.threading.wf2/vb/Form1.vb#5)]  
  
<a name="Iterating"></a>   
### <a name="changing-a-collection-while-iterating-it"></a>在循环访问集合时更改集合  
 Visual Basic 中的C#或 `For Each` 语句中的 `foreach` 语句用于循环访问集合的成员，并读取或修改其各个元素。 但是，它不能用于添加或删除集合中的项。 这样做会引发 <xref:System.InvalidOperationException> 异常，其中包含类似于 "**集合已修改;枚举操作可能无法执行。**"  
  
 下面的示例循环访问整数的集合，尝试将每个整数的平方添加到集合中。 该示例使用第一次调用 <xref:System.Collections.Generic.List%601.Add%2A?displayProperty=nameWithType> 方法引发 <xref:System.InvalidOperationException>。  
  
 [!code-csharp[System.InvalidOperationException#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.invalidoperationexception/cs/Iterating1.cs#1)]
 [!code-vb[System.InvalidOperationException#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.invalidoperationexception/vb/Iterating1.vb#1)]  
  
 可以通过以下两种方式之一消除异常：具体取决于应用程序逻辑：  
  
-   如果在循环访问时必须将元素添加到集合中，则可以使用 `for` 语句而不是 `foreach` 或 `For Each`按索引对其进行循环访问。 下面的示例使用 for 语句将集合中的数字的平方添加到集合中。  
  
     [!code-csharp[System.InvalidOperationException#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.invalidoperationexception/cs/Iterating2.cs#2)]
     [!code-vb[System.InvalidOperationException#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.invalidoperationexception/vb/Iterating2.vb#2)]  
  
     请注意，在循环访问集合之前，必须先建立迭代数，方法是使用循环中的计数器，该循环会将数组中的元素数分配给一个变量，并通过 `Count` 将数组中的元素数赋给一个变量，并使用它来确定循环的上限。 否则，如果在每次迭代时向集合中添加了一个元素，则会导致无限循环。  
  
-   如果在循环访问集合时不需要向集合添加元素，则可以存储要添加到临时集合中的元素，在循环访问完成后添加这些元素。  下面的示例使用此方法将集合中的数字的平方添加到临时集合，然后将这些集合合并为单个数组对象。  
  
     [!code-csharp[System.InvalidOperationException#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.invalidoperationexception/cs/Iterating3.cs#3)]
     [!code-vb[System.InvalidOperationException#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.invalidoperationexception/vb/Iterating3.vb#3)]  
  
<a name="Sorting"></a>   
### <a name="sorting-an-array-or-collection-whose-objects-cannot-be-compared"></a>对其对象无法进行比较的数组或集合进行排序  
 一般用途的排序方法（如 <xref:System.Array.Sort%28System.Array%29?displayProperty=nameWithType> 方法或 <xref:System.Collections.Generic.List%601.Sort?displayProperty=nameWithType> 方法）通常要求至少一个要排序的对象实现 <xref:System.IComparable%601> 或 <xref:System.IComparable> 接口。 如果不是，则不能对集合或数组进行排序，并且方法会引发 <xref:System.InvalidOperationException> 异常。 下面的示例定义一个 `Person` 类，将两个 `Person` 对象存储在一个泛型 <xref:System.Collections.Generic.List%601> 对象中，并尝试对它们进行排序。 如示例的输出所示，对 <xref:System.Collections.Generic.List%601.Sort?displayProperty=nameWithType> 方法的调用将引发 <xref:System.InvalidOperationException>。  
  
 [!code-csharp[System.InvalidOperationException#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.invalidoperationexception/cs/List_Sort1.cs#12)]
 [!code-vb[System.InvalidOperationException#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.invalidoperationexception/vb/List_Sort1.vb#12)]  
  
 可以通过以下三种方式之一消除异常：  
  
-   如果可以拥有要进行排序的类型（即，如果控制其源代码），则可以修改它以实现 <xref:System.IComparable%601> 或 <xref:System.IComparable> 接口。 这要求你实现 <xref:System.IComparable%601.CompareTo%2A?displayProperty=nameWithType> 或 <xref:System.IComparable.CompareTo%2A> 方法。 将接口实现添加到现有类型不是一项重大更改。  
  
     下面的示例使用此方法为 `Person` 类提供 <xref:System.IComparable%601> 实现。 你仍可以调用集合或数组的常规排序方法，如示例中的输出所示，该集合将成功排序。  
  
     [!code-csharp[System.InvalidOperationException#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.invalidoperationexception/cs/List_Sort2.cs#13)]
     [!code-vb[System.InvalidOperationException#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.invalidoperationexception/vb/List_Sort2.vb#13)]  
  
-   如果您无法修改您尝试进行排序的类型的源代码，则可以定义一个实现 <xref:System.Collections.Generic.IComparer%601> 接口的特殊用途的排序类。  可以调用 `Sort` 方法的重载，该重载包含一个 <xref:System.Collections.Generic.IComparer%601> 参数。 如果要开发可基于多个条件对对象进行排序的专用排序类，则此方法特别有用。  
  
     下面的示例通过开发用于对 `Person` 集合进行排序的自定义 `PersonComparer` 类来使用方法。  然后，它将此类的一个实例传递给 <xref:System.Collections.Generic.List%601.Sort%28System.Collections.Generic.IComparer%7B%600%7D%29?displayProperty=nameWithType> 方法。  
  
     [!code-csharp[System.InvalidOperationException#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.invalidoperationexception/cs/List_Sort3.cs#14)]
     [!code-vb[System.InvalidOperationException#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.invalidoperationexception/vb/List_Sort3.vb#14)]  
  
-   如果您无法修改您尝试排序的类型的源代码，则可以创建一个 <xref:System.Comparison%601> 委托来执行排序。 委托签名为  
  
    ```vb  
    Function Comparison(Of T)(x As T, y As T) As Integer  
    ```  
  
    ```csharp  
    int Comparison<T>(T x, T y)  
    ```  
  
     下面的示例通过定义与 <xref:System.Comparison%601> 委托签名匹配的 `PersonComparison` 方法来使用方法。  然后，它将此委托传递给 <xref:System.Collections.Generic.List%601.Sort%28System.Comparison%7B%600%7D%29?displayProperty=nameWithType> 方法。  
  
     [!code-csharp[System.InvalidOperationException#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.invalidoperationexception/cs/List_Sort4.cs#15)]
     [!code-vb[System.InvalidOperationException#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.invalidoperationexception/vb/List_Sort4.vb#15)]  
  
<a name="Nullable"></a>   
### <a name="casting-a-nullablet-that-is-null-to-its-underlying-type"></a>将为空的可以为 null 的\<T > 转换为其基础类型  
 尝试将 `null` 的 <xref:System.Nullable%601> 值强制转换为其基础类型会引发 <xref:System.InvalidOperationException> 异常，并显示错误消息 "**可以为 null 的对象必须具有值。**  
  
 下面的示例在尝试循环访问包含 `Nullable(Of Integer)` 值的数组时引发 <xref:System.InvalidOperationException> 异常。  
  
 [!code-csharp[System.InvalidOperationException#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.invalidoperationexception/cs/Nullable1.cs#4)]
 [!code-vb[System.InvalidOperationException#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.invalidoperationexception/vb/Nullable1.vb#4)]  
  
 若要防止发生此异常：  
  
-   使用 <xref:System.Nullable%601.HasValue%2A?displayProperty=nameWithType> 属性仅选择那些不 `null`的元素。  
  
-   调用 <xref:System.Nullable%601.GetValueOrDefault%2A?displayProperty=nameWithType> 重载之一，为 `null` 值提供默认值。  
  
 下面的示例执行此两个方法以避免 <xref:System.InvalidOperationException> 异常。  
  
 [!code-csharp[System.InvalidOperationException#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.invalidoperationexception/cs/Nullable2.cs#5)]
 [!code-vb[System.InvalidOperationException#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.invalidoperationexception/vb/Nullable2.vb#5)]  
  
<a name="Empty"></a>   
### <a name="calling-a-systemlinqenumerable-method-on-an-empty-collection"></a>对空集合调用 system.exception 方法  
 <xref:System.Linq.Enumerable.Aggregate%2A?displayProperty=nameWithType>、<xref:System.Linq.Enumerable.Average%2A?displayProperty=nameWithType>、<xref:System.Linq.Enumerable.First%2A?displayProperty=nameWithType>、<xref:System.Linq.Enumerable.Last%2A?displayProperty=nameWithType>、<xref:System.Linq.Enumerable.Max%2A?displayProperty=nameWithType>、<xref:System.Linq.Enumerable.Min%2A?displayProperty=nameWithType>、<xref:System.Linq.Enumerable.Single%2A?displayProperty=nameWithType>和 <xref:System.Linq.Enumerable.SingleOrDefault%2A?displayProperty=nameWithType> 方法对序列执行操作并返回单个结果。   当序列为空时，这些方法的某些重载会引发 <xref:System.InvalidOperationException> 异常，而其他重载返回 `null`。 当序列包含多个元素时，<xref:System.Linq.Enumerable.SingleOrDefault%2A?displayProperty=nameWithType> 方法还会引发 <xref:System.InvalidOperationException> 异常。  
  
> [!NOTE]
>  引发 <xref:System.InvalidOperationException> 异常的大多数方法都是重载。 请确保了解所选重载的行为。  
  
 下表列出了由对某些 <xref:System.Linq.Enumerable?displayProperty=nameWithType> 方法的调用引发的 <xref:System.InvalidOperationException> 异常对象的异常消息。  
  
|方法|Message|  
|------------|-------------|  
|`Aggregate` <br /> `Average` <br /> `Last` <br /> `Max` <br /> `Min`|**序列不包含任何元素**|  
|`First`|**序列不包含任何匹配元素**|  
|`Single` <br /> `SingleOrDefault`|**序列包含一个以上的匹配元素**|  
  
 消除或处理异常的方式取决于应用程序的假设和所调用的特定方法。  
  
-   如果在不检查空序列的情况下有意调用这些方法之一，则假设序列不为空，且空序列是意外的匹配项。 在这种情况下，会适当捕获或重新引发异常。  
  
-   如果无法检查是否有空序列，则可以调用 <xref:System.Linq.Enumerable.Any%2A?displayProperty=nameWithType> 重载的重载之一来确定序列是否包含任何元素。  
  
    > [!TIP]
    >  如果要处理的数据可能包含大量元素或生成序列的操作非常昂贵，则在生成序列之前调用 <xref:System.Linq.Enumerable.Any%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Boolean%7D%29?displayProperty=nameWithType> 方法可以提高性能。  
  
-   如果已调用方法，如 <xref:System.Linq.Enumerable.First%2A?displayProperty=nameWithType>、<xref:System.Linq.Enumerable.Last%2A?displayProperty=nameWithType>或 <xref:System.Linq.Enumerable.Single%2A?displayProperty=nameWithType>，则可以用返回默认值而不是序列成员的其他方法（如 <xref:System.Linq.Enumerable.FirstOrDefault%2A?displayProperty=nameWithType>、<xref:System.Linq.Enumerable.LastOrDefault%2A?displayProperty=nameWithType>或 <xref:System.Linq.Enumerable.SingleOrDefault%2A?displayProperty=nameWithType>）来替换。  
  
 这些示例提供更多详细信息。  
  
 下面的示例使用 <xref:System.Linq.Enumerable.Average%2A?displayProperty=nameWithType> 方法计算其值大于4的序列的平均值。 由于原始数组中没有值超过4，因此序列中不包含任何值，并且方法引发 <xref:System.InvalidOperationException> 异常。  
  
 [!code-csharp[System.InvalidOperationException#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.invalidoperationexception/cs/Enumerable1.cs#6)]
 [!code-vb[System.InvalidOperationException#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.invalidoperationexception/vb/Enumerable1.vb#6)]  
  
 在调用处理序列的方法之前，可以通过调用 <xref:System.Linq.Enumerable.Any%2A> 方法来确定序列是否包含任何元素，从而消除此异常，如下面的示例所示。  
  
 [!code-csharp[System.InvalidOperationException#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.invalidoperationexception/cs/Enumerable2.cs#7)]
 [!code-vb[System.InvalidOperationException#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.invalidoperationexception/vb/Enumerable2.vb#7)]  
  
 <xref:System.Linq.Enumerable.First%2A?displayProperty=nameWithType> 方法返回序列中的第一项，或序列中满足指定条件的第一个元素。 如果序列为空，因此不包含第一个元素，则会引发 <xref:System.InvalidOperationException> 异常。  
  
 在下面的示例中，<xref:System.Linq.Enumerable.First%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Boolean%7D%29?displayProperty=nameWithType> 方法引发 <xref:System.InvalidOperationException> 异常，因为 dbQueryResults 数组不包含大于4的元素。  
  
 [!code-csharp[System.InvalidOperationException#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.invalidoperationexception/cs/Enumerable3.cs#8)]
 [!code-vb[System.InvalidOperationException#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.invalidoperationexception/vb/Enumerable3.vb#8)]  
  
 可以调用 <xref:System.Linq.Enumerable.FirstOrDefault%2A?displayProperty=nameWithType> 方法，而不是 <xref:System.Linq.Enumerable.First%2A?displayProperty=nameWithType> 来返回指定值或默认值。 如果该方法未在序列中找到第一个元素，则它将返回该数据类型的默认值。  对于引用类型，默认值为 `null`; 对于数值数据类型，默认值为零，<xref:System.DateTime> 类型为 <xref:System.DateTime.MinValue?displayProperty=nameWithType>。  
  
> [!NOTE]
>  解释 <xref:System.Linq.Enumerable.FirstOrDefault%2A?displayProperty=nameWithType> 方法返回的值通常是很复杂的，因为该类型的默认值可以是序列中的有效值。 在这种情况下，调用 <xref:System.Linq.Enumerable.Any%2A?displayProperty=nameWithType> 方法，以确定序列在调用 <xref:System.Linq.Enumerable.First%2A?displayProperty=nameWithType> 方法之前是否具有有效的成员。  
  
 下面的示例调用 <xref:System.Linq.Enumerable.FirstOrDefault%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Boolean%7D%29?displayProperty=nameWithType> 方法，以防止在前面的示例中引发的 <xref:System.InvalidOperationException> 异常。  
  
 [!code-csharp[System.InvalidOperationException#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.invalidoperationexception/cs/Enumerable4.cs#9)]
 [!code-vb[System.InvalidOperationException#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.invalidoperationexception/vb/Enumerable4.vb#9)]  
  
<a name="Single"></a>   
### <a name="calling-enumerablesingle-or-enumerablesingleordefault-on-a-sequence-without-one-element"></a>对没有一个元素的序列调用 SingleOrDefault 或可枚举的。  
 <xref:System.Linq.Enumerable.Single%2A?displayProperty=nameWithType> 方法返回序列中的唯一元素，或序列中满足指定条件的唯一元素。    如果序列中没有元素，或者如果有多个元素，此方法将引发 <xref:System.InvalidOperationException> 异常。  
  
 如果序列不包含任何元素，则可以使用 <xref:System.Linq.Enumerable.SingleOrDefault%2A?displayProperty=nameWithType> 方法返回默认值，而不是引发异常。 但是，当序列包含多个元素时，<xref:System.Linq.Enumerable.SingleOrDefault%2A?displayProperty=nameWithType> 方法仍会引发 <xref:System.InvalidOperationException> 异常。  
  
 下表列出了由对 <xref:System.Linq.Enumerable.Single%2A?displayProperty=nameWithType> 和 <xref:System.Linq.Enumerable.SingleOrDefault%2A?displayProperty=nameWithType> 方法的调用引发的 <xref:System.InvalidOperationException> 异常对象的异常消息。  
  
|方法|Message|  
|------------|-------------|  
|`Single`|**序列不包含任何匹配元素**|  
|`Single` <br /> `SingleOrDefault`|**序列包含一个以上的匹配元素**|  
  
 在下面的示例中，对 <xref:System.Linq.Enumerable.Single%2A?displayProperty=nameWithType> 方法的调用将引发 <xref:System.InvalidOperationException> 异常，因为序列没有大于4的元素。  
  
 [!code-csharp[System.InvalidOperationException#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.invalidoperationexception/cs/Enumerable5.cs#10)]
 [!code-vb[System.InvalidOperationException#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.invalidoperationexception/vb/Enumerable5.vb#10)]  
  
 下面的示例尝试通过调用 <xref:System.Linq.Enumerable.SingleOrDefault%2A?displayProperty=nameWithType> 方法来防止序列为空时引发 <xref:System.InvalidOperationException> 异常。 但是，因为此序列返回多个值大于2的元素，所以它还会引发 <xref:System.InvalidOperationException> 异常。  
  
 [!code-csharp[System.InvalidOperationException#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.invalidoperationexception/cs/Enumerable6.cs#11)]
 [!code-vb[System.InvalidOperationException#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.invalidoperationexception/vb/Enumerable6.vb#11)]  
  
 调用 <xref:System.Linq.Enumerable.Single%2A?displayProperty=nameWithType> 方法假设序列或满足指定条件的序列只包含一个元素。  <xref:System.Linq.Enumerable.SingleOrDefault%2A?displayProperty=nameWithType> 假设序列中包含零个或一个结果，但没有其他结果。 如果此假设在您的部分中是有意的，则不满足这些条件，重新引发或捕获产生的 <xref:System.InvalidOperationException> 是合适的。 否则，或者，如果你希望在某些频率下发生无效的条件，则应考虑使用其他 <xref:System.Linq.Enumerable> 方法，如 <xref:System.Linq.Enumerable.FirstOrDefault%2A> 或 <xref:System.Linq.Enumerable.Where%2A>。  
  
<a name="Emit"></a>   
### <a name="dynamic-cross-application-domain-field-access"></a>动态跨应用程序域字段访问  
 如果包含您尝试检索其地址的字段所在的对象不在执行您的代码的应用程序域中，则 <xref:System.Reflection.Emit.OpCodes.Ldflda?displayProperty=nameWithType> Microsoft 中间语言（MSIL）指令引发 <xref:System.InvalidOperationException> 异常。 字段的地址只能从它所在的应用程序域进行访问。  
  
<a name="Throwing"></a>   
## <a name="throwing-an-invalidoperationexception-exception"></a>引发 InvalidOperationException 异常  
 仅当对象的状态出于某种原因不支持特定方法调用时，才应引发 <xref:System.InvalidOperationException> 异常。 也就是说，方法调用在某些环境或上下文中有效，但在其他情况下无效。  
  
 如果方法调用失败是由于参数无效，则应改为引发 <xref:System.ArgumentException> 或其派生类之一（<xref:System.ArgumentNullException> 或 <xref:System.ArgumentOutOfRangeException>）。  
  
<a name="Misc"></a>   
## <a name="miscellaneous-information"></a>杂项信息  
 <xref:System.InvalidOperationException> 使用值为0x80131509 的 HRESULT COR_E_INVALIDOPERATION。  
  
 有关实例的初始属性值的列表<xref:System.InvalidOperationException>，请参阅<xref:System.InvalidOperationException.%23ctor%2A>构造函数。  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Exception" />
    <altmember cref="T:System.Collections.IEnumerator" />
    <altmember cref="T:System.Resources.ResourceSet" />
    <related type="Article" href="/dotnet/standard/exceptions/">处理和引发异常</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>初始化 <see cref="T:System.InvalidOperationException" /> 类的新实例。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public InvalidOperationException ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.InvalidOperationException.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; InvalidOperationException();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>初始化 <see cref="T:System.InvalidOperationException" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此构造函数将新实例的 <xref:System.Exception.Message%2A> 属性初始化为系统提供的描述错误的消息，例如 "无法执行请求的操作"。 此消息会考虑当前系统区域性。  
  
 下表显示了 <xref:System.InvalidOperationException> 实例的初始属性值。  
  
|属性|值|  
|--------------|-----------|  
|<xref:System.Exception.InnerException%2A>|空引用（在 Visual Basic 中为 `Nothing`）。|  
|<xref:System.Exception.Message%2A>|本地化的错误消息字符串。|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public InvalidOperationException (string message);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string message) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.InvalidOperationException.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (message As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; InvalidOperationException(System::String ^ message);" />
      <MemberSignature Language="F#" Value="new InvalidOperationException : string -&gt; InvalidOperationException" Usage="new System.InvalidOperationException message" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="message">用于描述错误的消息。</param>
        <summary>用指定的错误消息初始化 <see cref="T:System.InvalidOperationException" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此构造函数使用 `message` 参数初始化新异常的 <xref:System.Exception.Message%2A?displayProperty=nameWithType> 属性。 `message` 的内容设计为易于理解。 此构造函数的调用方需要确保此字符串已针对当前系统区域性进行了本地化。  
  
 下表显示了 <xref:System.InvalidOperationException> 实例的初始属性值。  
  
|属性|值|  
|--------------|-----------|  
|<xref:System.Exception.InnerException%2A>|空引用（在 Visual Basic 中为 `Nothing`）。|  
|<xref:System.Exception.Message%2A>|错误消息字符串。|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected InvalidOperationException (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.InvalidOperationException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; InvalidOperationException(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="new InvalidOperationException : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; InvalidOperationException" Usage="new System.InvalidOperationException (info, context)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="info">包含序列化对象数据的对象。</param>
        <param name="context">与源或目标有关的上下文信息。</param>
        <summary>使用序列化数据初始化 <see cref="T:System.InvalidOperationException" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在反序列化期间调用此构造函数以重新构造在流上传输的异常对象。 有关详细信息，请参阅[XML 和 SOAP 序列化](/dotnet/standard/serialization/xml-and-soap-serialization)。  
  
 ]]></format>
        </remarks>
        <related type="Article" href="/dotnet/standard/serialization/xml-and-soap-serialization">XML 和 SOAP 序列化</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public InvalidOperationException (string message, Exception innerException);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string message, class System.Exception innerException) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.InvalidOperationException.#ctor(System.String,System.Exception)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (message As String, innerException As Exception)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; InvalidOperationException(System::String ^ message, Exception ^ innerException);" />
      <MemberSignature Language="F#" Value="new InvalidOperationException : string * Exception -&gt; InvalidOperationException" Usage="new System.InvalidOperationException (message, innerException)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="innerException" Type="System.Exception" />
      </Parameters>
      <Docs>
        <param name="message">用于解释异常原因的错误消息。</param>
        <param name="innerException">引起当前异常的异常。 如果 <paramref name="innerException" /> 参数不是 null 引用（在 Visual Basic 中为 <see langword="Nothing" />），则在处理内部异常的 <see langword="catch" /> 块中引发当前异常。</param>
        <summary>使用指定的错误消息和对作为此异常原因的内部异常的引用来初始化 <see cref="T:System.InvalidOperationException" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 作为前一个异常的直接结果引发的异常应在 <xref:System.Exception.InnerException%2A> 属性中包含对前一个异常的引用。 <xref:System.Exception.InnerException%2A> 属性返回传递到构造函数中的相同值，或者如果 `Nothing` 属性不向构造函数提供内部异常值，则为空引用（在 Visual Basic 中为 <xref:System.Exception.InnerException%2A>）。  
  
 下表显示了 <xref:System.InvalidOperationException> 实例的初始属性值。  
  
|属性|值|  
|--------------|-----------|  
|<xref:System.Exception.InnerException%2A>|内部异常引用。|  
|<xref:System.Exception.Message%2A>|错误消息字符串。|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Exception" />
        <related type="Article" href="/dotnet/standard/exceptions/">处理和引发异常</related>
      </Docs>
    </Member>
  </Members>
</Type>
